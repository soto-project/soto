//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension OpenSearch {
    // MARK: Enums

    public enum ActionSeverity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum ActionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case eligible = "ELIGIBLE"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case notEligible = "NOT_ELIGIBLE"
        case pendingUpdate = "PENDING_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum ActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jvmHeapSizeTuning = "JVM_HEAP_SIZE_TUNING"
        case jvmYoungGenTuning = "JVM_YOUNG_GEN_TUNING"
        case serviceSoftwareUpdate = "SERVICE_SOFTWARE_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum AutoTuneDesiredState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AutoTuneState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case disabled = "DISABLED"
        case disabledAndRollbackComplete = "DISABLED_AND_ROLLBACK_COMPLETE"
        case disabledAndRollbackError = "DISABLED_AND_ROLLBACK_ERROR"
        case disabledAndRollbackInProgress = "DISABLED_AND_ROLLBACK_IN_PROGRESS"
        case disabledAndRollbackScheduled = "DISABLED_AND_ROLLBACK_SCHEDULED"
        case enableInProgress = "ENABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public enum AutoTuneType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case scheduledAction = "SCHEDULED_ACTION"
        public var description: String { return self.rawValue }
    }

    public enum ConfigChangeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case applyingChanges = "ApplyingChanges"
        case cancelled = "Cancelled"
        case completed = "Completed"
        case initializing = "Initializing"
        case pending = "Pending"
        case pendingUserInput = "PendingUserInput"
        case validating = "Validating"
        case validationFailed = "ValidationFailed"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case direct = "DIRECT"
        case vpcEndpoint = "VPC_ENDPOINT"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case eligible = "ELIGIBLE"
        case inProgress = "IN_PROGRESS"
        case notEligible = "NOT_ELIGIBLE"
        case pendingUpdate = "PENDING_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DescribePackagesFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case engineVersion = "EngineVersion"
        case packageID = "PackageID"
        case packageName = "PackageName"
        case packageStatus = "PackageStatus"
        case packageType = "PackageType"
        public var description: String { return self.rawValue }
    }

    public enum DomainHealth: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case green = "Green"
        case notAvailable = "NotAvailable"
        case red = "Red"
        case yellow = "Yellow"
        public var description: String { return self.rawValue }
    }

    public enum DomainPackageStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case associating = "ASSOCIATING"
        case associationFailed = "ASSOCIATION_FAILED"
        case dissociating = "DISSOCIATING"
        case dissociationFailed = "DISSOCIATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum DomainProcessingStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case creating = "Creating"
        case deleting = "Deleting"
        case isolated = "Isolated"
        case modifying = "Modifying"
        case updating = "UpdatingServiceSoftware"
        case upgrading = "UpgradingEngineVersion"
        public var description: String { return self.rawValue }
    }

    public enum DomainState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case notAvailable = "NotAvailable"
        case processing = "Processing"
        public var description: String { return self.rawValue }
    }

    public enum DryRunMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case basic = "Basic"
        case verbose = "Verbose"
        public var description: String { return self.rawValue }
    }

    public enum EngineType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case elasticsearch = "Elasticsearch"
        case openSearch = "OpenSearch"
        public var description: String { return self.rawValue }
    }

    public enum IPAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dualstack = "dualstack"
        case ipv4 = "ipv4"
        public var description: String { return self.rawValue }
    }

    public enum InboundConnectionStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case approved = "APPROVED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pendingAcceptance = "PENDING_ACCEPTANCE"
        case provisioning = "PROVISIONING"
        case rejected = "REJECTED"
        case rejecting = "REJECTING"
        public var description: String { return self.rawValue }
    }

    public enum InitiatedBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customer = "CUSTOMER"
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auditLogs = "AUDIT_LOGS"
        case esApplicationLogs = "ES_APPLICATION_LOGS"
        case indexSlowLogs = "INDEX_SLOW_LOGS"
        case searchSlowLogs = "SEARCH_SLOW_LOGS"
        public var description: String { return self.rawValue }
    }

    public enum MaintenanceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum MaintenanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rebootNode = "REBOOT_NODE"
        case restartDashboard = "RESTART_DASHBOARD"
        case restartSearchProcess = "RESTART_SEARCH_PROCESS"
        public var description: String { return self.rawValue }
    }

    public enum MasterNodeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "Available"
        case unAvailable = "UnAvailable"
        public var description: String { return self.rawValue }
    }

    public enum NodeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case notAvailable = "NotAvailable"
        case standBy = "StandBy"
        public var description: String { return self.rawValue }
    }

    public enum NodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case data = "Data"
        case master = "Master"
        case ultrawarm = "Ultrawarm"
        public var description: String { return self.rawValue }
    }

    public enum OpenSearchPartitionInstanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case c42XlargeSearch = "c4.2xlarge.search"
        case c44XlargeSearch = "c4.4xlarge.search"
        case c48XlargeSearch = "c4.8xlarge.search"
        case c4LargeSearch = "c4.large.search"
        case c4XlargeSearch = "c4.xlarge.search"
        case c518XlargeSearch = "c5.18xlarge.search"
        case c52XlargeSearch = "c5.2xlarge.search"
        case c54XlargeSearch = "c5.4xlarge.search"
        case c59XlargeSearch = "c5.9xlarge.search"
        case c5LargeSearch = "c5.large.search"
        case c5XlargeSearch = "c5.xlarge.search"
        case c6g12XlargeSearch = "c6g.12xlarge.search"
        case c6g2XlargeSearch = "c6g.2xlarge.search"
        case c6g4XlargeSearch = "c6g.4xlarge.search"
        case c6g8XlargeSearch = "c6g.8xlarge.search"
        case c6gLargeSearch = "c6g.large.search"
        case c6gXlargeSearch = "c6g.xlarge.search"
        case d22XlargeSearch = "d2.2xlarge.search"
        case d24XlargeSearch = "d2.4xlarge.search"
        case d28XlargeSearch = "d2.8xlarge.search"
        case d2XlargeSearch = "d2.xlarge.search"
        case i22XlargeSearch = "i2.2xlarge.search"
        case i2XlargeSearch = "i2.xlarge.search"
        case i316XlargeSearch = "i3.16xlarge.search"
        case i32XlargeSearch = "i3.2xlarge.search"
        case i34XlargeSearch = "i3.4xlarge.search"
        case i38XlargeSearch = "i3.8xlarge.search"
        case i3LargeSearch = "i3.large.search"
        case i3XlargeSearch = "i3.xlarge.search"
        case m32XlargeSearch = "m3.2xlarge.search"
        case m3LargeSearch = "m3.large.search"
        case m3MediumSearch = "m3.medium.search"
        case m3XlargeSearch = "m3.xlarge.search"
        case m410XlargeSearch = "m4.10xlarge.search"
        case m42XlargeSearch = "m4.2xlarge.search"
        case m44XlargeSearch = "m4.4xlarge.search"
        case m4LargeSearch = "m4.large.search"
        case m4XlargeSearch = "m4.xlarge.search"
        case m512XlargeSearch = "m5.12xlarge.search"
        case m524XlargeSearch = "m5.24xlarge.search"
        case m52XlargeSearch = "m5.2xlarge.search"
        case m54XlargeSearch = "m5.4xlarge.search"
        case m5LargeSearch = "m5.large.search"
        case m5XlargeSearch = "m5.xlarge.search"
        case m6g12XlargeSearch = "m6g.12xlarge.search"
        case m6g2XlargeSearch = "m6g.2xlarge.search"
        case m6g4XlargeSearch = "m6g.4xlarge.search"
        case m6g8XlargeSearch = "m6g.8xlarge.search"
        case m6gLargeSearch = "m6g.large.search"
        case m6gXlargeSearch = "m6g.xlarge.search"
        case or112XlargeSearch = "or1.12xlarge.search"
        case or116XlargeSearch = "or1.16xlarge.search"
        case or12XlargeSearch = "or1.2xlarge.search"
        case or14XlargeSearch = "or1.4xlarge.search"
        case or18XlargeSearch = "or1.8xlarge.search"
        case or1LargeSearch = "or1.large.search"
        case or1MediumSearch = "or1.medium.search"
        case or1XlargeSearch = "or1.xlarge.search"
        case r32XlargeSearch = "r3.2xlarge.search"
        case r34XlargeSearch = "r3.4xlarge.search"
        case r38XlargeSearch = "r3.8xlarge.search"
        case r3LargeSearch = "r3.large.search"
        case r3XlargeSearch = "r3.xlarge.search"
        case r416XlargeSearch = "r4.16xlarge.search"
        case r42XlargeSearch = "r4.2xlarge.search"
        case r44XlargeSearch = "r4.4xlarge.search"
        case r48XlargeSearch = "r4.8xlarge.search"
        case r4LargeSearch = "r4.large.search"
        case r4XlargeSearch = "r4.xlarge.search"
        case r512XlargeSearch = "r5.12xlarge.search"
        case r524XlargeSearch = "r5.24xlarge.search"
        case r52XlargeSearch = "r5.2xlarge.search"
        case r54XlargeSearch = "r5.4xlarge.search"
        case r5LargeSearch = "r5.large.search"
        case r5XlargeSearch = "r5.xlarge.search"
        case r6g12XlargeSearch = "r6g.12xlarge.search"
        case r6g2XlargeSearch = "r6g.2xlarge.search"
        case r6g4XlargeSearch = "r6g.4xlarge.search"
        case r6g8XlargeSearch = "r6g.8xlarge.search"
        case r6gLargeSearch = "r6g.large.search"
        case r6gXlargeSearch = "r6g.xlarge.search"
        case r6gd12XlargeSearch = "r6gd.12xlarge.search"
        case r6gd16XlargeSearch = "r6gd.16xlarge.search"
        case r6gd2XlargeSearch = "r6gd.2xlarge.search"
        case r6gd4XlargeSearch = "r6gd.4xlarge.search"
        case r6gd8XlargeSearch = "r6gd.8xlarge.search"
        case r6gdLargeSearch = "r6gd.large.search"
        case r6gdXlargeSearch = "r6gd.xlarge.search"
        case t2MediumSearch = "t2.medium.search"
        case t2MicroSearch = "t2.micro.search"
        case t2SmallSearch = "t2.small.search"
        case t32XlargeSearch = "t3.2xlarge.search"
        case t3LargeSearch = "t3.large.search"
        case t3MediumSearch = "t3.medium.search"
        case t3MicroSearch = "t3.micro.search"
        case t3NanoSearch = "t3.nano.search"
        case t3SmallSearch = "t3.small.search"
        case t3XlargeSearch = "t3.xlarge.search"
        case t4gMediumSearch = "t4g.medium.search"
        case t4gSmallSearch = "t4g.small.search"
        case ultrawarm1LargeSearch = "ultrawarm1.large.search"
        case ultrawarm1MediumSearch = "ultrawarm1.medium.search"
        case ultrawarm1XlargeSearch = "ultrawarm1.xlarge.search"
        public var description: String { return self.rawValue }
    }

    public enum OpenSearchWarmPartitionInstanceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ultrawarm1LargeSearch = "ultrawarm1.large.search"
        case ultrawarm1MediumSearch = "ultrawarm1.medium.search"
        case ultrawarm1XlargeSearch = "ultrawarm1.xlarge.search"
        public var description: String { return self.rawValue }
    }

    public enum OptionState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case processing = "Processing"
        case requiresIndexDocuments = "RequiresIndexDocuments"
        public var description: String { return self.rawValue }
    }

    public enum OutboundConnectionStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case approved = "APPROVED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pendingAcceptance = "PENDING_ACCEPTANCE"
        case provisioning = "PROVISIONING"
        case rejected = "REJECTED"
        case rejecting = "REJECTING"
        case validating = "VALIDATING"
        case validationFailed = "VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum OverallChangeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case pending = "PENDING"
        case processing = "PROCESSING"
        public var description: String { return self.rawValue }
    }

    public enum PackageStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case copyFailed = "COPY_FAILED"
        case copying = "COPYING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case validating = "VALIDATING"
        case validationFailed = "VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum PackageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case txtDictionary = "TXT-DICTIONARY"
        case zipPlugin = "ZIP-PLUGIN"
        public var description: String { return self.rawValue }
    }

    public enum PrincipalType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsAccount = "AWS_ACCOUNT"
        case awsService = "AWS_SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum PropertyValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plainText = "PLAIN_TEXT"
        case stringifiedJson = "STRINGIFIED_JSON"
        public var description: String { return self.rawValue }
    }

    public enum ReservedInstancePaymentOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allUpfront = "ALL_UPFRONT"
        case noUpfront = "NO_UPFRONT"
        case partialUpfront = "PARTIAL_UPFRONT"
        public var description: String { return self.rawValue }
    }

    public enum RollbackOnDisable: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case defaultRollback = "DEFAULT_ROLLBACK"
        case noRollback = "NO_ROLLBACK"
        public var description: String { return self.rawValue }
    }

    public enum ScheduleAt: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case now = "NOW"
        case offPeakWindow = "OFF_PEAK_WINDOW"
        case timestamp = "TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledAutoTuneActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jvmHeapSizeTuning = "JVM_HEAP_SIZE_TUNING"
        case jvmYoungGenTuning = "JVM_YOUNG_GEN_TUNING"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledAutoTuneSeverityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledBy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customer = "CUSTOMER"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum SkipUnavailableStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum TLSSecurityPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case policyMinTls10201907 = "Policy-Min-TLS-1-0-2019-07"
        case policyMinTls12201907 = "Policy-Min-TLS-1-2-2019-07"
        case policyMinTls12Pfs202310 = "Policy-Min-TLS-1-2-PFS-2023-10"
        public var description: String { return self.rawValue }
    }

    public enum TimeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hours = "HOURS"
        public var description: String { return self.rawValue }
    }

    public enum UpgradeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        case succeededWithIssues = "SUCCEEDED_WITH_ISSUES"
        public var description: String { return self.rawValue }
    }

    public enum UpgradeStep: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case preUpgradeCheck = "PRE_UPGRADE_CHECK"
        case snapshot = "SNAPSHOT"
        case upgrade = "UPGRADE"
        public var description: String { return self.rawValue }
    }

    public enum VolumeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gp2 = "gp2"
        case gp3 = "gp3"
        case io1 = "io1"
        case standard = "standard"
        public var description: String { return self.rawValue }
    }

    public enum VpcEndpointErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case endpointNotFound = "ENDPOINT_NOT_FOUND"
        case serverError = "SERVER_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum VpcEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ZoneStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case notAvailable = "NotAvailable"
        case standBy = "StandBy"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AWSDomainInformation: AWSEncodableShape & AWSDecodableShape {
        /// Name of the domain.
        public let domainName: String
        /// The Amazon Web Services account ID of the domain owner.
        public let ownerId: String?
        /// The Amazon Web Services Region in which the domain is located.
        public let region: String?

        public init(domainName: String, ownerId: String? = nil, region: String? = nil) {
            self.domainName = domainName
            self.ownerId = ownerId
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.ownerId, name: "ownerId", parent: name, max: 12)
            try self.validate(self.ownerId, name: "ownerId", parent: name, min: 12)
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.region, name: "region", parent: name, max: 30)
            try self.validate(self.region, name: "region", parent: name, min: 5)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case ownerId = "OwnerId"
            case region = "Region"
        }
    }

    public struct AcceptInboundConnectionRequest: AWSEncodableShape {
        /// The ID of the inbound connection to accept.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectionId, key: "ConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AcceptInboundConnectionResponse: AWSDecodableShape {
        /// Information about the accepted inbound connection.
        public let connection: InboundConnection?

        public init(connection: InboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct AccessPoliciesStatus: AWSDecodableShape {
        /// The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. For more information, see Configuring access policies.
        public let options: String
        /// The status of the access policy for the domain.
        public let status: OptionStatus

        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AddDataSourceRequest: AWSEncodableShape {
        /// The type of data source.
        public let dataSourceType: DataSourceType
        /// A description of the data source.
        public let description: String?
        /// The name of the domain to add the data source to.
        public let domainName: String
        /// A name for the data source.
        public let name: String

        public init(dataSourceType: DataSourceType, description: String? = nil, domainName: String, name: String) {
            self.dataSourceType = dataSourceType
            self.description = description
            self.domainName = domainName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataSourceType, forKey: .dataSourceType)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.dataSourceType.validate(name: "\(name).dataSourceType")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^([a-zA-Z0-9_])*[\\\\a-zA-Z0-9_@#%*+=:?./!\\s-]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType = "DataSourceType"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct AddDataSourceResponse: AWSDecodableShape {
        /// A message associated with creation of the data source.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct AddTagsRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the OpenSearch Service domain to which you want to attach resource tags.
        public let arn: String
        /// List of resource tags.
        public let tagList: [Tag]

        public init(arn: String, tagList: [Tag]) {
            self.arn = arn
            self.tagList = tagList
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
            try self.tagList.forEach {
                try $0.validate(name: "\(name).tagList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
            case tagList = "TagList"
        }
    }

    public struct AdditionalLimit: AWSDecodableShape {
        ///    MaximumNumberOfDataNodesSupported - This attribute only applies to master nodes and specifies the maximum number of data nodes of a given instance type a master node can support.    MaximumNumberOfDataNodesWithoutMasterNode - This attribute only applies to data nodes and specifies the maximum number of data nodes of a given instance type can exist without a master node governing them.
        public let limitName: String?
        ///  The values of the additional instance type limits.
        public let limitValues: [String]?

        public init(limitName: String? = nil, limitValues: [String]? = nil) {
            self.limitName = limitName
            self.limitValues = limitValues
        }

        private enum CodingKeys: String, CodingKey {
            case limitName = "LimitName"
            case limitValues = "LimitValues"
        }
    }

    public struct AdvancedOptionsStatus: AWSDecodableShape {
        /// The status of advanced options for the specified domain.
        public let options: [String: String]
        /// The status of advanced options for the specified domain.
        public let status: OptionStatus

        public init(options: [String: String], status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AdvancedSecurityOptions: AWSDecodableShape {
        /// Date and time when the migration period will be disabled. Only necessary when enabling fine-grained access control on an existing domain.
        public let anonymousAuthDisableDate: Date?
        /// True if a 30-day migration period is enabled, during which administrators can create role mappings. Only necessary when enabling fine-grained access control on an existing domain.
        public let anonymousAuthEnabled: Bool?
        /// True if fine-grained access control is enabled.
        public let enabled: Bool?
        /// True if the internal user database is enabled.
        public let internalUserDatabaseEnabled: Bool?
        /// Container for information about the SAML configuration for OpenSearch Dashboards.
        public let samlOptions: SAMLOptionsOutput?

        public init(anonymousAuthDisableDate: Date? = nil, anonymousAuthEnabled: Bool? = nil, enabled: Bool? = nil, internalUserDatabaseEnabled: Bool? = nil, samlOptions: SAMLOptionsOutput? = nil) {
            self.anonymousAuthDisableDate = anonymousAuthDisableDate
            self.anonymousAuthEnabled = anonymousAuthEnabled
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.samlOptions = samlOptions
        }

        private enum CodingKeys: String, CodingKey {
            case anonymousAuthDisableDate = "AnonymousAuthDisableDate"
            case anonymousAuthEnabled = "AnonymousAuthEnabled"
            case enabled = "Enabled"
            case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
            case samlOptions = "SAMLOptions"
        }
    }

    public struct AdvancedSecurityOptionsInput: AWSEncodableShape {
        /// True to enable a 30-day migration period during which administrators can create role mappings. Only necessary when enabling fine-grained access control on an existing domain.
        public let anonymousAuthEnabled: Bool?
        /// True to enable fine-grained access control.
        public let enabled: Bool?
        /// True to enable the internal user database.
        public let internalUserDatabaseEnabled: Bool?
        /// Container for information about the master user.
        public let masterUserOptions: MasterUserOptions?
        /// Container for information about the SAML configuration for OpenSearch Dashboards.
        public let samlOptions: SAMLOptionsInput?

        public init(anonymousAuthEnabled: Bool? = nil, enabled: Bool? = nil, internalUserDatabaseEnabled: Bool? = nil, masterUserOptions: MasterUserOptions? = nil, samlOptions: SAMLOptionsInput? = nil) {
            self.anonymousAuthEnabled = anonymousAuthEnabled
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.masterUserOptions = masterUserOptions
            self.samlOptions = samlOptions
        }

        public func validate(name: String) throws {
            try self.masterUserOptions?.validate(name: "\(name).masterUserOptions")
            try self.samlOptions?.validate(name: "\(name).samlOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case anonymousAuthEnabled = "AnonymousAuthEnabled"
            case enabled = "Enabled"
            case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
            case masterUserOptions = "MasterUserOptions"
            case samlOptions = "SAMLOptions"
        }
    }

    public struct AdvancedSecurityOptionsStatus: AWSDecodableShape {
        /// Container for fine-grained access control settings.
        public let options: AdvancedSecurityOptions
        /// Status of the fine-grained access control settings for a domain.
        public let status: OptionStatus

        public init(options: AdvancedSecurityOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AssociatePackageRequest: AWSEncodableShape {
        /// Name of the domain to associate the package with.
        public let domainName: String
        /// Internal ID of the package to associate with a domain. Use DescribePackages to find this value.
        public let packageID: String

        public init(domainName: String, packageID: String) {
            self.domainName = domainName
            self.packageID = packageID
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.packageID, key: "PackageID")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.packageID, name: "packageID", parent: name, pattern: "^([FG][0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociatePackageResponse: AWSDecodableShape {
        /// Information about a package that is associated with a domain.
        public let domainPackageDetails: DomainPackageDetails?

        public init(domainPackageDetails: DomainPackageDetails? = nil) {
            self.domainPackageDetails = domainPackageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetails = "DomainPackageDetails"
        }
    }

    public struct AuthorizeVpcEndpointAccessRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID to grant access to.
        public let account: String
        /// The name of the OpenSearch Service domain to provide access to.
        public let domainName: String

        public init(account: String, domainName: String) {
            self.account = account
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.account, forKey: .account)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.account, name: "account", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case account = "Account"
        }
    }

    public struct AuthorizeVpcEndpointAccessResponse: AWSDecodableShape {
        /// Information about the Amazon Web Services account or service that was provided access to the domain.
        public let authorizedPrincipal: AuthorizedPrincipal

        public init(authorizedPrincipal: AuthorizedPrincipal) {
            self.authorizedPrincipal = authorizedPrincipal
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedPrincipal = "AuthorizedPrincipal"
        }
    }

    public struct AuthorizedPrincipal: AWSDecodableShape {
        /// The IAM principal that is allowed access to the domain.
        public let principal: String?
        /// The type of principal.
        public let principalType: PrincipalType?

        public init(principal: String? = nil, principalType: PrincipalType? = nil) {
            self.principal = principal
            self.principalType = principalType
        }

        private enum CodingKeys: String, CodingKey {
            case principal = "Principal"
            case principalType = "PrincipalType"
        }
    }

    public struct AutoTune: AWSDecodableShape {
        /// Details about an Auto-Tune action.
        public let autoTuneDetails: AutoTuneDetails?
        /// The type of Auto-Tune action.
        public let autoTuneType: AutoTuneType?

        public init(autoTuneDetails: AutoTuneDetails? = nil, autoTuneType: AutoTuneType? = nil) {
            self.autoTuneDetails = autoTuneDetails
            self.autoTuneType = autoTuneType
        }

        private enum CodingKeys: String, CodingKey {
            case autoTuneDetails = "AutoTuneDetails"
            case autoTuneType = "AutoTuneType"
        }
    }

    public struct AutoTuneDetails: AWSDecodableShape {
        /// Container for details about a scheduled Auto-Tune action.
        public let scheduledAutoTuneDetails: ScheduledAutoTuneDetails?

        public init(scheduledAutoTuneDetails: ScheduledAutoTuneDetails? = nil) {
            self.scheduledAutoTuneDetails = scheduledAutoTuneDetails
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledAutoTuneDetails = "ScheduledAutoTuneDetails"
        }
    }

    public struct AutoTuneMaintenanceSchedule: AWSEncodableShape & AWSDecodableShape {
        /// A cron expression for a recurring maintenance schedule during which Auto-Tune can deploy changes.
        public let cronExpressionForRecurrence: String?
        /// The duration of the maintenance schedule. For example, "Duration": {"Value": 2, "Unit": "HOURS"}.
        public let duration: Duration?
        /// The Epoch timestamp at which the Auto-Tune maintenance schedule starts.
        public let startAt: Date?

        public init(cronExpressionForRecurrence: String? = nil, duration: Duration? = nil, startAt: Date? = nil) {
            self.cronExpressionForRecurrence = cronExpressionForRecurrence
            self.duration = duration
            self.startAt = startAt
        }

        public func validate(name: String) throws {
            try self.duration?.validate(name: "\(name).duration")
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpressionForRecurrence = "CronExpressionForRecurrence"
            case duration = "Duration"
            case startAt = "StartAt"
        }
    }

    public struct AutoTuneOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether Auto-Tune is enabled or disabled.
        public let desiredState: AutoTuneDesiredState?
        /// DEPRECATED. Use off-peak window instead. A list of maintenance schedules during which Auto-Tune can deploy changes.
        public let maintenanceSchedules: [AutoTuneMaintenanceSchedule]?
        /// When disabling Auto-Tune, specify NO_ROLLBACK to retain all prior Auto-Tune settings or DEFAULT_ROLLBACK to revert to the OpenSearch Service defaults. If you specify DEFAULT_ROLLBACK, you must include a MaintenanceSchedule in the request. Otherwise, OpenSearch Service is unable to perform the rollback.
        public let rollbackOnDisable: RollbackOnDisable?
        /// Whether to use the domain's off-peak window to deploy configuration changes on the domain rather than a maintenance schedule.
        public let useOffPeakWindow: Bool?

        public init(desiredState: AutoTuneDesiredState? = nil, maintenanceSchedules: [AutoTuneMaintenanceSchedule]? = nil, rollbackOnDisable: RollbackOnDisable? = nil, useOffPeakWindow: Bool? = nil) {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
            self.rollbackOnDisable = rollbackOnDisable
            self.useOffPeakWindow = useOffPeakWindow
        }

        public func validate(name: String) throws {
            try self.maintenanceSchedules?.forEach {
                try $0.validate(name: "\(name).maintenanceSchedules[]")
            }
            try self.validate(self.maintenanceSchedules, name: "maintenanceSchedules", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case desiredState = "DesiredState"
            case maintenanceSchedules = "MaintenanceSchedules"
            case rollbackOnDisable = "RollbackOnDisable"
            case useOffPeakWindow = "UseOffPeakWindow"
        }
    }

    public struct AutoTuneOptionsInput: AWSEncodableShape {
        /// Whether Auto-Tune is enabled or disabled.
        public let desiredState: AutoTuneDesiredState?
        /// A list of maintenance schedules during which Auto-Tune can deploy changes. Maintenance windows are deprecated and have been replaced with off-peak windows.
        public let maintenanceSchedules: [AutoTuneMaintenanceSchedule]?
        /// Whether to schedule Auto-Tune optimizations that require blue/green deployments during the domain's configured daily off-peak window.
        public let useOffPeakWindow: Bool?

        public init(desiredState: AutoTuneDesiredState? = nil, maintenanceSchedules: [AutoTuneMaintenanceSchedule]? = nil, useOffPeakWindow: Bool? = nil) {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
            self.useOffPeakWindow = useOffPeakWindow
        }

        public func validate(name: String) throws {
            try self.maintenanceSchedules?.forEach {
                try $0.validate(name: "\(name).maintenanceSchedules[]")
            }
            try self.validate(self.maintenanceSchedules, name: "maintenanceSchedules", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case desiredState = "DesiredState"
            case maintenanceSchedules = "MaintenanceSchedules"
            case useOffPeakWindow = "UseOffPeakWindow"
        }
    }

    public struct AutoTuneOptionsOutput: AWSDecodableShape {
        /// Any errors that occurred while enabling or disabling Auto-Tune.
        public let errorMessage: String?
        /// The current state of Auto-Tune on the domain.
        public let state: AutoTuneState?
        /// Whether the domain's off-peak window will be used to deploy Auto-Tune changes rather than a maintenance schedule.
        public let useOffPeakWindow: Bool?

        public init(errorMessage: String? = nil, state: AutoTuneState? = nil, useOffPeakWindow: Bool? = nil) {
            self.errorMessage = errorMessage
            self.state = state
            self.useOffPeakWindow = useOffPeakWindow
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case state = "State"
            case useOffPeakWindow = "UseOffPeakWindow"
        }
    }

    public struct AutoTuneOptionsStatus: AWSDecodableShape {
        /// Auto-Tune settings for updating a domain.
        public let options: AutoTuneOptions?
        /// The current status of Auto-Tune for a domain.
        public let status: AutoTuneStatus?

        public init(options: AutoTuneOptions? = nil, status: AutoTuneStatus? = nil) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AutoTuneStatus: AWSDecodableShape {
        /// Date and time when Auto-Tune was enabled for the domain.
        public let creationDate: Date
        /// Any errors that occurred while enabling or disabling Auto-Tune.
        public let errorMessage: String?
        /// Indicates whether the domain is being deleted.
        public let pendingDeletion: Bool?
        /// The current state of Auto-Tune on the domain.
        public let state: AutoTuneState
        /// Date and time when the Auto-Tune options were last updated for the domain.
        public let updateDate: Date
        /// The latest version of the Auto-Tune options.
        public let updateVersion: Int?

        public init(creationDate: Date, errorMessage: String? = nil, pendingDeletion: Bool? = nil, state: AutoTuneState, updateDate: Date, updateVersion: Int? = nil) {
            self.creationDate = creationDate
            self.errorMessage = errorMessage
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case errorMessage = "ErrorMessage"
            case pendingDeletion = "PendingDeletion"
            case state = "State"
            case updateDate = "UpdateDate"
            case updateVersion = "UpdateVersion"
        }
    }

    public struct AvailabilityZoneInfo: AWSDecodableShape {
        /// The name of the Availability Zone.
        public let availabilityZoneName: String?
        /// The number of data nodes active in the Availability Zone.
        public let availableDataNodeCount: String?
        /// The total number of data nodes configured in the Availability Zone.
        public let configuredDataNodeCount: String?
        /// The total number of primary and replica shards in the Availability Zone.
        public let totalShards: String?
        /// The total number of primary and replica shards that aren't allocated to any of the nodes in the Availability Zone.
        public let totalUnAssignedShards: String?
        /// The current state of the Availability Zone. Current options are Active and StandBy.    Active - Data nodes in the Availability Zone are in use.    StandBy - Data nodes in the Availability Zone are in a standby state.    NotAvailable - Unable to retrieve information.
        public let zoneStatus: ZoneStatus?

        public init(availabilityZoneName: String? = nil, availableDataNodeCount: String? = nil, configuredDataNodeCount: String? = nil, totalShards: String? = nil, totalUnAssignedShards: String? = nil, zoneStatus: ZoneStatus? = nil) {
            self.availabilityZoneName = availabilityZoneName
            self.availableDataNodeCount = availableDataNodeCount
            self.configuredDataNodeCount = configuredDataNodeCount
            self.totalShards = totalShards
            self.totalUnAssignedShards = totalUnAssignedShards
            self.zoneStatus = zoneStatus
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneName = "AvailabilityZoneName"
            case availableDataNodeCount = "AvailableDataNodeCount"
            case configuredDataNodeCount = "ConfiguredDataNodeCount"
            case totalShards = "TotalShards"
            case totalUnAssignedShards = "TotalUnAssignedShards"
            case zoneStatus = "ZoneStatus"
        }
    }

    public struct CancelDomainConfigChangeRequest: AWSEncodableShape {
        public let domainName: String
        /// When set to True, returns the list of change IDs and properties that will be cancelled without actually cancelling the change.
        public let dryRun: Bool?

        public init(domainName: String, dryRun: Bool? = nil) {
            self.domainName = domainName
            self.dryRun = dryRun
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.dryRun, forKey: .dryRun)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dryRun = "DryRun"
        }
    }

    public struct CancelDomainConfigChangeResponse: AWSDecodableShape {
        /// The unique identifiers of the changes that were cancelled.
        public let cancelledChangeIds: [String]?
        /// The domain change properties that were cancelled.
        public let cancelledChangeProperties: [CancelledChangeProperty]?
        /// Whether or not the request was a dry run. If True, the changes were not actually cancelled.
        public let dryRun: Bool?

        public init(cancelledChangeIds: [String]? = nil, cancelledChangeProperties: [CancelledChangeProperty]? = nil, dryRun: Bool? = nil) {
            self.cancelledChangeIds = cancelledChangeIds
            self.cancelledChangeProperties = cancelledChangeProperties
            self.dryRun = dryRun
        }

        private enum CodingKeys: String, CodingKey {
            case cancelledChangeIds = "CancelledChangeIds"
            case cancelledChangeProperties = "CancelledChangeProperties"
            case dryRun = "DryRun"
        }
    }

    public struct CancelServiceSoftwareUpdateRequest: AWSEncodableShape {
        /// Name of the OpenSearch Service domain that you want to cancel the service software update on.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct CancelServiceSoftwareUpdateResponse: AWSDecodableShape {
        /// Container for the state of your domain relative to the latest service software.
        public let serviceSoftwareOptions: ServiceSoftwareOptions?

        public init(serviceSoftwareOptions: ServiceSoftwareOptions? = nil) {
            self.serviceSoftwareOptions = serviceSoftwareOptions
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
        }
    }

    public struct CancelledChangeProperty: AWSDecodableShape {
        /// The current value of the property, after the change was cancelled.
        public let activeValue: String?
        /// The pending value of the property that was cancelled. This would have been the eventual value of the property if the chance had not been cancelled.
        public let cancelledValue: String?
        /// The name of the property whose change was cancelled.
        public let propertyName: String?

        public init(activeValue: String? = nil, cancelledValue: String? = nil, propertyName: String? = nil) {
            self.activeValue = activeValue
            self.cancelledValue = cancelledValue
            self.propertyName = propertyName
        }

        private enum CodingKeys: String, CodingKey {
            case activeValue = "ActiveValue"
            case cancelledValue = "CancelledValue"
            case propertyName = "PropertyName"
        }
    }

    public struct ChangeProgressDetails: AWSDecodableShape {
        /// The ID of the configuration change.
        public let changeId: String?
        /// The current status of the configuration change.
        public let configChangeStatus: ConfigChangeStatus?
        /// The IAM principal who initiated the configuration change.
        public let initiatedBy: InitiatedBy?
        /// The last time that the configuration change was updated.
        public let lastUpdatedTime: Date?
        /// A message corresponding to the status of the configuration change.
        public let message: String?
        /// The time that the configuration change was initiated, in Universal Coordinated Time (UTC).
        public let startTime: Date?

        public init(changeId: String? = nil, configChangeStatus: ConfigChangeStatus? = nil, initiatedBy: InitiatedBy? = nil, lastUpdatedTime: Date? = nil, message: String? = nil, startTime: Date? = nil) {
            self.changeId = changeId
            self.configChangeStatus = configChangeStatus
            self.initiatedBy = initiatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.message = message
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case changeId = "ChangeId"
            case configChangeStatus = "ConfigChangeStatus"
            case initiatedBy = "InitiatedBy"
            case lastUpdatedTime = "LastUpdatedTime"
            case message = "Message"
            case startTime = "StartTime"
        }
    }

    public struct ChangeProgressStage: AWSDecodableShape {
        /// The description of the stage.
        public let description: String?
        /// The most recent updated timestamp of the stage.
        public let lastUpdated: Date?
        /// The name of the stage.
        public let name: String?
        /// The status of the stage.
        public let status: String?

        public init(description: String? = nil, lastUpdated: Date? = nil, name: String? = nil, status: String? = nil) {
            self.description = description
            self.lastUpdated = lastUpdated
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct ChangeProgressStatusDetails: AWSDecodableShape {
        /// The unique change identifier associated with a specific domain configuration change.
        public let changeId: String?
        /// The specific stages that the domain is going through to perform the configuration change.
        public let changeProgressStages: [ChangeProgressStage]?
        /// The list of properties in the domain configuration change that have completed.
        public let completedProperties: [String]?
        /// The current status of the configuration change.
        public let configChangeStatus: ConfigChangeStatus?
        /// The IAM principal who initiated the configuration change.
        public let initiatedBy: InitiatedBy?
        /// The last time that the status of the configuration change was updated.
        public let lastUpdatedTime: Date?
        /// The list of properties in the domain configuration change that are still pending.
        public let pendingProperties: [String]?
        /// The time at which the configuration change is made on the domain.
        public let startTime: Date?
        /// The overall status of the domain configuration change.
        public let status: OverallChangeStatus?
        /// The total number of stages required for the configuration change.
        public let totalNumberOfStages: Int?

        public init(changeId: String? = nil, changeProgressStages: [ChangeProgressStage]? = nil, completedProperties: [String]? = nil, configChangeStatus: ConfigChangeStatus? = nil, initiatedBy: InitiatedBy? = nil, lastUpdatedTime: Date? = nil, pendingProperties: [String]? = nil, startTime: Date? = nil, status: OverallChangeStatus? = nil, totalNumberOfStages: Int? = nil) {
            self.changeId = changeId
            self.changeProgressStages = changeProgressStages
            self.completedProperties = completedProperties
            self.configChangeStatus = configChangeStatus
            self.initiatedBy = initiatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.pendingProperties = pendingProperties
            self.startTime = startTime
            self.status = status
            self.totalNumberOfStages = totalNumberOfStages
        }

        private enum CodingKeys: String, CodingKey {
            case changeId = "ChangeId"
            case changeProgressStages = "ChangeProgressStages"
            case completedProperties = "CompletedProperties"
            case configChangeStatus = "ConfigChangeStatus"
            case initiatedBy = "InitiatedBy"
            case lastUpdatedTime = "LastUpdatedTime"
            case pendingProperties = "PendingProperties"
            case startTime = "StartTime"
            case status = "Status"
            case totalNumberOfStages = "TotalNumberOfStages"
        }
    }

    public struct ClusterConfig: AWSEncodableShape & AWSDecodableShape {
        /// Container for cold storage configuration options.
        public let coldStorageOptions: ColdStorageOptions?
        /// Number of dedicated master nodes in the cluster. This number must be greater than 2 and not 4, otherwise you receive a validation exception.
        public let dedicatedMasterCount: Int?
        /// Indicates whether dedicated master nodes are enabled for the cluster.True if the cluster will use a dedicated master node.False if the cluster will not.
        public let dedicatedMasterEnabled: Bool?
        /// OpenSearch Service instance type of the dedicated master nodes in the cluster.
        public let dedicatedMasterType: OpenSearchPartitionInstanceType?
        /// Number of data nodes in the cluster. This number must be greater than 1, otherwise you receive a validation exception.
        public let instanceCount: Int?
        /// Instance type of data nodes in the cluster.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// A boolean that indicates whether a multi-AZ domain is turned on with a standby AZ. For more information, see Configuring a multi-AZ domain in Amazon OpenSearch Service.
        public let multiAZWithStandbyEnabled: Bool?
        /// The number of warm nodes in the cluster.
        public let warmCount: Int?
        /// Whether to enable warm storage for the cluster.
        public let warmEnabled: Bool?
        /// The instance type for the cluster's warm nodes.
        public let warmType: OpenSearchWarmPartitionInstanceType?
        /// Container for zone awareness configuration options. Only required if ZoneAwarenessEnabled is true.
        public let zoneAwarenessConfig: ZoneAwarenessConfig?
        /// Indicates whether multiple Availability Zones are enabled. For more information, see Configuring a multi-AZ domain in Amazon OpenSearch Service.
        public let zoneAwarenessEnabled: Bool?

        public init(coldStorageOptions: ColdStorageOptions? = nil, dedicatedMasterCount: Int? = nil, dedicatedMasterEnabled: Bool? = nil, dedicatedMasterType: OpenSearchPartitionInstanceType? = nil, instanceCount: Int? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, multiAZWithStandbyEnabled: Bool? = nil, warmCount: Int? = nil, warmEnabled: Bool? = nil, warmType: OpenSearchWarmPartitionInstanceType? = nil, zoneAwarenessConfig: ZoneAwarenessConfig? = nil, zoneAwarenessEnabled: Bool? = nil) {
            self.coldStorageOptions = coldStorageOptions
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.multiAZWithStandbyEnabled = multiAZWithStandbyEnabled
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case coldStorageOptions = "ColdStorageOptions"
            case dedicatedMasterCount = "DedicatedMasterCount"
            case dedicatedMasterEnabled = "DedicatedMasterEnabled"
            case dedicatedMasterType = "DedicatedMasterType"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case multiAZWithStandbyEnabled = "MultiAZWithStandbyEnabled"
            case warmCount = "WarmCount"
            case warmEnabled = "WarmEnabled"
            case warmType = "WarmType"
            case zoneAwarenessConfig = "ZoneAwarenessConfig"
            case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
        }
    }

    public struct ClusterConfigStatus: AWSDecodableShape {
        /// Cluster configuration options for the specified domain.
        public let options: ClusterConfig
        /// The status of cluster configuration options for the specified domain.
        public let status: OptionStatus

        public init(options: ClusterConfig, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct CognitoOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable or disable Amazon Cognito authentication for OpenSearch Dashboards.
        public let enabled: Bool?
        /// The Amazon Cognito identity pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.
        public let identityPoolId: String?
        /// The AmazonOpenSearchServiceCognitoAccess role that allows OpenSearch Service to configure your user pool and identity pool.
        public let roleArn: String?
        /// The Amazon Cognito user pool ID that you want OpenSearch Service to use for OpenSearch Dashboards authentication.
        public let userPoolId: String?

        public init(enabled: Bool? = nil, identityPoolId: String? = nil, roleArn: String? = nil, userPoolId: String? = nil) {
            self.enabled = enabled
            self.identityPoolId = identityPoolId
            self.roleArn = roleArn
            self.userPoolId = userPoolId
        }

        public func validate(name: String) throws {
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, max: 55)
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, min: 1)
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, pattern: "^[\\w-]+:[0-9a-f-]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws|aws\\-cn|aws\\-us\\-gov|aws\\-iso|aws\\-iso\\-b):iam::[0-9]+:role\\/")
            try self.validate(self.userPoolId, name: "userPoolId", parent: name, max: 55)
            try self.validate(self.userPoolId, name: "userPoolId", parent: name, min: 1)
            try self.validate(self.userPoolId, name: "userPoolId", parent: name, pattern: "^[\\w-]+_[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case identityPoolId = "IdentityPoolId"
            case roleArn = "RoleArn"
            case userPoolId = "UserPoolId"
        }
    }

    public struct CognitoOptionsStatus: AWSDecodableShape {
        /// Cognito options for the specified domain.
        public let options: CognitoOptions
        /// The status of the Cognito options for the specified domain.
        public let status: OptionStatus

        public init(options: CognitoOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct ColdStorageOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable or disable cold storage on the domain. You must enable UltraWarm storage to enable cold storage.
        public let enabled: Bool

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct CompatibleVersionsMap: AWSDecodableShape {
        /// The current version that the OpenSearch Service domain is running.
        public let sourceVersion: String?
        /// The possible versions that you can upgrade the domain to.
        public let targetVersions: [String]?

        public init(sourceVersion: String? = nil, targetVersions: [String]? = nil) {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }

        private enum CodingKeys: String, CodingKey {
            case sourceVersion = "SourceVersion"
            case targetVersions = "TargetVersions"
        }
    }

    public struct ConnectionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The connection properties for cross cluster search.
        public let crossClusterSearch: CrossClusterSearchConnectionProperties?
        ///  The Endpoint attribute cannot be modified.   The endpoint of the remote domain. Applicable for VPC_ENDPOINT connection mode.
        public let endpoint: String?

        public init(crossClusterSearch: CrossClusterSearchConnectionProperties? = nil, endpoint: String? = nil) {
            self.crossClusterSearch = crossClusterSearch
            self.endpoint = endpoint
        }

        public func validate(name: String) throws {
            try self.validate(self.endpoint, name: "endpoint", parent: name, pattern: "^[A-Za-z0-9\\-\\.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case crossClusterSearch = "CrossClusterSearch"
            case endpoint = "Endpoint"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// Identity and Access Management (IAM) policy document specifying the access policies for the new domain.
        public let accessPolicies: String?
        /// Key-value pairs to specify advanced configuration options. The following key-value pairs are supported:    "rest.action.multi.allow_explicit_index": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether explicit references to indexes are allowed inside the body of HTTP requests. If you want to configure access policies for domain sub-resources, such as specific indexes and domain APIs, you must disable this property. Default is true.    "indices.fielddata.cache.size": "80"  - Note the use of a string rather than a boolean. Specifies the percentage of heap space allocated to field data. Default is unbounded.    "indices.query.bool.max_clause_count": "1024" - Note the use of a string rather than a boolean. Specifies the maximum number of clauses allowed in a Lucene boolean query. Default is 1,024. Queries with more than the permitted number of clauses result in a TooManyClauses error.    "override_main_response_version": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether the domain reports its version as 7.10 to allow Elasticsearch OSS clients and plugins to continue working with it. Default is false when creating a domain and true when upgrading a domain.   For more information, see Advanced cluster parameters.
        public let advancedOptions: [String: String]?
        /// Options for fine-grained access control.
        public let advancedSecurityOptions: AdvancedSecurityOptionsInput?
        /// Options for Auto-Tune.
        public let autoTuneOptions: AutoTuneOptionsInput?
        /// Container for the cluster configuration of a domain.
        public let clusterConfig: ClusterConfig?
        /// Key-value pairs to configure Amazon Cognito authentication. For more information, see Configuring Amazon Cognito authentication for OpenSearch Dashboards.
        public let cognitoOptions: CognitoOptions?
        /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
        public let domainEndpointOptions: DomainEndpointOptions?
        /// Name of the OpenSearch Service domain to create. Domain names are unique across the domains owned by an account within an Amazon Web Services Region.
        public let domainName: String
        /// Container for the parameters required to enable EBS-based storage for an OpenSearch Service domain.
        public let ebsOptions: EBSOptions?
        /// Key-value pairs to enable encryption at rest.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch Service domain. For example, OpenSearch_1.0 or Elasticsearch_7.9. For more information, see Creating and managing Amazon OpenSearch Service domains.
        public let engineVersion: String?
        /// Specify either dual stack or IPv4 as your IP address type. Dual stack allows you to share domain resources across IPv4 and IPv6 address types, and is the recommended option.  If you set your IP address type to dual stack, you can't change your address type later.
        public let ipAddressType: IPAddressType?
        /// Key-value pairs to configure log publishing.
        public let logPublishingOptions: [LogType: LogPublishingOption]?
        /// Enables node-to-node encryption.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
        /// Specifies a daily 10-hour time block during which OpenSearch Service can perform configuration changes on the domain, including service software updates and Auto-Tune enhancements that require a blue/green deployment. If no options are specified, the default start time of 10:00 P.M. local time (for the Region that the domain is created in) is used.
        public let offPeakWindowOptions: OffPeakWindowOptions?
        /// DEPRECATED. Container for the parameters required to configure automated snapshots of domain indexes.
        public let snapshotOptions: SnapshotOptions?
        /// Software update options for the domain.
        public let softwareUpdateOptions: SoftwareUpdateOptions?
        /// List of tags to add to the domain upon creation.
        public let tagList: [Tag]?
        /// Container for the values required to configure VPC access domains. If you don't specify these values, OpenSearch Service creates the domain with a public endpoint. For more information, see Launching your Amazon OpenSearch Service domains using a VPC.
        public let vpcOptions: VPCOptions?

        public init(accessPolicies: String? = nil, advancedOptions: [String: String]? = nil, advancedSecurityOptions: AdvancedSecurityOptionsInput? = nil, autoTuneOptions: AutoTuneOptionsInput? = nil, clusterConfig: ClusterConfig? = nil, cognitoOptions: CognitoOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, domainName: String, ebsOptions: EBSOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, engineVersion: String? = nil, ipAddressType: IPAddressType? = nil, logPublishingOptions: [LogType: LogPublishingOption]? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, offPeakWindowOptions: OffPeakWindowOptions? = nil, snapshotOptions: SnapshotOptions? = nil, softwareUpdateOptions: SoftwareUpdateOptions? = nil, tagList: [Tag]? = nil, vpcOptions: VPCOptions? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.domainName = domainName
            self.ebsOptions = ebsOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.ipAddressType = ipAddressType
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.offPeakWindowOptions = offPeakWindowOptions
            self.snapshotOptions = snapshotOptions
            self.softwareUpdateOptions = softwareUpdateOptions
            self.tagList = tagList
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, max: 102400)
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: ".*")
            try self.advancedSecurityOptions?.validate(name: "\(name).advancedSecurityOptions")
            try self.autoTuneOptions?.validate(name: "\(name).autoTuneOptions")
            try self.cognitoOptions?.validate(name: "\(name).cognitoOptions")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 18)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 14)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
            try self.logPublishingOptions?.forEach {
                try $0.value.validate(name: "\(name).logPublishingOptions[\"\($0.key)\"]")
            }
            try self.offPeakWindowOptions?.validate(name: "\(name).offPeakWindowOptions")
            try self.tagList?.forEach {
                try $0.validate(name: "\(name).tagList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case autoTuneOptions = "AutoTuneOptions"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainName = "DomainName"
            case ebsOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case engineVersion = "EngineVersion"
            case ipAddressType = "IPAddressType"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case offPeakWindowOptions = "OffPeakWindowOptions"
            case snapshotOptions = "SnapshotOptions"
            case softwareUpdateOptions = "SoftwareUpdateOptions"
            case tagList = "TagList"
            case vpcOptions = "VPCOptions"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The status of the newly created domain.
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct CreateOutboundConnectionRequest: AWSEncodableShape {
        /// Name of the connection.
        public let connectionAlias: String
        /// The connection mode.
        public let connectionMode: ConnectionMode?
        /// The ConnectionProperties for the outbound connection.
        public let connectionProperties: ConnectionProperties?
        /// Name and Region of the source (local) domain.
        public let localDomainInfo: DomainInformationContainer
        /// Name and Region of the destination (remote) domain.
        public let remoteDomainInfo: DomainInformationContainer

        public init(connectionAlias: String, connectionMode: ConnectionMode? = nil, connectionProperties: ConnectionProperties? = nil, localDomainInfo: DomainInformationContainer, remoteDomainInfo: DomainInformationContainer) {
            self.connectionAlias = connectionAlias
            self.connectionMode = connectionMode
            self.connectionProperties = connectionProperties
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionAlias, name: "connectionAlias", parent: name, max: 100)
            try self.validate(self.connectionAlias, name: "connectionAlias", parent: name, min: 2)
            try self.validate(self.connectionAlias, name: "connectionAlias", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9\\-\\_]+$")
            try self.connectionProperties?.validate(name: "\(name).connectionProperties")
            try self.localDomainInfo.validate(name: "\(name).localDomainInfo")
            try self.remoteDomainInfo.validate(name: "\(name).remoteDomainInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionAlias = "ConnectionAlias"
            case connectionMode = "ConnectionMode"
            case connectionProperties = "ConnectionProperties"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct CreateOutboundConnectionResponse: AWSDecodableShape {
        /// Name of the connection.
        public let connectionAlias: String?
        /// The unique identifier for the created outbound connection, which is used for subsequent operations on the connection.
        public let connectionId: String?
        /// The connection mode.
        public let connectionMode: ConnectionMode?
        /// The ConnectionProperties for the newly created connection.
        public let connectionProperties: ConnectionProperties?
        /// The status of the connection.
        public let connectionStatus: OutboundConnectionStatus?
        /// Information about the source (local) domain.
        public let localDomainInfo: DomainInformationContainer?
        /// Information about the destination (remote) domain.
        public let remoteDomainInfo: DomainInformationContainer?

        public init(connectionAlias: String? = nil, connectionId: String? = nil, connectionMode: ConnectionMode? = nil, connectionProperties: ConnectionProperties? = nil, connectionStatus: OutboundConnectionStatus? = nil, localDomainInfo: DomainInformationContainer? = nil, remoteDomainInfo: DomainInformationContainer? = nil) {
            self.connectionAlias = connectionAlias
            self.connectionId = connectionId
            self.connectionMode = connectionMode
            self.connectionProperties = connectionProperties
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        private enum CodingKeys: String, CodingKey {
            case connectionAlias = "ConnectionAlias"
            case connectionId = "ConnectionId"
            case connectionMode = "ConnectionMode"
            case connectionProperties = "ConnectionProperties"
            case connectionStatus = "ConnectionStatus"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct CreatePackageRequest: AWSEncodableShape {
        /// Description of the package.
        public let packageDescription: String?
        /// Unique name for the package.
        public let packageName: String
        /// The Amazon S3 location from which to import the package.
        public let packageSource: PackageSource
        /// The type of package.
        public let packageType: PackageType

        public init(packageDescription: String? = nil, packageName: String, packageSource: PackageSource, packageType: PackageType) {
            self.packageDescription = packageDescription
            self.packageName = packageName
            self.packageSource = packageSource
            self.packageType = packageType
        }

        public func validate(name: String) throws {
            try self.validate(self.packageDescription, name: "packageDescription", parent: name, max: 1024)
            try self.validate(self.packageName, name: "packageName", parent: name, max: 256)
            try self.validate(self.packageName, name: "packageName", parent: name, min: 3)
            try self.validate(self.packageName, name: "packageName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.packageSource.validate(name: "\(name).packageSource")
        }

        private enum CodingKeys: String, CodingKey {
            case packageDescription = "PackageDescription"
            case packageName = "PackageName"
            case packageSource = "PackageSource"
            case packageType = "PackageType"
        }
    }

    public struct CreatePackageResponse: AWSDecodableShape {
        /// Basic information about an OpenSearch Service package.
        public let packageDetails: PackageDetails?

        public init(packageDetails: PackageDetails? = nil) {
            self.packageDetails = packageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case packageDetails = "PackageDetails"
        }
    }

    public struct CreateVpcEndpointRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the domain to create the endpoint for.
        public let domainArn: String
        /// Options to specify the subnets and security groups for the endpoint.
        public let vpcOptions: VPCOptions

        public init(clientToken: String? = nil, domainArn: String, vpcOptions: VPCOptions) {
            self.clientToken = clientToken
            self.domainArn = domainArn
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.domainArn, name: "domainArn", parent: name, max: 512)
            try self.validate(self.domainArn, name: "domainArn", parent: name, min: 1)
            try self.validate(self.domainArn, name: "domainArn", parent: name, pattern: "^arn:aws[a-z\\-]*:[a-z]+:[a-z0-9\\-]+:[0-9]+:domain\\/[a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case domainArn = "DomainArn"
            case vpcOptions = "VpcOptions"
        }
    }

    public struct CreateVpcEndpointResponse: AWSDecodableShape {
        /// Information about the newly created VPC endpoint.
        public let vpcEndpoint: VpcEndpoint

        public init(vpcEndpoint: VpcEndpoint) {
            self.vpcEndpoint = vpcEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpoint = "VpcEndpoint"
        }
    }

    public struct CrossClusterSearchConnectionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The status of the SkipUnavailable setting for the outbound connection. This feature allows you to specify some clusters as optional and ensure that your cross-cluster queries return partial results despite failures on one or more remote clusters.
        public let skipUnavailable: SkipUnavailableStatus?

        public init(skipUnavailable: SkipUnavailableStatus? = nil) {
            self.skipUnavailable = skipUnavailable
        }

        private enum CodingKeys: String, CodingKey {
            case skipUnavailable = "SkipUnavailable"
        }
    }

    public struct DataSourceDetails: AWSDecodableShape {
        /// The type of data source.
        public let dataSourceType: DataSourceType?
        /// A description of the data source.
        public let description: String?
        /// The name of the data source.
        public let name: String?

        public init(dataSourceType: DataSourceType? = nil, description: String? = nil, name: String? = nil) {
            self.dataSourceType = dataSourceType
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType = "DataSourceType"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String
        /// The name of the data source to delete.
        public let name: String

        public init(domainName: String, name: String) {
            self.domainName = domainName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        /// A message associated with deletion of the data source.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        /// The name of the domain you want to permanently delete.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        /// The status of the domain being deleted.
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct DeleteInboundConnectionRequest: AWSEncodableShape {
        /// The ID of the inbound connection to permanently delete.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectionId, key: "ConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInboundConnectionResponse: AWSDecodableShape {
        /// The deleted inbound connection.
        public let connection: InboundConnection?

        public init(connection: InboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteOutboundConnectionRequest: AWSEncodableShape {
        /// The ID of the outbound connection you want to permanently delete.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectionId, key: "ConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOutboundConnectionResponse: AWSDecodableShape {
        /// The deleted inbound connection.
        public let connection: OutboundConnection?

        public init(connection: OutboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeletePackageRequest: AWSEncodableShape {
        /// The internal ID of the package you want to delete. Use DescribePackages to find this value.
        public let packageID: String

        public init(packageID: String) {
            self.packageID = packageID
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.packageID, key: "PackageID")
        }

        public func validate(name: String) throws {
            try self.validate(self.packageID, name: "packageID", parent: name, pattern: "^([FG][0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackageResponse: AWSDecodableShape {
        ///  Information about the deleted package.
        public let packageDetails: PackageDetails?

        public init(packageDetails: PackageDetails? = nil) {
            self.packageDetails = packageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case packageDetails = "PackageDetails"
        }
    }

    public struct DeleteVpcEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the endpoint.
        public let vpcEndpointId: String

        public init(vpcEndpointId: String) {
            self.vpcEndpointId = vpcEndpointId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vpcEndpointId, key: "VpcEndpointId")
        }

        public func validate(name: String) throws {
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, max: 256)
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, min: 5)
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, pattern: "^aos-[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVpcEndpointResponse: AWSDecodableShape {
        /// Information about the deleted endpoint, including its current status (DELETING or DELETE_FAILED).
        public let vpcEndpointSummary: VpcEndpointSummary

        public init(vpcEndpointSummary: VpcEndpointSummary) {
            self.vpcEndpointSummary = vpcEndpointSummary
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointSummary = "VpcEndpointSummary"
        }
    }

    public struct DescribeDomainAutoTunesRequest: AWSEncodableShape {
        /// Name of the domain that you want Auto-Tune details about.
        public let domainName: String
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial DescribeDomainAutoTunes operation returns a nextToken, you can include the returned nextToken in subsequent DescribeDomainAutoTunes operations, which returns results in the next page.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeDomainAutoTunesResponse: AWSDecodableShape {
        /// The list of setting adjustments that Auto-Tune has made to the domain.
        public let autoTunes: [AutoTune]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(autoTunes: [AutoTune]? = nil, nextToken: String? = nil) {
            self.autoTunes = autoTunes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case autoTunes = "AutoTunes"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeDomainChangeProgressRequest: AWSEncodableShape {
        /// The specific change ID for which you want to get progress information. If omitted, the request returns information about the most recent configuration change.
        public let changeId: String?
        /// The name of the domain to get progress information for.
        public let domainName: String

        public init(changeId: String? = nil, domainName: String) {
            self.changeId = changeId
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.changeId, key: "changeid")
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.changeId, name: "changeId", parent: name, max: 36)
            try self.validate(self.changeId, name: "changeId", parent: name, min: 36)
            try self.validate(self.changeId, name: "changeId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainChangeProgressResponse: AWSDecodableShape {
        /// Container for information about the stages of a configuration change happening on a domain.
        public let changeProgressStatus: ChangeProgressStatusDetails?

        public init(changeProgressStatus: ChangeProgressStatusDetails? = nil) {
            self.changeProgressStatus = changeProgressStatus
        }

        private enum CodingKeys: String, CodingKey {
            case changeProgressStatus = "ChangeProgressStatus"
        }
    }

    public struct DescribeDomainConfigRequest: AWSEncodableShape {
        /// Name of the OpenSearch Service domain configuration that you want to describe.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainConfigResponse: AWSDecodableShape {
        /// Container for the configuration of the OpenSearch Service domain.
        public let domainConfig: DomainConfig

        public init(domainConfig: DomainConfig) {
            self.domainConfig = domainConfig
        }

        private enum CodingKeys: String, CodingKey {
            case domainConfig = "DomainConfig"
        }
    }

    public struct DescribeDomainHealthRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainHealthResponse: AWSDecodableShape {
        /// The number of active Availability Zones configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
        public let activeAvailabilityZoneCount: String?
        /// The number of Availability Zones configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
        public let availabilityZoneCount: String?
        /// The current health status of your cluster.    Red - At least one primary shard is not allocated to any node.    Yellow - All primary shards are allocated to nodes, but some replicas aren’t.    Green - All primary shards and their replicas are allocated to nodes.    NotAvailable - Unable to retrieve cluster health.
        public let clusterHealth: DomainHealth?
        /// The number of data nodes configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
        public let dataNodeCount: String?
        /// A boolean that indicates if dedicated master nodes are activated for the domain.
        public let dedicatedMaster: Bool?
        /// The current state of the domain.    Processing - The domain has updates in progress.    Active - Requested changes have been processed and deployed to the domain.
        public let domainState: DomainState?
        /// A list of EnvironmentInfo for the domain.
        public let environmentInformation: [EnvironmentInfo]?
        /// The number of nodes that can be elected as a master node. If dedicated master nodes is turned on, this value is the number of dedicated master nodes configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
        public let masterEligibleNodeCount: String?
        /// Indicates whether the domain has an elected master node.    Available - The domain has an elected master node.    UnAvailable - The master node hasn't yet been elected, and a quorum to elect a new master node hasn't been reached.
        public let masterNode: MasterNodeStatus?
        /// The number of standby Availability Zones configured for the domain. If the service is unable to fetch this information, it will return NotAvailable.
        public let standByAvailabilityZoneCount: String?
        /// The total number of primary and replica shards for the domain.
        public let totalShards: String?
        /// The total number of primary and replica shards not allocated to any of the nodes for the cluster.
        public let totalUnAssignedShards: String?
        /// The number of warm nodes configured for the domain.
        public let warmNodeCount: String?

        public init(activeAvailabilityZoneCount: String? = nil, availabilityZoneCount: String? = nil, clusterHealth: DomainHealth? = nil, dataNodeCount: String? = nil, dedicatedMaster: Bool? = nil, domainState: DomainState? = nil, environmentInformation: [EnvironmentInfo]? = nil, masterEligibleNodeCount: String? = nil, masterNode: MasterNodeStatus? = nil, standByAvailabilityZoneCount: String? = nil, totalShards: String? = nil, totalUnAssignedShards: String? = nil, warmNodeCount: String? = nil) {
            self.activeAvailabilityZoneCount = activeAvailabilityZoneCount
            self.availabilityZoneCount = availabilityZoneCount
            self.clusterHealth = clusterHealth
            self.dataNodeCount = dataNodeCount
            self.dedicatedMaster = dedicatedMaster
            self.domainState = domainState
            self.environmentInformation = environmentInformation
            self.masterEligibleNodeCount = masterEligibleNodeCount
            self.masterNode = masterNode
            self.standByAvailabilityZoneCount = standByAvailabilityZoneCount
            self.totalShards = totalShards
            self.totalUnAssignedShards = totalUnAssignedShards
            self.warmNodeCount = warmNodeCount
        }

        private enum CodingKeys: String, CodingKey {
            case activeAvailabilityZoneCount = "ActiveAvailabilityZoneCount"
            case availabilityZoneCount = "AvailabilityZoneCount"
            case clusterHealth = "ClusterHealth"
            case dataNodeCount = "DataNodeCount"
            case dedicatedMaster = "DedicatedMaster"
            case domainState = "DomainState"
            case environmentInformation = "EnvironmentInformation"
            case masterEligibleNodeCount = "MasterEligibleNodeCount"
            case masterNode = "MasterNode"
            case standByAvailabilityZoneCount = "StandByAvailabilityZoneCount"
            case totalShards = "TotalShards"
            case totalUnAssignedShards = "TotalUnAssignedShards"
            case warmNodeCount = "WarmNodeCount"
        }
    }

    public struct DescribeDomainNodesRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainNodesResponse: AWSDecodableShape {
        /// Contains nodes information list DomainNodesStatusList with details about the all nodes on the requested domain.
        public let domainNodesStatusList: [DomainNodesStatus]?

        public init(domainNodesStatusList: [DomainNodesStatus]? = nil) {
            self.domainNodesStatusList = domainNodesStatusList
        }

        private enum CodingKeys: String, CodingKey {
            case domainNodesStatusList = "DomainNodesStatusList"
        }
    }

    public struct DescribeDomainRequest: AWSEncodableShape {
        /// The name of the domain that you want information about.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainResponse: AWSDecodableShape {
        /// List that contains the status of each specified OpenSearch Service domain.
        public let domainStatus: DomainStatus

        public init(domainStatus: DomainStatus) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct DescribeDomainsRequest: AWSEncodableShape {
        /// Array of OpenSearch Service domain names that you want information about. You must specify at least one domain name.
        public let domainNames: [String]

        public init(domainNames: [String]) {
            self.domainNames = domainNames
        }

        public func validate(name: String) throws {
            try self.domainNames.forEach {
                try validate($0, name: "domainNames[]", parent: name, max: 28)
                try validate($0, name: "domainNames[]", parent: name, min: 3)
                try validate($0, name: "domainNames[]", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct DescribeDomainsResponse: AWSDecodableShape {
        /// The status of the requested domains.
        public let domainStatusList: [DomainStatus]

        public init(domainStatusList: [DomainStatus]) {
            self.domainStatusList = domainStatusList
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatusList = "DomainStatusList"
        }
    }

    public struct DescribeDryRunProgressRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String
        /// The unique identifier of the dry run.
        public let dryRunId: String?
        /// Whether to include the configuration of the dry run in the response. The configuration specifies the updates that you're planning to make on the domain.
        public let loadDryRunConfig: Bool?

        public init(domainName: String, dryRunId: String? = nil, loadDryRunConfig: Bool? = nil) {
            self.domainName = domainName
            self.dryRunId = dryRunId
            self.loadDryRunConfig = loadDryRunConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.dryRunId, key: "dryRunId")
            request.encodeQuery(self.loadDryRunConfig, key: "loadDryRunConfig")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.dryRunId, name: "dryRunId", parent: name, max: 36)
            try self.validate(self.dryRunId, name: "dryRunId", parent: name, min: 36)
            try self.validate(self.dryRunId, name: "dryRunId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDryRunProgressResponse: AWSDecodableShape {
        /// Details about the changes you're planning to make on the domain.
        public let dryRunConfig: DomainStatus?
        /// The current status of the dry run, including any validation errors.
        public let dryRunProgressStatus: DryRunProgressStatus?
        /// The results of the dry run.
        public let dryRunResults: DryRunResults?

        public init(dryRunConfig: DomainStatus? = nil, dryRunProgressStatus: DryRunProgressStatus? = nil, dryRunResults: DryRunResults? = nil) {
            self.dryRunConfig = dryRunConfig
            self.dryRunProgressStatus = dryRunProgressStatus
            self.dryRunResults = dryRunResults
        }

        private enum CodingKeys: String, CodingKey {
            case dryRunConfig = "DryRunConfig"
            case dryRunProgressStatus = "DryRunProgressStatus"
            case dryRunResults = "DryRunResults"
        }
    }

    public struct DescribeInboundConnectionsRequest: AWSEncodableShape {
        ///  A list of filters used to match properties for inbound cross-cluster connections.
        public let filters: [Filter]?
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial DescribeInboundConnections operation returns a nextToken, you can include the returned nextToken in subsequent DescribeInboundConnections operations, which returns results in the next page.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeInboundConnectionsResponse: AWSDecodableShape {
        /// List of inbound connections.
        public let connections: [InboundConnection]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(connections: [InboundConnection]? = nil, nextToken: String? = nil) {
            self.connections = connections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeInstanceTypeLimitsRequest: AWSEncodableShape {
        /// The name of the domain. Only specify if you need the limits for an existing domain.
        public let domainName: String?
        /// Version of OpenSearch or Elasticsearch, in the format Elasticsearch_X.Y or OpenSearch_X.Y. Defaults to the latest version of OpenSearch.
        public let engineVersion: String
        /// The OpenSearch Service instance type for which you need limit information.
        public let instanceType: OpenSearchPartitionInstanceType

        public init(domainName: String? = nil, engineVersion: String, instanceType: OpenSearchPartitionInstanceType) {
            self.domainName = domainName
            self.engineVersion = engineVersion
            self.instanceType = instanceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domainName, key: "domainName")
            request.encodePath(self.engineVersion, key: "EngineVersion")
            request.encodePath(self.instanceType, key: "InstanceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 18)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 14)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceTypeLimitsResponse: AWSDecodableShape {
        /// Map that contains all applicable instance type limits.data refers to data nodes.master refers to dedicated master nodes.
        public let limitsByRole: [String: Limits]?

        public init(limitsByRole: [String: Limits]? = nil) {
            self.limitsByRole = limitsByRole
        }

        private enum CodingKeys: String, CodingKey {
            case limitsByRole = "LimitsByRole"
        }
    }

    public struct DescribeOutboundConnectionsRequest: AWSEncodableShape {
        /// List of filter names and values that you can use for requests.
        public let filters: [Filter]?
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial DescribeOutboundConnections operation returns a nextToken, you can include the returned nextToken in subsequent DescribeOutboundConnections operations, which returns results in the next page.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeOutboundConnectionsResponse: AWSDecodableShape {
        /// List of outbound connections that match the filter criteria.
        public let connections: [OutboundConnection]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(connections: [OutboundConnection]? = nil, nextToken: String? = nil) {
            self.connections = connections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case nextToken = "NextToken"
        }
    }

    public struct DescribePackagesFilter: AWSEncodableShape {
        /// Any field from PackageDetails.
        public let name: DescribePackagesFilterName?
        /// A non-empty list of values for the specified filter field.
        public let value: [String]?

        public init(name: DescribePackagesFilterName? = nil, value: [String]? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value?.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^[0-9a-zA-Z\\*\\.\\_\\\\\\/\\?-]+$")
            }
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct DescribePackagesRequest: AWSEncodableShape {
        /// Only returns packages that match the DescribePackagesFilterList values.
        public let filters: [DescribePackagesFilter]?
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial DescribePackageFilters operation returns a nextToken, you can include the returned nextToken in subsequent DescribePackageFilters operations, which returns results in the next page.
        public let nextToken: String?

        public init(filters: [DescribePackagesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribePackagesResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// Basic information about a package.
        public let packageDetailsList: [PackageDetails]?

        public init(nextToken: String? = nil, packageDetailsList: [PackageDetails]? = nil) {
            self.nextToken = nextToken
            self.packageDetailsList = packageDetailsList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case packageDetailsList = "PackageDetailsList"
        }
    }

    public struct DescribeReservedInstanceOfferingsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial DescribeReservedInstanceOfferings operation returns a nextToken, you can include the returned nextToken in subsequent DescribeReservedInstanceOfferings operations, which returns results in the next page.
        public let nextToken: String?
        /// The Reserved Instance identifier filter value. Use this parameter to show only the available instance types that match the specified reservation identifier.
        public let reservedInstanceOfferingId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, reservedInstanceOfferingId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.reservedInstanceOfferingId, key: "offeringId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, max: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, min: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReservedInstanceOfferingsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// List of Reserved Instance offerings.
        public let reservedInstanceOfferings: [ReservedInstanceOffering]?

        public init(nextToken: String? = nil, reservedInstanceOfferings: [ReservedInstanceOffering]? = nil) {
            self.nextToken = nextToken
            self.reservedInstanceOfferings = reservedInstanceOfferings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reservedInstanceOfferings = "ReservedInstanceOfferings"
        }
    }

    public struct DescribeReservedInstancesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial DescribeReservedInstances operation returns a nextToken, you can include the returned nextToken in subsequent DescribeReservedInstances operations, which returns results in the next page.
        public let nextToken: String?
        /// The reserved instance identifier filter value. Use this parameter to show only the reservation that matches the specified reserved OpenSearch instance ID.
        public let reservedInstanceId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, reservedInstanceId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.reservedInstanceId = reservedInstanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.reservedInstanceId, key: "reservationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.reservedInstanceId, name: "reservedInstanceId", parent: name, max: 36)
            try self.validate(self.reservedInstanceId, name: "reservedInstanceId", parent: name, min: 36)
            try self.validate(self.reservedInstanceId, name: "reservedInstanceId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReservedInstancesResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// List of Reserved Instances in the current Region.
        public let reservedInstances: [ReservedInstance]?

        public init(nextToken: String? = nil, reservedInstances: [ReservedInstance]? = nil) {
            self.nextToken = nextToken
            self.reservedInstances = reservedInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reservedInstances = "ReservedInstances"
        }
    }

    public struct DescribeVpcEndpointsRequest: AWSEncodableShape {
        /// The unique identifiers of the endpoints to get information about.
        public let vpcEndpointIds: [String]

        public init(vpcEndpointIds: [String]) {
            self.vpcEndpointIds = vpcEndpointIds
        }

        public func validate(name: String) throws {
            try self.vpcEndpointIds.forEach {
                try validate($0, name: "vpcEndpointIds[]", parent: name, max: 256)
                try validate($0, name: "vpcEndpointIds[]", parent: name, min: 5)
                try validate($0, name: "vpcEndpointIds[]", parent: name, pattern: "^aos-[a-zA-Z0-9]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointIds = "VpcEndpointIds"
        }
    }

    public struct DescribeVpcEndpointsResponse: AWSDecodableShape {
        /// Any errors associated with the request.
        public let vpcEndpointErrors: [VpcEndpointError]
        /// Information about each requested VPC endpoint.
        public let vpcEndpoints: [VpcEndpoint]

        public init(vpcEndpointErrors: [VpcEndpointError], vpcEndpoints: [VpcEndpoint]) {
            self.vpcEndpointErrors = vpcEndpointErrors
            self.vpcEndpoints = vpcEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointErrors = "VpcEndpointErrors"
            case vpcEndpoints = "VpcEndpoints"
        }
    }

    public struct DissociatePackageRequest: AWSEncodableShape {
        /// Name of the domain to dissociate the package from.
        public let domainName: String
        /// Internal ID of the package to dissociate from the domain. Use ListPackagesForDomain to find this value.
        public let packageID: String

        public init(domainName: String, packageID: String) {
            self.domainName = domainName
            self.packageID = packageID
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.packageID, key: "PackageID")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.packageID, name: "packageID", parent: name, pattern: "^([FG][0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DissociatePackageResponse: AWSDecodableShape {
        ///  Information about a package that has been dissociated from the domain.
        public let domainPackageDetails: DomainPackageDetails?

        public init(domainPackageDetails: DomainPackageDetails? = nil) {
            self.domainPackageDetails = domainPackageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetails = "DomainPackageDetails"
        }
    }

    public struct DomainConfig: AWSDecodableShape {
        /// Specifies the access policies for the domain.
        public let accessPolicies: AccessPoliciesStatus?
        /// Key-value pairs to specify advanced configuration options. For more information, see Advanced options.
        public let advancedOptions: AdvancedOptionsStatus?
        /// Container for fine-grained access control settings for the domain.
        public let advancedSecurityOptions: AdvancedSecurityOptionsStatus?
        /// Container for Auto-Tune settings for the domain.
        public let autoTuneOptions: AutoTuneOptionsStatus?
        /// Container for information about the progress of an existing configuration change.
        public let changeProgressDetails: ChangeProgressDetails?
        /// Container for the cluster configuration of a the domain.
        public let clusterConfig: ClusterConfigStatus?
        /// Container for Amazon Cognito options for the domain.
        public let cognitoOptions: CognitoOptionsStatus?
        /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
        public let domainEndpointOptions: DomainEndpointOptionsStatus?
        /// Container for EBS options configured for the domain.
        public let ebsOptions: EBSOptionsStatus?
        /// Key-value pairs to enable encryption at rest.
        public let encryptionAtRestOptions: EncryptionAtRestOptionsStatus?
        /// The OpenSearch or Elasticsearch version that the domain is running.
        public let engineVersion: VersionStatus?
        /// Choose either dual stack or IPv4 as your IP address type.  Dual stack allows you to share domain resources across IPv4 and IPv6 address types, and is the recommended option.  If you set your IP address type to dual stack, you can't change your address type later.
        public let ipAddressType: IPAddressTypeStatus?
        /// Key-value pairs to configure log publishing.
        public let logPublishingOptions: LogPublishingOptionsStatus?
        /// Information about the domain properties that are currently being modified.
        public let modifyingProperties: [ModifyingProperties]?
        /// Whether node-to-node encryption is enabled or disabled.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptionsStatus?
        /// Container for off-peak window options for the domain.
        public let offPeakWindowOptions: OffPeakWindowOptionsStatus?
        /// DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.
        public let snapshotOptions: SnapshotOptionsStatus?
        /// Software update options for the domain.
        public let softwareUpdateOptions: SoftwareUpdateOptionsStatus?
        /// The current VPC options for the domain and the status of any updates to their configuration.
        public let vpcOptions: VPCDerivedInfoStatus?

        public init(accessPolicies: AccessPoliciesStatus? = nil, advancedOptions: AdvancedOptionsStatus? = nil, advancedSecurityOptions: AdvancedSecurityOptionsStatus? = nil, autoTuneOptions: AutoTuneOptionsStatus? = nil, changeProgressDetails: ChangeProgressDetails? = nil, clusterConfig: ClusterConfigStatus? = nil, cognitoOptions: CognitoOptionsStatus? = nil, domainEndpointOptions: DomainEndpointOptionsStatus? = nil, ebsOptions: EBSOptionsStatus? = nil, encryptionAtRestOptions: EncryptionAtRestOptionsStatus? = nil, engineVersion: VersionStatus? = nil, ipAddressType: IPAddressTypeStatus? = nil, logPublishingOptions: LogPublishingOptionsStatus? = nil, modifyingProperties: [ModifyingProperties]? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptionsStatus? = nil, offPeakWindowOptions: OffPeakWindowOptionsStatus? = nil, snapshotOptions: SnapshotOptionsStatus? = nil, softwareUpdateOptions: SoftwareUpdateOptionsStatus? = nil, vpcOptions: VPCDerivedInfoStatus? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.changeProgressDetails = changeProgressDetails
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.ebsOptions = ebsOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.ipAddressType = ipAddressType
            self.logPublishingOptions = logPublishingOptions
            self.modifyingProperties = modifyingProperties
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.offPeakWindowOptions = offPeakWindowOptions
            self.snapshotOptions = snapshotOptions
            self.softwareUpdateOptions = softwareUpdateOptions
            self.vpcOptions = vpcOptions
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case autoTuneOptions = "AutoTuneOptions"
            case changeProgressDetails = "ChangeProgressDetails"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case domainEndpointOptions = "DomainEndpointOptions"
            case ebsOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case engineVersion = "EngineVersion"
            case ipAddressType = "IPAddressType"
            case logPublishingOptions = "LogPublishingOptions"
            case modifyingProperties = "ModifyingProperties"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case offPeakWindowOptions = "OffPeakWindowOptions"
            case snapshotOptions = "SnapshotOptions"
            case softwareUpdateOptions = "SoftwareUpdateOptions"
            case vpcOptions = "VPCOptions"
        }
    }

    public struct DomainEndpointOptions: AWSEncodableShape & AWSDecodableShape {
        /// The fully qualified URL for the custom endpoint.
        public let customEndpoint: String?
        /// The ARN for your security certificate, managed in Amazon Web Services Certificate Manager (ACM).
        public let customEndpointCertificateArn: String?
        /// Whether to enable a custom endpoint for the domain.
        public let customEndpointEnabled: Bool?
        /// True to require that all traffic to the domain arrive over HTTPS.
        public let enforceHTTPS: Bool?
        /// Specify the TLS security policy to apply to the HTTPS endpoint of the domain. The policy can be one of the following values:    Policy-Min-TLS-1-0-2019-07: TLS security policy that supports TLS version 1.0 to TLS version 1.2    Policy-Min-TLS-1-2-2019-07: TLS security policy that supports only TLS version 1.2    Policy-Min-TLS-1-2-PFS-2023-10: TLS security policy that supports TLS version 1.2 to TLS version 1.3 with perfect forward secrecy cipher suites
        public let tlsSecurityPolicy: TLSSecurityPolicy?

        public init(customEndpoint: String? = nil, customEndpointCertificateArn: String? = nil, customEndpointEnabled: Bool? = nil, enforceHTTPS: Bool? = nil, tlsSecurityPolicy: TLSSecurityPolicy? = nil) {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tlsSecurityPolicy = tlsSecurityPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, max: 255)
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, min: 1)
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, max: 2048)
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, min: 20)
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case customEndpoint = "CustomEndpoint"
            case customEndpointCertificateArn = "CustomEndpointCertificateArn"
            case customEndpointEnabled = "CustomEndpointEnabled"
            case enforceHTTPS = "EnforceHTTPS"
            case tlsSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct DomainEndpointOptionsStatus: AWSDecodableShape {
        /// Options to configure the endpoint for a domain.
        public let options: DomainEndpointOptions
        /// The status of the endpoint options for a domain.
        public let status: OptionStatus

        public init(options: DomainEndpointOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct DomainInfo: AWSDecodableShape {
        /// Name of the domain.
        public let domainName: String?
        /// The type of search engine that the domain is running.OpenSearch for an OpenSearch engine, or Elasticsearch for a legacy Elasticsearch OSS engine.
        public let engineType: EngineType?

        public init(domainName: String? = nil, engineType: EngineType? = nil) {
            self.domainName = domainName
            self.engineType = engineType
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case engineType = "EngineType"
        }
    }

    public struct DomainInformationContainer: AWSEncodableShape & AWSDecodableShape {
        /// Information about an Amazon OpenSearch Service domain.
        public let awsDomainInformation: AWSDomainInformation?

        public init(awsDomainInformation: AWSDomainInformation? = nil) {
            self.awsDomainInformation = awsDomainInformation
        }

        public func validate(name: String) throws {
            try self.awsDomainInformation?.validate(name: "\(name).awsDomainInformation")
        }

        private enum CodingKeys: String, CodingKey {
            case awsDomainInformation = "AWSDomainInformation"
        }
    }

    public struct DomainMaintenanceDetails: AWSDecodableShape {
        /// The name of the action.
        public let action: MaintenanceType?
        /// The time at which the action was created.
        public let createdAt: Date?
        /// The name of the domain.
        public let domainName: String?
        /// The ID of the requested action.
        public let maintenanceId: String?
        /// The ID of the data node.
        public let nodeId: String?
        /// The status of the action.
        public let status: MaintenanceStatus?
        /// The status message for the action.
        public let statusMessage: String?
        /// The time at which the action was updated.
        public let updatedAt: Date?

        public init(action: MaintenanceType? = nil, createdAt: Date? = nil, domainName: String? = nil, maintenanceId: String? = nil, nodeId: String? = nil, status: MaintenanceStatus? = nil, statusMessage: String? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.createdAt = createdAt
            self.domainName = domainName
            self.maintenanceId = maintenanceId
            self.nodeId = nodeId
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case maintenanceId = "MaintenanceId"
            case nodeId = "NodeId"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct DomainNodesStatus: AWSDecodableShape {
        /// The Availability Zone of the node.
        public let availabilityZone: String?
        /// The instance type information of the node.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// The ID of the node.
        public let nodeId: String?
        /// Indicates if the node is active or in standby.
        public let nodeStatus: NodeStatus?
        /// Indicates whether the nodes is a data, master, or ultrawarm node.
        public let nodeType: NodeType?
        /// The storage size of the node, in GiB.
        public let storageSize: String?
        /// Indicates if the node has EBS or instance storage.
        public let storageType: String?
        /// If the nodes has EBS storage, indicates if the volume type is GP2 or GP3. Only applicable for data nodes.
        public let storageVolumeType: VolumeType?

        public init(availabilityZone: String? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, nodeId: String? = nil, nodeStatus: NodeStatus? = nil, nodeType: NodeType? = nil, storageSize: String? = nil, storageType: String? = nil, storageVolumeType: VolumeType? = nil) {
            self.availabilityZone = availabilityZone
            self.instanceType = instanceType
            self.nodeId = nodeId
            self.nodeStatus = nodeStatus
            self.nodeType = nodeType
            self.storageSize = storageSize
            self.storageType = storageType
            self.storageVolumeType = storageVolumeType
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case instanceType = "InstanceType"
            case nodeId = "NodeId"
            case nodeStatus = "NodeStatus"
            case nodeType = "NodeType"
            case storageSize = "StorageSize"
            case storageType = "StorageType"
            case storageVolumeType = "StorageVolumeType"
        }
    }

    public struct DomainPackageDetails: AWSDecodableShape {
        /// Name of the domain that the package is associated with.
        public let domainName: String?
        /// State of the association.
        public let domainPackageStatus: DomainPackageStatus?
        /// Additional information if the package is in an error state. Null otherwise.
        public let errorDetails: ErrorDetails?
        /// Timestamp of the most recent update to the package association status.
        public let lastUpdated: Date?
        /// Internal ID of the package.
        public let packageID: String?
        /// User-specified name of the package.
        public let packageName: String?
        /// The type of package.
        public let packageType: PackageType?
        /// The current version of the package.
        public let packageVersion: String?
        /// The relative path of the package on the OpenSearch Service cluster nodes. This is synonym_path when the package is for synonym files.
        public let referencePath: String?

        public init(domainName: String? = nil, domainPackageStatus: DomainPackageStatus? = nil, errorDetails: ErrorDetails? = nil, lastUpdated: Date? = nil, packageID: String? = nil, packageName: String? = nil, packageType: PackageType? = nil, packageVersion: String? = nil, referencePath: String? = nil) {
            self.domainName = domainName
            self.domainPackageStatus = domainPackageStatus
            self.errorDetails = errorDetails
            self.lastUpdated = lastUpdated
            self.packageID = packageID
            self.packageName = packageName
            self.packageType = packageType
            self.packageVersion = packageVersion
            self.referencePath = referencePath
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case domainPackageStatus = "DomainPackageStatus"
            case errorDetails = "ErrorDetails"
            case lastUpdated = "LastUpdated"
            case packageID = "PackageID"
            case packageName = "PackageName"
            case packageType = "PackageType"
            case packageVersion = "PackageVersion"
            case referencePath = "ReferencePath"
        }
    }

    public struct DomainStatus: AWSDecodableShape {
        /// Identity and Access Management (IAM) policy document specifying the access policies for the domain.
        public let accessPolicies: String?
        /// Key-value pairs that specify advanced configuration options.
        public let advancedOptions: [String: String]?
        /// Settings for fine-grained access control.
        public let advancedSecurityOptions: AdvancedSecurityOptions?
        /// The Amazon Resource Name (ARN) of the domain. For more information, see IAM identifiers in the AWS Identity and Access Management User Guide.
        public let arn: String
        /// Auto-Tune settings for the domain.
        public let autoTuneOptions: AutoTuneOptionsOutput?
        /// Information about a configuration change happening on the domain.
        public let changeProgressDetails: ChangeProgressDetails?
        /// Container for the cluster configuration of the domain.
        public let clusterConfig: ClusterConfig
        /// Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.
        public let cognitoOptions: CognitoOptions?
        /// Creation status of an OpenSearch Service domain. True if domain creation is complete. False if domain creation is still in progress.
        public let created: Bool?
        /// Deletion status of an OpenSearch Service domain. True if domain deletion is complete. False if domain deletion is still in progress. Once deletion is complete, the status of the domain is no longer returned.
        public let deleted: Bool?
        /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
        public let domainEndpointOptions: DomainEndpointOptions?
        /// Unique identifier for the domain.
        public let domainId: String
        /// Name of the domain. Domain names are unique across all domains owned by the same account within an Amazon Web Services Region.
        public let domainName: String
        /// The status of any changes that are currently in progress for the domain.
        public let domainProcessingStatus: DomainProcessingStatusType?
        /// Container for EBS-based storage settings for the domain.
        public let ebsOptions: EBSOptions?
        /// Encryption at rest settings for the domain.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// Domain-specific endpoint used to submit index, search, and data upload requests to the domain.
        public let endpoint: String?
        /// The key-value pair that exists if the OpenSearch Service domain uses VPC endpoints. Example key, value: 'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'.
        public let endpoints: [String: String]?
        /// If IPAddressType to set to dualstack, a version 2 domain endpoint is provisioned. This endpoint functions like a normal endpoint, except that it works with both IPv4 and IPv6 IP addresses. Normal endpoints work only with IPv4 IP addresses.
        public let endpointV2: String?
        /// Version of OpenSearch or Elasticsearch that the domain is running, in the format Elasticsearch_X.Y or OpenSearch_X.Y.
        public let engineVersion: String?
        /// The type of IP addresses supported by the endpoint for the domain.
        public let ipAddressType: IPAddressType?
        /// Log publishing options for the domain.
        public let logPublishingOptions: [LogType: LogPublishingOption]?
        /// Information about the domain properties that are currently being modified.
        public let modifyingProperties: [ModifyingProperties]?
        /// Whether node-to-node encryption is enabled or disabled.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
        /// Options that specify a custom 10-hour window during which OpenSearch Service can perform configuration changes on the domain.
        public let offPeakWindowOptions: OffPeakWindowOptions?
        /// The status of the domain configuration. True if OpenSearch Service is processing configuration changes. False if the configuration is active.
        public let processing: Bool?
        /// The current status of the domain's service software.
        public let serviceSoftwareOptions: ServiceSoftwareOptions?
        /// DEPRECATED. Container for parameters required to configure automated snapshots of domain indexes.
        public let snapshotOptions: SnapshotOptions?
        /// Service software update options for the domain.
        public let softwareUpdateOptions: SoftwareUpdateOptions?
        /// The status of a domain version upgrade to a new version of OpenSearch or Elasticsearch. True if OpenSearch Service is in the process of a version upgrade. False if the configuration is active.
        public let upgradeProcessing: Bool?
        /// The VPC configuration for the domain.
        public let vpcOptions: VPCDerivedInfo?

        public init(accessPolicies: String? = nil, advancedOptions: [String: String]? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, arn: String, autoTuneOptions: AutoTuneOptionsOutput? = nil, changeProgressDetails: ChangeProgressDetails? = nil, clusterConfig: ClusterConfig, cognitoOptions: CognitoOptions? = nil, created: Bool? = nil, deleted: Bool? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, domainId: String, domainName: String, domainProcessingStatus: DomainProcessingStatusType? = nil, ebsOptions: EBSOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, endpoint: String? = nil, endpoints: [String: String]? = nil, endpointV2: String? = nil, engineVersion: String? = nil, ipAddressType: IPAddressType? = nil, logPublishingOptions: [LogType: LogPublishingOption]? = nil, modifyingProperties: [ModifyingProperties]? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, offPeakWindowOptions: OffPeakWindowOptions? = nil, processing: Bool? = nil, serviceSoftwareOptions: ServiceSoftwareOptions? = nil, snapshotOptions: SnapshotOptions? = nil, softwareUpdateOptions: SoftwareUpdateOptions? = nil, upgradeProcessing: Bool? = nil, vpcOptions: VPCDerivedInfo? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.arn = arn
            self.autoTuneOptions = autoTuneOptions
            self.changeProgressDetails = changeProgressDetails
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.created = created
            self.deleted = deleted
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.domainProcessingStatus = domainProcessingStatus
            self.ebsOptions = ebsOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.endpointV2 = endpointV2
            self.engineVersion = engineVersion
            self.ipAddressType = ipAddressType
            self.logPublishingOptions = logPublishingOptions
            self.modifyingProperties = modifyingProperties
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.offPeakWindowOptions = offPeakWindowOptions
            self.processing = processing
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.snapshotOptions = snapshotOptions
            self.softwareUpdateOptions = softwareUpdateOptions
            self.upgradeProcessing = upgradeProcessing
            self.vpcOptions = vpcOptions
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case arn = "ARN"
            case autoTuneOptions = "AutoTuneOptions"
            case changeProgressDetails = "ChangeProgressDetails"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case created = "Created"
            case deleted = "Deleted"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case domainProcessingStatus = "DomainProcessingStatus"
            case ebsOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case endpoint = "Endpoint"
            case endpoints = "Endpoints"
            case endpointV2 = "EndpointV2"
            case engineVersion = "EngineVersion"
            case ipAddressType = "IPAddressType"
            case logPublishingOptions = "LogPublishingOptions"
            case modifyingProperties = "ModifyingProperties"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case offPeakWindowOptions = "OffPeakWindowOptions"
            case processing = "Processing"
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
            case snapshotOptions = "SnapshotOptions"
            case softwareUpdateOptions = "SoftwareUpdateOptions"
            case upgradeProcessing = "UpgradeProcessing"
            case vpcOptions = "VPCOptions"
        }
    }

    public struct DryRunProgressStatus: AWSDecodableShape {
        /// The timestamp when the dry run was initiated.
        public let creationDate: String
        /// The unique identifier of the dry run.
        public let dryRunId: String
        /// The current status of the dry run.
        public let dryRunStatus: String
        /// The timestamp when the dry run was last updated.
        public let updateDate: String
        /// Any validation failures that occurred as a result of the dry run.
        public let validationFailures: [ValidationFailure]?

        public init(creationDate: String, dryRunId: String, dryRunStatus: String, updateDate: String, validationFailures: [ValidationFailure]? = nil) {
            self.creationDate = creationDate
            self.dryRunId = dryRunId
            self.dryRunStatus = dryRunStatus
            self.updateDate = updateDate
            self.validationFailures = validationFailures
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case dryRunId = "DryRunId"
            case dryRunStatus = "DryRunStatus"
            case updateDate = "UpdateDate"
            case validationFailures = "ValidationFailures"
        }
    }

    public struct DryRunResults: AWSDecodableShape {
        ///  Specifies the way in which OpenSearch Service will apply an update. Possible values are:    Blue/Green - The update requires a blue/green deployment.    DynamicUpdate - No blue/green deployment required    Undetermined - The domain is in the middle of an update and can't predict the deployment type. Try again after the update is complete.    None - The request doesn't include any configuration changes.
        public let deploymentType: String?
        /// A message corresponding to the deployment type.
        public let message: String?

        public init(deploymentType: String? = nil, message: String? = nil) {
            self.deploymentType = deploymentType
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentType = "DeploymentType"
            case message = "Message"
        }
    }

    public struct Duration: AWSEncodableShape & AWSDecodableShape {
        /// The unit of measurement for the duration of a maintenance schedule.
        public let unit: TimeUnit?
        /// Integer to specify the value of a maintenance schedule duration.
        public let value: Int64?

        public init(unit: TimeUnit? = nil, value: Int64? = nil) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 24)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct EBSOptions: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether EBS volumes are attached to data nodes in an OpenSearch Service domain.
        public let ebsEnabled: Bool?
        /// Specifies the baseline input/output (I/O) performance of EBS volumes attached to data nodes. Applicable only for the gp3 and provisioned IOPS EBS volume types.
        public let iops: Int?
        /// Specifies the throughput (in MiB/s) of the EBS volumes attached to data nodes. Applicable only for the gp3 volume type.
        public let throughput: Int?
        /// Specifies the size (in GiB) of EBS volumes attached to data nodes.
        public let volumeSize: Int?
        /// Specifies the type of EBS volumes attached to data nodes.
        public let volumeType: VolumeType?

        public init(ebsEnabled: Bool? = nil, iops: Int? = nil, throughput: Int? = nil, volumeSize: Int? = nil, volumeType: VolumeType? = nil) {
            self.ebsEnabled = ebsEnabled
            self.iops = iops
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case ebsEnabled = "EBSEnabled"
            case iops = "Iops"
            case throughput = "Throughput"
            case volumeSize = "VolumeSize"
            case volumeType = "VolumeType"
        }
    }

    public struct EBSOptionsStatus: AWSDecodableShape {
        /// The configured EBS options for the specified domain.
        public let options: EBSOptions
        /// The status of the EBS options for the specified domain.
        public let status: OptionStatus

        public init(options: EBSOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct EncryptionAtRestOptions: AWSEncodableShape & AWSDecodableShape {
        /// True to enable encryption at rest.
        public let enabled: Bool?
        /// The KMS key ID. Takes the form 1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a.
        public let kmsKeyId: String?

        public init(enabled: Bool? = nil, kmsKeyId: String? = nil) {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 500)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct EncryptionAtRestOptionsStatus: AWSDecodableShape {
        /// Encryption at rest options for the specified domain.
        public let options: EncryptionAtRestOptions
        /// The status of the encryption at rest options for the specified domain.
        public let status: OptionStatus

        public init(options: EncryptionAtRestOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct EnvironmentInfo: AWSDecodableShape {
        ///  A list of AvailabilityZoneInfo for the domain.
        public let availabilityZoneInformation: [AvailabilityZoneInfo]?

        public init(availabilityZoneInformation: [AvailabilityZoneInfo]? = nil) {
            self.availabilityZoneInformation = availabilityZoneInformation
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneInformation = "AvailabilityZoneInformation"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        /// A message describing the error.
        public let errorMessage: String?
        /// The type of error that occurred.
        public let errorType: String?

        public init(errorMessage: String? = nil, errorType: String? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorType = "ErrorType"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The name of the filter.
        public let name: String?
        /// One or more values for the filter.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]+$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]+$")
            }
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct GetCompatibleVersionsRequest: AWSEncodableShape {
        /// The name of an existing domain. Provide this parameter to limit the results to a single domain.
        public let domainName: String?

        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domainName, key: "domainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCompatibleVersionsResponse: AWSDecodableShape {
        /// A map of OpenSearch or Elasticsearch versions and the versions you can upgrade them to.
        public let compatibleVersions: [CompatibleVersionsMap]?

        public init(compatibleVersions: [CompatibleVersionsMap]? = nil) {
            self.compatibleVersions = compatibleVersions
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleVersions = "CompatibleVersions"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String
        /// The name of the data source to get information about.
        public let name: String

        public init(domainName: String, name: String) {
            self.domainName = domainName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {
        /// The type of data source.
        public let dataSourceType: DataSourceType?
        /// A description of the data source.
        public let description: String?
        /// The name of the data source.
        public let name: String?

        public init(dataSourceType: DataSourceType? = nil, description: String? = nil, name: String? = nil) {
            self.dataSourceType = dataSourceType
            self.description = description
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType = "DataSourceType"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct GetDomainMaintenanceStatusRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String
        /// The request ID of the maintenance action.
        public let maintenanceId: String

        public init(domainName: String, maintenanceId: String) {
            self.domainName = domainName
            self.maintenanceId = maintenanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maintenanceId, key: "maintenanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maintenanceId, name: "maintenanceId", parent: name, max: 100)
            try self.validate(self.maintenanceId, name: "maintenanceId", parent: name, min: 1)
            try self.validate(self.maintenanceId, name: "maintenanceId", parent: name, pattern: "^([\\s\\S]*)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainMaintenanceStatusResponse: AWSDecodableShape {
        /// The action name.
        public let action: MaintenanceType?
        /// The time at which the action was created.
        public let createdAt: Date?
        /// The node ID of the maintenance action.
        public let nodeId: String?
        /// The status of the maintenance action.
        public let status: MaintenanceStatus?
        /// The status message of the maintenance action.
        public let statusMessage: String?
        /// The time at which the action was updated.
        public let updatedAt: Date?

        public init(action: MaintenanceType? = nil, createdAt: Date? = nil, nodeId: String? = nil, status: MaintenanceStatus? = nil, statusMessage: String? = nil, updatedAt: Date? = nil) {
            self.action = action
            self.createdAt = createdAt
            self.nodeId = nodeId
            self.status = status
            self.statusMessage = statusMessage
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case createdAt = "CreatedAt"
            case nodeId = "NodeId"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetPackageVersionHistoryRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial GetPackageVersionHistory operation returns a nextToken, you can include the returned nextToken in subsequent GetPackageVersionHistory operations, which returns results in the next page.
        public let nextToken: String?
        /// The unique identifier of the package.
        public let packageID: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, packageID: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packageID = packageID
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.packageID, key: "PackageID")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.packageID, name: "packageID", parent: name, pattern: "^([FG][0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPackageVersionHistoryResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The unique identifier of the package.
        public let packageID: String?
        /// A list of package versions, along with their creation time and commit message.
        public let packageVersionHistoryList: [PackageVersionHistory]?

        public init(nextToken: String? = nil, packageID: String? = nil, packageVersionHistoryList: [PackageVersionHistory]? = nil) {
            self.nextToken = nextToken
            self.packageID = packageID
            self.packageVersionHistoryList = packageVersionHistoryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case packageID = "PackageID"
            case packageVersionHistoryList = "PackageVersionHistoryList"
        }
    }

    public struct GetUpgradeHistoryRequest: AWSEncodableShape {
        /// The name of an existing domain.
        public let domainName: String
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial GetUpgradeHistory operation returns a nextToken, you can include the returned nextToken in subsequent GetUpgradeHistory operations, which returns results in the next page.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUpgradeHistoryResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// A list of objects corresponding to each upgrade or upgrade eligibility check performed on a domain.
        public let upgradeHistories: [UpgradeHistory]?

        public init(nextToken: String? = nil, upgradeHistories: [UpgradeHistory]? = nil) {
            self.nextToken = nextToken
            self.upgradeHistories = upgradeHistories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case upgradeHistories = "UpgradeHistories"
        }
    }

    public struct GetUpgradeStatusRequest: AWSEncodableShape {
        /// The domain of the domain to get upgrade status information for.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUpgradeStatusResponse: AWSDecodableShape {
        /// The status of the current step that an upgrade is on.
        public let stepStatus: UpgradeStatus?
        /// A string that describes the update.
        public let upgradeName: String?
        /// One of three steps that an upgrade or upgrade eligibility check goes through.
        public let upgradeStep: UpgradeStep?

        public init(stepStatus: UpgradeStatus? = nil, upgradeName: String? = nil, upgradeStep: UpgradeStep? = nil) {
            self.stepStatus = stepStatus
            self.upgradeName = upgradeName
            self.upgradeStep = upgradeStep
        }

        private enum CodingKeys: String, CodingKey {
            case stepStatus = "StepStatus"
            case upgradeName = "UpgradeName"
            case upgradeStep = "UpgradeStep"
        }
    }

    public struct IPAddressTypeStatus: AWSDecodableShape {
        /// The IP address options for the domain.
        public let options: IPAddressType
        public let status: OptionStatus

        public init(options: IPAddressType, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct InboundConnection: AWSDecodableShape {
        /// The unique identifier of the connection.
        public let connectionId: String?
        /// The connection mode.
        public let connectionMode: ConnectionMode?
        /// The current status of the connection.
        public let connectionStatus: InboundConnectionStatus?
        /// Information about the source (local) domain.
        public let localDomainInfo: DomainInformationContainer?
        /// Information about the destination (remote) domain.
        public let remoteDomainInfo: DomainInformationContainer?

        public init(connectionId: String? = nil, connectionMode: ConnectionMode? = nil, connectionStatus: InboundConnectionStatus? = nil, localDomainInfo: DomainInformationContainer? = nil, remoteDomainInfo: DomainInformationContainer? = nil) {
            self.connectionId = connectionId
            self.connectionMode = connectionMode
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "ConnectionId"
            case connectionMode = "ConnectionMode"
            case connectionStatus = "ConnectionStatus"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct InboundConnectionStatus: AWSDecodableShape {
        /// Information about the connection.
        public let message: String?
        /// The status code for the connection. Can be one of the following:    PENDING_ACCEPTANCE - Inbound connection is not yet accepted by the remote domain owner.    APPROVED: Inbound connection is pending acceptance by the remote domain owner.    PROVISIONING: Inbound connection is being provisioned.    ACTIVE: Inbound connection is active and ready to use.    REJECTING: Inbound connection rejection is in process.    REJECTED: Inbound connection is rejected.    DELETING: Inbound connection deletion is in progress.    DELETED: Inbound connection is deleted and can no longer be used.
        public let statusCode: InboundConnectionStatusCode?

        public init(message: String? = nil, statusCode: InboundConnectionStatusCode? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct InstanceCountLimits: AWSDecodableShape {
        /// The minimum allowed number of instances.
        public let maximumInstanceCount: Int?
        /// The maximum allowed number of instances.
        public let minimumInstanceCount: Int?

        public init(maximumInstanceCount: Int? = nil, minimumInstanceCount: Int? = nil) {
            self.maximumInstanceCount = maximumInstanceCount
            self.minimumInstanceCount = minimumInstanceCount
        }

        private enum CodingKeys: String, CodingKey {
            case maximumInstanceCount = "MaximumInstanceCount"
            case minimumInstanceCount = "MinimumInstanceCount"
        }
    }

    public struct InstanceLimits: AWSDecodableShape {
        /// Limits on the number of instances that can be created for a given instance type.
        public let instanceCountLimits: InstanceCountLimits?

        public init(instanceCountLimits: InstanceCountLimits? = nil) {
            self.instanceCountLimits = instanceCountLimits
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCountLimits = "InstanceCountLimits"
        }
    }

    public struct InstanceTypeDetails: AWSDecodableShape {
        /// Whether fine-grained access control is supported for the instance type.
        public let advancedSecurityEnabled: Bool?
        /// Whether logging is supported for the instance type.
        public let appLogsEnabled: Bool?
        /// The supported Availability Zones for the instance type.
        public let availabilityZones: [String]?
        /// Whether Amazon Cognito access is supported for the instance type.
        public let cognitoEnabled: Bool?
        /// Whether encryption at rest and node-to-node encryption are supported for the instance type.
        public let encryptionEnabled: Bool?
        /// Whether the instance acts as a data node, a dedicated master node, or an UltraWarm node.
        public let instanceRole: [String]?
        /// The instance type.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// Whether UltraWarm is supported for the instance type.
        public let warmEnabled: Bool?

        public init(advancedSecurityEnabled: Bool? = nil, appLogsEnabled: Bool? = nil, availabilityZones: [String]? = nil, cognitoEnabled: Bool? = nil, encryptionEnabled: Bool? = nil, instanceRole: [String]? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, warmEnabled: Bool? = nil) {
            self.advancedSecurityEnabled = advancedSecurityEnabled
            self.appLogsEnabled = appLogsEnabled
            self.availabilityZones = availabilityZones
            self.cognitoEnabled = cognitoEnabled
            self.encryptionEnabled = encryptionEnabled
            self.instanceRole = instanceRole
            self.instanceType = instanceType
            self.warmEnabled = warmEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case advancedSecurityEnabled = "AdvancedSecurityEnabled"
            case appLogsEnabled = "AppLogsEnabled"
            case availabilityZones = "AvailabilityZones"
            case cognitoEnabled = "CognitoEnabled"
            case encryptionEnabled = "EncryptionEnabled"
            case instanceRole = "InstanceRole"
            case instanceType = "InstanceType"
            case warmEnabled = "WarmEnabled"
        }
    }

    public struct Limits: AWSDecodableShape {
        /// List of additional limits that are specific to a given instance type for each of its instance roles.
        public let additionalLimits: [AdditionalLimit]?
        /// The limits for a given instance type.
        public let instanceLimits: InstanceLimits?
        /// Storage-related attributes that are available for a given instance type.
        public let storageTypes: [StorageType]?

        public init(additionalLimits: [AdditionalLimit]? = nil, instanceLimits: InstanceLimits? = nil, storageTypes: [StorageType]? = nil) {
            self.additionalLimits = additionalLimits
            self.instanceLimits = instanceLimits
            self.storageTypes = storageTypes
        }

        private enum CodingKeys: String, CodingKey {
            case additionalLimits = "AdditionalLimits"
            case instanceLimits = "InstanceLimits"
            case storageTypes = "StorageTypes"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// A list of data sources associated with specified domain.
        public let dataSources: [DataSourceDetails]?

        public init(dataSources: [DataSourceDetails]? = nil) {
            self.dataSources = dataSources
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "DataSources"
        }
    }

    public struct ListDomainMaintenancesRequest: AWSEncodableShape {
        /// The name of the action.
        public let action: MaintenanceType?
        /// The name of the domain.
        public let domainName: String
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListDomainMaintenances operation returns a nextToken, include the returned nextToken in subsequent ListDomainMaintenances operations, which returns results in the next page.
        public let nextToken: String?
        /// The status of the action.
        public let status: MaintenanceStatus?

        public init(action: MaintenanceType? = nil, domainName: String, maxResults: Int? = nil, nextToken: String? = nil, status: MaintenanceStatus? = nil) {
            self.action = action
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.action, key: "action")
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainMaintenancesResponse: AWSDecodableShape {
        /// A list of the submitted maintenance actions.
        public let domainMaintenances: [DomainMaintenanceDetails]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(domainMaintenances: [DomainMaintenanceDetails]? = nil, nextToken: String? = nil) {
            self.domainMaintenances = domainMaintenances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domainMaintenances = "DomainMaintenances"
            case nextToken = "NextToken"
        }
    }

    public struct ListDomainNamesRequest: AWSEncodableShape {
        /// Filters the output by domain engine type.
        public let engineType: EngineType?

        public init(engineType: EngineType? = nil) {
            self.engineType = engineType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.engineType, key: "engineType")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainNamesResponse: AWSDecodableShape {
        /// The names of all OpenSearch Service domains owned by the current user and their respective engine types.
        public let domainNames: [DomainInfo]?

        public init(domainNames: [DomainInfo]? = nil) {
            self.domainNames = domainNames
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct ListDomainsForPackageRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListDomainsForPackage operation returns a nextToken, you can include the returned nextToken in subsequent ListDomainsForPackage operations, which returns results in the next page.
        public let nextToken: String?
        /// The unique identifier of the package for which to list associated domains.
        public let packageID: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, packageID: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packageID = packageID
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.packageID, key: "PackageID")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.packageID, name: "packageID", parent: name, pattern: "^([FG][0-9]+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsForPackageResponse: AWSDecodableShape {
        /// Information about all domains associated with a package.
        public let domainPackageDetailsList: [DomainPackageDetails]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(domainPackageDetailsList: [DomainPackageDetails]? = nil, nextToken: String? = nil) {
            self.domainPackageDetailsList = domainPackageDetailsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetailsList = "DomainPackageDetailsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListInstanceTypeDetailsRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String?
        /// The version of OpenSearch or Elasticsearch, in the format Elasticsearch_X.Y or OpenSearch_X.Y. Defaults to the latest version of OpenSearch.
        public let engineVersion: String
        /// An optional parameter that lists information for a given instance type.
        public let instanceType: String?
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListInstanceTypeDetails operation returns a nextToken, you can include the returned nextToken in subsequent ListInstanceTypeDetails operations, which returns results in the next page.
        public let nextToken: String?
        /// An optional parameter that specifies the Availability Zones for the domain.
        public let retrieveAZs: Bool?

        public init(domainName: String? = nil, engineVersion: String, instanceType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, retrieveAZs: Bool? = nil) {
            self.domainName = domainName
            self.engineVersion = engineVersion
            self.instanceType = instanceType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.retrieveAZs = retrieveAZs
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.domainName, key: "domainName")
            request.encodePath(self.engineVersion, key: "EngineVersion")
            request.encodeQuery(self.instanceType, key: "instanceType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.retrieveAZs, key: "retrieveAZs")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 18)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 14)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
            try self.validate(self.instanceType, name: "instanceType", parent: name, max: 40)
            try self.validate(self.instanceType, name: "instanceType", parent: name, min: 10)
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^.*\\..*\\.search$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstanceTypeDetailsResponse: AWSDecodableShape {
        /// Lists all supported instance types and features for the given OpenSearch or Elasticsearch version.
        public let instanceTypeDetails: [InstanceTypeDetails]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(instanceTypeDetails: [InstanceTypeDetails]? = nil, nextToken: String? = nil) {
            self.instanceTypeDetails = instanceTypeDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceTypeDetails = "InstanceTypeDetails"
            case nextToken = "NextToken"
        }
    }

    public struct ListPackagesForDomainRequest: AWSEncodableShape {
        /// The name of the domain for which you want to list associated packages.
        public let domainName: String
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListPackagesForDomain operation returns a nextToken, you can include the returned nextToken in subsequent ListPackagesForDomain operations, which returns results in the next page.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagesForDomainResponse: AWSDecodableShape {
        /// List of all packages associated with a domain.
        public let domainPackageDetailsList: [DomainPackageDetails]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(domainPackageDetailsList: [DomainPackageDetails]? = nil, nextToken: String? = nil) {
            self.domainPackageDetailsList = domainPackageDetailsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetailsList = "DomainPackageDetailsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListScheduledActionsRequest: AWSEncodableShape {
        /// The name of the domain.
        public let domainName: String
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListScheduledActions operation returns a nextToken, you can include the returned nextToken in subsequent ListScheduledActions operations, which returns results in the next page.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListScheduledActionsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// A list of actions that are scheduled for the domain.
        public let scheduledActions: [ScheduledAction]?

        public init(nextToken: String? = nil, scheduledActions: [ScheduledAction]? = nil) {
            self.nextToken = nextToken
            self.scheduledActions = scheduledActions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case scheduledActions = "ScheduledActions"
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the domain to view tags for.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.arn, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsResponse: AWSDecodableShape {
        /// List of resource tags associated with the specified domain.
        public let tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct ListVersionsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListVersions operation returns a nextToken, you can include the returned nextToken in subsequent ListVersions operations, which returns results in the next page.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVersionsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// A list of all versions of OpenSearch and Elasticsearch that Amazon OpenSearch Service supports.
        public let versions: [String]?

        public init(nextToken: String? = nil, versions: [String]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct ListVpcEndpointAccessRequest: AWSEncodableShape {
        /// The name of the OpenSearch Service domain to retrieve access information for.
        public let domainName: String
        /// If your initial ListVpcEndpointAccess operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpointAccess operations, which returns results in the next page.
        public let nextToken: String?

        public init(domainName: String, nextToken: String? = nil) {
            self.domainName = domainName
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVpcEndpointAccessResponse: AWSDecodableShape {
        /// A list of IAM principals that can currently access the domain.
        public let authorizedPrincipalList: [AuthorizedPrincipal]
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String

        public init(authorizedPrincipalList: [AuthorizedPrincipal], nextToken: String) {
            self.authorizedPrincipalList = authorizedPrincipalList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case authorizedPrincipalList = "AuthorizedPrincipalList"
            case nextToken = "NextToken"
        }
    }

    public struct ListVpcEndpointsForDomainRequest: AWSEncodableShape {
        /// The name of the domain to list associated VPC endpoints for.
        public let domainName: String
        /// If your initial ListEndpointsForDomain operation returns a nextToken, you can include the returned nextToken in subsequent ListEndpointsForDomain operations, which returns results in the next page.
        public let nextToken: String?

        public init(domainName: String, nextToken: String? = nil) {
            self.domainName = domainName
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVpcEndpointsForDomainResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String
        /// Information about each endpoint associated with the domain.
        public let vpcEndpointSummaryList: [VpcEndpointSummary]

        public init(nextToken: String, vpcEndpointSummaryList: [VpcEndpointSummary]) {
            self.nextToken = nextToken
            self.vpcEndpointSummaryList = vpcEndpointSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case vpcEndpointSummaryList = "VpcEndpointSummaryList"
        }
    }

    public struct ListVpcEndpointsRequest: AWSEncodableShape {
        /// If your initial ListVpcEndpoints operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpoints operations, which returns results in the next page.
        public let nextToken: String?

        public init(nextToken: String? = nil) {
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVpcEndpointsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Send the request again using the returned token to retrieve the next page.
        public let nextToken: String
        /// Information about each endpoint.
        public let vpcEndpointSummaryList: [VpcEndpointSummary]

        public init(nextToken: String, vpcEndpointSummaryList: [VpcEndpointSummary]) {
            self.nextToken = nextToken
            self.vpcEndpointSummaryList = vpcEndpointSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case vpcEndpointSummaryList = "VpcEndpointSummaryList"
        }
    }

    public struct LogPublishingOption: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the CloudWatch Logs group to publish logs to.
        public let cloudWatchLogsLogGroupArn: String?
        /// Whether the log should be published.
        public let enabled: Bool?

        public init(cloudWatchLogsLogGroupArn: String? = nil, enabled: Bool? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, max: 2048)
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, min: 20)
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case enabled = "Enabled"
        }
    }

    public struct LogPublishingOptionsStatus: AWSDecodableShape {
        /// The log publishing options configured for the domain.
        public let options: [LogType: LogPublishingOption]?
        /// The status of the log publishing options for the domain.
        public let status: OptionStatus?

        public init(options: [LogType: LogPublishingOption]? = nil, status: OptionStatus? = nil) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct MasterUserOptions: AWSEncodableShape {
        /// Amazon Resource Name (ARN) for the master user. Only specify if InternalUserDatabaseEnabled is false.
        public let masterUserARN: String?
        /// User name for the master user. Only specify if InternalUserDatabaseEnabled is true.
        public let masterUserName: String?
        /// Password for the master user. Only specify if InternalUserDatabaseEnabled is true.
        public let masterUserPassword: String?

        public init(masterUserARN: String? = nil, masterUserName: String? = nil, masterUserPassword: String? = nil) {
            self.masterUserARN = masterUserARN
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }

        public func validate(name: String) throws {
            try self.validate(self.masterUserARN, name: "masterUserARN", parent: name, max: 2048)
            try self.validate(self.masterUserARN, name: "masterUserARN", parent: name, min: 20)
            try self.validate(self.masterUserARN, name: "masterUserARN", parent: name, pattern: ".*")
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, max: 64)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, min: 1)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, pattern: ".*")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, max: 128)
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, min: 8)
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case masterUserARN = "MasterUserARN"
            case masterUserName = "MasterUserName"
            case masterUserPassword = "MasterUserPassword"
        }
    }

    public struct ModifyingProperties: AWSDecodableShape {
        /// The current value of the domain property that is being modified.
        public let activeValue: String?
        /// The name of the property that is currently being modified.
        public let name: String?
        /// The value that the property that is currently being modified will eventually have.
        public let pendingValue: String?
        /// The type of value that is currently being modified. Properties can have two types:    PLAIN_TEXT: Contain direct values such as "1", "True", or "c5.large.search".    STRINGIFIED_JSON: Contain content in JSON format, such as {"Enabled":"True"}".
        public let valueType: PropertyValueType?

        public init(activeValue: String? = nil, name: String? = nil, pendingValue: String? = nil, valueType: PropertyValueType? = nil) {
            self.activeValue = activeValue
            self.name = name
            self.pendingValue = pendingValue
            self.valueType = valueType
        }

        private enum CodingKeys: String, CodingKey {
            case activeValue = "ActiveValue"
            case name = "Name"
            case pendingValue = "PendingValue"
            case valueType = "ValueType"
        }
    }

    public struct NodeToNodeEncryptionOptions: AWSEncodableShape & AWSDecodableShape {
        /// True to enable node-to-node encryption.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct NodeToNodeEncryptionOptionsStatus: AWSDecodableShape {
        /// The node-to-node encryption options for the specified domain.
        public let options: NodeToNodeEncryptionOptions
        /// The status of the node-to-node encryption options for the specified domain.
        public let status: OptionStatus

        public init(options: NodeToNodeEncryptionOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct OffPeakWindow: AWSEncodableShape & AWSDecodableShape {
        /// A custom start time for the off-peak window, in Coordinated Universal Time (UTC). The window length will always be 10 hours, so you can't specify an end time. For example, if you specify 11:00 P.M. UTC as a start time, the end time will automatically be set to 9:00 A.M.
        public let windowStartTime: WindowStartTime?

        public init(windowStartTime: WindowStartTime? = nil) {
            self.windowStartTime = windowStartTime
        }

        public func validate(name: String) throws {
            try self.windowStartTime?.validate(name: "\(name).windowStartTime")
        }

        private enum CodingKeys: String, CodingKey {
            case windowStartTime = "WindowStartTime"
        }
    }

    public struct OffPeakWindowOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether to enable an off-peak window. This option is only available when modifying a domain created prior to February 16, 2023, not when creating a new domain. All domains created after this date have the off-peak window enabled by default. You can't disable the off-peak window after it's enabled for a domain.
        public let enabled: Bool?
        /// Off-peak window settings for the domain.
        public let offPeakWindow: OffPeakWindow?

        public init(enabled: Bool? = nil, offPeakWindow: OffPeakWindow? = nil) {
            self.enabled = enabled
            self.offPeakWindow = offPeakWindow
        }

        public func validate(name: String) throws {
            try self.offPeakWindow?.validate(name: "\(name).offPeakWindow")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case offPeakWindow = "OffPeakWindow"
        }
    }

    public struct OffPeakWindowOptionsStatus: AWSDecodableShape {
        /// The domain's off-peak window configuration.
        public let options: OffPeakWindowOptions?
        /// The current status of off-peak window options.
        public let status: OptionStatus?

        public init(options: OffPeakWindowOptions? = nil, status: OptionStatus? = nil) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct OptionStatus: AWSDecodableShape {
        /// The timestamp when the entity was created.
        public let creationDate: Date
        /// Indicates whether the entity is being deleted.
        public let pendingDeletion: Bool?
        /// The state of the entity.
        public let state: OptionState
        /// The timestamp of the last time the entity was updated.
        public let updateDate: Date
        /// The latest version of the entity.
        public let updateVersion: Int?

        public init(creationDate: Date, pendingDeletion: Bool? = nil, state: OptionState, updateDate: Date, updateVersion: Int? = nil) {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case pendingDeletion = "PendingDeletion"
            case state = "State"
            case updateDate = "UpdateDate"
            case updateVersion = "UpdateVersion"
        }
    }

    public struct OutboundConnection: AWSDecodableShape {
        /// Name of the connection.
        public let connectionAlias: String?
        /// Unique identifier of the connection.
        public let connectionId: String?
        /// The connection mode.
        public let connectionMode: ConnectionMode?
        /// Properties for the outbound connection.
        public let connectionProperties: ConnectionProperties?
        /// Status of the connection.
        public let connectionStatus: OutboundConnectionStatus?
        /// Information about the source (local) domain.
        public let localDomainInfo: DomainInformationContainer?
        /// Information about the destination (remote) domain.
        public let remoteDomainInfo: DomainInformationContainer?

        public init(connectionAlias: String? = nil, connectionId: String? = nil, connectionMode: ConnectionMode? = nil, connectionProperties: ConnectionProperties? = nil, connectionStatus: OutboundConnectionStatus? = nil, localDomainInfo: DomainInformationContainer? = nil, remoteDomainInfo: DomainInformationContainer? = nil) {
            self.connectionAlias = connectionAlias
            self.connectionId = connectionId
            self.connectionMode = connectionMode
            self.connectionProperties = connectionProperties
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        private enum CodingKeys: String, CodingKey {
            case connectionAlias = "ConnectionAlias"
            case connectionId = "ConnectionId"
            case connectionMode = "ConnectionMode"
            case connectionProperties = "ConnectionProperties"
            case connectionStatus = "ConnectionStatus"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct OutboundConnectionStatus: AWSDecodableShape {
        /// Verbose information for the outbound connection.
        public let message: String?
        /// The status code for the outbound connection. Can be one of the following:    VALIDATING - The outbound connection request is being validated.    VALIDATION_FAILED - Validation failed for the connection request.    PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner.    APPROVED - Outbound connection has been approved by the remote domain owner for getting provisioned.    PROVISIONING - Outbound connection request is in process.    ACTIVE - Outbound connection is active and ready to use.    REJECTING - Outbound connection rejection by remote domain owner is in progress.    REJECTED - Outbound connection request is rejected by remote domain owner.    DELETING - Outbound connection deletion is in progress.    DELETED - Outbound connection is deleted and can no longer be used.
        public let statusCode: OutboundConnectionStatusCode?

        public init(message: String? = nil, statusCode: OutboundConnectionStatusCode? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct PackageDetails: AWSDecodableShape {
        /// The package version.
        public let availablePackageVersion: String?
        /// If the package is a ZIP-PLUGIN package, additional information about plugin properties.
        public let availablePluginProperties: PluginProperties?
        /// The timestamp when the package was created.
        public let createdAt: Date?
        /// Version of OpenSearch or Elasticsearch, in the format Elasticsearch_X.Y or OpenSearch_X.Y. Defaults to the latest version of OpenSearch.
        public let engineVersion: String?
        /// Additional information if the package is in an error state. Null otherwise.
        public let errorDetails: ErrorDetails?
        /// Date and time when the package was last updated.
        public let lastUpdatedAt: Date?
        /// User-specified description of the package.
        public let packageDescription: String?
        /// The unique identifier of the package.
        public let packageID: String?
        /// The user-specified name of the package.
        public let packageName: String?
        /// The current status of the package. The available options are AVAILABLE, COPYING, COPY_FAILED, VALIDATNG, VALIDATION_FAILED, DELETING, and DELETE_FAILED.
        public let packageStatus: PackageStatus?
        /// The type of package.
        public let packageType: PackageType?

        public init(availablePackageVersion: String? = nil, availablePluginProperties: PluginProperties? = nil, createdAt: Date? = nil, engineVersion: String? = nil, errorDetails: ErrorDetails? = nil, lastUpdatedAt: Date? = nil, packageDescription: String? = nil, packageID: String? = nil, packageName: String? = nil, packageStatus: PackageStatus? = nil, packageType: PackageType? = nil) {
            self.availablePackageVersion = availablePackageVersion
            self.availablePluginProperties = availablePluginProperties
            self.createdAt = createdAt
            self.engineVersion = engineVersion
            self.errorDetails = errorDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.packageDescription = packageDescription
            self.packageID = packageID
            self.packageName = packageName
            self.packageStatus = packageStatus
            self.packageType = packageType
        }

        private enum CodingKeys: String, CodingKey {
            case availablePackageVersion = "AvailablePackageVersion"
            case availablePluginProperties = "AvailablePluginProperties"
            case createdAt = "CreatedAt"
            case engineVersion = "EngineVersion"
            case errorDetails = "ErrorDetails"
            case lastUpdatedAt = "LastUpdatedAt"
            case packageDescription = "PackageDescription"
            case packageID = "PackageID"
            case packageName = "PackageName"
            case packageStatus = "PackageStatus"
            case packageType = "PackageType"
        }
    }

    public struct PackageSource: AWSEncodableShape {
        /// The name of the Amazon S3 bucket containing the package.
        public let s3BucketName: String?
        /// Key (file name) of the package.
        public let s3Key: String?

        public init(s3BucketName: String? = nil, s3Key: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "S3BucketName"
            case s3Key = "S3Key"
        }
    }

    public struct PackageVersionHistory: AWSDecodableShape {
        /// A message associated with the package version when it was uploaded.
        public let commitMessage: String?
        /// The date and time when the package was created.
        public let createdAt: Date?
        /// The package version.
        public let packageVersion: String?
        /// Additional information about plugin properties if the package is a ZIP-PLUGIN package.
        public let pluginProperties: PluginProperties?

        public init(commitMessage: String? = nil, createdAt: Date? = nil, packageVersion: String? = nil, pluginProperties: PluginProperties? = nil) {
            self.commitMessage = commitMessage
            self.createdAt = createdAt
            self.packageVersion = packageVersion
            self.pluginProperties = pluginProperties
        }

        private enum CodingKeys: String, CodingKey {
            case commitMessage = "CommitMessage"
            case createdAt = "CreatedAt"
            case packageVersion = "PackageVersion"
            case pluginProperties = "PluginProperties"
        }
    }

    public struct PluginProperties: AWSDecodableShape {
        /// The name of the class to load.
        public let className: String?
        /// The description of the plugin.
        public let description: String?
        /// The name of the plugin.
        public let name: String?
        /// The uncompressed size of the plugin.
        public let uncompressedSizeInBytes: Int64?
        /// The version of the plugin.
        public let version: String?

        public init(className: String? = nil, description: String? = nil, name: String? = nil, uncompressedSizeInBytes: Int64? = nil, version: String? = nil) {
            self.className = className
            self.description = description
            self.name = name
            self.uncompressedSizeInBytes = uncompressedSizeInBytes
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case className = "ClassName"
            case description = "Description"
            case name = "Name"
            case uncompressedSizeInBytes = "UncompressedSizeInBytes"
            case version = "Version"
        }
    }

    public struct PurchaseReservedInstanceOfferingRequest: AWSEncodableShape {
        /// The number of OpenSearch instances to reserve.
        public let instanceCount: Int?
        /// A customer-specified identifier to track this reservation.
        public let reservationName: String
        /// The ID of the Reserved Instance offering to purchase.
        public let reservedInstanceOfferingId: String

        public init(instanceCount: Int? = nil, reservationName: String, reservedInstanceOfferingId: String) {
            self.instanceCount = instanceCount
            self.reservationName = reservationName
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 1)
            try self.validate(self.reservationName, name: "reservationName", parent: name, max: 64)
            try self.validate(self.reservationName, name: "reservationName", parent: name, min: 5)
            try self.validate(self.reservationName, name: "reservationName", parent: name, pattern: ".*")
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, max: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, min: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case reservationName = "ReservationName"
            case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
        }
    }

    public struct PurchaseReservedInstanceOfferingResponse: AWSDecodableShape {
        /// The customer-specified identifier used to track this reservation.
        public let reservationName: String?
        /// The ID of the Reserved Instance offering that was purchased.
        public let reservedInstanceId: String?

        public init(reservationName: String? = nil, reservedInstanceId: String? = nil) {
            self.reservationName = reservationName
            self.reservedInstanceId = reservedInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case reservationName = "ReservationName"
            case reservedInstanceId = "ReservedInstanceId"
        }
    }

    public struct RecurringCharge: AWSDecodableShape {
        /// The monetary amount of the recurring charge.
        public let recurringChargeAmount: Double?
        /// The frequency of the recurring charge.
        public let recurringChargeFrequency: String?

        public init(recurringChargeAmount: Double? = nil, recurringChargeFrequency: String? = nil) {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case recurringChargeAmount = "RecurringChargeAmount"
            case recurringChargeFrequency = "RecurringChargeFrequency"
        }
    }

    public struct RejectInboundConnectionRequest: AWSEncodableShape {
        /// The unique identifier of the inbound connection to reject.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectionId, key: "ConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RejectInboundConnectionResponse: AWSDecodableShape {
        /// Contains details about the rejected inbound connection.
        public let connection: InboundConnection?

        public init(connection: InboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct RemoveTagsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the domain from which you want to delete the specified tags.
        public let arn: String
        /// The list of tag keys to remove from the domain.
        public let tagKeys: [String]

        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct ReservedInstance: AWSDecodableShape {
        /// The unique identifier of the billing subscription.
        public let billingSubscriptionId: Int64?
        /// The currency code for the offering.
        public let currencyCode: String?
        /// The duration, in seconds, for which the OpenSearch instance is reserved.
        public let duration: Int?
        /// The upfront fixed charge you will paid to purchase the specific Reserved Instance offering.
        public let fixedPrice: Double?
        /// The number of OpenSearch instances that have been reserved.
        public let instanceCount: Int?
        /// The OpenSearch instance type offered by theReserved Instance offering.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// The payment option as defined in the Reserved Instance offering.
        public let paymentOption: ReservedInstancePaymentOption?
        /// The recurring charge to your account, regardless of whether you create any domains using the Reserved Instance offering.
        public let recurringCharges: [RecurringCharge]?
        /// The customer-specified identifier to track this reservation.
        public let reservationName: String?
        /// The unique identifier for the reservation.
        public let reservedInstanceId: String?
        /// The unique identifier of the Reserved Instance offering.
        public let reservedInstanceOfferingId: String?
        /// The date and time when the reservation was purchased.
        public let startTime: Date?
        /// The state of the Reserved Instance.
        public let state: String?
        /// The hourly rate at which you're charged for the domain using this Reserved Instance.
        public let usagePrice: Double?

        public init(billingSubscriptionId: Int64? = nil, currencyCode: String? = nil, duration: Int? = nil, fixedPrice: Double? = nil, instanceCount: Int? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, paymentOption: ReservedInstancePaymentOption? = nil, recurringCharges: [RecurringCharge]? = nil, reservationName: String? = nil, reservedInstanceId: String? = nil, reservedInstanceOfferingId: String? = nil, startTime: Date? = nil, state: String? = nil, usagePrice: Double? = nil) {
            self.billingSubscriptionId = billingSubscriptionId
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservationName = reservationName
            self.reservedInstanceId = reservedInstanceId
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }

        private enum CodingKeys: String, CodingKey {
            case billingSubscriptionId = "BillingSubscriptionId"
            case currencyCode = "CurrencyCode"
            case duration = "Duration"
            case fixedPrice = "FixedPrice"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case paymentOption = "PaymentOption"
            case recurringCharges = "RecurringCharges"
            case reservationName = "ReservationName"
            case reservedInstanceId = "ReservedInstanceId"
            case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
            case startTime = "StartTime"
            case state = "State"
            case usagePrice = "UsagePrice"
        }
    }

    public struct ReservedInstanceOffering: AWSDecodableShape {
        /// The currency code for the Reserved Instance offering.
        public let currencyCode: String?
        /// The duration, in seconds, for which the offering will reserve the OpenSearch instance.
        public let duration: Int?
        /// The upfront fixed charge you will pay to purchase the specific Reserved Instance offering.
        public let fixedPrice: Double?
        /// The OpenSearch instance type offered by the Reserved Instance offering.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// Payment option for the Reserved Instance offering
        public let paymentOption: ReservedInstancePaymentOption?
        /// The recurring charge to your account, regardless of whether you creates any domains using the offering.
        public let recurringCharges: [RecurringCharge]?
        /// The unique identifier of the Reserved Instance offering.
        public let reservedInstanceOfferingId: String?
        /// The hourly rate at which you're charged for the domain using this Reserved Instance.
        public let usagePrice: Double?

        public init(currencyCode: String? = nil, duration: Int? = nil, fixedPrice: Double? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, paymentOption: ReservedInstancePaymentOption? = nil, recurringCharges: [RecurringCharge]? = nil, reservedInstanceOfferingId: String? = nil, usagePrice: Double? = nil) {
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.usagePrice = usagePrice
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case duration = "Duration"
            case fixedPrice = "FixedPrice"
            case instanceType = "InstanceType"
            case paymentOption = "PaymentOption"
            case recurringCharges = "RecurringCharges"
            case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
            case usagePrice = "UsagePrice"
        }
    }

    public struct RevokeVpcEndpointAccessRequest: AWSEncodableShape {
        /// The account ID to revoke access from.
        public let account: String
        /// The name of the OpenSearch Service domain.
        public let domainName: String

        public init(account: String, domainName: String) {
            self.account = account
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.account, forKey: .account)
            request.encodePath(self.domainName, key: "DomainName")
        }

        public func validate(name: String) throws {
            try self.validate(self.account, name: "account", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case account = "Account"
        }
    }

    public struct RevokeVpcEndpointAccessResponse: AWSDecodableShape {
        public init() {}
    }

    public struct S3GlueDataCatalog: AWSEncodableShape & AWSDecodableShape {
        /// >The Amazon Resource Name (ARN) for the S3 Glue Data Catalog.
        public let roleArn: String?

        public init(roleArn: String? = nil) {
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws|aws\\-cn|aws\\-us\\-gov|aws\\-iso|aws\\-iso\\-b):iam::[0-9]+:role\\/")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "RoleArn"
        }
    }

    public struct SAMLIdp: AWSEncodableShape & AWSDecodableShape {
        /// The unique entity ID of the application in the SAML identity provider.
        public let entityId: String
        /// The metadata of the SAML application, in XML format.
        public let metadataContent: String

        public init(entityId: String, metadataContent: String) {
            self.entityId = entityId
            self.metadataContent = metadataContent
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 512)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 8)
            try self.validate(self.metadataContent, name: "metadataContent", parent: name, max: 1048576)
            try self.validate(self.metadataContent, name: "metadataContent", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case metadataContent = "MetadataContent"
        }
    }

    public struct SAMLOptionsInput: AWSEncodableShape {
        /// True to enable SAML authentication for a domain.
        public let enabled: Bool?
        /// The SAML Identity Provider's information.
        public let idp: SAMLIdp?
        /// The backend role that the SAML master user is mapped to.
        public let masterBackendRole: String?
        /// The SAML master user name, which is stored in the domain's internal user database.
        public let masterUserName: String?
        /// Element of the SAML assertion to use for backend roles. Default is roles.
        public let rolesKey: String?
        /// The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.
        public let sessionTimeoutMinutes: Int?
        /// Element of the SAML assertion to use for the user name. Default is NameID.
        public let subjectKey: String?

        public init(enabled: Bool? = nil, idp: SAMLIdp? = nil, masterBackendRole: String? = nil, masterUserName: String? = nil, rolesKey: String? = nil, sessionTimeoutMinutes: Int? = nil, subjectKey: String? = nil) {
            self.enabled = enabled
            self.idp = idp
            self.masterBackendRole = masterBackendRole
            self.masterUserName = masterUserName
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }

        public func validate(name: String) throws {
            try self.idp?.validate(name: "\(name).idp")
            try self.validate(self.masterBackendRole, name: "masterBackendRole", parent: name, max: 256)
            try self.validate(self.masterBackendRole, name: "masterBackendRole", parent: name, min: 1)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, max: 64)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, min: 1)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case idp = "Idp"
            case masterBackendRole = "MasterBackendRole"
            case masterUserName = "MasterUserName"
            case rolesKey = "RolesKey"
            case sessionTimeoutMinutes = "SessionTimeoutMinutes"
            case subjectKey = "SubjectKey"
        }
    }

    public struct SAMLOptionsOutput: AWSDecodableShape {
        /// True if SAML is enabled.
        public let enabled: Bool?
        /// Describes the SAML identity provider's information.
        public let idp: SAMLIdp?
        /// The key used for matching the SAML roles attribute.
        public let rolesKey: String?
        /// The duration, in minutes, after which a user session becomes inactive.
        public let sessionTimeoutMinutes: Int?
        /// The key used for matching the SAML subject attribute.
        public let subjectKey: String?

        public init(enabled: Bool? = nil, idp: SAMLIdp? = nil, rolesKey: String? = nil, sessionTimeoutMinutes: Int? = nil, subjectKey: String? = nil) {
            self.enabled = enabled
            self.idp = idp
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case idp = "Idp"
            case rolesKey = "RolesKey"
            case sessionTimeoutMinutes = "SessionTimeoutMinutes"
            case subjectKey = "SubjectKey"
        }
    }

    public struct ScheduledAction: AWSDecodableShape {
        /// Whether or not the scheduled action is cancellable.
        public let cancellable: Bool?
        /// A description of the action to be taken.
        public let description: String?
        /// The unique identifier of the scheduled action.
        public let id: String
        /// Whether the action is required or optional.
        public let mandatory: Bool?
        /// Whether the action was scheduled manually (CUSTOMER, or by OpenSearch Service automatically (SYSTEM).
        public let scheduledBy: ScheduledBy?
        /// The time when the change is scheduled to happen.
        public let scheduledTime: Int64
        /// The severity of the action.
        public let severity: ActionSeverity
        /// The current status of the scheduled action.
        public let status: ActionStatus?
        /// The type of action that will be taken on the domain.
        public let type: ActionType

        public init(cancellable: Bool? = nil, description: String? = nil, id: String, mandatory: Bool? = nil, scheduledBy: ScheduledBy? = nil, scheduledTime: Int64, severity: ActionSeverity, status: ActionStatus? = nil, type: ActionType) {
            self.cancellable = cancellable
            self.description = description
            self.id = id
            self.mandatory = mandatory
            self.scheduledBy = scheduledBy
            self.scheduledTime = scheduledTime
            self.severity = severity
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case cancellable = "Cancellable"
            case description = "Description"
            case id = "Id"
            case mandatory = "Mandatory"
            case scheduledBy = "ScheduledBy"
            case scheduledTime = "ScheduledTime"
            case severity = "Severity"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ScheduledAutoTuneDetails: AWSDecodableShape {
        /// A description of the Auto-Tune action.
        public let action: String?
        /// The type of Auto-Tune action.
        public let actionType: ScheduledAutoTuneActionType?
        /// The date and time when the Auto-Tune action is scheduled for the domain.
        public let date: Date?
        /// The severity of the Auto-Tune action. Valid values are LOW, MEDIUM, and HIGH.
        public let severity: ScheduledAutoTuneSeverityType?

        public init(action: String? = nil, actionType: ScheduledAutoTuneActionType? = nil, date: Date? = nil, severity: ScheduledAutoTuneSeverityType? = nil) {
            self.action = action
            self.actionType = actionType
            self.date = date
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case actionType = "ActionType"
            case date = "Date"
            case severity = "Severity"
        }
    }

    public struct ServiceSoftwareOptions: AWSDecodableShape {
        /// The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.
        public let automatedUpdateDate: Date?
        ///  True if you're able to cancel your service software version update. False if you can't cancel your service software update.
        public let cancellable: Bool?
        /// The current service software version present on the domain.
        public let currentVersion: String?
        /// A description of the service software update status.
        public let description: String?
        /// The new service software version, if one is available.
        public let newVersion: String?
        /// True if a service software is never automatically updated. False if a service software is automatically updated after the automated update date.
        public let optionalDeployment: Bool?
        /// True if you're able to update your service software version. False if you can't update your service software version.
        public let updateAvailable: Bool?
        /// The status of your service software update.
        public let updateStatus: DeploymentStatus?

        public init(automatedUpdateDate: Date? = nil, cancellable: Bool? = nil, currentVersion: String? = nil, description: String? = nil, newVersion: String? = nil, optionalDeployment: Bool? = nil, updateAvailable: Bool? = nil, updateStatus: DeploymentStatus? = nil) {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case automatedUpdateDate = "AutomatedUpdateDate"
            case cancellable = "Cancellable"
            case currentVersion = "CurrentVersion"
            case description = "Description"
            case newVersion = "NewVersion"
            case optionalDeployment = "OptionalDeployment"
            case updateAvailable = "UpdateAvailable"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct SnapshotOptions: AWSEncodableShape & AWSDecodableShape {
        /// The time, in UTC format, when OpenSearch Service takes a daily automated snapshot of the specified domain. Default is 0 hours.
        public let automatedSnapshotStartHour: Int?

        public init(automatedSnapshotStartHour: Int? = nil) {
            self.automatedSnapshotStartHour = automatedSnapshotStartHour
        }

        private enum CodingKeys: String, CodingKey {
            case automatedSnapshotStartHour = "AutomatedSnapshotStartHour"
        }
    }

    public struct SnapshotOptionsStatus: AWSDecodableShape {
        /// The daily snapshot options specified for the domain.
        public let options: SnapshotOptions
        /// The status of a daily automated snapshot.
        public let status: OptionStatus

        public init(options: SnapshotOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct SoftwareUpdateOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether automatic service software updates are enabled for the domain.
        public let autoSoftwareUpdateEnabled: Bool?

        public init(autoSoftwareUpdateEnabled: Bool? = nil) {
            self.autoSoftwareUpdateEnabled = autoSoftwareUpdateEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case autoSoftwareUpdateEnabled = "AutoSoftwareUpdateEnabled"
        }
    }

    public struct SoftwareUpdateOptionsStatus: AWSDecodableShape {
        /// The service software update options for a domain.
        public let options: SoftwareUpdateOptions?
        /// The status of service software update options, including creation date and last updated date.
        public let status: OptionStatus?

        public init(options: SoftwareUpdateOptions? = nil, status: OptionStatus? = nil) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct StartDomainMaintenanceRequest: AWSEncodableShape {
        /// The name of the action.
        public let action: MaintenanceType
        /// The name of the domain.
        public let domainName: String
        /// The ID of the data node.
        public let nodeId: String?

        public init(action: MaintenanceType, domainName: String, nodeId: String? = nil) {
            self.action = action
            self.domainName = domainName
            self.nodeId = nodeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.nodeId, forKey: .nodeId)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 40)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case nodeId = "NodeId"
        }
    }

    public struct StartDomainMaintenanceResponse: AWSDecodableShape {
        /// The request ID of requested action.
        public let maintenanceId: String?

        public init(maintenanceId: String? = nil) {
            self.maintenanceId = maintenanceId
        }

        private enum CodingKeys: String, CodingKey {
            case maintenanceId = "MaintenanceId"
        }
    }

    public struct StartServiceSoftwareUpdateRequest: AWSEncodableShape {
        /// The Epoch timestamp when you want the service software update to start. You only need to specify this parameter if you set ScheduleAt to TIMESTAMP.
        public let desiredStartTime: Int64?
        /// The name of the domain that you want to update to the latest service software.
        public let domainName: String
        /// When to start the service software update.    NOW - Immediately schedules the update to happen in the current hour if there's capacity available.    TIMESTAMP - Lets you specify a custom date and time to apply the update. If you specify this value, you must also provide a value for DesiredStartTime.    OFF_PEAK_WINDOW - Marks the update to be picked up during an upcoming off-peak window. There's no guarantee that the update will happen during the next immediate window. Depending on capacity, it might happen in subsequent days.   Default: NOW if you don't specify a value for DesiredStartTime, and TIMESTAMP if you do.
        public let scheduleAt: ScheduleAt?

        public init(desiredStartTime: Int64? = nil, domainName: String, scheduleAt: ScheduleAt? = nil) {
            self.desiredStartTime = desiredStartTime
            self.domainName = domainName
            self.scheduleAt = scheduleAt
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case desiredStartTime = "DesiredStartTime"
            case domainName = "DomainName"
            case scheduleAt = "ScheduleAt"
        }
    }

    public struct StartServiceSoftwareUpdateResponse: AWSDecodableShape {
        /// The current status of the OpenSearch Service software update.
        public let serviceSoftwareOptions: ServiceSoftwareOptions?

        public init(serviceSoftwareOptions: ServiceSoftwareOptions? = nil) {
            self.serviceSoftwareOptions = serviceSoftwareOptions
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
        }
    }

    public struct StorageType: AWSDecodableShape {
        /// The storage sub-type, such as gp3 or io1.
        public let storageSubTypeName: String?
        /// Limits that are applicable for the given storage type.
        public let storageTypeLimits: [StorageTypeLimit]?
        /// The name of the storage type.
        public let storageTypeName: String?

        public init(storageSubTypeName: String? = nil, storageTypeLimits: [StorageTypeLimit]? = nil, storageTypeName: String? = nil) {
            self.storageSubTypeName = storageSubTypeName
            self.storageTypeLimits = storageTypeLimits
            self.storageTypeName = storageTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case storageSubTypeName = "StorageSubTypeName"
            case storageTypeLimits = "StorageTypeLimits"
            case storageTypeName = "StorageTypeName"
        }
    }

    public struct StorageTypeLimit: AWSDecodableShape {
        ///  Name of storage limits that are applicable for the given storage type. If StorageType is ebs, the following options are available:    MinimumVolumeSize - Minimum volume size that is available for the given storage type. Can be empty if not applicable.    MaximumVolumeSize - Maximum volume size that is available for the given storage type. Can be empty if not applicable.    MaximumIops - Maximum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.    MinimumIops - Minimum amount of IOPS that is available for the given the storage type. Can be empty if not applicable.    MaximumThroughput - Maximum amount of throughput that is available for the given the storage type. Can be empty if not applicable.    MinimumThroughput - Minimum amount of throughput that is available for the given the storage type. Can be empty if not applicable.
        public let limitName: String?
        /// The limit values.
        public let limitValues: [String]?

        public init(limitName: String? = nil, limitValues: [String]? = nil) {
            self.limitName = limitName
            self.limitValues = limitValues
        }

        private enum CodingKeys: String, CodingKey {
            case limitName = "LimitName"
            case limitValues = "LimitValues"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key. Tag keys must be unique for the domain to which they are attached.
        public let key: String
        /// The value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of project : Trinity and cost-center : Trinity
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: ".*")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        /// The type of data source.
        public let dataSourceType: DataSourceType
        /// A new description of the data source.
        public let description: String?
        /// The name of the domain.
        public let domainName: String
        /// The name of the data source to modify.
        public let name: String

        public init(dataSourceType: DataSourceType, description: String? = nil, domainName: String, name: String) {
            self.dataSourceType = dataSourceType
            self.description = description
            self.domainName = domainName
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataSourceType, forKey: .dataSourceType)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.dataSourceType.validate(name: "\(name).dataSourceType")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^([a-zA-Z0-9_])*[\\\\a-zA-Z0-9_@#%*+=:?./!\\s-]*$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceType = "DataSourceType"
            case description = "Description"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        /// A message associated with the updated data source.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct UpdateDomainConfigRequest: AWSEncodableShape {
        /// Identity and Access Management (IAM) access policy as a JSON-formatted string.
        public let accessPolicies: String?
        /// Key-value pairs to specify advanced configuration options. The following key-value pairs are supported:    "rest.action.multi.allow_explicit_index": "true" | "false" - Note the use of a string rather than a boolean. Specifies whether explicit references to indexes are allowed inside the body of HTTP requests. If you want to configure access policies for domain sub-resources, such as specific indexes and domain APIs, you must disable this property. Default is true.    "indices.fielddata.cache.size": "80"  - Note the use of a string rather than a boolean. Specifies the percentage of heap space allocated to field data. Default is unbounded.    "indices.query.bool.max_clause_count": "1024" - Note the use of a string rather than a boolean. Specifies the maximum number of clauses allowed in a Lucene boolean query. Default is 1,024. Queries with more than the permitted number of clauses result in a TooManyClauses error.   For more information, see Advanced cluster parameters.
        public let advancedOptions: [String: String]?
        /// Options for fine-grained access control.
        public let advancedSecurityOptions: AdvancedSecurityOptionsInput?
        /// Options for Auto-Tune.
        public let autoTuneOptions: AutoTuneOptions?
        /// Changes that you want to make to the cluster configuration, such as the instance type and number of EC2 instances.
        public let clusterConfig: ClusterConfig?
        /// Key-value pairs to configure Amazon Cognito authentication for OpenSearch Dashboards.
        public let cognitoOptions: CognitoOptions?
        /// Additional options for the domain endpoint, such as whether to require HTTPS for all traffic.
        public let domainEndpointOptions: DomainEndpointOptions?
        /// The name of the domain that you're updating.
        public let domainName: String
        /// This flag, when set to True, specifies whether the UpdateDomain request should return the results of a dry run analysis without actually applying the change. A dry run determines what type of deployment the update will cause.
        public let dryRun: Bool?
        /// The type of dry run to perform.    Basic only returns the type of deployment (blue/green or dynamic) that the update will cause.    Verbose runs an additional check to validate the changes you're making. For more information, see Validating a domain update.
        public let dryRunMode: DryRunMode?
        /// The type and size of the EBS volume to attach to instances in the domain.
        public let ebsOptions: EBSOptions?
        /// Encryption at rest options for the domain.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// Specify either dual stack or IPv4 as your IP address type. Dual stack allows you to share domain resources across IPv4 and IPv6 address types, and is the recommended option.  If your IP address type is currently set to dual stack, you can't change it.
        public let ipAddressType: IPAddressType?
        /// Options to publish OpenSearch logs to Amazon CloudWatch Logs.
        public let logPublishingOptions: [LogType: LogPublishingOption]?
        /// Node-to-node encryption options for the domain.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
        /// Off-peak window options for the domain.
        public let offPeakWindowOptions: OffPeakWindowOptions?
        /// Option to set the time, in UTC format, for the daily automated snapshot. Default value is 0 hours.
        public let snapshotOptions: SnapshotOptions?
        /// Service software update options for the domain.
        public let softwareUpdateOptions: SoftwareUpdateOptions?
        /// Options to specify the subnets and security groups for a VPC endpoint. For more information, see Launching your Amazon OpenSearch Service domains using a VPC.
        public let vpcOptions: VPCOptions?

        public init(accessPolicies: String? = nil, advancedOptions: [String: String]? = nil, advancedSecurityOptions: AdvancedSecurityOptionsInput? = nil, autoTuneOptions: AutoTuneOptions? = nil, clusterConfig: ClusterConfig? = nil, cognitoOptions: CognitoOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, domainName: String, dryRun: Bool? = nil, dryRunMode: DryRunMode? = nil, ebsOptions: EBSOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, ipAddressType: IPAddressType? = nil, logPublishingOptions: [LogType: LogPublishingOption]? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, offPeakWindowOptions: OffPeakWindowOptions? = nil, snapshotOptions: SnapshotOptions? = nil, softwareUpdateOptions: SoftwareUpdateOptions? = nil, vpcOptions: VPCOptions? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.domainName = domainName
            self.dryRun = dryRun
            self.dryRunMode = dryRunMode
            self.ebsOptions = ebsOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.ipAddressType = ipAddressType
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.offPeakWindowOptions = offPeakWindowOptions
            self.snapshotOptions = snapshotOptions
            self.softwareUpdateOptions = softwareUpdateOptions
            self.vpcOptions = vpcOptions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accessPolicies, forKey: .accessPolicies)
            try container.encodeIfPresent(self.advancedOptions, forKey: .advancedOptions)
            try container.encodeIfPresent(self.advancedSecurityOptions, forKey: .advancedSecurityOptions)
            try container.encodeIfPresent(self.autoTuneOptions, forKey: .autoTuneOptions)
            try container.encodeIfPresent(self.clusterConfig, forKey: .clusterConfig)
            try container.encodeIfPresent(self.cognitoOptions, forKey: .cognitoOptions)
            try container.encodeIfPresent(self.domainEndpointOptions, forKey: .domainEndpointOptions)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.dryRun, forKey: .dryRun)
            try container.encodeIfPresent(self.dryRunMode, forKey: .dryRunMode)
            try container.encodeIfPresent(self.ebsOptions, forKey: .ebsOptions)
            try container.encodeIfPresent(self.encryptionAtRestOptions, forKey: .encryptionAtRestOptions)
            try container.encodeIfPresent(self.ipAddressType, forKey: .ipAddressType)
            try container.encodeIfPresent(self.logPublishingOptions, forKey: .logPublishingOptions)
            try container.encodeIfPresent(self.nodeToNodeEncryptionOptions, forKey: .nodeToNodeEncryptionOptions)
            try container.encodeIfPresent(self.offPeakWindowOptions, forKey: .offPeakWindowOptions)
            try container.encodeIfPresent(self.snapshotOptions, forKey: .snapshotOptions)
            try container.encodeIfPresent(self.softwareUpdateOptions, forKey: .softwareUpdateOptions)
            try container.encodeIfPresent(self.vpcOptions, forKey: .vpcOptions)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, max: 102400)
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: ".*")
            try self.advancedSecurityOptions?.validate(name: "\(name).advancedSecurityOptions")
            try self.autoTuneOptions?.validate(name: "\(name).autoTuneOptions")
            try self.cognitoOptions?.validate(name: "\(name).cognitoOptions")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.logPublishingOptions?.forEach {
                try $0.value.validate(name: "\(name).logPublishingOptions[\"\($0.key)\"]")
            }
            try self.offPeakWindowOptions?.validate(name: "\(name).offPeakWindowOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case autoTuneOptions = "AutoTuneOptions"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case domainEndpointOptions = "DomainEndpointOptions"
            case dryRun = "DryRun"
            case dryRunMode = "DryRunMode"
            case ebsOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case ipAddressType = "IPAddressType"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case offPeakWindowOptions = "OffPeakWindowOptions"
            case snapshotOptions = "SnapshotOptions"
            case softwareUpdateOptions = "SoftwareUpdateOptions"
            case vpcOptions = "VPCOptions"
        }
    }

    public struct UpdateDomainConfigResponse: AWSDecodableShape {
        /// The status of the updated domain.
        public let domainConfig: DomainConfig
        /// The status of the dry run being performed on the domain, if any.
        public let dryRunProgressStatus: DryRunProgressStatus?
        /// Results of the dry run performed in the update domain request.
        public let dryRunResults: DryRunResults?

        public init(domainConfig: DomainConfig, dryRunProgressStatus: DryRunProgressStatus? = nil, dryRunResults: DryRunResults? = nil) {
            self.domainConfig = domainConfig
            self.dryRunProgressStatus = dryRunProgressStatus
            self.dryRunResults = dryRunResults
        }

        private enum CodingKeys: String, CodingKey {
            case domainConfig = "DomainConfig"
            case dryRunProgressStatus = "DryRunProgressStatus"
            case dryRunResults = "DryRunResults"
        }
    }

    public struct UpdatePackageRequest: AWSEncodableShape {
        /// Commit message for the updated file, which is shown as part of GetPackageVersionHistoryResponse.
        public let commitMessage: String?
        /// A new description of the package.
        public let packageDescription: String?
        /// The unique identifier for the package.
        public let packageID: String
        /// Amazon S3 bucket and key for the package.
        public let packageSource: PackageSource

        public init(commitMessage: String? = nil, packageDescription: String? = nil, packageID: String, packageSource: PackageSource) {
            self.commitMessage = commitMessage
            self.packageDescription = packageDescription
            self.packageID = packageID
            self.packageSource = packageSource
        }

        public func validate(name: String) throws {
            try self.validate(self.commitMessage, name: "commitMessage", parent: name, max: 160)
            try self.validate(self.packageDescription, name: "packageDescription", parent: name, max: 1024)
            try self.validate(self.packageID, name: "packageID", parent: name, pattern: "^([FG][0-9]+)$")
            try self.packageSource.validate(name: "\(name).packageSource")
        }

        private enum CodingKeys: String, CodingKey {
            case commitMessage = "CommitMessage"
            case packageDescription = "PackageDescription"
            case packageID = "PackageID"
            case packageSource = "PackageSource"
        }
    }

    public struct UpdatePackageResponse: AWSDecodableShape {
        /// Information about a package.
        public let packageDetails: PackageDetails?

        public init(packageDetails: PackageDetails? = nil) {
            self.packageDetails = packageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case packageDetails = "PackageDetails"
        }
    }

    public struct UpdateScheduledActionRequest: AWSEncodableShape {
        /// The unique identifier of the action to reschedule. To retrieve this ID, send a ListScheduledActions request.
        public let actionID: String
        /// The type of action to reschedule. Can be one of SERVICE_SOFTWARE_UPDATE, JVM_HEAP_SIZE_TUNING, or JVM_YOUNG_GEN_TUNING. To retrieve this value, send a ListScheduledActions request.
        public let actionType: ActionType
        /// The time to implement the change, in Coordinated Universal Time (UTC). Only specify this parameter if you set ScheduleAt to TIMESTAMP.
        public let desiredStartTime: Int64?
        /// The name of the domain to reschedule an action for.
        public let domainName: String
        /// When to schedule the action.    NOW - Immediately schedules the update to happen in the current hour if there's capacity available.    TIMESTAMP - Lets you specify a custom date and time to apply the update. If you specify this value, you must also provide a value for DesiredStartTime.    OFF_PEAK_WINDOW - Marks the action to be picked up during an upcoming off-peak window. There's no guarantee that the change will be implemented during the next immediate window. Depending on capacity, it might happen in subsequent days.
        public let scheduleAt: ScheduleAt

        public init(actionID: String, actionType: ActionType, desiredStartTime: Int64? = nil, domainName: String, scheduleAt: ScheduleAt) {
            self.actionID = actionID
            self.actionType = actionType
            self.desiredStartTime = desiredStartTime
            self.domainName = domainName
            self.scheduleAt = scheduleAt
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actionID, forKey: .actionID)
            try container.encode(self.actionType, forKey: .actionType)
            try container.encodeIfPresent(self.desiredStartTime, forKey: .desiredStartTime)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encode(self.scheduleAt, forKey: .scheduleAt)
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionID = "ActionID"
            case actionType = "ActionType"
            case desiredStartTime = "DesiredStartTime"
            case scheduleAt = "ScheduleAt"
        }
    }

    public struct UpdateScheduledActionResponse: AWSDecodableShape {
        /// Information about the rescheduled action.
        public let scheduledAction: ScheduledAction?

        public init(scheduledAction: ScheduledAction? = nil) {
            self.scheduledAction = scheduledAction
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledAction = "ScheduledAction"
        }
    }

    public struct UpdateVpcEndpointRequest: AWSEncodableShape {
        /// The unique identifier of the endpoint.
        public let vpcEndpointId: String
        /// The security groups and/or subnets to add, remove, or modify.
        public let vpcOptions: VPCOptions

        public init(vpcEndpointId: String, vpcOptions: VPCOptions) {
            self.vpcEndpointId = vpcEndpointId
            self.vpcOptions = vpcOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, max: 256)
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, min: 5)
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, pattern: "^aos-[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointId = "VpcEndpointId"
            case vpcOptions = "VpcOptions"
        }
    }

    public struct UpdateVpcEndpointResponse: AWSDecodableShape {
        /// The endpoint to be updated.
        public let vpcEndpoint: VpcEndpoint

        public init(vpcEndpoint: VpcEndpoint) {
            self.vpcEndpoint = vpcEndpoint
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpoint = "VpcEndpoint"
        }
    }

    public struct UpgradeDomainRequest: AWSEncodableShape {
        /// Only supports the override_main_response_version parameter and not other advanced options. You can only include this option when upgrading to an OpenSearch version. Specifies whether the domain reports its version as 7.10 so that it continues to work with Elasticsearch OSS clients and plugins.
        public let advancedOptions: [String: String]?
        /// Name of the OpenSearch Service domain that you want to upgrade.
        public let domainName: String
        /// When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
        public let performCheckOnly: Bool?
        /// OpenSearch or Elasticsearch version to which you want to upgrade, in the format Opensearch_X.Y or Elasticsearch_X.Y.
        public let targetVersion: String

        public init(advancedOptions: [String: String]? = nil, domainName: String, performCheckOnly: Bool? = nil, targetVersion: String) {
            self.advancedOptions = advancedOptions
            self.domainName = domainName
            self.performCheckOnly = performCheckOnly
            self.targetVersion = targetVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.targetVersion, name: "targetVersion", parent: name, max: 18)
            try self.validate(self.targetVersion, name: "targetVersion", parent: name, min: 14)
            try self.validate(self.targetVersion, name: "targetVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case advancedOptions = "AdvancedOptions"
            case domainName = "DomainName"
            case performCheckOnly = "PerformCheckOnly"
            case targetVersion = "TargetVersion"
        }
    }

    public struct UpgradeDomainResponse: AWSDecodableShape {
        /// The advanced options configuration for the domain.
        public let advancedOptions: [String: String]?
        /// Container for information about a configuration change happening on a domain.
        public let changeProgressDetails: ChangeProgressDetails?
        /// The name of the domain that was upgraded.
        public let domainName: String?
        /// When true, indicates that an upgrade eligibility check was performed.
        public let performCheckOnly: Bool?
        /// OpenSearch or Elasticsearch version that the domain was upgraded to.
        public let targetVersion: String?
        /// The unique identifier of the domain upgrade.
        public let upgradeId: String?

        public init(advancedOptions: [String: String]? = nil, changeProgressDetails: ChangeProgressDetails? = nil, domainName: String? = nil, performCheckOnly: Bool? = nil, targetVersion: String? = nil, upgradeId: String? = nil) {
            self.advancedOptions = advancedOptions
            self.changeProgressDetails = changeProgressDetails
            self.domainName = domainName
            self.performCheckOnly = performCheckOnly
            self.targetVersion = targetVersion
            self.upgradeId = upgradeId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedOptions = "AdvancedOptions"
            case changeProgressDetails = "ChangeProgressDetails"
            case domainName = "DomainName"
            case performCheckOnly = "PerformCheckOnly"
            case targetVersion = "TargetVersion"
            case upgradeId = "UpgradeId"
        }
    }

    public struct UpgradeHistory: AWSDecodableShape {
        /// UTC timestamp at which the upgrade API call was made, in the format yyyy-MM-ddTHH:mm:ssZ.
        public let startTimestamp: Date?
        /// A list of each step performed as part of a specific upgrade or upgrade eligibility check.
        public let stepsList: [UpgradeStepItem]?
        /// A string that describes the upgrade.
        public let upgradeName: String?
        ///  The current status of the upgrade. The status can take one of the following values:    In Progress   Succeeded   Succeeded with Issues   Failed
        public let upgradeStatus: UpgradeStatus?

        public init(startTimestamp: Date? = nil, stepsList: [UpgradeStepItem]? = nil, upgradeName: String? = nil, upgradeStatus: UpgradeStatus? = nil) {
            self.startTimestamp = startTimestamp
            self.stepsList = stepsList
            self.upgradeName = upgradeName
            self.upgradeStatus = upgradeStatus
        }

        private enum CodingKeys: String, CodingKey {
            case startTimestamp = "StartTimestamp"
            case stepsList = "StepsList"
            case upgradeName = "UpgradeName"
            case upgradeStatus = "UpgradeStatus"
        }
    }

    public struct UpgradeStepItem: AWSDecodableShape {
        /// A list of strings containing detailed information about the errors encountered in a particular step.
        public let issues: [String]?
        /// The floating point value representing the progress percentage of a particular step.
        public let progressPercent: Double?
        ///  One of three steps that an upgrade or upgrade eligibility check goes through:    PreUpgradeCheck   Snapshot   Upgrade
        public let upgradeStep: UpgradeStep?
        ///  The current status of the upgrade. The status can take one of the following values:    In Progress   Succeeded   Succeeded with Issues   Failed
        public let upgradeStepStatus: UpgradeStatus?

        public init(issues: [String]? = nil, progressPercent: Double? = nil, upgradeStep: UpgradeStep? = nil, upgradeStepStatus: UpgradeStatus? = nil) {
            self.issues = issues
            self.progressPercent = progressPercent
            self.upgradeStep = upgradeStep
            self.upgradeStepStatus = upgradeStepStatus
        }

        private enum CodingKeys: String, CodingKey {
            case issues = "Issues"
            case progressPercent = "ProgressPercent"
            case upgradeStep = "UpgradeStep"
            case upgradeStepStatus = "UpgradeStepStatus"
        }
    }

    public struct VPCDerivedInfo: AWSDecodableShape {
        /// The list of Availability Zones associated with the VPC subnets.
        public let availabilityZones: [String]?
        /// The list of security group IDs associated with the VPC endpoints for the domain.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain.
        public let subnetIds: [String]?
        /// The ID for your VPC. Amazon VPC generates this value when you create a VPC.
        public let vpcId: String?

        public init(availabilityZones: [String]? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vpcId = "VPCId"
        }
    }

    public struct VPCDerivedInfoStatus: AWSDecodableShape {
        /// The VPC options for the specified domain.
        public let options: VPCDerivedInfo
        /// The status of the VPC options for the specified domain.
        public let status: OptionStatus

        public init(options: VPCDerivedInfo, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct VPCOptions: AWSEncodableShape {
        /// The list of security group IDs associated with the VPC endpoints for the domain. If you do not provide a security group ID, OpenSearch Service uses the default security group for the VPC.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs associated with the VPC endpoints for the domain. If your domain uses multiple Availability Zones, you need to provide two subnet IDs, one per zone. Otherwise, provide only one.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct ValidationFailure: AWSDecodableShape {
        /// The error code of the failure.
        public let code: String?
        /// A message corresponding to the failure.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct VersionStatus: AWSDecodableShape {
        /// The OpenSearch or Elasticsearch version for the specified domain.
        public let options: String
        /// The status of the version options for the specified domain.
        public let status: OptionStatus

        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct VpcEndpoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the domain associated with the endpoint.
        public let domainArn: String?
        /// The connection endpoint ID for connecting to the domain.
        public let endpoint: String?
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?
        /// The unique identifier of the endpoint.
        public let vpcEndpointId: String?
        /// The creator of the endpoint.
        public let vpcEndpointOwner: String?
        /// Options to specify the subnets and security groups for an Amazon OpenSearch Service VPC endpoint.
        public let vpcOptions: VPCDerivedInfo?

        public init(domainArn: String? = nil, endpoint: String? = nil, status: VpcEndpointStatus? = nil, vpcEndpointId: String? = nil, vpcEndpointOwner: String? = nil, vpcOptions: VPCDerivedInfo? = nil) {
            self.domainArn = domainArn
            self.endpoint = endpoint
            self.status = status
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwner = vpcEndpointOwner
            self.vpcOptions = vpcOptions
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "DomainArn"
            case endpoint = "Endpoint"
            case status = "Status"
            case vpcEndpointId = "VpcEndpointId"
            case vpcEndpointOwner = "VpcEndpointOwner"
            case vpcOptions = "VpcOptions"
        }
    }

    public struct VpcEndpointError: AWSDecodableShape {
        /// The code associated with the error.
        public let errorCode: VpcEndpointErrorCode?
        /// A message describing the error.
        public let errorMessage: String?
        /// The unique identifier of the endpoint.
        public let vpcEndpointId: String?

        public init(errorCode: VpcEndpointErrorCode? = nil, errorMessage: String? = nil, vpcEndpointId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.vpcEndpointId = vpcEndpointId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case vpcEndpointId = "VpcEndpointId"
        }
    }

    public struct VpcEndpointSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the domain associated with the endpoint.
        public let domainArn: String?
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?
        /// The unique identifier of the endpoint.
        public let vpcEndpointId: String?
        /// The creator of the endpoint.
        public let vpcEndpointOwner: String?

        public init(domainArn: String? = nil, status: VpcEndpointStatus? = nil, vpcEndpointId: String? = nil, vpcEndpointOwner: String? = nil) {
            self.domainArn = domainArn
            self.status = status
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwner = vpcEndpointOwner
        }

        private enum CodingKeys: String, CodingKey {
            case domainArn = "DomainArn"
            case status = "Status"
            case vpcEndpointId = "VpcEndpointId"
            case vpcEndpointOwner = "VpcEndpointOwner"
        }
    }

    public struct WindowStartTime: AWSEncodableShape & AWSDecodableShape {
        /// The start hour of the window in Coordinated Universal Time (UTC), using 24-hour time. For example, 17 refers to 5:00 P.M. UTC.
        public let hours: Int64
        /// The start minute of the window, in UTC.
        public let minutes: Int64

        public init(hours: Int64, minutes: Int64) {
            self.hours = hours
            self.minutes = minutes
        }

        public func validate(name: String) throws {
            try self.validate(self.hours, name: "hours", parent: name, max: 23)
            try self.validate(self.hours, name: "hours", parent: name, min: 0)
            try self.validate(self.minutes, name: "minutes", parent: name, max: 59)
            try self.validate(self.minutes, name: "minutes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case hours = "Hours"
            case minutes = "Minutes"
        }
    }

    public struct ZoneAwarenessConfig: AWSEncodableShape & AWSDecodableShape {
        /// If you enabled multiple Availability Zones, this value is the number of zones that you want the domain to use. Valid values are 2 and 3. If your domain is provisioned within a VPC, this value be equal to number of subnets.
        public let availabilityZoneCount: Int?

        public init(availabilityZoneCount: Int? = nil) {
            self.availabilityZoneCount = availabilityZoneCount
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneCount = "AvailabilityZoneCount"
        }
    }

    public struct DataSourceType: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon S3 data source.
        public let s3GlueDataCatalog: S3GlueDataCatalog?

        public init(s3GlueDataCatalog: S3GlueDataCatalog? = nil) {
            self.s3GlueDataCatalog = s3GlueDataCatalog
        }

        public func validate(name: String) throws {
            try self.s3GlueDataCatalog?.validate(name: "\(name).s3GlueDataCatalog")
        }

        private enum CodingKeys: String, CodingKey {
            case s3GlueDataCatalog = "S3GlueDataCatalog"
        }
    }
}

// MARK: - Errors

/// Error enum for OpenSearch
public struct OpenSearchErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case baseException = "BaseException"
        case conflictException = "ConflictException"
        case dependencyFailureException = "DependencyFailureException"
        case disabledOperationException = "DisabledOperationException"
        case internalException = "InternalException"
        case invalidPaginationTokenException = "InvalidPaginationTokenException"
        case invalidTypeException = "InvalidTypeException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case slotNotAvailableException = "SlotNotAvailableException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize OpenSearch
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An error occurred because you don't have permissions to access the resource.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// An error occurred while processing the request.
    public static var baseException: Self { .init(.baseException) }
    /// An error occurred because the client attempts to remove a resource that is currently in use.
    public static var conflictException: Self { .init(.conflictException) }
    /// An exception for when a failure in one of the dependencies results in the service being unable to fetch details about the resource.
    public static var dependencyFailureException: Self { .init(.dependencyFailureException) }
    /// An error occured because the client wanted to access an unsupported operation.
    public static var disabledOperationException: Self { .init(.disabledOperationException) }
    /// Request processing failed because of an unknown error, exception, or internal failure.
    public static var internalException: Self { .init(.internalException) }
    /// Request processing failed because you provided an invalid pagination token.
    public static var invalidPaginationTokenException: Self { .init(.invalidPaginationTokenException) }
    /// An exception for trying to create or access a sub-resource that's either invalid or not supported.
    public static var invalidTypeException: Self { .init(.invalidTypeException) }
    /// An exception for trying to create more than the allowed number of resources or sub-resources.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// An exception for creating a resource that already exists.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// An exception for accessing or deleting a resource that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// An exception for attempting to schedule a domain action during an unavailable time slot.
    public static var slotNotAvailableException: Self { .init(.slotNotAvailableException) }
    /// An exception for accessing or deleting a resource that doesn't exist.
    public static var validationException: Self { .init(.validationException) }
}

extension OpenSearchErrorType: Equatable {
    public static func == (lhs: OpenSearchErrorType, rhs: OpenSearchErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OpenSearchErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
