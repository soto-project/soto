//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension OpenSearch {
    // MARK: Enums

    public enum AutoTuneDesiredState: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AutoTuneState: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case disabledAndRollbackComplete = "DISABLED_AND_ROLLBACK_COMPLETE"
        case disabledAndRollbackError = "DISABLED_AND_ROLLBACK_ERROR"
        case disabledAndRollbackInProgress = "DISABLED_AND_ROLLBACK_IN_PROGRESS"
        case disabledAndRollbackScheduled = "DISABLED_AND_ROLLBACK_SCHEDULED"
        case disableInProgress = "DISABLE_IN_PROGRESS"
        case enabled = "ENABLED"
        case enableInProgress = "ENABLE_IN_PROGRESS"
        case error = "ERROR"
        public var description: String { return self.rawValue }
    }

    public enum AutoTuneType: String, CustomStringConvertible, Codable {
        case scheduledAction = "SCHEDULED_ACTION"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case eligible = "ELIGIBLE"
        case inProgress = "IN_PROGRESS"
        case notEligible = "NOT_ELIGIBLE"
        case pendingUpdate = "PENDING_UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum DescribePackagesFilterName: String, CustomStringConvertible, Codable {
        case packageid = "PackageID"
        case packagename = "PackageName"
        case packagestatus = "PackageStatus"
        public var description: String { return self.rawValue }
    }

    public enum DomainPackageStatus: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case associating = "ASSOCIATING"
        case associationFailed = "ASSOCIATION_FAILED"
        case dissociating = "DISSOCIATING"
        case dissociationFailed = "DISSOCIATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum EngineType: String, CustomStringConvertible, Codable {
        case elasticsearch = "Elasticsearch"
        case opensearch = "OpenSearch"
        public var description: String { return self.rawValue }
    }

    public enum InboundConnectionStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case approved = "APPROVED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pendingAcceptance = "PENDING_ACCEPTANCE"
        case provisioning = "PROVISIONING"
        case rejected = "REJECTED"
        case rejecting = "REJECTING"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable {
        case auditLogs = "AUDIT_LOGS"
        case esApplicationLogs = "ES_APPLICATION_LOGS"
        case indexSlowLogs = "INDEX_SLOW_LOGS"
        case searchSlowLogs = "SEARCH_SLOW_LOGS"
        public var description: String { return self.rawValue }
    }

    public enum OpenSearchPartitionInstanceType: String, CustomStringConvertible, Codable {
        case c42XlargeSearch = "c4.2xlarge.search"
        case c44XlargeSearch = "c4.4xlarge.search"
        case c48XlargeSearch = "c4.8xlarge.search"
        case c4LargeSearch = "c4.large.search"
        case c4XlargeSearch = "c4.xlarge.search"
        case c518XlargeSearch = "c5.18xlarge.search"
        case c52XlargeSearch = "c5.2xlarge.search"
        case c54XlargeSearch = "c5.4xlarge.search"
        case c59XlargeSearch = "c5.9xlarge.search"
        case c5LargeSearch = "c5.large.search"
        case c5XlargeSearch = "c5.xlarge.search"
        case c6g12XlargeSearch = "c6g.12xlarge.search"
        case c6g2XlargeSearch = "c6g.2xlarge.search"
        case c6g4XlargeSearch = "c6g.4xlarge.search"
        case c6g8XlargeSearch = "c6g.8xlarge.search"
        case c6gLargeSearch = "c6g.large.search"
        case c6gXlargeSearch = "c6g.xlarge.search"
        case d22XlargeSearch = "d2.2xlarge.search"
        case d24XlargeSearch = "d2.4xlarge.search"
        case d28XlargeSearch = "d2.8xlarge.search"
        case d2XlargeSearch = "d2.xlarge.search"
        case i22XlargeSearch = "i2.2xlarge.search"
        case i2XlargeSearch = "i2.xlarge.search"
        case i316XlargeSearch = "i3.16xlarge.search"
        case i32XlargeSearch = "i3.2xlarge.search"
        case i34XlargeSearch = "i3.4xlarge.search"
        case i38XlargeSearch = "i3.8xlarge.search"
        case i3LargeSearch = "i3.large.search"
        case i3XlargeSearch = "i3.xlarge.search"
        case m32XlargeSearch = "m3.2xlarge.search"
        case m3LargeSearch = "m3.large.search"
        case m3MediumSearch = "m3.medium.search"
        case m3XlargeSearch = "m3.xlarge.search"
        case m410XlargeSearch = "m4.10xlarge.search"
        case m42XlargeSearch = "m4.2xlarge.search"
        case m44XlargeSearch = "m4.4xlarge.search"
        case m4LargeSearch = "m4.large.search"
        case m4XlargeSearch = "m4.xlarge.search"
        case m512XlargeSearch = "m5.12xlarge.search"
        case m524XlargeSearch = "m5.24xlarge.search"
        case m52XlargeSearch = "m5.2xlarge.search"
        case m54XlargeSearch = "m5.4xlarge.search"
        case m5LargeSearch = "m5.large.search"
        case m5XlargeSearch = "m5.xlarge.search"
        case m6g12XlargeSearch = "m6g.12xlarge.search"
        case m6g2XlargeSearch = "m6g.2xlarge.search"
        case m6g4XlargeSearch = "m6g.4xlarge.search"
        case m6g8XlargeSearch = "m6g.8xlarge.search"
        case m6gLargeSearch = "m6g.large.search"
        case m6gXlargeSearch = "m6g.xlarge.search"
        case r32XlargeSearch = "r3.2xlarge.search"
        case r34XlargeSearch = "r3.4xlarge.search"
        case r38XlargeSearch = "r3.8xlarge.search"
        case r3LargeSearch = "r3.large.search"
        case r3XlargeSearch = "r3.xlarge.search"
        case r416XlargeSearch = "r4.16xlarge.search"
        case r42XlargeSearch = "r4.2xlarge.search"
        case r44XlargeSearch = "r4.4xlarge.search"
        case r48XlargeSearch = "r4.8xlarge.search"
        case r4LargeSearch = "r4.large.search"
        case r4XlargeSearch = "r4.xlarge.search"
        case r512XlargeSearch = "r5.12xlarge.search"
        case r524XlargeSearch = "r5.24xlarge.search"
        case r52XlargeSearch = "r5.2xlarge.search"
        case r54XlargeSearch = "r5.4xlarge.search"
        case r5LargeSearch = "r5.large.search"
        case r5XlargeSearch = "r5.xlarge.search"
        case r6g12XlargeSearch = "r6g.12xlarge.search"
        case r6g2XlargeSearch = "r6g.2xlarge.search"
        case r6g4XlargeSearch = "r6g.4xlarge.search"
        case r6g8XlargeSearch = "r6g.8xlarge.search"
        case r6gLargeSearch = "r6g.large.search"
        case r6gXlargeSearch = "r6g.xlarge.search"
        case r6gd12XlargeSearch = "r6gd.12xlarge.search"
        case r6gd16XlargeSearch = "r6gd.16xlarge.search"
        case r6gd2XlargeSearch = "r6gd.2xlarge.search"
        case r6gd4XlargeSearch = "r6gd.4xlarge.search"
        case r6gd8XlargeSearch = "r6gd.8xlarge.search"
        case r6gdLargeSearch = "r6gd.large.search"
        case r6gdXlargeSearch = "r6gd.xlarge.search"
        case t2MediumSearch = "t2.medium.search"
        case t2MicroSearch = "t2.micro.search"
        case t2SmallSearch = "t2.small.search"
        case t32XlargeSearch = "t3.2xlarge.search"
        case t3LargeSearch = "t3.large.search"
        case t3MediumSearch = "t3.medium.search"
        case t3MicroSearch = "t3.micro.search"
        case t3NanoSearch = "t3.nano.search"
        case t3SmallSearch = "t3.small.search"
        case t3XlargeSearch = "t3.xlarge.search"
        case t4gMediumSearch = "t4g.medium.search"
        case t4gSmallSearch = "t4g.small.search"
        case ultrawarm1LargeSearch = "ultrawarm1.large.search"
        case ultrawarm1MediumSearch = "ultrawarm1.medium.search"
        case ultrawarm1XlargeSearch = "ultrawarm1.xlarge.search"
        public var description: String { return self.rawValue }
    }

    public enum OpenSearchWarmPartitionInstanceType: String, CustomStringConvertible, Codable {
        case ultrawarm1LargeSearch = "ultrawarm1.large.search"
        case ultrawarm1MediumSearch = "ultrawarm1.medium.search"
        case ultrawarm1XlargeSearch = "ultrawarm1.xlarge.search"
        public var description: String { return self.rawValue }
    }

    public enum OptionState: String, CustomStringConvertible, Codable {
        case active = "Active"
        case processing = "Processing"
        case requiresindexdocuments = "RequiresIndexDocuments"
        public var description: String { return self.rawValue }
    }

    public enum OutboundConnectionStatusCode: String, CustomStringConvertible, Codable {
        case active = "ACTIVE"
        case approved = "APPROVED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case pendingAcceptance = "PENDING_ACCEPTANCE"
        case provisioning = "PROVISIONING"
        case rejected = "REJECTED"
        case rejecting = "REJECTING"
        case validating = "VALIDATING"
        case validationFailed = "VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum PackageStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case copying = "COPYING"
        case copyFailed = "COPY_FAILED"
        case deleted = "DELETED"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case validating = "VALIDATING"
        case validationFailed = "VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum PackageType: String, CustomStringConvertible, Codable {
        case txtDictionary = "TXT-DICTIONARY"
        public var description: String { return self.rawValue }
    }

    public enum ReservedInstancePaymentOption: String, CustomStringConvertible, Codable {
        case allUpfront = "ALL_UPFRONT"
        case noUpfront = "NO_UPFRONT"
        case partialUpfront = "PARTIAL_UPFRONT"
        public var description: String { return self.rawValue }
    }

    public enum RollbackOnDisable: String, CustomStringConvertible, Codable {
        case defaultRollback = "DEFAULT_ROLLBACK"
        case noRollback = "NO_ROLLBACK"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledAutoTuneActionType: String, CustomStringConvertible, Codable {
        case jvmHeapSizeTuning = "JVM_HEAP_SIZE_TUNING"
        case jvmYoungGenTuning = "JVM_YOUNG_GEN_TUNING"
        public var description: String { return self.rawValue }
    }

    public enum ScheduledAutoTuneSeverityType: String, CustomStringConvertible, Codable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        public var description: String { return self.rawValue }
    }

    public enum TLSSecurityPolicy: String, CustomStringConvertible, Codable {
        case policyMinTls10201907 = "Policy-Min-TLS-1-0-2019-07"
        case policyMinTls12201907 = "Policy-Min-TLS-1-2-2019-07"
        public var description: String { return self.rawValue }
    }

    public enum TimeUnit: String, CustomStringConvertible, Codable {
        case hours = "HOURS"
        public var description: String { return self.rawValue }
    }

    public enum UpgradeStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        case succeededWithIssues = "SUCCEEDED_WITH_ISSUES"
        public var description: String { return self.rawValue }
    }

    public enum UpgradeStep: String, CustomStringConvertible, Codable {
        case preUpgradeCheck = "PRE_UPGRADE_CHECK"
        case snapshot = "SNAPSHOT"
        case upgrade = "UPGRADE"
        public var description: String { return self.rawValue }
    }

    public enum VolumeType: String, CustomStringConvertible, Codable {
        case gp2
        case io1
        case standard
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AWSDomainInformation: AWSEncodableShape & AWSDecodableShape {
        public let domainName: String
        public let ownerId: String?
        public let region: String?

        public init(domainName: String, ownerId: String? = nil, region: String? = nil) {
            self.domainName = domainName
            self.ownerId = ownerId
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.ownerId, name: "ownerId", parent: name, max: 12)
            try self.validate(self.ownerId, name: "ownerId", parent: name, min: 12)
            try self.validate(self.ownerId, name: "ownerId", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.region, name: "region", parent: name, max: 30)
            try self.validate(self.region, name: "region", parent: name, min: 5)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case ownerId = "OwnerId"
            case region = "Region"
        }
    }

    public struct AcceptInboundConnectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectionId", location: .uri(locationName: "ConnectionId"))
        ]

        /// The ID of the inbound connection you want to accept.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AcceptInboundConnectionResponse: AWSDecodableShape {
        /// The  InboundConnection  of the accepted inbound connection.
        public let connection: InboundConnection?

        public init(connection: InboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct AccessPoliciesStatus: AWSDecodableShape {
        /// The access policy configured for the domain. Access policies can be resource-based, IP-based, or IAM-based. See  Configuring access policiesfor more information.
        public let options: String
        /// The status of the access policy for the domain. See OptionStatus for the status information that's included.
        public let status: OptionStatus

        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AddTagsRequest: AWSEncodableShape {
        /// Specify the ARN of the domain you want to add tags to.
        public let arn: String
        /// List of Tag to add to the domain.
        public let tagList: [Tag]

        public init(arn: String, tagList: [Tag]) {
            self.arn = arn
            self.tagList = tagList
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
            try self.tagList.forEach {
                try $0.validate(name: "\(name).tagList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
            case tagList = "TagList"
        }
    }

    public struct AdditionalLimit: AWSDecodableShape {
        ///  Additional limit is specific to a given InstanceType and for each of its  InstanceRole  etc.  Attributes and their details:   MaximumNumberOfDataNodesSupported This attribute is present on the master node only to specify how much data nodes up to which given  ESPartitionInstanceType  can support as master node. MaximumNumberOfDataNodesWithoutMasterNode This attribute is present on data node only to specify how much data nodes of given  ESPartitionInstanceType  up to which you don't need any master nodes to govern them.
        public let limitName: String?
        ///  Value for a given  AdditionalLimit$LimitName  .
        public let limitValues: [String]?

        public init(limitName: String? = nil, limitValues: [String]? = nil) {
            self.limitName = limitName
            self.limitValues = limitValues
        }

        private enum CodingKeys: String, CodingKey {
            case limitName = "LimitName"
            case limitValues = "LimitValues"
        }
    }

    public struct AdvancedOptionsStatus: AWSDecodableShape {
        /// The status of advanced options for the specified domain.
        public let options: [String: String]
        /// The OptionStatus for advanced options for the specified domain.
        public let status: OptionStatus

        public init(options: [String: String], status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AdvancedSecurityOptions: AWSDecodableShape {
        /// True if advanced security is enabled.
        public let enabled: Bool?
        /// True if the internal user database is enabled.
        public let internalUserDatabaseEnabled: Bool?
        /// Describes the SAML application configured for a domain.
        public let sAMLOptions: SAMLOptionsOutput?

        public init(enabled: Bool? = nil, internalUserDatabaseEnabled: Bool? = nil, sAMLOptions: SAMLOptionsOutput? = nil) {
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.sAMLOptions = sAMLOptions
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
            case sAMLOptions = "SAMLOptions"
        }
    }

    public struct AdvancedSecurityOptionsInput: AWSEncodableShape {
        /// True if advanced security is enabled.
        public let enabled: Bool?
        /// True if the internal user database is enabled.
        public let internalUserDatabaseEnabled: Bool?
        /// Credentials for the master user: username and password, ARN, or both.
        public let masterUserOptions: MasterUserOptions?
        /// The SAML application configuration for the domain.
        public let sAMLOptions: SAMLOptionsInput?

        public init(enabled: Bool? = nil, internalUserDatabaseEnabled: Bool? = nil, masterUserOptions: MasterUserOptions? = nil, sAMLOptions: SAMLOptionsInput? = nil) {
            self.enabled = enabled
            self.internalUserDatabaseEnabled = internalUserDatabaseEnabled
            self.masterUserOptions = masterUserOptions
            self.sAMLOptions = sAMLOptions
        }

        public func validate(name: String) throws {
            try self.masterUserOptions?.validate(name: "\(name).masterUserOptions")
            try self.sAMLOptions?.validate(name: "\(name).sAMLOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case internalUserDatabaseEnabled = "InternalUserDatabaseEnabled"
            case masterUserOptions = "MasterUserOptions"
            case sAMLOptions = "SAMLOptions"
        }
    }

    public struct AdvancedSecurityOptionsStatus: AWSDecodableShape {
        /// Advanced security options for the specified domain.
        public let options: AdvancedSecurityOptions
        /// Status of the advanced security options for the specified domain.
        public let status: OptionStatus

        public init(options: AdvancedSecurityOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AssociatePackageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "packageID", location: .uri(locationName: "PackageID"))
        ]

        /// The name of the domain to associate the package with.
        public let domainName: String
        /// Internal ID of the package to associate with a domain. Use DescribePackages to find this value.
        public let packageID: String

        public init(domainName: String, packageID: String) {
            self.domainName = domainName
            self.packageID = packageID
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct AssociatePackageResponse: AWSDecodableShape {
        ///  DomainPackageDetails
        public let domainPackageDetails: DomainPackageDetails?

        public init(domainPackageDetails: DomainPackageDetails? = nil) {
            self.domainPackageDetails = domainPackageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetails = "DomainPackageDetails"
        }
    }

    public struct AutoTune: AWSDecodableShape {
        /// Specifies details about the Auto-Tune action. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let autoTuneDetails: AutoTuneDetails?
        /// Specifies the Auto-Tune type. Valid value is SCHEDULED_ACTION.
        public let autoTuneType: AutoTuneType?

        public init(autoTuneDetails: AutoTuneDetails? = nil, autoTuneType: AutoTuneType? = nil) {
            self.autoTuneDetails = autoTuneDetails
            self.autoTuneType = autoTuneType
        }

        private enum CodingKeys: String, CodingKey {
            case autoTuneDetails = "AutoTuneDetails"
            case autoTuneType = "AutoTuneType"
        }
    }

    public struct AutoTuneDetails: AWSDecodableShape {
        public let scheduledAutoTuneDetails: ScheduledAutoTuneDetails?

        public init(scheduledAutoTuneDetails: ScheduledAutoTuneDetails? = nil) {
            self.scheduledAutoTuneDetails = scheduledAutoTuneDetails
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledAutoTuneDetails = "ScheduledAutoTuneDetails"
        }
    }

    public struct AutoTuneMaintenanceSchedule: AWSEncodableShape & AWSDecodableShape {
        /// A cron expression for a recurring maintenance schedule. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let cronExpressionForRecurrence: String?
        /// Specifies maintenance schedule duration: duration value and duration unit. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let duration: Duration?
        /// The timestamp at which the Auto-Tune maintenance schedule starts.
        public let startAt: Date?

        public init(cronExpressionForRecurrence: String? = nil, duration: Duration? = nil, startAt: Date? = nil) {
            self.cronExpressionForRecurrence = cronExpressionForRecurrence
            self.duration = duration
            self.startAt = startAt
        }

        public func validate(name: String) throws {
            try self.duration?.validate(name: "\(name).duration")
        }

        private enum CodingKeys: String, CodingKey {
            case cronExpressionForRecurrence = "CronExpressionForRecurrence"
            case duration = "Duration"
            case startAt = "StartAt"
        }
    }

    public struct AutoTuneOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public let desiredState: AutoTuneDesiredState?
        /// A list of maintenance schedules. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let maintenanceSchedules: [AutoTuneMaintenanceSchedule]?
        /// The rollback state while disabling Auto-Tune for the domain. Valid values are NO_ROLLBACK and DEFAULT_ROLLBACK.
        public let rollbackOnDisable: RollbackOnDisable?

        public init(desiredState: AutoTuneDesiredState? = nil, maintenanceSchedules: [AutoTuneMaintenanceSchedule]? = nil, rollbackOnDisable: RollbackOnDisable? = nil) {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
            self.rollbackOnDisable = rollbackOnDisable
        }

        public func validate(name: String) throws {
            try self.maintenanceSchedules?.forEach {
                try $0.validate(name: "\(name).maintenanceSchedules[]")
            }
            try self.validate(self.maintenanceSchedules, name: "maintenanceSchedules", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case desiredState = "DesiredState"
            case maintenanceSchedules = "MaintenanceSchedules"
            case rollbackOnDisable = "RollbackOnDisable"
        }
    }

    public struct AutoTuneOptionsInput: AWSEncodableShape {
        /// The Auto-Tune desired state. Valid values are ENABLED and DISABLED.
        public let desiredState: AutoTuneDesiredState?
        /// A list of maintenance schedules. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let maintenanceSchedules: [AutoTuneMaintenanceSchedule]?

        public init(desiredState: AutoTuneDesiredState? = nil, maintenanceSchedules: [AutoTuneMaintenanceSchedule]? = nil) {
            self.desiredState = desiredState
            self.maintenanceSchedules = maintenanceSchedules
        }

        public func validate(name: String) throws {
            try self.maintenanceSchedules?.forEach {
                try $0.validate(name: "\(name).maintenanceSchedules[]")
            }
            try self.validate(self.maintenanceSchedules, name: "maintenanceSchedules", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case desiredState = "DesiredState"
            case maintenanceSchedules = "MaintenanceSchedules"
        }
    }

    public struct AutoTuneOptionsOutput: AWSDecodableShape {
        /// The error message while enabling or disabling Auto-Tune.
        public let errorMessage: String?
        /// The AutoTuneState for the domain.
        public let state: AutoTuneState?

        public init(errorMessage: String? = nil, state: AutoTuneState? = nil) {
            self.errorMessage = errorMessage
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case state = "State"
        }
    }

    public struct AutoTuneOptionsStatus: AWSDecodableShape {
        /// Specifies Auto-Tune options for the domain.
        public let options: AutoTuneOptions?
        /// The status of the Auto-Tune options for the domain.
        public let status: AutoTuneStatus?

        public init(options: AutoTuneOptions? = nil, status: AutoTuneStatus? = nil) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct AutoTuneStatus: AWSDecodableShape {
        /// The timestamp of the Auto-Tune options creation date.
        public let creationDate: Date
        /// The error message while enabling or disabling Auto-Tune.
        public let errorMessage: String?
        /// Indicates whether the domain is being deleted.
        public let pendingDeletion: Bool?
        /// The AutoTuneState for the domain.
        public let state: AutoTuneState
        /// The timestamp of when the Auto-Tune options were last updated.
        public let updateDate: Date
        /// The latest version of the Auto-Tune options.
        public let updateVersion: Int?

        public init(creationDate: Date, errorMessage: String? = nil, pendingDeletion: Bool? = nil, state: AutoTuneState, updateDate: Date, updateVersion: Int? = nil) {
            self.creationDate = creationDate
            self.errorMessage = errorMessage
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case errorMessage = "ErrorMessage"
            case pendingDeletion = "PendingDeletion"
            case state = "State"
            case updateDate = "UpdateDate"
            case updateVersion = "UpdateVersion"
        }
    }

    public struct CancelServiceSoftwareUpdateRequest: AWSEncodableShape {
        /// The name of the domain that you want to stop the latest service software update on.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct CancelServiceSoftwareUpdateResponse: AWSDecodableShape {
        /// The current status of the OpenSearch service software update.
        public let serviceSoftwareOptions: ServiceSoftwareOptions?

        public init(serviceSoftwareOptions: ServiceSoftwareOptions? = nil) {
            self.serviceSoftwareOptions = serviceSoftwareOptions
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
        }
    }

    public struct ClusterConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the ColdStorageOptions config for a Domain
        public let coldStorageOptions: ColdStorageOptions?
        /// Total number of dedicated master nodes, active and on standby, for the cluster.
        public let dedicatedMasterCount: Int?
        /// A boolean value to indicate whether a dedicated master node is enabled. See Dedicated master nodes in Amazon OpenSearch Service  for more information.
        public let dedicatedMasterEnabled: Bool?
        /// The instance type for a dedicated master node.
        public let dedicatedMasterType: OpenSearchPartitionInstanceType?
        /// The number of instances in the specified domain cluster.
        public let instanceCount: Int?
        /// The instance type for an OpenSearch cluster. UltraWarm instance types are not supported for data instances.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// The number of UltraWarm nodes in the cluster.
        public let warmCount: Int?
        /// True to enable UltraWarm storage.
        public let warmEnabled: Bool?
        /// The instance type for the OpenSearch cluster's warm nodes.
        public let warmType: OpenSearchWarmPartitionInstanceType?
        /// The zone awareness configuration for a domain when zone awareness is enabled.
        public let zoneAwarenessConfig: ZoneAwarenessConfig?
        /// A boolean value to indicate whether zone awareness is enabled. See Configuring a multi-AZ domain in Amazon OpenSearch Service for more information.
        public let zoneAwarenessEnabled: Bool?

        public init(coldStorageOptions: ColdStorageOptions? = nil, dedicatedMasterCount: Int? = nil, dedicatedMasterEnabled: Bool? = nil, dedicatedMasterType: OpenSearchPartitionInstanceType? = nil, instanceCount: Int? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, warmCount: Int? = nil, warmEnabled: Bool? = nil, warmType: OpenSearchWarmPartitionInstanceType? = nil, zoneAwarenessConfig: ZoneAwarenessConfig? = nil, zoneAwarenessEnabled: Bool? = nil) {
            self.coldStorageOptions = coldStorageOptions
            self.dedicatedMasterCount = dedicatedMasterCount
            self.dedicatedMasterEnabled = dedicatedMasterEnabled
            self.dedicatedMasterType = dedicatedMasterType
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.warmCount = warmCount
            self.warmEnabled = warmEnabled
            self.warmType = warmType
            self.zoneAwarenessConfig = zoneAwarenessConfig
            self.zoneAwarenessEnabled = zoneAwarenessEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case coldStorageOptions = "ColdStorageOptions"
            case dedicatedMasterCount = "DedicatedMasterCount"
            case dedicatedMasterEnabled = "DedicatedMasterEnabled"
            case dedicatedMasterType = "DedicatedMasterType"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case warmCount = "WarmCount"
            case warmEnabled = "WarmEnabled"
            case warmType = "WarmType"
            case zoneAwarenessConfig = "ZoneAwarenessConfig"
            case zoneAwarenessEnabled = "ZoneAwarenessEnabled"
        }
    }

    public struct ClusterConfigStatus: AWSDecodableShape {
        /// The cluster configuration for the specified domain.
        public let options: ClusterConfig
        /// The cluster configuration status for the specified domain.
        public let status: OptionStatus

        public init(options: ClusterConfig, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct CognitoOptions: AWSEncodableShape & AWSDecodableShape {
        /// The option to enable Cognito for OpenSearch Dashboards authentication.
        public let enabled: Bool?
        /// The Cognito identity pool ID for OpenSearch Dashboards authentication.
        public let identityPoolId: String?
        /// The role ARN that provides OpenSearch permissions for accessing Cognito resources.
        public let roleArn: String?
        /// The Cognito user pool ID for OpenSearch Dashboards authentication.
        public let userPoolId: String?

        public init(enabled: Bool? = nil, identityPoolId: String? = nil, roleArn: String? = nil, userPoolId: String? = nil) {
            self.enabled = enabled
            self.identityPoolId = identityPoolId
            self.roleArn = roleArn
            self.userPoolId = userPoolId
        }

        public func validate(name: String) throws {
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, max: 55)
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, min: 1)
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, pattern: "^[\\w-]+:[0-9a-f-]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws|aws\\-cn|aws\\-us\\-gov|aws\\-iso|aws\\-iso\\-b):iam::[0-9]+:role\\/")
            try self.validate(self.userPoolId, name: "userPoolId", parent: name, max: 55)
            try self.validate(self.userPoolId, name: "userPoolId", parent: name, min: 1)
            try self.validate(self.userPoolId, name: "userPoolId", parent: name, pattern: "^[\\w-]+_[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case identityPoolId = "IdentityPoolId"
            case roleArn = "RoleArn"
            case userPoolId = "UserPoolId"
        }
    }

    public struct CognitoOptionsStatus: AWSDecodableShape {
        /// Cognito options for the specified domain.
        public let options: CognitoOptions
        /// The status of the Cognito options for the specified domain.
        public let status: OptionStatus

        public init(options: CognitoOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct ColdStorageOptions: AWSEncodableShape & AWSDecodableShape {
        /// Enable cold storage option. Accepted values true or false
        public let enabled: Bool

        public init(enabled: Bool) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct CompatibleVersionsMap: AWSDecodableShape {
        /// The current version of OpenSearch a domain is on.
        public let sourceVersion: String?
        public let targetVersions: [String]?

        public init(sourceVersion: String? = nil, targetVersions: [String]? = nil) {
            self.sourceVersion = sourceVersion
            self.targetVersions = targetVersions
        }

        private enum CodingKeys: String, CodingKey {
            case sourceVersion = "SourceVersion"
            case targetVersions = "TargetVersions"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        /// IAM access policy as a JSON-formatted string.
        public let accessPolicies: String?
        /// Option to allow references to indices in an HTTP request body. Must be false when configuring access to individual sub-resources. By default, the value is true. See Advanced cluster parameters for more information.
        public let advancedOptions: [String: String]?
        /// Specifies advanced security options.
        public let advancedSecurityOptions: AdvancedSecurityOptionsInput?
        /// Specifies Auto-Tune options.
        public let autoTuneOptions: AutoTuneOptionsInput?
        /// Configuration options for a domain. Specifies the instance type and number of instances in the domain.
        public let clusterConfig: ClusterConfig?
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see Configuring Amazon Cognito authentication for OpenSearch Dashboards.
        public let cognitoOptions: CognitoOptions?
        /// Options to specify configurations that will be applied to the domain endpoint.
        public let domainEndpointOptions: DomainEndpointOptions?
        /// The name of the Amazon OpenSearch Service domain you're creating. Domain names are unique across the domains owned by an account within an AWS region. Domain names must start with a lowercase letter and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public let domainName: String
        /// Options to enable, disable, and specify the type and size of EBS storage volumes.
        public let eBSOptions: EBSOptions?
        /// Options for encryption of data at rest.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the Amazon OpenSearch Service domain. For example, "OpenSearch_1.0" or "Elasticsearch_7.9". For more information, see Creating and managing Amazon OpenSearch Service domains .
        public let engineVersion: String?
        /// Map of LogType and LogPublishingOption, each containing options to publish a given type of OpenSearch log.
        public let logPublishingOptions: [LogType: LogPublishingOption]?
        /// Node-to-node encryption options.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
        /// Option to set time, in UTC format, of the daily automated snapshot. Default value is 0 hours.
        public let snapshotOptions: SnapshotOptions?
        /// A list of Tag added during domain creation.
        public let tagList: [Tag]?
        /// Options to specify the subnets and security groups for a VPC endpoint. For more information, see Launching your Amazon OpenSearch Service domains using a VPC .
        public let vPCOptions: VPCOptions?

        public init(accessPolicies: String? = nil, advancedOptions: [String: String]? = nil, advancedSecurityOptions: AdvancedSecurityOptionsInput? = nil, autoTuneOptions: AutoTuneOptionsInput? = nil, clusterConfig: ClusterConfig? = nil, cognitoOptions: CognitoOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, domainName: String, eBSOptions: EBSOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, engineVersion: String? = nil, logPublishingOptions: [LogType: LogPublishingOption]? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, snapshotOptions: SnapshotOptions? = nil, tagList: [Tag]? = nil, vPCOptions: VPCOptions? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.domainName = domainName
            self.eBSOptions = eBSOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.snapshotOptions = snapshotOptions
            self.tagList = tagList
            self.vPCOptions = vPCOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, max: 102_400)
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: ".*")
            try self.advancedSecurityOptions?.validate(name: "\(name).advancedSecurityOptions")
            try self.autoTuneOptions?.validate(name: "\(name).autoTuneOptions")
            try self.cognitoOptions?.validate(name: "\(name).cognitoOptions")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 18)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 14)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
            try self.logPublishingOptions?.forEach {
                try $0.value.validate(name: "\(name).logPublishingOptions[\"\($0.key)\"]")
            }
            try self.tagList?.forEach {
                try $0.validate(name: "\(name).tagList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case autoTuneOptions = "AutoTuneOptions"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainName = "DomainName"
            case eBSOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case engineVersion = "EngineVersion"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case snapshotOptions = "SnapshotOptions"
            case tagList = "TagList"
            case vPCOptions = "VPCOptions"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The status of the newly created domain.
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct CreateOutboundConnectionRequest: AWSEncodableShape {
        /// The connection alias used used by the customer for this cross-cluster connection.
        public let connectionAlias: String
        /// The  AWSDomainInformation  for the local OpenSearch domain.
        public let localDomainInfo: DomainInformationContainer
        /// The  AWSDomainInformation  for the remote OpenSearch domain.
        public let remoteDomainInfo: DomainInformationContainer

        public init(connectionAlias: String, localDomainInfo: DomainInformationContainer, remoteDomainInfo: DomainInformationContainer) {
            self.connectionAlias = connectionAlias
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionAlias, name: "connectionAlias", parent: name, max: 100)
            try self.validate(self.connectionAlias, name: "connectionAlias", parent: name, min: 2)
            try self.validate(self.connectionAlias, name: "connectionAlias", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9\\-\\_]+$")
            try self.localDomainInfo.validate(name: "\(name).localDomainInfo")
            try self.remoteDomainInfo.validate(name: "\(name).remoteDomainInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case connectionAlias = "ConnectionAlias"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct CreateOutboundConnectionResponse: AWSDecodableShape {
        /// The connection alias provided during the create connection request.
        public let connectionAlias: String?
        /// The unique ID for the created outbound connection, which is used for subsequent operations on the connection.
        public let connectionId: String?
        /// The  OutboundConnectionStatus  for the newly created connection.
        public let connectionStatus: OutboundConnectionStatus?
        /// The  AWSDomainInformation  for the local OpenSearch domain.
        public let localDomainInfo: DomainInformationContainer?
        /// The  AWSDomainInformation  for the remote OpenSearch domain.
        public let remoteDomainInfo: DomainInformationContainer?

        public init(connectionAlias: String? = nil, connectionId: String? = nil, connectionStatus: OutboundConnectionStatus? = nil, localDomainInfo: DomainInformationContainer? = nil, remoteDomainInfo: DomainInformationContainer? = nil) {
            self.connectionAlias = connectionAlias
            self.connectionId = connectionId
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        private enum CodingKeys: String, CodingKey {
            case connectionAlias = "ConnectionAlias"
            case connectionId = "ConnectionId"
            case connectionStatus = "ConnectionStatus"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct CreatePackageRequest: AWSEncodableShape {
        /// Description of the package.
        public let packageDescription: String?
        /// Unique identifier for the package.
        public let packageName: String
        /// The Amazon S3 location from which to import the package.
        public let packageSource: PackageSource
        /// Type of package. Currently supports only TXT-DICTIONARY.
        public let packageType: PackageType

        public init(packageDescription: String? = nil, packageName: String, packageSource: PackageSource, packageType: PackageType) {
            self.packageDescription = packageDescription
            self.packageName = packageName
            self.packageSource = packageSource
            self.packageType = packageType
        }

        public func validate(name: String) throws {
            try self.validate(self.packageDescription, name: "packageDescription", parent: name, max: 1024)
            try self.validate(self.packageName, name: "packageName", parent: name, max: 28)
            try self.validate(self.packageName, name: "packageName", parent: name, min: 3)
            try self.validate(self.packageName, name: "packageName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.packageSource.validate(name: "\(name).packageSource")
        }

        private enum CodingKeys: String, CodingKey {
            case packageDescription = "PackageDescription"
            case packageName = "PackageName"
            case packageSource = "PackageSource"
            case packageType = "PackageType"
        }
    }

    public struct CreatePackageResponse: AWSDecodableShape {
        /// Information about the package.
        public let packageDetails: PackageDetails?

        public init(packageDetails: PackageDetails? = nil) {
            self.packageDetails = packageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case packageDetails = "PackageDetails"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The name of the domain you want to permanently delete.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        /// The status of the domain being deleted.
        public let domainStatus: DomainStatus?

        public init(domainStatus: DomainStatus? = nil) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct DeleteInboundConnectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectionId", location: .uri(locationName: "ConnectionId"))
        ]

        /// The ID of the inbound connection to permanently delete.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInboundConnectionResponse: AWSDecodableShape {
        /// The  InboundConnection  of the deleted inbound connection.
        public let connection: InboundConnection?

        public init(connection: InboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeleteOutboundConnectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectionId", location: .uri(locationName: "ConnectionId"))
        ]

        /// The ID of the outbound connection you want to permanently delete.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOutboundConnectionResponse: AWSDecodableShape {
        /// The  OutboundConnection  of the deleted outbound connection.
        public let connection: OutboundConnection?

        public init(connection: OutboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct DeletePackageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "packageID", location: .uri(locationName: "PackageID"))
        ]

        /// The internal ID of the package you want to delete. Use DescribePackages to find this value.
        public let packageID: String

        public init(packageID: String) {
            self.packageID = packageID
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackageResponse: AWSDecodableShape {
        ///  PackageDetails
        public let packageDetails: PackageDetails?

        public init(packageDetails: PackageDetails? = nil) {
            self.packageDetails = packageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case packageDetails = "PackageDetails"
        }
    }

    public struct DescribeDomainAutoTunesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The domain name for which you want Auto-Tune action details.
        public let domainName: String
        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public let maxResults: Int?
        /// NextToken is sent in case the earlier API call results contain the NextToken. Used for pagination.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeDomainAutoTunesResponse: AWSDecodableShape {
        /// The list of setting adjustments that Auto-Tune has made to the domain. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let autoTunes: [AutoTune]?
        /// An identifier to allow retrieval of paginated results.
        public let nextToken: String?

        public init(autoTunes: [AutoTune]? = nil, nextToken: String? = nil) {
            self.autoTunes = autoTunes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case autoTunes = "AutoTunes"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeDomainConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The domain you want to get information about.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainConfigResponse: AWSDecodableShape {
        /// The configuration information of the domain requested in the DescribeDomainConfig request.
        public let domainConfig: DomainConfig

        public init(domainConfig: DomainConfig) {
            self.domainConfig = domainConfig
        }

        private enum CodingKeys: String, CodingKey {
            case domainConfig = "DomainConfig"
        }
    }

    public struct DescribeDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The name of the domain for which you want information.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeDomainResponse: AWSDecodableShape {
        /// The current status of the domain.
        public let domainStatus: DomainStatus

        public init(domainStatus: DomainStatus) {
            self.domainStatus = domainStatus
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatus = "DomainStatus"
        }
    }

    public struct DescribeDomainsRequest: AWSEncodableShape {
        /// The domains for which you want information.
        public let domainNames: [String]

        public init(domainNames: [String]) {
            self.domainNames = domainNames
        }

        public func validate(name: String) throws {
            try self.domainNames.forEach {
                try validate($0, name: "domainNames[]", parent: name, max: 28)
                try validate($0, name: "domainNames[]", parent: name, min: 3)
                try validate($0, name: "domainNames[]", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct DescribeDomainsResponse: AWSDecodableShape {
        /// The status of the domains requested in the DescribeDomains request.
        public let domainStatusList: [DomainStatus]

        public init(domainStatusList: [DomainStatus]) {
            self.domainStatusList = domainStatusList
        }

        private enum CodingKeys: String, CodingKey {
            case domainStatusList = "DomainStatusList"
        }
    }

    public struct DescribeInboundConnectionsRequest: AWSEncodableShape {
        ///  A list of filters used to match properties for inbound cross-cluster connections. Available  Filter  values are:  connection-id local-domain-info.domain-name local-domain-info.owner-id local-domain-info.region remote-domain-info.domain-name
        public let filters: [Filter]?
        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public let maxResults: Int?
        /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeInboundConnectionsResponse: AWSDecodableShape {
        /// A list of  InboundConnection  matching the specified filter criteria.
        public let connections: [InboundConnection]?
        /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
        public let nextToken: String?

        public init(connections: [InboundConnection]? = nil, nextToken: String? = nil) {
            self.connections = connections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeInstanceTypeLimitsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .querystring(locationName: "domainName")),
            AWSMemberEncoding(label: "engineVersion", location: .uri(locationName: "EngineVersion")),
            AWSMemberEncoding(label: "instanceType", location: .uri(locationName: "InstanceType"))
        ]

        ///  The name of the domain you want to modify. Only include this value if you're querying OpenSearch  Limits  for an existing domain.
        public let domainName: String?
        ///  Version of OpenSearch for which  Limits  are needed.
        public let engineVersion: String
        ///  The instance type for an OpenSearch cluster for which OpenSearch  Limits  are needed.
        public let instanceType: OpenSearchPartitionInstanceType

        public init(domainName: String? = nil, engineVersion: String, instanceType: OpenSearchPartitionInstanceType) {
            self.domainName = domainName
            self.engineVersion = engineVersion
            self.instanceType = instanceType
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 18)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 14)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceTypeLimitsResponse: AWSDecodableShape {
        public let limitsByRole: [String: Limits]?

        public init(limitsByRole: [String: Limits]? = nil) {
            self.limitsByRole = limitsByRole
        }

        private enum CodingKeys: String, CodingKey {
            case limitsByRole = "LimitsByRole"
        }
    }

    public struct DescribeOutboundConnectionsRequest: AWSEncodableShape {
        ///  A list of filters used to match properties for outbound cross-cluster connections. Available  Filter  names for this operation are:  connection-id remote-domain-info.domain-name remote-domain-info.owner-id remote-domain-info.region local-domain-info.domain-name
        public let filters: [Filter]?
        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public let maxResults: Int?
        /// NextToken is sent in case the earlier API call results contain the NextToken parameter. Used for pagination.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribeOutboundConnectionsResponse: AWSDecodableShape {
        /// A list of  OutboundConnection  matching the specified filter criteria.
        public let connections: [OutboundConnection]?
        /// If more results are available and NextToken is present, make the next request to the same API with the received NextToken to paginate the remaining results.
        public let nextToken: String?

        public init(connections: [OutboundConnection]? = nil, nextToken: String? = nil) {
            self.connections = connections
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
            case nextToken = "NextToken"
        }
    }

    public struct DescribePackagesFilter: AWSEncodableShape {
        /// Any field from PackageDetails.
        public let name: DescribePackagesFilterName?
        /// A list of values for the specified field.
        public let value: [String]?

        public init(name: DescribePackagesFilterName? = nil, value: [String]? = nil) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value?.forEach {
                try validate($0, name: "value[]", parent: name, pattern: "^[0-9a-zA-Z\\*\\.\\\\/\\?-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct DescribePackagesRequest: AWSEncodableShape {
        /// Only returns packages that match the DescribePackagesFilterList values.
        public let filters: [DescribePackagesFilter]?
        /// Limits results to a maximum number of packages.
        public let maxResults: Int?
        /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
        public let nextToken: String?

        public init(filters: [DescribePackagesFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct DescribePackagesResponse: AWSDecodableShape {
        public let nextToken: String?
        /// List of PackageDetails objects.
        public let packageDetailsList: [PackageDetails]?

        public init(nextToken: String? = nil, packageDetailsList: [PackageDetails]? = nil) {
            self.nextToken = nextToken
            self.packageDetailsList = packageDetailsList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case packageDetailsList = "PackageDetailsList"
        }
    }

    public struct DescribeReservedInstanceOfferingsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "reservedInstanceOfferingId", location: .querystring(locationName: "offeringId"))
        ]

        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public let maxResults: Int?
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?
        /// The offering identifier filter value. Use this parameter to show only the available offering that matches the specified reservation identifier.
        public let reservedInstanceOfferingId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, reservedInstanceOfferingId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, max: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, min: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReservedInstanceOfferingsResponse: AWSDecodableShape {
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?
        /// List of reserved OpenSearch instance offerings
        public let reservedInstanceOfferings: [ReservedInstanceOffering]?

        public init(nextToken: String? = nil, reservedInstanceOfferings: [ReservedInstanceOffering]? = nil) {
            self.nextToken = nextToken
            self.reservedInstanceOfferings = reservedInstanceOfferings
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reservedInstanceOfferings = "ReservedInstanceOfferings"
        }
    }

    public struct DescribeReservedInstancesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "reservedInstanceId", location: .querystring(locationName: "reservationId"))
        ]

        /// Set this value to limit the number of results returned. If not specified, defaults to 100.
        public let maxResults: Int?
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?
        /// The reserved instance identifier filter value. Use this parameter to show only the reservation that matches the specified reserved OpenSearch instance ID.
        public let reservedInstanceId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, reservedInstanceId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.reservedInstanceId = reservedInstanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.reservedInstanceId, name: "reservedInstanceId", parent: name, max: 36)
            try self.validate(self.reservedInstanceId, name: "reservedInstanceId", parent: name, min: 36)
            try self.validate(self.reservedInstanceId, name: "reservedInstanceId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeReservedInstancesResponse: AWSDecodableShape {
        /// Provides an identifier to allow retrieval of paginated results.
        public let nextToken: String?
        /// List of reserved OpenSearch instances.
        public let reservedInstances: [ReservedInstance]?

        public init(nextToken: String? = nil, reservedInstances: [ReservedInstance]? = nil) {
            self.nextToken = nextToken
            self.reservedInstances = reservedInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case reservedInstances = "ReservedInstances"
        }
    }

    public struct DissociatePackageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "packageID", location: .uri(locationName: "PackageID"))
        ]

        /// The name of the domain to associate the package with.
        public let domainName: String
        /// The internal ID of the package to associate with a domain. Use DescribePackages to find this value.
        public let packageID: String

        public init(domainName: String, packageID: String) {
            self.domainName = domainName
            self.packageID = packageID
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DissociatePackageResponse: AWSDecodableShape {
        ///  DomainPackageDetails
        public let domainPackageDetails: DomainPackageDetails?

        public init(domainPackageDetails: DomainPackageDetails? = nil) {
            self.domainPackageDetails = domainPackageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetails = "DomainPackageDetails"
        }
    }

    public struct DomainConfig: AWSDecodableShape {
        /// IAM access policy as a JSON-formatted string.
        public let accessPolicies: AccessPoliciesStatus?
        /// The AdvancedOptions for the domain. See Advanced options for more information.
        public let advancedOptions: AdvancedOptionsStatus?
        /// Specifies AdvancedSecurityOptions for the domain.
        public let advancedSecurityOptions: AdvancedSecurityOptionsStatus?
        /// Specifies AutoTuneOptions for the domain.
        public let autoTuneOptions: AutoTuneOptionsStatus?
        /// The ClusterConfig for the domain.
        public let clusterConfig: ClusterConfigStatus?
        /// The CognitoOptions for the specified domain. For more information, see Configuring Amazon Cognito authentication for OpenSearch Dashboards.
        public let cognitoOptions: CognitoOptionsStatus?
        /// The DomainEndpointOptions for the domain.
        public let domainEndpointOptions: DomainEndpointOptionsStatus?
        /// The EBSOptions for the domain.
        public let eBSOptions: EBSOptionsStatus?
        /// The EncryptionAtRestOptions for the domain.
        public let encryptionAtRestOptions: EncryptionAtRestOptionsStatus?
        /// String of format Elasticsearch_X.Y or OpenSearch_X.Y to specify the engine version for the OpenSearch or Elasticsearch domain.
        public let engineVersion: VersionStatus?
        /// Log publishing options for the given domain.
        public let logPublishingOptions: LogPublishingOptionsStatus?
        /// The NodeToNodeEncryptionOptions for the domain.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptionsStatus?
        /// The SnapshotOptions for the domain.
        public let snapshotOptions: SnapshotOptionsStatus?
        /// The VPCOptions for the specified domain. For more information, see  Launching your Amazon OpenSearch Service domains using a VPC.
        public let vPCOptions: VPCDerivedInfoStatus?

        public init(accessPolicies: AccessPoliciesStatus? = nil, advancedOptions: AdvancedOptionsStatus? = nil, advancedSecurityOptions: AdvancedSecurityOptionsStatus? = nil, autoTuneOptions: AutoTuneOptionsStatus? = nil, clusterConfig: ClusterConfigStatus? = nil, cognitoOptions: CognitoOptionsStatus? = nil, domainEndpointOptions: DomainEndpointOptionsStatus? = nil, eBSOptions: EBSOptionsStatus? = nil, encryptionAtRestOptions: EncryptionAtRestOptionsStatus? = nil, engineVersion: VersionStatus? = nil, logPublishingOptions: LogPublishingOptionsStatus? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptionsStatus? = nil, snapshotOptions: SnapshotOptionsStatus? = nil, vPCOptions: VPCDerivedInfoStatus? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.eBSOptions = eBSOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.engineVersion = engineVersion
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.snapshotOptions = snapshotOptions
            self.vPCOptions = vPCOptions
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case autoTuneOptions = "AutoTuneOptions"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case domainEndpointOptions = "DomainEndpointOptions"
            case eBSOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case engineVersion = "EngineVersion"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case snapshotOptions = "SnapshotOptions"
            case vPCOptions = "VPCOptions"
        }
    }

    public struct DomainEndpointOptions: AWSEncodableShape & AWSDecodableShape {
        /// The fully qualified domain for your custom endpoint.
        public let customEndpoint: String?
        /// The ACM certificate ARN for your custom endpoint.
        public let customEndpointCertificateArn: String?
        /// Whether to enable a custom endpoint for the domain.
        public let customEndpointEnabled: Bool?
        /// Whether only HTTPS endpoint should be enabled for the domain.
        public let enforceHTTPS: Bool?
        /// Specify the TLS security policy to apply to the HTTPS endpoint of the domain.  Can be one of the following values:   Policy-Min-TLS-1-0-2019-07: TLS security policy which supports TLSv1.0 and higher.   Policy-Min-TLS-1-2-2019-07: TLS security policy which supports only TLSv1.2
        public let tLSSecurityPolicy: TLSSecurityPolicy?

        public init(customEndpoint: String? = nil, customEndpointCertificateArn: String? = nil, customEndpointEnabled: Bool? = nil, enforceHTTPS: Bool? = nil, tLSSecurityPolicy: TLSSecurityPolicy? = nil) {
            self.customEndpoint = customEndpoint
            self.customEndpointCertificateArn = customEndpointCertificateArn
            self.customEndpointEnabled = customEndpointEnabled
            self.enforceHTTPS = enforceHTTPS
            self.tLSSecurityPolicy = tLSSecurityPolicy
        }

        public func validate(name: String) throws {
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, max: 255)
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, min: 1)
            try self.validate(self.customEndpoint, name: "customEndpoint", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, max: 2048)
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, min: 20)
            try self.validate(self.customEndpointCertificateArn, name: "customEndpointCertificateArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case customEndpoint = "CustomEndpoint"
            case customEndpointCertificateArn = "CustomEndpointCertificateArn"
            case customEndpointEnabled = "CustomEndpointEnabled"
            case enforceHTTPS = "EnforceHTTPS"
            case tLSSecurityPolicy = "TLSSecurityPolicy"
        }
    }

    public struct DomainEndpointOptionsStatus: AWSDecodableShape {
        /// Options to configure the endpoint for the domain.
        public let options: DomainEndpointOptions
        /// The status of the endpoint options for the domain. See OptionStatus for the status information that's included.
        public let status: OptionStatus

        public init(options: DomainEndpointOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct DomainInfo: AWSDecodableShape {
        /// The DomainName.
        public let domainName: String?
        ///  Specifies the EngineType of the domain.
        public let engineType: EngineType?

        public init(domainName: String? = nil, engineType: EngineType? = nil) {
            self.domainName = domainName
            self.engineType = engineType
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case engineType = "EngineType"
        }
    }

    public struct DomainInformationContainer: AWSEncodableShape & AWSDecodableShape {
        public let aWSDomainInformation: AWSDomainInformation?

        public init(aWSDomainInformation: AWSDomainInformation? = nil) {
            self.aWSDomainInformation = aWSDomainInformation
        }

        public func validate(name: String) throws {
            try self.aWSDomainInformation?.validate(name: "\(name).aWSDomainInformation")
        }

        private enum CodingKeys: String, CodingKey {
            case aWSDomainInformation = "AWSDomainInformation"
        }
    }

    public struct DomainPackageDetails: AWSDecodableShape {
        /// The name of the domain you've associated a package with.
        public let domainName: String?
        /// State of the association. Values are ASSOCIATING, ASSOCIATION_FAILED, ACTIVE, DISSOCIATING, and DISSOCIATION_FAILED.
        public let domainPackageStatus: DomainPackageStatus?
        /// Additional information if the package is in an error state. Null otherwise.
        public let errorDetails: ErrorDetails?
        /// The timestamp of the most recent update to the package association status.
        public let lastUpdated: Date?
        /// The internal ID of the package.
        public let packageID: String?
        /// User-specified name of the package.
        public let packageName: String?
        /// Currently supports only TXT-DICTIONARY.
        public let packageType: PackageType?
        public let packageVersion: String?
        /// The relative path on Amazon OpenSearch Service nodes, which can be used as synonym_path when the package is a synonym file.
        public let referencePath: String?

        public init(domainName: String? = nil, domainPackageStatus: DomainPackageStatus? = nil, errorDetails: ErrorDetails? = nil, lastUpdated: Date? = nil, packageID: String? = nil, packageName: String? = nil, packageType: PackageType? = nil, packageVersion: String? = nil, referencePath: String? = nil) {
            self.domainName = domainName
            self.domainPackageStatus = domainPackageStatus
            self.errorDetails = errorDetails
            self.lastUpdated = lastUpdated
            self.packageID = packageID
            self.packageName = packageName
            self.packageType = packageType
            self.packageVersion = packageVersion
            self.referencePath = referencePath
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case domainPackageStatus = "DomainPackageStatus"
            case errorDetails = "ErrorDetails"
            case lastUpdated = "LastUpdated"
            case packageID = "PackageID"
            case packageName = "PackageName"
            case packageType = "PackageType"
            case packageVersion = "PackageVersion"
            case referencePath = "ReferencePath"
        }
    }

    public struct DomainStatus: AWSDecodableShape {
        /// IAM access policy as a JSON-formatted string.
        public let accessPolicies: String?
        /// The status of the AdvancedOptions.
        public let advancedOptions: [String: String]?
        /// The current status of the domain's advanced security options.
        public let advancedSecurityOptions: AdvancedSecurityOptions?
        /// The Amazon Resource Name (ARN) of a domain. See IAM identifiers in the AWS Identity and Access Management User Guide for more information.
        public let arn: String
        /// The current status of the domain's Auto-Tune options.
        public let autoTuneOptions: AutoTuneOptionsOutput?
        /// The type and number of instances in the domain.
        public let clusterConfig: ClusterConfig
        /// The CognitoOptions for the specified domain. For more information, see Configuring Amazon Cognito authentication for OpenSearch Dashboards.
        public let cognitoOptions: CognitoOptions?
        /// The domain creation status. True if the creation of a domain is complete.  False if domain creation is still in progress.
        public let created: Bool?
        /// The domain deletion status. True if a delete request has been received for the domain but resource cleanup is still in progress. False if the domain has not been deleted. Once domain deletion is complete, the status of the domain is no longer returned.
        public let deleted: Bool?
        /// The current status of the domain's endpoint options.
        public let domainEndpointOptions: DomainEndpointOptions?
        /// The unique identifier for the specified domain.
        public let domainId: String
        /// The name of a domain. Domain names are unique across the domains owned by an account within an AWS region. Domain names start with a letter or number and can contain the following characters: a-z (lowercase), 0-9, and - (hyphen).
        public let domainName: String
        /// The EBSOptions for the specified domain.
        public let eBSOptions: EBSOptions?
        /// The status of the EncryptionAtRestOptions.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// The domain endpoint that you use to submit index and search requests.
        public let endpoint: String?
        /// Map containing the domain endpoints used to submit index and search requests. Example key, value: 'vpc','vpc-endpoint-h2dsd34efgyghrtguk5gt6j2foh4.us-east-1.es.amazonaws.com'.
        public let endpoints: [String: String]?
        public let engineVersion: String?
        /// Log publishing options for the given domain.
        public let logPublishingOptions: [LogType: LogPublishingOption]?
        /// The status of the NodeToNodeEncryptionOptions.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
        /// The status of the domain configuration. True if Amazon OpenSearch Service is processing configuration changes. False if the configuration is active.
        public let processing: Bool?
        /// The current status of the domain's service software.
        public let serviceSoftwareOptions: ServiceSoftwareOptions?
        /// The status of the SnapshotOptions.
        public let snapshotOptions: SnapshotOptions?
        /// The status of a domain version upgrade. True if Amazon OpenSearch Service is undergoing a version upgrade. False if the configuration is active.
        public let upgradeProcessing: Bool?
        /// The VPCOptions for the specified domain. For more information, see  Launching your Amazon OpenSearch Service domains using a VPC.
        public let vPCOptions: VPCDerivedInfo?

        public init(accessPolicies: String? = nil, advancedOptions: [String: String]? = nil, advancedSecurityOptions: AdvancedSecurityOptions? = nil, arn: String, autoTuneOptions: AutoTuneOptionsOutput? = nil, clusterConfig: ClusterConfig, cognitoOptions: CognitoOptions? = nil, created: Bool? = nil, deleted: Bool? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, domainId: String, domainName: String, eBSOptions: EBSOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, endpoint: String? = nil, endpoints: [String: String]? = nil, engineVersion: String? = nil, logPublishingOptions: [LogType: LogPublishingOption]? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, processing: Bool? = nil, serviceSoftwareOptions: ServiceSoftwareOptions? = nil, snapshotOptions: SnapshotOptions? = nil, upgradeProcessing: Bool? = nil, vPCOptions: VPCDerivedInfo? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.arn = arn
            self.autoTuneOptions = autoTuneOptions
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.created = created
            self.deleted = deleted
            self.domainEndpointOptions = domainEndpointOptions
            self.domainId = domainId
            self.domainName = domainName
            self.eBSOptions = eBSOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.endpoint = endpoint
            self.endpoints = endpoints
            self.engineVersion = engineVersion
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.processing = processing
            self.serviceSoftwareOptions = serviceSoftwareOptions
            self.snapshotOptions = snapshotOptions
            self.upgradeProcessing = upgradeProcessing
            self.vPCOptions = vPCOptions
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case arn = "ARN"
            case autoTuneOptions = "AutoTuneOptions"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case created = "Created"
            case deleted = "Deleted"
            case domainEndpointOptions = "DomainEndpointOptions"
            case domainId = "DomainId"
            case domainName = "DomainName"
            case eBSOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case endpoint = "Endpoint"
            case endpoints = "Endpoints"
            case engineVersion = "EngineVersion"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case processing = "Processing"
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
            case snapshotOptions = "SnapshotOptions"
            case upgradeProcessing = "UpgradeProcessing"
            case vPCOptions = "VPCOptions"
        }
    }

    public struct Duration: AWSEncodableShape & AWSDecodableShape {
        /// The unit of a maintenance schedule duration. Valid value is HOURS. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let unit: TimeUnit?
        /// Integer to specify the value of a maintenance schedule duration. See  Auto-Tune for Amazon OpenSearch Service for more information.
        public let value: Int64?

        public init(unit: TimeUnit? = nil, value: Int64? = nil) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 24)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "Unit"
            case value = "Value"
        }
    }

    public struct EBSOptions: AWSEncodableShape & AWSDecodableShape {
        /// Whether EBS-based storage is enabled.
        public let eBSEnabled: Bool?
        /// The IOPD for a Provisioned IOPS EBS volume (SSD).
        public let iops: Int?
        /// Integer to specify the size of an EBS volume.
        public let volumeSize: Int?
        /// The volume type for EBS-based storage.
        public let volumeType: VolumeType?

        public init(eBSEnabled: Bool? = nil, iops: Int? = nil, volumeSize: Int? = nil, volumeType: VolumeType? = nil) {
            self.eBSEnabled = eBSEnabled
            self.iops = iops
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }

        private enum CodingKeys: String, CodingKey {
            case eBSEnabled = "EBSEnabled"
            case iops = "Iops"
            case volumeSize = "VolumeSize"
            case volumeType = "VolumeType"
        }
    }

    public struct EBSOptionsStatus: AWSDecodableShape {
        /// The EBS options for the specified domain.
        public let options: EBSOptions
        /// The status of the EBS options for the specified domain.
        public let status: OptionStatus

        public init(options: EBSOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct EncryptionAtRestOptions: AWSEncodableShape & AWSDecodableShape {
        /// The option to enable encryption at rest.
        public let enabled: Bool?
        /// The KMS key ID for encryption at rest options.
        public let kmsKeyId: String?

        public init(enabled: Bool? = nil, kmsKeyId: String? = nil) {
            self.enabled = enabled
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 500)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case kmsKeyId = "KmsKeyId"
        }
    }

    public struct EncryptionAtRestOptionsStatus: AWSDecodableShape {
        /// The Encryption At Rest options for the specified domain.
        public let options: EncryptionAtRestOptions
        /// The status of the Encryption At Rest options for the specified domain.
        public let status: OptionStatus

        public init(options: EncryptionAtRestOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct ErrorDetails: AWSDecodableShape {
        public let errorMessage: String?
        public let errorType: String?

        public init(errorMessage: String? = nil, errorType: String? = nil) {
            self.errorMessage = errorMessage
            self.errorType = errorType
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "ErrorMessage"
            case errorType = "ErrorType"
        }
    }

    public struct Filter: AWSEncodableShape {
        ///  The name of the filter.
        public let name: String?
        ///  Contains one or more values for the filter.
        public let values: [String]?

        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]+$")
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
                try validate($0, name: "values[]", parent: name, min: 1)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.]+$")
            }
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct GetCompatibleVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .querystring(locationName: "domainName"))
        ]

        public let domainName: String?

        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCompatibleVersionsResponse: AWSDecodableShape {
        ///  A map of compatible OpenSearch versions returned as part of the  GetCompatibleVersions  operation.
        public let compatibleVersions: [CompatibleVersionsMap]?

        public init(compatibleVersions: [CompatibleVersionsMap]? = nil) {
            self.compatibleVersions = compatibleVersions
        }

        private enum CodingKeys: String, CodingKey {
            case compatibleVersions = "CompatibleVersions"
        }
    }

    public struct GetPackageVersionHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "packageID", location: .uri(locationName: "PackageID"))
        ]

        /// Limits results to a maximum number of package versions.
        public let maxResults: Int?
        /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
        public let nextToken: String?
        /// Returns an audit history of package versions.
        public let packageID: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, packageID: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packageID = packageID
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPackageVersionHistoryResponse: AWSDecodableShape {
        public let nextToken: String?
        public let packageID: String?
        /// List of PackageVersionHistory objects.
        public let packageVersionHistoryList: [PackageVersionHistory]?

        public init(nextToken: String? = nil, packageID: String? = nil, packageVersionHistoryList: [PackageVersionHistory]? = nil) {
            self.nextToken = nextToken
            self.packageID = packageID
            self.packageVersionHistoryList = packageVersionHistoryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case packageID = "PackageID"
            case packageVersionHistoryList = "PackageVersionHistoryList"
        }
    }

    public struct GetUpgradeHistoryRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let domainName: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUpgradeHistoryResponse: AWSDecodableShape {
        /// Pagination token that needs to be supplied to the next call to get the next page of results.
        public let nextToken: String?
        ///  A list of  UpgradeHistory  objects corresponding to each upgrade or upgrade eligibility check performed on a domain returned as part of the  GetUpgradeHistoryResponse  object.
        public let upgradeHistories: [UpgradeHistory]?

        public init(nextToken: String? = nil, upgradeHistories: [UpgradeHistory]? = nil) {
            self.nextToken = nextToken
            self.upgradeHistories = upgradeHistories
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case upgradeHistories = "UpgradeHistories"
        }
    }

    public struct GetUpgradeStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUpgradeStatusResponse: AWSDecodableShape {
        ///  One of four statuses an upgrade have, returned as part of the  GetUpgradeStatusResponse  object. The status can take one of the following values:  In Progress Succeeded Succeeded with Issues Failed
        public let stepStatus: UpgradeStatus?
        /// A string that briefly describes the update.
        public let upgradeName: String?
        ///  One of three steps an upgrade or upgrade eligibility check goes through:  PreUpgradeCheck Snapshot Upgrade
        public let upgradeStep: UpgradeStep?

        public init(stepStatus: UpgradeStatus? = nil, upgradeName: String? = nil, upgradeStep: UpgradeStep? = nil) {
            self.stepStatus = stepStatus
            self.upgradeName = upgradeName
            self.upgradeStep = upgradeStep
        }

        private enum CodingKeys: String, CodingKey {
            case stepStatus = "StepStatus"
            case upgradeName = "UpgradeName"
            case upgradeStep = "UpgradeStep"
        }
    }

    public struct InboundConnection: AWSDecodableShape {
        /// The connection ID for the inbound cross-cluster connection.
        public let connectionId: String?
        /// The  InboundConnectionStatus  for the outbound connection.
        public let connectionStatus: InboundConnectionStatus?
        /// The  AWSDomainInformation  for the local OpenSearch domain.
        public let localDomainInfo: DomainInformationContainer?
        /// The  AWSDomainInformation  for the remote OpenSearch domain.
        public let remoteDomainInfo: DomainInformationContainer?

        public init(connectionId: String? = nil, connectionStatus: InboundConnectionStatus? = nil, localDomainInfo: DomainInformationContainer? = nil, remoteDomainInfo: DomainInformationContainer? = nil) {
            self.connectionId = connectionId
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "ConnectionId"
            case connectionStatus = "ConnectionStatus"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct InboundConnectionStatus: AWSDecodableShape {
        /// Verbose information for the inbound connection status.
        public let message: String?
        /// The state code for the inbound connection. Can be one of the following:  PENDING_ACCEPTANCE: Inbound connection is not yet accepted by the remote domain owner. APPROVED: Inbound connection is pending acceptance by the remote domain owner. PROVISIONING: Inbound connection provisioning is in progress. ACTIVE: Inbound connection is active and ready to use. REJECTING: Inbound connection rejection is in process. REJECTED: Inbound connection is rejected. DELETING: Inbound connection deletion is in progress. DELETED: Inbound connection is deleted and can no longer be used.
        public let statusCode: InboundConnectionStatusCode?

        public init(message: String? = nil, statusCode: InboundConnectionStatusCode? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct InstanceCountLimits: AWSDecodableShape {
        public let maximumInstanceCount: Int?
        public let minimumInstanceCount: Int?

        public init(maximumInstanceCount: Int? = nil, minimumInstanceCount: Int? = nil) {
            self.maximumInstanceCount = maximumInstanceCount
            self.minimumInstanceCount = minimumInstanceCount
        }

        private enum CodingKeys: String, CodingKey {
            case maximumInstanceCount = "MaximumInstanceCount"
            case minimumInstanceCount = "MinimumInstanceCount"
        }
    }

    public struct InstanceLimits: AWSDecodableShape {
        public let instanceCountLimits: InstanceCountLimits?

        public init(instanceCountLimits: InstanceCountLimits? = nil) {
            self.instanceCountLimits = instanceCountLimits
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCountLimits = "InstanceCountLimits"
        }
    }

    public struct InstanceTypeDetails: AWSDecodableShape {
        public let advancedSecurityEnabled: Bool?
        public let appLogsEnabled: Bool?
        public let cognitoEnabled: Bool?
        public let encryptionEnabled: Bool?
        public let instanceRole: [String]?
        public let instanceType: OpenSearchPartitionInstanceType?
        public let warmEnabled: Bool?

        public init(advancedSecurityEnabled: Bool? = nil, appLogsEnabled: Bool? = nil, cognitoEnabled: Bool? = nil, encryptionEnabled: Bool? = nil, instanceRole: [String]? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, warmEnabled: Bool? = nil) {
            self.advancedSecurityEnabled = advancedSecurityEnabled
            self.appLogsEnabled = appLogsEnabled
            self.cognitoEnabled = cognitoEnabled
            self.encryptionEnabled = encryptionEnabled
            self.instanceRole = instanceRole
            self.instanceType = instanceType
            self.warmEnabled = warmEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case advancedSecurityEnabled = "AdvancedSecurityEnabled"
            case appLogsEnabled = "AppLogsEnabled"
            case cognitoEnabled = "CognitoEnabled"
            case encryptionEnabled = "EncryptionEnabled"
            case instanceRole = "InstanceRole"
            case instanceType = "InstanceType"
            case warmEnabled = "WarmEnabled"
        }
    }

    public struct Limits: AWSDecodableShape {
        ///  List of additional limits that are specific to a given InstanceType and for each of its  InstanceRole  .
        public let additionalLimits: [AdditionalLimit]?
        public let instanceLimits: InstanceLimits?
        /// Storage-related types and attributes that are available for a given InstanceType.
        public let storageTypes: [StorageType]?

        public init(additionalLimits: [AdditionalLimit]? = nil, instanceLimits: InstanceLimits? = nil, storageTypes: [StorageType]? = nil) {
            self.additionalLimits = additionalLimits
            self.instanceLimits = instanceLimits
            self.storageTypes = storageTypes
        }

        private enum CodingKeys: String, CodingKey {
            case additionalLimits = "AdditionalLimits"
            case instanceLimits = "InstanceLimits"
            case storageTypes = "StorageTypes"
        }
    }

    public struct ListDomainNamesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "engineType", location: .querystring(locationName: "engineType"))
        ]

        ///  Optional parameter to filter the output by domain engine type. Acceptable values are 'Elasticsearch' and 'OpenSearch'.
        public let engineType: EngineType?

        public init(engineType: EngineType? = nil) {
            self.engineType = engineType
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainNamesResponse: AWSDecodableShape {
        /// List of domain names and respective engine types.
        public let domainNames: [DomainInfo]?

        public init(domainNames: [DomainInfo]? = nil) {
            self.domainNames = domainNames
        }

        private enum CodingKeys: String, CodingKey {
            case domainNames = "DomainNames"
        }
    }

    public struct ListDomainsForPackageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "packageID", location: .uri(locationName: "PackageID"))
        ]

        /// Limits the results to a maximum number of domains.
        public let maxResults: Int?
        /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
        public let nextToken: String?
        /// The package for which to list associated domains.
        public let packageID: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, packageID: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packageID = packageID
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsForPackageResponse: AWSDecodableShape {
        /// List of DomainPackageDetails objects.
        public let domainPackageDetailsList: [DomainPackageDetails]?
        public let nextToken: String?

        public init(domainPackageDetailsList: [DomainPackageDetails]? = nil, nextToken: String? = nil) {
            self.domainPackageDetailsList = domainPackageDetailsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetailsList = "DomainPackageDetailsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListInstanceTypeDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .querystring(locationName: "domainName")),
            AWSMemberEncoding(label: "engineVersion", location: .uri(locationName: "EngineVersion")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let domainName: String?
        public let engineVersion: String
        public let maxResults: Int?
        public let nextToken: String?

        public init(domainName: String? = nil, engineVersion: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.engineVersion = engineVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, max: 18)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, min: 14)
            try self.validate(self.engineVersion, name: "engineVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstanceTypeDetailsResponse: AWSDecodableShape {
        public let instanceTypeDetails: [InstanceTypeDetails]?
        public let nextToken: String?

        public init(instanceTypeDetails: [InstanceTypeDetails]? = nil, nextToken: String? = nil) {
            self.instanceTypeDetails = instanceTypeDetails
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceTypeDetails = "InstanceTypeDetails"
            case nextToken = "NextToken"
        }
    }

    public struct ListPackagesForDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The name of the domain for which you want to list associated packages.
        public let domainName: String
        /// Limits results to a maximum number of packages.
        public let maxResults: Int?
        /// Used for pagination. Only necessary if a previous API call includes a non-null NextToken value. If provided, returns results for the next page.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagesForDomainResponse: AWSDecodableShape {
        /// List of DomainPackageDetails objects.
        public let domainPackageDetailsList: [DomainPackageDetails]?
        /// Pagination token to supply to the next call to get the next page of results.
        public let nextToken: String?

        public init(domainPackageDetailsList: [DomainPackageDetails]? = nil, nextToken: String? = nil) {
            self.domainPackageDetailsList = domainPackageDetailsList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case domainPackageDetailsList = "DomainPackageDetailsList"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "arn", location: .querystring(locationName: "arn"))
        ]

        /// Specify the ARN of the domain that the tags you want to view are attached to.
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsResponse: AWSDecodableShape {
        /// List of Tag for the requested domain.
        public let tagList: [Tag]?

        public init(tagList: [Tag]? = nil) {
            self.tagList = tagList
        }

        private enum CodingKeys: String, CodingKey {
            case tagList = "TagList"
        }
    }

    public struct ListVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        ///  Set this value to limit the number of results returned. Value must be greater than 10 or it won't be honored.
        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVersionsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let versions: [String]?

        public init(nextToken: String? = nil, versions: [String]? = nil) {
            self.nextToken = nextToken
            self.versions = versions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case versions = "Versions"
        }
    }

    public struct LogPublishingOption: AWSEncodableShape & AWSDecodableShape {
        public let cloudWatchLogsLogGroupArn: String?
        /// Whether the given log publishing option is enabled or not.
        public let enabled: Bool?

        public init(cloudWatchLogsLogGroupArn: String? = nil, enabled: Bool? = nil) {
            self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
            self.enabled = enabled
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, max: 2048)
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, min: 20)
            try self.validate(self.cloudWatchLogsLogGroupArn, name: "cloudWatchLogsLogGroupArn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
            case enabled = "Enabled"
        }
    }

    public struct LogPublishingOptionsStatus: AWSDecodableShape {
        /// The log publishing options configured for the domain.
        public let options: [LogType: LogPublishingOption]?
        /// The status of the log publishing options for the domain. See OptionStatus for the status information that's included.
        public let status: OptionStatus?

        public init(options: [LogType: LogPublishingOption]? = nil, status: OptionStatus? = nil) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct MasterUserOptions: AWSEncodableShape {
        /// ARN for the master user (if IAM is enabled).
        public let masterUserARN: String?
        /// The master user's username, which is stored in the Amazon OpenSearch Service domain's internal database.
        public let masterUserName: String?
        /// The master user's password, which is stored in the Amazon OpenSearch Service domain's internal database.
        public let masterUserPassword: String?

        public init(masterUserARN: String? = nil, masterUserName: String? = nil, masterUserPassword: String? = nil) {
            self.masterUserARN = masterUserARN
            self.masterUserName = masterUserName
            self.masterUserPassword = masterUserPassword
        }

        public func validate(name: String) throws {
            try self.validate(self.masterUserARN, name: "masterUserARN", parent: name, max: 2048)
            try self.validate(self.masterUserARN, name: "masterUserARN", parent: name, min: 20)
            try self.validate(self.masterUserARN, name: "masterUserARN", parent: name, pattern: ".*")
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, max: 64)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, min: 1)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, pattern: ".*")
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, max: 128)
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, min: 8)
            try self.validate(self.masterUserPassword, name: "masterUserPassword", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case masterUserARN = "MasterUserARN"
            case masterUserName = "MasterUserName"
            case masterUserPassword = "MasterUserPassword"
        }
    }

    public struct NodeToNodeEncryptionOptions: AWSEncodableShape & AWSDecodableShape {
        /// True to enable node-to-node encryption.
        public let enabled: Bool?

        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
        }
    }

    public struct NodeToNodeEncryptionOptionsStatus: AWSDecodableShape {
        /// The node-to-node encryption options for the specified domain.
        public let options: NodeToNodeEncryptionOptions
        /// The status of the node-to-node encryption options for the specified domain.
        public let status: OptionStatus

        public init(options: NodeToNodeEncryptionOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct OptionStatus: AWSDecodableShape {
        /// The timestamp of when the entity was created.
        public let creationDate: Date
        /// Indicates whether the domain is being deleted.
        public let pendingDeletion: Bool?
        /// Provides the OptionState for the domain.
        public let state: OptionState
        /// The timestamp of the last time the entity was updated.
        public let updateDate: Date
        /// The latest version of the entity.
        public let updateVersion: Int?

        public init(creationDate: Date, pendingDeletion: Bool? = nil, state: OptionState, updateDate: Date, updateVersion: Int? = nil) {
            self.creationDate = creationDate
            self.pendingDeletion = pendingDeletion
            self.state = state
            self.updateDate = updateDate
            self.updateVersion = updateVersion
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case pendingDeletion = "PendingDeletion"
            case state = "State"
            case updateDate = "UpdateDate"
            case updateVersion = "UpdateVersion"
        }
    }

    public struct OutboundConnection: AWSDecodableShape {
        /// The connection alias for the outbound cross-cluster connection.
        public let connectionAlias: String?
        /// The connection ID for the outbound cross-cluster connection.
        public let connectionId: String?
        /// The  OutboundConnectionStatus  for the outbound connection.
        public let connectionStatus: OutboundConnectionStatus?
        /// The  DomainInformation  for the local OpenSearch domain.
        public let localDomainInfo: DomainInformationContainer?
        /// The  DomainInformation  for the remote OpenSearch domain.
        public let remoteDomainInfo: DomainInformationContainer?

        public init(connectionAlias: String? = nil, connectionId: String? = nil, connectionStatus: OutboundConnectionStatus? = nil, localDomainInfo: DomainInformationContainer? = nil, remoteDomainInfo: DomainInformationContainer? = nil) {
            self.connectionAlias = connectionAlias
            self.connectionId = connectionId
            self.connectionStatus = connectionStatus
            self.localDomainInfo = localDomainInfo
            self.remoteDomainInfo = remoteDomainInfo
        }

        private enum CodingKeys: String, CodingKey {
            case connectionAlias = "ConnectionAlias"
            case connectionId = "ConnectionId"
            case connectionStatus = "ConnectionStatus"
            case localDomainInfo = "LocalDomainInfo"
            case remoteDomainInfo = "RemoteDomainInfo"
        }
    }

    public struct OutboundConnectionStatus: AWSDecodableShape {
        /// Verbose information for the outbound connection status.
        public let message: String?
        /// The state code for the outbound connection. Can be one of the following:  VALIDATING: The outbound connection request is being validated. VALIDATION_FAILED: Validation failed for the connection request. PENDING_ACCEPTANCE: Outbound connection request is validated and is not yet accepted by the remote domain owner.  APPROVED: Outbound connection has been approved by the remote domain owner for getting provisioned. PROVISIONING: Outbound connection request is in process. ACTIVE: Outbound connection is active and ready to use. REJECTING: Outbound connection rejection by remote domain owner is in progress. REJECTED: Outbound connection request is rejected by remote domain owner. DELETING: Outbound connection deletion is in progress. DELETED: Outbound connection is deleted and can no longer be used.
        public let statusCode: OutboundConnectionStatusCode?

        public init(message: String? = nil, statusCode: OutboundConnectionStatusCode? = nil) {
            self.message = message
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case statusCode = "StatusCode"
        }
    }

    public struct PackageDetails: AWSDecodableShape {
        public let availablePackageVersion: String?
        /// The timestamp of when the package was created.
        public let createdAt: Date?
        /// Additional information if the package is in an error state. Null otherwise.
        public let errorDetails: ErrorDetails?
        public let lastUpdatedAt: Date?
        /// User-specified description of the package.
        public let packageDescription: String?
        /// Internal ID of the package.
        public let packageID: String?
        /// User-specified name of the package.
        public let packageName: String?
        /// Current state of the package. Values are COPYING, COPY_FAILED, AVAILABLE, DELETING, and DELETE_FAILED.
        public let packageStatus: PackageStatus?
        /// Currently supports only TXT-DICTIONARY.
        public let packageType: PackageType?

        public init(availablePackageVersion: String? = nil, createdAt: Date? = nil, errorDetails: ErrorDetails? = nil, lastUpdatedAt: Date? = nil, packageDescription: String? = nil, packageID: String? = nil, packageName: String? = nil, packageStatus: PackageStatus? = nil, packageType: PackageType? = nil) {
            self.availablePackageVersion = availablePackageVersion
            self.createdAt = createdAt
            self.errorDetails = errorDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.packageDescription = packageDescription
            self.packageID = packageID
            self.packageName = packageName
            self.packageStatus = packageStatus
            self.packageType = packageType
        }

        private enum CodingKeys: String, CodingKey {
            case availablePackageVersion = "AvailablePackageVersion"
            case createdAt = "CreatedAt"
            case errorDetails = "ErrorDetails"
            case lastUpdatedAt = "LastUpdatedAt"
            case packageDescription = "PackageDescription"
            case packageID = "PackageID"
            case packageName = "PackageName"
            case packageStatus = "PackageStatus"
            case packageType = "PackageType"
        }
    }

    public struct PackageSource: AWSEncodableShape {
        /// The name of the Amazon S3 bucket containing the package.
        public let s3BucketName: String?
        /// Key (file name) of the package.
        public let s3Key: String?

        public init(s3BucketName: String? = nil, s3Key: String? = nil) {
            self.s3BucketName = s3BucketName
            self.s3Key = s3Key
        }

        public func validate(name: String) throws {
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 3)
            try self.validate(self.s3Key, name: "s3Key", parent: name, max: 1024)
            try self.validate(self.s3Key, name: "s3Key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketName = "S3BucketName"
            case s3Key = "S3Key"
        }
    }

    public struct PackageVersionHistory: AWSDecodableShape {
        /// A message associated with the package version.
        public let commitMessage: String?
        /// The timestamp of when the package was created.
        public let createdAt: Date?
        /// The package version.
        public let packageVersion: String?

        public init(commitMessage: String? = nil, createdAt: Date? = nil, packageVersion: String? = nil) {
            self.commitMessage = commitMessage
            self.createdAt = createdAt
            self.packageVersion = packageVersion
        }

        private enum CodingKeys: String, CodingKey {
            case commitMessage = "CommitMessage"
            case createdAt = "CreatedAt"
            case packageVersion = "PackageVersion"
        }
    }

    public struct PurchaseReservedInstanceOfferingRequest: AWSEncodableShape {
        /// The number of OpenSearch instances to reserve.
        public let instanceCount: Int?
        /// A customer-specified identifier to track this reservation.
        public let reservationName: String
        /// The ID of the reserved OpenSearch instance offering to purchase.
        public let reservedInstanceOfferingId: String

        public init(instanceCount: Int? = nil, reservationName: String, reservedInstanceOfferingId: String) {
            self.instanceCount = instanceCount
            self.reservationName = reservationName
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceCount, name: "instanceCount", parent: name, min: 1)
            try self.validate(self.reservationName, name: "reservationName", parent: name, max: 64)
            try self.validate(self.reservationName, name: "reservationName", parent: name, min: 5)
            try self.validate(self.reservationName, name: "reservationName", parent: name, pattern: ".*")
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, max: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, min: 36)
            try self.validate(self.reservedInstanceOfferingId, name: "reservedInstanceOfferingId", parent: name, pattern: "^\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceCount = "InstanceCount"
            case reservationName = "ReservationName"
            case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
        }
    }

    public struct PurchaseReservedInstanceOfferingResponse: AWSDecodableShape {
        /// The customer-specified identifier used to track this reservation.
        public let reservationName: String?
        /// Details of the reserved OpenSearch instance which was purchased.
        public let reservedInstanceId: String?

        public init(reservationName: String? = nil, reservedInstanceId: String? = nil) {
            self.reservationName = reservationName
            self.reservedInstanceId = reservedInstanceId
        }

        private enum CodingKeys: String, CodingKey {
            case reservationName = "ReservationName"
            case reservedInstanceId = "ReservedInstanceId"
        }
    }

    public struct RecurringCharge: AWSDecodableShape {
        /// The monetary amount of the recurring charge.
        public let recurringChargeAmount: Double?
        /// The frequency of the recurring charge.
        public let recurringChargeFrequency: String?

        public init(recurringChargeAmount: Double? = nil, recurringChargeFrequency: String? = nil) {
            self.recurringChargeAmount = recurringChargeAmount
            self.recurringChargeFrequency = recurringChargeFrequency
        }

        private enum CodingKeys: String, CodingKey {
            case recurringChargeAmount = "RecurringChargeAmount"
            case recurringChargeFrequency = "RecurringChargeFrequency"
        }
    }

    public struct RejectInboundConnectionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "connectionId", location: .uri(locationName: "ConnectionId"))
        ]

        /// The ID of the inbound connection to reject.
        public let connectionId: String

        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 256)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 10)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RejectInboundConnectionResponse: AWSDecodableShape {
        /// The  InboundConnection  of the rejected inbound connection.
        public let connection: InboundConnection?

        public init(connection: InboundConnection? = nil) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct RemoveTagsRequest: AWSEncodableShape {
        /// The ARN of the domain from which you want to delete the specified tags.
        public let arn: String
        /// The TagKey list you want to remove from the domain.
        public let tagKeys: [String]

        public init(arn: String, tagKeys: [String]) {
            self.arn = arn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct ReservedInstance: AWSDecodableShape {
        public let billingSubscriptionId: Int64?
        /// The currency code for the reserved OpenSearch instance offering.
        public let currencyCode: String?
        /// The duration, in seconds, for which the OpenSearch instance is reserved.
        public let duration: Int?
        /// The upfront fixed charge you will paid to purchase the specific reserved OpenSearch instance offering.
        public let fixedPrice: Double?
        /// The number of OpenSearch instances that have been reserved.
        public let instanceCount: Int?
        /// The OpenSearch instance type offered by the reserved instance offering.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// The payment option as defined in the reserved OpenSearch instance offering.
        public let paymentOption: ReservedInstancePaymentOption?
        /// The charge to your account regardless of whether you are creating any domains using the instance offering.
        public let recurringCharges: [RecurringCharge]?
        /// The customer-specified identifier to track this reservation.
        public let reservationName: String?
        /// The unique identifier for the reservation.
        public let reservedInstanceId: String?
        /// The offering identifier.
        public let reservedInstanceOfferingId: String?
        /// The time the reservation started.
        public let startTime: Date?
        /// The state of the reserved OpenSearch instance.
        public let state: String?
        /// The rate you are charged for each hour for the domain that is using this reserved instance.
        public let usagePrice: Double?

        public init(billingSubscriptionId: Int64? = nil, currencyCode: String? = nil, duration: Int? = nil, fixedPrice: Double? = nil, instanceCount: Int? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, paymentOption: ReservedInstancePaymentOption? = nil, recurringCharges: [RecurringCharge]? = nil, reservationName: String? = nil, reservedInstanceId: String? = nil, reservedInstanceOfferingId: String? = nil, startTime: Date? = nil, state: String? = nil, usagePrice: Double? = nil) {
            self.billingSubscriptionId = billingSubscriptionId
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceCount = instanceCount
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservationName = reservationName
            self.reservedInstanceId = reservedInstanceId
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.startTime = startTime
            self.state = state
            self.usagePrice = usagePrice
        }

        private enum CodingKeys: String, CodingKey {
            case billingSubscriptionId = "BillingSubscriptionId"
            case currencyCode = "CurrencyCode"
            case duration = "Duration"
            case fixedPrice = "FixedPrice"
            case instanceCount = "InstanceCount"
            case instanceType = "InstanceType"
            case paymentOption = "PaymentOption"
            case recurringCharges = "RecurringCharges"
            case reservationName = "ReservationName"
            case reservedInstanceId = "ReservedInstanceId"
            case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
            case startTime = "StartTime"
            case state = "State"
            case usagePrice = "UsagePrice"
        }
    }

    public struct ReservedInstanceOffering: AWSDecodableShape {
        /// The currency code for the reserved OpenSearch instance offering.
        public let currencyCode: String?
        /// The duration, in seconds, for which the offering will reserve the OpenSearch instance.
        public let duration: Int?
        /// The upfront fixed charge you will pay to purchase the specific reserved OpenSearch instance offering.
        public let fixedPrice: Double?
        /// The OpenSearch instance type offered by the reserved instance offering.
        public let instanceType: OpenSearchPartitionInstanceType?
        /// Payment option for the reserved OpenSearch instance offering
        public let paymentOption: ReservedInstancePaymentOption?
        /// The charge to your account regardless of whether you are creating any domains using the instance offering.
        public let recurringCharges: [RecurringCharge]?
        /// The OpenSearch reserved instance offering identifier.
        public let reservedInstanceOfferingId: String?
        /// The rate you are charged for each hour the domain that is using the offering is running.
        public let usagePrice: Double?

        public init(currencyCode: String? = nil, duration: Int? = nil, fixedPrice: Double? = nil, instanceType: OpenSearchPartitionInstanceType? = nil, paymentOption: ReservedInstancePaymentOption? = nil, recurringCharges: [RecurringCharge]? = nil, reservedInstanceOfferingId: String? = nil, usagePrice: Double? = nil) {
            self.currencyCode = currencyCode
            self.duration = duration
            self.fixedPrice = fixedPrice
            self.instanceType = instanceType
            self.paymentOption = paymentOption
            self.recurringCharges = recurringCharges
            self.reservedInstanceOfferingId = reservedInstanceOfferingId
            self.usagePrice = usagePrice
        }

        private enum CodingKeys: String, CodingKey {
            case currencyCode = "CurrencyCode"
            case duration = "Duration"
            case fixedPrice = "FixedPrice"
            case instanceType = "InstanceType"
            case paymentOption = "PaymentOption"
            case recurringCharges = "RecurringCharges"
            case reservedInstanceOfferingId = "ReservedInstanceOfferingId"
            case usagePrice = "UsagePrice"
        }
    }

    public struct SAMLIdp: AWSEncodableShape & AWSDecodableShape {
        /// The unique entity ID of the application in SAML identity provider.
        public let entityId: String
        /// The metadata of the SAML application in XML format.
        public let metadataContent: String

        public init(entityId: String, metadataContent: String) {
            self.entityId = entityId
            self.metadataContent = metadataContent
        }

        public func validate(name: String) throws {
            try self.validate(self.entityId, name: "entityId", parent: name, max: 512)
            try self.validate(self.entityId, name: "entityId", parent: name, min: 8)
            try self.validate(self.metadataContent, name: "metadataContent", parent: name, max: 1_048_576)
            try self.validate(self.metadataContent, name: "metadataContent", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case entityId = "EntityId"
            case metadataContent = "MetadataContent"
        }
    }

    public struct SAMLOptionsInput: AWSEncodableShape {
        /// True if SAML is enabled.
        public let enabled: Bool?
        /// The SAML Identity Provider's information.
        public let idp: SAMLIdp?
        /// The backend role that the SAML master user is mapped to.
        public let masterBackendRole: String?
        /// The SAML master username, which is stored in the Amazon OpenSearch Service domain's internal database.
        public let masterUserName: String?
        /// Element of the SAML assertion to use for backend roles. Default is roles.
        public let rolesKey: String?
        /// The duration, in minutes, after which a user session becomes inactive. Acceptable values are between 1 and 1440, and the default value is 60.
        public let sessionTimeoutMinutes: Int?
        /// Element of the SAML assertion to use for username. Default is NameID.
        public let subjectKey: String?

        public init(enabled: Bool? = nil, idp: SAMLIdp? = nil, masterBackendRole: String? = nil, masterUserName: String? = nil, rolesKey: String? = nil, sessionTimeoutMinutes: Int? = nil, subjectKey: String? = nil) {
            self.enabled = enabled
            self.idp = idp
            self.masterBackendRole = masterBackendRole
            self.masterUserName = masterUserName
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }

        public func validate(name: String) throws {
            try self.idp?.validate(name: "\(name).idp")
            try self.validate(self.masterBackendRole, name: "masterBackendRole", parent: name, max: 256)
            try self.validate(self.masterBackendRole, name: "masterBackendRole", parent: name, min: 1)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, max: 64)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, min: 1)
            try self.validate(self.masterUserName, name: "masterUserName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case idp = "Idp"
            case masterBackendRole = "MasterBackendRole"
            case masterUserName = "MasterUserName"
            case rolesKey = "RolesKey"
            case sessionTimeoutMinutes = "SessionTimeoutMinutes"
            case subjectKey = "SubjectKey"
        }
    }

    public struct SAMLOptionsOutput: AWSDecodableShape {
        /// True if SAML is enabled.
        public let enabled: Bool?
        /// Describes the SAML identity provider's information.
        public let idp: SAMLIdp?
        /// The key used for matching the SAML roles attribute.
        public let rolesKey: String?
        /// The duration, in minutes, after which a user session becomes inactive.
        public let sessionTimeoutMinutes: Int?
        /// The key used for matching the SAML subject attribute.
        public let subjectKey: String?

        public init(enabled: Bool? = nil, idp: SAMLIdp? = nil, rolesKey: String? = nil, sessionTimeoutMinutes: Int? = nil, subjectKey: String? = nil) {
            self.enabled = enabled
            self.idp = idp
            self.rolesKey = rolesKey
            self.sessionTimeoutMinutes = sessionTimeoutMinutes
            self.subjectKey = subjectKey
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case idp = "Idp"
            case rolesKey = "RolesKey"
            case sessionTimeoutMinutes = "SessionTimeoutMinutes"
            case subjectKey = "SubjectKey"
        }
    }

    public struct ScheduledAutoTuneDetails: AWSDecodableShape {
        /// The Auto-Tune action description.
        public let action: String?
        /// The Auto-Tune action type. Valid values are JVM_HEAP_SIZE_TUNING and JVM_YOUNG_GEN_TUNING.
        public let actionType: ScheduledAutoTuneActionType?
        /// The timestamp of the Auto-Tune action scheduled for the domain.
        public let date: Date?
        /// The Auto-Tune action severity. Valid values are LOW, MEDIUM, and HIGH.
        public let severity: ScheduledAutoTuneSeverityType?

        public init(action: String? = nil, actionType: ScheduledAutoTuneActionType? = nil, date: Date? = nil, severity: ScheduledAutoTuneSeverityType? = nil) {
            self.action = action
            self.actionType = actionType
            self.date = date
            self.severity = severity
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case actionType = "ActionType"
            case date = "Date"
            case severity = "Severity"
        }
    }

    public struct ServiceSoftwareOptions: AWSDecodableShape {
        /// The timestamp, in Epoch time, until which you can manually request a service software update. After this date, we automatically update your service software.
        public let automatedUpdateDate: Date?
        ///  True if you're able to cancel your service software version update. False if you can't cancel your service software update.
        public let cancellable: Bool?
        /// The current service software version present on the domain.
        public let currentVersion: String?
        /// The description of the UpdateStatus.
        public let description: String?
        /// The new service software version if one is available.
        public let newVersion: String?
        ///  True if a service software is never automatically updated. False if a service software is automatically updated after AutomatedUpdateDate.
        public let optionalDeployment: Bool?
        ///  True if you're able to update your service software version. False if you can't update your service software version.
        public let updateAvailable: Bool?
        /// The status of your service software update. This field can take the following values:  ELIGIBLE, PENDING_UPDATE, IN_PROGRESS, COMPLETED, and  NOT_ELIGIBLE.
        public let updateStatus: DeploymentStatus?

        public init(automatedUpdateDate: Date? = nil, cancellable: Bool? = nil, currentVersion: String? = nil, description: String? = nil, newVersion: String? = nil, optionalDeployment: Bool? = nil, updateAvailable: Bool? = nil, updateStatus: DeploymentStatus? = nil) {
            self.automatedUpdateDate = automatedUpdateDate
            self.cancellable = cancellable
            self.currentVersion = currentVersion
            self.description = description
            self.newVersion = newVersion
            self.optionalDeployment = optionalDeployment
            self.updateAvailable = updateAvailable
            self.updateStatus = updateStatus
        }

        private enum CodingKeys: String, CodingKey {
            case automatedUpdateDate = "AutomatedUpdateDate"
            case cancellable = "Cancellable"
            case currentVersion = "CurrentVersion"
            case description = "Description"
            case newVersion = "NewVersion"
            case optionalDeployment = "OptionalDeployment"
            case updateAvailable = "UpdateAvailable"
            case updateStatus = "UpdateStatus"
        }
    }

    public struct SnapshotOptions: AWSEncodableShape & AWSDecodableShape {
        /// The time, in UTC format, when the service takes a daily automated snapshot of the specified domain. Default is 0 hours.
        public let automatedSnapshotStartHour: Int?

        public init(automatedSnapshotStartHour: Int? = nil) {
            self.automatedSnapshotStartHour = automatedSnapshotStartHour
        }

        private enum CodingKeys: String, CodingKey {
            case automatedSnapshotStartHour = "AutomatedSnapshotStartHour"
        }
    }

    public struct SnapshotOptionsStatus: AWSDecodableShape {
        /// The daily snapshot options specified for the domain.
        public let options: SnapshotOptions
        /// The status of a daily automated snapshot.
        public let status: OptionStatus

        public init(options: SnapshotOptions, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct StartServiceSoftwareUpdateRequest: AWSEncodableShape {
        /// The name of the domain that you want to update to the latest service software.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
        }
    }

    public struct StartServiceSoftwareUpdateResponse: AWSDecodableShape {
        /// The current status of the OpenSearch service software update.
        public let serviceSoftwareOptions: ServiceSoftwareOptions?

        public init(serviceSoftwareOptions: ServiceSoftwareOptions? = nil) {
            self.serviceSoftwareOptions = serviceSoftwareOptions
        }

        private enum CodingKeys: String, CodingKey {
            case serviceSoftwareOptions = "ServiceSoftwareOptions"
        }
    }

    public struct StorageType: AWSDecodableShape {
        public let storageSubTypeName: String?
        /// Limits that are applicable for the given storage type.
        public let storageTypeLimits: [StorageTypeLimit]?
        public let storageTypeName: String?

        public init(storageSubTypeName: String? = nil, storageTypeLimits: [StorageTypeLimit]? = nil, storageTypeName: String? = nil) {
            self.storageSubTypeName = storageSubTypeName
            self.storageTypeLimits = storageTypeLimits
            self.storageTypeName = storageTypeName
        }

        private enum CodingKeys: String, CodingKey {
            case storageSubTypeName = "StorageSubTypeName"
            case storageTypeLimits = "StorageTypeLimits"
            case storageTypeName = "StorageTypeName"
        }
    }

    public struct StorageTypeLimit: AWSDecodableShape {
        ///  Name of storage limits that are applicable for the given storage type. If  StorageType  is "ebs", the following storage options are applicable:  MinimumVolumeSize Minimum amount of volume size that is applicable for the given storage type. Can be empty if not applicable. MaximumVolumeSize Maximum amount of volume size that is applicable for the given storage type. Can be empty if not applicable. MaximumIops Maximum amount of Iops that is applicable for given the storage type. Can be empty if not applicable. MinimumIops Minimum amount of Iops that is applicable for given the storage type. Can be empty if not applicable.
        public let limitName: String?
        ///  Values for the  StorageTypeLimit$LimitName  .
        public let limitValues: [String]?

        public init(limitName: String? = nil, limitValues: [String]? = nil) {
            self.limitName = limitName
            self.limitValues = limitValues
        }

        private enum CodingKeys: String, CodingKey {
            case limitName = "LimitName"
            case limitValues = "LimitValues"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The TagKey, the name of the tag. Tag keys must be unique for the domain to which they are attached.
        public let key: String
        /// The TagValue, the value assigned to the corresponding tag key. Tag values can be null and don't have to be unique in a tag set. For example, you can have a key value pair in a tag set of project : Trinity and cost-center : Trinity
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: ".*")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct UpdateDomainConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// IAM access policy as a JSON-formatted string.
        public let accessPolicies: String?
        /// Modifies the advanced option to allow references to indices in an HTTP request body. Must be false when configuring access to individual sub-resources. By default, the value is true. See Advanced options for more information.
        public let advancedOptions: [String: String]?
        /// Specifies advanced security options.
        public let advancedSecurityOptions: AdvancedSecurityOptionsInput?
        /// Specifies Auto-Tune options.
        public let autoTuneOptions: AutoTuneOptions?
        /// The type and number of instances to instantiate for the domain cluster.
        public let clusterConfig: ClusterConfig?
        /// Options to specify the Cognito user and identity pools for OpenSearch Dashboards authentication. For more information, see Configuring Amazon Cognito authentication for OpenSearch Dashboards.
        public let cognitoOptions: CognitoOptions?
        /// Options to specify configuration that will be applied to the domain endpoint.
        public let domainEndpointOptions: DomainEndpointOptions?
        /// The name of the domain you're updating.
        public let domainName: String
        /// Specify the type and size of the EBS volume to use.
        public let eBSOptions: EBSOptions?
        /// Specifies encryption of data at rest options.
        public let encryptionAtRestOptions: EncryptionAtRestOptions?
        /// Map of LogType and LogPublishingOption, each containing options to publish a given type of OpenSearch log.
        public let logPublishingOptions: [LogType: LogPublishingOption]?
        /// Specifies node-to-node encryption options.
        public let nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions?
        /// Option to set the time, in UTC format, for the daily automated snapshot. Default value is 0 hours.
        public let snapshotOptions: SnapshotOptions?
        /// Options to specify the subnets and security groups for the VPC endpoint. For more information, see Launching your Amazon OpenSearch Service domains using a VPC .
        public let vPCOptions: VPCOptions?

        public init(accessPolicies: String? = nil, advancedOptions: [String: String]? = nil, advancedSecurityOptions: AdvancedSecurityOptionsInput? = nil, autoTuneOptions: AutoTuneOptions? = nil, clusterConfig: ClusterConfig? = nil, cognitoOptions: CognitoOptions? = nil, domainEndpointOptions: DomainEndpointOptions? = nil, domainName: String, eBSOptions: EBSOptions? = nil, encryptionAtRestOptions: EncryptionAtRestOptions? = nil, logPublishingOptions: [LogType: LogPublishingOption]? = nil, nodeToNodeEncryptionOptions: NodeToNodeEncryptionOptions? = nil, snapshotOptions: SnapshotOptions? = nil, vPCOptions: VPCOptions? = nil) {
            self.accessPolicies = accessPolicies
            self.advancedOptions = advancedOptions
            self.advancedSecurityOptions = advancedSecurityOptions
            self.autoTuneOptions = autoTuneOptions
            self.clusterConfig = clusterConfig
            self.cognitoOptions = cognitoOptions
            self.domainEndpointOptions = domainEndpointOptions
            self.domainName = domainName
            self.eBSOptions = eBSOptions
            self.encryptionAtRestOptions = encryptionAtRestOptions
            self.logPublishingOptions = logPublishingOptions
            self.nodeToNodeEncryptionOptions = nodeToNodeEncryptionOptions
            self.snapshotOptions = snapshotOptions
            self.vPCOptions = vPCOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, max: 102_400)
            try self.validate(self.accessPolicies, name: "accessPolicies", parent: name, pattern: ".*")
            try self.advancedSecurityOptions?.validate(name: "\(name).advancedSecurityOptions")
            try self.autoTuneOptions?.validate(name: "\(name).autoTuneOptions")
            try self.cognitoOptions?.validate(name: "\(name).cognitoOptions")
            try self.domainEndpointOptions?.validate(name: "\(name).domainEndpointOptions")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.encryptionAtRestOptions?.validate(name: "\(name).encryptionAtRestOptions")
            try self.logPublishingOptions?.forEach {
                try $0.value.validate(name: "\(name).logPublishingOptions[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicies = "AccessPolicies"
            case advancedOptions = "AdvancedOptions"
            case advancedSecurityOptions = "AdvancedSecurityOptions"
            case autoTuneOptions = "AutoTuneOptions"
            case clusterConfig = "ClusterConfig"
            case cognitoOptions = "CognitoOptions"
            case domainEndpointOptions = "DomainEndpointOptions"
            case eBSOptions = "EBSOptions"
            case encryptionAtRestOptions = "EncryptionAtRestOptions"
            case logPublishingOptions = "LogPublishingOptions"
            case nodeToNodeEncryptionOptions = "NodeToNodeEncryptionOptions"
            case snapshotOptions = "SnapshotOptions"
            case vPCOptions = "VPCOptions"
        }
    }

    public struct UpdateDomainConfigResponse: AWSDecodableShape {
        /// The status of the updated domain.
        public let domainConfig: DomainConfig

        public init(domainConfig: DomainConfig) {
            self.domainConfig = domainConfig
        }

        private enum CodingKeys: String, CodingKey {
            case domainConfig = "DomainConfig"
        }
    }

    public struct UpdatePackageRequest: AWSEncodableShape {
        /// A commit message for the new version which is shown as part of GetPackageVersionHistoryResponse.
        public let commitMessage: String?
        /// A new description of the package.
        public let packageDescription: String?
        /// The unique identifier for the package.
        public let packageID: String
        public let packageSource: PackageSource

        public init(commitMessage: String? = nil, packageDescription: String? = nil, packageID: String, packageSource: PackageSource) {
            self.commitMessage = commitMessage
            self.packageDescription = packageDescription
            self.packageID = packageID
            self.packageSource = packageSource
        }

        public func validate(name: String) throws {
            try self.validate(self.commitMessage, name: "commitMessage", parent: name, max: 160)
            try self.validate(self.packageDescription, name: "packageDescription", parent: name, max: 1024)
            try self.packageSource.validate(name: "\(name).packageSource")
        }

        private enum CodingKeys: String, CodingKey {
            case commitMessage = "CommitMessage"
            case packageDescription = "PackageDescription"
            case packageID = "PackageID"
            case packageSource = "PackageSource"
        }
    }

    public struct UpdatePackageResponse: AWSDecodableShape {
        /// Information about the package.
        public let packageDetails: PackageDetails?

        public init(packageDetails: PackageDetails? = nil) {
            self.packageDetails = packageDetails
        }

        private enum CodingKeys: String, CodingKey {
            case packageDetails = "PackageDetails"
        }
    }

    public struct UpgradeDomainRequest: AWSEncodableShape {
        public let advancedOptions: [String: String]?
        public let domainName: String
        ///  When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
        public let performCheckOnly: Bool?
        /// The version of OpenSearch you intend to upgrade the domain to.
        public let targetVersion: String

        public init(advancedOptions: [String: String]? = nil, domainName: String, performCheckOnly: Bool? = nil, targetVersion: String) {
            self.advancedOptions = advancedOptions
            self.domainName = domainName
            self.performCheckOnly = performCheckOnly
            self.targetVersion = targetVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 28)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-z][a-z0-9\\-]+$")
            try self.validate(self.targetVersion, name: "targetVersion", parent: name, max: 18)
            try self.validate(self.targetVersion, name: "targetVersion", parent: name, min: 14)
            try self.validate(self.targetVersion, name: "targetVersion", parent: name, pattern: "^Elasticsearch_[0-9]{1}\\.[0-9]{1,2}$|^OpenSearch_[0-9]{1,2}\\.[0-9]{1,2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case advancedOptions = "AdvancedOptions"
            case domainName = "DomainName"
            case performCheckOnly = "PerformCheckOnly"
            case targetVersion = "TargetVersion"
        }
    }

    public struct UpgradeDomainResponse: AWSDecodableShape {
        public let advancedOptions: [String: String]?
        public let domainName: String?
        ///  When true, indicates that an upgrade eligibility check needs to be performed. Does not actually perform the upgrade.
        public let performCheckOnly: Bool?
        /// The version of OpenSearch that you intend to upgrade the domain to.
        public let targetVersion: String?
        public let upgradeId: String?

        public init(advancedOptions: [String: String]? = nil, domainName: String? = nil, performCheckOnly: Bool? = nil, targetVersion: String? = nil, upgradeId: String? = nil) {
            self.advancedOptions = advancedOptions
            self.domainName = domainName
            self.performCheckOnly = performCheckOnly
            self.targetVersion = targetVersion
            self.upgradeId = upgradeId
        }

        private enum CodingKeys: String, CodingKey {
            case advancedOptions = "AdvancedOptions"
            case domainName = "DomainName"
            case performCheckOnly = "PerformCheckOnly"
            case targetVersion = "TargetVersion"
            case upgradeId = "UpgradeId"
        }
    }

    public struct UpgradeHistory: AWSDecodableShape {
        /// UTC timestamp at which the upgrade API call was made in "yyyy-MM-ddTHH:mm:ssZ" format.
        public let startTimestamp: Date?
        ///  A list of  UpgradeStepItem  s representing information about each step performed as part of a specific upgrade or upgrade eligibility check.
        public let stepsList: [UpgradeStepItem]?
        /// A string that briefly describes the upgrade.
        public let upgradeName: String?
        ///  The current status of the upgrade. The status can take one of the following values:  In Progress Succeeded Succeeded with Issues Failed
        public let upgradeStatus: UpgradeStatus?

        public init(startTimestamp: Date? = nil, stepsList: [UpgradeStepItem]? = nil, upgradeName: String? = nil, upgradeStatus: UpgradeStatus? = nil) {
            self.startTimestamp = startTimestamp
            self.stepsList = stepsList
            self.upgradeName = upgradeName
            self.upgradeStatus = upgradeStatus
        }

        private enum CodingKeys: String, CodingKey {
            case startTimestamp = "StartTimestamp"
            case stepsList = "StepsList"
            case upgradeName = "UpgradeName"
            case upgradeStatus = "UpgradeStatus"
        }
    }

    public struct UpgradeStepItem: AWSDecodableShape {
        /// A list of strings containing detailed information about the errors encountered in a particular step.
        public let issues: [String]?
        /// The floating point value representing the progress percentage of a particular step.
        public let progressPercent: Double?
        ///  One of three steps an upgrade or upgrade eligibility check goes through:  PreUpgradeCheck Snapshot Upgrade
        public let upgradeStep: UpgradeStep?
        ///  The current status of the upgrade. The status can take one of the following values:  In Progress Succeeded Succeeded with Issues Failed
        public let upgradeStepStatus: UpgradeStatus?

        public init(issues: [String]? = nil, progressPercent: Double? = nil, upgradeStep: UpgradeStep? = nil, upgradeStepStatus: UpgradeStatus? = nil) {
            self.issues = issues
            self.progressPercent = progressPercent
            self.upgradeStep = upgradeStep
            self.upgradeStepStatus = upgradeStepStatus
        }

        private enum CodingKeys: String, CodingKey {
            case issues = "Issues"
            case progressPercent = "ProgressPercent"
            case upgradeStep = "UpgradeStep"
            case upgradeStepStatus = "UpgradeStepStatus"
        }
    }

    public struct VPCDerivedInfo: AWSDecodableShape {
        /// The Availability Zones for the domain. Exists only if the domain was created with VPCOptions.
        public let availabilityZones: [String]?
        /// The security groups for the VPC endpoint.
        public let securityGroupIds: [String]?
        /// The subnets for the VPC endpoint.
        public let subnetIds: [String]?
        /// The VPC ID for the domain. Exists only if the domain was created with VPCOptions.
        public let vPCId: String?

        public init(availabilityZones: [String]? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, vPCId: String? = nil) {
            self.availabilityZones = availabilityZones
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vPCId = vPCId
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "AvailabilityZones"
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
            case vPCId = "VPCId"
        }
    }

    public struct VPCDerivedInfoStatus: AWSDecodableShape {
        /// The VPC options for the specified domain.
        public let options: VPCDerivedInfo
        /// The status of the VPC options for the specified domain.
        public let status: OptionStatus

        public init(options: VPCDerivedInfo, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct VPCOptions: AWSEncodableShape {
        /// The security groups for the VPC endpoint.
        public let securityGroupIds: [String]?
        /// The subnets for the VPC endpoint.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "SecurityGroupIds"
            case subnetIds = "SubnetIds"
        }
    }

    public struct VersionStatus: AWSDecodableShape {
        /// The OpenSearch version for the specified OpenSearch domain.
        public let options: String
        /// The status of the OpenSearch version options for the specified OpenSearch domain.
        public let status: OptionStatus

        public init(options: String, status: OptionStatus) {
            self.options = options
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case options = "Options"
            case status = "Status"
        }
    }

    public struct ZoneAwarenessConfig: AWSEncodableShape & AWSDecodableShape {
        /// An integer value to indicate the number of availability zones for a domain when zone awareness is enabled. This should be equal to number of subnets if VPC endpoints is enabled.
        public let availabilityZoneCount: Int?

        public init(availabilityZoneCount: Int? = nil) {
            self.availabilityZoneCount = availabilityZoneCount
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZoneCount = "AvailabilityZoneCount"
        }
    }
}
