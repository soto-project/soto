//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTFleetWise {
    // MARK: Enums

    public enum CampaignStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case running = "RUNNING"
        case suspended = "SUSPENDED"
        case waitingForApproval = "WAITING_FOR_APPROVAL"
        public var description: String { return self.rawValue }
    }

    public enum Compression: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "OFF"
        case snappy = "SNAPPY"
        public var description: String { return self.rawValue }
    }

    public enum DataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum DiagnosticsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "OFF"
        case sendActiveDtcs = "SEND_ACTIVE_DTCS"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failure = "FAILURE"
        case pending = "PENDING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fleetwiseDefaultEncryption = "FLEETWISE_DEFAULT_ENCRYPTION"
        case kmsBasedEncryption = "KMS_BASED_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum ManifestStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case draft = "DRAFT"
        case invalid = "INVALID"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum NetworkInterfaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canInterface = "CAN_INTERFACE"
        case obdInterface = "OBD_INTERFACE"
        case vehicleMiddleware = "VEHICLE_MIDDLEWARE"
        public var description: String { return self.rawValue }
    }

    public enum NodeDataEncoding: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binary = "BINARY"
        case typed = "TYPED"
        public var description: String { return self.rawValue }
    }

    public enum NodeDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `struct` = "STRUCT"
        case boolean = "BOOLEAN"
        case booleanArray = "BOOLEAN_ARRAY"
        case double = "DOUBLE"
        case doubleArray = "DOUBLE_ARRAY"
        case float = "FLOAT"
        case floatArray = "FLOAT_ARRAY"
        case int16 = "INT16"
        case int16Array = "INT16_ARRAY"
        case int32 = "INT32"
        case int32Array = "INT32_ARRAY"
        case int64 = "INT64"
        case int64Array = "INT64_ARRAY"
        case int8 = "INT8"
        case int8Array = "INT8_ARRAY"
        case string = "STRING"
        case stringArray = "STRING_ARRAY"
        case structArray = "STRUCT_ARRAY"
        case uint16 = "UINT16"
        case uint16Array = "UINT16_ARRAY"
        case uint32 = "UINT32"
        case uint32Array = "UINT32_ARRAY"
        case uint64 = "UINT64"
        case uint64Array = "UINT64_ARRAY"
        case uint8 = "UINT8"
        case uint8Array = "UINT8_ARRAY"
        case unixTimestamp = "UNIX_TIMESTAMP"
        case unixTimestampArray = "UNIX_TIMESTAMP_ARRAY"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum ROS2PrimitiveType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bool = "BOOL"
        case byte = "BYTE"
        case char = "CHAR"
        case float32 = "FLOAT32"
        case float64 = "FLOAT64"
        case int16 = "INT16"
        case int32 = "INT32"
        case int64 = "INT64"
        case int8 = "INT8"
        case string = "STRING"
        case uint16 = "UINT16"
        case uint32 = "UINT32"
        case uint64 = "UINT64"
        case uint8 = "UINT8"
        case wstring = "WSTRING"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case registrationFailure = "REGISTRATION_FAILURE"
        case registrationPending = "REGISTRATION_PENDING"
        case registrationSuccess = "REGISTRATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum SignalDecoderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canSignal = "CAN_SIGNAL"
        case messageSignal = "MESSAGE_SIGNAL"
        case obdSignal = "OBD_SIGNAL"
        public var description: String { return self.rawValue }
    }

    public enum SignalNodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actuator = "ACTUATOR"
        case attribute = "ATTRIBUTE"
        case branch = "BRANCH"
        case customProperty = "CUSTOM_PROPERTY"
        case customStruct = "CUSTOM_STRUCT"
        case sensor = "SENSOR"
        public var description: String { return self.rawValue }
    }

    public enum SpoolingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "OFF"
        case toDisk = "TO_DISK"
        public var description: String { return self.rawValue }
    }

    public enum StorageCompressionFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum StructuredMessageListType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dynamicBoundedCapacity = "DYNAMIC_BOUNDED_CAPACITY"
        case dynamicUnboundedCapacity = "DYNAMIC_UNBOUNDED_CAPACITY"
        case fixedCapacity = "FIXED_CAPACITY"
        public var description: String { return self.rawValue }
    }

    public enum TriggerMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case always = "ALWAYS"
        case risingEdge = "RISING_EDGE"
        public var description: String { return self.rawValue }
    }

    public enum UpdateCampaignAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approve = "APPROVE"
        case resume = "RESUME"
        case suspend = "SUSPEND"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum UpdateMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case merge = "Merge"
        case overwrite = "Overwrite"
        public var description: String { return self.rawValue }
    }

    public enum VehicleAssociationBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createIotThing = "CreateIotThing"
        case validateIotThingExists = "ValidateIotThingExists"
        public var description: String { return self.rawValue }
    }

    public enum VehicleMiddlewareProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ros2 = "ROS_2"
        public var description: String { return self.rawValue }
    }

    public enum VehicleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case deleting = "DELETING"
        case healthy = "HEALTHY"
        case ready = "READY"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum CollectionScheme: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
        case conditionBasedCollectionScheme(ConditionBasedCollectionScheme)
        /// Information about a collection scheme that uses a time period to decide how often to collect data.
        case timeBasedCollectionScheme(TimeBasedCollectionScheme)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .conditionBasedCollectionScheme:
                let value = try container.decode(ConditionBasedCollectionScheme.self, forKey: .conditionBasedCollectionScheme)
                self = .conditionBasedCollectionScheme(value)
            case .timeBasedCollectionScheme:
                let value = try container.decode(TimeBasedCollectionScheme.self, forKey: .timeBasedCollectionScheme)
                self = .timeBasedCollectionScheme(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .conditionBasedCollectionScheme(let value):
                try container.encode(value, forKey: .conditionBasedCollectionScheme)
            case .timeBasedCollectionScheme(let value):
                try container.encode(value, forKey: .timeBasedCollectionScheme)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .conditionBasedCollectionScheme(let value):
                try value.validate(name: "\(name).conditionBasedCollectionScheme")
            case .timeBasedCollectionScheme(let value):
                try value.validate(name: "\(name).timeBasedCollectionScheme")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditionBasedCollectionScheme = "conditionBasedCollectionScheme"
            case timeBasedCollectionScheme = "timeBasedCollectionScheme"
        }
    }

    public enum DataDestinationConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Amazon S3 bucket where the Amazon Web Services IoT FleetWise campaign sends data.
        case s3Config(S3Config)
        /// The Amazon Timestream table where the campaign sends data.
        case timestreamConfig(TimestreamConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .s3Config:
                let value = try container.decode(S3Config.self, forKey: .s3Config)
                self = .s3Config(value)
            case .timestreamConfig:
                let value = try container.decode(TimestreamConfig.self, forKey: .timestreamConfig)
                self = .timestreamConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .s3Config(let value):
                try container.encode(value, forKey: .s3Config)
            case .timestreamConfig(let value):
                try container.encode(value, forKey: .timestreamConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3Config(let value):
                try value.validate(name: "\(name).s3Config")
            case .timestreamConfig(let value):
                try value.validate(name: "\(name).timestreamConfig")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "s3Config"
            case timestreamConfig = "timestreamConfig"
        }
    }

    public enum Node: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Information about a node specified as an actuator.  An actuator is a digital representation of a vehicle device.
        case actuator(Actuator)
        /// Information about a node specified as an attribute.  An attribute represents static information about a vehicle.
        case attribute(Attribute)
        /// Information about a node specified as a branch.  A group of signals that are defined in a hierarchical structure.
        case branch(Branch)
        /// Represents a member of the complex data structure. The datatype of the property can be either primitive or another struct.
        case property(CustomProperty)
        case sensor(Sensor)
        /// Represents a complex or higher-order data structure.
        case `struct`(CustomStruct)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .actuator:
                let value = try container.decode(Actuator.self, forKey: .actuator)
                self = .actuator(value)
            case .attribute:
                let value = try container.decode(Attribute.self, forKey: .attribute)
                self = .attribute(value)
            case .branch:
                let value = try container.decode(Branch.self, forKey: .branch)
                self = .branch(value)
            case .property:
                let value = try container.decode(CustomProperty.self, forKey: .property)
                self = .property(value)
            case .sensor:
                let value = try container.decode(Sensor.self, forKey: .sensor)
                self = .sensor(value)
            case .`struct`:
                let value = try container.decode(CustomStruct.self, forKey: .`struct`)
                self = .`struct`(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .actuator(let value):
                try container.encode(value, forKey: .actuator)
            case .attribute(let value):
                try container.encode(value, forKey: .attribute)
            case .branch(let value):
                try container.encode(value, forKey: .branch)
            case .property(let value):
                try container.encode(value, forKey: .property)
            case .sensor(let value):
                try container.encode(value, forKey: .sensor)
            case .`struct`(let value):
                try container.encode(value, forKey: .`struct`)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .actuator(let value):
                try value.validate(name: "\(name).actuator")
            case .attribute(let value):
                try value.validate(name: "\(name).attribute")
            case .branch(let value):
                try value.validate(name: "\(name).branch")
            case .property(let value):
                try value.validate(name: "\(name).property")
            case .sensor(let value):
                try value.validate(name: "\(name).sensor")
            case .`struct`(let value):
                try value.validate(name: "\(name).`struct`")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actuator = "actuator"
            case attribute = "attribute"
            case branch = "branch"
            case property = "property"
            case sensor = "sensor"
            case `struct` = "struct"
        }
    }

    public indirect enum StructuredMessage: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Represents a primitive type node of the complex data structure.
        case primitiveMessageDefinition(PrimitiveMessageDefinition)
        /// Represents a struct type node of the complex data structure.
        case structuredMessageDefinition([StructuredMessageFieldNameAndDataTypePair])
        /// Represents a list type node of the complex data structure.
        case structuredMessageListDefinition(StructuredMessageListDefinition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .primitiveMessageDefinition:
                let value = try container.decode(PrimitiveMessageDefinition.self, forKey: .primitiveMessageDefinition)
                self = .primitiveMessageDefinition(value)
            case .structuredMessageDefinition:
                let value = try container.decode([StructuredMessageFieldNameAndDataTypePair].self, forKey: .structuredMessageDefinition)
                self = .structuredMessageDefinition(value)
            case .structuredMessageListDefinition:
                let value = try container.decode(StructuredMessageListDefinition.self, forKey: .structuredMessageListDefinition)
                self = .structuredMessageListDefinition(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .primitiveMessageDefinition(let value):
                try container.encode(value, forKey: .primitiveMessageDefinition)
            case .structuredMessageDefinition(let value):
                try container.encode(value, forKey: .structuredMessageDefinition)
            case .structuredMessageListDefinition(let value):
                try container.encode(value, forKey: .structuredMessageListDefinition)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .primitiveMessageDefinition(let value):
                try value.validate(name: "\(name).primitiveMessageDefinition")
            case .structuredMessageDefinition(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).structuredMessageDefinition[]")
                }
                try self.validate(value, name: "structuredMessageDefinition", parent: name, max: 500)
                try self.validate(value, name: "structuredMessageDefinition", parent: name, min: 1)
            case .structuredMessageListDefinition(let value):
                try value.validate(name: "\(name).structuredMessageListDefinition")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case primitiveMessageDefinition = "primitiveMessageDefinition"
            case structuredMessageDefinition = "structuredMessageDefinition"
            case structuredMessageListDefinition = "structuredMessageListDefinition"
        }
    }

    // MARK: Shapes

    public struct Actuator: AWSEncodableShape & AWSDecodableShape {
        /// A list of possible values an actuator can take.
        public let allowedValues: [String]?
        /// A specified value for the actuator.
        public let assignedValue: String?
        /// A comment in addition to the description.
        public let comment: String?
        /// The specified data type of the actuator.
        public let dataType: NodeDataType
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the actuator.
        public let description: String?
        /// The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be Vehicle.Front.Left.Door.Lock.
        public let fullyQualifiedName: String
        /// The specified possible maximum value of an actuator.
        public let max: Double?
        /// The specified possible minimum value of an actuator.
        public let min: Double?
        /// The fully qualified name of the struct node for the actuator if the data type of the actuator is Struct or StructArray. For example, the struct fully qualified name of an actuator might be Vehicle.Door.LockStruct.
        public let structFullyQualifiedName: String?
        /// The scientific unit for the actuator.
        public let unit: String?

        public init(allowedValues: [String]? = nil, comment: String? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, structFullyQualifiedName: String? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = nil
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }

        @available(*, deprecated, message: "Members assignedValue have been deprecated")
        public init(allowedValues: [String]? = nil, assignedValue: String? = nil, comment: String? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, structFullyQualifiedName: String? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, max: 150)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, min: 1)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case assignedValue = "assignedValue"
            case comment = "comment"
            case dataType = "dataType"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case max = "max"
            case min = "min"
            case structFullyQualifiedName = "structFullyQualifiedName"
            case unit = "unit"
        }
    }

    public struct AssociateVehicleFleetRequest: AWSEncodableShape {
        ///  The ID of a fleet.
        public let fleetId: String
        ///  The unique ID of the vehicle to associate with the fleet.
        public let vehicleName: String

        public init(fleetId: String, vehicleName: String) {
            self.fleetId = fleetId
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.fleetId, forKey: .fleetId)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fleetId = "fleetId"
        }
    }

    public struct AssociateVehicleFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {
        /// A list of possible values an attribute can be assigned.
        public let allowedValues: [String]?
        /// A specified value for the attribute.
        public let assignedValue: String?
        /// A comment in addition to the description.
        public let comment: String?
        /// The specified data type of the attribute.
        public let dataType: NodeDataType
        /// The default value of the attribute.
        public let defaultValue: String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the attribute.
        public let description: String?
        /// The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be Vehicle.Body.Engine.Type.
        public let fullyQualifiedName: String
        /// The specified possible maximum value of the attribute.
        public let max: Double?
        /// The specified possible minimum value of the attribute.
        public let min: Double?
        /// The scientific unit for the attribute.
        public let unit: String?

        public init(allowedValues: [String]? = nil, comment: String? = nil, dataType: NodeDataType, defaultValue: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = nil
            self.comment = comment
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }

        @available(*, deprecated, message: "Members assignedValue have been deprecated")
        public init(allowedValues: [String]? = nil, assignedValue: String? = nil, comment: String? = nil, dataType: NodeDataType, defaultValue: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case assignedValue = "assignedValue"
            case comment = "comment"
            case dataType = "dataType"
            case defaultValue = "defaultValue"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case max = "max"
            case min = "min"
            case unit = "unit"
        }
    }

    public struct BatchCreateVehicleRequest: AWSEncodableShape {
        ///  A list of information about each vehicle to create. For more information, see the API data type.
        public let vehicles: [CreateVehicleRequestItem]

        public init(vehicles: [CreateVehicleRequestItem]) {
            self.vehicles = vehicles
        }

        public func validate(name: String) throws {
            try self.vehicles.forEach {
                try $0.validate(name: "\(name).vehicles[]")
            }
            try self.validate(self.vehicles, name: "vehicles", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vehicles = "vehicles"
        }
    }

    public struct BatchCreateVehicleResponse: AWSDecodableShape {
        /// A list of information about creation errors, or an empty list if there aren't any errors.
        public let errors: [CreateVehicleError]?
        ///  A list of information about a batch of created vehicles. For more information, see the  API data type.
        public let vehicles: [CreateVehicleResponseItem]?

        public init(errors: [CreateVehicleError]? = nil, vehicles: [CreateVehicleResponseItem]? = nil) {
            self.errors = errors
            self.vehicles = vehicles
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case vehicles = "vehicles"
        }
    }

    public struct BatchUpdateVehicleRequest: AWSEncodableShape {
        ///  A list of information about the vehicles to update. For more information, see the API data type.
        public let vehicles: [UpdateVehicleRequestItem]

        public init(vehicles: [UpdateVehicleRequestItem]) {
            self.vehicles = vehicles
        }

        public func validate(name: String) throws {
            try self.vehicles.forEach {
                try $0.validate(name: "\(name).vehicles[]")
            }
            try self.validate(self.vehicles, name: "vehicles", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vehicles = "vehicles"
        }
    }

    public struct BatchUpdateVehicleResponse: AWSDecodableShape {
        /// A list of information about errors returned while updating a batch of vehicles, or, if there aren't any errors, an empty list.
        public let errors: [UpdateVehicleError]?
        ///  A list of information about the batch of updated vehicles.   This list contains only unique IDs for the vehicles that were updated.
        public let vehicles: [UpdateVehicleResponseItem]?

        public init(errors: [UpdateVehicleError]? = nil, vehicles: [UpdateVehicleResponseItem]? = nil) {
            self.errors = errors
            self.vehicles = vehicles
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case vehicles = "vehicles"
        }
    }

    public struct Branch: AWSEncodableShape & AWSDecodableShape {
        /// A comment in addition to the description.
        public let comment: String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the branch.
        public let description: String?
        /// The fully qualified name of the branch. For example, the fully qualified name of a branch might be Vehicle.Body.Engine.
        public let fullyQualifiedName: String

        public init(comment: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String) {
            self.comment = comment
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
        }
    }

    public struct CampaignSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a campaign.
        public let arn: String?
        /// The time the campaign was created.
        public let creationTime: Date
        /// The description of the campaign.
        public let description: String?
        /// The last time the campaign was modified.
        public let lastModificationTime: Date
        /// The name of a campaign.
        public let name: String?
        /// The ARN of the signal catalog associated with the campaign.
        public let signalCatalogArn: String?
        /// The state of a campaign. The status can be one of the following:    CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.    WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the  API operation to approve the campaign.     RUNNING - The campaign is active.     SUSPENDED - The campaign is suspended. To resume the campaign, use the  API operation.
        public let status: CampaignStatus?
        /// The ARN of a vehicle or fleet to which the campaign is deployed.
        public let targetArn: String?

        public init(arn: String? = nil, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String? = nil, signalCatalogArn: String? = nil, status: CampaignStatus? = nil, targetArn: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
            case status = "status"
            case targetArn = "targetArn"
        }
    }

    public struct CanDbcDefinition: AWSEncodableShape {
        /// A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list. The DBC file can be a maximum size of 200 MB.
        public let canDbcFiles: [AWSBase64Data]
        /// Contains information about a network interface.
        public let networkInterface: String
        /// Pairs every signal specified in your vehicle model with a signal decoder.
        public let signalsMap: [String: String]?

        public init(canDbcFiles: [AWSBase64Data], networkInterface: String, signalsMap: [String: String]? = nil) {
            self.canDbcFiles = canDbcFiles
            self.networkInterface = networkInterface
            self.signalsMap = signalsMap
        }

        public func validate(name: String) throws {
            try self.canDbcFiles.forEach {
                try validate($0, name: "canDbcFiles[]", parent: name, max: 200000000)
            }
            try self.validate(self.canDbcFiles, name: "canDbcFiles", parent: name, max: 5)
            try self.validate(self.canDbcFiles, name: "canDbcFiles", parent: name, min: 1)
            try self.validate(self.networkInterface, name: "networkInterface", parent: name, max: 50)
            try self.validate(self.networkInterface, name: "networkInterface", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case canDbcFiles = "canDbcFiles"
            case networkInterface = "networkInterface"
            case signalsMap = "signalsMap"
        }
    }

    public struct CanInterface: AWSEncodableShape & AWSDecodableShape {
        /// The unique name of the interface.
        public let name: String
        /// The name of the communication protocol for the interface.
        public let protocolName: String?
        /// The version of the communication protocol for the interface.
        public let protocolVersion: String?

        public init(name: String, protocolName: String? = nil, protocolVersion: String? = nil) {
            self.name = name
            self.protocolName = protocolName
            self.protocolVersion = protocolVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.protocolName, name: "protocolName", parent: name, max: 50)
            try self.validate(self.protocolName, name: "protocolName", parent: name, min: 1)
            try self.validate(self.protocolVersion, name: "protocolVersion", parent: name, max: 50)
            try self.validate(self.protocolVersion, name: "protocolVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case protocolName = "protocolName"
            case protocolVersion = "protocolVersion"
        }
    }

    public struct CanSignal: AWSEncodableShape & AWSDecodableShape {
        /// A multiplier used to decode the CAN message.
        public let factor: Double
        /// Whether the byte ordering of a CAN message is big-endian.
        public let isBigEndian: Bool
        /// Whether the message data is specified as a signed value.
        public let isSigned: Bool
        /// How many bytes of data are in the message.
        public let length: Int
        /// The ID of the message.
        public let messageId: Int
        /// The name of the signal.
        public let name: String?
        /// The offset used to calculate the signal value. Combined with factor, the calculation is value = raw_value * factor + offset.
        public let offset: Double
        /// Indicates the beginning of the CAN signal. This should always be the least significant bit (LSB). This value might be different from the value in a DBC file. For little endian signals, startBit is the same value as in the DBC file. For big endian signals in a DBC file, the start bit is the most significant bit (MSB). You will have to calculate the LSB instead and pass it as the startBit.
        public let startBit: Int

        public init(factor: Double, isBigEndian: Bool, isSigned: Bool, length: Int, messageId: Int, name: String? = nil, offset: Double, startBit: Int) {
            self.factor = factor
            self.isBigEndian = isBigEndian
            self.isSigned = isSigned
            self.length = length
            self.messageId = messageId
            self.name = name
            self.offset = offset
            self.startBit = startBit
        }

        public func validate(name: String) throws {
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.startBit, name: "startBit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case factor = "factor"
            case isBigEndian = "isBigEndian"
            case isSigned = "isSigned"
            case length = "length"
            case messageId = "messageId"
            case name = "name"
            case offset = "offset"
            case startBit = "startBit"
        }
    }

    public struct CloudWatchLogDeliveryOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon CloudWatch Logs group the operation sends data to.
        public let logGroupName: String?
        /// The type of log to send data to Amazon CloudWatch Logs.
        public let logType: LogType

        public init(logGroupName: String? = nil, logType: LogType) {
            self.logGroupName = logGroupName
            self.logType = logType
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, max: 512)
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, min: 1)
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, pattern: "^[\\.\\-_\\/#A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "logGroupName"
            case logType = "logType"
        }
    }

    public struct ConditionBasedCollectionScheme: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the version of the conditional expression language.
        public let conditionLanguageVersion: Int?
        /// The logical expression used to recognize what data to collect. For example, $variable.`Vehicle.OutsideAirTemperature` &gt;= 105.0.
        public let expression: String
        /// The minimum duration of time between two triggering events to collect data, in milliseconds.  If a signal changes often, you might want to collect data at a slower rate.
        public let minimumTriggerIntervalMs: Int64?
        /// Whether to collect data for all triggering events (ALWAYS). Specify (RISING_EDGE), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed =&gt; deployed.
        public let triggerMode: TriggerMode?

        public init(conditionLanguageVersion: Int? = nil, expression: String, minimumTriggerIntervalMs: Int64? = nil, triggerMode: TriggerMode? = nil) {
            self.conditionLanguageVersion = conditionLanguageVersion
            self.expression = expression
            self.minimumTriggerIntervalMs = minimumTriggerIntervalMs
            self.triggerMode = triggerMode
        }

        public func validate(name: String) throws {
            try self.validate(self.conditionLanguageVersion, name: "conditionLanguageVersion", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.minimumTriggerIntervalMs, name: "minimumTriggerIntervalMs", parent: name, max: 4294967295)
            try self.validate(self.minimumTriggerIntervalMs, name: "minimumTriggerIntervalMs", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionLanguageVersion = "conditionLanguageVersion"
            case expression = "expression"
            case minimumTriggerIntervalMs = "minimumTriggerIntervalMs"
            case triggerMode = "triggerMode"
        }
    }

    public struct CreateCampaignRequest: AWSEncodableShape {
        ///  The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.
        public let collectionScheme: CollectionScheme
        ///  (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use OFF. If it's not specified, SNAPPY is used.  Default: SNAPPY
        public let compression: Compression?
        /// The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics. Amazon Web Services IoT FleetWise supports at-least-once file delivery to S3. Your vehicle data is stored on multiple Amazon Web Services IoT FleetWise servers for redundancy and high availability. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
        public let dataDestinationConfigs: [DataDestinationConfig]?
        ///  (Optional) A list of vehicle attributes to associate with a campaign.  Enrich the data with specified vehicle attributes. For example, add make and model to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against make and model. Default: An empty array
        public let dataExtraDimensions: [String]?
        /// An optional description of the campaign to help identify its purpose.
        public let description: String?
        ///  (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use SEND_ACTIVE_DTCS. If it's not specified, OFF is used. Default: OFF
        public let diagnosticsMode: DiagnosticsMode?
        ///  (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data isn't collected after the campaign expires.  Default: 253402214400 (December 31, 9999, 00:00:00 UTC)
        public let expiryTime: Date?
        ///  The name of the campaign to create.
        public let name: String
        ///  (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, 0 is used. Default: 0
        public let postTriggerCollectionDuration: Int64?
        /// (Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, 0 is used.  Default: 0
        public let priority: Int?
        /// (Optional) The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign.
        public let signalCatalogArn: String
        /// (Optional) A list of information about signals to collect.
        public let signalsToCollect: [SignalInformation]?
        /// (Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use TO_DISK. If it's not specified, OFF is used. Default: OFF
        public let spoolingMode: SpoolingMode?
        /// (Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, 0 is used. Default: 0
        public let startTime: Date?
        /// Metadata that can be used to manage the campaign.
        public let tags: [Tag]?
        ///  The ARN of the vehicle or fleet to deploy a campaign to.
        public let targetArn: String

        public init(collectionScheme: CollectionScheme, compression: Compression? = nil, dataDestinationConfigs: [DataDestinationConfig]? = nil, dataExtraDimensions: [String]? = nil, description: String? = nil, diagnosticsMode: DiagnosticsMode? = nil, expiryTime: Date? = nil, name: String, postTriggerCollectionDuration: Int64? = nil, priority: Int? = nil, signalCatalogArn: String, signalsToCollect: [SignalInformation]? = nil, spoolingMode: SpoolingMode? = nil, startTime: Date? = nil, tags: [Tag]? = nil, targetArn: String) {
            self.collectionScheme = collectionScheme
            self.compression = compression
            self.dataDestinationConfigs = dataDestinationConfigs
            self.dataExtraDimensions = dataExtraDimensions
            self.description = description
            self.diagnosticsMode = diagnosticsMode
            self.expiryTime = expiryTime
            self.name = name
            self.postTriggerCollectionDuration = postTriggerCollectionDuration
            self.priority = priority
            self.signalCatalogArn = signalCatalogArn
            self.signalsToCollect = signalsToCollect
            self.spoolingMode = spoolingMode
            self.startTime = startTime
            self.tags = tags
            self.targetArn = targetArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.collectionScheme, forKey: .collectionScheme)
            try container.encodeIfPresent(self.compression, forKey: .compression)
            try container.encodeIfPresent(self.dataDestinationConfigs, forKey: .dataDestinationConfigs)
            try container.encodeIfPresent(self.dataExtraDimensions, forKey: .dataExtraDimensions)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.diagnosticsMode, forKey: .diagnosticsMode)
            try container.encodeIfPresent(self.expiryTime, forKey: .expiryTime)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.postTriggerCollectionDuration, forKey: .postTriggerCollectionDuration)
            try container.encodeIfPresent(self.priority, forKey: .priority)
            try container.encode(self.signalCatalogArn, forKey: .signalCatalogArn)
            try container.encodeIfPresent(self.signalsToCollect, forKey: .signalsToCollect)
            try container.encodeIfPresent(self.spoolingMode, forKey: .spoolingMode)
            try container.encodeIfPresent(self.startTime, forKey: .startTime)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.targetArn, forKey: .targetArn)
        }

        public func validate(name: String) throws {
            try self.collectionScheme.validate(name: "\(name).collectionScheme")
            try self.dataDestinationConfigs?.forEach {
                try $0.validate(name: "\(name).dataDestinationConfigs[]")
            }
            try self.validate(self.dataDestinationConfigs, name: "dataDestinationConfigs", parent: name, max: 1)
            try self.validate(self.dataDestinationConfigs, name: "dataDestinationConfigs", parent: name, min: 1)
            try self.dataExtraDimensions?.forEach {
                try validate($0, name: "dataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "dataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "dataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.dataExtraDimensions, name: "dataExtraDimensions", parent: name, max: 5)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.postTriggerCollectionDuration, name: "postTriggerCollectionDuration", parent: name, max: 4294967295)
            try self.validate(self.postTriggerCollectionDuration, name: "postTriggerCollectionDuration", parent: name, min: 0)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.signalsToCollect?.forEach {
                try $0.validate(name: "\(name).signalsToCollect[]")
            }
            try self.validate(self.signalsToCollect, name: "signalsToCollect", parent: name, max: 1000)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionScheme = "collectionScheme"
            case compression = "compression"
            case dataDestinationConfigs = "dataDestinationConfigs"
            case dataExtraDimensions = "dataExtraDimensions"
            case description = "description"
            case diagnosticsMode = "diagnosticsMode"
            case expiryTime = "expiryTime"
            case postTriggerCollectionDuration = "postTriggerCollectionDuration"
            case priority = "priority"
            case signalCatalogArn = "signalCatalogArn"
            case signalsToCollect = "signalsToCollect"
            case spoolingMode = "spoolingMode"
            case startTime = "startTime"
            case tags = "tags"
            case targetArn = "targetArn"
        }
    }

    public struct CreateCampaignResponse: AWSDecodableShape {
        ///  The ARN of the created campaign.
        public let arn: String?
        /// The name of the created campaign.
        public let name: String?

        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateDecoderManifestRequest: AWSEncodableShape {
        ///  A brief description of the decoder manifest.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the vehicle model (model manifest).
        public let modelManifestArn: String
        ///  The unique name of the decoder manifest to create.
        public let name: String
        ///  A list of information about available network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        ///  A list of information about signal decoders.
        public let signalDecoders: [SignalDecoder]?
        /// Metadata that can be used to manage the decoder manifest.
        public let tags: [Tag]?

        public init(description: String? = nil, modelManifestArn: String, name: String, networkInterfaces: [NetworkInterface]? = nil, signalDecoders: [SignalDecoder]? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.networkInterfaces = networkInterfaces
            self.signalDecoders = signalDecoders
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.modelManifestArn, forKey: .modelManifestArn)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.networkInterfaces, forKey: .networkInterfaces)
            try container.encodeIfPresent(self.signalDecoders, forKey: .signalDecoders)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.networkInterfaces?.forEach {
                try $0.validate(name: "\(name).networkInterfaces[]")
            }
            try self.validate(self.networkInterfaces, name: "networkInterfaces", parent: name, max: 500)
            try self.validate(self.networkInterfaces, name: "networkInterfaces", parent: name, min: 1)
            try self.signalDecoders?.forEach {
                try $0.validate(name: "\(name).signalDecoders[]")
            }
            try self.validate(self.signalDecoders, name: "signalDecoders", parent: name, max: 500)
            try self.validate(self.signalDecoders, name: "signalDecoders", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case modelManifestArn = "modelManifestArn"
            case networkInterfaces = "networkInterfaces"
            case signalDecoders = "signalDecoders"
            case tags = "tags"
        }
    }

    public struct CreateDecoderManifestResponse: AWSDecodableShape {
        ///  The ARN of the created decoder manifest.
        public let arn: String
        ///  The name of the created decoder manifest.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateFleetRequest: AWSEncodableShape {
        ///  A brief description of the fleet to create.
        public let description: String?
        ///  The unique ID of the fleet to create.
        public let fleetId: String
        ///  The Amazon Resource Name (ARN) of a signal catalog.
        public let signalCatalogArn: String
        /// Metadata that can be used to manage the fleet.
        public let tags: [Tag]?

        public init(description: String? = nil, fleetId: String, signalCatalogArn: String, tags: [Tag]? = nil) {
            self.description = description
            self.fleetId = fleetId
            self.signalCatalogArn = signalCatalogArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encode(self.signalCatalogArn, forKey: .signalCatalogArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case signalCatalogArn = "signalCatalogArn"
            case tags = "tags"
        }
    }

    public struct CreateFleetResponse: AWSDecodableShape {
        ///  The ARN of the created fleet.
        public let arn: String
        ///  The ID of the created fleet.
        public let id: String

        public init(arn: String, id: String) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct CreateModelManifestRequest: AWSEncodableShape {
        ///  A brief description of the vehicle model.
        public let description: String?
        ///  The name of the vehicle model to create.
        public let name: String
        ///  A list of nodes, which are a general abstraction of signals.
        public let nodes: [String]
        ///  The Amazon Resource Name (ARN) of a signal catalog.
        public let signalCatalogArn: String
        /// Metadata that can be used to manage the vehicle model.
        public let tags: [Tag]?

        public init(description: String? = nil, name: String, nodes: [String], signalCatalogArn: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.nodes = nodes
            self.signalCatalogArn = signalCatalogArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encode(self.nodes, forKey: .nodes)
            try container.encode(self.signalCatalogArn, forKey: .signalCatalogArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodes = "nodes"
            case signalCatalogArn = "signalCatalogArn"
            case tags = "tags"
        }
    }

    public struct CreateModelManifestResponse: AWSDecodableShape {
        ///  The ARN of the created vehicle model.
        public let arn: String
        ///  The name of the created vehicle model.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateSignalCatalogRequest: AWSEncodableShape {
        /// A brief description of the signal catalog.
        public let description: String?
        ///  The name of the signal catalog to create.
        public let name: String
        ///  A list of information about nodes, which are a general abstraction of signals. For more information, see the  API data type.
        public let nodes: [Node]?
        /// Metadata that can be used to manage the signal catalog.
        public let tags: [Tag]?

        public init(description: String? = nil, name: String, nodes: [Node]? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.nodes = nodes
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.nodes, forKey: .nodes)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.nodes?.forEach {
                try $0.validate(name: "\(name).nodes[]")
            }
            try self.validate(self.nodes, name: "nodes", parent: name, max: 500)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodes = "nodes"
            case tags = "tags"
        }
    }

    public struct CreateSignalCatalogResponse: AWSDecodableShape {
        ///  The ARN of the created signal catalog.
        public let arn: String
        ///  The name of the created signal catalog.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateVehicleError: AWSDecodableShape {
        /// An HTTP error code.
        public let code: String?
        /// A description of the HTTP error.
        public let message: String?
        /// The ID of the vehicle with the error.
        public let vehicleName: String?

        public init(code: String? = nil, message: String? = nil, vehicleName: String? = nil) {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case vehicleName = "vehicleName"
        }
    }

    public struct CreateVehicleRequest: AWSEncodableShape {
        ///  An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle.  Default:
        public let associationBehavior: VehicleAssociationBehavior?
        /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"  A campaign must include the keys (attribute names) in dataExtraDimensions for them to display in Amazon Timestream.
        public let attributes: [String: String]?
        ///  The ARN of a decoder manifest.
        public let decoderManifestArn: String
        ///  The Amazon Resource Name ARN of a vehicle model.
        public let modelManifestArn: String
        /// Metadata that can be used to manage the vehicle.
        public let tags: [Tag]?
        ///  The unique ID of the vehicle to create.
        public let vehicleName: String

        public init(associationBehavior: VehicleAssociationBehavior? = nil, attributes: [String: String]? = nil, decoderManifestArn: String, modelManifestArn: String, tags: [Tag]? = nil, vehicleName: String) {
            self.associationBehavior = associationBehavior
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.tags = tags
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.associationBehavior, forKey: .associationBehavior)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encode(self.decoderManifestArn, forKey: .decoderManifestArn)
            try container.encode(self.modelManifestArn, forKey: .modelManifestArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case associationBehavior = "associationBehavior"
            case attributes = "attributes"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
            case tags = "tags"
        }
    }

    public struct CreateVehicleRequestItem: AWSEncodableShape {
        /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.
        public let associationBehavior: VehicleAssociationBehavior?
        /// Static information about a vehicle in a key-value pair. For example: "engine Type" : "v6"
        public let attributes: [String: String]?
        /// The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create.
        public let decoderManifestArn: String
        /// The ARN of the vehicle model (model manifest) to create the vehicle from.
        public let modelManifestArn: String
        /// Metadata which can be used to manage the vehicle.
        public let tags: [Tag]?
        /// The unique ID of the vehicle to create.
        public let vehicleName: String

        public init(associationBehavior: VehicleAssociationBehavior? = nil, attributes: [String: String]? = nil, decoderManifestArn: String, modelManifestArn: String, tags: [Tag]? = nil, vehicleName: String) {
            self.associationBehavior = associationBehavior
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.tags = tags
            self.vehicleName = vehicleName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case associationBehavior = "associationBehavior"
            case attributes = "attributes"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
            case tags = "tags"
            case vehicleName = "vehicleName"
        }
    }

    public struct CreateVehicleResponse: AWSDecodableShape {
        ///  The ARN of the created vehicle.
        public let arn: String?
        ///  The ARN of a created or validated Amazon Web Services IoT thing.
        public let thingArn: String?
        /// The unique ID of the created vehicle.
        public let vehicleName: String?

        public init(arn: String? = nil, thingArn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.thingArn = thingArn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case thingArn = "thingArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct CreateVehicleResponseItem: AWSDecodableShape {
        /// The ARN of the created vehicle.
        public let arn: String?
        /// The ARN of a created or validated Amazon Web Services IoT thing.
        public let thingArn: String?
        /// The unique ID of the vehicle to create.
        public let vehicleName: String?

        public init(arn: String? = nil, thingArn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.thingArn = thingArn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case thingArn = "thingArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct CustomProperty: AWSEncodableShape & AWSDecodableShape {
        /// A comment in addition to the description.
        public let comment: String?
        /// Indicates whether the property is binary data.
        public let dataEncoding: NodeDataEncoding?
        /// The data type for the custom property.
        public let dataType: NodeDataType
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the custom property.
        public let description: String?
        /// The fully qualified name of the custom property. For example, the fully qualified name of a custom property might be ComplexDataTypes.VehicleDataTypes.SVMCamera.FPS.
        public let fullyQualifiedName: String
        /// The fully qualified name of the struct node for the custom property if the data type of the custom property is Struct or StructArray.
        public let structFullyQualifiedName: String?

        public init(comment: String? = nil, dataEncoding: NodeDataEncoding? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, structFullyQualifiedName: String? = nil) {
            self.comment = comment
            self.dataEncoding = dataEncoding
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.structFullyQualifiedName = structFullyQualifiedName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, max: 150)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, min: 1)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case dataEncoding = "dataEncoding"
            case dataType = "dataType"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case structFullyQualifiedName = "structFullyQualifiedName"
        }
    }

    public struct CustomStruct: AWSEncodableShape & AWSDecodableShape {
        /// A comment in addition to the description.
        public let comment: String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the custom structure.
        public let description: String?
        /// The fully qualified name of the custom structure. For example, the fully qualified name of a custom structure might be ComplexDataTypes.VehicleDataTypes.SVMCamera.
        public let fullyQualifiedName: String

        public init(comment: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String) {
            self.comment = comment
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
        }
    }

    public struct DecoderManifestSummary: AWSDecodableShape {
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public let arn: String?
        /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// A brief description of the decoder manifest.
        public let description: String?
        /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The detailed message for the decoder manifest. When a decoder manifest is in an INVALID status, the message contains detailed reason and help information.
        public let message: String?
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public let modelManifestArn: String?
        /// The name of the decoder manifest.
        public let name: String?
        /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
        public let status: ManifestStatus?

        public init(arn: String? = nil, creationTime: Date, description: String? = nil, lastModificationTime: Date, message: String? = nil, modelManifestArn: String? = nil, name: String? = nil, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case message = "message"
            case modelManifestArn = "modelManifestArn"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteCampaignRequest: AWSEncodableShape {
        ///  The name of the campaign to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCampaignResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the deleted campaign.  The ARN isn’t returned if a campaign doesn’t exist.
        public let arn: String?
        /// The name of the deleted campaign.
        public let name: String?

        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteDecoderManifestRequest: AWSEncodableShape {
        ///  The name of the decoder manifest to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDecoderManifestResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted decoder manifest.
        public let arn: String
        /// The name of the deleted decoder manifest.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteFleetRequest: AWSEncodableShape {
        ///  The ID of the fleet to delete.
        public let fleetId: String

        public init(fleetId: String) {
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFleetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted fleet.
        public let arn: String?
        /// The ID of the deleted fleet.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct DeleteModelManifestRequest: AWSEncodableShape {
        ///  The name of the model manifest to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteModelManifestResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted model manifest.
        public let arn: String
        /// The name of the deleted model manifest.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteSignalCatalogRequest: AWSEncodableShape {
        ///  The name of the signal catalog to delete.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSignalCatalogResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted signal catalog.
        public let arn: String
        /// The name of the deleted signal catalog.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteVehicleRequest: AWSEncodableShape {
        /// The ID of the vehicle to delete.
        public let vehicleName: String

        public init(vehicleName: String) {
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVehicleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted vehicle.
        public let arn: String
        /// The ID of the deleted vehicle.
        public let vehicleName: String

        public init(arn: String, vehicleName: String) {
            self.arn = arn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case vehicleName = "vehicleName"
        }
    }

    public struct DisassociateVehicleFleetRequest: AWSEncodableShape {
        ///  The unique ID of a fleet.
        public let fleetId: String
        ///  The unique ID of the vehicle to disassociate from the fleet.
        public let vehicleName: String

        public init(fleetId: String, vehicleName: String) {
            self.fleetId = fleetId
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.fleetId, forKey: .fleetId)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fleetId = "fleetId"
        }
    }

    public struct DisassociateVehicleFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FleetSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let arn: String
        /// The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// A brief description of the fleet.
        public let description: String?
        /// The unique ID of the fleet.
        public let id: String
        /// The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        /// The ARN of the signal catalog associated with the fleet.
        public let signalCatalogArn: String

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, lastModificationTime: Date? = nil, signalCatalogArn: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.signalCatalogArn = signalCatalogArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case lastModificationTime = "lastModificationTime"
            case signalCatalogArn = "signalCatalogArn"
        }
    }

    public struct GetCampaignRequest: AWSEncodableShape {
        ///  The name of the campaign to retrieve information about.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCampaignResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the campaign.
        public let arn: String?
        ///  Information about the data collection scheme associated with the campaign.
        public let collectionScheme: CollectionScheme?
        ///  Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If OFF is specified, the signals aren't compressed. If it's not specified, SNAPPY is used.
        public let compression: Compression?
        ///  The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics.  You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
        public let dataDestinationConfigs: [DataDestinationConfig]?
        ///  A list of vehicle attributes associated with the campaign.
        public let dataExtraDimensions: [String]?
        /// The description of the campaign.
        public let description: String?
        ///  Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.
        public let diagnosticsMode: DiagnosticsMode?
        ///  The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.
        public let expiryTime: Date?
        /// The last time the campaign was modified.
        public let lastModificationTime: Date?
        /// The name of the campaign.
        public let name: String?
        ///  How long (in seconds) to collect raw data after a triggering event initiates the collection.
        public let postTriggerCollectionDuration: Int64?
        ///  A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.
        public let priority: Int?
        ///  The ARN of a signal catalog.
        public let signalCatalogArn: String?
        ///  Information about a list of signals to collect data on.
        public let signalsToCollect: [SignalInformation]?
        ///  Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.
        public let spoolingMode: SpoolingMode?
        ///  The time, in milliseconds, to deliver a campaign after it was approved.
        public let startTime: Date?
        /// The state of the campaign. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, and SUSPENDED.
        public let status: CampaignStatus?
        ///  The ARN of the vehicle or the fleet targeted by the campaign.
        public let targetArn: String?

        public init(arn: String? = nil, collectionScheme: CollectionScheme? = nil, compression: Compression? = nil, creationTime: Date? = nil, dataDestinationConfigs: [DataDestinationConfig]? = nil, dataExtraDimensions: [String]? = nil, description: String? = nil, diagnosticsMode: DiagnosticsMode? = nil, expiryTime: Date? = nil, lastModificationTime: Date? = nil, name: String? = nil, postTriggerCollectionDuration: Int64? = nil, priority: Int? = nil, signalCatalogArn: String? = nil, signalsToCollect: [SignalInformation]? = nil, spoolingMode: SpoolingMode? = nil, startTime: Date? = nil, status: CampaignStatus? = nil, targetArn: String? = nil) {
            self.arn = arn
            self.collectionScheme = collectionScheme
            self.compression = compression
            self.creationTime = creationTime
            self.dataDestinationConfigs = dataDestinationConfigs
            self.dataExtraDimensions = dataExtraDimensions
            self.description = description
            self.diagnosticsMode = diagnosticsMode
            self.expiryTime = expiryTime
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.postTriggerCollectionDuration = postTriggerCollectionDuration
            self.priority = priority
            self.signalCatalogArn = signalCatalogArn
            self.signalsToCollect = signalsToCollect
            self.spoolingMode = spoolingMode
            self.startTime = startTime
            self.status = status
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collectionScheme = "collectionScheme"
            case compression = "compression"
            case creationTime = "creationTime"
            case dataDestinationConfigs = "dataDestinationConfigs"
            case dataExtraDimensions = "dataExtraDimensions"
            case description = "description"
            case diagnosticsMode = "diagnosticsMode"
            case expiryTime = "expiryTime"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case postTriggerCollectionDuration = "postTriggerCollectionDuration"
            case priority = "priority"
            case signalCatalogArn = "signalCatalogArn"
            case signalsToCollect = "signalsToCollect"
            case spoolingMode = "spoolingMode"
            case startTime = "startTime"
            case status = "status"
            case targetArn = "targetArn"
        }
    }

    public struct GetDecoderManifestRequest: AWSEncodableShape {
        ///  The name of the decoder manifest to retrieve information about.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDecoderManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the decoder manifest.
        public let arn: String
        ///  The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the decoder manifest.
        public let description: String?
        ///  The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The detailed message for the decoder manifest. When a decoder manifest is in an INVALID status, the message contains detailed reason and help information.
        public let message: String?
        ///  The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public let modelManifestArn: String?
        ///  The name of the decoder manifest.
        public let name: String
        ///  The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
        public let status: ManifestStatus?

        public init(arn: String, creationTime: Date, description: String? = nil, lastModificationTime: Date, message: String? = nil, modelManifestArn: String? = nil, name: String, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case message = "message"
            case modelManifestArn = "modelManifestArn"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetEncryptionConfigurationResponse: AWSDecodableShape {
        /// The time when encryption was configured in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// The encryption status.
        public let encryptionStatus: EncryptionStatus
        /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use a KMS key that you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key that is owned by the Amazon Web Services IoT FleetWise service account.
        public let encryptionType: EncryptionType
        /// The error message that describes why encryption settings couldn't be configured, if applicable.
        public let errorMessage: String?
        /// The ID of the KMS key that is used for encryption.
        public let kmsKeyId: String?
        /// The time when encryption was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?

        public init(creationTime: Date? = nil, encryptionStatus: EncryptionStatus, encryptionType: EncryptionType, errorMessage: String? = nil, kmsKeyId: String? = nil, lastModificationTime: Date? = nil) {
            self.creationTime = creationTime
            self.encryptionStatus = encryptionStatus
            self.encryptionType = encryptionType
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case encryptionStatus = "encryptionStatus"
            case encryptionType = "encryptionType"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case lastModificationTime = "lastModificationTime"
        }
    }

    public struct GetFleetRequest: AWSEncodableShape {
        ///  The ID of the fleet to retrieve information about.
        public let fleetId: String

        public init(fleetId: String) {
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFleetResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the fleet.
        public let arn: String
        ///  The time the fleet was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the fleet.
        public let description: String?
        ///  The ID of the fleet.
        public let id: String
        ///  The time the fleet was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        ///  The ARN of a signal catalog associated with the fleet.
        public let signalCatalogArn: String

        public init(arn: String, creationTime: Date, description: String? = nil, id: String, lastModificationTime: Date, signalCatalogArn: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.signalCatalogArn = signalCatalogArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case lastModificationTime = "lastModificationTime"
            case signalCatalogArn = "signalCatalogArn"
        }
    }

    public struct GetLoggingOptionsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetLoggingOptionsResponse: AWSDecodableShape {
        /// Returns information about log delivery to Amazon CloudWatch Logs.
        public let cloudWatchLogDelivery: CloudWatchLogDeliveryOptions

        public init(cloudWatchLogDelivery: CloudWatchLogDeliveryOptions) {
            self.cloudWatchLogDelivery = cloudWatchLogDelivery
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogDelivery = "cloudWatchLogDelivery"
        }
    }

    public struct GetModelManifestRequest: AWSEncodableShape {
        ///  The name of the vehicle model to retrieve information about.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the vehicle model.
        public let arn: String
        /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the vehicle model.
        public let description: String?
        /// The last time the vehicle model was modified.
        public let lastModificationTime: Date
        ///  The name of the vehicle model.
        public let name: String
        ///  The ARN of the signal catalog associated with the vehicle model.
        public let signalCatalogArn: String?
        ///  The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. You can edit the vehicle model if the status is marked DRAFT.
        public let status: ManifestStatus?

        public init(arn: String, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String, signalCatalogArn: String? = nil, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
            case status = "status"
        }
    }

    public struct GetRegisterAccountStatusRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetRegisterAccountStatusResponse: AWSDecodableShape {
        ///  The status of registering your account and resources. The status can be one of:    REGISTRATION_SUCCESS - The Amazon Web Services resource is successfully registered.    REGISTRATION_PENDING - Amazon Web Services IoT FleetWise is processing the registration request. This process takes approximately five minutes to complete.    REGISTRATION_FAILURE - Amazon Web Services IoT FleetWise can't register the AWS resource. Try again later.
        public let accountStatus: RegistrationStatus
        ///  The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  The unique ID of the Amazon Web Services account, provided at account creation.
        public let customerAccountId: String
        ///  Information about the registered IAM resources or errors, if any.
        public let iamRegistrationResponse: IamRegistrationResponse
        ///  The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        ///  Information about the registered Amazon Timestream resources or errors, if any.
        public let timestreamRegistrationResponse: TimestreamRegistrationResponse?

        public init(accountStatus: RegistrationStatus, creationTime: Date, customerAccountId: String, iamRegistrationResponse: IamRegistrationResponse, lastModificationTime: Date, timestreamRegistrationResponse: TimestreamRegistrationResponse? = nil) {
            self.accountStatus = accountStatus
            self.creationTime = creationTime
            self.customerAccountId = customerAccountId
            self.iamRegistrationResponse = iamRegistrationResponse
            self.lastModificationTime = lastModificationTime
            self.timestreamRegistrationResponse = timestreamRegistrationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case accountStatus = "accountStatus"
            case creationTime = "creationTime"
            case customerAccountId = "customerAccountId"
            case iamRegistrationResponse = "iamRegistrationResponse"
            case lastModificationTime = "lastModificationTime"
            case timestreamRegistrationResponse = "timestreamRegistrationResponse"
        }
    }

    public struct GetSignalCatalogRequest: AWSEncodableShape {
        ///  The name of the signal catalog to retrieve information about.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSignalCatalogResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the signal catalog.
        public let arn: String
        ///  The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the signal catalog.
        public let description: String?
        /// The last time the signal catalog was modified.
        public let lastModificationTime: Date
        ///  The name of the signal catalog.
        public let name: String
        ///  The total number of network nodes specified in a signal catalog.
        public let nodeCounts: NodeCounts?

        public init(arn: String, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String, nodeCounts: NodeCounts? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.nodeCounts = nodeCounts
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case nodeCounts = "nodeCounts"
        }
    }

    public struct GetVehicleRequest: AWSEncodableShape {
        ///  The ID of the vehicle to retrieve information about.
        public let vehicleName: String

        public init(vehicleName: String) {
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVehicleResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the vehicle to retrieve information about.
        public let arn: String?
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        ///  The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        ///  The ARN of a decoder manifest associated with the vehicle.
        public let decoderManifestArn: String?
        ///  The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        ///  The ARN of a vehicle model (model manifest) associated with the vehicle.
        public let modelManifestArn: String?
        /// The ID of the vehicle.
        public let vehicleName: String?

        public init(arn: String? = nil, attributes: [String: String]? = nil, creationTime: Date? = nil, decoderManifestArn: String? = nil, lastModificationTime: Date? = nil, modelManifestArn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.attributes = attributes
            self.creationTime = creationTime
            self.decoderManifestArn = decoderManifestArn
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case attributes = "attributes"
            case creationTime = "creationTime"
            case decoderManifestArn = "decoderManifestArn"
            case lastModificationTime = "lastModificationTime"
            case modelManifestArn = "modelManifestArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct GetVehicleStatusRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        ///  The ID of the vehicle to retrieve information about.
        public let vehicleName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, vehicleName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVehicleStatusResponse: AWSDecodableShape {
        ///  Lists information about the state of the vehicle with deployed campaigns.
        public let campaigns: [VehicleStatus]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(campaigns: [VehicleStatus]? = nil, nextToken: String? = nil) {
            self.campaigns = campaigns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaigns = "campaigns"
            case nextToken = "nextToken"
        }
    }

    public struct IamRegistrationResponse: AWSDecodableShape {
        /// A message associated with a registration error.
        public let errorMessage: String?
        /// The status of registering your IAM resource. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        public let registrationStatus: RegistrationStatus
        /// The Amazon Resource Name (ARN) of the IAM role to register.
        public let roleArn: String

        public init(errorMessage: String? = nil, registrationStatus: RegistrationStatus, roleArn: String) {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case registrationStatus = "registrationStatus"
            case roleArn = "roleArn"
        }
    }

    public struct IamResources: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN.
        public let roleArn: String

        public init(roleArn: String) {
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):iam::(\\d{12})?:(role((\\u002F)|(\\u002F[\\u0021-\\u007F]+\\u002F))[\\w+=,.@-]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
        }
    }

    public struct ImportDecoderManifestRequest: AWSEncodableShape {
        ///  The name of the decoder manifest to import.
        public let name: String
        ///  The file to load into an Amazon Web Services account.
        public let networkFileDefinitions: [NetworkFileDefinition]

        public init(name: String, networkFileDefinitions: [NetworkFileDefinition]) {
            self.name = name
            self.networkFileDefinitions = networkFileDefinitions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            try container.encode(self.networkFileDefinitions, forKey: .networkFileDefinitions)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.networkFileDefinitions.forEach {
                try $0.validate(name: "\(name).networkFileDefinitions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case networkFileDefinitions = "networkFileDefinitions"
        }
    }

    public struct ImportDecoderManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the decoder manifest that was imported.
        public let arn: String
        ///  The name of the imported decoder manifest.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct ImportSignalCatalogRequest: AWSEncodableShape {
        ///  A brief description of the signal catalog.
        public let description: String?
        /// The name of the signal catalog to import.
        public let name: String
        /// Metadata that can be used to manage the signal catalog.
        public let tags: [Tag]?
        /// The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.
        public let vss: FormattedVss?

        public init(description: String? = nil, name: String, tags: [Tag]? = nil, vss: FormattedVss? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
            self.vss = vss
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.vss, forKey: .vss)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case tags = "tags"
            case vss = "vss"
        }
    }

    public struct ImportSignalCatalogResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the imported signal catalog.
        public let arn: String
        ///  The name of the imported signal catalog.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct ListCampaignsRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        /// Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, or SUSPENDED.
        public let status: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, status: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCampaignsResponse: AWSDecodableShape {
        ///  A summary of information about each campaign.
        public let campaignSummaries: [CampaignSummary]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(campaignSummaries: [CampaignSummary]? = nil, nextToken: String? = nil) {
            self.campaignSummaries = campaignSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaignSummaries = "campaignSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDecoderManifestNetworkInterfacesRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the decoder manifest to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDecoderManifestNetworkInterfacesResponse: AWSDecodableShape {
        ///  A list of information about network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(networkInterfaces: [NetworkInterface]? = nil, nextToken: String? = nil) {
            self.networkInterfaces = networkInterfaces
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkInterfaces = "networkInterfaces"
            case nextToken = "nextToken"
        }
    }

    public struct ListDecoderManifestSignalsRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the decoder manifest to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDecoderManifestSignalsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  Information about a list of signals to decode.
        public let signalDecoders: [SignalDecoder]?

        public init(nextToken: String? = nil, signalDecoders: [SignalDecoder]? = nil) {
            self.nextToken = nextToken
            self.signalDecoders = signalDecoders
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case signalDecoders = "signalDecoders"
        }
    }

    public struct ListDecoderManifestsRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.
        public let modelManifestArn: String?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, modelManifestArn: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelManifestArn = modelManifestArn
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.modelManifestArn, key: "modelManifestArn")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDecoderManifestsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about each decoder manifest.
        public let summaries: [DecoderManifestSummary]?

        public init(nextToken: String? = nil, summaries: [DecoderManifestSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListFleetsForVehicleRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        ///  The ID of the vehicle to retrieve information about.
        public let vehicleName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, vehicleName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFleetsForVehicleResponse: AWSDecodableShape {
        ///  A list of fleet IDs that the vehicle is associated with.
        public let fleets: [String]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(fleets: [String]? = nil, nextToken: String? = nil) {
            self.fleets = fleets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleets = "fleets"
            case nextToken = "nextToken"
        }
    }

    public struct ListFleetsRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFleetsResponse: AWSDecodableShape {
        ///  A list of information for each fleet.
        public let fleetSummaries: [FleetSummary]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        public init(fleetSummaries: [FleetSummary]? = nil, nextToken: String? = nil) {
            self.fleetSummaries = fleetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleetSummaries = "fleetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListModelManifestNodesRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the vehicle model to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelManifestNodesResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about nodes.
        public let nodes: [Node]?

        public init(nextToken: String? = nil, nodes: [Node]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodes = "nodes"
        }
    }

    public struct ListModelManifestsRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        ///  The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.
        public let signalCatalogArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, signalCatalogArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.signalCatalogArn = signalCatalogArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.signalCatalogArn, key: "signalCatalogArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelManifestsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about vehicle models.
        public let summaries: [ModelManifestSummary]?

        public init(nextToken: String? = nil, summaries: [ModelManifestSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListSignalCatalogNodesRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the signal catalog to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        /// The type of node in the signal catalog.
        public let signalNodeType: SignalNodeType?

        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil, signalNodeType: SignalNodeType? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.signalNodeType = signalNodeType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.signalNodeType, key: "signalNodeType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSignalCatalogNodesResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about nodes.
        public let nodes: [Node]?

        public init(nextToken: String? = nil, nodes: [Node]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodes = "nodes"
        }
    }

    public struct ListSignalCatalogsRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSignalCatalogsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about each signal catalog.
        public let summaries: [SignalCatalogSummary]?

        public init(nextToken: String? = nil, summaries: [SignalCatalogSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags assigned to the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListVehiclesInFleetRequest: AWSEncodableShape {
        ///  The ID of a fleet.
        public let fleetId: String
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(fleetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.fleetId = fleetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVehiclesInFleetResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of vehicles associated with the fleet.
        public let vehicles: [String]?

        public init(nextToken: String? = nil, vehicles: [String]? = nil) {
            self.nextToken = nextToken
            self.vehicles = vehicles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vehicles = "vehicles"
        }
    }

    public struct ListVehiclesRequest: AWSEncodableShape {
        ///  The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model.
        public let modelManifestArn: String?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, modelManifestArn: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.modelManifestArn = modelManifestArn
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.modelManifestArn, key: "modelManifestArn")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVehiclesResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of vehicles and information about them.
        public let vehicleSummaries: [VehicleSummary]?

        public init(nextToken: String? = nil, vehicleSummaries: [VehicleSummary]? = nil) {
            self.nextToken = nextToken
            self.vehicleSummaries = vehicleSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vehicleSummaries = "vehicleSummaries"
        }
    }

    public struct MessageSignal: AWSEncodableShape & AWSDecodableShape {
        /// The structured message for the message signal. It can be defined with either a primitiveMessageDefinition, structuredMessageListDefinition, or structuredMessageDefinition recursively.
        public let structuredMessage: StructuredMessage
        /// The topic name for the message signal. It corresponds to topics in ROS 2.
        public let topicName: String

        public init(structuredMessage: StructuredMessage, topicName: String) {
            self.structuredMessage = structuredMessage
            self.topicName = topicName
        }

        public func validate(name: String) throws {
            try self.structuredMessage.validate(name: "\(name).structuredMessage")
            try self.validate(self.topicName, name: "topicName", parent: name, max: 150)
            try self.validate(self.topicName, name: "topicName", parent: name, min: 1)
            try self.validate(self.topicName, name: "topicName", parent: name, pattern: "^[a-zA-Z0-9_\\-#:./]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case structuredMessage = "structuredMessage"
            case topicName = "topicName"
        }
    }

    public struct ModelManifestSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the vehicle model.
        public let arn: String?
        /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// A brief description of the vehicle model.
        public let description: String?
        /// The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The name of the vehicle model.
        public let name: String?
        /// The ARN of the signal catalog associated with the vehicle model.
        public let signalCatalogArn: String?
        /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
        public let status: ManifestStatus?

        public init(arn: String? = nil, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String? = nil, signalCatalogArn: String? = nil, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
            case status = "status"
        }
    }

    public struct NetworkInterface: AWSEncodableShape & AWSDecodableShape {
        /// Information about a network interface specified by the Controller Area Network (CAN) protocol.
        public let canInterface: CanInterface?
        /// The ID of the network interface.
        public let interfaceId: String
        /// Information about a network interface specified by the On-board diagnostic (OBD) II protocol.
        public let obdInterface: ObdInterface?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        public let type: NetworkInterfaceType
        /// The vehicle middleware defined as a type of network interface. Examples of vehicle middleware include ROS2 and SOME/IP.
        public let vehicleMiddleware: VehicleMiddleware?

        public init(canInterface: CanInterface? = nil, interfaceId: String, obdInterface: ObdInterface? = nil, type: NetworkInterfaceType, vehicleMiddleware: VehicleMiddleware? = nil) {
            self.canInterface = canInterface
            self.interfaceId = interfaceId
            self.obdInterface = obdInterface
            self.type = type
            self.vehicleMiddleware = vehicleMiddleware
        }

        public func validate(name: String) throws {
            try self.canInterface?.validate(name: "\(name).canInterface")
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, max: 50)
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, min: 1)
            try self.obdInterface?.validate(name: "\(name).obdInterface")
            try self.vehicleMiddleware?.validate(name: "\(name).vehicleMiddleware")
        }

        private enum CodingKeys: String, CodingKey {
            case canInterface = "canInterface"
            case interfaceId = "interfaceId"
            case obdInterface = "obdInterface"
            case type = "type"
            case vehicleMiddleware = "vehicleMiddleware"
        }
    }

    public struct NodeCounts: AWSDecodableShape {
        /// The total number of nodes in a vehicle network that represent actuators.
        public let totalActuators: Int?
        /// The total number of nodes in a vehicle network that represent attributes.
        public let totalAttributes: Int?
        /// The total number of nodes in a vehicle network that represent branches.
        public let totalBranches: Int?
        /// The total number of nodes in a vehicle network.
        public let totalNodes: Int?
        /// The total properties for the node.
        public let totalProperties: Int?
        /// The total number of nodes in a vehicle network that represent sensors.
        public let totalSensors: Int?
        /// The total structure for the node.
        public let totalStructs: Int?

        public init(totalActuators: Int? = nil, totalAttributes: Int? = nil, totalBranches: Int? = nil, totalNodes: Int? = nil, totalProperties: Int? = nil, totalSensors: Int? = nil, totalStructs: Int? = nil) {
            self.totalActuators = totalActuators
            self.totalAttributes = totalAttributes
            self.totalBranches = totalBranches
            self.totalNodes = totalNodes
            self.totalProperties = totalProperties
            self.totalSensors = totalSensors
            self.totalStructs = totalStructs
        }

        private enum CodingKeys: String, CodingKey {
            case totalActuators = "totalActuators"
            case totalAttributes = "totalAttributes"
            case totalBranches = "totalBranches"
            case totalNodes = "totalNodes"
            case totalProperties = "totalProperties"
            case totalSensors = "totalSensors"
            case totalStructs = "totalStructs"
        }
    }

    public struct ObdInterface: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number message requests per diagnostic trouble code per second.
        public let dtcRequestIntervalSeconds: Int?
        /// Whether the vehicle has a transmission control module (TCM).
        public let hasTransmissionEcu: Bool?
        /// The name of the interface.
        public let name: String
        /// The standard OBD II PID.
        public let obdStandard: String?
        /// The maximum number message requests per second.
        public let pidRequestIntervalSeconds: Int?
        /// The ID of the message requesting vehicle data.
        public let requestMessageId: Int
        /// Whether to use extended IDs in the message.
        public let useExtendedIds: Bool?

        public init(dtcRequestIntervalSeconds: Int? = nil, hasTransmissionEcu: Bool? = nil, name: String, obdStandard: String? = nil, pidRequestIntervalSeconds: Int? = nil, requestMessageId: Int, useExtendedIds: Bool? = nil) {
            self.dtcRequestIntervalSeconds = dtcRequestIntervalSeconds
            self.hasTransmissionEcu = hasTransmissionEcu
            self.name = name
            self.obdStandard = obdStandard
            self.pidRequestIntervalSeconds = pidRequestIntervalSeconds
            self.requestMessageId = requestMessageId
            self.useExtendedIds = useExtendedIds
        }

        public func validate(name: String) throws {
            try self.validate(self.dtcRequestIntervalSeconds, name: "dtcRequestIntervalSeconds", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.obdStandard, name: "obdStandard", parent: name, max: 50)
            try self.validate(self.obdStandard, name: "obdStandard", parent: name, min: 1)
            try self.validate(self.pidRequestIntervalSeconds, name: "pidRequestIntervalSeconds", parent: name, min: 0)
            try self.validate(self.requestMessageId, name: "requestMessageId", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dtcRequestIntervalSeconds = "dtcRequestIntervalSeconds"
            case hasTransmissionEcu = "hasTransmissionEcu"
            case name = "name"
            case obdStandard = "obdStandard"
            case pidRequestIntervalSeconds = "pidRequestIntervalSeconds"
            case requestMessageId = "requestMessageId"
            case useExtendedIds = "useExtendedIds"
        }
    }

    public struct ObdSignal: AWSEncodableShape & AWSDecodableShape {
        /// The number of bits to mask in a message.
        public let bitMaskLength: Int?
        /// The number of positions to shift bits in the message.
        public let bitRightShift: Int?
        /// The length of a message.
        public let byteLength: Int
        /// The offset used to calculate the signal value. Combined with scaling, the calculation is value = raw_value * scaling + offset.
        public let offset: Double
        /// The diagnostic code used to request data from a vehicle for this signal.
        public let pid: Int
        /// The length of the requested data.
        public let pidResponseLength: Int
        /// A multiplier used to decode the message.
        public let scaling: Double
        /// The mode of operation (diagnostic service) in a message.
        public let serviceMode: Int
        /// Indicates the beginning of the message.
        public let startByte: Int

        public init(bitMaskLength: Int? = nil, bitRightShift: Int? = nil, byteLength: Int, offset: Double, pid: Int, pidResponseLength: Int, scaling: Double, serviceMode: Int, startByte: Int) {
            self.bitMaskLength = bitMaskLength
            self.bitRightShift = bitRightShift
            self.byteLength = byteLength
            self.offset = offset
            self.pid = pid
            self.pidResponseLength = pidResponseLength
            self.scaling = scaling
            self.serviceMode = serviceMode
            self.startByte = startByte
        }

        public func validate(name: String) throws {
            try self.validate(self.bitMaskLength, name: "bitMaskLength", parent: name, max: 8)
            try self.validate(self.bitMaskLength, name: "bitMaskLength", parent: name, min: 1)
            try self.validate(self.bitRightShift, name: "bitRightShift", parent: name, min: 0)
            try self.validate(self.byteLength, name: "byteLength", parent: name, max: 8)
            try self.validate(self.byteLength, name: "byteLength", parent: name, min: 1)
            try self.validate(self.pid, name: "pid", parent: name, min: 0)
            try self.validate(self.pidResponseLength, name: "pidResponseLength", parent: name, min: 1)
            try self.validate(self.serviceMode, name: "serviceMode", parent: name, min: 0)
            try self.validate(self.startByte, name: "startByte", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case bitMaskLength = "bitMaskLength"
            case bitRightShift = "bitRightShift"
            case byteLength = "byteLength"
            case offset = "offset"
            case pid = "pid"
            case pidResponseLength = "pidResponseLength"
            case scaling = "scaling"
            case serviceMode = "serviceMode"
            case startByte = "startByte"
        }
    }

    public struct PutEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption. Choose KMS_BASED_ENCRYPTION to use a KMS key or FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key.
        public let encryptionType: EncryptionType
        /// The ID of the KMS key that is used for encryption.
        public let kmsKeyId: String?

        public init(encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct PutEncryptionConfigurationResponse: AWSDecodableShape {
        /// The encryption status.
        public let encryptionStatus: EncryptionStatus
        /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use an KMS key that you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key that is owned by the Amazon Web Services IoT FleetWise service account.
        public let encryptionType: EncryptionType
        /// The ID of the KMS key that is used for encryption.
        public let kmsKeyId: String?

        public init(encryptionStatus: EncryptionStatus, encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionStatus = encryptionStatus
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionStatus = "encryptionStatus"
            case encryptionType = "encryptionType"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {
        /// Creates or updates the log delivery option to Amazon CloudWatch Logs.
        public let cloudWatchLogDelivery: CloudWatchLogDeliveryOptions

        public init(cloudWatchLogDelivery: CloudWatchLogDeliveryOptions) {
            self.cloudWatchLogDelivery = cloudWatchLogDelivery
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogDelivery.validate(name: "\(name).cloudWatchLogDelivery")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogDelivery = "cloudWatchLogDelivery"
        }
    }

    public struct PutLoggingOptionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ROS2PrimitiveMessageDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The offset used to calculate the signal value. Combined with scaling, the calculation is value = raw_value * scaling + offset.
        public let offset: Double?
        /// The primitive type (integer, floating point, boolean, etc.) for the ROS 2 primitive message definition.
        public let primitiveType: ROS2PrimitiveType
        /// A multiplier used to decode the message.
        public let scaling: Double?
        /// An optional attribute specifying the upper bound for STRING and WSTRING.
        public let upperBound: Int64?

        public init(offset: Double? = nil, primitiveType: ROS2PrimitiveType, scaling: Double? = nil, upperBound: Int64? = nil) {
            self.offset = offset
            self.primitiveType = primitiveType
            self.scaling = scaling
            self.upperBound = upperBound
        }

        public func validate(name: String) throws {
            try self.validate(self.upperBound, name: "upperBound", parent: name, max: 2048)
            try self.validate(self.upperBound, name: "upperBound", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case offset = "offset"
            case primitiveType = "primitiveType"
            case scaling = "scaling"
            case upperBound = "upperBound"
        }
    }

    public struct RegisterAccountRequest: AWSEncodableShape {
        /// The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
        public let iamResources: IamResources?
        public let timestreamResources: TimestreamResources?

        public init() {
            self.iamResources = nil
            self.timestreamResources = nil
        }

        @available(*, deprecated, message: "Members iamResources, timestreamResources have been deprecated")
        public init(iamResources: IamResources? = nil, timestreamResources: TimestreamResources? = nil) {
            self.iamResources = iamResources
            self.timestreamResources = timestreamResources
        }

        public func validate(name: String) throws {
            try self.iamResources?.validate(name: "\(name).iamResources")
            try self.timestreamResources?.validate(name: "\(name).timestreamResources")
        }

        private enum CodingKeys: String, CodingKey {
            case iamResources = "iamResources"
            case timestreamResources = "timestreamResources"
        }
    }

    public struct RegisterAccountResponse: AWSDecodableShape {
        ///  The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  The registered IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
        public let iamResources: IamResources
        ///  The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        ///  The status of registering your Amazon Web Services account, IAM role, and Timestream resources.
        public let registerAccountStatus: RegistrationStatus
        public let timestreamResources: TimestreamResources?

        public init(creationTime: Date, iamResources: IamResources, lastModificationTime: Date, registerAccountStatus: RegistrationStatus, timestreamResources: TimestreamResources? = nil) {
            self.creationTime = creationTime
            self.iamResources = iamResources
            self.lastModificationTime = lastModificationTime
            self.registerAccountStatus = registerAccountStatus
            self.timestreamResources = timestreamResources
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case iamResources = "iamResources"
            case lastModificationTime = "lastModificationTime"
            case registerAccountStatus = "registerAccountStatus"
            case timestreamResources = "timestreamResources"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket.
        public let bucketArn: String
        /// Specify the format that files are saved in the Amazon S3 bucket. You can save files in an Apache Parquet or JSON format.   Parquet - Store data in a columnar storage file format. Parquet is optimal for fast data retrieval and can reduce costs. This option is selected by default.   JSON - Store data in a standard text-based JSON file format.
        public let dataFormat: DataFormat?
        /// (Optional) Enter an S3 bucket prefix. The prefix is the string of characters after the bucket name and before the object name. You can use the prefix to organize data stored in Amazon S3 buckets. For more information, see Organizing objects using prefixes in the Amazon Simple Storage Service User Guide. By default, Amazon Web Services IoT FleetWise sets the prefix processed-data/year=YY/month=MM/date=DD/hour=HH/ (in UTC) to data it delivers to Amazon S3. You can enter a prefix to append it to this default prefix. For example, if you enter the prefix vehicles, the prefix will be vehicles/processed-data/year=YY/month=MM/date=DD/hour=HH/.
        public let prefix: String?
        /// By default, stored data is compressed as a .gzip file. Compressed files have a reduced file size, which can optimize the cost of data storage.
        public let storageCompressionFormat: StorageCompressionFormat?

        public init(bucketArn: String, dataFormat: DataFormat? = nil, prefix: String? = nil, storageCompressionFormat: StorageCompressionFormat? = nil) {
            self.bucketArn = bucketArn
            self.dataFormat = dataFormat
            self.prefix = prefix
            self.storageCompressionFormat = storageCompressionFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, max: 100)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, min: 16)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):s3:::.+$")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 512)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^[a-zA-Z0-9-_:./!*'()]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case dataFormat = "dataFormat"
            case prefix = "prefix"
            case storageCompressionFormat = "storageCompressionFormat"
        }
    }

    public struct Sensor: AWSEncodableShape & AWSDecodableShape {
        /// A list of possible values a sensor can take.
        public let allowedValues: [String]?
        /// A comment in addition to the description.
        public let comment: String?
        /// The specified data type of the sensor.
        public let dataType: NodeDataType
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of a sensor.
        public let description: String?
        /// The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be Vehicle.Body.Engine.Battery.
        public let fullyQualifiedName: String
        /// The specified possible maximum value of the sensor.
        public let max: Double?
        /// The specified possible minimum value of the sensor.
        public let min: Double?
        /// The fully qualified name of the struct node for a sensor if the data type of the actuator is Struct or StructArray. For example, the struct fully qualified name of a sensor might be Vehicle.ADAS.CameraStruct.
        public let structFullyQualifiedName: String?
        /// The scientific unit of measurement for data collected by the sensor.
        public let unit: String?

        public init(allowedValues: [String]? = nil, comment: String? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, structFullyQualifiedName: String? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, max: 150)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, min: 1)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case comment = "comment"
            case dataType = "dataType"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case max = "max"
            case min = "min"
            case structFullyQualifiedName = "structFullyQualifiedName"
            case unit = "unit"
        }
    }

    public struct SignalCatalogSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the signal catalog.
        public let arn: String?
        /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        /// The name of the signal catalog.
        public let name: String?

        public init(arn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
        }
    }

    public struct SignalDecoder: AWSEncodableShape & AWSDecodableShape {
        /// Information about signal decoder using the Controller Area Network (CAN) protocol.
        public let canSignal: CanSignal?
        /// The fully qualified name of a signal decoder as defined in a vehicle model.
        public let fullyQualifiedName: String
        /// The ID of a network interface that specifies what network protocol a vehicle follows.
        public let interfaceId: String
        /// The decoding information for a specific message which supports higher order data types.
        public let messageSignal: MessageSignal?
        /// Information about signal decoder using the On-board diagnostic (OBD) II protocol.
        public let obdSignal: ObdSignal?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        public let type: SignalDecoderType

        public init(canSignal: CanSignal? = nil, fullyQualifiedName: String, interfaceId: String, messageSignal: MessageSignal? = nil, obdSignal: ObdSignal? = nil, type: SignalDecoderType) {
            self.canSignal = canSignal
            self.fullyQualifiedName = fullyQualifiedName
            self.interfaceId = interfaceId
            self.messageSignal = messageSignal
            self.obdSignal = obdSignal
            self.type = type
        }

        public func validate(name: String) throws {
            try self.canSignal?.validate(name: "\(name).canSignal")
            try self.validate(self.fullyQualifiedName, name: "fullyQualifiedName", parent: name, max: 150)
            try self.validate(self.fullyQualifiedName, name: "fullyQualifiedName", parent: name, min: 1)
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, max: 50)
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, min: 1)
            try self.messageSignal?.validate(name: "\(name).messageSignal")
            try self.obdSignal?.validate(name: "\(name).obdSignal")
        }

        private enum CodingKeys: String, CodingKey {
            case canSignal = "canSignal"
            case fullyQualifiedName = "fullyQualifiedName"
            case interfaceId = "interfaceId"
            case messageSignal = "messageSignal"
            case obdSignal = "obdSignal"
            case type = "type"
        }
    }

    public struct SignalInformation: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number of samples to collect.
        public let maxSampleCount: Int64?
        /// The minimum duration of time (in milliseconds) between two triggering events to collect data.  If a signal changes often, you might want to collect data at a slower rate.
        public let minimumSamplingIntervalMs: Int64?
        /// The name of the signal.
        public let name: String

        public init(maxSampleCount: Int64? = nil, minimumSamplingIntervalMs: Int64? = nil, name: String) {
            self.maxSampleCount = maxSampleCount
            self.minimumSamplingIntervalMs = minimumSamplingIntervalMs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.maxSampleCount, name: "maxSampleCount", parent: name, max: 4294967295)
            try self.validate(self.maxSampleCount, name: "maxSampleCount", parent: name, min: 1)
            try self.validate(self.minimumSamplingIntervalMs, name: "minimumSamplingIntervalMs", parent: name, max: 4294967295)
            try self.validate(self.minimumSamplingIntervalMs, name: "minimumSamplingIntervalMs", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w|*|-]+(\\.[\\w|*|-]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxSampleCount = "maxSampleCount"
            case minimumSamplingIntervalMs = "minimumSamplingIntervalMs"
            case name = "name"
        }
    }

    public struct StructuredMessageFieldNameAndDataTypePair: AWSEncodableShape & AWSDecodableShape {
        /// The data type.
        public let dataType: StructuredMessage
        /// The field name of the structured message. It determines how a data value is referenced in the target language.
        public let fieldName: String

        public init(dataType: StructuredMessage, fieldName: String) {
            self.dataType = dataType
            self.fieldName = fieldName
        }

        public func validate(name: String) throws {
            try self.dataType.validate(name: "\(name).dataType")
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 150)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case fieldName = "fieldName"
        }
    }

    public struct StructuredMessageListDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The capacity of the structured message list definition when the list type is FIXED_CAPACITY or DYNAMIC_BOUNDED_CAPACITY.
        public let capacity: Int?
        /// The type of list of the structured message list definition.
        public let listType: StructuredMessageListType
        /// The member type of the structured message list definition.
        public let memberType: StructuredMessage
        /// The name of the structured message list definition.
        public let name: String

        public init(capacity: Int? = nil, listType: StructuredMessageListType, memberType: StructuredMessage, name: String) {
            self.capacity = capacity
            self.listType = listType
            self.memberType = memberType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.capacity, name: "capacity", parent: name, min: 0)
            try self.memberType.validate(name: "\(name).memberType")
            try self.validate(self.name, name: "name", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case listType = "listType"
            case memberType = "memberType"
            case name = "name"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag's key.
        public let key: String
        /// The tag's value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// The new or modified tags for the resource.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeBasedCollectionScheme: AWSEncodableShape & AWSDecodableShape {
        /// The time period (in milliseconds) to decide how often to collect data. For example, if the time period is 60000, the Edge Agent software collects data once every minute.
        public let periodMs: Int64

        public init(periodMs: Int64) {
            self.periodMs = periodMs
        }

        public func validate(name: String) throws {
            try self.validate(self.periodMs, name: "periodMs", parent: name, max: 60000)
            try self.validate(self.periodMs, name: "periodMs", parent: name, min: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case periodMs = "periodMs"
        }
    }

    public struct TimestreamConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the task execution role that grants Amazon Web Services IoT FleetWise permission to deliver data to the Amazon Timestream table.
        public let executionRoleArn: String
        /// The Amazon Resource Name (ARN) of the Amazon Timestream table.
        public let timestreamTableArn: String

        public init(executionRoleArn: String, timestreamTableArn: String) {
            self.executionRoleArn = executionRoleArn
            self.timestreamTableArn = timestreamTableArn
        }

        public func validate(name: String) throws {
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):iam::(\\d{12})?:(role((\\u002F)|(\\u002F[\\u0021-\\u007F]+\\u002F))[\\w+=,.@-]+)$")
            try self.validate(self.timestreamTableArn, name: "timestreamTableArn", parent: name, max: 2048)
            try self.validate(self.timestreamTableArn, name: "timestreamTableArn", parent: name, min: 20)
            try self.validate(self.timestreamTableArn, name: "timestreamTableArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):timestream:[a-zA-Z0-9-]+:[0-9]{12}:database/[a-zA-Z0-9_.-]+/table/[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case executionRoleArn = "executionRoleArn"
            case timestreamTableArn = "timestreamTableArn"
        }
    }

    public struct TimestreamRegistrationResponse: AWSDecodableShape {
        /// A message associated with a registration error.
        public let errorMessage: String?
        /// The status of registering your Amazon Timestream resources. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        public let registrationStatus: RegistrationStatus
        /// The Amazon Resource Name (ARN) of the Timestream database.
        public let timestreamDatabaseArn: String?
        /// The name of the Timestream database.
        public let timestreamDatabaseName: String
        /// The ARN of the Timestream database table.
        public let timestreamTableArn: String?
        /// The name of the Timestream database table.
        public let timestreamTableName: String

        public init(errorMessage: String? = nil, registrationStatus: RegistrationStatus, timestreamDatabaseArn: String? = nil, timestreamDatabaseName: String, timestreamTableArn: String? = nil, timestreamTableName: String) {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.timestreamDatabaseArn = timestreamDatabaseArn
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableArn = timestreamTableArn
            self.timestreamTableName = timestreamTableName
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case registrationStatus = "registrationStatus"
            case timestreamDatabaseArn = "timestreamDatabaseArn"
            case timestreamDatabaseName = "timestreamDatabaseName"
            case timestreamTableArn = "timestreamTableArn"
            case timestreamTableName = "timestreamTableName"
        }
    }

    public struct TimestreamResources: AWSEncodableShape & AWSDecodableShape {
        /// The name of the registered Amazon Timestream database.
        public let timestreamDatabaseName: String
        /// The name of the registered Amazon Timestream database table.
        public let timestreamTableName: String

        public init(timestreamDatabaseName: String, timestreamTableName: String) {
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableName = timestreamTableName
        }

        public func validate(name: String) throws {
            try self.validate(self.timestreamDatabaseName, name: "timestreamDatabaseName", parent: name, max: 255)
            try self.validate(self.timestreamDatabaseName, name: "timestreamDatabaseName", parent: name, min: 3)
            try self.validate(self.timestreamDatabaseName, name: "timestreamDatabaseName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.timestreamTableName, name: "timestreamTableName", parent: name, max: 255)
            try self.validate(self.timestreamTableName, name: "timestreamTableName", parent: name, min: 3)
            try self.validate(self.timestreamTableName, name: "timestreamTableName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case timestreamDatabaseName = "timestreamDatabaseName"
            case timestreamTableName = "timestreamTableName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// A list of the keys of the tags to be removed from the resource.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCampaignRequest: AWSEncodableShape {
        ///  Specifies how to update a campaign. The action can be one of the following:    APPROVE - To approve delivering a data collection scheme to vehicles.     SUSPEND - To suspend collecting signal data. The campaign is deleted from vehicles and all vehicles in the suspended campaign will stop sending data.    RESUME - To reactivate the SUSPEND campaign. The campaign is redeployed to all vehicles and the vehicles will resume sending data.    UPDATE - To update a campaign.
        public let action: UpdateCampaignAction
        ///  A list of vehicle attributes to associate with a signal.  Default: An empty array
        public let dataExtraDimensions: [String]?
        /// The description of the campaign.
        public let description: String?
        ///  The name of the campaign to update.
        public let name: String

        public init(action: UpdateCampaignAction, dataExtraDimensions: [String]? = nil, description: String? = nil, name: String) {
            self.action = action
            self.dataExtraDimensions = dataExtraDimensions
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.dataExtraDimensions, forKey: .dataExtraDimensions)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.dataExtraDimensions?.forEach {
                try validate($0, name: "dataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "dataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "dataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.dataExtraDimensions, name: "dataExtraDimensions", parent: name, max: 5)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case dataExtraDimensions = "dataExtraDimensions"
            case description = "description"
        }
    }

    public struct UpdateCampaignResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the campaign.
        public let arn: String?
        /// The name of the updated campaign.
        public let name: String?
        /// The state of a campaign. The status can be one of:    CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.     WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the  API operation to approve the campaign.     RUNNING - The campaign is active.     SUSPENDED - The campaign is suspended. To resume the campaign, use the  API operation.
        public let status: CampaignStatus?

        public init(arn: String? = nil, name: String? = nil, status: CampaignStatus? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateDecoderManifestRequest: AWSEncodableShape {
        ///  A brief description of the decoder manifest to update.
        public let description: String?
        ///  The name of the decoder manifest to update.
        public let name: String
        ///  A list of information about the network interfaces to add to the decoder manifest.
        public let networkInterfacesToAdd: [NetworkInterface]?
        ///  A list of network interfaces to remove from the decoder manifest.
        public let networkInterfacesToRemove: [String]?
        ///  A list of information about the network interfaces to update in the decoder manifest.
        public let networkInterfacesToUpdate: [NetworkInterface]?
        ///  A list of information about decoding additional signals to add to the decoder manifest.
        public let signalDecodersToAdd: [SignalDecoder]?
        ///  A list of signal decoders to remove from the decoder manifest.
        public let signalDecodersToRemove: [String]?
        ///  A list of updated information about decoding signals to update in the decoder manifest.
        public let signalDecodersToUpdate: [SignalDecoder]?
        ///  The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is DRAFT, you can edit the decoder manifest.
        public let status: ManifestStatus?

        public init(description: String? = nil, name: String, networkInterfacesToAdd: [NetworkInterface]? = nil, networkInterfacesToRemove: [String]? = nil, networkInterfacesToUpdate: [NetworkInterface]? = nil, signalDecodersToAdd: [SignalDecoder]? = nil, signalDecodersToRemove: [String]? = nil, signalDecodersToUpdate: [SignalDecoder]? = nil, status: ManifestStatus? = nil) {
            self.description = description
            self.name = name
            self.networkInterfacesToAdd = networkInterfacesToAdd
            self.networkInterfacesToRemove = networkInterfacesToRemove
            self.networkInterfacesToUpdate = networkInterfacesToUpdate
            self.signalDecodersToAdd = signalDecodersToAdd
            self.signalDecodersToRemove = signalDecodersToRemove
            self.signalDecodersToUpdate = signalDecodersToUpdate
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.networkInterfacesToAdd, forKey: .networkInterfacesToAdd)
            try container.encodeIfPresent(self.networkInterfacesToRemove, forKey: .networkInterfacesToRemove)
            try container.encodeIfPresent(self.networkInterfacesToUpdate, forKey: .networkInterfacesToUpdate)
            try container.encodeIfPresent(self.signalDecodersToAdd, forKey: .signalDecodersToAdd)
            try container.encodeIfPresent(self.signalDecodersToRemove, forKey: .signalDecodersToRemove)
            try container.encodeIfPresent(self.signalDecodersToUpdate, forKey: .signalDecodersToUpdate)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.networkInterfacesToAdd?.forEach {
                try $0.validate(name: "\(name).networkInterfacesToAdd[]")
            }
            try self.validate(self.networkInterfacesToAdd, name: "networkInterfacesToAdd", parent: name, max: 500)
            try self.validate(self.networkInterfacesToAdd, name: "networkInterfacesToAdd", parent: name, min: 1)
            try self.networkInterfacesToRemove?.forEach {
                try validate($0, name: "networkInterfacesToRemove[]", parent: name, max: 50)
                try validate($0, name: "networkInterfacesToRemove[]", parent: name, min: 1)
            }
            try self.validate(self.networkInterfacesToRemove, name: "networkInterfacesToRemove", parent: name, max: 500)
            try self.validate(self.networkInterfacesToRemove, name: "networkInterfacesToRemove", parent: name, min: 1)
            try self.networkInterfacesToUpdate?.forEach {
                try $0.validate(name: "\(name).networkInterfacesToUpdate[]")
            }
            try self.validate(self.networkInterfacesToUpdate, name: "networkInterfacesToUpdate", parent: name, max: 500)
            try self.validate(self.networkInterfacesToUpdate, name: "networkInterfacesToUpdate", parent: name, min: 1)
            try self.signalDecodersToAdd?.forEach {
                try $0.validate(name: "\(name).signalDecodersToAdd[]")
            }
            try self.validate(self.signalDecodersToAdd, name: "signalDecodersToAdd", parent: name, max: 500)
            try self.validate(self.signalDecodersToAdd, name: "signalDecodersToAdd", parent: name, min: 1)
            try self.signalDecodersToRemove?.forEach {
                try validate($0, name: "signalDecodersToRemove[]", parent: name, max: 150)
                try validate($0, name: "signalDecodersToRemove[]", parent: name, min: 1)
            }
            try self.validate(self.signalDecodersToRemove, name: "signalDecodersToRemove", parent: name, max: 500)
            try self.validate(self.signalDecodersToRemove, name: "signalDecodersToRemove", parent: name, min: 1)
            try self.signalDecodersToUpdate?.forEach {
                try $0.validate(name: "\(name).signalDecodersToUpdate[]")
            }
            try self.validate(self.signalDecodersToUpdate, name: "signalDecodersToUpdate", parent: name, max: 500)
            try self.validate(self.signalDecodersToUpdate, name: "signalDecodersToUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case networkInterfacesToAdd = "networkInterfacesToAdd"
            case networkInterfacesToRemove = "networkInterfacesToRemove"
            case networkInterfacesToUpdate = "networkInterfacesToUpdate"
            case signalDecodersToAdd = "signalDecodersToAdd"
            case signalDecodersToRemove = "signalDecodersToRemove"
            case signalDecodersToUpdate = "signalDecodersToUpdate"
            case status = "status"
        }
    }

    public struct UpdateDecoderManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the updated decoder manifest.
        public let arn: String
        ///  The name of the updated decoder manifest.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateFleetRequest: AWSEncodableShape {
        ///  An updated description of the fleet.
        public let description: String?
        ///  The ID of the fleet to update.
        public let fleetId: String

        public init(description: String? = nil, fleetId: String) {
            self.description = description
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateFleetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated fleet.
        public let arn: String?
        /// The ID of the updated fleet.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct UpdateModelManifestRequest: AWSEncodableShape {
        ///  A brief description of the vehicle model.
        public let description: String?
        ///  The name of the vehicle model to update.
        public let name: String
        ///  A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to add to the vehicle model.
        public let nodesToAdd: [String]?
        ///  A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to remove from the vehicle model.
        public let nodesToRemove: [String]?
        ///  The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
        public let status: ManifestStatus?

        public init(description: String? = nil, name: String, nodesToAdd: [String]? = nil, nodesToRemove: [String]? = nil, status: ManifestStatus? = nil) {
            self.description = description
            self.name = name
            self.nodesToAdd = nodesToAdd
            self.nodesToRemove = nodesToRemove
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.nodesToAdd, forKey: .nodesToAdd)
            try container.encodeIfPresent(self.nodesToRemove, forKey: .nodesToRemove)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.nodesToAdd?.forEach {
                try validate($0, name: "nodesToAdd[]", parent: name, max: 150)
                try validate($0, name: "nodesToAdd[]", parent: name, min: 1)
                try validate($0, name: "nodesToAdd[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.nodesToAdd, name: "nodesToAdd", parent: name, max: 500)
            try self.validate(self.nodesToAdd, name: "nodesToAdd", parent: name, min: 1)
            try self.nodesToRemove?.forEach {
                try validate($0, name: "nodesToRemove[]", parent: name, max: 150)
                try validate($0, name: "nodesToRemove[]", parent: name, min: 1)
                try validate($0, name: "nodesToRemove[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, max: 500)
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodesToAdd = "nodesToAdd"
            case nodesToRemove = "nodesToRemove"
            case status = "status"
        }
    }

    public struct UpdateModelManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the updated vehicle model.
        public let arn: String
        ///  The name of the updated vehicle model.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateSignalCatalogRequest: AWSEncodableShape {
        ///  A brief description of the signal catalog to update.
        public let description: String?
        ///  The name of the signal catalog to update.
        public let name: String
        ///  A list of information about nodes to add to the signal catalog.
        public let nodesToAdd: [Node]?
        ///  A list of fullyQualifiedName of nodes to remove from the signal catalog.
        public let nodesToRemove: [String]?
        ///  A list of information about nodes to update in the signal catalog.
        public let nodesToUpdate: [Node]?

        public init(description: String? = nil, name: String, nodesToAdd: [Node]? = nil, nodesToRemove: [String]? = nil, nodesToUpdate: [Node]? = nil) {
            self.description = description
            self.name = name
            self.nodesToAdd = nodesToAdd
            self.nodesToRemove = nodesToRemove
            self.nodesToUpdate = nodesToUpdate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.nodesToAdd, forKey: .nodesToAdd)
            try container.encodeIfPresent(self.nodesToRemove, forKey: .nodesToRemove)
            try container.encodeIfPresent(self.nodesToUpdate, forKey: .nodesToUpdate)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.nodesToAdd?.forEach {
                try $0.validate(name: "\(name).nodesToAdd[]")
            }
            try self.validate(self.nodesToAdd, name: "nodesToAdd", parent: name, max: 500)
            try self.nodesToRemove?.forEach {
                try validate($0, name: "nodesToRemove[]", parent: name, max: 150)
                try validate($0, name: "nodesToRemove[]", parent: name, min: 1)
                try validate($0, name: "nodesToRemove[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, max: 500)
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, min: 1)
            try self.nodesToUpdate?.forEach {
                try $0.validate(name: "\(name).nodesToUpdate[]")
            }
            try self.validate(self.nodesToUpdate, name: "nodesToUpdate", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodesToAdd = "nodesToAdd"
            case nodesToRemove = "nodesToRemove"
            case nodesToUpdate = "nodesToUpdate"
        }
    }

    public struct UpdateSignalCatalogResponse: AWSDecodableShape {
        ///  The ARN of the updated signal catalog.
        public let arn: String
        ///  The name of the updated signal catalog.
        public let name: String

        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateVehicleError: AWSDecodableShape {
        /// The relevant HTTP error code (400+).
        public let code: Int?
        /// A message associated with the error.
        public let message: String?
        /// The ID of the vehicle with the error.
        public let vehicleName: String?

        public init(code: Int? = nil, message: String? = nil, vehicleName: String? = nil) {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case vehicleName = "vehicleName"
        }
    }

    public struct UpdateVehicleRequest: AWSEncodableShape {
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
        public let attributeUpdateMode: UpdateMode?
        /// The ARN of the decoder manifest associated with this vehicle.
        public let decoderManifestArn: String?
        /// The ARN of a vehicle model (model manifest) associated with the vehicle.
        public let modelManifestArn: String?
        /// The unique ID of the vehicle to update.
        public let vehicleName: String

        public init(attributes: [String: String]? = nil, attributeUpdateMode: UpdateMode? = nil, decoderManifestArn: String? = nil, modelManifestArn: String? = nil, vehicleName: String) {
            self.attributes = attributes
            self.attributeUpdateMode = attributeUpdateMode
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encodeIfPresent(self.attributeUpdateMode, forKey: .attributeUpdateMode)
            try container.encodeIfPresent(self.decoderManifestArn, forKey: .decoderManifestArn)
            try container.encodeIfPresent(self.modelManifestArn, forKey: .modelManifestArn)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case attributeUpdateMode = "attributeUpdateMode"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
        }
    }

    public struct UpdateVehicleRequestItem: AWSEncodableShape {
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
        public let attributeUpdateMode: UpdateMode?
        /// The ARN of the signal decoder manifest associated with the vehicle to update.
        public let decoderManifestArn: String?
        /// The ARN of the vehicle model (model manifest) associated with the vehicle to update.
        public let modelManifestArn: String?
        /// The unique ID of the vehicle to update.
        public let vehicleName: String

        public init(attributes: [String: String]? = nil, attributeUpdateMode: UpdateMode? = nil, decoderManifestArn: String? = nil, modelManifestArn: String? = nil, vehicleName: String) {
            self.attributes = attributes
            self.attributeUpdateMode = attributeUpdateMode
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case attributeUpdateMode = "attributeUpdateMode"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct UpdateVehicleResponse: AWSDecodableShape {
        /// The ARN of the updated vehicle.
        public let arn: String?
        /// The ID of the updated vehicle.
        public let vehicleName: String?

        public init(arn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case vehicleName = "vehicleName"
        }
    }

    public struct UpdateVehicleResponseItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated vehicle.
        public let arn: String?
        /// The unique ID of the updated vehicle.
        public let vehicleName: String?

        public init(arn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case vehicleName = "vehicleName"
        }
    }

    public struct VehicleMiddleware: AWSEncodableShape & AWSDecodableShape {
        /// The name of the vehicle middleware.
        public let name: String
        /// The protocol name of the vehicle middleware.
        public let protocolName: VehicleMiddlewareProtocol

        public init(name: String, protocolName: VehicleMiddlewareProtocol) {
            self.name = name
            self.protocolName = protocolName
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case protocolName = "protocolName"
        }
    }

    public struct VehicleStatus: AWSDecodableShape {
        /// The name of a campaign.
        public let campaignName: String?
        /// The state of a vehicle, which can be one of the following:    CREATED - Amazon Web Services IoT FleetWise sucessfully created the vehicle.     READY - The vehicle is ready to receive a campaign deployment.     HEALTHY - A campaign deployment was delivered to the vehicle.     SUSPENDED - A campaign associated with the vehicle was suspended and data collection was paused.     DELETING - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle.
        public let status: VehicleState?
        /// The unique ID of the vehicle.
        public let vehicleName: String?

        public init(campaignName: String? = nil, status: VehicleState? = nil, vehicleName: String? = nil) {
            self.campaignName = campaignName
            self.status = status
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case campaignName = "campaignName"
            case status = "status"
            case vehicleName = "vehicleName"
        }
    }

    public struct VehicleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the vehicle.
        public let arn: String
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// The ARN of a decoder manifest associated with the vehicle.
        public let decoderManifestArn: String
        /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The ARN of a vehicle model (model manifest) associated with the vehicle.
        public let modelManifestArn: String
        /// The unique ID of the vehicle.
        public let vehicleName: String

        public init(arn: String, attributes: [String: String]? = nil, creationTime: Date, decoderManifestArn: String, lastModificationTime: Date, modelManifestArn: String, vehicleName: String) {
            self.arn = arn
            self.attributes = attributes
            self.creationTime = creationTime
            self.decoderManifestArn = decoderManifestArn
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case attributes = "attributes"
            case creationTime = "creationTime"
            case decoderManifestArn = "decoderManifestArn"
            case lastModificationTime = "lastModificationTime"
            case modelManifestArn = "modelManifestArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct FormattedVss: AWSEncodableShape {
        /// Provides the VSS in JSON format.
        public let vssJson: String?

        public init(vssJson: String? = nil) {
            self.vssJson = vssJson
        }

        private enum CodingKeys: String, CodingKey {
            case vssJson = "vssJson"
        }
    }

    public struct NetworkFileDefinition: AWSEncodableShape {
        /// Information, including CAN DBC files, about the configurations used to create a decoder manifest.
        public let canDbc: CanDbcDefinition?

        public init(canDbc: CanDbcDefinition? = nil) {
            self.canDbc = canDbc
        }

        public func validate(name: String) throws {
            try self.canDbc?.validate(name: "\(name).canDbc")
        }

        private enum CodingKeys: String, CodingKey {
            case canDbc = "canDbc"
        }
    }

    public struct PrimitiveMessageDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Information about a PrimitiveMessage using a ROS 2 compliant primitive type message of the complex data structure.
        public let ros2PrimitiveMessageDefinition: ROS2PrimitiveMessageDefinition?

        public init(ros2PrimitiveMessageDefinition: ROS2PrimitiveMessageDefinition? = nil) {
            self.ros2PrimitiveMessageDefinition = ros2PrimitiveMessageDefinition
        }

        public func validate(name: String) throws {
            try self.ros2PrimitiveMessageDefinition?.validate(name: "\(name).ros2PrimitiveMessageDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case ros2PrimitiveMessageDefinition = "ros2PrimitiveMessageDefinition"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTFleetWise
public struct IoTFleetWiseErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case decoderManifestValidationException = "DecoderManifestValidationException"
        case internalServerException = "InternalServerException"
        case invalidNodeException = "InvalidNodeException"
        case invalidSignalsException = "InvalidSignalsException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTFleetWise
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient permission to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request couldn't be completed because it contains signal decoders with one or more validation errors.
    public static var decoderManifestValidationException: Self { .init(.decoderManifestValidationException) }
    /// The request couldn't be completed because the server temporarily failed.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified node type doesn't match the expected node type for a node. You can specify the node type as branch, sensor, actuator, or attribute.
    public static var invalidNodeException: Self { .init(.invalidNodeException) }
    /// The request couldn't be completed because it contains signals that aren't valid.
    public static var invalidSignalsException: Self { .init(.invalidSignalsException) }
    /// A service quota was exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The resource wasn't found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request couldn't be completed due to throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension IoTFleetWiseErrorType: Equatable {
    public static func == (lhs: IoTFleetWiseErrorType, rhs: IoTFleetWiseErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTFleetWiseErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
