//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTFleetWise {
    // MARK: Enums

    public enum CampaignStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creating = "CREATING"
        case running = "RUNNING"
        case suspended = "SUSPENDED"
        case waitingForApproval = "WAITING_FOR_APPROVAL"
        public var description: String { return self.rawValue }
    }

    public enum Compression: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "OFF"
        case snappy = "SNAPPY"
        public var description: String { return self.rawValue }
    }

    public enum DataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum DefaultForUnmappedSignalsType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customDecoding = "CUSTOM_DECODING"
        public var description: String { return self.rawValue }
    }

    public enum DiagnosticsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "OFF"
        case sendActiveDtcs = "SEND_ACTIVE_DTCS"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failure = "FAILURE"
        case pending = "PENDING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fleetwiseDefaultEncryption = "FLEETWISE_DEFAULT_ENCRYPTION"
        case kmsBasedEncryption = "KMS_BASED_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum ListResponseScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case metadataOnly = "METADATA_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum LogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum ManifestStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case draft = "DRAFT"
        case invalid = "INVALID"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum NetworkInterfaceFailureReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canNetworkInterfaceInfoIsNull = "CAN_NETWORK_INTERFACE_INFO_IS_NULL"
        case conflictingNetworkInterface = "CONFLICTING_NETWORK_INTERFACE"
        case customDecodingSignalNetworkInterfaceInfoIsNull = "CUSTOM_DECODING_SIGNAL_NETWORK_INTERFACE_INFO_IS_NULL"
        case duplicateInterface = "DUPLICATE_NETWORK_INTERFACE"
        case networkInterfaceToAddAlreadyExists = "NETWORK_INTERFACE_TO_ADD_ALREADY_EXISTS"
        case networkInterfaceToRemoveAssociatedWithSignals = "NETWORK_INTERFACE_TO_REMOVE_ASSOCIATED_WITH_SIGNALS"
        case obdNetworkInterfaceInfoIsNull = "OBD_NETWORK_INTERFACE_INFO_IS_NULL"
        case vehicleMiddlewareNetworkInterfaceInfoIsNull = "VEHICLE_MIDDLEWARE_NETWORK_INTERFACE_INFO_IS_NULL"
        public var description: String { return self.rawValue }
    }

    public enum NetworkInterfaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canInterface = "CAN_INTERFACE"
        case customDecodingInterface = "CUSTOM_DECODING_INTERFACE"
        case obdInterface = "OBD_INTERFACE"
        case vehicleMiddleware = "VEHICLE_MIDDLEWARE"
        public var description: String { return self.rawValue }
    }

    public enum NodeDataEncoding: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case binary = "BINARY"
        case typed = "TYPED"
        public var description: String { return self.rawValue }
    }

    public enum NodeDataType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `struct` = "STRUCT"
        case boolean = "BOOLEAN"
        case booleanArray = "BOOLEAN_ARRAY"
        case double = "DOUBLE"
        case doubleArray = "DOUBLE_ARRAY"
        case float = "FLOAT"
        case floatArray = "FLOAT_ARRAY"
        case int16 = "INT16"
        case int16Array = "INT16_ARRAY"
        case int32 = "INT32"
        case int32Array = "INT32_ARRAY"
        case int64 = "INT64"
        case int64Array = "INT64_ARRAY"
        case int8 = "INT8"
        case int8Array = "INT8_ARRAY"
        case string = "STRING"
        case stringArray = "STRING_ARRAY"
        case structArray = "STRUCT_ARRAY"
        case uint16 = "UINT16"
        case uint16Array = "UINT16_ARRAY"
        case uint32 = "UINT32"
        case uint32Array = "UINT32_ARRAY"
        case uint64 = "UINT64"
        case uint64Array = "UINT64_ARRAY"
        case uint8 = "UINT8"
        case uint8Array = "UINT8_ARRAY"
        case unixTimestamp = "UNIX_TIMESTAMP"
        case unixTimestampArray = "UNIX_TIMESTAMP_ARRAY"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum ROS2PrimitiveType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bool = "BOOL"
        case byte = "BYTE"
        case char = "CHAR"
        case float32 = "FLOAT32"
        case float64 = "FLOAT64"
        case int16 = "INT16"
        case int32 = "INT32"
        case int64 = "INT64"
        case int8 = "INT8"
        case string = "STRING"
        case uint16 = "UINT16"
        case uint32 = "UINT32"
        case uint64 = "UINT64"
        case uint8 = "UINT8"
        case wstring = "WSTRING"
        public var description: String { return self.rawValue }
    }

    public enum RegistrationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case registrationFailure = "REGISTRATION_FAILURE"
        case registrationPending = "REGISTRATION_PENDING"
        case registrationSuccess = "REGISTRATION_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum SignalDecoderFailureReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canSignalInfoIsNull = "CAN_SIGNAL_INFO_IS_NULL"
        case conflictingSignal = "CONFLICTING_SIGNAL"
        case customDecodingSignalInfoIsNull = "CUSTOM_DECODING_SIGNAL_INFO_IS_NULL"
        case duplicateSignal = "DUPLICATE_SIGNAL"
        case emptyMessageSignal = "EMPTY_MESSAGE_SIGNAL"
        case messageSignalInfoIsNull = "MESSAGE_SIGNAL_INFO_IS_NULL"
        case networkInterfaceTypeIncompatibleWithSignalDecoderType = "NETWORK_INTERFACE_TYPE_INCOMPATIBLE_WITH_SIGNAL_DECODER_TYPE"
        case noDecoderInfoForSignalInModel = "NO_DECODER_INFO_FOR_SIGNAL_IN_MODEL"
        case noSignalInCatalogForDecoderSignal = "NO_SIGNAL_IN_CATALOG_FOR_DECODER_SIGNAL"
        case obdSignalInfoIsNull = "OBD_SIGNAL_INFO_IS_NULL"
        case signalDecoderIncompatibleWithSignalCatalog = "SIGNAL_DECODER_INCOMPATIBLE_WITH_SIGNAL_CATALOG"
        case signalDecoderTypeIncompatibleWithMessageSignalType = "SIGNAL_DECODER_TYPE_INCOMPATIBLE_WITH_MESSAGE_SIGNAL_TYPE"
        case signalNotAssociatedWithNetworkInterface = "SIGNAL_NOT_ASSOCIATED_WITH_NETWORK_INTERFACE"
        case signalNotInModel = "SIGNAL_NOT_IN_MODEL"
        case signalToAddAlreadyExists = "SIGNAL_TO_ADD_ALREADY_EXISTS"
        case structSizeMismatch = "STRUCT_SIZE_MISMATCH"
        public var description: String { return self.rawValue }
    }

    public enum SignalDecoderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canSignal = "CAN_SIGNAL"
        case customDecodingSignal = "CUSTOM_DECODING_SIGNAL"
        case messageSignal = "MESSAGE_SIGNAL"
        case obdSignal = "OBD_SIGNAL"
        public var description: String { return self.rawValue }
    }

    public enum SignalNodeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actuator = "ACTUATOR"
        case attribute = "ATTRIBUTE"
        case branch = "BRANCH"
        case customProperty = "CUSTOM_PROPERTY"
        case customStruct = "CUSTOM_STRUCT"
        case sensor = "SENSOR"
        public var description: String { return self.rawValue }
    }

    public enum SignalValueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case floatingPoint = "FLOATING_POINT"
        case integer = "INTEGER"
        public var description: String { return self.rawValue }
    }

    public enum SpoolingMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case off = "OFF"
        case toDisk = "TO_DISK"
        public var description: String { return self.rawValue }
    }

    public enum StorageCompressionFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gzip = "GZIP"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum StorageMaximumSizeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gb = "GB"
        case mb = "MB"
        case tb = "TB"
        public var description: String { return self.rawValue }
    }

    public enum StorageMinimumTimeToLiveUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        case hours = "HOURS"
        case weeks = "WEEKS"
        public var description: String { return self.rawValue }
    }

    public enum StructuredMessageListType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dynamicBoundedCapacity = "DYNAMIC_BOUNDED_CAPACITY"
        case dynamicUnboundedCapacity = "DYNAMIC_UNBOUNDED_CAPACITY"
        case fixedCapacity = "FIXED_CAPACITY"
        public var description: String { return self.rawValue }
    }

    public enum TimeUnit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hour = "HOUR"
        case millisecond = "MILLISECOND"
        case minute = "MINUTE"
        case second = "SECOND"
        public var description: String { return self.rawValue }
    }

    public enum TriggerMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case always = "ALWAYS"
        case risingEdge = "RISING_EDGE"
        public var description: String { return self.rawValue }
    }

    public enum UpdateCampaignAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approve = "APPROVE"
        case resume = "RESUME"
        case suspend = "SUSPEND"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum UpdateMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case merge = "Merge"
        case overwrite = "Overwrite"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum VehicleAssociationBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createIotThing = "CreateIotThing"
        case validateIotThingExists = "ValidateIotThingExists"
        public var description: String { return self.rawValue }
    }

    public enum VehicleMiddlewareProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ros2 = "ROS_2"
        public var description: String { return self.rawValue }
    }

    public enum VehicleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case created = "CREATED"
        case deleting = "DELETING"
        case healthy = "HEALTHY"
        case ready = "READY"
        case suspended = "SUSPENDED"
        public var description: String { return self.rawValue }
    }

    public enum CollectionScheme: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
        case conditionBasedCollectionScheme(ConditionBasedCollectionScheme)
        /// Information about a collection scheme that uses a time period to decide how often to collect data.
        case timeBasedCollectionScheme(TimeBasedCollectionScheme)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .conditionBasedCollectionScheme:
                let value = try container.decode(ConditionBasedCollectionScheme.self, forKey: .conditionBasedCollectionScheme)
                self = .conditionBasedCollectionScheme(value)
            case .timeBasedCollectionScheme:
                let value = try container.decode(TimeBasedCollectionScheme.self, forKey: .timeBasedCollectionScheme)
                self = .timeBasedCollectionScheme(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .conditionBasedCollectionScheme(let value):
                try container.encode(value, forKey: .conditionBasedCollectionScheme)
            case .timeBasedCollectionScheme(let value):
                try container.encode(value, forKey: .timeBasedCollectionScheme)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .conditionBasedCollectionScheme(let value):
                try value.validate(name: "\(name).conditionBasedCollectionScheme")
            case .timeBasedCollectionScheme(let value):
                try value.validate(name: "\(name).timeBasedCollectionScheme")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditionBasedCollectionScheme = "conditionBasedCollectionScheme"
            case timeBasedCollectionScheme = "timeBasedCollectionScheme"
        }
    }

    public enum DataDestinationConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The MQTT topic to which the Amazon Web Services IoT FleetWise campaign routes data.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
        case mqttTopicConfig(MqttTopicConfig)
        /// The Amazon S3 bucket where the Amazon Web Services IoT FleetWise campaign sends data.
        case s3Config(S3Config)
        /// The Amazon Timestream table where the campaign sends data.
        case timestreamConfig(TimestreamConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .mqttTopicConfig:
                let value = try container.decode(MqttTopicConfig.self, forKey: .mqttTopicConfig)
                self = .mqttTopicConfig(value)
            case .s3Config:
                let value = try container.decode(S3Config.self, forKey: .s3Config)
                self = .s3Config(value)
            case .timestreamConfig:
                let value = try container.decode(TimestreamConfig.self, forKey: .timestreamConfig)
                self = .timestreamConfig(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .mqttTopicConfig(let value):
                try container.encode(value, forKey: .mqttTopicConfig)
            case .s3Config(let value):
                try container.encode(value, forKey: .s3Config)
            case .timestreamConfig(let value):
                try container.encode(value, forKey: .timestreamConfig)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .mqttTopicConfig(let value):
                try value.validate(name: "\(name).mqttTopicConfig")
            case .s3Config(let value):
                try value.validate(name: "\(name).s3Config")
            case .timestreamConfig(let value):
                try value.validate(name: "\(name).timestreamConfig")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case mqttTopicConfig = "mqttTopicConfig"
            case s3Config = "s3Config"
            case timestreamConfig = "timestreamConfig"
        }
    }

    public enum Node: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Information about a node specified as an actuator.  An actuator is a digital representation of a vehicle device.
        case actuator(Actuator)
        /// Information about a node specified as an attribute.  An attribute represents static information about a vehicle.
        case attribute(Attribute)
        /// Information about a node specified as a branch.  A group of signals that are defined in a hierarchical structure.
        case branch(Branch)
        /// Represents a member of the complex data structure. The datatype of the property can be either primitive or another struct.
        case property(CustomProperty)
        case sensor(Sensor)
        /// Represents a complex or higher-order data structure.
        case `struct`(CustomStruct)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .actuator:
                let value = try container.decode(Actuator.self, forKey: .actuator)
                self = .actuator(value)
            case .attribute:
                let value = try container.decode(Attribute.self, forKey: .attribute)
                self = .attribute(value)
            case .branch:
                let value = try container.decode(Branch.self, forKey: .branch)
                self = .branch(value)
            case .property:
                let value = try container.decode(CustomProperty.self, forKey: .property)
                self = .property(value)
            case .sensor:
                let value = try container.decode(Sensor.self, forKey: .sensor)
                self = .sensor(value)
            case .`struct`:
                let value = try container.decode(CustomStruct.self, forKey: .`struct`)
                self = .`struct`(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .actuator(let value):
                try container.encode(value, forKey: .actuator)
            case .attribute(let value):
                try container.encode(value, forKey: .attribute)
            case .branch(let value):
                try container.encode(value, forKey: .branch)
            case .property(let value):
                try container.encode(value, forKey: .property)
            case .sensor(let value):
                try container.encode(value, forKey: .sensor)
            case .`struct`(let value):
                try container.encode(value, forKey: .`struct`)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .actuator(let value):
                try value.validate(name: "\(name).actuator")
            case .attribute(let value):
                try value.validate(name: "\(name).attribute")
            case .branch(let value):
                try value.validate(name: "\(name).branch")
            case .property(let value):
                try value.validate(name: "\(name).property")
            case .sensor(let value):
                try value.validate(name: "\(name).sensor")
            case .`struct`(let value):
                try value.validate(name: "\(name).`struct`")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actuator = "actuator"
            case attribute = "attribute"
            case branch = "branch"
            case property = "property"
            case sensor = "sensor"
            case `struct` = "struct"
        }
    }

    public enum SignalFetchConfig: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The configuration of a condition-based signal fetch operation.
        case conditionBased(ConditionBasedSignalFetchConfig)
        /// The configuration of a time-based signal fetch operation.
        case timeBased(TimeBasedSignalFetchConfig)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .conditionBased:
                let value = try container.decode(ConditionBasedSignalFetchConfig.self, forKey: .conditionBased)
                self = .conditionBased(value)
            case .timeBased:
                let value = try container.decode(TimeBasedSignalFetchConfig.self, forKey: .timeBased)
                self = .timeBased(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .conditionBased(let value):
                try container.encode(value, forKey: .conditionBased)
            case .timeBased(let value):
                try container.encode(value, forKey: .timeBased)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .conditionBased(let value):
                try value.validate(name: "\(name).conditionBased")
            case .timeBased(let value):
                try value.validate(name: "\(name).timeBased")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case conditionBased = "conditionBased"
            case timeBased = "timeBased"
        }
    }

    public enum StateTemplateUpdateStrategy: AWSEncodableShape & AWSDecodableShape, Sendable {
        case onChange(OnChangeStateTemplateUpdateStrategy)
        case periodic(PeriodicStateTemplateUpdateStrategy)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .onChange:
                let value = try container.decode(OnChangeStateTemplateUpdateStrategy.self, forKey: .onChange)
                self = .onChange(value)
            case .periodic:
                let value = try container.decode(PeriodicStateTemplateUpdateStrategy.self, forKey: .periodic)
                self = .periodic(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .onChange(let value):
                try container.encode(value, forKey: .onChange)
            case .periodic(let value):
                try container.encode(value, forKey: .periodic)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .periodic(let value):
                try value.validate(name: "\(name).periodic")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case onChange = "onChange"
            case periodic = "periodic"
        }
    }

    public indirect enum StructuredMessage: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Represents a primitive type node of the complex data structure.
        case primitiveMessageDefinition(PrimitiveMessageDefinition)
        /// Represents a struct type node of the complex data structure.
        case structuredMessageDefinition([StructuredMessageFieldNameAndDataTypePair])
        /// Represents a list type node of the complex data structure.
        case structuredMessageListDefinition(StructuredMessageListDefinition)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .primitiveMessageDefinition:
                let value = try container.decode(PrimitiveMessageDefinition.self, forKey: .primitiveMessageDefinition)
                self = .primitiveMessageDefinition(value)
            case .structuredMessageDefinition:
                let value = try container.decode([StructuredMessageFieldNameAndDataTypePair].self, forKey: .structuredMessageDefinition)
                self = .structuredMessageDefinition(value)
            case .structuredMessageListDefinition:
                let value = try container.decode(StructuredMessageListDefinition.self, forKey: .structuredMessageListDefinition)
                self = .structuredMessageListDefinition(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .primitiveMessageDefinition(let value):
                try container.encode(value, forKey: .primitiveMessageDefinition)
            case .structuredMessageDefinition(let value):
                try container.encode(value, forKey: .structuredMessageDefinition)
            case .structuredMessageListDefinition(let value):
                try container.encode(value, forKey: .structuredMessageListDefinition)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .primitiveMessageDefinition(let value):
                try value.validate(name: "\(name).primitiveMessageDefinition")
            case .structuredMessageDefinition(let value):
                try value.forEach {
                    try $0.validate(name: "\(name).structuredMessageDefinition[]")
                }
                try self.validate(value, name: "structuredMessageDefinition", parent: name, max: 500)
                try self.validate(value, name: "structuredMessageDefinition", parent: name, min: 1)
            case .structuredMessageListDefinition(let value):
                try value.validate(name: "\(name).structuredMessageListDefinition")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case primitiveMessageDefinition = "primitiveMessageDefinition"
            case structuredMessageDefinition = "structuredMessageDefinition"
            case structuredMessageListDefinition = "structuredMessageListDefinition"
        }
    }

    // MARK: Shapes

    public struct Actuator: AWSEncodableShape & AWSDecodableShape {
        /// A list of possible values an actuator can take.
        public let allowedValues: [String]?
        /// A specified value for the actuator.
        public let assignedValue: String?
        /// A comment in addition to the description.
        public let comment: String?
        /// The specified data type of the actuator.
        public let dataType: NodeDataType
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the actuator.
        public let description: String?
        /// The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be Vehicle.Front.Left.Door.Lock.
        public let fullyQualifiedName: String
        /// The specified possible maximum value of an actuator.
        public let max: Double?
        /// The specified possible minimum value of an actuator.
        public let min: Double?
        /// The fully qualified name of the struct node for the actuator if the data type of the actuator is Struct or StructArray. For example, the struct fully qualified name of an actuator might be Vehicle.Door.LockStruct.
        public let structFullyQualifiedName: String?
        /// The scientific unit for the actuator.
        public let unit: String?

        @inlinable
        public init(allowedValues: [String]? = nil, comment: String? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, structFullyQualifiedName: String? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = nil
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }

        @available(*, deprecated, message: "Members assignedValue have been deprecated")
        @inlinable
        public init(allowedValues: [String]? = nil, assignedValue: String? = nil, comment: String? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, structFullyQualifiedName: String? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, max: 150)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, min: 1)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case assignedValue = "assignedValue"
            case comment = "comment"
            case dataType = "dataType"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case max = "max"
            case min = "min"
            case structFullyQualifiedName = "structFullyQualifiedName"
            case unit = "unit"
        }
    }

    public struct AssociateVehicleFleetRequest: AWSEncodableShape {
        ///  The ID of a fleet.
        public let fleetId: String
        ///  The unique ID of the vehicle to associate with the fleet.
        public let vehicleName: String

        @inlinable
        public init(fleetId: String, vehicleName: String) {
            self.fleetId = fleetId
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.fleetId, forKey: .fleetId)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fleetId = "fleetId"
        }
    }

    public struct AssociateVehicleFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Attribute: AWSEncodableShape & AWSDecodableShape {
        /// A list of possible values an attribute can be assigned.
        public let allowedValues: [String]?
        /// A specified value for the attribute.
        public let assignedValue: String?
        /// A comment in addition to the description.
        public let comment: String?
        /// The specified data type of the attribute.
        public let dataType: NodeDataType
        /// The default value of the attribute.
        public let defaultValue: String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the attribute.
        public let description: String?
        /// The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be Vehicle.Body.Engine.Type.
        public let fullyQualifiedName: String
        /// The specified possible maximum value of the attribute.
        public let max: Double?
        /// The specified possible minimum value of the attribute.
        public let min: Double?
        /// The scientific unit for the attribute.
        public let unit: String?

        @inlinable
        public init(allowedValues: [String]? = nil, comment: String? = nil, dataType: NodeDataType, defaultValue: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = nil
            self.comment = comment
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }

        @available(*, deprecated, message: "Members assignedValue have been deprecated")
        @inlinable
        public init(allowedValues: [String]? = nil, assignedValue: String? = nil, comment: String? = nil, dataType: NodeDataType, defaultValue: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case assignedValue = "assignedValue"
            case comment = "comment"
            case dataType = "dataType"
            case defaultValue = "defaultValue"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case max = "max"
            case min = "min"
            case unit = "unit"
        }
    }

    public struct BatchCreateVehicleRequest: AWSEncodableShape {
        ///  A list of information about each vehicle to create. For more information, see the API data type.
        public let vehicles: [CreateVehicleRequestItem]

        @inlinable
        public init(vehicles: [CreateVehicleRequestItem]) {
            self.vehicles = vehicles
        }

        public func validate(name: String) throws {
            try self.vehicles.forEach {
                try $0.validate(name: "\(name).vehicles[]")
            }
            try self.validate(self.vehicles, name: "vehicles", parent: name, max: 10)
            try self.validate(self.vehicles, name: "vehicles", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vehicles = "vehicles"
        }
    }

    public struct BatchCreateVehicleResponse: AWSDecodableShape {
        /// A list of information about creation errors, or an empty list if there aren't any errors.
        public let errors: [CreateVehicleError]?
        ///  A list of information about a batch of created vehicles. For more information, see the  API data type.
        public let vehicles: [CreateVehicleResponseItem]?

        @inlinable
        public init(errors: [CreateVehicleError]? = nil, vehicles: [CreateVehicleResponseItem]? = nil) {
            self.errors = errors
            self.vehicles = vehicles
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case vehicles = "vehicles"
        }
    }

    public struct BatchUpdateVehicleRequest: AWSEncodableShape {
        ///  A list of information about the vehicles to update. For more information, see the API data type.
        public let vehicles: [UpdateVehicleRequestItem]

        @inlinable
        public init(vehicles: [UpdateVehicleRequestItem]) {
            self.vehicles = vehicles
        }

        public func validate(name: String) throws {
            try self.vehicles.forEach {
                try $0.validate(name: "\(name).vehicles[]")
            }
            try self.validate(self.vehicles, name: "vehicles", parent: name, max: 10)
            try self.validate(self.vehicles, name: "vehicles", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vehicles = "vehicles"
        }
    }

    public struct BatchUpdateVehicleResponse: AWSDecodableShape {
        /// A list of information about errors returned while updating a batch of vehicles, or, if there aren't any errors, an empty list.
        public let errors: [UpdateVehicleError]?
        ///  A list of information about the batch of updated vehicles.   This list contains only unique IDs for the vehicles that were updated.
        public let vehicles: [UpdateVehicleResponseItem]?

        @inlinable
        public init(errors: [UpdateVehicleError]? = nil, vehicles: [UpdateVehicleResponseItem]? = nil) {
            self.errors = errors
            self.vehicles = vehicles
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case vehicles = "vehicles"
        }
    }

    public struct Branch: AWSEncodableShape & AWSDecodableShape {
        /// A comment in addition to the description.
        public let comment: String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the branch.
        public let description: String?
        /// The fully qualified name of the branch. For example, the fully qualified name of a branch might be Vehicle.Body.Engine.
        public let fullyQualifiedName: String

        @inlinable
        public init(comment: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String) {
            self.comment = comment
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
        }
    }

    public struct CampaignSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a campaign.
        public let arn: String?
        /// The time the campaign was created.
        public let creationTime: Date
        /// The description of the campaign.
        public let description: String?
        /// The last time the campaign was modified.
        public let lastModificationTime: Date
        /// The name of a campaign.
        public let name: String?
        /// The ARN of the signal catalog associated with the campaign.
        public let signalCatalogArn: String?
        /// The state of a campaign. The status can be one of the following:    CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.    WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the  API operation to approve the campaign.     RUNNING - The campaign is active.     SUSPENDED - The campaign is suspended. To resume the campaign, use the  API operation.
        public let status: CampaignStatus?
        /// The ARN of a vehicle or fleet to which the campaign is deployed.
        public let targetArn: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String? = nil, signalCatalogArn: String? = nil, status: CampaignStatus? = nil, targetArn: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
            case status = "status"
            case targetArn = "targetArn"
        }
    }

    public struct CanDbcDefinition: AWSEncodableShape {
        /// A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list. The DBC file can be a maximum size of 200 MB.
        public let canDbcFiles: [AWSBase64Data]
        /// Contains information about a network interface.
        public let networkInterface: String
        /// Pairs every signal specified in your vehicle model with a signal decoder.
        public let signalsMap: [String: String]?

        @inlinable
        public init(canDbcFiles: [AWSBase64Data], networkInterface: String, signalsMap: [String: String]? = nil) {
            self.canDbcFiles = canDbcFiles
            self.networkInterface = networkInterface
            self.signalsMap = signalsMap
        }

        public func validate(name: String) throws {
            try self.canDbcFiles.forEach {
                try validate($0, name: "canDbcFiles[]", parent: name, max: 200000000)
            }
            try self.validate(self.canDbcFiles, name: "canDbcFiles", parent: name, max: 5)
            try self.validate(self.canDbcFiles, name: "canDbcFiles", parent: name, min: 1)
            try self.validate(self.networkInterface, name: "networkInterface", parent: name, max: 50)
            try self.validate(self.networkInterface, name: "networkInterface", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case canDbcFiles = "canDbcFiles"
            case networkInterface = "networkInterface"
            case signalsMap = "signalsMap"
        }
    }

    public struct CanInterface: AWSEncodableShape & AWSDecodableShape {
        /// The unique name of the interface.
        public let name: String
        /// The name of the communication protocol for the interface.
        public let protocolName: String?
        /// The version of the communication protocol for the interface.
        public let protocolVersion: String?

        @inlinable
        public init(name: String, protocolName: String? = nil, protocolVersion: String? = nil) {
            self.name = name
            self.protocolName = protocolName
            self.protocolVersion = protocolVersion
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.protocolName, name: "protocolName", parent: name, max: 50)
            try self.validate(self.protocolName, name: "protocolName", parent: name, min: 1)
            try self.validate(self.protocolVersion, name: "protocolVersion", parent: name, max: 50)
            try self.validate(self.protocolVersion, name: "protocolVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case protocolName = "protocolName"
            case protocolVersion = "protocolVersion"
        }
    }

    public struct CanSignal: AWSEncodableShape & AWSDecodableShape {
        /// A multiplier used to decode the CAN message.
        public let factor: Double
        /// Whether the byte ordering of a CAN message is big-endian.
        public let isBigEndian: Bool
        /// Determines whether the message is signed (true) or not (false). If it's signed, the message can represent both positive and negative numbers. The isSigned parameter only applies to the INTEGER raw signal type, and it doesn't affect the FLOATING_POINT raw signal type.
        public let isSigned: Bool
        /// How many bytes of data are in the message.
        public let length: Int
        /// The ID of the message.
        public let messageId: Int
        /// The name of the signal.
        public let name: String?
        /// The offset used to calculate the signal value. Combined with factor, the calculation is value = raw_value * factor + offset.
        public let offset: Double
        /// The value type of the signal. The default value is INTEGER.
        public let signalValueType: SignalValueType?
        /// Indicates the beginning of the CAN signal. This should always be the least significant bit (LSB). This value might be different from the value in a DBC file. For little endian signals, startBit is the same value as in the DBC file. For big endian signals in a DBC file, the start bit is the most significant bit (MSB). You will have to calculate the LSB instead and pass it as the startBit.
        public let startBit: Int

        @inlinable
        public init(factor: Double, isBigEndian: Bool, isSigned: Bool, length: Int, messageId: Int, name: String? = nil, offset: Double, signalValueType: SignalValueType? = nil, startBit: Int) {
            self.factor = factor
            self.isBigEndian = isBigEndian
            self.isSigned = isSigned
            self.length = length
            self.messageId = messageId
            self.name = name
            self.offset = offset
            self.signalValueType = signalValueType
            self.startBit = startBit
        }

        public func validate(name: String) throws {
            try self.validate(self.length, name: "length", parent: name, min: 0)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.startBit, name: "startBit", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case factor = "factor"
            case isBigEndian = "isBigEndian"
            case isSigned = "isSigned"
            case length = "length"
            case messageId = "messageId"
            case name = "name"
            case offset = "offset"
            case signalValueType = "signalValueType"
            case startBit = "startBit"
        }
    }

    public struct CloudWatchLogDeliveryOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon CloudWatch Logs group the operation sends data to.
        public let logGroupName: String?
        /// The type of log to send data to Amazon CloudWatch Logs.
        public let logType: LogType

        @inlinable
        public init(logGroupName: String? = nil, logType: LogType) {
            self.logGroupName = logGroupName
            self.logType = logType
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, max: 512)
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, min: 1)
            try self.validate(self.logGroupName, name: "logGroupName", parent: name, pattern: "^[\\.\\-_\\/#A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "logGroupName"
            case logType = "logType"
        }
    }

    public struct ConditionBasedCollectionScheme: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the version of the conditional expression language.
        public let conditionLanguageVersion: Int?
        /// The logical expression used to recognize what data to collect. For example, $variable.`Vehicle.OutsideAirTemperature` &gt;= 105.0.
        public let expression: String
        /// The minimum duration of time between two triggering events to collect data, in milliseconds.  If a signal changes often, you might want to collect data at a slower rate.
        public let minimumTriggerIntervalMs: Int64?
        /// Whether to collect data for all triggering events (ALWAYS). Specify (RISING_EDGE), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed =&gt; deployed.
        public let triggerMode: TriggerMode?

        @inlinable
        public init(conditionLanguageVersion: Int? = nil, expression: String, minimumTriggerIntervalMs: Int64? = nil, triggerMode: TriggerMode? = nil) {
            self.conditionLanguageVersion = conditionLanguageVersion
            self.expression = expression
            self.minimumTriggerIntervalMs = minimumTriggerIntervalMs
            self.triggerMode = triggerMode
        }

        public func validate(name: String) throws {
            try self.validate(self.conditionLanguageVersion, name: "conditionLanguageVersion", parent: name, max: 1)
            try self.validate(self.conditionLanguageVersion, name: "conditionLanguageVersion", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
            try self.validate(self.minimumTriggerIntervalMs, name: "minimumTriggerIntervalMs", parent: name, max: 4294967295)
            try self.validate(self.minimumTriggerIntervalMs, name: "minimumTriggerIntervalMs", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionLanguageVersion = "conditionLanguageVersion"
            case expression = "expression"
            case minimumTriggerIntervalMs = "minimumTriggerIntervalMs"
            case triggerMode = "triggerMode"
        }
    }

    public struct ConditionBasedSignalFetchConfig: AWSEncodableShape & AWSDecodableShape {
        /// The condition that must be satisfied to trigger a signal fetch.
        public let conditionExpression: String
        /// Indicates the mode in which the signal fetch is triggered.
        public let triggerMode: TriggerMode

        @inlinable
        public init(conditionExpression: String, triggerMode: TriggerMode) {
            self.conditionExpression = conditionExpression
            self.triggerMode = triggerMode
        }

        public func validate(name: String) throws {
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, max: 400)
            try self.validate(self.conditionExpression, name: "conditionExpression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionExpression = "conditionExpression"
            case triggerMode = "triggerMode"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The resource on which there are conflicting operations.
        public let resource: String
        /// The type of resource on which there are conflicting operations..
        public let resourceType: String

        @inlinable
        public init(message: String, resource: String, resourceType: String) {
            self.message = message
            self.resource = resource
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resource = "resource"
            case resourceType = "resourceType"
        }
    }

    public struct CreateCampaignRequest: AWSEncodableShape {
        ///  The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.
        public let collectionScheme: CollectionScheme
        /// Determines whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use OFF. If it's not specified, SNAPPY is used.  Default: SNAPPY
        public let compression: Compression?
        /// The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream. MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle  data, such as data lakes, centralized data storage, data processing pipelines, and analytics.  Amazon Web Services IoT FleetWise supports at-least-once file delivery to S3. Your vehicle data is stored on multiple  Amazon Web Services IoT FleetWise servers for redundancy and high availability. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
        public let dataDestinationConfigs: [DataDestinationConfig]?
        /// A list of vehicle attributes to associate with a campaign.  Enrich the data with specified vehicle attributes. For example, add make and model to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against make and model. Default: An empty array
        public let dataExtraDimensions: [String]?
        /// The data partitions associated with the signals collected from the vehicle.
        public let dataPartitions: [DataPartition]?
        /// An optional description of the campaign to help identify its purpose.
        public let description: String?
        /// Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use SEND_ACTIVE_DTCS. If it's not specified, OFF is used. Default: OFF
        public let diagnosticsMode: DiagnosticsMode?
        /// The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data isn't collected after the campaign expires.  Default: 253402214400 (December 31, 9999, 00:00:00 UTC)
        public let expiryTime: Date?
        ///  The name of the campaign to create.
        public let name: String
        /// How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, 0 is used. Default: 0
        public let postTriggerCollectionDuration: Int64?
        /// A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, 0 is used.  Default: 0
        public let priority: Int?
        /// The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign.
        public let signalCatalogArn: String
        /// A list of information about signals to collect.   If you upload a signal as a condition in a data partition for a campaign, then those same signals must be included in signalsToCollect.
        public let signalsToCollect: [SignalInformation]?
        /// A list of information about signals to fetch.
        public let signalsToFetch: [SignalFetchInformation]?
        /// Determines whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use TO_DISK. If it's not specified, OFF is used. Default: OFF
        public let spoolingMode: SpoolingMode?
        /// The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, 0 is used. Default: 0
        public let startTime: Date?
        /// Metadata that can be used to manage the campaign.
        public let tags: [Tag]?
        ///  The ARN of the vehicle or fleet to deploy a campaign to.
        public let targetArn: String

        @inlinable
        public init(collectionScheme: CollectionScheme, compression: Compression? = nil, dataDestinationConfigs: [DataDestinationConfig]? = nil, dataExtraDimensions: [String]? = nil, dataPartitions: [DataPartition]? = nil, description: String? = nil, diagnosticsMode: DiagnosticsMode? = nil, expiryTime: Date? = nil, name: String, postTriggerCollectionDuration: Int64? = nil, signalCatalogArn: String, signalsToCollect: [SignalInformation]? = nil, signalsToFetch: [SignalFetchInformation]? = nil, spoolingMode: SpoolingMode? = nil, startTime: Date? = nil, tags: [Tag]? = nil, targetArn: String) {
            self.collectionScheme = collectionScheme
            self.compression = compression
            self.dataDestinationConfigs = dataDestinationConfigs
            self.dataExtraDimensions = dataExtraDimensions
            self.dataPartitions = dataPartitions
            self.description = description
            self.diagnosticsMode = diagnosticsMode
            self.expiryTime = expiryTime
            self.name = name
            self.postTriggerCollectionDuration = postTriggerCollectionDuration
            self.priority = nil
            self.signalCatalogArn = signalCatalogArn
            self.signalsToCollect = signalsToCollect
            self.signalsToFetch = signalsToFetch
            self.spoolingMode = spoolingMode
            self.startTime = startTime
            self.tags = tags
            self.targetArn = targetArn
        }

        @available(*, deprecated, message: "Members priority have been deprecated")
        @inlinable
        public init(collectionScheme: CollectionScheme, compression: Compression? = nil, dataDestinationConfigs: [DataDestinationConfig]? = nil, dataExtraDimensions: [String]? = nil, dataPartitions: [DataPartition]? = nil, description: String? = nil, diagnosticsMode: DiagnosticsMode? = nil, expiryTime: Date? = nil, name: String, postTriggerCollectionDuration: Int64? = nil, priority: Int? = nil, signalCatalogArn: String, signalsToCollect: [SignalInformation]? = nil, signalsToFetch: [SignalFetchInformation]? = nil, spoolingMode: SpoolingMode? = nil, startTime: Date? = nil, tags: [Tag]? = nil, targetArn: String) {
            self.collectionScheme = collectionScheme
            self.compression = compression
            self.dataDestinationConfigs = dataDestinationConfigs
            self.dataExtraDimensions = dataExtraDimensions
            self.dataPartitions = dataPartitions
            self.description = description
            self.diagnosticsMode = diagnosticsMode
            self.expiryTime = expiryTime
            self.name = name
            self.postTriggerCollectionDuration = postTriggerCollectionDuration
            self.priority = priority
            self.signalCatalogArn = signalCatalogArn
            self.signalsToCollect = signalsToCollect
            self.signalsToFetch = signalsToFetch
            self.spoolingMode = spoolingMode
            self.startTime = startTime
            self.tags = tags
            self.targetArn = targetArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.collectionScheme, forKey: .collectionScheme)
            try container.encodeIfPresent(self.compression, forKey: .compression)
            try container.encodeIfPresent(self.dataDestinationConfigs, forKey: .dataDestinationConfigs)
            try container.encodeIfPresent(self.dataExtraDimensions, forKey: .dataExtraDimensions)
            try container.encodeIfPresent(self.dataPartitions, forKey: .dataPartitions)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.diagnosticsMode, forKey: .diagnosticsMode)
            try container.encodeIfPresent(self.expiryTime, forKey: .expiryTime)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.postTriggerCollectionDuration, forKey: .postTriggerCollectionDuration)
            try container.encodeIfPresent(self.priority, forKey: .priority)
            try container.encode(self.signalCatalogArn, forKey: .signalCatalogArn)
            try container.encodeIfPresent(self.signalsToCollect, forKey: .signalsToCollect)
            try container.encodeIfPresent(self.signalsToFetch, forKey: .signalsToFetch)
            try container.encodeIfPresent(self.spoolingMode, forKey: .spoolingMode)
            try container.encodeIfPresent(self.startTime, forKey: .startTime)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.targetArn, forKey: .targetArn)
        }

        public func validate(name: String) throws {
            try self.collectionScheme.validate(name: "\(name).collectionScheme")
            try self.dataDestinationConfigs?.forEach {
                try $0.validate(name: "\(name).dataDestinationConfigs[]")
            }
            try self.validate(self.dataDestinationConfigs, name: "dataDestinationConfigs", parent: name, max: 3)
            try self.validate(self.dataDestinationConfigs, name: "dataDestinationConfigs", parent: name, min: 1)
            try self.dataExtraDimensions?.forEach {
                try validate($0, name: "dataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "dataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "dataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.dataExtraDimensions, name: "dataExtraDimensions", parent: name, max: 5)
            try self.dataPartitions?.forEach {
                try $0.validate(name: "\(name).dataPartitions[]")
            }
            try self.validate(self.dataPartitions, name: "dataPartitions", parent: name, max: 20)
            try self.validate(self.dataPartitions, name: "dataPartitions", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.postTriggerCollectionDuration, name: "postTriggerCollectionDuration", parent: name, max: 4294967295)
            try self.validate(self.postTriggerCollectionDuration, name: "postTriggerCollectionDuration", parent: name, min: 0)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.signalsToCollect?.forEach {
                try $0.validate(name: "\(name).signalsToCollect[]")
            }
            try self.validate(self.signalsToCollect, name: "signalsToCollect", parent: name, max: 1000)
            try self.signalsToFetch?.forEach {
                try $0.validate(name: "\(name).signalsToFetch[]")
            }
            try self.validate(self.signalsToFetch, name: "signalsToFetch", parent: name, max: 2)
            try self.validate(self.signalsToFetch, name: "signalsToFetch", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case collectionScheme = "collectionScheme"
            case compression = "compression"
            case dataDestinationConfigs = "dataDestinationConfigs"
            case dataExtraDimensions = "dataExtraDimensions"
            case dataPartitions = "dataPartitions"
            case description = "description"
            case diagnosticsMode = "diagnosticsMode"
            case expiryTime = "expiryTime"
            case postTriggerCollectionDuration = "postTriggerCollectionDuration"
            case priority = "priority"
            case signalCatalogArn = "signalCatalogArn"
            case signalsToCollect = "signalsToCollect"
            case signalsToFetch = "signalsToFetch"
            case spoolingMode = "spoolingMode"
            case startTime = "startTime"
            case tags = "tags"
            case targetArn = "targetArn"
        }
    }

    public struct CreateCampaignResponse: AWSDecodableShape {
        ///  The ARN of the created campaign.
        public let arn: String?
        /// The name of the created campaign.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateDecoderManifestRequest: AWSEncodableShape {
        /// Use default decoders for all unmapped signals in the model. You don't need to provide any detailed decoding information.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
        public let defaultForUnmappedSignals: DefaultForUnmappedSignalsType?
        /// A brief description of the decoder manifest.
        public let description: String?
        ///  The Amazon Resource Name (ARN) of the vehicle model (model manifest).
        public let modelManifestArn: String
        ///  The unique name of the decoder manifest to create.
        public let name: String
        ///  A list of information about available network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        ///  A list of information about signal decoders.
        public let signalDecoders: [SignalDecoder]?
        /// Metadata that can be used to manage the decoder manifest.
        public let tags: [Tag]?

        @inlinable
        public init(defaultForUnmappedSignals: DefaultForUnmappedSignalsType? = nil, description: String? = nil, modelManifestArn: String, name: String, networkInterfaces: [NetworkInterface]? = nil, signalDecoders: [SignalDecoder]? = nil, tags: [Tag]? = nil) {
            self.defaultForUnmappedSignals = defaultForUnmappedSignals
            self.description = description
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.networkInterfaces = networkInterfaces
            self.signalDecoders = signalDecoders
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.defaultForUnmappedSignals, forKey: .defaultForUnmappedSignals)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.modelManifestArn, forKey: .modelManifestArn)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.networkInterfaces, forKey: .networkInterfaces)
            try container.encodeIfPresent(self.signalDecoders, forKey: .signalDecoders)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.networkInterfaces?.forEach {
                try $0.validate(name: "\(name).networkInterfaces[]")
            }
            try self.validate(self.networkInterfaces, name: "networkInterfaces", parent: name, max: 500)
            try self.validate(self.networkInterfaces, name: "networkInterfaces", parent: name, min: 1)
            try self.signalDecoders?.forEach {
                try $0.validate(name: "\(name).signalDecoders[]")
            }
            try self.validate(self.signalDecoders, name: "signalDecoders", parent: name, max: 500)
            try self.validate(self.signalDecoders, name: "signalDecoders", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultForUnmappedSignals = "defaultForUnmappedSignals"
            case description = "description"
            case modelManifestArn = "modelManifestArn"
            case networkInterfaces = "networkInterfaces"
            case signalDecoders = "signalDecoders"
            case tags = "tags"
        }
    }

    public struct CreateDecoderManifestResponse: AWSDecodableShape {
        ///  The ARN of the created decoder manifest.
        public let arn: String
        ///  The name of the created decoder manifest.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateFleetRequest: AWSEncodableShape {
        ///  A brief description of the fleet to create.
        public let description: String?
        ///  The unique ID of the fleet to create.
        public let fleetId: String
        ///  The Amazon Resource Name (ARN) of a signal catalog.
        public let signalCatalogArn: String
        /// Metadata that can be used to manage the fleet.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, fleetId: String, signalCatalogArn: String, tags: [Tag]? = nil) {
            self.description = description
            self.fleetId = fleetId
            self.signalCatalogArn = signalCatalogArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.fleetId, key: "fleetId")
            try container.encode(self.signalCatalogArn, forKey: .signalCatalogArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case signalCatalogArn = "signalCatalogArn"
            case tags = "tags"
        }
    }

    public struct CreateFleetResponse: AWSDecodableShape {
        ///  The ARN of the created fleet.
        public let arn: String
        ///  The ID of the created fleet.
        public let id: String

        @inlinable
        public init(arn: String, id: String) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct CreateModelManifestRequest: AWSEncodableShape {
        ///  A brief description of the vehicle model.
        public let description: String?
        ///  The name of the vehicle model to create.
        public let name: String
        ///  A list of nodes, which are a general abstraction of signals.
        public let nodes: [String]
        ///  The Amazon Resource Name (ARN) of a signal catalog.
        public let signalCatalogArn: String
        /// Metadata that can be used to manage the vehicle model.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, name: String, nodes: [String], signalCatalogArn: String, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.nodes = nodes
            self.signalCatalogArn = signalCatalogArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encode(self.nodes, forKey: .nodes)
            try container.encode(self.signalCatalogArn, forKey: .signalCatalogArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodes = "nodes"
            case signalCatalogArn = "signalCatalogArn"
            case tags = "tags"
        }
    }

    public struct CreateModelManifestResponse: AWSDecodableShape {
        ///  The ARN of the created vehicle model.
        public let arn: String
        ///  The name of the created vehicle model.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateSignalCatalogRequest: AWSEncodableShape {
        /// A brief description of the signal catalog.
        public let description: String?
        ///  The name of the signal catalog to create.
        public let name: String
        ///  A list of information about nodes, which are a general abstraction of signals. For more information, see the  API data type.
        public let nodes: [Node]?
        /// Metadata that can be used to manage the signal catalog.
        public let tags: [Tag]?

        @inlinable
        public init(description: String? = nil, name: String, nodes: [Node]? = nil, tags: [Tag]? = nil) {
            self.description = description
            self.name = name
            self.nodes = nodes
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.nodes, forKey: .nodes)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.nodes?.forEach {
                try $0.validate(name: "\(name).nodes[]")
            }
            try self.validate(self.nodes, name: "nodes", parent: name, max: 500)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodes = "nodes"
            case tags = "tags"
        }
    }

    public struct CreateSignalCatalogResponse: AWSDecodableShape {
        ///  The ARN of the created signal catalog.
        public let arn: String
        ///  The name of the created signal catalog.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct CreateStateTemplateRequest: AWSEncodableShape {
        /// A list of vehicle attributes to associate with the payload published on the state template's  MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will enrich the protobuf encoded payload with those attributes in the extraDimensions field.
        public let dataExtraDimensions: [String]?
        /// A brief description of the state template.
        public let description: String?
        /// A list of vehicle attributes to associate with user properties of the messages published on the state template's MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will include these attributes as User Properties with the MQTT message. Default: An empty array
        public let metadataExtraDimensions: [String]?
        /// The name of the state template.
        public let name: String
        /// The ARN of the signal catalog associated with the state template.
        public let signalCatalogArn: String
        /// A list of signals from which data is collected. The state template properties contain the fully qualified names of the signals.
        public let stateTemplateProperties: [String]
        /// Metadata that can be used to manage the state template.
        public let tags: [Tag]?

        @inlinable
        public init(dataExtraDimensions: [String]? = nil, description: String? = nil, metadataExtraDimensions: [String]? = nil, name: String, signalCatalogArn: String, stateTemplateProperties: [String], tags: [Tag]? = nil) {
            self.dataExtraDimensions = dataExtraDimensions
            self.description = description
            self.metadataExtraDimensions = metadataExtraDimensions
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.stateTemplateProperties = stateTemplateProperties
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.dataExtraDimensions, forKey: .dataExtraDimensions)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.metadataExtraDimensions, forKey: .metadataExtraDimensions)
            request.encodePath(self.name, key: "name")
            try container.encode(self.signalCatalogArn, forKey: .signalCatalogArn)
            try container.encode(self.stateTemplateProperties, forKey: .stateTemplateProperties)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.dataExtraDimensions?.forEach {
                try validate($0, name: "dataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "dataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "dataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.dataExtraDimensions, name: "dataExtraDimensions", parent: name, max: 5)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.metadataExtraDimensions?.forEach {
                try validate($0, name: "metadataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "metadataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "metadataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.metadataExtraDimensions, name: "metadataExtraDimensions", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.stateTemplateProperties.forEach {
                try validate($0, name: "stateTemplateProperties[]", parent: name, max: 150)
                try validate($0, name: "stateTemplateProperties[]", parent: name, min: 1)
                try validate($0, name: "stateTemplateProperties[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.stateTemplateProperties, name: "stateTemplateProperties", parent: name, max: 500)
            try self.validate(self.stateTemplateProperties, name: "stateTemplateProperties", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case dataExtraDimensions = "dataExtraDimensions"
            case description = "description"
            case metadataExtraDimensions = "metadataExtraDimensions"
            case signalCatalogArn = "signalCatalogArn"
            case stateTemplateProperties = "stateTemplateProperties"
            case tags = "tags"
        }
    }

    public struct CreateStateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the state template.
        public let arn: String?
        /// The unique ID of the state template.
        public let id: String?
        /// The name of the state template.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
        }
    }

    public struct CreateVehicleError: AWSDecodableShape {
        /// An HTTP error code.
        public let code: String?
        /// A description of the HTTP error.
        public let message: String?
        /// The ID of the vehicle with the error.
        public let vehicleName: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil, vehicleName: String? = nil) {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case vehicleName = "vehicleName"
        }
    }

    public struct CreateVehicleRequest: AWSEncodableShape {
        ///  An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle.  Default:
        public let associationBehavior: VehicleAssociationBehavior?
        /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"  To use attributes with Campaigns or State Templates, you must include them using the  request parameters dataExtraDimensions and/or metadataExtraDimensions  (for state templates only) when creating your campaign/state template.
        public let attributes: [String: String]?
        ///  The ARN of a decoder manifest.
        public let decoderManifestArn: String
        ///  The Amazon Resource Name ARN of a vehicle model.
        public let modelManifestArn: String
        /// Associate state templates with the vehicle. You can monitor the last known state of the vehicle in near real time.
        public let stateTemplates: [StateTemplateAssociation]?
        /// Metadata that can be used to manage the vehicle.
        public let tags: [Tag]?
        ///  The unique ID of the vehicle to create.
        public let vehicleName: String

        @inlinable
        public init(associationBehavior: VehicleAssociationBehavior? = nil, attributes: [String: String]? = nil, decoderManifestArn: String, modelManifestArn: String, stateTemplates: [StateTemplateAssociation]? = nil, tags: [Tag]? = nil, vehicleName: String) {
            self.associationBehavior = associationBehavior
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.stateTemplates = stateTemplates
            self.tags = tags
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.associationBehavior, forKey: .associationBehavior)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encode(self.decoderManifestArn, forKey: .decoderManifestArn)
            try container.encode(self.modelManifestArn, forKey: .modelManifestArn)
            try container.encodeIfPresent(self.stateTemplates, forKey: .stateTemplates)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.stateTemplates?.forEach {
                try $0.validate(name: "\(name).stateTemplates[]")
            }
            try self.validate(self.stateTemplates, name: "stateTemplates", parent: name, max: 20)
            try self.validate(self.stateTemplates, name: "stateTemplates", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case associationBehavior = "associationBehavior"
            case attributes = "attributes"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
            case stateTemplates = "stateTemplates"
            case tags = "tags"
        }
    }

    public struct CreateVehicleRequestItem: AWSEncodableShape {
        /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.
        public let associationBehavior: VehicleAssociationBehavior?
        /// Static information about a vehicle in a key-value pair. For example: "engine Type" : "v6"
        public let attributes: [String: String]?
        /// The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create.
        public let decoderManifestArn: String
        /// The ARN of the vehicle model (model manifest) to create the vehicle from.
        public let modelManifestArn: String
        /// Associate state templates to track the state of the vehicle. State templates determine which signal updates the vehicle sends to the cloud.
        public let stateTemplates: [StateTemplateAssociation]?
        /// Metadata which can be used to manage the vehicle.
        public let tags: [Tag]?
        /// The unique ID of the vehicle to create.
        public let vehicleName: String

        @inlinable
        public init(associationBehavior: VehicleAssociationBehavior? = nil, attributes: [String: String]? = nil, decoderManifestArn: String, modelManifestArn: String, stateTemplates: [StateTemplateAssociation]? = nil, tags: [Tag]? = nil, vehicleName: String) {
            self.associationBehavior = associationBehavior
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.stateTemplates = stateTemplates
            self.tags = tags
            self.vehicleName = vehicleName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.stateTemplates?.forEach {
                try $0.validate(name: "\(name).stateTemplates[]")
            }
            try self.validate(self.stateTemplates, name: "stateTemplates", parent: name, max: 20)
            try self.validate(self.stateTemplates, name: "stateTemplates", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case associationBehavior = "associationBehavior"
            case attributes = "attributes"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
            case stateTemplates = "stateTemplates"
            case tags = "tags"
            case vehicleName = "vehicleName"
        }
    }

    public struct CreateVehicleResponse: AWSDecodableShape {
        ///  The ARN of the created vehicle.
        public let arn: String?
        ///  The ARN of a created or validated Amazon Web Services IoT thing.
        public let thingArn: String?
        /// The unique ID of the created vehicle.
        public let vehicleName: String?

        @inlinable
        public init(arn: String? = nil, thingArn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.thingArn = thingArn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case thingArn = "thingArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct CreateVehicleResponseItem: AWSDecodableShape {
        /// The ARN of the created vehicle.
        public let arn: String?
        /// The ARN of a created or validated Amazon Web Services IoT thing.
        public let thingArn: String?
        /// The unique ID of the vehicle to create.
        public let vehicleName: String?

        @inlinable
        public init(arn: String? = nil, thingArn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.thingArn = thingArn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case thingArn = "thingArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct CustomDecodingInterface: AWSEncodableShape & AWSDecodableShape {
        /// The name of the interface.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct CustomDecodingSignal: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the signal.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 150)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^(?!.*\\.\\.)[a-zA-Z0-9_\\-#:.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct CustomProperty: AWSEncodableShape & AWSDecodableShape {
        /// A comment in addition to the description.
        public let comment: String?
        /// Indicates whether the property is binary data.
        public let dataEncoding: NodeDataEncoding?
        /// The data type for the custom property.
        public let dataType: NodeDataType
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the custom property.
        public let description: String?
        /// The fully qualified name of the custom property. For example, the fully qualified name of a custom property might be ComplexDataTypes.VehicleDataTypes.SVMCamera.FPS.
        public let fullyQualifiedName: String
        /// The fully qualified name of the struct node for the custom property if the data type of the custom property is Struct or StructArray.
        public let structFullyQualifiedName: String?

        @inlinable
        public init(comment: String? = nil, dataEncoding: NodeDataEncoding? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, structFullyQualifiedName: String? = nil) {
            self.comment = comment
            self.dataEncoding = dataEncoding
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.structFullyQualifiedName = structFullyQualifiedName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, max: 150)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, min: 1)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case dataEncoding = "dataEncoding"
            case dataType = "dataType"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case structFullyQualifiedName = "structFullyQualifiedName"
        }
    }

    public struct CustomStruct: AWSEncodableShape & AWSDecodableShape {
        /// A comment in addition to the description.
        public let comment: String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of the custom structure.
        public let description: String?
        /// The fully qualified name of the custom structure. For example, the fully qualified name of a custom structure might be ComplexDataTypes.VehicleDataTypes.SVMCamera.
        public let fullyQualifiedName: String

        @inlinable
        public init(comment: String? = nil, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String) {
            self.comment = comment
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
        }
    }

    public struct DataPartition: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the data partition. The data partition ID must be unique within a campaign. You can establish a data partition as the default partition for a campaign by using default as the ID.
        public let id: String
        /// The storage options for a data partition.
        public let storageOptions: DataPartitionStorageOptions
        /// The upload options for the data partition.
        public let uploadOptions: DataPartitionUploadOptions?

        @inlinable
        public init(id: String, storageOptions: DataPartitionStorageOptions, uploadOptions: DataPartitionUploadOptions? = nil) {
            self.id = id
            self.storageOptions = storageOptions
            self.uploadOptions = uploadOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.storageOptions.validate(name: "\(name).storageOptions")
            try self.uploadOptions?.validate(name: "\(name).uploadOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case storageOptions = "storageOptions"
            case uploadOptions = "uploadOptions"
        }
    }

    public struct DataPartitionStorageOptions: AWSEncodableShape & AWSDecodableShape {
        /// The maximum storage size of the data stored in the data partition.  Newer data overwrites older data when the partition reaches the maximum size.
        public let maximumSize: StorageMaximumSize
        /// The amount of time that data in this partition will be kept on disk.   After the designated amount of time passes, the data can be removed, but it's not guaranteed to be removed.   Before the time expires, data in this partition can still be deleted if the partition reaches its configured maximum size.   Newer data will overwrite older data when the partition reaches the maximum size.
        public let minimumTimeToLive: StorageMinimumTimeToLive
        /// The folder name for the data partition under the campaign storage folder.
        public let storageLocation: String

        @inlinable
        public init(maximumSize: StorageMaximumSize, minimumTimeToLive: StorageMinimumTimeToLive, storageLocation: String) {
            self.maximumSize = maximumSize
            self.minimumTimeToLive = minimumTimeToLive
            self.storageLocation = storageLocation
        }

        public func validate(name: String) throws {
            try self.maximumSize.validate(name: "\(name).maximumSize")
            try self.minimumTimeToLive.validate(name: "\(name).minimumTimeToLive")
            try self.validate(self.storageLocation, name: "storageLocation", parent: name, max: 4096)
            try self.validate(self.storageLocation, name: "storageLocation", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maximumSize = "maximumSize"
            case minimumTimeToLive = "minimumTimeToLive"
            case storageLocation = "storageLocation"
        }
    }

    public struct DataPartitionUploadOptions: AWSEncodableShape & AWSDecodableShape {
        /// The version of the condition language. Defaults to the most recent condition language version.
        public let conditionLanguageVersion: Int?
        /// The logical expression used to recognize what data to collect. For example, $variable.`Vehicle.OutsideAirTemperature` &gt;= 105.0.
        public let expression: String

        @inlinable
        public init(conditionLanguageVersion: Int? = nil, expression: String) {
            self.conditionLanguageVersion = conditionLanguageVersion
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.validate(self.conditionLanguageVersion, name: "conditionLanguageVersion", parent: name, max: 1)
            try self.validate(self.conditionLanguageVersion, name: "conditionLanguageVersion", parent: name, min: 1)
            try self.validate(self.expression, name: "expression", parent: name, max: 2048)
            try self.validate(self.expression, name: "expression", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case conditionLanguageVersion = "conditionLanguageVersion"
            case expression = "expression"
        }
    }

    public struct DecoderManifestSummary: AWSDecodableShape {
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public let arn: String?
        /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// A brief description of the decoder manifest.
        public let description: String?
        /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The detailed message for the decoder manifest. When a decoder manifest is in an INVALID status, the message contains detailed reason and help information.
        public let message: String?
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public let modelManifestArn: String?
        /// The name of the decoder manifest.
        public let name: String?
        /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
        public let status: ManifestStatus?

        @inlinable
        public init(arn: String? = nil, creationTime: Date, description: String? = nil, lastModificationTime: Date, message: String? = nil, modelManifestArn: String? = nil, name: String? = nil, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case message = "message"
            case modelManifestArn = "modelManifestArn"
            case name = "name"
            case status = "status"
        }
    }

    public struct DecoderManifestValidationException: AWSErrorShape {
        /// The request couldn't be completed because of invalid network interfaces in the request.
        public let invalidNetworkInterfaces: [InvalidNetworkInterface]?
        /// The request couldn't be completed because of invalid signals in the request.
        public let invalidSignals: [InvalidSignalDecoder]?
        public let message: String?

        @inlinable
        public init(invalidNetworkInterfaces: [InvalidNetworkInterface]? = nil, invalidSignals: [InvalidSignalDecoder]? = nil, message: String? = nil) {
            self.invalidNetworkInterfaces = invalidNetworkInterfaces
            self.invalidSignals = invalidSignals
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case invalidNetworkInterfaces = "invalidNetworkInterfaces"
            case invalidSignals = "invalidSignals"
            case message = "message"
        }
    }

    public struct DeleteCampaignRequest: AWSEncodableShape {
        ///  The name of the campaign to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCampaignResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the deleted campaign.  The ARN isnt returned if a campaign doesnt exist.
        public let arn: String?
        /// The name of the deleted campaign.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteDecoderManifestRequest: AWSEncodableShape {
        ///  The name of the decoder manifest to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDecoderManifestResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted decoder manifest.
        public let arn: String
        /// The name of the deleted decoder manifest.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteFleetRequest: AWSEncodableShape {
        ///  The ID of the fleet to delete.
        public let fleetId: String

        @inlinable
        public init(fleetId: String) {
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFleetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted fleet.
        public let arn: String?
        /// The ID of the deleted fleet.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct DeleteModelManifestRequest: AWSEncodableShape {
        ///  The name of the model manifest to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteModelManifestResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted model manifest.
        public let arn: String
        /// The name of the deleted model manifest.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteSignalCatalogRequest: AWSEncodableShape {
        ///  The name of the signal catalog to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSignalCatalogResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted signal catalog.
        public let arn: String
        /// The name of the deleted signal catalog.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct DeleteStateTemplateRequest: AWSEncodableShape {
        /// The unique ID of the state template.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 100)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the state template.
        public let arn: String?
        /// The unique ID of the state template.
        public let id: String?
        /// The name of the state template.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
        }
    }

    public struct DeleteVehicleRequest: AWSEncodableShape {
        /// The ID of the vehicle to delete.
        public let vehicleName: String

        @inlinable
        public init(vehicleName: String) {
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVehicleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the deleted vehicle.
        public let arn: String
        /// The ID of the deleted vehicle.
        public let vehicleName: String

        @inlinable
        public init(arn: String, vehicleName: String) {
            self.arn = arn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case vehicleName = "vehicleName"
        }
    }

    public struct DisassociateVehicleFleetRequest: AWSEncodableShape {
        ///  The unique ID of a fleet.
        public let fleetId: String
        ///  The unique ID of the vehicle to disassociate from the fleet.
        public let vehicleName: String

        @inlinable
        public init(fleetId: String, vehicleName: String) {
            self.fleetId = fleetId
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.fleetId, forKey: .fleetId)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case fleetId = "fleetId"
        }
    }

    public struct DisassociateVehicleFleetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FleetSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the fleet.
        public let arn: String
        /// The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// A brief description of the fleet.
        public let description: String?
        /// The unique ID of the fleet.
        public let id: String
        /// The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        /// The ARN of the signal catalog associated with the fleet.
        public let signalCatalogArn: String

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, id: String, lastModificationTime: Date? = nil, signalCatalogArn: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.signalCatalogArn = signalCatalogArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case lastModificationTime = "lastModificationTime"
            case signalCatalogArn = "signalCatalogArn"
        }
    }

    public struct GetCampaignRequest: AWSEncodableShape {
        ///  The name of the campaign to retrieve information about.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCampaignResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the campaign.
        public let arn: String?
        ///  Information about the data collection scheme associated with the campaign.
        public let collectionScheme: CollectionScheme?
        ///  Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If OFF is specified, the signals aren't compressed. If it's not specified, SNAPPY is used.
        public let compression: Compression?
        ///  The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream. MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data,  such as data lakes, centralized data storage, data processing pipelines, and analytics.  You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
        public let dataDestinationConfigs: [DataDestinationConfig]?
        ///  A list of vehicle attributes associated with the campaign.
        public let dataExtraDimensions: [String]?
        /// The data partitions associated with the signals collected from the vehicle.
        public let dataPartitions: [DataPartition]?
        /// The description of the campaign.
        public let description: String?
        ///  Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.
        public let diagnosticsMode: DiagnosticsMode?
        ///  The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.
        public let expiryTime: Date?
        /// The last time the campaign was modified.
        public let lastModificationTime: Date?
        /// The name of the campaign.
        public let name: String?
        ///  How long (in seconds) to collect raw data after a triggering event initiates the collection.
        public let postTriggerCollectionDuration: Int64?
        ///  A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.
        public let priority: Int?
        ///  The ARN of a signal catalog.
        public let signalCatalogArn: String?
        ///  Information about a list of signals to collect data on.
        public let signalsToCollect: [SignalInformation]?
        /// Information about a list of signals to fetch data from.
        public let signalsToFetch: [SignalFetchInformation]?
        ///  Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.
        public let spoolingMode: SpoolingMode?
        ///  The time, in milliseconds, to deliver a campaign after it was approved.
        public let startTime: Date?
        /// The state of the campaign. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, and SUSPENDED.
        public let status: CampaignStatus?
        ///  The ARN of the vehicle or the fleet targeted by the campaign.
        public let targetArn: String?

        @inlinable
        public init(arn: String? = nil, collectionScheme: CollectionScheme? = nil, compression: Compression? = nil, creationTime: Date? = nil, dataDestinationConfigs: [DataDestinationConfig]? = nil, dataExtraDimensions: [String]? = nil, dataPartitions: [DataPartition]? = nil, description: String? = nil, diagnosticsMode: DiagnosticsMode? = nil, expiryTime: Date? = nil, lastModificationTime: Date? = nil, name: String? = nil, postTriggerCollectionDuration: Int64? = nil, priority: Int? = nil, signalCatalogArn: String? = nil, signalsToCollect: [SignalInformation]? = nil, signalsToFetch: [SignalFetchInformation]? = nil, spoolingMode: SpoolingMode? = nil, startTime: Date? = nil, status: CampaignStatus? = nil, targetArn: String? = nil) {
            self.arn = arn
            self.collectionScheme = collectionScheme
            self.compression = compression
            self.creationTime = creationTime
            self.dataDestinationConfigs = dataDestinationConfigs
            self.dataExtraDimensions = dataExtraDimensions
            self.dataPartitions = dataPartitions
            self.description = description
            self.diagnosticsMode = diagnosticsMode
            self.expiryTime = expiryTime
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.postTriggerCollectionDuration = postTriggerCollectionDuration
            self.priority = priority
            self.signalCatalogArn = signalCatalogArn
            self.signalsToCollect = signalsToCollect
            self.signalsToFetch = signalsToFetch
            self.spoolingMode = spoolingMode
            self.startTime = startTime
            self.status = status
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collectionScheme = "collectionScheme"
            case compression = "compression"
            case creationTime = "creationTime"
            case dataDestinationConfigs = "dataDestinationConfigs"
            case dataExtraDimensions = "dataExtraDimensions"
            case dataPartitions = "dataPartitions"
            case description = "description"
            case diagnosticsMode = "diagnosticsMode"
            case expiryTime = "expiryTime"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case postTriggerCollectionDuration = "postTriggerCollectionDuration"
            case priority = "priority"
            case signalCatalogArn = "signalCatalogArn"
            case signalsToCollect = "signalsToCollect"
            case signalsToFetch = "signalsToFetch"
            case spoolingMode = "spoolingMode"
            case startTime = "startTime"
            case status = "status"
            case targetArn = "targetArn"
        }
    }

    public struct GetDecoderManifestRequest: AWSEncodableShape {
        ///  The name of the decoder manifest to retrieve information about.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDecoderManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the decoder manifest.
        public let arn: String
        ///  The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the decoder manifest.
        public let description: String?
        ///  The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The detailed message for the decoder manifest. When a decoder manifest is in an INVALID status, the message contains detailed reason and help information.
        public let message: String?
        ///  The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public let modelManifestArn: String?
        ///  The name of the decoder manifest.
        public let name: String
        ///  The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
        public let status: ManifestStatus?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, lastModificationTime: Date, message: String? = nil, modelManifestArn: String? = nil, name: String, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case message = "message"
            case modelManifestArn = "modelManifestArn"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetEncryptionConfigurationResponse: AWSDecodableShape {
        /// The time when encryption was configured in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// The encryption status.
        public let encryptionStatus: EncryptionStatus
        /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use a KMS key that you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key that is owned by the Amazon Web Services IoT FleetWise service account.
        public let encryptionType: EncryptionType
        /// The error message that describes why encryption settings couldn't be configured, if applicable.
        public let errorMessage: String?
        /// The ID of the KMS key that is used for encryption.
        public let kmsKeyId: String?
        /// The time when encryption was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?

        @inlinable
        public init(creationTime: Date? = nil, encryptionStatus: EncryptionStatus, encryptionType: EncryptionType, errorMessage: String? = nil, kmsKeyId: String? = nil, lastModificationTime: Date? = nil) {
            self.creationTime = creationTime
            self.encryptionStatus = encryptionStatus
            self.encryptionType = encryptionType
            self.errorMessage = errorMessage
            self.kmsKeyId = kmsKeyId
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case encryptionStatus = "encryptionStatus"
            case encryptionType = "encryptionType"
            case errorMessage = "errorMessage"
            case kmsKeyId = "kmsKeyId"
            case lastModificationTime = "lastModificationTime"
        }
    }

    public struct GetFleetRequest: AWSEncodableShape {
        ///  The ID of the fleet to retrieve information about.
        public let fleetId: String

        @inlinable
        public init(fleetId: String) {
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFleetResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the fleet.
        public let arn: String
        ///  The time the fleet was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the fleet.
        public let description: String?
        ///  The ID of the fleet.
        public let id: String
        ///  The time the fleet was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        ///  The ARN of a signal catalog associated with the fleet.
        public let signalCatalogArn: String

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, id: String, lastModificationTime: Date, signalCatalogArn: String) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.signalCatalogArn = signalCatalogArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case lastModificationTime = "lastModificationTime"
            case signalCatalogArn = "signalCatalogArn"
        }
    }

    public struct GetLoggingOptionsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetLoggingOptionsResponse: AWSDecodableShape {
        /// Returns information about log delivery to Amazon CloudWatch Logs.
        public let cloudWatchLogDelivery: CloudWatchLogDeliveryOptions

        @inlinable
        public init(cloudWatchLogDelivery: CloudWatchLogDeliveryOptions) {
            self.cloudWatchLogDelivery = cloudWatchLogDelivery
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogDelivery = "cloudWatchLogDelivery"
        }
    }

    public struct GetModelManifestRequest: AWSEncodableShape {
        ///  The name of the vehicle model to retrieve information about.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the vehicle model.
        public let arn: String
        /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the vehicle model.
        public let description: String?
        /// The last time the vehicle model was modified.
        public let lastModificationTime: Date
        ///  The name of the vehicle model.
        public let name: String
        ///  The ARN of the signal catalog associated with the vehicle model.
        public let signalCatalogArn: String?
        ///  The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. You can edit the vehicle model if the status is marked DRAFT.
        public let status: ManifestStatus?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String, signalCatalogArn: String? = nil, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
            case status = "status"
        }
    }

    public struct GetRegisterAccountStatusRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetRegisterAccountStatusResponse: AWSDecodableShape {
        ///  The status of registering your account and resources. The status can be one of:    REGISTRATION_SUCCESS - The Amazon Web Services resource is successfully registered.    REGISTRATION_PENDING - Amazon Web Services IoT FleetWise is processing the registration request. This process takes approximately five minutes to complete.    REGISTRATION_FAILURE - Amazon Web Services IoT FleetWise can't register the AWS resource. Try again later.
        public let accountStatus: RegistrationStatus
        ///  The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  The unique ID of the Amazon Web Services account, provided at account creation.
        public let customerAccountId: String
        ///  Information about the registered IAM resources or errors, if any.
        public let iamRegistrationResponse: IamRegistrationResponse
        ///  The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        ///  Information about the registered Amazon Timestream resources or errors, if any.
        public let timestreamRegistrationResponse: TimestreamRegistrationResponse?

        @inlinable
        public init(accountStatus: RegistrationStatus, creationTime: Date, customerAccountId: String, iamRegistrationResponse: IamRegistrationResponse, lastModificationTime: Date, timestreamRegistrationResponse: TimestreamRegistrationResponse? = nil) {
            self.accountStatus = accountStatus
            self.creationTime = creationTime
            self.customerAccountId = customerAccountId
            self.iamRegistrationResponse = iamRegistrationResponse
            self.lastModificationTime = lastModificationTime
            self.timestreamRegistrationResponse = timestreamRegistrationResponse
        }

        private enum CodingKeys: String, CodingKey {
            case accountStatus = "accountStatus"
            case creationTime = "creationTime"
            case customerAccountId = "customerAccountId"
            case iamRegistrationResponse = "iamRegistrationResponse"
            case lastModificationTime = "lastModificationTime"
            case timestreamRegistrationResponse = "timestreamRegistrationResponse"
        }
    }

    public struct GetSignalCatalogRequest: AWSEncodableShape {
        ///  The name of the signal catalog to retrieve information about.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSignalCatalogResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the signal catalog.
        public let arn: String
        ///  The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  A brief description of the signal catalog.
        public let description: String?
        /// The last time the signal catalog was modified.
        public let lastModificationTime: Date
        ///  The name of the signal catalog.
        public let name: String
        ///  The total number of network nodes specified in a signal catalog.
        public let nodeCounts: NodeCounts?

        @inlinable
        public init(arn: String, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String, nodeCounts: NodeCounts? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.nodeCounts = nodeCounts
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case nodeCounts = "nodeCounts"
        }
    }

    public struct GetStateTemplateRequest: AWSEncodableShape {
        /// The unique ID of the state template.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 100)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the state template.
        public let arn: String?
        /// The time the state template was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// A list of vehicle attributes associated with the payload published on the state template's  MQTT topic.  Default: An empty array
        public let dataExtraDimensions: [String]?
        /// A brief description of the state template.
        public let description: String?
        /// The unique ID of the state template.
        public let id: String?
        /// The time the state template was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        /// A list of vehicle attributes to associate with user properties of the messages published on the state template's MQTT topic. Default: An empty array
        public let metadataExtraDimensions: [String]?
        /// The name of the state template.
        public let name: String?
        /// The ARN of the signal catalog associated with the state template.
        public let signalCatalogArn: String?
        /// A list of signals from which data is collected. The state template properties contain the fully qualified names of the signals.
        public let stateTemplateProperties: [String]?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, dataExtraDimensions: [String]? = nil, description: String? = nil, id: String? = nil, lastModificationTime: Date? = nil, metadataExtraDimensions: [String]? = nil, name: String? = nil, signalCatalogArn: String? = nil, stateTemplateProperties: [String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.dataExtraDimensions = dataExtraDimensions
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.metadataExtraDimensions = metadataExtraDimensions
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.stateTemplateProperties = stateTemplateProperties
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case dataExtraDimensions = "dataExtraDimensions"
            case description = "description"
            case id = "id"
            case lastModificationTime = "lastModificationTime"
            case metadataExtraDimensions = "metadataExtraDimensions"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
            case stateTemplateProperties = "stateTemplateProperties"
        }
    }

    public struct GetVehicleRequest: AWSEncodableShape {
        ///  The ID of the vehicle to retrieve information about.
        public let vehicleName: String

        @inlinable
        public init(vehicleName: String) {
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVehicleResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the vehicle to retrieve information about.
        public let arn: String?
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        ///  The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        ///  The ARN of a decoder manifest associated with the vehicle.
        public let decoderManifestArn: String?
        ///  The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        ///  The ARN of a vehicle model (model manifest) associated with the vehicle.
        public let modelManifestArn: String?
        /// State templates associated with the vehicle.
        public let stateTemplates: [StateTemplateAssociation]?
        /// The ID of the vehicle.
        public let vehicleName: String?

        @inlinable
        public init(arn: String? = nil, attributes: [String: String]? = nil, creationTime: Date? = nil, decoderManifestArn: String? = nil, lastModificationTime: Date? = nil, modelManifestArn: String? = nil, stateTemplates: [StateTemplateAssociation]? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.attributes = attributes
            self.creationTime = creationTime
            self.decoderManifestArn = decoderManifestArn
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.stateTemplates = stateTemplates
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case attributes = "attributes"
            case creationTime = "creationTime"
            case decoderManifestArn = "decoderManifestArn"
            case lastModificationTime = "lastModificationTime"
            case modelManifestArn = "modelManifestArn"
            case stateTemplates = "stateTemplates"
            case vehicleName = "vehicleName"
        }
    }

    public struct GetVehicleStatusRequest: AWSEncodableShape {
        /// The maximum number of items to return, between 1 and 100, inclusive. This parameter is only  supported for resources of type CAMPAIGN.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a  nextToken pagination token is returned in the response. To retrieve the next  set of results, reissue the search request and include the returned token. When all results  have been returned, the response does not contain a pagination token value. This parameter  is only supported for resources of type CAMPAIGN.
        public let nextToken: String?
        ///  The ID of the vehicle to retrieve information about.
        public let vehicleName: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, vehicleName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVehicleStatusResponse: AWSDecodableShape {
        ///  Lists information about the state of the vehicle with deployed campaigns.
        public let campaigns: [VehicleStatus]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(campaigns: [VehicleStatus]? = nil, nextToken: String? = nil) {
            self.campaigns = campaigns
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaigns = "campaigns"
            case nextToken = "nextToken"
        }
    }

    public struct IamRegistrationResponse: AWSDecodableShape {
        /// A message associated with a registration error.
        public let errorMessage: String?
        /// The status of registering your IAM resource. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        public let registrationStatus: RegistrationStatus
        /// The Amazon Resource Name (ARN) of the IAM role to register.
        public let roleArn: String

        @inlinable
        public init(errorMessage: String? = nil, registrationStatus: RegistrationStatus, roleArn: String) {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case registrationStatus = "registrationStatus"
            case roleArn = "roleArn"
        }
    }

    public struct IamResources: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN.
        public let roleArn: String

        @inlinable
        public init(roleArn: String) {
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):iam::(\\d{12})?:(role((\\u002F)|(\\u002F[\\u0021-\\u007F]+\\u002F))[\\w+=,.@-]+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
        }
    }

    public struct ImportDecoderManifestRequest: AWSEncodableShape {
        ///  The name of the decoder manifest to import.
        public let name: String
        ///  The file to load into an Amazon Web Services account.
        public let networkFileDefinitions: [NetworkFileDefinition]

        @inlinable
        public init(name: String, networkFileDefinitions: [NetworkFileDefinition]) {
            self.name = name
            self.networkFileDefinitions = networkFileDefinitions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "name")
            try container.encode(self.networkFileDefinitions, forKey: .networkFileDefinitions)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.networkFileDefinitions.forEach {
                try $0.validate(name: "\(name).networkFileDefinitions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case networkFileDefinitions = "networkFileDefinitions"
        }
    }

    public struct ImportDecoderManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the decoder manifest that was imported.
        public let arn: String
        ///  The name of the imported decoder manifest.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct ImportSignalCatalogRequest: AWSEncodableShape {
        ///  A brief description of the signal catalog.
        public let description: String?
        /// The name of the signal catalog to import.
        public let name: String
        /// Metadata that can be used to manage the signal catalog.
        public let tags: [Tag]?
        /// The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.
        public let vss: FormattedVss?

        @inlinable
        public init(description: String? = nil, name: String, tags: [Tag]? = nil, vss: FormattedVss? = nil) {
            self.description = description
            self.name = name
            self.tags = tags
            self.vss = vss
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.vss, forKey: .vss)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case tags = "tags"
            case vss = "vss"
        }
    }

    public struct ImportSignalCatalogResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the imported signal catalog.
        public let arn: String
        ///  The name of the imported signal catalog.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying the command.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvalidNetworkInterface: AWSDecodableShape {
        /// The ID of the interface that isn't valid.
        public let interfaceId: String?
        /// A message about why the interface isn't valid.
        public let reason: NetworkInterfaceFailureReason?

        @inlinable
        public init(interfaceId: String? = nil, reason: NetworkInterfaceFailureReason? = nil) {
            self.interfaceId = interfaceId
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case interfaceId = "interfaceId"
            case reason = "reason"
        }
    }

    public struct InvalidNodeException: AWSErrorShape {
        /// The specified node type isn't valid.
        public let invalidNodes: [Node]?
        public let message: String?
        /// The reason the node validation failed.
        public let reason: String?

        @inlinable
        public init(invalidNodes: [Node]? = nil, message: String? = nil, reason: String? = nil) {
            self.invalidNodes = invalidNodes
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case invalidNodes = "invalidNodes"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct InvalidSignal: AWSDecodableShape {
        /// The name of the signal that isn't valid.
        public let name: String?
        /// A message about why the signal isn't valid.
        public let reason: String?

        @inlinable
        public init(name: String? = nil, reason: String? = nil) {
            self.name = name
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case reason = "reason"
        }
    }

    public struct InvalidSignalDecoder: AWSDecodableShape {
        /// The possible cause for the invalid signal decoder.
        public let hint: String?
        /// The name of a signal decoder that isn't valid.
        public let name: String?
        /// A message about why the signal decoder isn't valid.
        public let reason: SignalDecoderFailureReason?

        @inlinable
        public init(hint: String? = nil, name: String? = nil, reason: SignalDecoderFailureReason? = nil) {
            self.hint = hint
            self.name = name
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case hint = "hint"
            case name = "name"
            case reason = "reason"
        }
    }

    public struct InvalidSignalsException: AWSErrorShape {
        /// The signals which caused the exception.
        public let invalidSignals: [InvalidSignal]?
        public let message: String?

        @inlinable
        public init(invalidSignals: [InvalidSignal]? = nil, message: String? = nil) {
            self.invalidSignals = invalidSignals
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case invalidSignals = "invalidSignals"
            case message = "message"
        }
    }

    public struct LimitExceededException: AWSErrorShape {
        public let message: String
        /// The identifier of the resource that was exceeded.
        public let resourceId: String
        /// The type of resource that was exceeded.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ListCampaignsRequest: AWSEncodableShape {
        /// When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: campaign name, Amazon Resource Name (ARN), creation time, and last modification time.
        public let listResponseScope: ListResponseScope?
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        /// An optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, or SUSPENDED.
        public let status: String?

        @inlinable
        public init(listResponseScope: ListResponseScope? = nil, maxResults: Int? = nil, nextToken: String? = nil, status: String? = nil) {
            self.listResponseScope = listResponseScope
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.listResponseScope, key: "listResponseScope")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.status, name: "status", parent: name, max: 20)
            try self.validate(self.status, name: "status", parent: name, min: 1)
            try self.validate(self.status, name: "status", parent: name, pattern: "^[A-Z_]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCampaignsResponse: AWSDecodableShape {
        ///  A summary of information about each campaign.
        public let campaignSummaries: [CampaignSummary]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(campaignSummaries: [CampaignSummary]? = nil, nextToken: String? = nil) {
            self.campaignSummaries = campaignSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case campaignSummaries = "campaignSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListDecoderManifestNetworkInterfacesRequest: AWSEncodableShape {
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the decoder manifest to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDecoderManifestNetworkInterfacesResponse: AWSDecodableShape {
        ///  A list of information about network interfaces.
        public let networkInterfaces: [NetworkInterface]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(networkInterfaces: [NetworkInterface]? = nil, nextToken: String? = nil) {
            self.networkInterfaces = networkInterfaces
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case networkInterfaces = "networkInterfaces"
            case nextToken = "nextToken"
        }
    }

    public struct ListDecoderManifestSignalsRequest: AWSEncodableShape {
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the decoder manifest to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDecoderManifestSignalsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  Information about a list of signals to decode.
        public let signalDecoders: [SignalDecoder]?

        @inlinable
        public init(nextToken: String? = nil, signalDecoders: [SignalDecoder]? = nil) {
            self.nextToken = nextToken
            self.signalDecoders = signalDecoders
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case signalDecoders = "signalDecoders"
        }
    }

    public struct ListDecoderManifestsRequest: AWSEncodableShape {
        /// When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: decoder manifest name, Amazon Resource Name (ARN), creation time, and last modification time.
        public let listResponseScope: ListResponseScope?
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.
        public let modelManifestArn: String?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(listResponseScope: ListResponseScope? = nil, maxResults: Int? = nil, modelManifestArn: String? = nil, nextToken: String? = nil) {
            self.listResponseScope = listResponseScope
            self.maxResults = maxResults
            self.modelManifestArn = modelManifestArn
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.listResponseScope, key: "listResponseScope")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.modelManifestArn, key: "modelManifestArn")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDecoderManifestsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about each decoder manifest.
        public let summaries: [DecoderManifestSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [DecoderManifestSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListFleetsForVehicleRequest: AWSEncodableShape {
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        ///  The ID of the vehicle to retrieve information about.
        public let vehicleName: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, vehicleName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFleetsForVehicleResponse: AWSDecodableShape {
        ///  A list of fleet IDs that the vehicle is associated with.
        public let fleets: [String]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(fleets: [String]? = nil, nextToken: String? = nil) {
            self.fleets = fleets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleets = "fleets"
            case nextToken = "nextToken"
        }
    }

    public struct ListFleetsRequest: AWSEncodableShape {
        /// When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: fleet ID, Amazon Resource Name (ARN), creation time, and last modification time.
        public let listResponseScope: ListResponseScope?
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(listResponseScope: ListResponseScope? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.listResponseScope = listResponseScope
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.listResponseScope, key: "listResponseScope")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFleetsResponse: AWSDecodableShape {
        ///  A list of information for each fleet.
        public let fleetSummaries: [FleetSummary]?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(fleetSummaries: [FleetSummary]? = nil, nextToken: String? = nil) {
            self.fleetSummaries = fleetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case fleetSummaries = "fleetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListModelManifestNodesRequest: AWSEncodableShape {
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the vehicle model to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelManifestNodesResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about nodes.
        public let nodes: [Node]?

        @inlinable
        public init(nextToken: String? = nil, nodes: [Node]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodes = "nodes"
        }
    }

    public struct ListModelManifestsRequest: AWSEncodableShape {
        /// When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: model manifest name, Amazon Resource Name (ARN), creation time, and last modification time.
        public let listResponseScope: ListResponseScope?
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        ///  The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.
        public let signalCatalogArn: String?

        @inlinable
        public init(listResponseScope: ListResponseScope? = nil, maxResults: Int? = nil, nextToken: String? = nil, signalCatalogArn: String? = nil) {
            self.listResponseScope = listResponseScope
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.signalCatalogArn = signalCatalogArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.listResponseScope, key: "listResponseScope")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.signalCatalogArn, key: "signalCatalogArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListModelManifestsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about vehicle models.
        public let summaries: [ModelManifestSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [ModelManifestSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListSignalCatalogNodesRequest: AWSEncodableShape {
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The name of the signal catalog to list information about.
        public let name: String
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        /// The type of node in the signal catalog.
        public let signalNodeType: SignalNodeType?

        @inlinable
        public init(maxResults: Int? = nil, name: String, nextToken: String? = nil, signalNodeType: SignalNodeType? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.signalNodeType = signalNodeType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.signalNodeType, key: "signalNodeType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSignalCatalogNodesResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about nodes.
        public let nodes: [Node]?

        @inlinable
        public init(nextToken: String? = nil, nodes: [Node]? = nil) {
            self.nextToken = nextToken
            self.nodes = nodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case nodes = "nodes"
        }
    }

    public struct ListSignalCatalogsRequest: AWSEncodableShape {
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSignalCatalogsResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of information about each signal catalog.
        public let summaries: [SignalCatalogSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [SignalCatalogSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListStateTemplatesRequest: AWSEncodableShape {
        /// When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: state template ID, Amazon Resource Name (ARN), creation time, and last modification time.
        public let listResponseScope: ListResponseScope?
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?

        @inlinable
        public init(listResponseScope: ListResponseScope? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.listResponseScope = listResponseScope
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.listResponseScope, key: "listResponseScope")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStateTemplatesResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        /// A list of information about each state template.
        public let summaries: [StateTemplateSummary]?

        @inlinable
        public init(nextToken: String? = nil, summaries: [StateTemplateSummary]? = nil) {
            self.nextToken = nextToken
            self.summaries = summaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case summaries = "summaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The list of tags assigned to the resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListVehiclesInFleetRequest: AWSEncodableShape {
        ///  The ID of a fleet.
        public let fleetId: String
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(fleetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.fleetId = fleetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.fleetId, key: "fleetId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVehiclesInFleetResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of vehicles associated with the fleet.
        public let vehicles: [String]?

        @inlinable
        public init(nextToken: String? = nil, vehicles: [String]? = nil) {
            self.nextToken = nextToken
            self.vehicles = vehicles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vehicles = "vehicles"
        }
    }

    public struct ListVehiclesRequest: AWSEncodableShape {
        /// The fully qualified names of the attributes. You can use this optional parameter to list the  vehicles containing all the attributes in the request. For example, attributeNames  could be "Vehicle.Body.Engine.Type, Vehicle.Color" and the corresponding  attributeValues could be "1.3 L R2, Blue" . In this case, the API  will filter vehicles with an attribute name Vehicle.Body.Engine.Type that contains a value of 1.3 L R2 AND an attribute name Vehicle.Color that contains a value of "Blue". A request must contain unique values for the attributeNames  filter and the matching number of attributeValues filters to return the subset  of vehicles that match the attributes filter condition.
        public let attributeNames: [String]?
        /// Static information about a vehicle attribute value in string format. You can use this optional  parameter in conjunction with attributeNames to list the vehicles containing all  the attributeValues corresponding to the attributeNames filter. For  example, attributeValues could be "1.3 L R2, Blue" and the corresponding  attributeNames filter could be "Vehicle.Body.Engine.Type, Vehicle.Color".  In this case, the API will filter vehicles with attribute name Vehicle.Body.Engine.Type  that contains a value of 1.3 L R2 AND an attribute name Vehicle.Color that contains a value of "Blue". A request must contain unique values for the  attributeNames filter and the matching number of attributeValues  filter to return the subset of vehicles that match the attributes filter condition.
        public let attributeValues: [String]?
        /// When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: vehicle name, Amazon Resource Name (ARN), creation time, and last modification time.
        public let listResponseScope: ListResponseScope?
        /// The maximum number of items to return, between 1 and 100, inclusive.
        public let maxResults: Int?
        ///  The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model.
        public let modelManifestArn: String?
        /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        @inlinable
        public init(attributeNames: [String]? = nil, attributeValues: [String]? = nil, listResponseScope: ListResponseScope? = nil, maxResults: Int? = nil, modelManifestArn: String? = nil, nextToken: String? = nil) {
            self.attributeNames = attributeNames
            self.attributeValues = attributeValues
            self.listResponseScope = listResponseScope
            self.maxResults = maxResults
            self.modelManifestArn = modelManifestArn
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.attributeNames, key: "attributeNames")
            request.encodeQuery(self.attributeValues, key: "attributeValues")
            request.encodeQuery(self.listResponseScope, key: "listResponseScope")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.modelManifestArn, key: "modelManifestArn")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.attributeNames?.forEach {
                try validate($0, name: "attributeNames[]", parent: name, max: 150)
                try validate($0, name: "attributeNames[]", parent: name, min: 1)
                try validate($0, name: "attributeNames[]", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.validate(self.attributeNames, name: "attributeNames", parent: name, max: 5)
            try self.validate(self.attributeNames, name: "attributeNames", parent: name, min: 1)
            try self.validate(self.attributeValues, name: "attributeValues", parent: name, max: 5)
            try self.validate(self.attributeValues, name: "attributeValues", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListVehiclesResponse: AWSDecodableShape {
        ///  The token to retrieve the next set of results, or null if there are no more results.
        public let nextToken: String?
        ///  A list of vehicles and information about them.
        public let vehicleSummaries: [VehicleSummary]?

        @inlinable
        public init(nextToken: String? = nil, vehicleSummaries: [VehicleSummary]? = nil) {
            self.nextToken = nextToken
            self.vehicleSummaries = vehicleSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vehicleSummaries = "vehicleSummaries"
        }
    }

    public struct MessageSignal: AWSEncodableShape & AWSDecodableShape {
        /// The structured message for the message signal. It can be defined with either a primitiveMessageDefinition, structuredMessageListDefinition, or structuredMessageDefinition recursively.
        public let structuredMessage: StructuredMessage
        /// The topic name for the message signal. It corresponds to topics in ROS 2.
        public let topicName: String

        @inlinable
        public init(structuredMessage: StructuredMessage, topicName: String) {
            self.structuredMessage = structuredMessage
            self.topicName = topicName
        }

        public func validate(name: String) throws {
            try self.structuredMessage.validate(name: "\(name).structuredMessage")
            try self.validate(self.topicName, name: "topicName", parent: name, max: 150)
            try self.validate(self.topicName, name: "topicName", parent: name, min: 1)
            try self.validate(self.topicName, name: "topicName", parent: name, pattern: "^[a-zA-Z0-9_\\-#:./]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case structuredMessage = "structuredMessage"
            case topicName = "topicName"
        }
    }

    public struct ModelManifestSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the vehicle model.
        public let arn: String?
        /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// A brief description of the vehicle model.
        public let description: String?
        /// The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The name of the vehicle model.
        public let name: String?
        /// The ARN of the signal catalog associated with the vehicle model.
        public let signalCatalogArn: String?
        /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
        public let status: ManifestStatus?

        @inlinable
        public init(arn: String? = nil, creationTime: Date, description: String? = nil, lastModificationTime: Date, name: String? = nil, signalCatalogArn: String? = nil, status: ManifestStatus? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
            case status = "status"
        }
    }

    public struct MqttTopicConfig: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the role that grants Amazon Web Services IoT FleetWise permission to access and act on messages sent to  the MQTT topic.
        public let executionRoleArn: String
        /// The ARN of the MQTT topic.
        public let mqttTopicArn: String

        @inlinable
        public init(executionRoleArn: String, mqttTopicArn: String) {
            self.executionRoleArn = executionRoleArn
            self.mqttTopicArn = mqttTopicArn
        }

        public func validate(name: String) throws {
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):iam::(\\d{12})?:(role((\\u002F)|(\\u002F[\\u0021-\\u007F]+\\u002F))[\\w+=,.@-]+)$")
            try self.validate(self.mqttTopicArn, name: "mqttTopicArn", parent: name, max: 2048)
            try self.validate(self.mqttTopicArn, name: "mqttTopicArn", parent: name, min: 20)
            try self.validate(self.mqttTopicArn, name: "mqttTopicArn", parent: name, pattern: "^arn:.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case executionRoleArn = "executionRoleArn"
            case mqttTopicArn = "mqttTopicArn"
        }
    }

    public struct NetworkInterface: AWSEncodableShape & AWSDecodableShape {
        /// Information about a network interface specified by the Controller Area Network (CAN) protocol.
        public let canInterface: CanInterface?
        /// Information about a custom network  interface.
        public let customDecodingInterface: CustomDecodingInterface?
        /// The ID of the network interface.
        public let interfaceId: String
        /// Information about a network interface specified by the on-board diagnostic (OBD) II protocol.
        public let obdInterface: ObdInterface?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        public let type: NetworkInterfaceType
        /// The vehicle middleware defined as a type of network interface. Examples of vehicle middleware include ROS2 and SOME/IP.
        public let vehicleMiddleware: VehicleMiddleware?

        @inlinable
        public init(canInterface: CanInterface? = nil, customDecodingInterface: CustomDecodingInterface? = nil, interfaceId: String, obdInterface: ObdInterface? = nil, type: NetworkInterfaceType, vehicleMiddleware: VehicleMiddleware? = nil) {
            self.canInterface = canInterface
            self.customDecodingInterface = customDecodingInterface
            self.interfaceId = interfaceId
            self.obdInterface = obdInterface
            self.type = type
            self.vehicleMiddleware = vehicleMiddleware
        }

        public func validate(name: String) throws {
            try self.canInterface?.validate(name: "\(name).canInterface")
            try self.customDecodingInterface?.validate(name: "\(name).customDecodingInterface")
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, max: 50)
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, min: 1)
            try self.obdInterface?.validate(name: "\(name).obdInterface")
            try self.vehicleMiddleware?.validate(name: "\(name).vehicleMiddleware")
        }

        private enum CodingKeys: String, CodingKey {
            case canInterface = "canInterface"
            case customDecodingInterface = "customDecodingInterface"
            case interfaceId = "interfaceId"
            case obdInterface = "obdInterface"
            case type = "type"
            case vehicleMiddleware = "vehicleMiddleware"
        }
    }

    public struct NodeCounts: AWSDecodableShape {
        /// The total number of nodes in a vehicle network that represent actuators.
        public let totalActuators: Int?
        /// The total number of nodes in a vehicle network that represent attributes.
        public let totalAttributes: Int?
        /// The total number of nodes in a vehicle network that represent branches.
        public let totalBranches: Int?
        /// The total number of nodes in a vehicle network.
        public let totalNodes: Int?
        /// The total properties for the node.
        public let totalProperties: Int?
        /// The total number of nodes in a vehicle network that represent sensors.
        public let totalSensors: Int?
        /// The total structure for the node.
        public let totalStructs: Int?

        @inlinable
        public init(totalActuators: Int? = nil, totalAttributes: Int? = nil, totalBranches: Int? = nil, totalNodes: Int? = nil, totalProperties: Int? = nil, totalSensors: Int? = nil, totalStructs: Int? = nil) {
            self.totalActuators = totalActuators
            self.totalAttributes = totalAttributes
            self.totalBranches = totalBranches
            self.totalNodes = totalNodes
            self.totalProperties = totalProperties
            self.totalSensors = totalSensors
            self.totalStructs = totalStructs
        }

        private enum CodingKeys: String, CodingKey {
            case totalActuators = "totalActuators"
            case totalAttributes = "totalAttributes"
            case totalBranches = "totalBranches"
            case totalNodes = "totalNodes"
            case totalProperties = "totalProperties"
            case totalSensors = "totalSensors"
            case totalStructs = "totalStructs"
        }
    }

    public struct ObdInterface: AWSEncodableShape & AWSDecodableShape {
        /// The maximum number message requests per diagnostic trouble code per second.
        public let dtcRequestIntervalSeconds: Int?
        /// Whether the vehicle has a transmission control module (TCM).
        public let hasTransmissionEcu: Bool?
        /// The name of the interface.
        public let name: String
        /// The standard OBD II PID.
        public let obdStandard: String?
        /// The maximum number message requests per second.
        public let pidRequestIntervalSeconds: Int?
        /// The ID of the message requesting vehicle data.
        public let requestMessageId: Int
        /// Whether to use extended IDs in the message.
        public let useExtendedIds: Bool?

        @inlinable
        public init(dtcRequestIntervalSeconds: Int? = nil, hasTransmissionEcu: Bool? = nil, name: String, obdStandard: String? = nil, pidRequestIntervalSeconds: Int? = nil, requestMessageId: Int, useExtendedIds: Bool? = nil) {
            self.dtcRequestIntervalSeconds = dtcRequestIntervalSeconds
            self.hasTransmissionEcu = hasTransmissionEcu
            self.name = name
            self.obdStandard = obdStandard
            self.pidRequestIntervalSeconds = pidRequestIntervalSeconds
            self.requestMessageId = requestMessageId
            self.useExtendedIds = useExtendedIds
        }

        public func validate(name: String) throws {
            try self.validate(self.dtcRequestIntervalSeconds, name: "dtcRequestIntervalSeconds", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.obdStandard, name: "obdStandard", parent: name, max: 50)
            try self.validate(self.obdStandard, name: "obdStandard", parent: name, min: 1)
            try self.validate(self.pidRequestIntervalSeconds, name: "pidRequestIntervalSeconds", parent: name, min: 0)
            try self.validate(self.requestMessageId, name: "requestMessageId", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dtcRequestIntervalSeconds = "dtcRequestIntervalSeconds"
            case hasTransmissionEcu = "hasTransmissionEcu"
            case name = "name"
            case obdStandard = "obdStandard"
            case pidRequestIntervalSeconds = "pidRequestIntervalSeconds"
            case requestMessageId = "requestMessageId"
            case useExtendedIds = "useExtendedIds"
        }
    }

    public struct ObdSignal: AWSEncodableShape & AWSDecodableShape {
        /// The number of bits to mask in a message.
        public let bitMaskLength: Int?
        /// The number of positions to shift bits in the message.
        public let bitRightShift: Int?
        /// The length of a message.
        public let byteLength: Int
        /// Determines whether the message is signed (true) or not (false). If it's signed, the message can represent both positive and negative numbers. The isSigned parameter only applies to the INTEGER raw signal type, and it doesn't affect the FLOATING_POINT raw signal type. The default value is false.
        public let isSigned: Bool?
        /// The offset used to calculate the signal value. Combined with scaling, the calculation is value = raw_value * scaling + offset.
        public let offset: Double
        /// The diagnostic code used to request data from a vehicle for this signal.
        public let pid: Int
        /// The length of the requested data.
        public let pidResponseLength: Int
        /// A multiplier used to decode the message.
        public let scaling: Double
        /// The mode of operation (diagnostic service) in a message.
        public let serviceMode: Int
        /// The value type of the signal. The default value is INTEGER.
        public let signalValueType: SignalValueType?
        /// Indicates the beginning of the message.
        public let startByte: Int

        @inlinable
        public init(bitMaskLength: Int? = nil, bitRightShift: Int? = nil, byteLength: Int, isSigned: Bool? = nil, offset: Double, pid: Int, pidResponseLength: Int, scaling: Double, serviceMode: Int, signalValueType: SignalValueType? = nil, startByte: Int) {
            self.bitMaskLength = bitMaskLength
            self.bitRightShift = bitRightShift
            self.byteLength = byteLength
            self.isSigned = isSigned
            self.offset = offset
            self.pid = pid
            self.pidResponseLength = pidResponseLength
            self.scaling = scaling
            self.serviceMode = serviceMode
            self.signalValueType = signalValueType
            self.startByte = startByte
        }

        public func validate(name: String) throws {
            try self.validate(self.bitMaskLength, name: "bitMaskLength", parent: name, max: 8)
            try self.validate(self.bitMaskLength, name: "bitMaskLength", parent: name, min: 1)
            try self.validate(self.bitRightShift, name: "bitRightShift", parent: name, min: 0)
            try self.validate(self.byteLength, name: "byteLength", parent: name, max: 8)
            try self.validate(self.byteLength, name: "byteLength", parent: name, min: 1)
            try self.validate(self.pid, name: "pid", parent: name, min: 0)
            try self.validate(self.pidResponseLength, name: "pidResponseLength", parent: name, min: 1)
            try self.validate(self.serviceMode, name: "serviceMode", parent: name, min: 0)
            try self.validate(self.startByte, name: "startByte", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case bitMaskLength = "bitMaskLength"
            case bitRightShift = "bitRightShift"
            case byteLength = "byteLength"
            case isSigned = "isSigned"
            case offset = "offset"
            case pid = "pid"
            case pidResponseLength = "pidResponseLength"
            case scaling = "scaling"
            case serviceMode = "serviceMode"
            case signalValueType = "signalValueType"
            case startByte = "startByte"
        }
    }

    public struct OnChangeStateTemplateUpdateStrategy: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct PeriodicStateTemplateUpdateStrategy: AWSEncodableShape & AWSDecodableShape {
        public let stateTemplateUpdateRate: TimePeriod

        @inlinable
        public init(stateTemplateUpdateRate: TimePeriod) {
            self.stateTemplateUpdateRate = stateTemplateUpdateRate
        }

        public func validate(name: String) throws {
            try self.stateTemplateUpdateRate.validate(name: "\(name).stateTemplateUpdateRate")
        }

        private enum CodingKeys: String, CodingKey {
            case stateTemplateUpdateRate = "stateTemplateUpdateRate"
        }
    }

    public struct PutEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption. Choose KMS_BASED_ENCRYPTION to use a KMS key or FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key.
        public let encryptionType: EncryptionType
        /// The ID of the KMS key that is used for encryption.
        public let kmsKeyId: String?

        @inlinable
        public init(encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct PutEncryptionConfigurationResponse: AWSDecodableShape {
        /// The encryption status.
        public let encryptionStatus: EncryptionStatus
        /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use an KMS key that  you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed  key that is owned by the Amazon Web Services IoT FleetWise service account.
        public let encryptionType: EncryptionType
        /// The ID of the KMS key that is used for encryption.
        public let kmsKeyId: String?

        @inlinable
        public init(encryptionStatus: EncryptionStatus, encryptionType: EncryptionType, kmsKeyId: String? = nil) {
            self.encryptionStatus = encryptionStatus
            self.encryptionType = encryptionType
            self.kmsKeyId = kmsKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionStatus = "encryptionStatus"
            case encryptionType = "encryptionType"
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct PutLoggingOptionsRequest: AWSEncodableShape {
        /// Creates or updates the log delivery option to Amazon CloudWatch Logs.
        public let cloudWatchLogDelivery: CloudWatchLogDeliveryOptions

        @inlinable
        public init(cloudWatchLogDelivery: CloudWatchLogDeliveryOptions) {
            self.cloudWatchLogDelivery = cloudWatchLogDelivery
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogDelivery.validate(name: "\(name).cloudWatchLogDelivery")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogDelivery = "cloudWatchLogDelivery"
        }
    }

    public struct PutLoggingOptionsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ROS2PrimitiveMessageDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The offset used to calculate the signal value. Combined with scaling, the calculation is value = raw_value * scaling + offset.
        public let offset: Double?
        /// The primitive type (integer, floating point, boolean, etc.) for the ROS 2 primitive message definition.
        public let primitiveType: ROS2PrimitiveType
        /// A multiplier used to decode the message.
        public let scaling: Double?
        /// An optional attribute specifying the upper bound for STRING and WSTRING.
        public let upperBound: Int64?

        @inlinable
        public init(offset: Double? = nil, primitiveType: ROS2PrimitiveType, scaling: Double? = nil, upperBound: Int64? = nil) {
            self.offset = offset
            self.primitiveType = primitiveType
            self.scaling = scaling
            self.upperBound = upperBound
        }

        public func validate(name: String) throws {
            try self.validate(self.upperBound, name: "upperBound", parent: name, max: 2048)
            try self.validate(self.upperBound, name: "upperBound", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case offset = "offset"
            case primitiveType = "primitiveType"
            case scaling = "scaling"
            case upperBound = "upperBound"
        }
    }

    public struct RegisterAccountRequest: AWSEncodableShape {
        /// The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
        public let iamResources: IamResources?
        public let timestreamResources: TimestreamResources?

        @inlinable
        public init() {
            self.iamResources = nil
            self.timestreamResources = nil
        }

        @available(*, deprecated, message: "Members iamResources, timestreamResources have been deprecated")
        @inlinable
        public init(iamResources: IamResources? = nil, timestreamResources: TimestreamResources? = nil) {
            self.iamResources = iamResources
            self.timestreamResources = timestreamResources
        }

        public func validate(name: String) throws {
            try self.iamResources?.validate(name: "\(name).iamResources")
            try self.timestreamResources?.validate(name: "\(name).timestreamResources")
        }

        private enum CodingKeys: String, CodingKey {
            case iamResources = "iamResources"
            case timestreamResources = "timestreamResources"
        }
    }

    public struct RegisterAccountResponse: AWSDecodableShape {
        ///  The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        ///  The registered IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
        public let iamResources: IamResources
        ///  The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        ///  The status of registering your Amazon Web Services account, IAM role, and Timestream resources.
        public let registerAccountStatus: RegistrationStatus
        public let timestreamResources: TimestreamResources?

        @inlinable
        public init(creationTime: Date, iamResources: IamResources, lastModificationTime: Date, registerAccountStatus: RegistrationStatus, timestreamResources: TimestreamResources? = nil) {
            self.creationTime = creationTime
            self.iamResources = iamResources
            self.lastModificationTime = lastModificationTime
            self.registerAccountStatus = registerAccountStatus
            self.timestreamResources = timestreamResources
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "creationTime"
            case iamResources = "iamResources"
            case lastModificationTime = "lastModificationTime"
            case registerAccountStatus = "registerAccountStatus"
            case timestreamResources = "timestreamResources"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The identifier of the resource that wasn't found.
        public let resourceId: String
        /// The type of resource that wasn't found.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket.
        public let bucketArn: String
        /// Specify the format that files are saved in the Amazon S3 bucket. You can save files in an Apache Parquet or JSON format.   Parquet - Store data in a columnar storage file format. Parquet is optimal for fast data retrieval and can reduce costs. This option is selected by default.   JSON - Store data in a standard text-based JSON file format.
        public let dataFormat: DataFormat?
        /// Enter an S3 bucket prefix. The prefix is the string of characters after the bucket name and before the object name. You can use the prefix to organize data stored in Amazon S3 buckets. For more information, see Organizing objects using prefixes in the Amazon Simple Storage Service User Guide. By default, Amazon Web Services IoT FleetWise sets the prefix processed-data/year=YY/month=MM/date=DD/hour=HH/ (in UTC) to data it delivers to Amazon S3. You can enter a prefix to append it to this default prefix. For example, if you enter the prefix vehicles, the prefix will be vehicles/processed-data/year=YY/month=MM/date=DD/hour=HH/.
        public let prefix: String?
        /// By default, stored data is compressed as a .gzip file. Compressed files have a reduced file size, which can optimize the cost of data storage.
        public let storageCompressionFormat: StorageCompressionFormat?

        @inlinable
        public init(bucketArn: String, dataFormat: DataFormat? = nil, prefix: String? = nil, storageCompressionFormat: StorageCompressionFormat? = nil) {
            self.bucketArn = bucketArn
            self.dataFormat = dataFormat
            self.prefix = prefix
            self.storageCompressionFormat = storageCompressionFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, max: 100)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, min: 16)
            try self.validate(self.bucketArn, name: "bucketArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):s3:::.+$")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 512)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^[a-zA-Z0-9-_:./!*'()]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "bucketArn"
            case dataFormat = "dataFormat"
            case prefix = "prefix"
            case storageCompressionFormat = "storageCompressionFormat"
        }
    }

    public struct Sensor: AWSEncodableShape & AWSDecodableShape {
        /// A list of possible values a sensor can take.
        public let allowedValues: [String]?
        /// A comment in addition to the description.
        public let comment: String?
        /// The specified data type of the sensor.
        public let dataType: NodeDataType
        /// The deprecation message for the node or the branch that was moved or deleted.
        public let deprecationMessage: String?
        /// A brief description of a sensor.
        public let description: String?
        /// The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be Vehicle.Body.Engine.Battery.
        public let fullyQualifiedName: String
        /// The specified possible maximum value of the sensor.
        public let max: Double?
        /// The specified possible minimum value of the sensor.
        public let min: Double?
        /// The fully qualified name of the struct node for a sensor if the data type of the actuator is Struct or StructArray. For example, the struct fully qualified name of a sensor might be Vehicle.ADAS.CameraStruct.
        public let structFullyQualifiedName: String?
        /// The scientific unit of measurement for data collected by the sensor.
        public let unit: String?

        @inlinable
        public init(allowedValues: [String]? = nil, comment: String? = nil, dataType: NodeDataType, deprecationMessage: String? = nil, description: String? = nil, fullyQualifiedName: String, max: Double? = nil, min: Double? = nil, structFullyQualifiedName: String? = nil, unit: String? = nil) {
            self.allowedValues = allowedValues
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 2048)
            try self.validate(self.comment, name: "comment", parent: name, min: 1)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, max: 2048)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, min: 1)
            try self.validate(self.deprecationMessage, name: "deprecationMessage", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, max: 150)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, min: 1)
            try self.validate(self.structFullyQualifiedName, name: "structFullyQualifiedName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case comment = "comment"
            case dataType = "dataType"
            case deprecationMessage = "deprecationMessage"
            case description = "description"
            case fullyQualifiedName = "fullyQualifiedName"
            case max = "max"
            case min = "min"
            case structFullyQualifiedName = "structFullyQualifiedName"
            case unit = "unit"
        }
    }

    public struct SignalCatalogSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the signal catalog.
        public let arn: String?
        /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        /// The name of the signal catalog.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, lastModificationTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
        }
    }

    public struct SignalDecoder: AWSEncodableShape & AWSDecodableShape {
        /// Information about signal decoder using the Controller Area Network (CAN) protocol.
        public let canSignal: CanSignal?
        /// Information about a custom signal  decoder.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
        public let customDecodingSignal: CustomDecodingSignal?
        /// The fully qualified name of a signal decoder as defined in a vehicle model.
        public let fullyQualifiedName: String
        /// The ID of a network interface that specifies what network protocol a vehicle follows.
        public let interfaceId: String
        /// The decoding information for a specific message which supports higher order data types.
        public let messageSignal: MessageSignal?
        /// Information about signal decoder using the on-board diagnostic (OBD) II protocol.
        public let obdSignal: ObdSignal?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        public let type: SignalDecoderType

        @inlinable
        public init(canSignal: CanSignal? = nil, customDecodingSignal: CustomDecodingSignal? = nil, fullyQualifiedName: String, interfaceId: String, messageSignal: MessageSignal? = nil, obdSignal: ObdSignal? = nil, type: SignalDecoderType) {
            self.canSignal = canSignal
            self.customDecodingSignal = customDecodingSignal
            self.fullyQualifiedName = fullyQualifiedName
            self.interfaceId = interfaceId
            self.messageSignal = messageSignal
            self.obdSignal = obdSignal
            self.type = type
        }

        public func validate(name: String) throws {
            try self.canSignal?.validate(name: "\(name).canSignal")
            try self.customDecodingSignal?.validate(name: "\(name).customDecodingSignal")
            try self.validate(self.fullyQualifiedName, name: "fullyQualifiedName", parent: name, max: 150)
            try self.validate(self.fullyQualifiedName, name: "fullyQualifiedName", parent: name, min: 1)
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, max: 50)
            try self.validate(self.interfaceId, name: "interfaceId", parent: name, min: 1)
            try self.messageSignal?.validate(name: "\(name).messageSignal")
            try self.obdSignal?.validate(name: "\(name).obdSignal")
        }

        private enum CodingKeys: String, CodingKey {
            case canSignal = "canSignal"
            case customDecodingSignal = "customDecodingSignal"
            case fullyQualifiedName = "fullyQualifiedName"
            case interfaceId = "interfaceId"
            case messageSignal = "messageSignal"
            case obdSignal = "obdSignal"
            case type = "type"
        }
    }

    public struct SignalFetchInformation: AWSEncodableShape & AWSDecodableShape {
        /// The actions to be performed by the signal fetch.
        public let actions: [String]
        /// The version of the condition language used.
        public let conditionLanguageVersion: Int?
        /// The fully qualified name of the signal to be fetched.
        public let fullyQualifiedName: String
        /// The configuration of the signal fetch operation.
        public let signalFetchConfig: SignalFetchConfig

        @inlinable
        public init(actions: [String], conditionLanguageVersion: Int? = nil, fullyQualifiedName: String, signalFetchConfig: SignalFetchConfig) {
            self.actions = actions
            self.conditionLanguageVersion = conditionLanguageVersion
            self.fullyQualifiedName = fullyQualifiedName
            self.signalFetchConfig = signalFetchConfig
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try validate($0, name: "actions[]", parent: name, max: 100)
                try validate($0, name: "actions[]", parent: name, min: 1)
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 2)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.conditionLanguageVersion, name: "conditionLanguageVersion", parent: name, max: 1)
            try self.validate(self.conditionLanguageVersion, name: "conditionLanguageVersion", parent: name, min: 1)
            try self.validate(self.fullyQualifiedName, name: "fullyQualifiedName", parent: name, max: 150)
            try self.validate(self.fullyQualifiedName, name: "fullyQualifiedName", parent: name, min: 1)
            try self.validate(self.fullyQualifiedName, name: "fullyQualifiedName", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            try self.signalFetchConfig.validate(name: "\(name).signalFetchConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case conditionLanguageVersion = "conditionLanguageVersion"
            case fullyQualifiedName = "fullyQualifiedName"
            case signalFetchConfig = "signalFetchConfig"
        }
    }

    public struct SignalInformation: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the data partition this signal is associated with. The ID must match one of the IDs provided in dataPartitions. This is accomplished either by specifying a particular data partition ID or by using default for an established default partition. You can establish a default partition in the DataPartition data type.  If you upload a signal as a condition for a campaign's data partition, the same signal must be included in signalsToCollect.   Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
        public let dataPartitionId: String?
        /// The maximum number of samples to collect.
        public let maxSampleCount: Int64?
        /// The minimum duration of time (in milliseconds) between two triggering events to collect data.  If a signal changes often, you might want to collect data at a slower rate.
        public let minimumSamplingIntervalMs: Int64?
        /// The name of the signal.
        public let name: String

        @inlinable
        public init(dataPartitionId: String? = nil, maxSampleCount: Int64? = nil, minimumSamplingIntervalMs: Int64? = nil, name: String) {
            self.dataPartitionId = dataPartitionId
            self.maxSampleCount = maxSampleCount
            self.minimumSamplingIntervalMs = minimumSamplingIntervalMs
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.dataPartitionId, name: "dataPartitionId", parent: name, max: 128)
            try self.validate(self.dataPartitionId, name: "dataPartitionId", parent: name, min: 1)
            try self.validate(self.dataPartitionId, name: "dataPartitionId", parent: name, pattern: "^[a-zA-Z0-9]+$")
            try self.validate(self.maxSampleCount, name: "maxSampleCount", parent: name, max: 4294967295)
            try self.validate(self.maxSampleCount, name: "maxSampleCount", parent: name, min: 1)
            try self.validate(self.minimumSamplingIntervalMs, name: "minimumSamplingIntervalMs", parent: name, max: 4294967295)
            try self.validate(self.minimumSamplingIntervalMs, name: "minimumSamplingIntervalMs", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\w|*|-]+(\\.[\\w|*|-]+)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataPartitionId = "dataPartitionId"
            case maxSampleCount = "maxSampleCount"
            case minimumSamplingIntervalMs = "minimumSamplingIntervalMs"
            case name = "name"
        }
    }

    public struct StateTemplateAssociation: AWSEncodableShape & AWSDecodableShape {
        /// The unique ID of the state template.
        public let identifier: String
        public let stateTemplateUpdateStrategy: StateTemplateUpdateStrategy

        @inlinable
        public init(identifier: String, stateTemplateUpdateStrategy: StateTemplateUpdateStrategy) {
            self.identifier = identifier
            self.stateTemplateUpdateStrategy = stateTemplateUpdateStrategy
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 100)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.stateTemplateUpdateStrategy.validate(name: "\(name).stateTemplateUpdateStrategy")
        }

        private enum CodingKeys: String, CodingKey {
            case identifier = "identifier"
            case stateTemplateUpdateStrategy = "stateTemplateUpdateStrategy"
        }
    }

    public struct StateTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the state template.
        public let arn: String?
        /// The time the state template was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date?
        /// A brief description of the state template.
        public let description: String?
        /// The unique ID of the state template.
        public let id: String?
        /// The time the state template was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date?
        /// The name of the state template.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the signal catalog associated with the state template.
        public let signalCatalogArn: String?

        @inlinable
        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, id: String? = nil, lastModificationTime: Date? = nil, name: String? = nil, signalCatalogArn: String? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case lastModificationTime = "lastModificationTime"
            case name = "name"
            case signalCatalogArn = "signalCatalogArn"
        }
    }

    public struct StorageMaximumSize: AWSEncodableShape & AWSDecodableShape {
        /// The data type of the data to store.
        public let unit: StorageMaximumSizeUnit
        /// The maximum amount of time to store data.
        public let value: Int

        @inlinable
        public init(unit: StorageMaximumSizeUnit, value: Int) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1073741824)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct StorageMinimumTimeToLive: AWSEncodableShape & AWSDecodableShape {
        /// The time increment type.
        public let unit: StorageMinimumTimeToLiveUnit
        /// The minimum amount of time to store the data.
        public let value: Int

        @inlinable
        public init(unit: StorageMinimumTimeToLiveUnit, value: Int) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 876600)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct StructuredMessageFieldNameAndDataTypePair: AWSEncodableShape & AWSDecodableShape {
        /// The data type.
        public let dataType: StructuredMessage
        /// The field name of the structured message. It determines how a data value is referenced in the target language.
        public let fieldName: String

        @inlinable
        public init(dataType: StructuredMessage, fieldName: String) {
            self.dataType = dataType
            self.fieldName = fieldName
        }

        public func validate(name: String) throws {
            try self.dataType.validate(name: "\(name).dataType")
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 150)
            try self.validate(self.fieldName, name: "fieldName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataType = "dataType"
            case fieldName = "fieldName"
        }
    }

    public final class StructuredMessageListDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The capacity of the structured message list definition when the list type is FIXED_CAPACITY or DYNAMIC_BOUNDED_CAPACITY.
        public let capacity: Int?
        /// The type of list of the structured message list definition.
        public let listType: StructuredMessageListType
        /// The member type of the structured message list definition.
        public let memberType: StructuredMessage
        /// The name of the structured message list definition.
        public let name: String

        @inlinable
        public init(capacity: Int? = nil, listType: StructuredMessageListType, memberType: StructuredMessage, name: String) {
            self.capacity = capacity
            self.listType = listType
            self.memberType = memberType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.capacity, name: "capacity", parent: name, min: 0)
            try self.memberType.validate(name: "\(name).memberType")
            try self.validate(self.name, name: "name", parent: name, max: 150)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case capacity = "capacity"
            case listType = "listType"
            case memberType = "memberType"
            case name = "name"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag's key.
        public let key: String
        /// The tag's value.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// The new or modified tags for the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:.*")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The quota identifier of the applied throttling rules for this request.
        public let quotaCode: String?
        /// The number of seconds to wait before retrying the command.
        public let retryAfterSeconds: Int?
        /// The code for the service that couldn't be completed due to throttling.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct TimeBasedCollectionScheme: AWSEncodableShape & AWSDecodableShape {
        /// The time period (in milliseconds) to decide how often to collect data. For example, if the time period is 60000, the Edge Agent software collects data once every minute.
        public let periodMs: Int64

        @inlinable
        public init(periodMs: Int64) {
            self.periodMs = periodMs
        }

        public func validate(name: String) throws {
            try self.validate(self.periodMs, name: "periodMs", parent: name, max: 86400000)
            try self.validate(self.periodMs, name: "periodMs", parent: name, min: 10000)
        }

        private enum CodingKeys: String, CodingKey {
            case periodMs = "periodMs"
        }
    }

    public struct TimeBasedSignalFetchConfig: AWSEncodableShape & AWSDecodableShape {
        /// The frequency with which the signal fetch will be executed.
        public let executionFrequencyMs: Int64

        @inlinable
        public init(executionFrequencyMs: Int64) {
            self.executionFrequencyMs = executionFrequencyMs
        }

        public func validate(name: String) throws {
            try self.validate(self.executionFrequencyMs, name: "executionFrequencyMs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case executionFrequencyMs = "executionFrequencyMs"
        }
    }

    public struct TimePeriod: AWSEncodableShape & AWSDecodableShape {
        /// A unit of time.
        public let unit: TimeUnit
        /// A number of time units.
        public let value: Int

        @inlinable
        public init(unit: TimeUnit, value: Int) {
            self.unit = unit
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case unit = "unit"
            case value = "value"
        }
    }

    public struct TimestreamConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the task execution role that grants Amazon Web Services IoT FleetWise permission to deliver data to the Amazon Timestream table.
        public let executionRoleArn: String
        /// The Amazon Resource Name (ARN) of the Amazon Timestream table.
        public let timestreamTableArn: String

        @inlinable
        public init(executionRoleArn: String, timestreamTableArn: String) {
            self.executionRoleArn = executionRoleArn
            self.timestreamTableArn = timestreamTableArn
        }

        public func validate(name: String) throws {
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, max: 2048)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, min: 20)
            try self.validate(self.executionRoleArn, name: "executionRoleArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):iam::(\\d{12})?:(role((\\u002F)|(\\u002F[\\u0021-\\u007F]+\\u002F))[\\w+=,.@-]+)$")
            try self.validate(self.timestreamTableArn, name: "timestreamTableArn", parent: name, max: 2048)
            try self.validate(self.timestreamTableArn, name: "timestreamTableArn", parent: name, min: 20)
            try self.validate(self.timestreamTableArn, name: "timestreamTableArn", parent: name, pattern: "^arn:(aws[a-zA-Z0-9-]*):timestream:[a-zA-Z0-9-]+:[0-9]{12}:database/[a-zA-Z0-9_.-]+/table/[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case executionRoleArn = "executionRoleArn"
            case timestreamTableArn = "timestreamTableArn"
        }
    }

    public struct TimestreamRegistrationResponse: AWSDecodableShape {
        /// A message associated with a registration error.
        public let errorMessage: String?
        /// The status of registering your Amazon Timestream resources. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        public let registrationStatus: RegistrationStatus
        /// The Amazon Resource Name (ARN) of the Timestream database.
        public let timestreamDatabaseArn: String?
        /// The name of the Timestream database.
        public let timestreamDatabaseName: String
        /// The ARN of the Timestream database table.
        public let timestreamTableArn: String?
        /// The name of the Timestream database table.
        public let timestreamTableName: String

        @inlinable
        public init(errorMessage: String? = nil, registrationStatus: RegistrationStatus, timestreamDatabaseArn: String? = nil, timestreamDatabaseName: String, timestreamTableArn: String? = nil, timestreamTableName: String) {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.timestreamDatabaseArn = timestreamDatabaseArn
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableArn = timestreamTableArn
            self.timestreamTableName = timestreamTableName
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case registrationStatus = "registrationStatus"
            case timestreamDatabaseArn = "timestreamDatabaseArn"
            case timestreamDatabaseName = "timestreamDatabaseName"
            case timestreamTableArn = "timestreamTableArn"
            case timestreamTableName = "timestreamTableName"
        }
    }

    public struct TimestreamResources: AWSEncodableShape & AWSDecodableShape {
        /// The name of the registered Amazon Timestream database.
        public let timestreamDatabaseName: String
        /// The name of the registered Amazon Timestream database table.
        public let timestreamTableName: String

        @inlinable
        public init(timestreamDatabaseName: String, timestreamTableName: String) {
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableName = timestreamTableName
        }

        public func validate(name: String) throws {
            try self.validate(self.timestreamDatabaseName, name: "timestreamDatabaseName", parent: name, max: 255)
            try self.validate(self.timestreamDatabaseName, name: "timestreamDatabaseName", parent: name, min: 3)
            try self.validate(self.timestreamDatabaseName, name: "timestreamDatabaseName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.validate(self.timestreamTableName, name: "timestreamTableName", parent: name, max: 255)
            try self.validate(self.timestreamTableName, name: "timestreamTableName", parent: name, min: 3)
            try self.validate(self.timestreamTableName, name: "timestreamTableName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case timestreamDatabaseName = "timestreamDatabaseName"
            case timestreamTableName = "timestreamTableName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource.
        public let resourceARN: String
        /// A list of the keys of the tags to be removed from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCampaignRequest: AWSEncodableShape {
        ///  Specifies how to update a campaign. The action can be one of the following:    APPROVE - To approve delivering a data collection scheme to vehicles.     SUSPEND - To suspend collecting signal data. The campaign is deleted from vehicles and all vehicles in the suspended campaign will stop sending data.    RESUME - To reactivate the SUSPEND campaign. The campaign is redeployed to all vehicles and the vehicles will resume sending data.    UPDATE - To update a campaign.
        public let action: UpdateCampaignAction
        ///  A list of vehicle attributes to associate with a signal.  Default: An empty array
        public let dataExtraDimensions: [String]?
        /// The description of the campaign.
        public let description: String?
        ///  The name of the campaign to update.
        public let name: String

        @inlinable
        public init(action: UpdateCampaignAction, dataExtraDimensions: [String]? = nil, description: String? = nil, name: String) {
            self.action = action
            self.dataExtraDimensions = dataExtraDimensions
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.dataExtraDimensions, forKey: .dataExtraDimensions)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.dataExtraDimensions?.forEach {
                try validate($0, name: "dataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "dataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "dataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.dataExtraDimensions, name: "dataExtraDimensions", parent: name, max: 5)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case dataExtraDimensions = "dataExtraDimensions"
            case description = "description"
        }
    }

    public struct UpdateCampaignResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the campaign.
        public let arn: String?
        /// The name of the updated campaign.
        public let name: String?
        /// The state of a campaign. The status can be one of:    CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.     WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the  API operation to approve the campaign.     RUNNING - The campaign is active.     SUSPENDED - The campaign is suspended. To resume the campaign, use the  API operation.
        public let status: CampaignStatus?

        @inlinable
        public init(arn: String? = nil, name: String? = nil, status: CampaignStatus? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
            case status = "status"
        }
    }

    public struct UpdateDecoderManifestRequest: AWSEncodableShape {
        /// Use default decoders for all unmapped signals in the model. You don't need to provide any detailed decoding information.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
        public let defaultForUnmappedSignals: DefaultForUnmappedSignalsType?
        ///  A brief description of the decoder manifest to update.
        public let description: String?
        ///  The name of the decoder manifest to update.
        public let name: String
        ///  A list of information about the network interfaces to add to the decoder manifest.
        public let networkInterfacesToAdd: [NetworkInterface]?
        ///  A list of network interfaces to remove from the decoder manifest.
        public let networkInterfacesToRemove: [String]?
        ///  A list of information about the network interfaces to update in the decoder manifest.
        public let networkInterfacesToUpdate: [NetworkInterface]?
        ///  A list of information about decoding additional signals to add to the decoder manifest.
        public let signalDecodersToAdd: [SignalDecoder]?
        ///  A list of signal decoders to remove from the decoder manifest.
        public let signalDecodersToRemove: [String]?
        ///  A list of updated information about decoding signals to update in the decoder manifest.
        public let signalDecodersToUpdate: [SignalDecoder]?
        ///  The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is DRAFT, you can edit the decoder manifest.
        public let status: ManifestStatus?

        @inlinable
        public init(defaultForUnmappedSignals: DefaultForUnmappedSignalsType? = nil, description: String? = nil, name: String, networkInterfacesToAdd: [NetworkInterface]? = nil, networkInterfacesToRemove: [String]? = nil, networkInterfacesToUpdate: [NetworkInterface]? = nil, signalDecodersToAdd: [SignalDecoder]? = nil, signalDecodersToRemove: [String]? = nil, signalDecodersToUpdate: [SignalDecoder]? = nil, status: ManifestStatus? = nil) {
            self.defaultForUnmappedSignals = defaultForUnmappedSignals
            self.description = description
            self.name = name
            self.networkInterfacesToAdd = networkInterfacesToAdd
            self.networkInterfacesToRemove = networkInterfacesToRemove
            self.networkInterfacesToUpdate = networkInterfacesToUpdate
            self.signalDecodersToAdd = signalDecodersToAdd
            self.signalDecodersToRemove = signalDecodersToRemove
            self.signalDecodersToUpdate = signalDecodersToUpdate
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.defaultForUnmappedSignals, forKey: .defaultForUnmappedSignals)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.networkInterfacesToAdd, forKey: .networkInterfacesToAdd)
            try container.encodeIfPresent(self.networkInterfacesToRemove, forKey: .networkInterfacesToRemove)
            try container.encodeIfPresent(self.networkInterfacesToUpdate, forKey: .networkInterfacesToUpdate)
            try container.encodeIfPresent(self.signalDecodersToAdd, forKey: .signalDecodersToAdd)
            try container.encodeIfPresent(self.signalDecodersToRemove, forKey: .signalDecodersToRemove)
            try container.encodeIfPresent(self.signalDecodersToUpdate, forKey: .signalDecodersToUpdate)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.networkInterfacesToAdd?.forEach {
                try $0.validate(name: "\(name).networkInterfacesToAdd[]")
            }
            try self.validate(self.networkInterfacesToAdd, name: "networkInterfacesToAdd", parent: name, max: 500)
            try self.validate(self.networkInterfacesToAdd, name: "networkInterfacesToAdd", parent: name, min: 1)
            try self.networkInterfacesToRemove?.forEach {
                try validate($0, name: "networkInterfacesToRemove[]", parent: name, max: 50)
                try validate($0, name: "networkInterfacesToRemove[]", parent: name, min: 1)
            }
            try self.validate(self.networkInterfacesToRemove, name: "networkInterfacesToRemove", parent: name, max: 500)
            try self.validate(self.networkInterfacesToRemove, name: "networkInterfacesToRemove", parent: name, min: 1)
            try self.networkInterfacesToUpdate?.forEach {
                try $0.validate(name: "\(name).networkInterfacesToUpdate[]")
            }
            try self.validate(self.networkInterfacesToUpdate, name: "networkInterfacesToUpdate", parent: name, max: 500)
            try self.validate(self.networkInterfacesToUpdate, name: "networkInterfacesToUpdate", parent: name, min: 1)
            try self.signalDecodersToAdd?.forEach {
                try $0.validate(name: "\(name).signalDecodersToAdd[]")
            }
            try self.validate(self.signalDecodersToAdd, name: "signalDecodersToAdd", parent: name, max: 500)
            try self.validate(self.signalDecodersToAdd, name: "signalDecodersToAdd", parent: name, min: 1)
            try self.signalDecodersToRemove?.forEach {
                try validate($0, name: "signalDecodersToRemove[]", parent: name, max: 150)
                try validate($0, name: "signalDecodersToRemove[]", parent: name, min: 1)
            }
            try self.validate(self.signalDecodersToRemove, name: "signalDecodersToRemove", parent: name, max: 500)
            try self.validate(self.signalDecodersToRemove, name: "signalDecodersToRemove", parent: name, min: 1)
            try self.signalDecodersToUpdate?.forEach {
                try $0.validate(name: "\(name).signalDecodersToUpdate[]")
            }
            try self.validate(self.signalDecodersToUpdate, name: "signalDecodersToUpdate", parent: name, max: 500)
            try self.validate(self.signalDecodersToUpdate, name: "signalDecodersToUpdate", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultForUnmappedSignals = "defaultForUnmappedSignals"
            case description = "description"
            case networkInterfacesToAdd = "networkInterfacesToAdd"
            case networkInterfacesToRemove = "networkInterfacesToRemove"
            case networkInterfacesToUpdate = "networkInterfacesToUpdate"
            case signalDecodersToAdd = "signalDecodersToAdd"
            case signalDecodersToRemove = "signalDecodersToRemove"
            case signalDecodersToUpdate = "signalDecodersToUpdate"
            case status = "status"
        }
    }

    public struct UpdateDecoderManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the updated decoder manifest.
        public let arn: String
        ///  The name of the updated decoder manifest.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateFleetRequest: AWSEncodableShape {
        ///  An updated description of the fleet.
        public let description: String?
        ///  The ID of the fleet to update.
        public let fleetId: String

        @inlinable
        public init(description: String? = nil, fleetId: String) {
            self.description = description
            self.fleetId = fleetId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.fleetId, key: "fleetId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.fleetId, name: "fleetId", parent: name, max: 100)
            try self.validate(self.fleetId, name: "fleetId", parent: name, min: 1)
            try self.validate(self.fleetId, name: "fleetId", parent: name, pattern: "^[a-zA-Z0-9:_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateFleetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated fleet.
        public let arn: String?
        /// The ID of the updated fleet.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
        }
    }

    public struct UpdateModelManifestRequest: AWSEncodableShape {
        ///  A brief description of the vehicle model.
        public let description: String?
        ///  The name of the vehicle model to update.
        public let name: String
        ///  A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to add to the vehicle model.
        public let nodesToAdd: [String]?
        ///  A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to remove from the vehicle model.
        public let nodesToRemove: [String]?
        ///  The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
        public let status: ManifestStatus?

        @inlinable
        public init(description: String? = nil, name: String, nodesToAdd: [String]? = nil, nodesToRemove: [String]? = nil, status: ManifestStatus? = nil) {
            self.description = description
            self.name = name
            self.nodesToAdd = nodesToAdd
            self.nodesToRemove = nodesToRemove
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.nodesToAdd, forKey: .nodesToAdd)
            try container.encodeIfPresent(self.nodesToRemove, forKey: .nodesToRemove)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.nodesToAdd?.forEach {
                try validate($0, name: "nodesToAdd[]", parent: name, max: 150)
                try validate($0, name: "nodesToAdd[]", parent: name, min: 1)
                try validate($0, name: "nodesToAdd[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.nodesToAdd, name: "nodesToAdd", parent: name, max: 500)
            try self.validate(self.nodesToAdd, name: "nodesToAdd", parent: name, min: 1)
            try self.nodesToRemove?.forEach {
                try validate($0, name: "nodesToRemove[]", parent: name, max: 150)
                try validate($0, name: "nodesToRemove[]", parent: name, min: 1)
                try validate($0, name: "nodesToRemove[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, max: 500)
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodesToAdd = "nodesToAdd"
            case nodesToRemove = "nodesToRemove"
            case status = "status"
        }
    }

    public struct UpdateModelManifestResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the updated vehicle model.
        public let arn: String
        ///  The name of the updated vehicle model.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateSignalCatalogRequest: AWSEncodableShape {
        ///  A brief description of the signal catalog to update.
        public let description: String?
        ///  The name of the signal catalog to update.
        public let name: String
        ///  A list of information about nodes to add to the signal catalog.
        public let nodesToAdd: [Node]?
        ///  A list of fullyQualifiedName of nodes to remove from the signal catalog.
        public let nodesToRemove: [String]?
        ///  A list of information about nodes to update in the signal catalog.
        public let nodesToUpdate: [Node]?

        @inlinable
        public init(description: String? = nil, name: String, nodesToAdd: [Node]? = nil, nodesToRemove: [String]? = nil, nodesToUpdate: [Node]? = nil) {
            self.description = description
            self.name = name
            self.nodesToAdd = nodesToAdd
            self.nodesToRemove = nodesToRemove
            self.nodesToUpdate = nodesToUpdate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "name")
            try container.encodeIfPresent(self.nodesToAdd, forKey: .nodesToAdd)
            try container.encodeIfPresent(self.nodesToRemove, forKey: .nodesToRemove)
            try container.encodeIfPresent(self.nodesToUpdate, forKey: .nodesToUpdate)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.nodesToAdd?.forEach {
                try $0.validate(name: "\(name).nodesToAdd[]")
            }
            try self.validate(self.nodesToAdd, name: "nodesToAdd", parent: name, max: 500)
            try self.nodesToRemove?.forEach {
                try validate($0, name: "nodesToRemove[]", parent: name, max: 150)
                try validate($0, name: "nodesToRemove[]", parent: name, min: 1)
                try validate($0, name: "nodesToRemove[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, max: 500)
            try self.validate(self.nodesToRemove, name: "nodesToRemove", parent: name, min: 1)
            try self.nodesToUpdate?.forEach {
                try $0.validate(name: "\(name).nodesToUpdate[]")
            }
            try self.validate(self.nodesToUpdate, name: "nodesToUpdate", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case nodesToAdd = "nodesToAdd"
            case nodesToRemove = "nodesToRemove"
            case nodesToUpdate = "nodesToUpdate"
        }
    }

    public struct UpdateSignalCatalogResponse: AWSDecodableShape {
        ///  The ARN of the updated signal catalog.
        public let arn: String
        ///  The name of the updated signal catalog.
        public let name: String

        @inlinable
        public init(arn: String, name: String) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case name = "name"
        }
    }

    public struct UpdateStateTemplateRequest: AWSEncodableShape {
        /// A list of vehicle attributes to associate with the payload published on the state template's  MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will enrich the protobuf encoded payload with those attributes in the extraDimensions field. Default: An empty array
        public let dataExtraDimensions: [String]?
        /// A brief description of the state template.
        public let description: String?
        /// The unique ID of the state template.
        public let identifier: String
        /// A list of vehicle attributes to associate with user properties of the messages published on the state template's MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will include these attributes as User Properties with the MQTT message.
        public let metadataExtraDimensions: [String]?
        /// Add signals from which data is collected as part of the state template.
        public let stateTemplatePropertiesToAdd: [String]?
        /// Remove signals from which data is collected as part of the state template.
        public let stateTemplatePropertiesToRemove: [String]?

        @inlinable
        public init(dataExtraDimensions: [String]? = nil, description: String? = nil, identifier: String, metadataExtraDimensions: [String]? = nil, stateTemplatePropertiesToAdd: [String]? = nil, stateTemplatePropertiesToRemove: [String]? = nil) {
            self.dataExtraDimensions = dataExtraDimensions
            self.description = description
            self.identifier = identifier
            self.metadataExtraDimensions = metadataExtraDimensions
            self.stateTemplatePropertiesToAdd = stateTemplatePropertiesToAdd
            self.stateTemplatePropertiesToRemove = stateTemplatePropertiesToRemove
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.dataExtraDimensions, forKey: .dataExtraDimensions)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "identifier")
            try container.encodeIfPresent(self.metadataExtraDimensions, forKey: .metadataExtraDimensions)
            try container.encodeIfPresent(self.stateTemplatePropertiesToAdd, forKey: .stateTemplatePropertiesToAdd)
            try container.encodeIfPresent(self.stateTemplatePropertiesToRemove, forKey: .stateTemplatePropertiesToRemove)
        }

        public func validate(name: String) throws {
            try self.dataExtraDimensions?.forEach {
                try validate($0, name: "dataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "dataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "dataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.dataExtraDimensions, name: "dataExtraDimensions", parent: name, max: 5)
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[^\\u0000-\\u001F\\u007F]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 100)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            try self.metadataExtraDimensions?.forEach {
                try validate($0, name: "metadataExtraDimensions[]", parent: name, max: 150)
                try validate($0, name: "metadataExtraDimensions[]", parent: name, min: 1)
                try validate($0, name: "metadataExtraDimensions[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.metadataExtraDimensions, name: "metadataExtraDimensions", parent: name, max: 5)
            try self.stateTemplatePropertiesToAdd?.forEach {
                try validate($0, name: "stateTemplatePropertiesToAdd[]", parent: name, max: 150)
                try validate($0, name: "stateTemplatePropertiesToAdd[]", parent: name, min: 1)
                try validate($0, name: "stateTemplatePropertiesToAdd[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.stateTemplatePropertiesToAdd, name: "stateTemplatePropertiesToAdd", parent: name, max: 500)
            try self.validate(self.stateTemplatePropertiesToAdd, name: "stateTemplatePropertiesToAdd", parent: name, min: 1)
            try self.stateTemplatePropertiesToRemove?.forEach {
                try validate($0, name: "stateTemplatePropertiesToRemove[]", parent: name, max: 150)
                try validate($0, name: "stateTemplatePropertiesToRemove[]", parent: name, min: 1)
                try validate($0, name: "stateTemplatePropertiesToRemove[]", parent: name, pattern: "^[a-zA-Z0-9_.]+$")
            }
            try self.validate(self.stateTemplatePropertiesToRemove, name: "stateTemplatePropertiesToRemove", parent: name, max: 500)
            try self.validate(self.stateTemplatePropertiesToRemove, name: "stateTemplatePropertiesToRemove", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataExtraDimensions = "dataExtraDimensions"
            case description = "description"
            case metadataExtraDimensions = "metadataExtraDimensions"
            case stateTemplatePropertiesToAdd = "stateTemplatePropertiesToAdd"
            case stateTemplatePropertiesToRemove = "stateTemplatePropertiesToRemove"
        }
    }

    public struct UpdateStateTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the state template.
        public let arn: String?
        /// The unique ID of the state template.
        public let id: String?
        /// The name of the state template.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
        }
    }

    public struct UpdateVehicleError: AWSDecodableShape {
        /// The relevant HTTP error code (400+).
        public let code: Int?
        /// A message associated with the error.
        public let message: String?
        /// The ID of the vehicle with the error.
        public let vehicleName: String?

        @inlinable
        public init(code: Int? = nil, message: String? = nil, vehicleName: String? = nil) {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case vehicleName = "vehicleName"
        }
    }

    public struct UpdateVehicleRequest: AWSEncodableShape {
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
        public let attributeUpdateMode: UpdateMode?
        /// The ARN of the decoder manifest associated with this vehicle.
        public let decoderManifestArn: String?
        /// The ARN of a vehicle model (model manifest) associated with the vehicle.
        public let modelManifestArn: String?
        /// Associate state templates with the vehicle.
        public let stateTemplatesToAdd: [StateTemplateAssociation]?
        /// Remove state templates from the vehicle.
        public let stateTemplatesToRemove: [String]?
        /// Change the stateTemplateUpdateStrategy of state templates already associated with the vehicle.
        public let stateTemplatesToUpdate: [StateTemplateAssociation]?
        /// The unique ID of the vehicle to update.
        public let vehicleName: String

        @inlinable
        public init(attributes: [String: String]? = nil, attributeUpdateMode: UpdateMode? = nil, decoderManifestArn: String? = nil, modelManifestArn: String? = nil, stateTemplatesToAdd: [StateTemplateAssociation]? = nil, stateTemplatesToRemove: [String]? = nil, stateTemplatesToUpdate: [StateTemplateAssociation]? = nil, vehicleName: String) {
            self.attributes = attributes
            self.attributeUpdateMode = attributeUpdateMode
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.stateTemplatesToAdd = stateTemplatesToAdd
            self.stateTemplatesToRemove = stateTemplatesToRemove
            self.stateTemplatesToUpdate = stateTemplatesToUpdate
            self.vehicleName = vehicleName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.attributes, forKey: .attributes)
            try container.encodeIfPresent(self.attributeUpdateMode, forKey: .attributeUpdateMode)
            try container.encodeIfPresent(self.decoderManifestArn, forKey: .decoderManifestArn)
            try container.encodeIfPresent(self.modelManifestArn, forKey: .modelManifestArn)
            try container.encodeIfPresent(self.stateTemplatesToAdd, forKey: .stateTemplatesToAdd)
            try container.encodeIfPresent(self.stateTemplatesToRemove, forKey: .stateTemplatesToRemove)
            try container.encodeIfPresent(self.stateTemplatesToUpdate, forKey: .stateTemplatesToUpdate)
            request.encodePath(self.vehicleName, key: "vehicleName")
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.stateTemplatesToAdd?.forEach {
                try $0.validate(name: "\(name).stateTemplatesToAdd[]")
            }
            try self.validate(self.stateTemplatesToAdd, name: "stateTemplatesToAdd", parent: name, max: 20)
            try self.validate(self.stateTemplatesToAdd, name: "stateTemplatesToAdd", parent: name, min: 1)
            try self.stateTemplatesToRemove?.forEach {
                try validate($0, name: "stateTemplatesToRemove[]", parent: name, max: 100)
                try validate($0, name: "stateTemplatesToRemove[]", parent: name, min: 1)
                try validate($0, name: "stateTemplatesToRemove[]", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            }
            try self.validate(self.stateTemplatesToRemove, name: "stateTemplatesToRemove", parent: name, max: 20)
            try self.validate(self.stateTemplatesToRemove, name: "stateTemplatesToRemove", parent: name, min: 1)
            try self.stateTemplatesToUpdate?.forEach {
                try $0.validate(name: "\(name).stateTemplatesToUpdate[]")
            }
            try self.validate(self.stateTemplatesToUpdate, name: "stateTemplatesToUpdate", parent: name, max: 20)
            try self.validate(self.stateTemplatesToUpdate, name: "stateTemplatesToUpdate", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case attributeUpdateMode = "attributeUpdateMode"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
            case stateTemplatesToAdd = "stateTemplatesToAdd"
            case stateTemplatesToRemove = "stateTemplatesToRemove"
            case stateTemplatesToUpdate = "stateTemplatesToUpdate"
        }
    }

    public struct UpdateVehicleRequestItem: AWSEncodableShape {
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
        public let attributeUpdateMode: UpdateMode?
        /// The ARN of the signal decoder manifest associated with the vehicle to update.
        public let decoderManifestArn: String?
        /// The ARN of the vehicle model (model manifest) associated with the vehicle to update.
        public let modelManifestArn: String?
        /// Associate additional state templates to track the state of the vehicle. State templates determine which signal updates the vehicle sends to the cloud.
        public let stateTemplatesToAdd: [StateTemplateAssociation]?
        /// Remove existing state template associations from the vehicle.
        public let stateTemplatesToRemove: [String]?
        /// Change the stateTemplateUpdateStrategy of state templates already associated with the vehicle.
        public let stateTemplatesToUpdate: [StateTemplateAssociation]?
        /// The unique ID of the vehicle to update.
        public let vehicleName: String

        @inlinable
        public init(attributes: [String: String]? = nil, attributeUpdateMode: UpdateMode? = nil, decoderManifestArn: String? = nil, modelManifestArn: String? = nil, stateTemplatesToAdd: [StateTemplateAssociation]? = nil, stateTemplatesToRemove: [String]? = nil, stateTemplatesToUpdate: [StateTemplateAssociation]? = nil, vehicleName: String) {
            self.attributes = attributes
            self.attributeUpdateMode = attributeUpdateMode
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.stateTemplatesToAdd = stateTemplatesToAdd
            self.stateTemplatesToRemove = stateTemplatesToRemove
            self.stateTemplatesToUpdate = stateTemplatesToUpdate
            self.vehicleName = vehicleName
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 150)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.key, name: "attributes.key", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            }
            try self.stateTemplatesToAdd?.forEach {
                try $0.validate(name: "\(name).stateTemplatesToAdd[]")
            }
            try self.validate(self.stateTemplatesToAdd, name: "stateTemplatesToAdd", parent: name, max: 20)
            try self.validate(self.stateTemplatesToAdd, name: "stateTemplatesToAdd", parent: name, min: 1)
            try self.stateTemplatesToRemove?.forEach {
                try validate($0, name: "stateTemplatesToRemove[]", parent: name, max: 100)
                try validate($0, name: "stateTemplatesToRemove[]", parent: name, min: 1)
                try validate($0, name: "stateTemplatesToRemove[]", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
            }
            try self.validate(self.stateTemplatesToRemove, name: "stateTemplatesToRemove", parent: name, max: 20)
            try self.validate(self.stateTemplatesToRemove, name: "stateTemplatesToRemove", parent: name, min: 1)
            try self.stateTemplatesToUpdate?.forEach {
                try $0.validate(name: "\(name).stateTemplatesToUpdate[]")
            }
            try self.validate(self.stateTemplatesToUpdate, name: "stateTemplatesToUpdate", parent: name, max: 20)
            try self.validate(self.stateTemplatesToUpdate, name: "stateTemplatesToUpdate", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, max: 100)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, min: 1)
            try self.validate(self.vehicleName, name: "vehicleName", parent: name, pattern: "^[a-zA-Z\\d\\-_:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case attributeUpdateMode = "attributeUpdateMode"
            case decoderManifestArn = "decoderManifestArn"
            case modelManifestArn = "modelManifestArn"
            case stateTemplatesToAdd = "stateTemplatesToAdd"
            case stateTemplatesToRemove = "stateTemplatesToRemove"
            case stateTemplatesToUpdate = "stateTemplatesToUpdate"
            case vehicleName = "vehicleName"
        }
    }

    public struct UpdateVehicleResponse: AWSDecodableShape {
        /// The ARN of the updated vehicle.
        public let arn: String?
        /// The ID of the updated vehicle.
        public let vehicleName: String?

        @inlinable
        public init(arn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case vehicleName = "vehicleName"
        }
    }

    public struct UpdateVehicleResponseItem: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the updated vehicle.
        public let arn: String?
        /// The unique ID of the updated vehicle.
        public let vehicleName: String?

        @inlinable
        public init(arn: String? = nil, vehicleName: String? = nil) {
            self.arn = arn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case vehicleName = "vehicleName"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The list of fields that fail to satisfy the constraints specified by an Amazon Web Services service.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason the input failed to satisfy the constraints specified by an Amazon Web Services service.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason? = nil) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message about the validation error.
        public let message: String
        /// The name of the parameter field with the validation error.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct VehicleMiddleware: AWSEncodableShape & AWSDecodableShape {
        /// The name of the vehicle middleware.
        public let name: String
        /// The protocol name of the vehicle middleware.
        public let protocolName: VehicleMiddlewareProtocol

        @inlinable
        public init(name: String, protocolName: VehicleMiddlewareProtocol) {
            self.name = name
            self.protocolName = protocolName
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case protocolName = "protocolName"
        }
    }

    public struct VehicleStatus: AWSDecodableShape {
        /// The name of a campaign.
        public let campaignName: String?
        /// The status of a campaign, which can be one of the following:    CREATED - The campaign has been created successfully but has not been approved.     READY - The campaign has been approved but has not been deployed to the vehicle.    HEALTHY - The campaign has been deployed to the vehicle.      SUSPENDED - The campaign has been suspended and data collection is  paused.     DELETING - The campaign is being removed from the vehicle.
        public let status: VehicleState?
        /// The unique ID of the vehicle.
        public let vehicleName: String?

        @inlinable
        public init(campaignName: String? = nil, status: VehicleState? = nil, vehicleName: String? = nil) {
            self.campaignName = campaignName
            self.status = status
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case campaignName = "campaignName"
            case status = "status"
            case vehicleName = "vehicleName"
        }
    }

    public struct VehicleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the vehicle.
        public let arn: String
        /// Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
        public let attributes: [String: String]?
        /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let creationTime: Date
        /// The ARN of a decoder manifest associated with the vehicle.
        public let decoderManifestArn: String
        /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public let lastModificationTime: Date
        /// The ARN of a vehicle model (model manifest) associated with the vehicle.
        public let modelManifestArn: String
        /// The unique ID of the vehicle.
        public let vehicleName: String

        @inlinable
        public init(arn: String, attributes: [String: String]? = nil, creationTime: Date, decoderManifestArn: String, lastModificationTime: Date, modelManifestArn: String, vehicleName: String) {
            self.arn = arn
            self.attributes = attributes
            self.creationTime = creationTime
            self.decoderManifestArn = decoderManifestArn
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case attributes = "attributes"
            case creationTime = "creationTime"
            case decoderManifestArn = "decoderManifestArn"
            case lastModificationTime = "lastModificationTime"
            case modelManifestArn = "modelManifestArn"
            case vehicleName = "vehicleName"
        }
    }

    public struct FormattedVss: AWSEncodableShape {
        /// Provides the VSS in JSON format.
        public let vssJson: String?

        @inlinable
        public init(vssJson: String? = nil) {
            self.vssJson = vssJson
        }

        private enum CodingKeys: String, CodingKey {
            case vssJson = "vssJson"
        }
    }

    public struct NetworkFileDefinition: AWSEncodableShape {
        /// Information, including CAN DBC files, about the configurations used to create a decoder manifest.
        public let canDbc: CanDbcDefinition?

        @inlinable
        public init(canDbc: CanDbcDefinition? = nil) {
            self.canDbc = canDbc
        }

        public func validate(name: String) throws {
            try self.canDbc?.validate(name: "\(name).canDbc")
        }

        private enum CodingKeys: String, CodingKey {
            case canDbc = "canDbc"
        }
    }

    public struct PrimitiveMessageDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Information about a PrimitiveMessage using a ROS 2 compliant primitive type message of the complex data structure.
        public let ros2PrimitiveMessageDefinition: ROS2PrimitiveMessageDefinition?

        @inlinable
        public init(ros2PrimitiveMessageDefinition: ROS2PrimitiveMessageDefinition? = nil) {
            self.ros2PrimitiveMessageDefinition = ros2PrimitiveMessageDefinition
        }

        public func validate(name: String) throws {
            try self.ros2PrimitiveMessageDefinition?.validate(name: "\(name).ros2PrimitiveMessageDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case ros2PrimitiveMessageDefinition = "ros2PrimitiveMessageDefinition"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTFleetWise
public struct IoTFleetWiseErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case decoderManifestValidationException = "DecoderManifestValidationException"
        case internalServerException = "InternalServerException"
        case invalidNodeException = "InvalidNodeException"
        case invalidSignalsException = "InvalidSignalsException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTFleetWise
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient permission to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request couldn't be completed because it contains signal decoders with one or more validation errors.
    public static var decoderManifestValidationException: Self { .init(.decoderManifestValidationException) }
    /// The request couldn't be completed because the server temporarily failed.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified node type doesn't match the expected node type for a node. You can specify the node type as branch, sensor, actuator, or attribute.
    public static var invalidNodeException: Self { .init(.invalidNodeException) }
    /// The request couldn't be completed because it contains signals that aren't valid.
    public static var invalidSignalsException: Self { .init(.invalidSignalsException) }
    /// A service quota was exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The resource wasn't found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request couldn't be completed due to throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension IoTFleetWiseErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": IoTFleetWise.ConflictException.self,
        "DecoderManifestValidationException": IoTFleetWise.DecoderManifestValidationException.self,
        "InternalServerException": IoTFleetWise.InternalServerException.self,
        "InvalidNodeException": IoTFleetWise.InvalidNodeException.self,
        "InvalidSignalsException": IoTFleetWise.InvalidSignalsException.self,
        "LimitExceededException": IoTFleetWise.LimitExceededException.self,
        "ResourceNotFoundException": IoTFleetWise.ResourceNotFoundException.self,
        "ThrottlingException": IoTFleetWise.ThrottlingException.self,
        "ValidationException": IoTFleetWise.ValidationException.self
    ]
}

extension IoTFleetWiseErrorType: Equatable {
    public static func == (lhs: IoTFleetWiseErrorType, rhs: IoTFleetWiseErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTFleetWiseErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
