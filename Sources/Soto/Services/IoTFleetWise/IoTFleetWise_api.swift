//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS IoTFleetWise service.
///
/// Amazon Web Services IoT FleetWise is a fully managed service that you can use to collect, model, and transfer vehicle data to the Amazon Web Services cloud at scale. With Amazon Web Services IoT FleetWise, you can standardize all of your vehicle data models, independent of the in-vehicle communication architecture, and define data collection rules to transfer only high-value data to the cloud.  For more information, see What is Amazon Web Services IoT FleetWise? in the Amazon Web Services IoT FleetWise Developer Guide.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
public struct IoTFleetWise: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the IoTFleetWise client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "IoTAutobahnControlPlane",
            serviceName: "IoTFleetWise",
            serviceIdentifier: "iotfleetwise",
            serviceProtocol: .json(version: "1.0"),
            apiVersion: "2021-06-17",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: IoTFleetWiseErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.dualstack]: .init(endpoints: [
            "ap-south-1": "iotfleetwise.ap-south-1.api.aws",
            "eu-central-1": "iotfleetwise.eu-central-1.api.aws",
            "us-east-1": "iotfleetwise.us-east-1.api.aws"
        ])
    ]}

    // MARK: API Calls

    ///  Adds, or associates, a vehicle with a fleet.
    @Sendable
    @inlinable
    public func associateVehicleFleet(_ input: AssociateVehicleFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> AssociateVehicleFleetResponse {
        try await self.client.execute(
            operation: "AssociateVehicleFleet", 
            path: "/vehicles/{vehicleName}/associate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Adds, or associates, a vehicle with a fleet.
    ///
    /// Parameters:
    ///   - fleetId:  The ID of a fleet.
    ///   - vehicleName:  The unique ID of the vehicle to associate with the fleet.
    ///   - logger: Logger use during operation
    @inlinable
    public func associateVehicleFleet(
        fleetId: String,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> AssociateVehicleFleetResponse {
        let input = AssociateVehicleFleetRequest(
            fleetId: fleetId, 
            vehicleName: vehicleName
        )
        return try await self.associateVehicleFleet(input, logger: logger)
    }

    ///  Creates a group, or batch, of vehicles.   You must specify a decoder manifest and a vehicle model (model manifest) for each vehicle.   For more information, see Create multiple vehicles (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func batchCreateVehicle(_ input: BatchCreateVehicleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchCreateVehicleResponse {
        try await self.client.execute(
            operation: "BatchCreateVehicle", 
            path: "/vehicles", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a group, or batch, of vehicles.   You must specify a decoder manifest and a vehicle model (model manifest) for each vehicle.   For more information, see Create multiple vehicles (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - vehicles:  A list of information about each vehicle to create. For more information, see the API data type.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchCreateVehicle(
        vehicles: [CreateVehicleRequestItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchCreateVehicleResponse {
        let input = BatchCreateVehicleRequest(
            vehicles: vehicles
        )
        return try await self.batchCreateVehicle(input, logger: logger)
    }

    ///  Updates a group, or batch, of vehicles.  You must specify a decoder manifest and a vehicle model (model manifest) for each vehicle.   For more information, see Update multiple vehicles (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func batchUpdateVehicle(_ input: BatchUpdateVehicleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> BatchUpdateVehicleResponse {
        try await self.client.execute(
            operation: "BatchUpdateVehicle", 
            path: "/vehicles", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a group, or batch, of vehicles.  You must specify a decoder manifest and a vehicle model (model manifest) for each vehicle.   For more information, see Update multiple vehicles (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - vehicles:  A list of information about the vehicles to update. For more information, see the API data type.
    ///   - logger: Logger use during operation
    @inlinable
    public func batchUpdateVehicle(
        vehicles: [UpdateVehicleRequestItem],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> BatchUpdateVehicleResponse {
        let input = BatchUpdateVehicleRequest(
            vehicles: vehicles
        )
        return try await self.batchUpdateVehicle(input, logger: logger)
    }

    /// Creates an orchestration of data collection rules. The Amazon Web Services IoT FleetWise Edge Agent software running in vehicles uses campaigns to decide how to collect and transfer data to the cloud. You create campaigns in the cloud. After you or your team approve campaigns, Amazon Web Services IoT FleetWise automatically deploys them to vehicles.  For more information, see Collect and transfer data with campaigns in the Amazon Web Services IoT FleetWise Developer Guide.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func createCampaign(_ input: CreateCampaignRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateCampaignResponse {
        try await self.client.execute(
            operation: "CreateCampaign", 
            path: "/campaigns/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates an orchestration of data collection rules. The Amazon Web Services IoT FleetWise Edge Agent software running in vehicles uses campaigns to decide how to collect and transfer data to the cloud. You create campaigns in the cloud. After you or your team approve campaigns, Amazon Web Services IoT FleetWise automatically deploys them to vehicles.  For more information, see Collect and transfer data with campaigns in the Amazon Web Services IoT FleetWise Developer Guide.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - collectionScheme:  The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.
    ///   - compression: Determines whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use OFF. If it's not specified, SNAPPY is used.  Default: SNAPPY
    ///   - dataDestinationConfigs: The destination where the campaign sends data. You can send data to an MQTT topic, or store it in Amazon S3 or Amazon Timestream. MQTT is the publish/subscribe messaging protocol used by Amazon Web Services IoT to communicate with your devices. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle  data, such as data lakes, centralized data storage, data processing pipelines, and analytics.  Amazon Web Services IoT FleetWise supports at-least-once file delivery to S3. Your vehicle data is stored on multiple  Amazon Web Services IoT FleetWise servers for redundancy and high availability. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
    ///   - dataExtraDimensions: A list of vehicle attributes to associate with a campaign.  Enrich the data with specified vehicle attributes. For example, add make and model to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against make and model. Default: An empty array
    ///   - dataPartitions: The data partitions associated with the signals collected from the vehicle.
    ///   - description: An optional description of the campaign to help identify its purpose.
    ///   - diagnosticsMode: Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use SEND_ACTIVE_DTCS. If it's not specified, OFF is used. Default: OFF
    ///   - expiryTime: The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data isn't collected after the campaign expires.  Default: 253402214400 (December 31, 9999, 00:00:00 UTC)
    ///   - name:  The name of the campaign to create.
    ///   - postTriggerCollectionDuration: How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, 0 is used. Default: 0
    ///   - signalCatalogArn: The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign.
    ///   - signalsToCollect: A list of information about signals to collect.   If you upload a signal as a condition in a data partition for a campaign, then those same signals must be included in signalsToCollect.
    ///   - signalsToFetch: A list of information about signals to fetch.
    ///   - spoolingMode: Determines whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use TO_DISK. If it's not specified, OFF is used. Default: OFF
    ///   - startTime: The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, 0 is used. Default: 0
    ///   - tags: Metadata that can be used to manage the campaign.
    ///   - targetArn:  The ARN of the vehicle or fleet to deploy a campaign to.
    ///   - logger: Logger use during operation
    @inlinable
    public func createCampaign(
        collectionScheme: CollectionScheme,
        compression: Compression? = nil,
        dataDestinationConfigs: [DataDestinationConfig]? = nil,
        dataExtraDimensions: [String]? = nil,
        dataPartitions: [DataPartition]? = nil,
        description: String? = nil,
        diagnosticsMode: DiagnosticsMode? = nil,
        expiryTime: Date? = nil,
        name: String,
        postTriggerCollectionDuration: Int64? = nil,
        signalCatalogArn: String,
        signalsToCollect: [SignalInformation]? = nil,
        signalsToFetch: [SignalFetchInformation]? = nil,
        spoolingMode: SpoolingMode? = nil,
        startTime: Date? = nil,
        tags: [Tag]? = nil,
        targetArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateCampaignResponse {
        let input = CreateCampaignRequest(
            collectionScheme: collectionScheme, 
            compression: compression, 
            dataDestinationConfigs: dataDestinationConfigs, 
            dataExtraDimensions: dataExtraDimensions, 
            dataPartitions: dataPartitions, 
            description: description, 
            diagnosticsMode: diagnosticsMode, 
            expiryTime: expiryTime, 
            name: name, 
            postTriggerCollectionDuration: postTriggerCollectionDuration, 
            signalCatalogArn: signalCatalogArn, 
            signalsToCollect: signalsToCollect, 
            signalsToFetch: signalsToFetch, 
            spoolingMode: spoolingMode, 
            startTime: startTime, 
            tags: tags, 
            targetArn: targetArn
        )
        return try await self.createCampaign(input, logger: logger)
    }

    /// Creates the decoder manifest associated with a model manifest. To create a decoder manifest, the following must be true:   Every signal decoder has a unique name.   Each signal decoder is associated with a network interface.   Each network interface has a unique ID.   The signal decoders are specified in the model manifest.
    @Sendable
    @inlinable
    public func createDecoderManifest(_ input: CreateDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDecoderManifestResponse {
        try await self.client.execute(
            operation: "CreateDecoderManifest", 
            path: "/decoder-manifests/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates the decoder manifest associated with a model manifest. To create a decoder manifest, the following must be true:   Every signal decoder has a unique name.   Each signal decoder is associated with a network interface.   Each network interface has a unique ID.   The signal decoders are specified in the model manifest.
    ///
    /// Parameters:
    ///   - defaultForUnmappedSignals: Use default decoders for all unmapped signals in the model. You don't need to provide any detailed decoding information.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///   - description: A brief description of the decoder manifest.
    ///   - modelManifestArn:  The Amazon Resource Name (ARN) of the vehicle model (model manifest).
    ///   - name:  The unique name of the decoder manifest to create.
    ///   - networkInterfaces:  A list of information about available network interfaces.
    ///   - signalDecoders:  A list of information about signal decoders.
    ///   - tags: Metadata that can be used to manage the decoder manifest.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDecoderManifest(
        defaultForUnmappedSignals: DefaultForUnmappedSignalsType? = nil,
        description: String? = nil,
        modelManifestArn: String,
        name: String,
        networkInterfaces: [NetworkInterface]? = nil,
        signalDecoders: [SignalDecoder]? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDecoderManifestResponse {
        let input = CreateDecoderManifestRequest(
            defaultForUnmappedSignals: defaultForUnmappedSignals, 
            description: description, 
            modelManifestArn: modelManifestArn, 
            name: name, 
            networkInterfaces: networkInterfaces, 
            signalDecoders: signalDecoders, 
            tags: tags
        )
        return try await self.createDecoderManifest(input, logger: logger)
    }

    ///  Creates a fleet that represents a group of vehicles.   You must create both a signal catalog and vehicles before you can create a fleet.   For more information, see Fleets in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func createFleet(_ input: CreateFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateFleetResponse {
        try await self.client.execute(
            operation: "CreateFleet", 
            path: "/fleets/{fleetId}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a fleet that represents a group of vehicles.   You must create both a signal catalog and vehicles before you can create a fleet.   For more information, see Fleets in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - description:  A brief description of the fleet to create.
    ///   - fleetId:  The unique ID of the fleet to create.
    ///   - signalCatalogArn:  The Amazon Resource Name (ARN) of a signal catalog.
    ///   - tags: Metadata that can be used to manage the fleet.
    ///   - logger: Logger use during operation
    @inlinable
    public func createFleet(
        description: String? = nil,
        fleetId: String,
        signalCatalogArn: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateFleetResponse {
        let input = CreateFleetRequest(
            description: description, 
            fleetId: fleetId, 
            signalCatalogArn: signalCatalogArn, 
            tags: tags
        )
        return try await self.createFleet(input, logger: logger)
    }

    ///  Creates a vehicle model (model manifest) that specifies signals (attributes, branches, sensors, and actuators).  For more information, see Vehicle models in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func createModelManifest(_ input: CreateModelManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateModelManifestResponse {
        try await self.client.execute(
            operation: "CreateModelManifest", 
            path: "/model-manifests/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a vehicle model (model manifest) that specifies signals (attributes, branches, sensors, and actuators).  For more information, see Vehicle models in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - description:  A brief description of the vehicle model.
    ///   - name:  The name of the vehicle model to create.
    ///   - nodes:  A list of nodes, which are a general abstraction of signals.
    ///   - signalCatalogArn:  The Amazon Resource Name (ARN) of a signal catalog.
    ///   - tags: Metadata that can be used to manage the vehicle model.
    ///   - logger: Logger use during operation
    @inlinable
    public func createModelManifest(
        description: String? = nil,
        name: String,
        nodes: [String],
        signalCatalogArn: String,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateModelManifestResponse {
        let input = CreateModelManifestRequest(
            description: description, 
            name: name, 
            nodes: nodes, 
            signalCatalogArn: signalCatalogArn, 
            tags: tags
        )
        return try await self.createModelManifest(input, logger: logger)
    }

    ///  Creates a collection of standardized signals that can be reused to create vehicle models.
    @Sendable
    @inlinable
    public func createSignalCatalog(_ input: CreateSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSignalCatalogResponse {
        try await self.client.execute(
            operation: "CreateSignalCatalog", 
            path: "/signal-catalogs/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a collection of standardized signals that can be reused to create vehicle models.
    ///
    /// Parameters:
    ///   - description: A brief description of the signal catalog.
    ///   - name:  The name of the signal catalog to create.
    ///   - nodes:  A list of information about nodes, which are a general abstraction of signals. For more information, see the  API data type.
    ///   - tags: Metadata that can be used to manage the signal catalog.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSignalCatalog(
        description: String? = nil,
        name: String,
        nodes: [Node]? = nil,
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSignalCatalogResponse {
        let input = CreateSignalCatalogRequest(
            description: description, 
            name: name, 
            nodes: nodes, 
            tags: tags
        )
        return try await self.createSignalCatalog(input, logger: logger)
    }

    /// Creates a state template. State templates contain state properties, which are signals that belong to a signal catalog that is synchronized between the Amazon Web Services IoT FleetWise Edge and the Amazon Web Services Cloud.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func createStateTemplate(_ input: CreateStateTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateStateTemplateResponse {
        try await self.client.execute(
            operation: "CreateStateTemplate", 
            path: "/state-templates/{name}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a state template. State templates contain state properties, which are signals that belong to a signal catalog that is synchronized between the Amazon Web Services IoT FleetWise Edge and the Amazon Web Services Cloud.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - dataExtraDimensions: A list of vehicle attributes to associate with the payload published on the state template's  MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will enrich the protobuf encoded payload with those attributes in the extraDimensions field.
    ///   - description: A brief description of the state template.
    ///   - metadataExtraDimensions: A list of vehicle attributes to associate with user properties of the messages published on the state template's MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will include these attributes as User Properties with the MQTT message. Default: An empty array
    ///   - name: The name of the state template.
    ///   - signalCatalogArn: The ARN of the signal catalog associated with the state template.
    ///   - stateTemplateProperties: A list of signals from which data is collected. The state template properties contain the fully qualified names of the signals.
    ///   - tags: Metadata that can be used to manage the state template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createStateTemplate(
        dataExtraDimensions: [String]? = nil,
        description: String? = nil,
        metadataExtraDimensions: [String]? = nil,
        name: String,
        signalCatalogArn: String,
        stateTemplateProperties: [String],
        tags: [Tag]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateStateTemplateResponse {
        let input = CreateStateTemplateRequest(
            dataExtraDimensions: dataExtraDimensions, 
            description: description, 
            metadataExtraDimensions: metadataExtraDimensions, 
            name: name, 
            signalCatalogArn: signalCatalogArn, 
            stateTemplateProperties: stateTemplateProperties, 
            tags: tags
        )
        return try await self.createStateTemplate(input, logger: logger)
    }

    ///  Creates a vehicle, which is an instance of a vehicle model (model manifest). Vehicles created from the same vehicle model consist of the same signals inherited from the vehicle model.  If you have an existing Amazon Web Services IoT thing, you can use Amazon Web Services IoT FleetWise to create a vehicle and collect data from your thing.   For more information, see Create a vehicle (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func createVehicle(_ input: CreateVehicleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVehicleResponse {
        try await self.client.execute(
            operation: "CreateVehicle", 
            path: "/vehicles/{vehicleName}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a vehicle, which is an instance of a vehicle model (model manifest). Vehicles created from the same vehicle model consist of the same signals inherited from the vehicle model.  If you have an existing Amazon Web Services IoT thing, you can use Amazon Web Services IoT FleetWise to create a vehicle and collect data from your thing.   For more information, see Create a vehicle (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - associationBehavior:  An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle.  Default:
    ///   - attributes: Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"  To use attributes with Campaigns or State Templates, you must include them using the  request parameters dataExtraDimensions and/or metadataExtraDimensions  (for state templates only) when creating your campaign/state template.
    ///   - decoderManifestArn:  The ARN of a decoder manifest.
    ///   - modelManifestArn:  The Amazon Resource Name ARN of a vehicle model.
    ///   - stateTemplates: Associate state templates with the vehicle. You can monitor the last known state of the vehicle in near real time.
    ///   - tags: Metadata that can be used to manage the vehicle.
    ///   - vehicleName:  The unique ID of the vehicle to create.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVehicle(
        associationBehavior: VehicleAssociationBehavior? = nil,
        attributes: [String: String]? = nil,
        decoderManifestArn: String,
        modelManifestArn: String,
        stateTemplates: [StateTemplateAssociation]? = nil,
        tags: [Tag]? = nil,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVehicleResponse {
        let input = CreateVehicleRequest(
            associationBehavior: associationBehavior, 
            attributes: attributes, 
            decoderManifestArn: decoderManifestArn, 
            modelManifestArn: modelManifestArn, 
            stateTemplates: stateTemplates, 
            tags: tags, 
            vehicleName: vehicleName
        )
        return try await self.createVehicle(input, logger: logger)
    }

    ///  Deletes a data collection campaign. Deleting a campaign suspends all data collection and removes it from any vehicles.
    @Sendable
    @inlinable
    public func deleteCampaign(_ input: DeleteCampaignRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteCampaignResponse {
        try await self.client.execute(
            operation: "DeleteCampaign", 
            path: "/campaigns/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a data collection campaign. Deleting a campaign suspends all data collection and removes it from any vehicles.
    ///
    /// Parameters:
    ///   - name:  The name of the campaign to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteCampaign(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteCampaignResponse {
        let input = DeleteCampaignRequest(
            name: name
        )
        return try await self.deleteCampaign(input, logger: logger)
    }

    ///  Deletes a decoder manifest. You can't delete a decoder manifest if it has vehicles associated with it.
    @Sendable
    @inlinable
    public func deleteDecoderManifest(_ input: DeleteDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDecoderManifestResponse {
        try await self.client.execute(
            operation: "DeleteDecoderManifest", 
            path: "/decoder-manifests/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a decoder manifest. You can't delete a decoder manifest if it has vehicles associated with it.
    ///
    /// Parameters:
    ///   - name:  The name of the decoder manifest to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDecoderManifest(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDecoderManifestResponse {
        let input = DeleteDecoderManifestRequest(
            name: name
        )
        return try await self.deleteDecoderManifest(input, logger: logger)
    }

    ///  Deletes a fleet. Before you delete a fleet, all vehicles must be dissociated from the fleet. For more information, see Delete a fleet (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func deleteFleet(_ input: DeleteFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteFleetResponse {
        try await self.client.execute(
            operation: "DeleteFleet", 
            path: "/fleets/{fleetId}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a fleet. Before you delete a fleet, all vehicles must be dissociated from the fleet. For more information, see Delete a fleet (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - fleetId:  The ID of the fleet to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteFleet(
        fleetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteFleetResponse {
        let input = DeleteFleetRequest(
            fleetId: fleetId
        )
        return try await self.deleteFleet(input, logger: logger)
    }

    ///  Deletes a vehicle model (model manifest).
    @Sendable
    @inlinable
    public func deleteModelManifest(_ input: DeleteModelManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteModelManifestResponse {
        try await self.client.execute(
            operation: "DeleteModelManifest", 
            path: "/model-manifests/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a vehicle model (model manifest).
    ///
    /// Parameters:
    ///   - name:  The name of the model manifest to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteModelManifest(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteModelManifestResponse {
        let input = DeleteModelManifestRequest(
            name: name
        )
        return try await self.deleteModelManifest(input, logger: logger)
    }

    ///  Deletes a signal catalog.
    @Sendable
    @inlinable
    public func deleteSignalCatalog(_ input: DeleteSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteSignalCatalogResponse {
        try await self.client.execute(
            operation: "DeleteSignalCatalog", 
            path: "/signal-catalogs/{name}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a signal catalog.
    ///
    /// Parameters:
    ///   - name:  The name of the signal catalog to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteSignalCatalog(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteSignalCatalogResponse {
        let input = DeleteSignalCatalogRequest(
            name: name
        )
        return try await self.deleteSignalCatalog(input, logger: logger)
    }

    /// Deletes a state template.
    @Sendable
    @inlinable
    public func deleteStateTemplate(_ input: DeleteStateTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteStateTemplateResponse {
        try await self.client.execute(
            operation: "DeleteStateTemplate", 
            path: "/state-templates/{identifier}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a state template.
    ///
    /// Parameters:
    ///   - identifier: The unique ID of the state template.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteStateTemplate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteStateTemplateResponse {
        let input = DeleteStateTemplateRequest(
            identifier: identifier
        )
        return try await self.deleteStateTemplate(input, logger: logger)
    }

    ///  Deletes a vehicle and removes it from any campaigns.
    @Sendable
    @inlinable
    public func deleteVehicle(_ input: DeleteVehicleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVehicleResponse {
        try await self.client.execute(
            operation: "DeleteVehicle", 
            path: "/vehicles/{vehicleName}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Deletes a vehicle and removes it from any campaigns.
    ///
    /// Parameters:
    ///   - vehicleName: The ID of the vehicle to delete.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVehicle(
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVehicleResponse {
        let input = DeleteVehicleRequest(
            vehicleName: vehicleName
        )
        return try await self.deleteVehicle(input, logger: logger)
    }

    /// Removes, or disassociates, a vehicle from a fleet. Disassociating a vehicle from a fleet doesn't delete the vehicle.
    @Sendable
    @inlinable
    public func disassociateVehicleFleet(_ input: DisassociateVehicleFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DisassociateVehicleFleetResponse {
        try await self.client.execute(
            operation: "DisassociateVehicleFleet", 
            path: "/vehicles/{vehicleName}/disassociate", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes, or disassociates, a vehicle from a fleet. Disassociating a vehicle from a fleet doesn't delete the vehicle.
    ///
    /// Parameters:
    ///   - fleetId:  The unique ID of a fleet.
    ///   - vehicleName:  The unique ID of the vehicle to disassociate from the fleet.
    ///   - logger: Logger use during operation
    @inlinable
    public func disassociateVehicleFleet(
        fleetId: String,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DisassociateVehicleFleetResponse {
        let input = DisassociateVehicleFleetRequest(
            fleetId: fleetId, 
            vehicleName: vehicleName
        )
        return try await self.disassociateVehicleFleet(input, logger: logger)
    }

    ///  Retrieves information about a campaign.   Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func getCampaign(_ input: GetCampaignRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetCampaignResponse {
        try await self.client.execute(
            operation: "GetCampaign", 
            path: "/campaigns/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about a campaign.   Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - name:  The name of the campaign to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getCampaign(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetCampaignResponse {
        let input = GetCampaignRequest(
            name: name
        )
        return try await self.getCampaign(input, logger: logger)
    }

    ///  Retrieves information about a created decoder manifest.
    @Sendable
    @inlinable
    public func getDecoderManifest(_ input: GetDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDecoderManifestResponse {
        try await self.client.execute(
            operation: "GetDecoderManifest", 
            path: "/decoder-manifests/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about a created decoder manifest.
    ///
    /// Parameters:
    ///   - name:  The name of the decoder manifest to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDecoderManifest(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDecoderManifestResponse {
        let input = GetDecoderManifestRequest(
            name: name
        )
        return try await self.getDecoderManifest(input, logger: logger)
    }

    /// Retrieves the encryption configuration for resources and data in Amazon Web Services IoT FleetWise.
    @Sendable
    @inlinable
    public func getEncryptionConfiguration(_ input: GetEncryptionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetEncryptionConfigurationResponse {
        try await self.client.execute(
            operation: "GetEncryptionConfiguration", 
            path: "/encryptionConfiguration", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the encryption configuration for resources and data in Amazon Web Services IoT FleetWise.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getEncryptionConfiguration(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetEncryptionConfigurationResponse {
        let input = GetEncryptionConfigurationRequest(
        )
        return try await self.getEncryptionConfiguration(input, logger: logger)
    }

    ///  Retrieves information about a fleet.
    @Sendable
    @inlinable
    public func getFleet(_ input: GetFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetFleetResponse {
        try await self.client.execute(
            operation: "GetFleet", 
            path: "/fleets/{fleetId}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about a fleet.
    ///
    /// Parameters:
    ///   - fleetId:  The ID of the fleet to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getFleet(
        fleetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetFleetResponse {
        let input = GetFleetRequest(
            fleetId: fleetId
        )
        return try await self.getFleet(input, logger: logger)
    }

    /// Retrieves the logging options.
    @Sendable
    @inlinable
    public func getLoggingOptions(_ input: GetLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetLoggingOptionsResponse {
        try await self.client.execute(
            operation: "GetLoggingOptions", 
            path: "/loggingOptions", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves the logging options.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getLoggingOptions(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetLoggingOptionsResponse {
        let input = GetLoggingOptionsRequest(
        )
        return try await self.getLoggingOptions(input, logger: logger)
    }

    ///  Retrieves information about a vehicle model (model manifest).
    @Sendable
    @inlinable
    public func getModelManifest(_ input: GetModelManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetModelManifestResponse {
        try await self.client.execute(
            operation: "GetModelManifest", 
            path: "/model-manifests/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about a vehicle model (model manifest).
    ///
    /// Parameters:
    ///   - name:  The name of the vehicle model to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getModelManifest(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetModelManifestResponse {
        let input = GetModelManifestRequest(
            name: name
        )
        return try await self.getModelManifest(input, logger: logger)
    }

    ///  Retrieves information about the status of registering your Amazon Web Services account, IAM, and Amazon Timestream resources so that Amazon Web Services IoT FleetWise can transfer your vehicle data to the Amazon Web Services Cloud.  For more information, including step-by-step procedures, see Setting up Amazon Web Services IoT FleetWise.   This API operation doesn't require input parameters.
    @Sendable
    @inlinable
    public func getRegisterAccountStatus(_ input: GetRegisterAccountStatusRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetRegisterAccountStatusResponse {
        try await self.client.execute(
            operation: "GetRegisterAccountStatus", 
            path: "/account/registration_status", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about the status of registering your Amazon Web Services account, IAM, and Amazon Timestream resources so that Amazon Web Services IoT FleetWise can transfer your vehicle data to the Amazon Web Services Cloud.  For more information, including step-by-step procedures, see Setting up Amazon Web Services IoT FleetWise.   This API operation doesn't require input parameters.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func getRegisterAccountStatus(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetRegisterAccountStatusResponse {
        let input = GetRegisterAccountStatusRequest(
        )
        return try await self.getRegisterAccountStatus(input, logger: logger)
    }

    ///  Retrieves information about a signal catalog.
    @Sendable
    @inlinable
    public func getSignalCatalog(_ input: GetSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetSignalCatalogResponse {
        try await self.client.execute(
            operation: "GetSignalCatalog", 
            path: "/signal-catalogs/{name}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about a signal catalog.
    ///
    /// Parameters:
    ///   - name:  The name of the signal catalog to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getSignalCatalog(
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetSignalCatalogResponse {
        let input = GetSignalCatalogRequest(
            name: name
        )
        return try await self.getSignalCatalog(input, logger: logger)
    }

    /// Retrieves information about a state template.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func getStateTemplate(_ input: GetStateTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetStateTemplateResponse {
        try await self.client.execute(
            operation: "GetStateTemplate", 
            path: "/state-templates/{identifier}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves information about a state template.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - identifier: The unique ID of the state template.
    ///   - logger: Logger use during operation
    @inlinable
    public func getStateTemplate(
        identifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetStateTemplateResponse {
        let input = GetStateTemplateRequest(
            identifier: identifier
        )
        return try await self.getStateTemplate(input, logger: logger)
    }

    ///  Retrieves information about a vehicle.
    @Sendable
    @inlinable
    public func getVehicle(_ input: GetVehicleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetVehicleResponse {
        try await self.client.execute(
            operation: "GetVehicle", 
            path: "/vehicles/{vehicleName}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about a vehicle.
    ///
    /// Parameters:
    ///   - vehicleName:  The ID of the vehicle to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getVehicle(
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetVehicleResponse {
        let input = GetVehicleRequest(
            vehicleName: vehicleName
        )
        return try await self.getVehicle(input, logger: logger)
    }

    ///  Retrieves information about the status of campaigns, decoder manifests, or state templates associated with a vehicle.
    @Sendable
    @inlinable
    public func getVehicleStatus(_ input: GetVehicleStatusRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetVehicleStatusResponse {
        try await self.client.execute(
            operation: "GetVehicleStatus", 
            path: "/vehicles/{vehicleName}/status", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information about the status of campaigns, decoder manifests, or state templates associated with a vehicle.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive. This parameter is only  supported for resources of type CAMPAIGN.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a  nextToken pagination token is returned in the response. To retrieve the next  set of results, reissue the search request and include the returned token. When all results  have been returned, the response does not contain a pagination token value. This parameter  is only supported for resources of type CAMPAIGN.
    ///   - vehicleName:  The ID of the vehicle to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func getVehicleStatus(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetVehicleStatusResponse {
        let input = GetVehicleStatusRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            vehicleName: vehicleName
        )
        return try await self.getVehicleStatus(input, logger: logger)
    }

    ///  Creates a decoder manifest using your existing CAN DBC file from your local device.  The CAN signal name must be unique and not repeated across CAN message definitions in a .dbc file.
    @Sendable
    @inlinable
    public func importDecoderManifest(_ input: ImportDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportDecoderManifestResponse {
        try await self.client.execute(
            operation: "ImportDecoderManifest", 
            path: "/decoder-manifests/{name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a decoder manifest using your existing CAN DBC file from your local device.  The CAN signal name must be unique and not repeated across CAN message definitions in a .dbc file.
    ///
    /// Parameters:
    ///   - name:  The name of the decoder manifest to import.
    ///   - networkFileDefinitions:  The file to load into an Amazon Web Services account.
    ///   - logger: Logger use during operation
    @inlinable
    public func importDecoderManifest(
        name: String,
        networkFileDefinitions: [NetworkFileDefinition],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportDecoderManifestResponse {
        let input = ImportDecoderManifestRequest(
            name: name, 
            networkFileDefinitions: networkFileDefinitions
        )
        return try await self.importDecoderManifest(input, logger: logger)
    }

    ///  Creates a signal catalog using your existing VSS formatted content from your local device.
    @Sendable
    @inlinable
    public func importSignalCatalog(_ input: ImportSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ImportSignalCatalogResponse {
        try await self.client.execute(
            operation: "ImportSignalCatalog", 
            path: "/signal-catalogs/{name}/nodes", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Creates a signal catalog using your existing VSS formatted content from your local device.
    ///
    /// Parameters:
    ///   - description:  A brief description of the signal catalog.
    ///   - name: The name of the signal catalog to import.
    ///   - tags: Metadata that can be used to manage the signal catalog.
    ///   - vss: The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.
    ///   - logger: Logger use during operation
    @inlinable
    public func importSignalCatalog(
        description: String? = nil,
        name: String,
        tags: [Tag]? = nil,
        vss: FormattedVss? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ImportSignalCatalogResponse {
        let input = ImportSignalCatalogRequest(
            description: description, 
            name: name, 
            tags: tags, 
            vss: vss
        )
        return try await self.importSignalCatalog(input, logger: logger)
    }

    ///  Lists information about created campaigns.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listCampaigns(_ input: ListCampaignsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListCampaignsResponse {
        try await self.client.execute(
            operation: "ListCampaigns", 
            path: "/campaigns", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists information about created campaigns.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: campaign name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - status: An optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, or SUSPENDED.
    ///   - logger: Logger use during operation
    @inlinable
    public func listCampaigns(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListCampaignsResponse {
        let input = ListCampaignsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            status: status
        )
        return try await self.listCampaigns(input, logger: logger)
    }

    ///  Lists the network interfaces specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listDecoderManifestNetworkInterfaces(_ input: ListDecoderManifestNetworkInterfacesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDecoderManifestNetworkInterfacesResponse {
        try await self.client.execute(
            operation: "ListDecoderManifestNetworkInterfaces", 
            path: "/decoder-manifests/{name}/network-interfaces", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists the network interfaces specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the decoder manifest to list information about.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDecoderManifestNetworkInterfaces(
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDecoderManifestNetworkInterfacesResponse {
        let input = ListDecoderManifestNetworkInterfacesRequest(
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken
        )
        return try await self.listDecoderManifestNetworkInterfaces(input, logger: logger)
    }

    ///  A list of information about signal decoders specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listDecoderManifestSignals(_ input: ListDecoderManifestSignalsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDecoderManifestSignalsResponse {
        try await self.client.execute(
            operation: "ListDecoderManifestSignals", 
            path: "/decoder-manifests/{name}/signals", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  A list of information about signal decoders specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the decoder manifest to list information about.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDecoderManifestSignals(
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDecoderManifestSignalsResponse {
        let input = ListDecoderManifestSignalsRequest(
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken
        )
        return try await self.listDecoderManifestSignals(input, logger: logger)
    }

    ///  Lists decoder manifests.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listDecoderManifests(_ input: ListDecoderManifestsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDecoderManifestsResponse {
        try await self.client.execute(
            operation: "ListDecoderManifests", 
            path: "/decoder-manifests", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists decoder manifests.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: decoder manifest name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - modelManifestArn:  The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDecoderManifests(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        modelManifestArn: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDecoderManifestsResponse {
        let input = ListDecoderManifestsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            modelManifestArn: modelManifestArn, 
            nextToken: nextToken
        )
        return try await self.listDecoderManifests(input, logger: logger)
    }

    ///  Retrieves information for each created fleet in an Amazon Web Services account.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listFleets(_ input: ListFleetsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFleetsResponse {
        try await self.client.execute(
            operation: "ListFleets", 
            path: "/fleets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves information for each created fleet in an Amazon Web Services account.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: fleet ID, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFleets(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFleetsResponse {
        let input = ListFleetsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listFleets(input, logger: logger)
    }

    /// Retrieves a list of IDs for all fleets that the vehicle is associated with.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listFleetsForVehicle(_ input: ListFleetsForVehicleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListFleetsForVehicleResponse {
        try await self.client.execute(
            operation: "ListFleetsForVehicle", 
            path: "/vehicles/{vehicleName}/fleets", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Retrieves a list of IDs for all fleets that the vehicle is associated with.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - vehicleName:  The ID of the vehicle to retrieve information about.
    ///   - logger: Logger use during operation
    @inlinable
    public func listFleetsForVehicle(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListFleetsForVehicleResponse {
        let input = ListFleetsForVehicleRequest(
            maxResults: maxResults, 
            nextToken: nextToken, 
            vehicleName: vehicleName
        )
        return try await self.listFleetsForVehicle(input, logger: logger)
    }

    ///  Lists information about nodes specified in a vehicle model (model manifest).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listModelManifestNodes(_ input: ListModelManifestNodesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListModelManifestNodesResponse {
        try await self.client.execute(
            operation: "ListModelManifestNodes", 
            path: "/model-manifests/{name}/nodes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists information about nodes specified in a vehicle model (model manifest).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the vehicle model to list information about.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listModelManifestNodes(
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListModelManifestNodesResponse {
        let input = ListModelManifestNodesRequest(
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken
        )
        return try await self.listModelManifestNodes(input, logger: logger)
    }

    ///  Retrieves a list of vehicle models (model manifests).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listModelManifests(_ input: ListModelManifestsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListModelManifestsResponse {
        try await self.client.execute(
            operation: "ListModelManifests", 
            path: "/model-manifests", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves a list of vehicle models (model manifests).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: model manifest name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - signalCatalogArn:  The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.
    ///   - logger: Logger use during operation
    @inlinable
    public func listModelManifests(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        signalCatalogArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListModelManifestsResponse {
        let input = ListModelManifestsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            signalCatalogArn: signalCatalogArn
        )
        return try await self.listModelManifests(input, logger: logger)
    }

    ///  Lists of information about the signals (nodes) specified in a signal catalog.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listSignalCatalogNodes(_ input: ListSignalCatalogNodesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSignalCatalogNodesResponse {
        try await self.client.execute(
            operation: "ListSignalCatalogNodes", 
            path: "/signal-catalogs/{name}/nodes", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists of information about the signals (nodes) specified in a signal catalog.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the signal catalog to list information about.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - signalNodeType: The type of node in the signal catalog.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSignalCatalogNodes(
        maxResults: Int? = nil,
        name: String,
        nextToken: String? = nil,
        signalNodeType: SignalNodeType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSignalCatalogNodesResponse {
        let input = ListSignalCatalogNodesRequest(
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken, 
            signalNodeType: signalNodeType
        )
        return try await self.listSignalCatalogNodes(input, logger: logger)
    }

    ///  Lists all the created signal catalogs in an Amazon Web Services account.  You can use  to list information about each signal (node) specified in a signal catalog.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listSignalCatalogs(_ input: ListSignalCatalogsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSignalCatalogsResponse {
        try await self.client.execute(
            operation: "ListSignalCatalogs", 
            path: "/signal-catalogs", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Lists all the created signal catalogs in an Amazon Web Services account.  You can use  to list information about each signal (node) specified in a signal catalog.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSignalCatalogs(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSignalCatalogsResponse {
        let input = ListSignalCatalogsRequest(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSignalCatalogs(input, logger: logger)
    }

    /// Lists information about created state templates.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func listStateTemplates(_ input: ListStateTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListStateTemplatesResponse {
        try await self.client.execute(
            operation: "ListStateTemplates", 
            path: "/state-templates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists information about created state templates.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: state template ID, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - nextToken:  The token to retrieve the next set of results, or null if there are no more results.
    ///   - logger: Logger use during operation
    @inlinable
    public func listStateTemplates(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListStateTemplatesResponse {
        let input = ListStateTemplatesRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listStateTemplates(input, logger: logger)
    }

    /// Lists the tags (metadata) you have assigned to the resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags (metadata) you have assigned to the resource.
    ///
    /// Parameters:
    ///   - resourceARN: The ARN of the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceARN: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceARN: resourceARN
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    ///  Retrieves a list of summaries of created vehicles.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listVehicles(_ input: ListVehiclesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVehiclesResponse {
        try await self.client.execute(
            operation: "ListVehicles", 
            path: "/vehicles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves a list of summaries of created vehicles.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - attributeNames: The fully qualified names of the attributes. You can use this optional parameter to list the  vehicles containing all the attributes in the request. For example, attributeNames  could be "Vehicle.Body.Engine.Type, Vehicle.Color" and the corresponding  attributeValues could be "1.3 L R2, Blue" . In this case, the API  will filter vehicles with an attribute name Vehicle.Body.Engine.Type that contains a value of 1.3 L R2 AND an attribute name Vehicle.Color that contains a value of "Blue". A request must contain unique values for the attributeNames  filter and the matching number of attributeValues filters to return the subset  of vehicles that match the attributes filter condition.
    ///   - attributeValues: Static information about a vehicle attribute value in string format. You can use this optional  parameter in conjunction with attributeNames to list the vehicles containing all  the attributeValues corresponding to the attributeNames filter. For  example, attributeValues could be "1.3 L R2, Blue" and the corresponding  attributeNames filter could be "Vehicle.Body.Engine.Type, Vehicle.Color".  In this case, the API will filter vehicles with attribute name Vehicle.Body.Engine.Type  that contains a value of 1.3 L R2 AND an attribute name Vehicle.Color that contains a value of "Blue". A request must contain unique values for the  attributeNames filter and the matching number of attributeValues  filter to return the subset of vehicles that match the attributes filter condition.
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: vehicle name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - modelManifestArn:  The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVehicles(
        attributeNames: [String]? = nil,
        attributeValues: [String]? = nil,
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        modelManifestArn: String? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVehiclesResponse {
        let input = ListVehiclesRequest(
            attributeNames: attributeNames, 
            attributeValues: attributeValues, 
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            modelManifestArn: modelManifestArn, 
            nextToken: nextToken
        )
        return try await self.listVehicles(input, logger: logger)
    }

    ///  Retrieves a list of summaries of all vehicles associated with a fleet.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    @Sendable
    @inlinable
    public func listVehiclesInFleet(_ input: ListVehiclesInFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVehiclesInFleetResponse {
        try await self.client.execute(
            operation: "ListVehiclesInFleet", 
            path: "/fleets/{fleetId}/vehicles", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Retrieves a list of summaries of all vehicles associated with a fleet.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    ///
    /// Parameters:
    ///   - fleetId:  The ID of a fleet.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - nextToken: A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVehiclesInFleet(
        fleetId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVehiclesInFleetResponse {
        let input = ListVehiclesInFleetRequest(
            fleetId: fleetId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listVehiclesInFleet(input, logger: logger)
    }

    /// Creates or updates the encryption configuration. Amazon Web Services IoT FleetWise can encrypt your data and resources using an Amazon Web Services managed key. Or, you can use a KMS key that you own and manage. For more information, see Data encryption in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func putEncryptionConfiguration(_ input: PutEncryptionConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutEncryptionConfigurationResponse {
        try await self.client.execute(
            operation: "PutEncryptionConfiguration", 
            path: "/encryptionConfiguration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates the encryption configuration. Amazon Web Services IoT FleetWise can encrypt your data and resources using an Amazon Web Services managed key. Or, you can use a KMS key that you own and manage. For more information, see Data encryption in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - encryptionType: The type of encryption. Choose KMS_BASED_ENCRYPTION to use a KMS key or FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key.
    ///   - kmsKeyId: The ID of the KMS key that is used for encryption.
    ///   - logger: Logger use during operation
    @inlinable
    public func putEncryptionConfiguration(
        encryptionType: EncryptionType,
        kmsKeyId: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutEncryptionConfigurationResponse {
        let input = PutEncryptionConfigurationRequest(
            encryptionType: encryptionType, 
            kmsKeyId: kmsKeyId
        )
        return try await self.putEncryptionConfiguration(input, logger: logger)
    }

    /// Creates or updates the logging option.
    @Sendable
    @inlinable
    public func putLoggingOptions(_ input: PutLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> PutLoggingOptionsResponse {
        try await self.client.execute(
            operation: "PutLoggingOptions", 
            path: "/loggingOptions", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates or updates the logging option.
    ///
    /// Parameters:
    ///   - cloudWatchLogDelivery: Creates or updates the log delivery option to Amazon CloudWatch Logs.
    ///   - logger: Logger use during operation
    @inlinable
    public func putLoggingOptions(
        cloudWatchLogDelivery: CloudWatchLogDeliveryOptions,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> PutLoggingOptionsResponse {
        let input = PutLoggingOptionsRequest(
            cloudWatchLogDelivery: cloudWatchLogDelivery
        )
        return try await self.putLoggingOptions(input, logger: logger)
    }

    ///  This API operation contains deprecated parameters. Register your account again without the Timestream resources parameter so that Amazon Web Services IoT FleetWise can remove the Timestream metadata stored. You should then pass the data destination into the CreateCampaign API operation. You must delete any existing campaigns that include an empty data destination before you register your account again. For more information, see the DeleteCampaign API operation. If you want to delete the Timestream inline policy from the service-linked role, such as to mitigate an overly permissive policy, you must first delete any existing campaigns. Then delete the service-linked role and register your account again to enable CloudWatch metrics. For more information, see DeleteServiceLinkedRole in the Identity and Access Management API Reference.  Registers your Amazon Web Services account, IAM, and Amazon Timestream resources so Amazon Web Services IoT FleetWise can transfer your vehicle data to the Amazon Web Services Cloud. For more information, including step-by-step procedures, see Setting up Amazon Web Services IoT FleetWise.   An Amazon Web Services account is not the same thing as a "user." An Amazon Web Services user is an identity that you create using Identity and Access Management (IAM) and takes the form of either an IAM user or an IAM role, both with credentials. A single Amazon Web Services account can, and typically does, contain many users and roles.
    @Sendable
    @inlinable
    public func registerAccount(_ input: RegisterAccountRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> RegisterAccountResponse {
        try await self.client.execute(
            operation: "RegisterAccount", 
            path: "/account/registration", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  This API operation contains deprecated parameters. Register your account again without the Timestream resources parameter so that Amazon Web Services IoT FleetWise can remove the Timestream metadata stored. You should then pass the data destination into the CreateCampaign API operation. You must delete any existing campaigns that include an empty data destination before you register your account again. For more information, see the DeleteCampaign API operation. If you want to delete the Timestream inline policy from the service-linked role, such as to mitigate an overly permissive policy, you must first delete any existing campaigns. Then delete the service-linked role and register your account again to enable CloudWatch metrics. For more information, see DeleteServiceLinkedRole in the Identity and Access Management API Reference.  Registers your Amazon Web Services account, IAM, and Amazon Timestream resources so Amazon Web Services IoT FleetWise can transfer your vehicle data to the Amazon Web Services Cloud. For more information, including step-by-step procedures, see Setting up Amazon Web Services IoT FleetWise.   An Amazon Web Services account is not the same thing as a "user." An Amazon Web Services user is an identity that you create using Identity and Access Management (IAM) and takes the form of either an IAM user or an IAM role, both with credentials. A single Amazon Web Services account can, and typically does, contain many users and roles.
    ///
    /// Parameters:
    ///   - logger: Logger use during operation
    @inlinable
    public func registerAccount(
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> RegisterAccountResponse {
        let input = RegisterAccountRequest(
        )
        return try await self.registerAccount(input, logger: logger)
    }

    /// Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
    ///
    /// Parameters:
    ///   - resourceARN: The ARN of the resource.
    ///   - tags: The new or modified tags for the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceARN: String,
        tags: [Tag],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceARN: resourceARN, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes the given tags (metadata) from the resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the given tags (metadata) from the resource.
    ///
    /// Parameters:
    ///   - resourceARN: The ARN of the resource.
    ///   - tagKeys: A list of the keys of the tags to be removed from the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceARN: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceARN: resourceARN, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }

    ///  Updates a campaign.
    @Sendable
    @inlinable
    public func updateCampaign(_ input: UpdateCampaignRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateCampaignResponse {
        try await self.client.execute(
            operation: "UpdateCampaign", 
            path: "/campaigns/{name}", 
            httpMethod: .PUT, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a campaign.
    ///
    /// Parameters:
    ///   - action:  Specifies how to update a campaign. The action can be one of the following:    APPROVE - To approve delivering a data collection scheme to vehicles.     SUSPEND - To suspend collecting signal data. The campaign is deleted from vehicles and all vehicles in the suspended campaign will stop sending data.    RESUME - To reactivate the SUSPEND campaign. The campaign is redeployed to all vehicles and the vehicles will resume sending data.    UPDATE - To update a campaign.
    ///   - dataExtraDimensions:  A list of vehicle attributes to associate with a signal.  Default: An empty array
    ///   - description: The description of the campaign.
    ///   - name:  The name of the campaign to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateCampaign(
        action: UpdateCampaignAction,
        dataExtraDimensions: [String]? = nil,
        description: String? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateCampaignResponse {
        let input = UpdateCampaignRequest(
            action: action, 
            dataExtraDimensions: dataExtraDimensions, 
            description: description, 
            name: name
        )
        return try await self.updateCampaign(input, logger: logger)
    }

    ///  Updates a decoder manifest. A decoder manifest can only be updated when the status is DRAFT. Only ACTIVE decoder manifests can be associated with vehicles.
    @Sendable
    @inlinable
    public func updateDecoderManifest(_ input: UpdateDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateDecoderManifestResponse {
        try await self.client.execute(
            operation: "UpdateDecoderManifest", 
            path: "/decoder-manifests/{name}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a decoder manifest. A decoder manifest can only be updated when the status is DRAFT. Only ACTIVE decoder manifests can be associated with vehicles.
    ///
    /// Parameters:
    ///   - defaultForUnmappedSignals: Use default decoders for all unmapped signals in the model. You don't need to provide any detailed decoding information.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///   - description:  A brief description of the decoder manifest to update.
    ///   - name:  The name of the decoder manifest to update.
    ///   - networkInterfacesToAdd:  A list of information about the network interfaces to add to the decoder manifest.
    ///   - networkInterfacesToRemove:  A list of network interfaces to remove from the decoder manifest.
    ///   - networkInterfacesToUpdate:  A list of information about the network interfaces to update in the decoder manifest.
    ///   - signalDecodersToAdd:  A list of information about decoding additional signals to add to the decoder manifest.
    ///   - signalDecodersToRemove:  A list of signal decoders to remove from the decoder manifest.
    ///   - signalDecodersToUpdate:  A list of updated information about decoding signals to update in the decoder manifest.
    ///   - status:  The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is DRAFT, you can edit the decoder manifest.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateDecoderManifest(
        defaultForUnmappedSignals: DefaultForUnmappedSignalsType? = nil,
        description: String? = nil,
        name: String,
        networkInterfacesToAdd: [NetworkInterface]? = nil,
        networkInterfacesToRemove: [String]? = nil,
        networkInterfacesToUpdate: [NetworkInterface]? = nil,
        signalDecodersToAdd: [SignalDecoder]? = nil,
        signalDecodersToRemove: [String]? = nil,
        signalDecodersToUpdate: [SignalDecoder]? = nil,
        status: ManifestStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateDecoderManifestResponse {
        let input = UpdateDecoderManifestRequest(
            defaultForUnmappedSignals: defaultForUnmappedSignals, 
            description: description, 
            name: name, 
            networkInterfacesToAdd: networkInterfacesToAdd, 
            networkInterfacesToRemove: networkInterfacesToRemove, 
            networkInterfacesToUpdate: networkInterfacesToUpdate, 
            signalDecodersToAdd: signalDecodersToAdd, 
            signalDecodersToRemove: signalDecodersToRemove, 
            signalDecodersToUpdate: signalDecodersToUpdate, 
            status: status
        )
        return try await self.updateDecoderManifest(input, logger: logger)
    }

    ///  Updates the description of an existing fleet.
    @Sendable
    @inlinable
    public func updateFleet(_ input: UpdateFleetRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateFleetResponse {
        try await self.client.execute(
            operation: "UpdateFleet", 
            path: "/fleets/{fleetId}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates the description of an existing fleet.
    ///
    /// Parameters:
    ///   - description:  An updated description of the fleet.
    ///   - fleetId:  The ID of the fleet to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateFleet(
        description: String? = nil,
        fleetId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateFleetResponse {
        let input = UpdateFleetRequest(
            description: description, 
            fleetId: fleetId
        )
        return try await self.updateFleet(input, logger: logger)
    }

    ///  Updates a vehicle model (model manifest). If created vehicles are associated with a vehicle model, it can't be updated.
    @Sendable
    @inlinable
    public func updateModelManifest(_ input: UpdateModelManifestRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateModelManifestResponse {
        try await self.client.execute(
            operation: "UpdateModelManifest", 
            path: "/model-manifests/{name}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a vehicle model (model manifest). If created vehicles are associated with a vehicle model, it can't be updated.
    ///
    /// Parameters:
    ///   - description:  A brief description of the vehicle model.
    ///   - name:  The name of the vehicle model to update.
    ///   - nodesToAdd:  A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to add to the vehicle model.
    ///   - nodesToRemove:  A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to remove from the vehicle model.
    ///   - status:  The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateModelManifest(
        description: String? = nil,
        name: String,
        nodesToAdd: [String]? = nil,
        nodesToRemove: [String]? = nil,
        status: ManifestStatus? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateModelManifestResponse {
        let input = UpdateModelManifestRequest(
            description: description, 
            name: name, 
            nodesToAdd: nodesToAdd, 
            nodesToRemove: nodesToRemove, 
            status: status
        )
        return try await self.updateModelManifest(input, logger: logger)
    }

    ///  Updates a signal catalog.
    @Sendable
    @inlinable
    public func updateSignalCatalog(_ input: UpdateSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateSignalCatalogResponse {
        try await self.client.execute(
            operation: "UpdateSignalCatalog", 
            path: "/signal-catalogs/{name}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a signal catalog.
    ///
    /// Parameters:
    ///   - description:  A brief description of the signal catalog to update.
    ///   - name:  The name of the signal catalog to update.
    ///   - nodesToAdd:  A list of information about nodes to add to the signal catalog.
    ///   - nodesToRemove:  A list of fullyQualifiedName of nodes to remove from the signal catalog.
    ///   - nodesToUpdate:  A list of information about nodes to update in the signal catalog.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateSignalCatalog(
        description: String? = nil,
        name: String,
        nodesToAdd: [Node]? = nil,
        nodesToRemove: [String]? = nil,
        nodesToUpdate: [Node]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateSignalCatalogResponse {
        let input = UpdateSignalCatalogRequest(
            description: description, 
            name: name, 
            nodesToAdd: nodesToAdd, 
            nodesToRemove: nodesToRemove, 
            nodesToUpdate: nodesToUpdate
        )
        return try await self.updateSignalCatalog(input, logger: logger)
    }

    /// Updates a state template.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func updateStateTemplate(_ input: UpdateStateTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateStateTemplateResponse {
        try await self.client.execute(
            operation: "UpdateStateTemplate", 
            path: "/state-templates/{identifier}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Updates a state template.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - dataExtraDimensions: A list of vehicle attributes to associate with the payload published on the state template's  MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will enrich the protobuf encoded payload with those attributes in the extraDimensions field. Default: An empty array
    ///   - description: A brief description of the state template.
    ///   - identifier: The unique ID of the state template.
    ///   - metadataExtraDimensions: A list of vehicle attributes to associate with user properties of the messages published on the state template's MQTT topic. (See  Processing last known state vehicle data using MQTT messaging). For example, if you add  Vehicle.Attributes.Make and Vehicle.Attributes.Model attributes, Amazon Web Services IoT FleetWise  will include these attributes as User Properties with the MQTT message.
    ///   - stateTemplatePropertiesToAdd: Add signals from which data is collected as part of the state template.
    ///   - stateTemplatePropertiesToRemove: Remove signals from which data is collected as part of the state template.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateStateTemplate(
        dataExtraDimensions: [String]? = nil,
        description: String? = nil,
        identifier: String,
        metadataExtraDimensions: [String]? = nil,
        stateTemplatePropertiesToAdd: [String]? = nil,
        stateTemplatePropertiesToRemove: [String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateStateTemplateResponse {
        let input = UpdateStateTemplateRequest(
            dataExtraDimensions: dataExtraDimensions, 
            description: description, 
            identifier: identifier, 
            metadataExtraDimensions: metadataExtraDimensions, 
            stateTemplatePropertiesToAdd: stateTemplatePropertiesToAdd, 
            stateTemplatePropertiesToRemove: stateTemplatePropertiesToRemove
        )
        return try await self.updateStateTemplate(input, logger: logger)
    }

    ///  Updates a vehicle.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    @Sendable
    @inlinable
    public func updateVehicle(_ input: UpdateVehicleRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UpdateVehicleResponse {
        try await self.client.execute(
            operation: "UpdateVehicle", 
            path: "/vehicles/{vehicleName}", 
            httpMethod: .PATCH, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    ///  Updates a vehicle.  Access to certain Amazon Web Services IoT FleetWise features is currently gated. For more information, see Amazon Web Services Region and feature availability in the Amazon Web Services IoT FleetWise Developer Guide.
    ///
    /// Parameters:
    ///   - attributes: Static information about a vehicle in a key-value pair. For example:  "engineType" : "1.3 L R2"
    ///   - attributeUpdateMode: The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
    ///   - decoderManifestArn: The ARN of the decoder manifest associated with this vehicle.
    ///   - modelManifestArn: The ARN of a vehicle model (model manifest) associated with the vehicle.
    ///   - stateTemplatesToAdd: Associate state templates with the vehicle.
    ///   - stateTemplatesToRemove: Remove state templates from the vehicle.
    ///   - stateTemplatesToUpdate: Change the stateTemplateUpdateStrategy of state templates already associated with the vehicle.
    ///   - vehicleName: The unique ID of the vehicle to update.
    ///   - logger: Logger use during operation
    @inlinable
    public func updateVehicle(
        attributes: [String: String]? = nil,
        attributeUpdateMode: UpdateMode? = nil,
        decoderManifestArn: String? = nil,
        modelManifestArn: String? = nil,
        stateTemplatesToAdd: [StateTemplateAssociation]? = nil,
        stateTemplatesToRemove: [String]? = nil,
        stateTemplatesToUpdate: [StateTemplateAssociation]? = nil,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UpdateVehicleResponse {
        let input = UpdateVehicleRequest(
            attributes: attributes, 
            attributeUpdateMode: attributeUpdateMode, 
            decoderManifestArn: decoderManifestArn, 
            modelManifestArn: modelManifestArn, 
            stateTemplatesToAdd: stateTemplatesToAdd, 
            stateTemplatesToRemove: stateTemplatesToRemove, 
            stateTemplatesToUpdate: stateTemplatesToUpdate, 
            vehicleName: vehicleName
        )
        return try await self.updateVehicle(input, logger: logger)
    }
}

extension IoTFleetWise {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: IoTFleetWise, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension IoTFleetWise {
    /// Return PaginatorSequence for operation ``getVehicleStatus(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func getVehicleStatusPaginator(
        _ input: GetVehicleStatusRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<GetVehicleStatusRequest, GetVehicleStatusResponse> {
        return .init(
            input: input,
            command: self.getVehicleStatus,
            inputKey: \GetVehicleStatusRequest.nextToken,
            outputKey: \GetVehicleStatusResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``getVehicleStatus(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive. This parameter is only  supported for resources of type CAMPAIGN.
    ///   - vehicleName:  The ID of the vehicle to retrieve information about.
    ///   - logger: Logger used for logging
    @inlinable
    public func getVehicleStatusPaginator(
        maxResults: Int? = nil,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<GetVehicleStatusRequest, GetVehicleStatusResponse> {
        let input = GetVehicleStatusRequest(
            maxResults: maxResults, 
            vehicleName: vehicleName
        )
        return self.getVehicleStatusPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listCampaigns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listCampaignsPaginator(
        _ input: ListCampaignsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListCampaignsRequest, ListCampaignsResponse> {
        return .init(
            input: input,
            command: self.listCampaigns,
            inputKey: \ListCampaignsRequest.nextToken,
            outputKey: \ListCampaignsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listCampaigns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: campaign name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - status: An optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, or SUSPENDED.
    ///   - logger: Logger used for logging
    @inlinable
    public func listCampaignsPaginator(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        status: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListCampaignsRequest, ListCampaignsResponse> {
        let input = ListCampaignsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            status: status
        )
        return self.listCampaignsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDecoderManifestNetworkInterfaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDecoderManifestNetworkInterfacesPaginator(
        _ input: ListDecoderManifestNetworkInterfacesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestNetworkInterfacesRequest, ListDecoderManifestNetworkInterfacesResponse> {
        return .init(
            input: input,
            command: self.listDecoderManifestNetworkInterfaces,
            inputKey: \ListDecoderManifestNetworkInterfacesRequest.nextToken,
            outputKey: \ListDecoderManifestNetworkInterfacesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDecoderManifestNetworkInterfaces(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the decoder manifest to list information about.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDecoderManifestNetworkInterfacesPaginator(
        maxResults: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestNetworkInterfacesRequest, ListDecoderManifestNetworkInterfacesResponse> {
        let input = ListDecoderManifestNetworkInterfacesRequest(
            maxResults: maxResults, 
            name: name
        )
        return self.listDecoderManifestNetworkInterfacesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDecoderManifestSignals(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDecoderManifestSignalsPaginator(
        _ input: ListDecoderManifestSignalsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestSignalsRequest, ListDecoderManifestSignalsResponse> {
        return .init(
            input: input,
            command: self.listDecoderManifestSignals,
            inputKey: \ListDecoderManifestSignalsRequest.nextToken,
            outputKey: \ListDecoderManifestSignalsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDecoderManifestSignals(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the decoder manifest to list information about.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDecoderManifestSignalsPaginator(
        maxResults: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestSignalsRequest, ListDecoderManifestSignalsResponse> {
        let input = ListDecoderManifestSignalsRequest(
            maxResults: maxResults, 
            name: name
        )
        return self.listDecoderManifestSignalsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDecoderManifests(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDecoderManifestsPaginator(
        _ input: ListDecoderManifestsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestsRequest, ListDecoderManifestsResponse> {
        return .init(
            input: input,
            command: self.listDecoderManifests,
            inputKey: \ListDecoderManifestsRequest.nextToken,
            outputKey: \ListDecoderManifestsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDecoderManifests(_:logger:)``.
    ///
    /// - Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: decoder manifest name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - modelManifestArn:  The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDecoderManifestsPaginator(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        modelManifestArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestsRequest, ListDecoderManifestsResponse> {
        let input = ListDecoderManifestsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            modelManifestArn: modelManifestArn
        )
        return self.listDecoderManifestsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFleets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetsPaginator(
        _ input: ListFleetsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFleetsRequest, ListFleetsResponse> {
        return .init(
            input: input,
            command: self.listFleets,
            inputKey: \ListFleetsRequest.nextToken,
            outputKey: \ListFleetsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFleets(_:logger:)``.
    ///
    /// - Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: fleet ID, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetsPaginator(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFleetsRequest, ListFleetsResponse> {
        let input = ListFleetsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults
        )
        return self.listFleetsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listFleetsForVehicle(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetsForVehiclePaginator(
        _ input: ListFleetsForVehicleRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListFleetsForVehicleRequest, ListFleetsForVehicleResponse> {
        return .init(
            input: input,
            command: self.listFleetsForVehicle,
            inputKey: \ListFleetsForVehicleRequest.nextToken,
            outputKey: \ListFleetsForVehicleResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listFleetsForVehicle(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - vehicleName:  The ID of the vehicle to retrieve information about.
    ///   - logger: Logger used for logging
    @inlinable
    public func listFleetsForVehiclePaginator(
        maxResults: Int? = nil,
        vehicleName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListFleetsForVehicleRequest, ListFleetsForVehicleResponse> {
        let input = ListFleetsForVehicleRequest(
            maxResults: maxResults, 
            vehicleName: vehicleName
        )
        return self.listFleetsForVehiclePaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listModelManifestNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelManifestNodesPaginator(
        _ input: ListModelManifestNodesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListModelManifestNodesRequest, ListModelManifestNodesResponse> {
        return .init(
            input: input,
            command: self.listModelManifestNodes,
            inputKey: \ListModelManifestNodesRequest.nextToken,
            outputKey: \ListModelManifestNodesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listModelManifestNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the vehicle model to list information about.
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelManifestNodesPaginator(
        maxResults: Int? = nil,
        name: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListModelManifestNodesRequest, ListModelManifestNodesResponse> {
        let input = ListModelManifestNodesRequest(
            maxResults: maxResults, 
            name: name
        )
        return self.listModelManifestNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listModelManifests(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelManifestsPaginator(
        _ input: ListModelManifestsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListModelManifestsRequest, ListModelManifestsResponse> {
        return .init(
            input: input,
            command: self.listModelManifests,
            inputKey: \ListModelManifestsRequest.nextToken,
            outputKey: \ListModelManifestsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listModelManifests(_:logger:)``.
    ///
    /// - Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: model manifest name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - signalCatalogArn:  The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.
    ///   - logger: Logger used for logging
    @inlinable
    public func listModelManifestsPaginator(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        signalCatalogArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListModelManifestsRequest, ListModelManifestsResponse> {
        let input = ListModelManifestsRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            signalCatalogArn: signalCatalogArn
        )
        return self.listModelManifestsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSignalCatalogNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSignalCatalogNodesPaginator(
        _ input: ListSignalCatalogNodesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSignalCatalogNodesRequest, ListSignalCatalogNodesResponse> {
        return .init(
            input: input,
            command: self.listSignalCatalogNodes,
            inputKey: \ListSignalCatalogNodesRequest.nextToken,
            outputKey: \ListSignalCatalogNodesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSignalCatalogNodes(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - name:  The name of the signal catalog to list information about.
    ///   - signalNodeType: The type of node in the signal catalog.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSignalCatalogNodesPaginator(
        maxResults: Int? = nil,
        name: String,
        signalNodeType: SignalNodeType? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSignalCatalogNodesRequest, ListSignalCatalogNodesResponse> {
        let input = ListSignalCatalogNodesRequest(
            maxResults: maxResults, 
            name: name, 
            signalNodeType: signalNodeType
        )
        return self.listSignalCatalogNodesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSignalCatalogs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSignalCatalogsPaginator(
        _ input: ListSignalCatalogsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSignalCatalogsRequest, ListSignalCatalogsResponse> {
        return .init(
            input: input,
            command: self.listSignalCatalogs,
            inputKey: \ListSignalCatalogsRequest.nextToken,
            outputKey: \ListSignalCatalogsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSignalCatalogs(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSignalCatalogsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSignalCatalogsRequest, ListSignalCatalogsResponse> {
        let input = ListSignalCatalogsRequest(
            maxResults: maxResults
        )
        return self.listSignalCatalogsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listStateTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listStateTemplatesPaginator(
        _ input: ListStateTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListStateTemplatesRequest, ListStateTemplatesResponse> {
        return .init(
            input: input,
            command: self.listStateTemplates,
            inputKey: \ListStateTemplatesRequest.nextToken,
            outputKey: \ListStateTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listStateTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: state template ID, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - logger: Logger used for logging
    @inlinable
    public func listStateTemplatesPaginator(
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListStateTemplatesRequest, ListStateTemplatesResponse> {
        let input = ListStateTemplatesRequest(
            listResponseScope: listResponseScope, 
            maxResults: maxResults
        )
        return self.listStateTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVehicles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVehiclesPaginator(
        _ input: ListVehiclesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVehiclesRequest, ListVehiclesResponse> {
        return .init(
            input: input,
            command: self.listVehicles,
            inputKey: \ListVehiclesRequest.nextToken,
            outputKey: \ListVehiclesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVehicles(_:logger:)``.
    ///
    /// - Parameters:
    ///   - attributeNames: The fully qualified names of the attributes. You can use this optional parameter to list the  vehicles containing all the attributes in the request. For example, attributeNames  could be "Vehicle.Body.Engine.Type, Vehicle.Color" and the corresponding  attributeValues could be "1.3 L R2, Blue" . In this case, the API  will filter vehicles with an attribute name Vehicle.Body.Engine.Type that contains a value of 1.3 L R2 AND an attribute name Vehicle.Color that contains a value of "Blue". A request must contain unique values for the attributeNames  filter and the matching number of attributeValues filters to return the subset  of vehicles that match the attributes filter condition.
    ///   - attributeValues: Static information about a vehicle attribute value in string format. You can use this optional  parameter in conjunction with attributeNames to list the vehicles containing all  the attributeValues corresponding to the attributeNames filter. For  example, attributeValues could be "1.3 L R2, Blue" and the corresponding  attributeNames filter could be "Vehicle.Body.Engine.Type, Vehicle.Color".  In this case, the API will filter vehicles with attribute name Vehicle.Body.Engine.Type  that contains a value of 1.3 L R2 AND an attribute name Vehicle.Color that contains a value of "Blue". A request must contain unique values for the  attributeNames filter and the matching number of attributeValues  filter to return the subset of vehicles that match the attributes filter condition.
    ///   - listResponseScope: When you set the listResponseScope parameter to METADATA_ONLY, the list response includes: vehicle name, Amazon Resource Name (ARN), creation time, and last modification time.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - modelManifestArn:  The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVehiclesPaginator(
        attributeNames: [String]? = nil,
        attributeValues: [String]? = nil,
        listResponseScope: ListResponseScope? = nil,
        maxResults: Int? = nil,
        modelManifestArn: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVehiclesRequest, ListVehiclesResponse> {
        let input = ListVehiclesRequest(
            attributeNames: attributeNames, 
            attributeValues: attributeValues, 
            listResponseScope: listResponseScope, 
            maxResults: maxResults, 
            modelManifestArn: modelManifestArn
        )
        return self.listVehiclesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVehiclesInFleet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVehiclesInFleetPaginator(
        _ input: ListVehiclesInFleetRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVehiclesInFleetRequest, ListVehiclesInFleetResponse> {
        return .init(
            input: input,
            command: self.listVehiclesInFleet,
            inputKey: \ListVehiclesInFleetRequest.nextToken,
            outputKey: \ListVehiclesInFleetResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVehiclesInFleet(_:logger:)``.
    ///
    /// - Parameters:
    ///   - fleetId:  The ID of a fleet.
    ///   - maxResults: The maximum number of items to return, between 1 and 100, inclusive.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVehiclesInFleetPaginator(
        fleetId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVehiclesInFleetRequest, ListVehiclesInFleetResponse> {
        let input = ListVehiclesInFleetRequest(
            fleetId: fleetId, 
            maxResults: maxResults
        )
        return self.listVehiclesInFleetPaginator(input, logger: logger)
    }
}

extension IoTFleetWise.GetVehicleStatusRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.GetVehicleStatusRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            vehicleName: self.vehicleName
        )
    }
}

extension IoTFleetWise.ListCampaignsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListCampaignsRequest {
        return .init(
            listResponseScope: self.listResponseScope,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )
    }
}

extension IoTFleetWise.ListDecoderManifestNetworkInterfacesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListDecoderManifestNetworkInterfacesRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListDecoderManifestSignalsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListDecoderManifestSignalsRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListDecoderManifestsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListDecoderManifestsRequest {
        return .init(
            listResponseScope: self.listResponseScope,
            maxResults: self.maxResults,
            modelManifestArn: self.modelManifestArn,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListFleetsForVehicleRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListFleetsForVehicleRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            vehicleName: self.vehicleName
        )
    }
}

extension IoTFleetWise.ListFleetsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListFleetsRequest {
        return .init(
            listResponseScope: self.listResponseScope,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListModelManifestNodesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListModelManifestNodesRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListModelManifestsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListModelManifestsRequest {
        return .init(
            listResponseScope: self.listResponseScope,
            maxResults: self.maxResults,
            nextToken: token,
            signalCatalogArn: self.signalCatalogArn
        )
    }
}

extension IoTFleetWise.ListSignalCatalogNodesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListSignalCatalogNodesRequest {
        return .init(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            signalNodeType: self.signalNodeType
        )
    }
}

extension IoTFleetWise.ListSignalCatalogsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListSignalCatalogsRequest {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListStateTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListStateTemplatesRequest {
        return .init(
            listResponseScope: self.listResponseScope,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListVehiclesInFleetRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListVehiclesInFleetRequest {
        return .init(
            fleetId: self.fleetId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension IoTFleetWise.ListVehiclesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> IoTFleetWise.ListVehiclesRequest {
        return .init(
            attributeNames: self.attributeNames,
            attributeValues: self.attributeValues,
            listResponseScope: self.listResponseScope,
            maxResults: self.maxResults,
            modelManifestArn: self.modelManifestArn,
            nextToken: token
        )
    }
}
