//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if compiler(>=5.5.2) && canImport(_Concurrency)

import SotoCore

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension IoTFleetWise {
    // MARK: Async API Calls

    ///  Adds, or associates, a vehicle with a fleet.
    public func associateVehicleFleet(_ input: AssociateVehicleFleetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> AssociateVehicleFleetResponse {
        return try await self.client.execute(operation: "AssociateVehicleFleet", path: "/vehicles/{vehicleName}/associate", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Creates a group, or batch, of vehicles.   You must specify a decoder manifest and a vehicle model (model manifest) for each vehicle.   For more information, see Create multiple vehicles (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    public func batchCreateVehicle(_ input: BatchCreateVehicleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BatchCreateVehicleResponse {
        return try await self.client.execute(operation: "BatchCreateVehicle", path: "/vehicles", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Updates a group, or batch, of vehicles.  You must specify a decoder manifest and a vehicle model (model manifest) for each vehicle.   For more information, see Update multiple vehicles (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    public func batchUpdateVehicle(_ input: BatchUpdateVehicleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> BatchUpdateVehicleResponse {
        return try await self.client.execute(operation: "BatchUpdateVehicle", path: "/vehicles", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates an orchestration of data collection rules. The Amazon Web Services IoT FleetWise Edge Agent software running in vehicles uses campaigns to decide how to collect and transfer data to the cloud. You create campaigns in the cloud. After you or your team approve campaigns, Amazon Web Services IoT FleetWise automatically deploys them to vehicles.  For more information, see Collect and transfer data with campaigns in the Amazon Web Services IoT FleetWise Developer Guide.
    public func createCampaign(_ input: CreateCampaignRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateCampaignResponse {
        return try await self.client.execute(operation: "CreateCampaign", path: "/campaigns/{name}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates the decoder manifest associated with a model manifest. To create a decoder manifest, the following must be true:   Every signal decoder has a unique name.   Each signal decoder is associated with a network interface.   Each network interface has a unique ID.   The signal decoders are specified in the model manifest.
    public func createDecoderManifest(_ input: CreateDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateDecoderManifestResponse {
        return try await self.client.execute(operation: "CreateDecoderManifest", path: "/decoder-manifests/{name}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Creates a fleet that represents a group of vehicles.   You must create both a signal catalog and vehicles before you can create a fleet.   For more information, see Fleets in the Amazon Web Services IoT FleetWise Developer Guide.
    public func createFleet(_ input: CreateFleetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateFleetResponse {
        return try await self.client.execute(operation: "CreateFleet", path: "/fleets/{fleetId}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Creates a vehicle model (model manifest) that specifies signals (attributes, branches, sensors, and actuators).  For more information, see Vehicle models in the Amazon Web Services IoT FleetWise Developer Guide.
    public func createModelManifest(_ input: CreateModelManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateModelManifestResponse {
        return try await self.client.execute(operation: "CreateModelManifest", path: "/model-manifests/{name}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Creates a collection of standardized signals that can be reused to create vehicle models.
    public func createSignalCatalog(_ input: CreateSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateSignalCatalogResponse {
        return try await self.client.execute(operation: "CreateSignalCatalog", path: "/signal-catalogs/{name}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Creates a vehicle, which is an instance of a vehicle model (model manifest). Vehicles created from the same vehicle model consist of the same signals inherited from the vehicle model.  If you have an existing Amazon Web Services IoT Thing, you can use Amazon Web Services IoT FleetWise to create a vehicle and collect data from your thing.   For more information, see Create a vehicle (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.
    public func createVehicle(_ input: CreateVehicleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> CreateVehicleResponse {
        return try await self.client.execute(operation: "CreateVehicle", path: "/vehicles/{vehicleName}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Deletes a data collection campaign. Deleting a campaign suspends all data collection and removes it from any vehicles.
    public func deleteCampaign(_ input: DeleteCampaignRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteCampaignResponse {
        return try await self.client.execute(operation: "DeleteCampaign", path: "/campaigns/{name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Deletes a decoder manifest. You can't delete a decoder manifest if it has vehicles associated with it.   If the decoder manifest is successfully deleted, Amazon Web Services IoT FleetWise sends back an HTTP 200 response with an empty body.
    public func deleteDecoderManifest(_ input: DeleteDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteDecoderManifestResponse {
        return try await self.client.execute(operation: "DeleteDecoderManifest", path: "/decoder-manifests/{name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Deletes a fleet. Before you delete a fleet, all vehicles must be dissociated from the fleet. For more information, see Delete a fleet (AWS CLI) in the Amazon Web Services IoT FleetWise Developer Guide.  If the fleet is successfully deleted, Amazon Web Services IoT FleetWise sends back an HTTP 200 response with an empty body.
    public func deleteFleet(_ input: DeleteFleetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteFleetResponse {
        return try await self.client.execute(operation: "DeleteFleet", path: "/fleets/{fleetId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Deletes a vehicle model (model manifest).  If the vehicle model is successfully deleted, Amazon Web Services IoT FleetWise sends back an HTTP 200 response with an empty body.
    public func deleteModelManifest(_ input: DeleteModelManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteModelManifestResponse {
        return try await self.client.execute(operation: "DeleteModelManifest", path: "/model-manifests/{name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Deletes a signal catalog.   If the signal catalog is successfully deleted, Amazon Web Services IoT FleetWise sends back an HTTP 200 response with an empty body.
    public func deleteSignalCatalog(_ input: DeleteSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteSignalCatalogResponse {
        return try await self.client.execute(operation: "DeleteSignalCatalog", path: "/signal-catalogs/{name}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Deletes a vehicle and removes it from any campaigns.  If the vehicle is successfully deleted, Amazon Web Services IoT FleetWise sends back an HTTP 200 response with an empty body.
    public func deleteVehicle(_ input: DeleteVehicleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DeleteVehicleResponse {
        return try await self.client.execute(operation: "DeleteVehicle", path: "/vehicles/{vehicleName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes, or disassociates, a vehicle from a fleet. Disassociating a vehicle from a fleet doesn't delete the vehicle.  If the vehicle is successfully dissociated from a fleet, Amazon Web Services IoT FleetWise sends back an HTTP 200 response with an empty body.
    public func disassociateVehicleFleet(_ input: DisassociateVehicleFleetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> DisassociateVehicleFleetResponse {
        return try await self.client.execute(operation: "DisassociateVehicleFleet", path: "/vehicles/{vehicleName}/disassociate", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about a campaign.
    public func getCampaign(_ input: GetCampaignRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetCampaignResponse {
        return try await self.client.execute(operation: "GetCampaign", path: "/campaigns/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about a created decoder manifest.
    public func getDecoderManifest(_ input: GetDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetDecoderManifestResponse {
        return try await self.client.execute(operation: "GetDecoderManifest", path: "/decoder-manifests/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about a fleet.
    public func getFleet(_ input: GetFleetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetFleetResponse {
        return try await self.client.execute(operation: "GetFleet", path: "/fleets/{fleetId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves the logging options.
    public func getLoggingOptions(_ input: GetLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetLoggingOptionsResponse {
        return try await self.client.execute(operation: "GetLoggingOptions", path: "/loggingOptions", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about a vehicle model (model manifest).
    public func getModelManifest(_ input: GetModelManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetModelManifestResponse {
        return try await self.client.execute(operation: "GetModelManifest", path: "/model-manifests/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about the status of registering your Amazon Web Services account, IAM, and Amazon Timestream resources so that Amazon Web Services IoT FleetWise can transfer your vehicle data to the Amazon Web Services Cloud.  For more information, including step-by-step procedures, see Setting up Amazon Web Services IoT FleetWise.   This API operation doesn't require input parameters.
    public func getRegisterAccountStatus(_ input: GetRegisterAccountStatusRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetRegisterAccountStatusResponse {
        return try await self.client.execute(operation: "GetRegisterAccountStatus", path: "/account/registration_status", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about a signal catalog.
    public func getSignalCatalog(_ input: GetSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetSignalCatalogResponse {
        return try await self.client.execute(operation: "GetSignalCatalog", path: "/signal-catalogs/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about a vehicle.
    public func getVehicle(_ input: GetVehicleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetVehicleResponse {
        return try await self.client.execute(operation: "GetVehicle", path: "/vehicles/{vehicleName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information about the status of a vehicle with any associated campaigns.
    public func getVehicleStatus(_ input: GetVehicleStatusRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> GetVehicleStatusResponse {
        return try await self.client.execute(operation: "GetVehicleStatus", path: "/vehicles/{vehicleName}/status", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Creates a decoder manifest using your existing CAN DBC file from your local device.
    public func importDecoderManifest(_ input: ImportDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ImportDecoderManifestResponse {
        return try await self.client.execute(operation: "ImportDecoderManifest", path: "/decoder-manifests/{name}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Creates a signal catalog using your existing VSS formatted content from your local device.
    public func importSignalCatalog(_ input: ImportSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ImportSignalCatalogResponse {
        return try await self.client.execute(operation: "ImportSignalCatalog", path: "/signal-catalogs/{name}/nodes", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Lists information about created campaigns.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listCampaigns(_ input: ListCampaignsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListCampaignsResponse {
        return try await self.client.execute(operation: "ListCampaigns", path: "/campaigns", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Lists the network interfaces specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listDecoderManifestNetworkInterfaces(_ input: ListDecoderManifestNetworkInterfacesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListDecoderManifestNetworkInterfacesResponse {
        return try await self.client.execute(operation: "ListDecoderManifestNetworkInterfaces", path: "/decoder-manifests/{name}/network-interfaces", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  A list of information about signal decoders specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listDecoderManifestSignals(_ input: ListDecoderManifestSignalsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListDecoderManifestSignalsResponse {
        return try await self.client.execute(operation: "ListDecoderManifestSignals", path: "/decoder-manifests/{name}/signals", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Lists decoder manifests.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listDecoderManifests(_ input: ListDecoderManifestsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListDecoderManifestsResponse {
        return try await self.client.execute(operation: "ListDecoderManifests", path: "/decoder-manifests", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves information for each created fleet in an Amazon Web Services account.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listFleets(_ input: ListFleetsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListFleetsResponse {
        return try await self.client.execute(operation: "ListFleets", path: "/fleets", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a list of IDs for all fleets that the vehicle is associated with.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listFleetsForVehicle(_ input: ListFleetsForVehicleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListFleetsForVehicleResponse {
        return try await self.client.execute(operation: "ListFleetsForVehicle", path: "/vehicles/{vehicleName}/fleets", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Lists information about nodes specified in a vehicle model (model manifest).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listModelManifestNodes(_ input: ListModelManifestNodesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListModelManifestNodesResponse {
        return try await self.client.execute(operation: "ListModelManifestNodes", path: "/model-manifests/{name}/nodes", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves a list of vehicle models (model manifests).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listModelManifests(_ input: ListModelManifestsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListModelManifestsResponse {
        return try await self.client.execute(operation: "ListModelManifests", path: "/model-manifests", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Lists of information about the signals (nodes) specified in a signal catalog.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listSignalCatalogNodes(_ input: ListSignalCatalogNodesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListSignalCatalogNodesResponse {
        return try await self.client.execute(operation: "ListSignalCatalogNodes", path: "/signal-catalogs/{name}/nodes", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Lists all the created signal catalogs in an Amazon Web Services account.  You can use  to list information about each signal (node) specified in a signal catalog.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listSignalCatalogs(_ input: ListSignalCatalogsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListSignalCatalogsResponse {
        return try await self.client.execute(operation: "ListSignalCatalogs", path: "/signal-catalogs", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the tags (metadata) you have assigned to the resource.
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListTagsForResourceResponse {
        return try await self.client.execute(operation: "ListTagsForResource", path: "/tags", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves a list of summaries of created vehicles.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listVehicles(_ input: ListVehiclesRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListVehiclesResponse {
        return try await self.client.execute(operation: "ListVehicles", path: "/vehicles", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Retrieves a list of summaries of all vehicles associated with a fleet.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    public func listVehiclesInFleet(_ input: ListVehiclesInFleetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> ListVehiclesInFleetResponse {
        return try await self.client.execute(operation: "ListVehiclesInFleet", path: "/fleets/{fleetId}/vehicles", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates or updates the logging option.
    public func putLoggingOptions(_ input: PutLoggingOptionsRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> PutLoggingOptionsResponse {
        return try await self.client.execute(operation: "PutLoggingOptions", path: "/loggingOptions", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Registers your Amazon Web Services account, IAM, and Amazon Timestream resources so Amazon Web Services IoT FleetWise can transfer your vehicle data to the Amazon Web Services Cloud. For more information, including step-by-step procedures, see Setting up Amazon Web Services IoT FleetWise.   An Amazon Web Services account is not the same thing as a "user account". An Amazon Web Services user is an identity that you create using Identity and Access Management (IAM) and takes the form of either an IAM user or an IAM role, both with credentials. A single Amazon Web Services account can, and typically does, contain many users and roles.
    public func registerAccount(_ input: RegisterAccountRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> RegisterAccountResponse {
        return try await self.client.execute(operation: "RegisterAccount", path: "/account/registration", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds to or modifies the tags of the given resource. Tags are metadata which can be used to manage a resource.
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> TagResourceResponse {
        return try await self.client.execute(operation: "TagResource", path: "/tags", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes the given tags (metadata) from the resource.
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UntagResourceResponse {
        return try await self.client.execute(operation: "UntagResource", path: "/tags", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Updates a campaign.
    public func updateCampaign(_ input: UpdateCampaignRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateCampaignResponse {
        return try await self.client.execute(operation: "UpdateCampaign", path: "/campaigns/{name}", httpMethod: .PUT, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Updates a decoder manifest. A decoder manifest can only be updated when the status is DRAFT. Only ACTIVE decoder manifests can be associated with vehicles.
    public func updateDecoderManifest(_ input: UpdateDecoderManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateDecoderManifestResponse {
        return try await self.client.execute(operation: "UpdateDecoderManifest", path: "/decoder-manifests/{name}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Updates the description of an existing fleet.   If the fleet is successfully updated, Amazon Web Services IoT FleetWise sends back an HTTP 200 response with an empty HTTP body.
    public func updateFleet(_ input: UpdateFleetRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateFleetResponse {
        return try await self.client.execute(operation: "UpdateFleet", path: "/fleets/{fleetId}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Updates a vehicle model (model manifest). If created vehicles are associated with a vehicle model, it can't be updated.
    public func updateModelManifest(_ input: UpdateModelManifestRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateModelManifestResponse {
        return try await self.client.execute(operation: "UpdateModelManifest", path: "/model-manifests/{name}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Updates a signal catalog.
    public func updateSignalCatalog(_ input: UpdateSignalCatalogRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateSignalCatalogResponse {
        return try await self.client.execute(operation: "UpdateSignalCatalog", path: "/signal-catalogs/{name}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    ///  Updates a vehicle.
    public func updateVehicle(_ input: UpdateVehicleRequest, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) async throws -> UpdateVehicleResponse {
        return try await self.client.execute(operation: "UpdateVehicle", path: "/vehicles/{vehicleName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension IoTFleetWise {
    ///   Retrieves information about the status of a vehicle with any associated campaigns.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func getVehicleStatusPaginator(
        _ input: GetVehicleStatusRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<GetVehicleStatusRequest, GetVehicleStatusResponse> {
        return .init(
            input: input,
            command: self.getVehicleStatus,
            inputKey: \GetVehicleStatusRequest.nextToken,
            outputKey: \GetVehicleStatusResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Lists information about created campaigns.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listCampaignsPaginator(
        _ input: ListCampaignsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListCampaignsRequest, ListCampaignsResponse> {
        return .init(
            input: input,
            command: self.listCampaigns,
            inputKey: \ListCampaignsRequest.nextToken,
            outputKey: \ListCampaignsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Lists the network interfaces specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listDecoderManifestNetworkInterfacesPaginator(
        _ input: ListDecoderManifestNetworkInterfacesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestNetworkInterfacesRequest, ListDecoderManifestNetworkInterfacesResponse> {
        return .init(
            input: input,
            command: self.listDecoderManifestNetworkInterfaces,
            inputKey: \ListDecoderManifestNetworkInterfacesRequest.nextToken,
            outputKey: \ListDecoderManifestNetworkInterfacesResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   A list of information about signal decoders specified in a decoder manifest.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listDecoderManifestSignalsPaginator(
        _ input: ListDecoderManifestSignalsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestSignalsRequest, ListDecoderManifestSignalsResponse> {
        return .init(
            input: input,
            command: self.listDecoderManifestSignals,
            inputKey: \ListDecoderManifestSignalsRequest.nextToken,
            outputKey: \ListDecoderManifestSignalsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Lists decoder manifests.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listDecoderManifestsPaginator(
        _ input: ListDecoderManifestsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListDecoderManifestsRequest, ListDecoderManifestsResponse> {
        return .init(
            input: input,
            command: self.listDecoderManifests,
            inputKey: \ListDecoderManifestsRequest.nextToken,
            outputKey: \ListDecoderManifestsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Retrieves information for each created fleet in an Amazon Web Services account.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listFleetsPaginator(
        _ input: ListFleetsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListFleetsRequest, ListFleetsResponse> {
        return .init(
            input: input,
            command: self.listFleets,
            inputKey: \ListFleetsRequest.nextToken,
            outputKey: \ListFleetsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///  Retrieves a list of IDs for all fleets that the vehicle is associated with.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listFleetsForVehiclePaginator(
        _ input: ListFleetsForVehicleRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListFleetsForVehicleRequest, ListFleetsForVehicleResponse> {
        return .init(
            input: input,
            command: self.listFleetsForVehicle,
            inputKey: \ListFleetsForVehicleRequest.nextToken,
            outputKey: \ListFleetsForVehicleResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Lists information about nodes specified in a vehicle model (model manifest).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listModelManifestNodesPaginator(
        _ input: ListModelManifestNodesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListModelManifestNodesRequest, ListModelManifestNodesResponse> {
        return .init(
            input: input,
            command: self.listModelManifestNodes,
            inputKey: \ListModelManifestNodesRequest.nextToken,
            outputKey: \ListModelManifestNodesResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Retrieves a list of vehicle models (model manifests).   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listModelManifestsPaginator(
        _ input: ListModelManifestsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListModelManifestsRequest, ListModelManifestsResponse> {
        return .init(
            input: input,
            command: self.listModelManifests,
            inputKey: \ListModelManifestsRequest.nextToken,
            outputKey: \ListModelManifestsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Lists of information about the signals (nodes) specified in a signal catalog.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listSignalCatalogNodesPaginator(
        _ input: ListSignalCatalogNodesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListSignalCatalogNodesRequest, ListSignalCatalogNodesResponse> {
        return .init(
            input: input,
            command: self.listSignalCatalogNodes,
            inputKey: \ListSignalCatalogNodesRequest.nextToken,
            outputKey: \ListSignalCatalogNodesResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Lists all the created signal catalogs in an Amazon Web Services account.  You can use  to list information about each signal (node) specified in a signal catalog.  This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listSignalCatalogsPaginator(
        _ input: ListSignalCatalogsRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListSignalCatalogsRequest, ListSignalCatalogsResponse> {
        return .init(
            input: input,
            command: self.listSignalCatalogs,
            inputKey: \ListSignalCatalogsRequest.nextToken,
            outputKey: \ListSignalCatalogsResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Retrieves a list of summaries of created vehicles.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listVehiclesPaginator(
        _ input: ListVehiclesRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListVehiclesRequest, ListVehiclesResponse> {
        return .init(
            input: input,
            command: self.listVehicles,
            inputKey: \ListVehiclesRequest.nextToken,
            outputKey: \ListVehiclesResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }

    ///   Retrieves a list of summaries of all vehicles associated with a fleet.   This API operation uses pagination. Specify the nextToken parameter in the request to return more results.
    /// Return PaginatorSequence for operation.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    public func listVehiclesInFleetPaginator(
        _ input: ListVehiclesInFleetRequest,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil
    ) -> AWSClient.PaginatorSequence<ListVehiclesInFleetRequest, ListVehiclesInFleetResponse> {
        return .init(
            input: input,
            command: self.listVehiclesInFleet,
            inputKey: \ListVehiclesInFleetRequest.nextToken,
            outputKey: \ListVehiclesInFleetResponse.nextToken,
            logger: logger,
            on: eventLoop
        )
    }
}

#endif // compiler(>=5.5.2) && canImport(_Concurrency)
