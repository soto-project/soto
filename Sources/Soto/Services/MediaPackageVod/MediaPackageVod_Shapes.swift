//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension MediaPackageVod {
    // MARK: Enums

    public enum AdMarkers: String, CustomStringConvertible, Codable {
        case none = "NONE"
        case passthrough = "PASSTHROUGH"
        case scte35Enhanced = "SCTE35_ENHANCED"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMethod: String, CustomStringConvertible, Codable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum ManifestLayout: String, CustomStringConvertible, Codable {
        case compact = "COMPACT"
        case full = "FULL"
        public var description: String { return self.rawValue }
    }

    public enum Profile: String, CustomStringConvertible, Codable {
        case hbbtv15 = "HBBTV_1_5"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum SegmentTemplateFormat: String, CustomStringConvertible, Codable {
        case numberWithDuration = "NUMBER_WITH_DURATION"
        case numberWithTimeline = "NUMBER_WITH_TIMELINE"
        case timeWithTimeline = "TIME_WITH_TIMELINE"
        public var description: String { return self.rawValue }
    }

    public enum StreamOrder: String, CustomStringConvertible, Codable {
        case original = "ORIGINAL"
        case videoBitrateAscending = "VIDEO_BITRATE_ASCENDING"
        case videoBitrateDescending = "VIDEO_BITRATE_DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum Periodtriggerselement: String, CustomStringConvertible, Codable {
        case ads = "ADS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssetShallow: AWSDecodableShape {
        /// The ARN of the Asset.
        public let arn: String?
        /// The time the Asset was initially submitted for Ingest.
        public let createdAt: String?
        /// The unique identifier for the Asset.
        public let id: String?
        /// The ID of the PackagingGroup for the Asset.
        public let packagingGroupId: String?
        /// The resource ID to include in SPEKE key requests.
        public let resourceId: String?
        /// ARN of the source object in S3.
        public let sourceArn: String?
        /// The IAM role ARN used to access the source S3 bucket.
        public let sourceRoleArn: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case id
            case packagingGroupId
            case resourceId
            case sourceArn
            case sourceRoleArn
            case tags
        }
    }

    public struct Authorization: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the secret in AWS Secrets Manager that is used for CDN authorization.
        public let cdnIdentifierSecret: String
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        public let secretsRoleArn: String

        public init(cdnIdentifierSecret: String, secretsRoleArn: String) {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case cdnIdentifierSecret
            case secretsRoleArn
        }
    }

    public struct CmafEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public let constantInitializationVector: String?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(constantInitializationVector: String? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector
            case spekeKeyProvider
        }
    }

    public struct CmafPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations.
        public let hlsManifests: [HlsManifest]
        /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
        public let includeEncoderConfigurationInSegments: Bool?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?

        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifest], includeEncoderConfigurationInSegments: Bool? = nil, segmentDurationSeconds: Int? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
            self.segmentDurationSeconds = segmentDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case encryption
            case hlsManifests
            case includeEncoderConfigurationInSegments
            case segmentDurationSeconds
        }
    }

    public struct ConfigureLogsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let egressAccessLogs: EgressAccessLogs?
        public let id: String

        public init(egressAccessLogs: EgressAccessLogs? = nil, id: String) {
            self.egressAccessLogs = egressAccessLogs
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case egressAccessLogs
        }
    }

    public struct ConfigureLogsResponse: AWSDecodableShape {
        public let arn: String?
        public let authorization: Authorization?
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case domainName
            case egressAccessLogs
            case id
            case tags
        }
    }

    public struct CreateAssetRequest: AWSEncodableShape {
        public let id: String
        public let packagingGroupId: String
        public let resourceId: String?
        public let sourceArn: String
        public let sourceRoleArn: String
        public let tags: [String: String]?

        public init(id: String, packagingGroupId: String, resourceId: String? = nil, sourceArn: String, sourceRoleArn: String, tags: [String: String]? = nil) {
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case id
            case packagingGroupId
            case resourceId
            case sourceArn
            case sourceRoleArn
            case tags
        }
    }

    public struct CreateAssetResponse: AWSDecodableShape {
        public let arn: String?
        public let createdAt: String?
        public let egressEndpoints: [EgressEndpoint]?
        public let id: String?
        public let packagingGroupId: String?
        public let resourceId: String?
        public let sourceArn: String?
        public let sourceRoleArn: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, egressEndpoints: [EgressEndpoint]? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.egressEndpoints = egressEndpoints
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case egressEndpoints
            case id
            case packagingGroupId
            case resourceId
            case sourceArn
            case sourceRoleArn
            case tags
        }
    }

    public struct CreatePackagingConfigurationRequest: AWSEncodableShape {
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        public let id: String
        public let mssPackage: MssPackage?
        public let packagingGroupId: String
        public let tags: [String: String]?

        public init(cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String, mssPackage: MssPackage? = nil, packagingGroupId: String, tags: [String: String]? = nil) {
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cmafPackage
            case dashPackage
            case hlsPackage
            case id
            case mssPackage
            case packagingGroupId
            case tags
        }
    }

    public struct CreatePackagingConfigurationResponse: AWSDecodableShape {
        public let arn: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let mssPackage: MssPackage?
        public let packagingGroupId: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case cmafPackage
            case dashPackage
            case hlsPackage
            case id
            case mssPackage
            case packagingGroupId
            case tags
        }
    }

    public struct CreatePackagingGroupRequest: AWSEncodableShape {
        public let authorization: Authorization?
        public let egressAccessLogs: EgressAccessLogs?
        public let id: String
        public let tags: [String: String]?

        public init(authorization: Authorization? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String, tags: [String: String]? = nil) {
            self.authorization = authorization
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case authorization
            case egressAccessLogs
            case id
            case tags
        }
    }

    public struct CreatePackagingGroupResponse: AWSDecodableShape {
        public let arn: String?
        public let authorization: Authorization?
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case domainName
            case egressAccessLogs
            case id
            case tags
        }
    }

    public struct DashEncryption: AWSEncodableShape & AWSDecodableShape {
        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider
        }
    }

    public struct DashManifest: AWSEncodableShape & AWSDecodableShape {
        /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public let manifestLayout: ManifestLayout?
        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public let minBufferTimeSeconds: Int?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public let profile: Profile?
        public let streamSelection: StreamSelection?

        public init(manifestLayout: ManifestLayout? = nil, manifestName: String? = nil, minBufferTimeSeconds: Int? = nil, profile: Profile? = nil, streamSelection: StreamSelection? = nil) {
            self.manifestLayout = manifestLayout
            self.manifestName = manifestName
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.profile = profile
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case manifestLayout
            case manifestName
            case minBufferTimeSeconds
            case profile
            case streamSelection
        }
    }

    public struct DashPackage: AWSEncodableShape & AWSDecodableShape {
        /// A list of DASH manifest configurations.
        public let dashManifests: [DashManifest]
        public let encryption: DashEncryption?
        /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
        public let includeEncoderConfigurationInSegments: Bool?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
        /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
        /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
        /// the Asset contains SCTE-35 ad markers.
        public let periodTriggers: [Periodtriggerselement]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public let segmentTemplateFormat: SegmentTemplateFormat?

        public init(dashManifests: [DashManifest], encryption: DashEncryption? = nil, includeEncoderConfigurationInSegments: Bool? = nil, periodTriggers: [Periodtriggerselement]? = nil, segmentDurationSeconds: Int? = nil, segmentTemplateFormat: SegmentTemplateFormat? = nil) {
            self.dashManifests = dashManifests
            self.encryption = encryption
            self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
            self.periodTriggers = periodTriggers
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
        }

        private enum CodingKeys: String, CodingKey {
            case dashManifests
            case encryption
            case includeEncoderConfigurationInSegments
            case periodTriggers
            case segmentDurationSeconds
            case segmentTemplateFormat
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePackagingConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackagingConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePackagingGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackagingGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAssetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetResponse: AWSDecodableShape {
        public let arn: String?
        public let createdAt: String?
        public let egressEndpoints: [EgressEndpoint]?
        public let id: String?
        public let packagingGroupId: String?
        public let resourceId: String?
        public let sourceArn: String?
        public let sourceRoleArn: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: String? = nil, egressEndpoints: [EgressEndpoint]? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.egressEndpoints = egressEndpoints
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case egressEndpoints
            case id
            case packagingGroupId
            case resourceId
            case sourceArn
            case sourceRoleArn
            case tags
        }
    }

    public struct DescribePackagingConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackagingConfigurationResponse: AWSDecodableShape {
        public let arn: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        public let id: String?
        public let mssPackage: MssPackage?
        public let packagingGroupId: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case cmafPackage
            case dashPackage
            case hlsPackage
            case id
            case mssPackage
            case packagingGroupId
            case tags
        }
    }

    public struct DescribePackagingGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackagingGroupResponse: AWSDecodableShape {
        public let arn: String?
        public let authorization: Authorization?
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case domainName
            case egressAccessLogs
            case id
            case tags
        }
    }

    public struct EgressAccessLogs: AWSEncodableShape & AWSDecodableShape {
        /// Customize the log group name.
        public let logGroupName: String?

        public init(logGroupName: String? = nil) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName
        }
    }

    public struct EgressEndpoint: AWSDecodableShape {
        /// The ID of the PackagingConfiguration being applied to the Asset.
        public let packagingConfigurationId: String?
        /// The URL of the parent manifest for the repackaged Asset.
        public let url: String?

        public init(packagingConfigurationId: String? = nil, url: String? = nil) {
            self.packagingConfigurationId = packagingConfigurationId
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case packagingConfigurationId
            case url
        }
    }

    public struct HlsEncryption: AWSEncodableShape & AWSDecodableShape {
        /// A constant initialization vector for encryption (optional).
        /// When not specified the initialization vector will be periodically rotated.
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod?
        public let spekeKeyProvider: SpekeKeyProvider

        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod? = nil, spekeKeyProvider: SpekeKeyProvider) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector
            case encryptionMethod
            case spekeKeyProvider
        }
    }

    public struct HlsManifest: AWSEncodableShape & AWSDecodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public let repeatExtXKey: Bool?
        public let streamSelection: StreamSelection?

        public init(adMarkers: AdMarkers? = nil, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, programDateTimeIntervalSeconds: Int? = nil, repeatExtXKey: Bool? = nil, streamSelection: StreamSelection? = nil) {
            self.adMarkers = adMarkers
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers
            case includeIframeOnlyStream
            case manifestName
            case programDateTimeIntervalSeconds
            case repeatExtXKey
            case streamSelection
        }
    }

    public struct HlsPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: HlsEncryption?
        /// A list of HLS manifest configurations.
        public let hlsManifests: [HlsManifest]
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public let useAudioRenditionGroup: Bool?

        public init(encryption: HlsEncryption? = nil, hlsManifests: [HlsManifest], segmentDurationSeconds: Int? = nil, useAudioRenditionGroup: Bool? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.segmentDurationSeconds = segmentDurationSeconds
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case encryption
            case hlsManifests
            case segmentDurationSeconds
            case useAudioRenditionGroup
        }
    }

    public struct ListAssetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "packagingGroupId", location: .querystring(locationName: "packagingGroupId"))
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let packagingGroupId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, packagingGroupId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packagingGroupId = packagingGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsResponse: AWSDecodableShape {
        public let assets: [AssetShallow]?
        public let nextToken: String?

        public init(assets: [AssetShallow]? = nil, nextToken: String? = nil) {
            self.assets = assets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assets
            case nextToken
        }
    }

    public struct ListPackagingConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "packagingGroupId", location: .querystring(locationName: "packagingGroupId"))
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let packagingGroupId: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, packagingGroupId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packagingGroupId = packagingGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagingConfigurationsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let packagingConfigurations: [PackagingConfiguration]?

        public init(nextToken: String? = nil, packagingConfigurations: [PackagingConfiguration]? = nil) {
            self.nextToken = nextToken
            self.packagingConfigurations = packagingConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case packagingConfigurations
        }
    }

    public struct ListPackagingGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagingGroupsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let packagingGroups: [PackagingGroup]?

        public init(nextToken: String? = nil, packagingGroups: [PackagingGroup]? = nil) {
            self.nextToken = nextToken
            self.packagingGroups = packagingGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case packagingGroups
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct MssEncryption: AWSEncodableShape & AWSDecodableShape {
        public let spekeKeyProvider: SpekeKeyProvider

        public init(spekeKeyProvider: SpekeKeyProvider) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider
        }
    }

    public struct MssManifest: AWSEncodableShape & AWSDecodableShape {
        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        public let streamSelection: StreamSelection?

        public init(manifestName: String? = nil, streamSelection: StreamSelection? = nil) {
            self.manifestName = manifestName
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName
            case streamSelection
        }
    }

    public struct MssPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: MssEncryption?
        /// A list of MSS manifest configurations.
        public let mssManifests: [MssManifest]
        /// The duration (in seconds) of each segment.
        public let segmentDurationSeconds: Int?

        public init(encryption: MssEncryption? = nil, mssManifests: [MssManifest], segmentDurationSeconds: Int? = nil) {
            self.encryption = encryption
            self.mssManifests = mssManifests
            self.segmentDurationSeconds = segmentDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case encryption
            case mssManifests
            case segmentDurationSeconds
        }
    }

    public struct PackagingConfiguration: AWSDecodableShape {
        /// The ARN of the PackagingConfiguration.
        public let arn: String?
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        /// The ID of the PackagingConfiguration.
        public let id: String?
        public let mssPackage: MssPackage?
        /// The ID of a PackagingGroup.
        public let packagingGroupId: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case cmafPackage
            case dashPackage
            case hlsPackage
            case id
            case mssPackage
            case packagingGroupId
            case tags
        }
    }

    public struct PackagingGroup: AWSDecodableShape {
        /// The ARN of the PackagingGroup.
        public let arn: String?
        public let authorization: Authorization?
        /// The fully qualified domain name for Assets in the PackagingGroup.
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case domainName
            case egressAccessLogs
            case id
            case tags
        }
    }

    public struct SpekeKeyProvider: AWSEncodableShape & AWSDecodableShape {
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        public let roleArn: String
        /// The system IDs to include in key requests.
        public let systemIds: [String]
        /// The URL of the external key provider service.
        public let url: String

        public init(roleArn: String, systemIds: [String], url: String) {
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn
            case systemIds
            case url
        }
    }

    public struct StreamSelection: AWSEncodableShape & AWSDecodableShape {
        /// The maximum video bitrate (bps) to include in output.
        public let maxVideoBitsPerSecond: Int?
        /// The minimum video bitrate (bps) to include in output.
        public let minVideoBitsPerSecond: Int?
        /// A directive that determines the order of streams in the output.
        public let streamOrder: StreamOrder?

        public init(maxVideoBitsPerSecond: Int? = nil, minVideoBitsPerSecond: Int? = nil, streamOrder: StreamOrder? = nil) {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxVideoBitsPerSecond
            case minVideoBitsPerSecond
            case streamOrder
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn"))
        ]

        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resource-arn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdatePackagingGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let authorization: Authorization?
        public let id: String

        public init(authorization: Authorization? = nil, id: String) {
            self.authorization = authorization
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case authorization
        }
    }

    public struct UpdatePackagingGroupResponse: AWSDecodableShape {
        public let arn: String?
        public let authorization: Authorization?
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        public let id: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, authorization: Authorization? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case authorization
            case domainName
            case egressAccessLogs
            case id
            case tags
        }
    }
}
