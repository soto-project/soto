//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension MediaPackageVod {
    // MARK: Enums

    public enum AdMarkers: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case none = "NONE"
        case passthrough = "PASSTHROUGH"
        case scte35Enhanced = "SCTE35_ENHANCED"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aes128 = "AES_128"
        case sampleAes = "SAMPLE_AES"
        public var description: String { return self.rawValue }
    }

    public enum ManifestLayout: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compact = "COMPACT"
        case full = "FULL"
        public var description: String { return self.rawValue }
    }

    public enum PeriodTriggersElement: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ads = "ADS"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Audio: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetAudio1 = "PRESET-AUDIO-1"
        case presetAudio2 = "PRESET-AUDIO-2"
        case presetAudio3 = "PRESET-AUDIO-3"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum PresetSpeke20Video: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case presetVideo1 = "PRESET-VIDEO-1"
        case presetVideo2 = "PRESET-VIDEO-2"
        case presetVideo3 = "PRESET-VIDEO-3"
        case presetVideo4 = "PRESET-VIDEO-4"
        case presetVideo5 = "PRESET-VIDEO-5"
        case presetVideo6 = "PRESET-VIDEO-6"
        case presetVideo7 = "PRESET-VIDEO-7"
        case presetVideo8 = "PRESET-VIDEO-8"
        case shared = "SHARED"
        case unencrypted = "UNENCRYPTED"
        public var description: String { return self.rawValue }
    }

    public enum Profile: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case hbbtv15 = "HBBTV_1_5"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ScteMarkersSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case manifest = "MANIFEST"
        case segments = "SEGMENTS"
        public var description: String { return self.rawValue }
    }

    public enum SegmentTemplateFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case numberWithDuration = "NUMBER_WITH_DURATION"
        case numberWithTimeline = "NUMBER_WITH_TIMELINE"
        case timeWithTimeline = "TIME_WITH_TIMELINE"
        public var description: String { return self.rawValue }
    }

    public enum StreamOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case original = "ORIGINAL"
        case videoBitrateAscending = "VIDEO_BITRATE_ASCENDING"
        case videoBitrateDescending = "VIDEO_BITRATE_DESCENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssetShallow: AWSDecodableShape {
        /// The ARN of the Asset.
        public let arn: String?
        /// The time the Asset was initially submitted for Ingest.
        public let createdAt: String?
        /// The unique identifier for the Asset.
        public let id: String?
        /// The ID of the PackagingGroup for the Asset.
        public let packagingGroupId: String?
        /// The resource ID to include in SPEKE key requests.
        public let resourceId: String?
        /// ARN of the source object in S3.
        public let sourceArn: String?
        /// The IAM role ARN used to access the source S3 bucket.
        public let sourceRoleArn: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, createdAt: String? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
            case tags = "tags"
        }
    }

    public struct Authorization: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the secret in AWS Secrets Manager that is used for CDN authorization.
        public let cdnIdentifierSecret: String?
        /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
        public let secretsRoleArn: String?

        @inlinable
        public init(cdnIdentifierSecret: String? = nil, secretsRoleArn: String? = nil) {
            self.cdnIdentifierSecret = cdnIdentifierSecret
            self.secretsRoleArn = secretsRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case cdnIdentifierSecret = "cdnIdentifierSecret"
            case secretsRoleArn = "secretsRoleArn"
        }
    }

    public struct CmafEncryption: AWSEncodableShape & AWSDecodableShape {
        /// An optional 128-bit, 16-byte hex value represented by a 32-character string, used in conjunction with the key for encrypting blocks. If you don't specify a value, then MediaPackage creates the constant initialization vector (IV).
        public let constantInitializationVector: String?
        public let spekeKeyProvider: SpekeKeyProvider?

        @inlinable
        public init(constantInitializationVector: String? = nil, spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.constantInitializationVector = constantInitializationVector
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct CmafPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: CmafEncryption?
        /// A list of HLS manifest configurations.
        public let hlsManifests: [HlsManifest]?
        /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
        public let includeEncoderConfigurationInSegments: Bool?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?

        @inlinable
        public init(encryption: CmafEncryption? = nil, hlsManifests: [HlsManifest]? = nil, includeEncoderConfigurationInSegments: Bool? = nil, segmentDurationSeconds: Int? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
            self.segmentDurationSeconds = segmentDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case includeEncoderConfigurationInSegments = "includeEncoderConfigurationInSegments"
            case segmentDurationSeconds = "segmentDurationSeconds"
        }
    }

    public struct ConfigureLogsRequest: AWSEncodableShape {
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of a MediaPackage VOD PackagingGroup resource.
        public let id: String

        @inlinable
        public init(egressAccessLogs: EgressAccessLogs? = nil, id: String) {
            self.egressAccessLogs = egressAccessLogs
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.egressAccessLogs, forKey: .egressAccessLogs)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: String, CodingKey {
            case egressAccessLogs = "egressAccessLogs"
        }
    }

    public struct ConfigureLogsResponse: AWSDecodableShape {
        /// The ARN of the PackagingGroup.
        public let arn: String?
        public let authorization: Authorization?
        /// The time the PackagingGroup was created.
        public let createdAt: String?
        /// The fully qualified domain name for Assets in the PackagingGroup.
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public let id: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, authorization: Authorization? = nil, createdAt: String? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.createdAt = createdAt
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case createdAt = "createdAt"
            case domainName = "domainName"
            case egressAccessLogs = "egressAccessLogs"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreateAssetRequest: AWSEncodableShape {
        /// The unique identifier for the Asset.
        public let id: String?
        /// The ID of the PackagingGroup for the Asset.
        public let packagingGroupId: String?
        /// The resource ID to include in SPEKE key requests.
        public let resourceId: String?
        /// ARN of the source object in S3.
        public let sourceArn: String?
        /// The IAM role ARN used to access the source S3 bucket.
        public let sourceRoleArn: String?
        public let tags: [String: String]?

        @inlinable
        public init(id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
            case tags = "tags"
        }
    }

    public struct CreateAssetResponse: AWSDecodableShape {
        /// The ARN of the Asset.
        public let arn: String?
        /// The time the Asset was initially submitted for Ingest.
        public let createdAt: String?
        /// The list of egress endpoints available for the Asset.
        public let egressEndpoints: [EgressEndpoint]?
        /// The unique identifier for the Asset.
        public let id: String?
        /// The ID of the PackagingGroup for the Asset.
        public let packagingGroupId: String?
        /// The resource ID to include in SPEKE key requests.
        public let resourceId: String?
        /// ARN of the source object in S3.
        public let sourceArn: String?
        /// The IAM role_arn used to access the source S3 bucket.
        public let sourceRoleArn: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, createdAt: String? = nil, egressEndpoints: [EgressEndpoint]? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.egressEndpoints = egressEndpoints
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case egressEndpoints = "egressEndpoints"
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
            case tags = "tags"
        }
    }

    public struct CreatePackagingConfigurationRequest: AWSEncodableShape {
        public let cmafPackage: CmafPackage?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        /// The ID of the PackagingConfiguration.
        public let id: String?
        public let mssPackage: MssPackage?
        /// The ID of a PackagingGroup.
        public let packagingGroupId: String?
        public let tags: [String: String]?

        @inlinable
        public init(cmafPackage: CmafPackage? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil, tags: [String: String]? = nil) {
            self.cmafPackage = cmafPackage
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case cmafPackage = "cmafPackage"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
            case tags = "tags"
        }
    }

    public struct CreatePackagingConfigurationResponse: AWSDecodableShape {
        /// The ARN of the PackagingConfiguration.
        public let arn: String?
        public let cmafPackage: CmafPackage?
        /// The time the PackagingConfiguration was created.
        public let createdAt: String?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        /// The ID of the PackagingConfiguration.
        public let id: String?
        public let mssPackage: MssPackage?
        /// The ID of a PackagingGroup.
        public let packagingGroupId: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, createdAt: String? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cmafPackage = "cmafPackage"
            case createdAt = "createdAt"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
            case tags = "tags"
        }
    }

    public struct CreatePackagingGroupRequest: AWSEncodableShape {
        public let authorization: Authorization?
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public let id: String?
        public let tags: [String: String]?

        @inlinable
        public init(authorization: Authorization? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.authorization = authorization
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case authorization = "authorization"
            case egressAccessLogs = "egressAccessLogs"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct CreatePackagingGroupResponse: AWSDecodableShape {
        /// The ARN of the PackagingGroup.
        public let arn: String?
        public let authorization: Authorization?
        /// The time the PackagingGroup was created.
        public let createdAt: String?
        /// The fully qualified domain name for Assets in the PackagingGroup.
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public let id: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, authorization: Authorization? = nil, createdAt: String? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.authorization = authorization
            self.createdAt = createdAt
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authorization = "authorization"
            case createdAt = "createdAt"
            case domainName = "domainName"
            case egressAccessLogs = "egressAccessLogs"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct DashEncryption: AWSEncodableShape & AWSDecodableShape {
        public let spekeKeyProvider: SpekeKeyProvider?

        @inlinable
        public init(spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct DashManifest: AWSEncodableShape & AWSDecodableShape {
        /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
        public let manifestLayout: ManifestLayout?
        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
        public let minBufferTimeSeconds: Int?
        /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
        public let profile: Profile?
        /// The source of scte markers used. When set to SEGMENTS, the scte markers are sourced from the segments of the ingested content. When set to MANIFEST, the scte markers are sourced from the manifest of the ingested content.
        public let scteMarkersSource: ScteMarkersSource?
        public let streamSelection: StreamSelection?

        @inlinable
        public init(manifestLayout: ManifestLayout? = nil, manifestName: String? = nil, minBufferTimeSeconds: Int? = nil, profile: Profile? = nil, scteMarkersSource: ScteMarkersSource? = nil, streamSelection: StreamSelection? = nil) {
            self.manifestLayout = manifestLayout
            self.manifestName = manifestName
            self.minBufferTimeSeconds = minBufferTimeSeconds
            self.profile = profile
            self.scteMarkersSource = scteMarkersSource
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case manifestLayout = "manifestLayout"
            case manifestName = "manifestName"
            case minBufferTimeSeconds = "minBufferTimeSeconds"
            case profile = "profile"
            case scteMarkersSource = "scteMarkersSource"
            case streamSelection = "streamSelection"
        }
    }

    public struct DashPackage: AWSEncodableShape & AWSDecodableShape {
        /// A list of DASH manifest configurations.
        public let dashManifests: [DashManifest]?
        public let encryption: DashEncryption?
        /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
        public let includeEncoderConfigurationInSegments: Bool?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
        /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
        /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
        /// the Asset contains SCTE-35 ad markers.
        public let periodTriggers: [PeriodTriggersElement]?
        /// Duration (in seconds) of each segment. Actual segments will be
        /// rounded to the nearest multiple of the source segment duration.
        public let segmentDurationSeconds: Int?
        /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
        public let segmentTemplateFormat: SegmentTemplateFormat?

        @inlinable
        public init(dashManifests: [DashManifest]? = nil, encryption: DashEncryption? = nil, includeEncoderConfigurationInSegments: Bool? = nil, includeIframeOnlyStream: Bool? = nil, periodTriggers: [PeriodTriggersElement]? = nil, segmentDurationSeconds: Int? = nil, segmentTemplateFormat: SegmentTemplateFormat? = nil) {
            self.dashManifests = dashManifests
            self.encryption = encryption
            self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.periodTriggers = periodTriggers
            self.segmentDurationSeconds = segmentDurationSeconds
            self.segmentTemplateFormat = segmentTemplateFormat
        }

        private enum CodingKeys: String, CodingKey {
            case dashManifests = "dashManifests"
            case encryption = "encryption"
            case includeEncoderConfigurationInSegments = "includeEncoderConfigurationInSegments"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case periodTriggers = "periodTriggers"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case segmentTemplateFormat = "segmentTemplateFormat"
        }
    }

    public struct DeleteAssetRequest: AWSEncodableShape {
        /// The ID of the MediaPackage VOD Asset resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAssetResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePackagingConfigurationRequest: AWSEncodableShape {
        /// The ID of the MediaPackage VOD PackagingConfiguration resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackagingConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePackagingGroupRequest: AWSEncodableShape {
        /// The ID of the MediaPackage VOD PackagingGroup resource to delete.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePackagingGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeAssetRequest: AWSEncodableShape {
        /// The ID of an MediaPackage VOD Asset resource.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAssetResponse: AWSDecodableShape {
        /// The ARN of the Asset.
        public let arn: String?
        /// The time the Asset was initially submitted for Ingest.
        public let createdAt: String?
        /// The list of egress endpoints available for the Asset.
        public let egressEndpoints: [EgressEndpoint]?
        /// The unique identifier for the Asset.
        public let id: String?
        /// The ID of the PackagingGroup for the Asset.
        public let packagingGroupId: String?
        /// The resource ID to include in SPEKE key requests.
        public let resourceId: String?
        /// ARN of the source object in S3.
        public let sourceArn: String?
        /// The IAM role_arn used to access the source S3 bucket.
        public let sourceRoleArn: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, createdAt: String? = nil, egressEndpoints: [EgressEndpoint]? = nil, id: String? = nil, packagingGroupId: String? = nil, resourceId: String? = nil, sourceArn: String? = nil, sourceRoleArn: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.egressEndpoints = egressEndpoints
            self.id = id
            self.packagingGroupId = packagingGroupId
            self.resourceId = resourceId
            self.sourceArn = sourceArn
            self.sourceRoleArn = sourceRoleArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case egressEndpoints = "egressEndpoints"
            case id = "id"
            case packagingGroupId = "packagingGroupId"
            case resourceId = "resourceId"
            case sourceArn = "sourceArn"
            case sourceRoleArn = "sourceRoleArn"
            case tags = "tags"
        }
    }

    public struct DescribePackagingConfigurationRequest: AWSEncodableShape {
        /// The ID of a MediaPackage VOD PackagingConfiguration resource.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackagingConfigurationResponse: AWSDecodableShape {
        /// The ARN of the PackagingConfiguration.
        public let arn: String?
        public let cmafPackage: CmafPackage?
        /// The time the PackagingConfiguration was created.
        public let createdAt: String?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        /// The ID of the PackagingConfiguration.
        public let id: String?
        public let mssPackage: MssPackage?
        /// The ID of a PackagingGroup.
        public let packagingGroupId: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, createdAt: String? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cmafPackage = "cmafPackage"
            case createdAt = "createdAt"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
            case tags = "tags"
        }
    }

    public struct DescribePackagingGroupRequest: AWSEncodableShape {
        /// The ID of a MediaPackage VOD PackagingGroup resource.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePackagingGroupResponse: AWSDecodableShape {
        /// The approximate asset count of the PackagingGroup.
        public let approximateAssetCount: Int?
        /// The ARN of the PackagingGroup.
        public let arn: String?
        public let authorization: Authorization?
        /// The time the PackagingGroup was created.
        public let createdAt: String?
        /// The fully qualified domain name for Assets in the PackagingGroup.
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public let id: String?
        public let tags: [String: String]?

        @inlinable
        public init(approximateAssetCount: Int? = nil, arn: String? = nil, authorization: Authorization? = nil, createdAt: String? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.approximateAssetCount = approximateAssetCount
            self.arn = arn
            self.authorization = authorization
            self.createdAt = createdAt
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case approximateAssetCount = "approximateAssetCount"
            case arn = "arn"
            case authorization = "authorization"
            case createdAt = "createdAt"
            case domainName = "domainName"
            case egressAccessLogs = "egressAccessLogs"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct EgressAccessLogs: AWSEncodableShape & AWSDecodableShape {
        /// Customize the log group name.
        public let logGroupName: String?

        @inlinable
        public init(logGroupName: String? = nil) {
            self.logGroupName = logGroupName
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupName = "logGroupName"
        }
    }

    public struct EgressEndpoint: AWSDecodableShape {
        /// The ID of the PackagingConfiguration being applied to the Asset.
        public let packagingConfigurationId: String?
        /// The current processing status of the asset used for the packaging configuration. The status can be either QUEUED, PROCESSING, PLAYABLE, or FAILED. Status information won't be available for most assets ingested before 2021-09-30.
        public let status: String?
        /// The URL of the parent manifest for the repackaged Asset.
        public let url: String?

        @inlinable
        public init(packagingConfigurationId: String? = nil, status: String? = nil, url: String? = nil) {
            self.packagingConfigurationId = packagingConfigurationId
            self.status = status
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case packagingConfigurationId = "packagingConfigurationId"
            case status = "status"
            case url = "url"
        }
    }

    public struct EncryptionContractConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A collection of audio encryption presets.
        public let presetSpeke20Audio: PresetSpeke20Audio?
        /// A collection of video encryption presets.
        public let presetSpeke20Video: PresetSpeke20Video?

        @inlinable
        public init(presetSpeke20Audio: PresetSpeke20Audio? = nil, presetSpeke20Video: PresetSpeke20Video? = nil) {
            self.presetSpeke20Audio = presetSpeke20Audio
            self.presetSpeke20Video = presetSpeke20Video
        }

        private enum CodingKeys: String, CodingKey {
            case presetSpeke20Audio = "presetSpeke20Audio"
            case presetSpeke20Video = "presetSpeke20Video"
        }
    }

    public struct HlsEncryption: AWSEncodableShape & AWSDecodableShape {
        /// A constant initialization vector for encryption (optional).
        /// When not specified the initialization vector will be periodically rotated.
        public let constantInitializationVector: String?
        /// The encryption method to use.
        public let encryptionMethod: EncryptionMethod?
        public let spekeKeyProvider: SpekeKeyProvider?

        @inlinable
        public init(constantInitializationVector: String? = nil, encryptionMethod: EncryptionMethod? = nil, spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.constantInitializationVector = constantInitializationVector
            self.encryptionMethod = encryptionMethod
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case constantInitializationVector = "constantInitializationVector"
            case encryptionMethod = "encryptionMethod"
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct HlsManifest: AWSEncodableShape & AWSDecodableShape {
        /// This setting controls how ad markers are included in the packaged OriginEndpoint.
        /// "NONE" will omit all SCTE-35 ad markers from the output.
        /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
        /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
        /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
        /// messages in the input source.
        public let adMarkers: AdMarkers?
        /// When enabled, an I-Frame only stream will be included in the output.
        public let includeIframeOnlyStream: Bool?
        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
        /// inserted into manifests. Additionally, when an interval is specified
        /// ID3Timed Metadata messages will be generated every 5 seconds using the
        /// ingest time of the content.
        /// If the interval is not specified, or set to 0, then
        /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
        /// ID3Timed Metadata messages will be generated. Note that irrespective
        /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
        /// it will be passed through to HLS output.
        public let programDateTimeIntervalSeconds: Int?
        /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
        public let repeatExtXKey: Bool?
        public let streamSelection: StreamSelection?

        @inlinable
        public init(adMarkers: AdMarkers? = nil, includeIframeOnlyStream: Bool? = nil, manifestName: String? = nil, programDateTimeIntervalSeconds: Int? = nil, repeatExtXKey: Bool? = nil, streamSelection: StreamSelection? = nil) {
            self.adMarkers = adMarkers
            self.includeIframeOnlyStream = includeIframeOnlyStream
            self.manifestName = manifestName
            self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
            self.repeatExtXKey = repeatExtXKey
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case adMarkers = "adMarkers"
            case includeIframeOnlyStream = "includeIframeOnlyStream"
            case manifestName = "manifestName"
            case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
            case repeatExtXKey = "repeatExtXKey"
            case streamSelection = "streamSelection"
        }
    }

    public struct HlsPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: HlsEncryption?
        /// A list of HLS manifest configurations.
        public let hlsManifests: [HlsManifest]?
        /// When enabled, MediaPackage passes through digital video broadcasting (DVB) subtitles into the output.
        public let includeDvbSubtitles: Bool?
        /// Duration (in seconds) of each fragment. Actual fragments will be
        /// rounded to the nearest multiple of the source fragment duration.
        public let segmentDurationSeconds: Int?
        /// When enabled, audio streams will be placed in rendition groups in the output.
        public let useAudioRenditionGroup: Bool?

        @inlinable
        public init(encryption: HlsEncryption? = nil, hlsManifests: [HlsManifest]? = nil, includeDvbSubtitles: Bool? = nil, segmentDurationSeconds: Int? = nil, useAudioRenditionGroup: Bool? = nil) {
            self.encryption = encryption
            self.hlsManifests = hlsManifests
            self.includeDvbSubtitles = includeDvbSubtitles
            self.segmentDurationSeconds = segmentDurationSeconds
            self.useAudioRenditionGroup = useAudioRenditionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case hlsManifests = "hlsManifests"
            case includeDvbSubtitles = "includeDvbSubtitles"
            case segmentDurationSeconds = "segmentDurationSeconds"
            case useAudioRenditionGroup = "useAudioRenditionGroup"
        }
    }

    public struct ListAssetsRequest: AWSEncodableShape {
        /// Upper bound on number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?
        /// Returns Assets associated with the specified PackagingGroup.
        public let packagingGroupId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, packagingGroupId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packagingGroupId = packagingGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.packagingGroupId, key: "packagingGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsResponse: AWSDecodableShape {
        /// A list of MediaPackage VOD Asset resources.
        public let assets: [AssetShallow]?
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?

        @inlinable
        public init(assets: [AssetShallow]? = nil, nextToken: String? = nil) {
            self.assets = assets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "assets"
            case nextToken = "nextToken"
        }
    }

    public struct ListPackagingConfigurationsRequest: AWSEncodableShape {
        /// Upper bound on number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?
        /// Returns MediaPackage VOD PackagingConfigurations associated with the specified PackagingGroup.
        public let packagingGroupId: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, packagingGroupId: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.packagingGroupId = packagingGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.packagingGroupId, key: "packagingGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagingConfigurationsResponse: AWSDecodableShape {
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?
        /// A list of MediaPackage VOD PackagingConfiguration resources.
        public let packagingConfigurations: [PackagingConfiguration]?

        @inlinable
        public init(nextToken: String? = nil, packagingConfigurations: [PackagingConfiguration]? = nil) {
            self.nextToken = nextToken
            self.packagingConfigurations = packagingConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packagingConfigurations = "packagingConfigurations"
        }
    }

    public struct ListPackagingGroupsRequest: AWSEncodableShape {
        /// Upper bound on number of records to return.
        public let maxResults: Int?
        /// A token used to resume pagination from the end of a previous request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPackagingGroupsResponse: AWSDecodableShape {
        /// A token that can be used to resume pagination from the end of the collection.
        public let nextToken: String?
        /// A list of MediaPackage VOD PackagingGroup resources.
        public let packagingGroups: [PackagingGroup]?

        @inlinable
        public init(nextToken: String? = nil, packagingGroups: [PackagingGroup]? = nil) {
            self.nextToken = nextToken
            self.packagingGroups = packagingGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case packagingGroups = "packagingGroups"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A collection of tags associated with a resource
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MssEncryption: AWSEncodableShape & AWSDecodableShape {
        public let spekeKeyProvider: SpekeKeyProvider?

        @inlinable
        public init(spekeKeyProvider: SpekeKeyProvider? = nil) {
            self.spekeKeyProvider = spekeKeyProvider
        }

        private enum CodingKeys: String, CodingKey {
            case spekeKeyProvider = "spekeKeyProvider"
        }
    }

    public struct MssManifest: AWSEncodableShape & AWSDecodableShape {
        /// An optional string to include in the name of the manifest.
        public let manifestName: String?
        public let streamSelection: StreamSelection?

        @inlinable
        public init(manifestName: String? = nil, streamSelection: StreamSelection? = nil) {
            self.manifestName = manifestName
            self.streamSelection = streamSelection
        }

        private enum CodingKeys: String, CodingKey {
            case manifestName = "manifestName"
            case streamSelection = "streamSelection"
        }
    }

    public struct MssPackage: AWSEncodableShape & AWSDecodableShape {
        public let encryption: MssEncryption?
        /// A list of MSS manifest configurations.
        public let mssManifests: [MssManifest]?
        /// The duration (in seconds) of each segment.
        public let segmentDurationSeconds: Int?

        @inlinable
        public init(encryption: MssEncryption? = nil, mssManifests: [MssManifest]? = nil, segmentDurationSeconds: Int? = nil) {
            self.encryption = encryption
            self.mssManifests = mssManifests
            self.segmentDurationSeconds = segmentDurationSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case encryption = "encryption"
            case mssManifests = "mssManifests"
            case segmentDurationSeconds = "segmentDurationSeconds"
        }
    }

    public struct PackagingConfiguration: AWSDecodableShape {
        /// The ARN of the PackagingConfiguration.
        public let arn: String?
        public let cmafPackage: CmafPackage?
        /// The time the PackagingConfiguration was created.
        public let createdAt: String?
        public let dashPackage: DashPackage?
        public let hlsPackage: HlsPackage?
        /// The ID of the PackagingConfiguration.
        public let id: String?
        public let mssPackage: MssPackage?
        /// The ID of a PackagingGroup.
        public let packagingGroupId: String?
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, cmafPackage: CmafPackage? = nil, createdAt: String? = nil, dashPackage: DashPackage? = nil, hlsPackage: HlsPackage? = nil, id: String? = nil, mssPackage: MssPackage? = nil, packagingGroupId: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.cmafPackage = cmafPackage
            self.createdAt = createdAt
            self.dashPackage = dashPackage
            self.hlsPackage = hlsPackage
            self.id = id
            self.mssPackage = mssPackage
            self.packagingGroupId = packagingGroupId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case cmafPackage = "cmafPackage"
            case createdAt = "createdAt"
            case dashPackage = "dashPackage"
            case hlsPackage = "hlsPackage"
            case id = "id"
            case mssPackage = "mssPackage"
            case packagingGroupId = "packagingGroupId"
            case tags = "tags"
        }
    }

    public struct PackagingGroup: AWSDecodableShape {
        /// The approximate asset count of the PackagingGroup.
        public let approximateAssetCount: Int?
        /// The ARN of the PackagingGroup.
        public let arn: String?
        public let authorization: Authorization?
        /// The time the PackagingGroup was created.
        public let createdAt: String?
        /// The fully qualified domain name for Assets in the PackagingGroup.
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public let id: String?
        public let tags: [String: String]?

        @inlinable
        public init(approximateAssetCount: Int? = nil, arn: String? = nil, authorization: Authorization? = nil, createdAt: String? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.approximateAssetCount = approximateAssetCount
            self.arn = arn
            self.authorization = authorization
            self.createdAt = createdAt
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case approximateAssetCount = "approximateAssetCount"
            case arn = "arn"
            case authorization = "authorization"
            case createdAt = "createdAt"
            case domainName = "domainName"
            case egressAccessLogs = "egressAccessLogs"
            case id = "id"
            case tags = "tags"
        }
    }

    public struct SpekeKeyProvider: AWSEncodableShape & AWSDecodableShape {
        public let encryptionContractConfiguration: EncryptionContractConfiguration?
        /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
        /// MediaPackage will assume when accessing the key provider service.
        public let roleArn: String?
        /// The system IDs to include in key requests.
        public let systemIds: [String]?
        /// The URL of the external key provider service.
        public let url: String?

        @inlinable
        public init(encryptionContractConfiguration: EncryptionContractConfiguration? = nil, roleArn: String? = nil, systemIds: [String]? = nil, url: String? = nil) {
            self.encryptionContractConfiguration = encryptionContractConfiguration
            self.roleArn = roleArn
            self.systemIds = systemIds
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionContractConfiguration = "encryptionContractConfiguration"
            case roleArn = "roleArn"
            case systemIds = "systemIds"
            case url = "url"
        }
    }

    public struct StreamSelection: AWSEncodableShape & AWSDecodableShape {
        /// The maximum video bitrate (bps) to include in output.
        public let maxVideoBitsPerSecond: Int?
        /// The minimum video bitrate (bps) to include in output.
        public let minVideoBitsPerSecond: Int?
        /// A directive that determines the order of streams in the output.
        public let streamOrder: StreamOrder?

        @inlinable
        public init(maxVideoBitsPerSecond: Int? = nil, minVideoBitsPerSecond: Int? = nil, streamOrder: StreamOrder? = nil) {
            self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
            self.minVideoBitsPerSecond = minVideoBitsPerSecond
            self.streamOrder = streamOrder
        }

        private enum CodingKeys: String, CodingKey {
            case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
            case minVideoBitsPerSecond = "minVideoBitsPerSecond"
            case streamOrder = "streamOrder"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
        public let resourceArn: String
        /// A collection of tags associated with a resource
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
        public let resourceArn: String
        /// A comma-separated list of the tag keys to remove from the resource.
        public let tagKeys: [String]?

        @inlinable
        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdatePackagingGroupRequest: AWSEncodableShape {
        public let authorization: Authorization?
        /// The ID of a MediaPackage VOD PackagingGroup resource.
        public let id: String

        @inlinable
        public init(authorization: Authorization? = nil, id: String) {
            self.authorization = authorization
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authorization, forKey: .authorization)
            request.encodePath(self.id, key: "Id")
        }

        private enum CodingKeys: String, CodingKey {
            case authorization = "authorization"
        }
    }

    public struct UpdatePackagingGroupResponse: AWSDecodableShape {
        /// The approximate asset count of the PackagingGroup.
        public let approximateAssetCount: Int?
        /// The ARN of the PackagingGroup.
        public let arn: String?
        public let authorization: Authorization?
        /// The time the PackagingGroup was created.
        public let createdAt: String?
        /// The fully qualified domain name for Assets in the PackagingGroup.
        public let domainName: String?
        public let egressAccessLogs: EgressAccessLogs?
        /// The ID of the PackagingGroup.
        public let id: String?
        public let tags: [String: String]?

        @inlinable
        public init(approximateAssetCount: Int? = nil, arn: String? = nil, authorization: Authorization? = nil, createdAt: String? = nil, domainName: String? = nil, egressAccessLogs: EgressAccessLogs? = nil, id: String? = nil, tags: [String: String]? = nil) {
            self.approximateAssetCount = approximateAssetCount
            self.arn = arn
            self.authorization = authorization
            self.createdAt = createdAt
            self.domainName = domainName
            self.egressAccessLogs = egressAccessLogs
            self.id = id
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case approximateAssetCount = "approximateAssetCount"
            case arn = "arn"
            case authorization = "authorization"
            case createdAt = "createdAt"
            case domainName = "domainName"
            case egressAccessLogs = "egressAccessLogs"
            case id = "id"
            case tags = "tags"
        }
    }
}

// MARK: - Errors

/// Error enum for MediaPackageVod
public struct MediaPackageVodErrorType: AWSErrorType {
    enum Code: String {
        case forbiddenException = "ForbiddenException"
        case internalServerErrorException = "InternalServerErrorException"
        case notFoundException = "NotFoundException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case tooManyRequestsException = "TooManyRequestsException"
        case unprocessableEntityException = "UnprocessableEntityException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize MediaPackageVod
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The client is not authorized to access the requested resource.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// An unexpected error occurred.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// The requested resource does not exist.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// An unexpected error occurred.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The client has exceeded their resource or throttling limits.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// The parameters sent in the request are not valid.
    public static var unprocessableEntityException: Self { .init(.unprocessableEntityException) }
}

extension MediaPackageVodErrorType: Equatable {
    public static func == (lhs: MediaPackageVodErrorType, rhs: MediaPackageVodErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension MediaPackageVodErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
