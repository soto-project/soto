//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTManagedIntegrations {
    // MARK: Enums

    public enum AbortCriteriaAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancel = "CANCEL"
        public var description: String { return self.rawValue }
    }

    public enum AbortCriteriaFailureType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case failed = "FAILED"
        case rejected = "REJECTED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum AssociationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case associationDeleting = "ASSOCIATION_DELETING"
        case associationFailed = "ASSOCIATION_FAILED"
        case associationInProgress = "ASSOCIATION_IN_PROGRESS"
        case associationSucceeded = "ASSOCIATION_SUCCEEDED"
        case refreshTokenExpired = "REFRESH_TOKEN_EXPIRED"
        public var description: String { return self.rawValue }
    }

    public enum AuthMaterialType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customProtocolQrBarCode = "CUSTOM_PROTOCOL_QR_BAR_CODE"
        case discoveredDevice = "DISCOVERED_DEVICE"
        case wifiSetupQrBarCode = "WIFI_SETUP_QR_BAR_CODE"
        case zigbeeQrBarCode = "ZIGBEE_QR_BAR_CODE"
        case zwaveQrBarCode = "ZWAVE_QR_BAR_CODE"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oauth = "OAUTH"
        public var description: String { return self.rawValue }
    }

    public enum CloudConnectorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case listed = "LISTED"
        case unlisted = "UNLISTED"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enabled = "ENABLED"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ConnectorEventOperation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deviceCommandRequest = "DEVICE_COMMAND_REQUEST"
        case deviceCommandResponse = "DEVICE_COMMAND_RESPONSE"
        case deviceDiscovery = "DEVICE_DISCOVERY"
        case deviceEvent = "DEVICE_EVENT"
        public var description: String { return self.rawValue }
    }

    public enum DeliveryDestinationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kinesis = "KINESIS"
        public var description: String { return self.rawValue }
    }

    public enum DeviceDiscoveryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum DisconnectReasonValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authError = "AUTH_ERROR"
        case clientError = "CLIENT_ERROR"
        case clientInitiatedDisconnect = "CLIENT_INITIATED_DISCONNECT"
        case connectionLost = "CONNECTION_LOST"
        case customauthTtlExpiration = "CUSTOMAUTH_TTL_EXPIRATION"
        case duplicateClientid = "DUPLICATE_CLIENTID"
        case forbiddenAccess = "FORBIDDEN_ACCESS"
        case mqttKeepAliveTimeout = "MQTT_KEEP_ALIVE_TIMEOUT"
        case none = "NONE"
        case serverError = "SERVER_ERROR"
        case serverInitiatedDisconnect = "SERVER_INITIATED_DISCONNECT"
        case throttled = "THROTTLED"
        case unknown = "UNKNOWN"
        case websocketTtlExpiration = "WEBSOCKET_TTL_EXPIRATION"
        public var description: String { return self.rawValue }
    }

    public enum DiscoveryAuthMaterialType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case zwaveInstallCode = "ZWAVE_INSTALL_CODE"
        public var description: String { return self.rawValue }
    }

    public enum DiscoveryModification: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case discovered = "DISCOVERED"
        case noChange = "NO_CHANGE"
        case updated = "UPDATED"
        public var description: String { return self.rawValue }
    }

    public enum DiscoveryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloud = "CLOUD"
        case custom = "CUSTOM"
        case zigbee = "ZIGBEE"
        case zwave = "ZWAVE"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerKeyEncryption = "CUSTOMER_KEY_ENCRYPTION"
        case managedIntegrationsDefaultEncryption = "MANAGED_INTEGRATIONS_DEFAULT_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum EndpointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountAssociation = "ACCOUNT_ASSOCIATION"
        case connectorAssociation = "CONNECTOR_ASSOCIATION"
        case connectorErrorReport = "CONNECTOR_ERROR_REPORT"
        case deviceCommand = "DEVICE_COMMAND"
        case deviceCommandRequest = "DEVICE_COMMAND_REQUEST"
        case deviceDiscoveryStatus = "DEVICE_DISCOVERY_STATUS"
        case deviceEvent = "DEVICE_EVENT"
        case deviceLifeCycle = "DEVICE_LIFE_CYCLE"
        case deviceOta = "DEVICE_OTA"
        case deviceState = "DEVICE_STATE"
        public var description: String { return self.rawValue }
    }

    public enum HubNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case networkWideExclusion = "NETWORK_WIDE_EXCLUSION"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case error = "ERROR"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum OtaMechanism: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case push = "PUSH"
        public var description: String { return self.rawValue }
    }

    public enum OtaProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case http = "HTTP"
        public var description: String { return self.rawValue }
    }

    public enum OtaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case completed = "COMPLETED"
        case deletionInProgress = "DELETION_IN_PROGRESS"
        case inProgress = "IN_PROGRESS"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum OtaTaskExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case rejected = "REJECTED"
        case removed = "REMOVED"
        case succeeded = "SUCCEEDED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum OtaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuous = "CONTINUOUS"
        case oneTime = "ONE_TIME"
        public var description: String { return self.rawValue }
    }

    public enum ProvisioningStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case deletionFailed = "DELETION_FAILED"
        case discovered = "DISCOVERED"
        case isolated = "ISOLATED"
        case preAssociated = "PRE_ASSOCIATED"
        case unassociated = "UNASSOCIATED"
        public var description: String { return self.rawValue }
    }

    public enum ProvisioningType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fleetProvisioning = "FLEET_PROVISIONING"
        case jitr = "JITR"
        public var description: String { return self.rawValue }
    }

    public enum RetryCriteriaFailureType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case failed = "FAILED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum Role: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case controller = "CONTROLLER"
        case device = "DEVICE"
        public var description: String { return self.rawValue }
    }

    public enum SchedulingConfigEndBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancel = "CANCEL"
        case forceCancel = "FORCE_CANCEL"
        case stopRollout = "STOP_ROLLOUT"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case connector = "CONNECTOR"
        case zcl = "ZCL"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case capability = "capability"
        case definition = "definition"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionVisibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum TokenEndpointAuthenticationScheme: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case httpBasic = "HTTP_BASIC"
        case requestBodyCredentials = "REQUEST_BODY_CREDENTIALS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AbortConfigCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The action taken by the abort configuration.
        public let action: AbortCriteriaAction?
        /// Over-the-air (OTA) task abort criteria failure type.
        public let failureType: AbortCriteriaFailureType?
        /// The minimum number of things that must receive task execution notifications before the task can be aborted.
        public let minNumberOfExecutedThings: Int?
        /// The minimum percentage of over-the-air (OTA) task execution failures that must occur to initiate the last abort.
        public let thresholdPercentage: Double?

        @inlinable
        public init(action: AbortCriteriaAction? = nil, failureType: AbortCriteriaFailureType? = nil, minNumberOfExecutedThings: Int? = nil, thresholdPercentage: Double? = nil) {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.minNumberOfExecutedThings, name: "minNumberOfExecutedThings", parent: name, max: 100)
            try self.validate(self.minNumberOfExecutedThings, name: "minNumberOfExecutedThings", parent: name, min: 1)
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, max: 100.0)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case failureType = "FailureType"
            case minNumberOfExecutedThings = "MinNumberOfExecutedThings"
            case thresholdPercentage = "ThresholdPercentage"
        }
    }

    public struct AccountAssociationItem: AWSDecodableShape {
        /// The unique identifier of the account association.
        public let accountAssociationId: String
        /// The Amazon Resource Name (ARN) of the account association.
        public let arn: String?
        /// The current state of the account association, indicating its status in the association lifecycle.
        public let associationState: AssociationState
        /// The identifier of the connector destination associated with this account association.
        public let connectorDestinationId: String?
        /// A description of the account association.
        public let description: String?
        /// The error message explaining any issues with the account association, if applicable.
        public let errorMessage: String?
        /// The name of the account association.
        public let name: String?

        @inlinable
        public init(accountAssociationId: String, arn: String? = nil, associationState: AssociationState, connectorDestinationId: String? = nil, description: String? = nil, errorMessage: String? = nil, name: String? = nil) {
            self.accountAssociationId = accountAssociationId
            self.arn = arn
            self.associationState = associationState
            self.connectorDestinationId = connectorDestinationId
            self.description = description
            self.errorMessage = errorMessage
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case arn = "Arn"
            case associationState = "AssociationState"
            case connectorDestinationId = "ConnectorDestinationId"
            case description = "Description"
            case errorMessage = "ErrorMessage"
            case name = "Name"
        }
    }

    public struct AuthConfig: AWSEncodableShape & AWSDecodableShape {
        /// The OAuth configuration settings used for authentication with the third-party service.
        public let oAuth: OAuthConfig?

        @inlinable
        public init(oAuth: OAuthConfig? = nil) {
            self.oAuth = oAuth
        }

        public func validate(name: String) throws {
            try self.oAuth?.validate(name: "\(name).oAuth")
        }

        private enum CodingKeys: String, CodingKey {
            case oAuth = "oAuth"
        }
    }

    public struct AuthConfigUpdate: AWSEncodableShape {
        /// The updated OAuth configuration settings for the authentication configuration.
        public let oAuthUpdate: OAuthUpdate?

        @inlinable
        public init(oAuthUpdate: OAuthUpdate? = nil) {
            self.oAuthUpdate = oAuthUpdate
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthUpdate = "oAuthUpdate"
        }
    }

    public struct CapabilityAction: AWSEncodableShape {
        /// Describe a capability action with an actionTraceId for a response command.
        public let actionTraceId: String?
        /// Describe a capability action with a name.
        public let name: String
        /// Describe a capability action with a capability property.
        public let parameters: AWSDocument?
        /// Describe a capability action with an reference.
        public let ref: String?

        @inlinable
        public init(actionTraceId: String? = nil, name: String, parameters: AWSDocument? = nil, ref: String? = nil) {
            self.actionTraceId = actionTraceId
            self.name = name
            self.parameters = parameters
            self.ref = ref
        }

        public func validate(name: String) throws {
            try self.validate(self.actionTraceId, name: "actionTraceId", parent: name, max: 20)
            try self.validate(self.actionTraceId, name: "actionTraceId", parent: name, min: 16)
            try self.validate(self.actionTraceId, name: "actionTraceId", parent: name, pattern: "^[a-zA-Z0-9]+=(?:_[0-9]+)?$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z]+$")
            try self.validate(self.ref, name: "ref", parent: name, pattern: "^[a-zA-Z.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionTraceId = "actionTraceId"
            case name = "name"
            case parameters = "parameters"
            case ref = "ref"
        }
    }

    public struct CapabilityReport: AWSEncodableShape & AWSDecodableShape {
        /// The endpoints used in the capability report.
        public let endpoints: [CapabilityReportEndpoint]
        /// The numeric identifier of the node.
        public let nodeId: String?
        /// The version of the capability report.
        public let version: String

        @inlinable
        public init(endpoints: [CapabilityReportEndpoint], nodeId: String? = nil, version: String) {
            self.endpoints = endpoints
            self.nodeId = nodeId
            self.version = version
        }

        public func validate(name: String) throws {
            try self.endpoints.forEach {
                try $0.validate(name: "\(name).endpoints[]")
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 40)
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 64)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
            try self.validate(self.nodeId, name: "nodeId", parent: name, pattern: "^[a-zA-Z0-9=_.,@\\+\\-/]+$")
            try self.validate(self.version, name: "version", parent: name, max: 10)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^1\\.0\\.0$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "endpoints"
            case nodeId = "nodeId"
            case version = "version"
        }
    }

    public struct CapabilityReportCapability: AWSEncodableShape & AWSDecodableShape {
        /// The capability actions used in the capability report.
        public let actions: [String]
        /// The capability events used in the capability report.
        public let events: [String]
        /// The id of the schema version.
        public let id: String
        /// The name of the capability.
        public let name: String
        /// The capability properties used in the capability report.
        public let properties: [String]
        /// The version of the capability.
        public let version: String

        @inlinable
        public init(actions: [String], events: [String], id: String, name: String, properties: [String], version: String) {
            self.actions = actions
            self.events = events
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try validate($0, name: "actions[]", parent: name, max: 128)
                try validate($0, name: "actions[]", parent: name, min: 1)
                try validate($0, name: "actions[]", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 100)
            try self.events.forEach {
                try validate($0, name: "events[]", parent: name, max: 128)
                try validate($0, name: "events[]", parent: name, min: 1)
                try validate($0, name: "events[]", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            }
            try self.validate(self.events, name: "events", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 7)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9.]+@(\\d+\\.\\d+(\\.\\d+)?|\\$latest)$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            try self.properties.forEach {
                try validate($0, name: "properties[]", parent: name, max: 128)
                try validate($0, name: "properties[]", parent: name, min: 1)
                try validate($0, name: "properties[]", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 100)
            try self.validate(self.version, name: "version", parent: name, max: 64)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^(0|[1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case events = "events"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case version = "version"
        }
    }

    public struct CapabilityReportEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// The capabilities used in the capability report.
        public let capabilities: [CapabilityReportCapability]
        /// The type of device.
        public let deviceTypes: [String]
        /// The id of the endpoint used in the capability report.
        public let id: String

        @inlinable
        public init(capabilities: [CapabilityReportCapability], deviceTypes: [String], id: String) {
            self.capabilities = capabilities
            self.deviceTypes = deviceTypes
            self.id = id
        }

        public func validate(name: String) throws {
            try self.capabilities.forEach {
                try $0.validate(name: "\(name).capabilities[]")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 40)
            try self.deviceTypes.forEach {
                try validate($0, name: "deviceTypes[]", parent: name, max: 256)
                try validate($0, name: "deviceTypes[]", parent: name, pattern: "^[a-zA-Z0-9=_. ,@\\+\\-/]+$")
            }
            try self.validate(self.deviceTypes, name: "deviceTypes", parent: name, max: 50)
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case deviceTypes = "deviceTypes"
            case id = "id"
        }
    }

    public struct CapabilitySchemaItem: AWSEncodableShape {
        /// The unique identifier of the capability defined in the schema.
        public let capabilityId: String
        /// The external identifier for the capability, used when referencing the capability outside of the AWS ecosystem.
        public let extrinsicId: String
        /// The version of the external capability definition, used to track compatibility with external systems.
        public let extrinsicVersion: Int
        /// The format of the capability schema, which defines how the schema is structured and interpreted.
        public let format: SchemaVersionFormat
        /// The actual schema definition that describes the capability's properties, actions, and events.
        public let schema: AWSDocument

        @inlinable
        public init(capabilityId: String, extrinsicId: String, extrinsicVersion: Int, format: SchemaVersionFormat, schema: AWSDocument) {
            self.capabilityId = capabilityId
            self.extrinsicId = extrinsicId
            self.extrinsicVersion = extrinsicVersion
            self.format = format
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, max: 128)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, min: 7)
            try self.validate(self.capabilityId, name: "capabilityId", parent: name, pattern: "^[a-zA-Z0-9.]+@(\\d+\\.\\d+(\\.\\d+)?|\\$latest)$")
            try self.validate(self.extrinsicId, name: "extrinsicId", parent: name, max: 10)
            try self.validate(self.extrinsicId, name: "extrinsicId", parent: name, min: 1)
            try self.validate(self.extrinsicId, name: "extrinsicId", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            try self.validate(self.extrinsicVersion, name: "extrinsicVersion", parent: name, max: 10)
            try self.validate(self.extrinsicVersion, name: "extrinsicVersion", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityId = "CapabilityId"
            case extrinsicId = "ExtrinsicId"
            case extrinsicVersion = "ExtrinsicVersion"
            case format = "Format"
            case schema = "Schema"
        }
    }

    public struct CommandCapability: AWSEncodableShape {
        /// Describe the command capability with the actions it supports.
        public let actions: [CapabilityAction]
        /// Describe the capability with an id.
        public let id: String
        /// Describe the capability with an name.
        public let name: String
        /// Describe the capability with a version.
        public let version: String

        @inlinable
        public init(actions: [CapabilityAction], id: String, name: String, version: String) {
            self.actions = actions
            self.id = id
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 5)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 7)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9.]+@(\\d+\\.\\d+(\\.\\d+)?|\\$latest)$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            try self.validate(self.version, name: "version", parent: name, max: 64)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^(0|[1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case id = "id"
            case name = "name"
            case version = "version"
        }
    }

    public struct CommandEndpoint: AWSEncodableShape {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for sending commands.
        public let capabilities: [CommandCapability]
        /// The id of the endpoint for a managed thing.
        public let endpointId: String

        @inlinable
        public init(capabilities: [CommandCapability], endpointId: String) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }

        public func validate(name: String) throws {
            try self.capabilities.forEach {
                try $0.validate(name: "\(name).capabilities[]")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 5)
            try self.validate(self.capabilities, name: "capabilities", parent: name, min: 1)
            try self.validate(self.endpointId, name: "endpointId", parent: name, max: 64)
            try self.validate(self.endpointId, name: "endpointId", parent: name, min: 1)
            try self.validate(self.endpointId, name: "endpointId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case endpointId = "endpointId"
        }
    }

    public struct ConfigurationError: AWSDecodableShape {
        /// The error code returned when the default encryption configuration update fails.
        public let code: String?
        /// The error message returned when the default encryption configuration update fails.
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ConfigurationStatus: AWSDecodableShape {
        /// The error details describing a failed default encryption configuration update.
        public let error: ConfigurationError?
        /// The status state describing the default encryption configuration update.
        public let state: ConfigurationState

        @inlinable
        public init(error: ConfigurationError? = nil, state: ConfigurationState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct ConnectorDestinationSummary: AWSDecodableShape {
        /// The identifier of the cloud connector associated with this connector destination.
        public let cloudConnectorId: String?
        /// A description of the connector destination.
        public let description: String?
        /// The unique identifier of the connector destination.
        public let id: String?
        /// The display name of the connector destination.
        public let name: String?

        @inlinable
        public init(cloudConnectorId: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil) {
            self.cloudConnectorId = cloudConnectorId
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case cloudConnectorId = "CloudConnectorId"
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ConnectorItem: AWSDecodableShape {
        /// A description of the C2C connector.
        public let description: String?
        /// The configuration details for the cloud connector endpoint, including connection parameters and authentication requirements.
        public let endpointConfig: EndpointConfig
        /// The type of endpoint used for the C2C connector.
        public let endpointType: EndpointType?
        /// The identifier of the C2C connector.
        public let id: String?
        /// The display name of the C2C connector.
        public let name: String
        /// The type of cloud connector created.
        public let type: CloudConnectorType?

        @inlinable
        public init(description: String? = nil, endpointConfig: EndpointConfig, endpointType: EndpointType? = nil, id: String? = nil, name: String, type: CloudConnectorType? = nil) {
            self.description = description
            self.endpointConfig = endpointConfig
            self.endpointType = endpointType
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case endpointConfig = "EndpointConfig"
            case endpointType = "EndpointType"
            case id = "Id"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct CreateAccountAssociationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The identifier of the connector destination.
        public let connectorDestinationId: String
        /// A description of the account association request.
        public let description: String?
        /// The name of the destination for the new account association.
        public let name: String?
        /// A set of key/value pairs that are used to manage the account association.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateAccountAssociationRequest.idempotencyToken(), connectorDestinationId: String, description: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.connectorDestinationId = connectorDestinationId
            self.description = description
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.connectorDestinationId, name: "connectorDestinationId", parent: name, max: 64)
            try self.validate(self.connectorDestinationId, name: "connectorDestinationId", parent: name, min: 1)
            try self.validate(self.connectorDestinationId, name: "connectorDestinationId", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case connectorDestinationId = "ConnectorDestinationId"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateAccountAssociationResponse: AWSDecodableShape {
        /// The identifier for the account association request.
        public let accountAssociationId: String
        /// The Amazon Resource Name (ARN) of the account association.
        public let arn: String?
        /// The current state of the account association request.
        public let associationState: AssociationState
        /// Third-party IoT platform OAuth authorization server URL backed with all the required parameters to perform end-user authentication.
        public let oAuthAuthorizationUrl: String

        @inlinable
        public init(accountAssociationId: String, arn: String? = nil, associationState: AssociationState, oAuthAuthorizationUrl: String) {
            self.accountAssociationId = accountAssociationId
            self.arn = arn
            self.associationState = associationState
            self.oAuthAuthorizationUrl = oAuthAuthorizationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case arn = "Arn"
            case associationState = "AssociationState"
            case oAuthAuthorizationUrl = "OAuthAuthorizationUrl"
        }
    }

    public struct CreateCloudConnectorRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// A description of the C2C connector.
        public let description: String?
        /// The configuration details for the cloud connector endpoint, including connection parameters and authentication requirements.
        public let endpointConfig: EndpointConfig
        /// The type of endpoint used for the cloud connector, which defines how the connector communicates with external services.
        public let endpointType: EndpointType?
        /// The display name of the C2C connector.
        public let name: String

        @inlinable
        public init(clientToken: String? = CreateCloudConnectorRequest.idempotencyToken(), description: String? = nil, endpointConfig: EndpointConfig, endpointType: EndpointType? = nil, name: String) {
            self.clientToken = clientToken
            self.description = description
            self.endpointConfig = endpointConfig
            self.endpointType = endpointType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.endpointConfig.validate(name: "\(name).endpointConfig")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case endpointConfig = "EndpointConfig"
            case endpointType = "EndpointType"
            case name = "Name"
        }
    }

    public struct CreateCloudConnectorResponse: AWSDecodableShape {
        /// The unique identifier assigned to the newly created cloud connector.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct CreateConnectorDestinationRequest: AWSEncodableShape {
        /// The authentication configuration details for the connector destination, including OAuth settings and other authentication parameters.
        public let authConfig: AuthConfig
        /// The authentication type used for the connector destination, which determines how credentials and access are managed.
        public let authType: AuthType
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The identifier of the C2C connector.
        public let cloudConnectorId: String
        /// A description of the connector destination.
        public let description: String?
        /// The display name of the connector destination.
        public let name: String?
        /// The AWS Secrets Manager configuration used to securely store and manage sensitive information for the connector destination.
        public let secretsManager: SecretsManager

        @inlinable
        public init(authConfig: AuthConfig, authType: AuthType, clientToken: String? = CreateConnectorDestinationRequest.idempotencyToken(), cloudConnectorId: String, description: String? = nil, name: String? = nil, secretsManager: SecretsManager) {
            self.authConfig = authConfig
            self.authType = authType
            self.clientToken = clientToken
            self.cloudConnectorId = cloudConnectorId
            self.description = description
            self.name = name
            self.secretsManager = secretsManager
        }

        public func validate(name: String) throws {
            try self.authConfig.validate(name: "\(name).authConfig")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.cloudConnectorId, name: "cloudConnectorId", parent: name, max: 64)
            try self.validate(self.cloudConnectorId, name: "cloudConnectorId", parent: name, min: 1)
            try self.validate(self.cloudConnectorId, name: "cloudConnectorId", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.secretsManager.validate(name: "\(name).secretsManager")
        }

        private enum CodingKeys: String, CodingKey {
            case authConfig = "AuthConfig"
            case authType = "AuthType"
            case clientToken = "ClientToken"
            case cloudConnectorId = "CloudConnectorId"
            case description = "Description"
            case name = "Name"
            case secretsManager = "SecretsManager"
        }
    }

    public struct CreateConnectorDestinationResponse: AWSDecodableShape {
        /// The identifier of the C2C connector destination creation request.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct CreateCredentialLockerRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The name of the credential locker.
        public let name: String?
        /// A set of key/value pairs that are used to manage the credential locker.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateCredentialLockerRequest.idempotencyToken(), name: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateCredentialLockerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public let arn: String?
        /// The timestamp value of when the credential locker request occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker creation request.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
        }
    }

    public struct CreateDestinationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String
        /// The Amazon Resource Name (ARN) of the delivery destination role.
        public let roleArn: String
        /// A set of key/value pairs that are used to manage the destination.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateDestinationRequest.idempotencyToken(), deliveryDestinationArn: String, deliveryDestinationType: DeliveryDestinationType, description: String? = nil, name: String, roleArn: String) {
            self.clientToken = clientToken
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.tags = nil
        }

        @available(*, deprecated, message: "Members tags have been deprecated")
        @inlinable
        public init(clientToken: String? = CreateDestinationRequest.idempotencyToken(), deliveryDestinationArn: String, deliveryDestinationType: DeliveryDestinationType, description: String? = nil, name: String, roleArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, max: 2048)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, min: 20)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, pattern: "^arn:aws:[0-9a-zA-Z]+:[0-9a-zA-Z-]+:[0-9]+:[0-9a-zA-Z]+/[0-9a-zA-Z._-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case name = "Name"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateDestinationResponse: AWSDecodableShape {
        /// The name of the customer-managed destination.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateEventLogConfigurationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The logging level for the event log configuration.
        public let eventLogLevel: LogLevel
        /// The identifier of the resource for the event log configuration.
        public let resourceId: String?
        /// The type of resource for the event log configuration.
        public let resourceType: String

        @inlinable
        public init(clientToken: String? = CreateEventLogConfigurationRequest.idempotencyToken(), eventLogLevel: LogLevel, resourceId: String? = nil, resourceType: String) {
            self.clientToken = clientToken
            self.eventLogLevel = eventLogLevel
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 200)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9+*]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[*]$|^(managed-thing|credential-locker|provisioning-profile|ota-task|account-association)$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case eventLogLevel = "EventLogLevel"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateEventLogConfigurationResponse: AWSDecodableShape {
        /// The identifier of the event log configuration request.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct CreateManagedThingRequest: AWSEncodableShape {
        /// The authentication material defining the device connectivity setup requests. The authentication materials used are the device bar code.
        public let authenticationMaterial: String
        /// The type of authentication material used for device connectivity setup requests.
        public let authenticationMaterialType: AuthMaterialType
        /// The brand of the device.
        public let brand: String?
        /// The capabilities of the device such as light bulb.
        public let capabilities: String?
        /// A report of the capabilities for the managed thing.
        public let capabilityReport: CapabilityReport?
        /// The capability schemas that define the functionality and features supported by the managed thing, including device capabilities and their associated properties.
        public let capabilitySchemas: [CapabilitySchemaItem]?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The identifier of the credential for the managed thing.
        public let credentialLockerId: String?
        /// The metadata for the managed thing.  The managedThing metadata parameter is used for associating attributes with a managedThing that can be used for grouping over-the-air (OTA) tasks. Name value pairs in metadata can be used in the OtaTargetQueryString parameter for the CreateOtaTask API operation.
        public let metaData: [String: String]?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// The type of device used. This will be the hub controller, cloud device, or AWS IoT device.
        public let role: Role
        /// The serial number of the device.
        public let serialNumber: String?
        /// A set of key/value pairs that are used to manage the managed thing.
        public let tags: [String: String]?

        @inlinable
        public init(authenticationMaterial: String, authenticationMaterialType: AuthMaterialType, brand: String? = nil, capabilities: String? = nil, capabilityReport: CapabilityReport? = nil, capabilitySchemas: [CapabilitySchemaItem]? = nil, classification: String? = nil, clientToken: String? = CreateManagedThingRequest.idempotencyToken(), credentialLockerId: String? = nil, metaData: [String: String]? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, role: Role, serialNumber: String? = nil, tags: [String: String]? = nil) {
            self.authenticationMaterial = authenticationMaterial
            self.authenticationMaterialType = authenticationMaterialType
            self.brand = brand
            self.capabilities = capabilities
            self.capabilityReport = capabilityReport
            self.capabilitySchemas = capabilitySchemas
            self.classification = classification
            self.clientToken = clientToken
            self.credentialLockerId = credentialLockerId
            self.metaData = metaData
            self.model = model
            self.name = name
            self.owner = owner
            self.role = role
            self.serialNumber = serialNumber
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, max: 512)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, min: 1)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, pattern: "^[0-9A-Za-z!#$%&()*\\+\\-;<=>?@^_`{|}~\\/: {},\\\\\"]+$")
            try self.validate(self.brand, name: "brand", parent: name, max: 128)
            try self.validate(self.brand, name: "brand", parent: name, min: 1)
            try self.validate(self.brand, name: "brand", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 65535)
            try self.validate(self.capabilities, name: "capabilities", parent: name, min: 1)
            try self.validate(self.capabilities, name: "capabilities", parent: name, pattern: "^[a-zA-Z0-9\\s'\\x{0022},.:\\\\\\/{$}\\[\\]=_\\-\\+]+$")
            try self.capabilityReport?.validate(name: "\(name).capabilityReport")
            try self.capabilitySchemas?.forEach {
                try $0.validate(name: "\(name).capabilitySchemas[]")
            }
            try self.validate(self.capabilitySchemas, name: "capabilitySchemas", parent: name, max: 40)
            try self.validate(self.classification, name: "classification", parent: name, max: 64)
            try self.validate(self.classification, name: "classification", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, max: 64)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, min: 1)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.metaData?.forEach {
                try validate($0.key, name: "metaData.key", parent: name, max: 128)
                try validate($0.key, name: "metaData.key", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]+")
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]*")
            }
            try self.validate(self.metaData, name: "metaData", parent: name, max: 50)
            try self.validate(self.metaData, name: "metaData", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, max: 128)
            try self.validate(self.model, name: "model", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.validate(self.owner, name: "owner", parent: name, max: 64)
            try self.validate(self.owner, name: "owner", parent: name, min: 1)
            try self.validate(self.owner, name: "owner", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 128)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, min: 1)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationMaterial = "AuthenticationMaterial"
            case authenticationMaterialType = "AuthenticationMaterialType"
            case brand = "Brand"
            case capabilities = "Capabilities"
            case capabilityReport = "CapabilityReport"
            case capabilitySchemas = "CapabilitySchemas"
            case classification = "Classification"
            case clientToken = "ClientToken"
            case credentialLockerId = "CredentialLockerId"
            case metaData = "MetaData"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case role = "Role"
            case serialNumber = "SerialNumber"
            case tags = "Tags"
        }
    }

    public struct CreateManagedThingResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the managed thing.
        public let arn: String?
        /// The timestamp value of when the device creation request occurred.
        public let createdAt: Date?
        /// The id of the managed thing.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
        }
    }

    public struct CreateNotificationConfigurationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The name of the destination for the notification configuration.
        public let destinationName: String
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType
        /// A set of key/value pairs that are used to manage the notification configuration.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateNotificationConfigurationRequest.idempotencyToken(), destinationName: String, eventType: EventType) {
            self.clientToken = clientToken
            self.destinationName = destinationName
            self.eventType = eventType
            self.tags = nil
        }

        @available(*, deprecated, message: "Members tags have been deprecated")
        @inlinable
        public init(clientToken: String? = CreateNotificationConfigurationRequest.idempotencyToken(), destinationName: String, eventType: EventType, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.destinationName = destinationName
            self.eventType = eventType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 1)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case destinationName = "DestinationName"
            case eventType = "EventType"
            case tags = "Tags"
        }
    }

    public struct CreateNotificationConfigurationResponse: AWSDecodableShape {
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType?

        @inlinable
        public init(eventType: EventType? = nil) {
            self.eventType = eventType
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "EventType"
        }
    }

    public struct CreateOtaTaskConfigurationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// A description of the over-the-air (OTA) task configuration.
        public let description: String?
        /// The name of the over-the-air (OTA) task.
        public let name: String?
        /// Describes the type of configuration used for the over-the-air (OTA) task.
        public let pushConfig: PushConfig?

        @inlinable
        public init(clientToken: String? = CreateOtaTaskConfigurationRequest.idempotencyToken(), description: String? = nil, name: String? = nil, pushConfig: PushConfig? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.pushConfig = pushConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.pushConfig?.validate(name: "\(name).pushConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case name = "Name"
            case pushConfig = "PushConfig"
        }
    }

    public struct CreateOtaTaskConfigurationResponse: AWSDecodableShape {
        /// The identifier of the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?

        @inlinable
        public init(taskConfigurationId: String? = nil) {
            self.taskConfigurationId = taskConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct CreateOtaTaskRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The description of the over-the-air (OTA) task.
        public let description: String?
        /// The deployment mechanism for the over-the-air (OTA) task.
        public let otaMechanism: OtaMechanism?
        public let otaSchedulingConfig: OtaTaskSchedulingConfig?
        /// The query string to add things to the thing group.
        public let otaTargetQueryString: String?
        public let otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig?
        /// The frequency type for the over-the-air (OTA) task.
        public let otaType: OtaType
        /// The connection protocol the over-the-air (OTA) task uses to update the device.
        public let `protocol`: OtaProtocol?
        /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
        public let s3Url: String
        /// A set of key/value pairs that are used to manage the over-the-air (OTA) task.
        public let tags: [String: String]?
        /// The device targeted for the over-the-air (OTA) task.
        public let target: [String]?
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?

        @inlinable
        public init(clientToken: String? = CreateOtaTaskRequest.idempotencyToken(), description: String? = nil, otaMechanism: OtaMechanism? = nil, otaSchedulingConfig: OtaTaskSchedulingConfig? = nil, otaTargetQueryString: String? = nil, otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig? = nil, otaType: OtaType, protocol: OtaProtocol? = nil, s3Url: String, tags: [String: String]? = nil, target: [String]? = nil, taskConfigurationId: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.otaMechanism = otaMechanism
            self.otaSchedulingConfig = otaSchedulingConfig
            self.otaTargetQueryString = otaTargetQueryString
            self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
            self.otaType = otaType
            self.`protocol` = `protocol`
            self.s3Url = s3Url
            self.tags = tags
            self.target = target
            self.taskConfigurationId = taskConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.otaSchedulingConfig?.validate(name: "\(name).otaSchedulingConfig")
            try self.otaTaskExecutionRetryConfig?.validate(name: "\(name).otaTaskExecutionRetryConfig")
            try self.validate(self.s3Url, name: "s3Url", parent: name, max: 1000)
            try self.validate(self.s3Url, name: "s3Url", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, max: 64)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, min: 1)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case otaMechanism = "OtaMechanism"
            case otaSchedulingConfig = "OtaSchedulingConfig"
            case otaTargetQueryString = "OtaTargetQueryString"
            case otaTaskExecutionRetryConfig = "OtaTaskExecutionRetryConfig"
            case otaType = "OtaType"
            case `protocol` = "Protocol"
            case s3Url = "S3Url"
            case tags = "Tags"
            case target = "Target"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct CreateOtaTaskResponse: AWSDecodableShape {
        /// A description of the over-the-air (OTA) task.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
        public let taskArn: String?
        /// The identifier of the over-the-air (OTA) task.
        public let taskId: String?

        @inlinable
        public init(description: String? = nil, taskArn: String? = nil, taskId: String? = nil) {
            self.description = description
            self.taskArn = taskArn
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case taskArn = "TaskArn"
            case taskId = "TaskId"
        }
    }

    public struct CreateProvisioningProfileRequest: AWSEncodableShape {
        /// The id of the certificate authority (CA) certificate.
        public let caCertificate: String?
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType
        /// A set of key/value pairs that are used to manage the provisioning profile.
        public let tags: [String: String]?

        @inlinable
        public init(caCertificate: String? = nil, clientToken: String? = CreateProvisioningProfileRequest.idempotencyToken(), name: String? = nil, provisioningType: ProvisioningType, tags: [String: String]? = nil) {
            self.caCertificate = caCertificate
            self.clientToken = clientToken
            self.name = name
            self.provisioningType = provisioningType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.caCertificate, name: "caCertificate", parent: name, pattern: "^-----BEGIN CERTIFICATE-----.*(.|\\n)*-----END CERTIFICATE-----\\n?$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case caCertificate = "CaCertificate"
            case clientToken = "ClientToken"
            case name = "Name"
            case provisioningType = "ProvisioningType"
            case tags = "Tags"
        }
    }

    public struct CreateProvisioningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public let arn: String?
        /// The id of the claim certificate.
        public let claimCertificate: String?
        /// The private key of the claim certificate. This is stored securely on the device for validating the connection endpoint with IoT managed integrations using the public key.
        public let claimCertificatePrivateKey: String?
        /// The identifier of the provisioning profile.
        public let id: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType?

        @inlinable
        public init(arn: String? = nil, claimCertificate: String? = nil, claimCertificatePrivateKey: String? = nil, id: String? = nil, name: String? = nil, provisioningType: ProvisioningType? = nil) {
            self.arn = arn
            self.claimCertificate = claimCertificate
            self.claimCertificatePrivateKey = claimCertificatePrivateKey
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case claimCertificate = "ClaimCertificate"
            case claimCertificatePrivateKey = "ClaimCertificatePrivateKey"
            case id = "Id"
            case name = "Name"
            case provisioningType = "ProvisioningType"
        }
    }

    public struct CredentialLockerSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public let arn: String?
        /// The timestampe value of when the credential locker was created at.
        public let createdAt: Date?
        /// The id of the credential locker.
        public let id: String?
        /// The name of the credential locker.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct DeleteAccountAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the account association to be deleted.
        public let accountAssociationId: String

        @inlinable
        public init(accountAssociationId: String) {
            self.accountAssociationId = accountAssociationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountAssociationId, key: "AccountAssociationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCloudConnectorRequest: AWSEncodableShape {
        /// The identifier of the cloud connector.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConnectorDestinationRequest: AWSEncodableShape {
        /// The identifier of the connector destination.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCredentialLockerRequest: AWSEncodableShape {
        /// The identifier of the credential locker.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDestinationRequest: AWSEncodableShape {
        /// The id of the customer-managed destination.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventLogConfigurationRequest: AWSEncodableShape {
        /// The identifier of the event log configuration.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 200)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteManagedThingRequest: AWSEncodableShape {
        /// When set to TRUE, a forceful deteletion of the managed thing will occur. When set to FALSE, a non-forceful deletion of the managed thing will occur.
        public let force: Bool?
        /// The id of the managed thing.
        public let identifier: String

        @inlinable
        public init(force: Bool? = nil, identifier: String) {
            self.force = force
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "Force")
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNotificationConfigurationRequest: AWSEncodableShape {
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType

        @inlinable
        public init(eventType: EventType) {
            self.eventType = eventType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventType, key: "EventType")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOtaTaskConfigurationRequest: AWSEncodableShape {
        /// The identifier of the over-the-air (OTA) task configuration.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOtaTaskRequest: AWSEncodableShape {
        /// The identifier of the over-the-air (OTA) task.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProvisioningProfileRequest: AWSEncodableShape {
        /// The name of the provisioning template.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeregisterAccountAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the account association to be deregistered.
        public let accountAssociationId: String
        /// The identifier of the managed thing to be deregistered from the account association.
        public let managedThingId: String

        @inlinable
        public init(accountAssociationId: String, managedThingId: String) {
            self.accountAssociationId = accountAssociationId
            self.managedThingId = managedThingId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case managedThingId = "ManagedThingId"
        }
    }

    public struct DestinationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String?
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the delivery destination.
        public let roleArn: String?

        @inlinable
        public init(deliveryDestinationArn: String? = nil, deliveryDestinationType: DeliveryDestinationType? = nil, description: String? = nil, name: String? = nil, roleArn: String? = nil) {
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case name = "Name"
            case roleArn = "RoleArn"
        }
    }

    public struct Device: AWSEncodableShape {
        /// The capability report for the device.
        public let capabilityReport: MatterCapabilityReport
        /// Report of all capabilities supported by the device.
        public let capabilitySchemas: [CapabilitySchemaItem]?
        /// The device id as defined by the connector.  This parameter is used for cloud-to-cloud devices only.
        public let connectorDeviceId: String
        /// The name of the device as defined by the connector.
        public let connectorDeviceName: String?
        /// The metadata attributes for a device.
        public let deviceMetadata: AWSDocument?

        @inlinable
        public init(capabilityReport: MatterCapabilityReport, capabilitySchemas: [CapabilitySchemaItem]? = nil, connectorDeviceId: String, connectorDeviceName: String? = nil, deviceMetadata: AWSDocument? = nil) {
            self.capabilityReport = capabilityReport
            self.capabilitySchemas = capabilitySchemas
            self.connectorDeviceId = connectorDeviceId
            self.connectorDeviceName = connectorDeviceName
            self.deviceMetadata = deviceMetadata
        }

        public func validate(name: String) throws {
            try self.capabilityReport.validate(name: "\(name).capabilityReport")
            try self.capabilitySchemas?.forEach {
                try $0.validate(name: "\(name).capabilitySchemas[]")
            }
            try self.validate(self.capabilitySchemas, name: "capabilitySchemas", parent: name, max: 40)
            try self.validate(self.connectorDeviceId, name: "connectorDeviceId", parent: name, max: 256)
            try self.validate(self.connectorDeviceId, name: "connectorDeviceId", parent: name, min: 1)
            try self.validate(self.connectorDeviceId, name: "connectorDeviceId", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.connectorDeviceName, name: "connectorDeviceName", parent: name, max: 256)
            try self.validate(self.connectorDeviceName, name: "connectorDeviceName", parent: name, min: 1)
            try self.validate(self.connectorDeviceName, name: "connectorDeviceName", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityReport = "CapabilityReport"
            case capabilitySchemas = "CapabilitySchemas"
            case connectorDeviceId = "ConnectorDeviceId"
            case connectorDeviceName = "ConnectorDeviceName"
            case deviceMetadata = "DeviceMetadata"
        }
    }

    public struct DeviceDiscoverySummary: AWSDecodableShape {
        /// The type of discovery process used to find devices.
        public let discoveryType: DiscoveryType?
        /// The unique identifier of the device discovery job.
        public let id: String?
        /// The current status of the device discovery job.
        public let status: DeviceDiscoveryStatus?

        @inlinable
        public init(discoveryType: DiscoveryType? = nil, id: String? = nil, status: DeviceDiscoveryStatus? = nil) {
            self.discoveryType = discoveryType
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case discoveryType = "DiscoveryType"
            case id = "Id"
            case status = "Status"
        }
    }

    public struct DiscoveredDeviceSummary: AWSDecodableShape {
        /// The authentication material required for connecting to the discovered device, such as credentials or tokens.
        public let authenticationMaterial: String?
        /// The brand of the discovered device.
        public let brand: String?
        /// The third-party device identifier as defined by the connector. This identifier must not contain personal identifiable information (PII).
        public let connectorDeviceId: String?
        /// The name of the device as defined by the connector or third-party system.
        public let connectorDeviceName: String?
        /// The list of device types or categories that the discovered device belongs to.
        public let deviceTypes: [String]?
        /// The timestamp indicating when the device was discovered.
        public let discoveredAt: Date?
        /// The identifier of the managed thing created for this discovered device, if one exists.
        public let managedThingId: String?
        /// The model of the discovered device.
        public let model: String?
        /// The status of the discovered device, indicating whether it has been added, removed, or modified since the last discovery.
        public let modification: DiscoveryModification?

        @inlinable
        public init(authenticationMaterial: String? = nil, brand: String? = nil, connectorDeviceId: String? = nil, connectorDeviceName: String? = nil, deviceTypes: [String]? = nil, discoveredAt: Date? = nil, managedThingId: String? = nil, model: String? = nil, modification: DiscoveryModification? = nil) {
            self.authenticationMaterial = authenticationMaterial
            self.brand = brand
            self.connectorDeviceId = connectorDeviceId
            self.connectorDeviceName = connectorDeviceName
            self.deviceTypes = deviceTypes
            self.discoveredAt = discoveredAt
            self.managedThingId = managedThingId
            self.model = model
            self.modification = modification
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationMaterial = "AuthenticationMaterial"
            case brand = "Brand"
            case connectorDeviceId = "ConnectorDeviceId"
            case connectorDeviceName = "ConnectorDeviceName"
            case deviceTypes = "DeviceTypes"
            case discoveredAt = "DiscoveredAt"
            case managedThingId = "ManagedThingId"
            case model = "Model"
            case modification = "Modification"
        }
    }

    public struct EndpointConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Lambda function configuration for the endpoint, used when the endpoint communicates through an AWS Lambda function.
        public let lambda: LambdaConfig?

        @inlinable
        public init(lambda: LambdaConfig? = nil) {
            self.lambda = lambda
        }

        public func validate(name: String) throws {
            try self.lambda?.validate(name: "\(name).lambda")
        }

        private enum CodingKeys: String, CodingKey {
            case lambda = "lambda"
        }
    }

    public struct EventLogConfigurationSummary: AWSDecodableShape {
        /// The logging level for the event log configuration.
        public let eventLogLevel: LogLevel?
        /// The identifier of the event log configuration.
        public let id: String?
        /// The identifier of the resource for the event log configuration.
        public let resourceId: String?
        /// The type of resource for the event log configuration.
        public let resourceType: String?

        @inlinable
        public init(eventLogLevel: LogLevel? = nil, id: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.eventLogLevel = eventLogLevel
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogLevel = "EventLogLevel"
            case id = "Id"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ExponentialRolloutRate: AWSEncodableShape & AWSDecodableShape {
        /// The base rate per minute for the rollout of an over-the-air (OTA) task.
        public let baseRatePerMinute: Int?
        /// The incremental factor for increasing the rollout rate of an over-the-air (OTA) task.
        public let incrementFactor: Double?
        /// The criteria for increasing the rollout rate of an over-the-air (OTA) task.
        public let rateIncreaseCriteria: RolloutRateIncreaseCriteria?

        @inlinable
        public init(baseRatePerMinute: Int? = nil, incrementFactor: Double? = nil, rateIncreaseCriteria: RolloutRateIncreaseCriteria? = nil) {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.baseRatePerMinute, name: "baseRatePerMinute", parent: name, max: 100)
            try self.validate(self.baseRatePerMinute, name: "baseRatePerMinute", parent: name, min: 1)
            try self.validate(self.incrementFactor, name: "incrementFactor", parent: name, max: 5.0)
            try self.validate(self.incrementFactor, name: "incrementFactor", parent: name, min: 1.1)
            try self.rateIncreaseCriteria?.validate(name: "\(name).rateIncreaseCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case baseRatePerMinute = "BaseRatePerMinute"
            case incrementFactor = "IncrementFactor"
            case rateIncreaseCriteria = "RateIncreaseCriteria"
        }
    }

    public struct GetAccountAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the account association to retrieve.
        public let accountAssociationId: String

        @inlinable
        public init(accountAssociationId: String) {
            self.accountAssociationId = accountAssociationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountAssociationId, key: "AccountAssociationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccountAssociationResponse: AWSDecodableShape {
        /// The unique identifier of the retrieved account association.
        public let accountAssociationId: String
        /// The Amazon Resource Name (ARN) of the account association.
        public let arn: String?
        /// The current status state for the account association.
        public let associationState: AssociationState
        /// The identifier of the connector destination associated with this account association.
        public let connectorDestinationId: String?
        /// The description of the account association.
        public let description: String?
        /// The error message explaining the current account association error.
        public let errorMessage: String?
        /// The name of the account association.
        public let name: String?
        /// Third party IoT platform OAuth authorization server URL backed with all the required parameters to perform end-user authentication.
        public let oAuthAuthorizationUrl: String
        /// A set of key/value pairs that are used to manage the account association.
        public let tags: [String: String]?

        @inlinable
        public init(accountAssociationId: String, arn: String? = nil, associationState: AssociationState, connectorDestinationId: String? = nil, description: String? = nil, errorMessage: String? = nil, name: String? = nil, oAuthAuthorizationUrl: String, tags: [String: String]? = nil) {
            self.accountAssociationId = accountAssociationId
            self.arn = arn
            self.associationState = associationState
            self.connectorDestinationId = connectorDestinationId
            self.description = description
            self.errorMessage = errorMessage
            self.name = name
            self.oAuthAuthorizationUrl = oAuthAuthorizationUrl
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case arn = "Arn"
            case associationState = "AssociationState"
            case connectorDestinationId = "ConnectorDestinationId"
            case description = "Description"
            case errorMessage = "ErrorMessage"
            case name = "Name"
            case oAuthAuthorizationUrl = "OAuthAuthorizationUrl"
            case tags = "Tags"
        }
    }

    public struct GetCloudConnectorRequest: AWSEncodableShape {
        /// The identifier of the C2C connector.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCloudConnectorResponse: AWSDecodableShape {
        /// A description of the C2C connector.
        public let description: String?
        /// The configuration details for the cloud connector endpoint, including connection parameters and authentication requirements.
        public let endpointConfig: EndpointConfig
        /// The type of endpoint used for the cloud connector, which defines how the connector communicates with external services.
        public let endpointType: EndpointType?
        /// The unique identifier of the cloud connector.
        public let id: String?
        /// The display name of the C2C connector.
        public let name: String
        /// The type of cloud connector created.
        public let type: CloudConnectorType?

        @inlinable
        public init(description: String? = nil, endpointConfig: EndpointConfig, endpointType: EndpointType? = nil, id: String? = nil, name: String, type: CloudConnectorType? = nil) {
            self.description = description
            self.endpointConfig = endpointConfig
            self.endpointType = endpointType
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case endpointConfig = "EndpointConfig"
            case endpointType = "EndpointType"
            case id = "Id"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct GetConnectorDestinationRequest: AWSEncodableShape {
        /// The identifier of the C2C connector destination.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectorDestinationResponse: AWSDecodableShape {
        /// The authentication configuration details for the connector destination, including OAuth settings and other authentication parameters.
        public let authConfig: AuthConfig?
        /// The authentication type used for the connector destination, which determines how credentials and access are managed.
        public let authType: AuthType?
        /// The identifier of the C2C connector.
        public let cloudConnectorId: String?
        /// A description of the connector destination.
        public let description: String?
        /// The unique identifier of the connector destination.
        public let id: String?
        /// The display name of the connector destination.
        public let name: String?
        /// The URL where users are redirected after completing the OAuth authorization process for the connector destination.
        public let oAuthCompleteRedirectUrl: String?
        /// The AWS Secrets Manager configuration used to securely store and manage sensitive information for the connector destination.
        public let secretsManager: SecretsManager?

        @inlinable
        public init(authConfig: AuthConfig? = nil, authType: AuthType? = nil, cloudConnectorId: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, oAuthCompleteRedirectUrl: String? = nil, secretsManager: SecretsManager? = nil) {
            self.authConfig = authConfig
            self.authType = authType
            self.cloudConnectorId = cloudConnectorId
            self.description = description
            self.id = id
            self.name = name
            self.oAuthCompleteRedirectUrl = oAuthCompleteRedirectUrl
            self.secretsManager = secretsManager
        }

        private enum CodingKeys: String, CodingKey {
            case authConfig = "AuthConfig"
            case authType = "AuthType"
            case cloudConnectorId = "CloudConnectorId"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case oAuthCompleteRedirectUrl = "OAuthCompleteRedirectUrl"
            case secretsManager = "SecretsManager"
        }
    }

    public struct GetCredentialLockerRequest: AWSEncodableShape {
        /// The identifier of the credential locker.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCredentialLockerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public let arn: String?
        /// The timestamp value of when the credential locker requset occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker.
        public let id: String?
        /// The name of the credential locker.
        public let name: String?
        /// A set of key/value pairs that are used to manage the credential locker.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct GetCustomEndpointRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetCustomEndpointResponse: AWSDecodableShape {
        /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
        public let endpointAddress: String

        @inlinable
        public init(endpointAddress: String) {
            self.endpointAddress = endpointAddress
        }

        private enum CodingKeys: String, CodingKey {
            case endpointAddress = "EndpointAddress"
        }
    }

    public struct GetDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// Provides the status of the default encryption configuration for an Amazon Web Services account.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct GetDestinationRequest: AWSEncodableShape {
        /// The name of the customer-managed destination.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDestinationResponse: AWSDecodableShape {
        /// The timestamp value of when the destination creation requset occurred.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String?
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the delivery destination role.
        public let roleArn: String?
        /// A set of key/value pairs that are used to manage the customer-managed destination.
        public let tags: [String: String]?
        /// The timestamp value of when the destination update requset occurred.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, deliveryDestinationArn: String? = nil, deliveryDestinationType: DeliveryDestinationType? = nil, description: String? = nil, name: String? = nil, roleArn: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.tags = nil
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members tags have been deprecated")
        @inlinable
        public init(createdAt: Date? = nil, deliveryDestinationArn: String? = nil, deliveryDestinationType: DeliveryDestinationType? = nil, description: String? = nil, name: String? = nil, roleArn: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case name = "Name"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetDeviceDiscoveryRequest: AWSEncodableShape {
        /// The id of the device discovery job request.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeviceDiscoveryResponse: AWSDecodableShape {
        /// The identifier of the account association used for the device discovery.
        public let accountAssociationId: String?
        /// The Amazon Resource Name (ARN) of the device discovery job request.
        public let arn: String
        /// The ID tracking the current discovery process for one connector association.
        public let connectorAssociationId: String?
        /// The id of the end-user's IoT hub.
        public let controllerId: String?
        /// The discovery type supporting the type of device to be discovered in the device discovery job request.
        public let discoveryType: DiscoveryType
        /// The timestamp value for the completion time of the device discovery.
        public let finishedAt: Date?
        /// The id of the device discovery job request.
        public let id: String
        /// The timestamp value for the start time of the device discovery.
        public let startedAt: Date
        /// The status of the device discovery job request.
        public let status: DeviceDiscoveryStatus
        /// A set of key/value pairs that are used to manage the device discovery request.
        public let tags: [String: String]?

        @inlinable
        public init(accountAssociationId: String? = nil, arn: String, controllerId: String? = nil, discoveryType: DiscoveryType, finishedAt: Date? = nil, id: String, startedAt: Date, status: DeviceDiscoveryStatus) {
            self.accountAssociationId = accountAssociationId
            self.arn = arn
            self.connectorAssociationId = nil
            self.controllerId = controllerId
            self.discoveryType = discoveryType
            self.finishedAt = finishedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.tags = nil
        }

        @available(*, deprecated, message: "Members connectorAssociationId, tags have been deprecated")
        @inlinable
        public init(accountAssociationId: String? = nil, arn: String, connectorAssociationId: String? = nil, controllerId: String? = nil, discoveryType: DiscoveryType, finishedAt: Date? = nil, id: String, startedAt: Date, status: DeviceDiscoveryStatus, tags: [String: String]? = nil) {
            self.accountAssociationId = accountAssociationId
            self.arn = arn
            self.connectorAssociationId = connectorAssociationId
            self.controllerId = controllerId
            self.discoveryType = discoveryType
            self.finishedAt = finishedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case arn = "Arn"
            case connectorAssociationId = "ConnectorAssociationId"
            case controllerId = "ControllerId"
            case discoveryType = "DiscoveryType"
            case finishedAt = "FinishedAt"
            case id = "Id"
            case startedAt = "StartedAt"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetEventLogConfigurationRequest: AWSEncodableShape {
        /// The identifier of the event log configuration.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 200)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventLogConfigurationResponse: AWSDecodableShape {
        /// The logging level for the event log configuration.
        public let eventLogLevel: LogLevel?
        /// The identifier of the event log configuration.
        public let id: String?
        /// The identifier of the resource for the event log configuration.
        public let resourceId: String?
        /// The type of resource for the event log configuration.
        public let resourceType: String?

        @inlinable
        public init(eventLogLevel: LogLevel? = nil, id: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.eventLogLevel = eventLogLevel
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogLevel = "EventLogLevel"
            case id = "Id"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct GetHubConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetHubConfigurationResponse: AWSDecodableShape {
        /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
        public let hubTokenTimerExpirySettingInSeconds: Int64?
        /// The timestamp value of when the hub configuration was updated.
        public let updatedAt: Date?

        @inlinable
        public init(hubTokenTimerExpirySettingInSeconds: Int64? = nil, updatedAt: Date? = nil) {
            self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case hubTokenTimerExpirySettingInSeconds = "HubTokenTimerExpirySettingInSeconds"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetManagedThingCapabilitiesRequest: AWSEncodableShape {
        /// The id of the device.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingCapabilitiesResponse: AWSDecodableShape {
        /// The capabilities of the device such as light bulb.
        public let capabilities: String?
        /// A report of the capabilities for the managed thing.
        public let capabilityReport: CapabilityReport?
        /// The id of the device.
        public let managedThingId: String?

        @inlinable
        public init(capabilities: String? = nil, capabilityReport: CapabilityReport? = nil, managedThingId: String? = nil) {
            self.capabilities = capabilities
            self.capabilityReport = capabilityReport
            self.managedThingId = managedThingId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case capabilityReport = "CapabilityReport"
            case managedThingId = "ManagedThingId"
        }
    }

    public struct GetManagedThingConnectivityDataRequest: AWSEncodableShape {
        /// The identifier of a managed thing.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingConnectivityDataResponse: AWSDecodableShape {
        /// The connectivity status for a managed thing.
        public let connected: Bool?
        /// The reason for the connectivity disconnect with the managed thing.
        public let disconnectReason: DisconnectReasonValue?
        /// The id of a managed thing.
        public let managedThingId: String?
        /// The timestamp value of when the connectivity status for a managed thing was last taken.
        public let timestamp: Date?

        @inlinable
        public init(connected: Bool? = nil, disconnectReason: DisconnectReasonValue? = nil, managedThingId: String? = nil, timestamp: Date? = nil) {
            self.connected = connected
            self.disconnectReason = disconnectReason
            self.managedThingId = managedThingId
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case connected = "Connected"
            case disconnectReason = "DisconnectReason"
            case managedThingId = "ManagedThingId"
            case timestamp = "Timestamp"
        }
    }

    public struct GetManagedThingMetaDataRequest: AWSEncodableShape {
        /// The managed thing id.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingMetaDataResponse: AWSDecodableShape {
        /// The managed thing id.
        public let managedThingId: String?
        /// The metadata for the managed thing.
        public let metaData: [String: String]?

        @inlinable
        public init(managedThingId: String? = nil, metaData: [String: String]? = nil) {
            self.managedThingId = managedThingId
            self.metaData = metaData
        }

        private enum CodingKeys: String, CodingKey {
            case managedThingId = "ManagedThingId"
            case metaData = "MetaData"
        }
    }

    public struct GetManagedThingRequest: AWSEncodableShape {
        /// The id of the managed thing.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingResponse: AWSDecodableShape {
        /// The timestampe value of when the device was activated.
        public let activatedAt: Date?
        /// The id of the advertised product.
        public let advertisedProductId: String?
        /// The Amazon Resource Name (ARN) of the managed thing.
        public let arn: String?
        /// The brand of the device.
        public let brand: String?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// The identifier of the connector destination associated with this managed thing.
        public let connectorDestinationId: String?
        /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).  This parameter is used for cloud-to-cloud devices only.
        public let connectorDeviceId: String?
        /// The id of the connector policy.  This parameter is used for cloud-to-cloud devices only.
        public let connectorPolicyId: String?
        /// The timestamp value of when the device creation request occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker for the managed thing.
        public let credentialLockerId: String?
        /// A Zwave device-specific key used during device activation.  This parameter is used for Zwave devices only.
        public let deviceSpecificKey: String?
        /// The network mode for the hub-connected device.
        public let hubNetworkMode: HubNetworkMode?
        /// The id of the managed thing.
        public let id: String?
        /// The unique 13 digit number that identifies the managed thing.
        public let internationalArticleNumber: String?
        /// The media access control (MAC) address for the device represented by the managed thing.  This parameter is used for Zigbee devices only.
        public let macAddress: String?
        /// The metadata for the managed thing.
        public let metaData: [String: String]?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// Id of the controller device used for the discovery job.
        public let parentControllerId: String?
        /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
        public let provisioningStatus: ProvisioningStatus?
        /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public let role: Role?
        /// The serial number of the device.
        public let serialNumber: String?
        /// A set of key/value pairs that are used to manage the managed thing.
        public let tags: [String: String]?
        /// The universal product code (UPC) of the device model. The UPC is typically used in the United States of America and Canada.
        public let universalProductCode: String?
        /// The timestamp value of when the managed thing was last updated at.
        public let updatedAt: Date?

        @inlinable
        public init(activatedAt: Date? = nil, advertisedProductId: String? = nil, arn: String? = nil, brand: String? = nil, classification: String? = nil, connectorDestinationId: String? = nil, connectorDeviceId: String? = nil, createdAt: Date? = nil, credentialLockerId: String? = nil, deviceSpecificKey: String? = nil, hubNetworkMode: HubNetworkMode? = nil, id: String? = nil, internationalArticleNumber: String? = nil, macAddress: String? = nil, metaData: [String: String]? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, parentControllerId: String? = nil, provisioningStatus: ProvisioningStatus? = nil, role: Role? = nil, serialNumber: String? = nil, tags: [String: String]? = nil, universalProductCode: String? = nil, updatedAt: Date? = nil) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDestinationId = connectorDestinationId
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = nil
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.deviceSpecificKey = deviceSpecificKey
            self.hubNetworkMode = hubNetworkMode
            self.id = id
            self.internationalArticleNumber = internationalArticleNumber
            self.macAddress = macAddress
            self.metaData = metaData
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.tags = tags
            self.universalProductCode = universalProductCode
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members connectorPolicyId have been deprecated")
        @inlinable
        public init(activatedAt: Date? = nil, advertisedProductId: String? = nil, arn: String? = nil, brand: String? = nil, classification: String? = nil, connectorDestinationId: String? = nil, connectorDeviceId: String? = nil, connectorPolicyId: String? = nil, createdAt: Date? = nil, credentialLockerId: String? = nil, deviceSpecificKey: String? = nil, hubNetworkMode: HubNetworkMode? = nil, id: String? = nil, internationalArticleNumber: String? = nil, macAddress: String? = nil, metaData: [String: String]? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, parentControllerId: String? = nil, provisioningStatus: ProvisioningStatus? = nil, role: Role? = nil, serialNumber: String? = nil, tags: [String: String]? = nil, universalProductCode: String? = nil, updatedAt: Date? = nil) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDestinationId = connectorDestinationId
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = connectorPolicyId
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.deviceSpecificKey = deviceSpecificKey
            self.hubNetworkMode = hubNetworkMode
            self.id = id
            self.internationalArticleNumber = internationalArticleNumber
            self.macAddress = macAddress
            self.metaData = metaData
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.tags = tags
            self.universalProductCode = universalProductCode
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case activatedAt = "ActivatedAt"
            case advertisedProductId = "AdvertisedProductId"
            case arn = "Arn"
            case brand = "Brand"
            case classification = "Classification"
            case connectorDestinationId = "ConnectorDestinationId"
            case connectorDeviceId = "ConnectorDeviceId"
            case connectorPolicyId = "ConnectorPolicyId"
            case createdAt = "CreatedAt"
            case credentialLockerId = "CredentialLockerId"
            case deviceSpecificKey = "DeviceSpecificKey"
            case hubNetworkMode = "HubNetworkMode"
            case id = "Id"
            case internationalArticleNumber = "InternationalArticleNumber"
            case macAddress = "MacAddress"
            case metaData = "MetaData"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case parentControllerId = "ParentControllerId"
            case provisioningStatus = "ProvisioningStatus"
            case role = "Role"
            case serialNumber = "SerialNumber"
            case tags = "Tags"
            case universalProductCode = "UniversalProductCode"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetManagedThingStateRequest: AWSEncodableShape {
        /// The id of the device.
        public let managedThingId: String

        @inlinable
        public init(managedThingId: String) {
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingStateResponse: AWSDecodableShape {
        /// The device endpoint.
        public let endpoints: [StateEndpoint]

        @inlinable
        public init(endpoints: [StateEndpoint]) {
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct GetNotificationConfigurationRequest: AWSEncodableShape {
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType

        @inlinable
        public init(eventType: EventType) {
            self.eventType = eventType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventType, key: "EventType")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationConfigurationResponse: AWSDecodableShape {
        /// The timestamp value of when the notification configuration was created.
        public let createdAt: Date?
        /// The name of the destination for the notification configuration.
        public let destinationName: String?
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType?
        /// A set of key/value pairs that are used to manage the notification configuration.
        public let tags: [String: String]?
        /// The timestamp value of when the notification configuration was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, destinationName: String? = nil, eventType: EventType? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.destinationName = destinationName
            self.eventType = eventType
            self.tags = nil
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members tags have been deprecated")
        @inlinable
        public init(createdAt: Date? = nil, destinationName: String? = nil, eventType: EventType? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.destinationName = destinationName
            self.eventType = eventType
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case destinationName = "DestinationName"
            case eventType = "EventType"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetOtaTaskConfigurationRequest: AWSEncodableShape {
        /// The over-the-air (OTA) task configuration id.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOtaTaskConfigurationResponse: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
        public let createdAt: Date?
        /// A description of the over-the-air (OTA) task configuration.
        public let description: String?
        /// The name of the over-the-air (OTA) task configuration.
        public let name: String?
        /// Describes the type of configuration used for the over-the-air (OTA) task.
        public let pushConfig: PushConfig?
        /// The over-the-air (OTA) task configuration id.
        public let taskConfigurationId: String?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, name: String? = nil, pushConfig: PushConfig? = nil, taskConfigurationId: String? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.pushConfig = pushConfig
            self.taskConfigurationId = taskConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case name = "Name"
            case pushConfig = "PushConfig"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct GetOtaTaskRequest: AWSEncodableShape {
        /// The over-the-air (OTA) task id.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOtaTaskResponse: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task was created.
        public let createdAt: Date?
        /// The description of the over-the-air (OTA) task.
        public let description: String?
        /// The timestamp value of when the over-the-air (OTA) task was last updated at.
        public let lastUpdatedAt: Date?
        /// The deployment mechanism for the over-the-air (OTA) task.
        public let otaMechanism: OtaMechanism?
        public let otaSchedulingConfig: OtaTaskSchedulingConfig?
        /// The query string to add things to the thing group.
        public let otaTargetQueryString: String?
        public let otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig?
        /// The frequency type for the over-the-air (OTA) task.
        public let otaType: OtaType?
        /// The connection protocol the over-the-air (OTA) task uses to update the device.
        public let `protocol`: OtaProtocol?
        /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
        public let s3Url: String?
        /// The status of the over-the-air (OTA) task.
        public let status: OtaStatus?
        /// A set of key/value pairs that are used to manage the over-the-air (OTA) task.
        public let tags: [String: String]?
        /// The device targeted for the over-the-air (OTA) task.
        public let target: [String]?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task
        public let taskArn: String?
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?
        /// The id of the over-the-air (OTA) task.
        public let taskId: String?
        /// The processing details of all over-the-air (OTA) tasks.
        public let taskProcessingDetails: TaskProcessingDetails?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, lastUpdatedAt: Date? = nil, otaMechanism: OtaMechanism? = nil, otaSchedulingConfig: OtaTaskSchedulingConfig? = nil, otaTargetQueryString: String? = nil, otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig? = nil, otaType: OtaType? = nil, protocol: OtaProtocol? = nil, s3Url: String? = nil, status: OtaStatus? = nil, tags: [String: String]? = nil, target: [String]? = nil, taskArn: String? = nil, taskConfigurationId: String? = nil, taskId: String? = nil, taskProcessingDetails: TaskProcessingDetails? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.otaMechanism = otaMechanism
            self.otaSchedulingConfig = otaSchedulingConfig
            self.otaTargetQueryString = otaTargetQueryString
            self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
            self.otaType = otaType
            self.`protocol` = `protocol`
            self.s3Url = s3Url
            self.status = status
            self.tags = tags
            self.target = target
            self.taskArn = taskArn
            self.taskConfigurationId = taskConfigurationId
            self.taskId = taskId
            self.taskProcessingDetails = taskProcessingDetails
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case lastUpdatedAt = "LastUpdatedAt"
            case otaMechanism = "OtaMechanism"
            case otaSchedulingConfig = "OtaSchedulingConfig"
            case otaTargetQueryString = "OtaTargetQueryString"
            case otaTaskExecutionRetryConfig = "OtaTaskExecutionRetryConfig"
            case otaType = "OtaType"
            case `protocol` = "Protocol"
            case s3Url = "S3Url"
            case status = "Status"
            case tags = "Tags"
            case target = "Target"
            case taskArn = "TaskArn"
            case taskConfigurationId = "TaskConfigurationId"
            case taskId = "TaskId"
            case taskProcessingDetails = "TaskProcessingDetails"
        }
    }

    public struct GetProvisioningProfileRequest: AWSEncodableShape {
        /// The provisioning template the device uses for the provisioning process.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProvisioningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public let arn: String?
        /// The id of the claim certificate.
        public let claimCertificate: String?
        /// The provisioning profile id..
        public let id: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType?
        /// A set of key/value pairs that are used to manage the provisioning profile.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, claimCertificate: String? = nil, id: String? = nil, name: String? = nil, provisioningType: ProvisioningType? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.claimCertificate = claimCertificate
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case claimCertificate = "ClaimCertificate"
            case id = "Id"
            case name = "Name"
            case provisioningType = "ProvisioningType"
            case tags = "Tags"
        }
    }

    public struct GetRuntimeLogConfigurationRequest: AWSEncodableShape {
        /// The id for a managed thing.
        public let managedThingId: String

        @inlinable
        public init(managedThingId: String) {
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRuntimeLogConfigurationResponse: AWSDecodableShape {
        /// The id for a managed thing.
        public let managedThingId: String?
        /// The runtime log configuration for a managed thing.
        public let runtimeLogConfigurations: RuntimeLogConfigurations?

        @inlinable
        public init(managedThingId: String? = nil, runtimeLogConfigurations: RuntimeLogConfigurations? = nil) {
            self.managedThingId = managedThingId
            self.runtimeLogConfigurations = runtimeLogConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case managedThingId = "ManagedThingId"
            case runtimeLogConfigurations = "RuntimeLogConfigurations"
        }
    }

    public struct GetSchemaVersionRequest: AWSEncodableShape {
        /// The format of the schema version.
        public let format: SchemaVersionFormat?
        /// Schema id with a version specified. If the version is missing, it defaults to latest version.
        public let schemaVersionedId: String
        /// The type of schema version.
        public let type: SchemaVersionType

        @inlinable
        public init(format: SchemaVersionFormat? = nil, schemaVersionedId: String, type: SchemaVersionType) {
            self.format = format
            self.schemaVersionedId = schemaVersionedId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.format, key: "Format")
            request.encodePath(self.schemaVersionedId, key: "SchemaVersionedId")
            request.encodePath(self.type, key: "Type")
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaVersionedId, name: "schemaVersionedId", parent: name, max: 128)
            try self.validate(self.schemaVersionedId, name: "schemaVersionedId", parent: name, min: 7)
            try self.validate(self.schemaVersionedId, name: "schemaVersionedId", parent: name, pattern: "^[a-zA-Z0-9.]+@(\\d+\\.\\d+(\\.\\d+)?|\\$latest)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaVersionResponse: AWSDecodableShape {
        /// The description of the schema version.
        public let description: String?
        /// The name of the schema version.
        public let namespace: String?
        /// The schema of the schema version.
        public let schema: AWSDocument?
        /// The id of the schema version.
        public let schemaId: String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public let semanticVersion: String?
        /// The type of schema version.
        public let type: SchemaVersionType?
        /// The visibility of the schema version.
        public let visibility: SchemaVersionVisibility?

        @inlinable
        public init(description: String? = nil, namespace: String? = nil, schema: AWSDocument? = nil, schemaId: String? = nil, semanticVersion: String? = nil, type: SchemaVersionType? = nil, visibility: SchemaVersionVisibility? = nil) {
            self.description = description
            self.namespace = namespace
            self.schema = schema
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case namespace = "Namespace"
            case schema = "Schema"
            case schemaId = "SchemaId"
            case semanticVersion = "SemanticVersion"
            case type = "Type"
            case visibility = "Visibility"
        }
    }

    public struct LambdaConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function used as an endpoint.
        public let arn: String

        @inlinable
        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^(arn:aws:lambda:[0-9a-zA-Z-]+:[0-9]+:function:)?([a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?)$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct ListAccountAssociationsRequest: AWSEncodableShape {
        /// The identifier of the connector destination to filter account associations by.
        public let connectorDestinationId: String?
        /// The maximum number of account associations to return in a single response.
        public let maxResults: Int?
        /// A token used for pagination of results.
        public let nextToken: String?

        @inlinable
        public init(connectorDestinationId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.connectorDestinationId = connectorDestinationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectorDestinationId, key: "ConnectorDestinationId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorDestinationId, name: "connectorDestinationId", parent: name, max: 64)
            try self.validate(self.connectorDestinationId, name: "connectorDestinationId", parent: name, min: 1)
            try self.validate(self.connectorDestinationId, name: "connectorDestinationId", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccountAssociationsResponse: AWSDecodableShape {
        /// The list of account associations that match the specified criteria.
        public let items: [AccountAssociationItem]?
        /// A token used for pagination of results when there are more account associations than can be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(items: [AccountAssociationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListCloudConnectorsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function to filter cloud connectors by.
        public let lambdaArn: String?
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// The type of cloud connectors to filter by when listing available connectors.
        public let type: CloudConnectorType?

        @inlinable
        public init(lambdaArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, type: CloudConnectorType? = nil) {
            self.lambdaArn = lambdaArn
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.lambdaArn, key: "LambdaArn")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.type, key: "Type")
        }

        public func validate(name: String) throws {
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^(arn:aws:lambda:[0-9a-zA-Z-]+:[0-9]+:function:)?([a-zA-Z0-9-_]+(:(\\$LATEST|[a-zA-Z0-9-_]+))?)$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCloudConnectorsResponse: AWSDecodableShape {
        /// The list of connectors.
        public let items: [ConnectorItem]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ConnectorItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectorDestinationsRequest: AWSEncodableShape {
        /// The identifier of the cloud connector to filter connector destinations by.
        public let cloudConnectorId: String?
        /// The maximum number of connector destinations to return in a single response.
        public let maxResults: Int?
        /// A token used for pagination of results.
        public let nextToken: String?

        @inlinable
        public init(cloudConnectorId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.cloudConnectorId = cloudConnectorId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.cloudConnectorId, key: "CloudConnectorId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.cloudConnectorId, name: "cloudConnectorId", parent: name, max: 64)
            try self.validate(self.cloudConnectorId, name: "cloudConnectorId", parent: name, min: 1)
            try self.validate(self.cloudConnectorId, name: "cloudConnectorId", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConnectorDestinationsResponse: AWSDecodableShape {
        /// The list of connector destinations that match the specified criteria.
        public let connectorDestinationList: [ConnectorDestinationSummary]?
        /// A token used for pagination of results when there are more connector destinations than can be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(connectorDestinationList: [ConnectorDestinationSummary]? = nil, nextToken: String? = nil) {
            self.connectorDestinationList = connectorDestinationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectorDestinationList = "ConnectorDestinationList"
            case nextToken = "NextToken"
        }
    }

    public struct ListCredentialLockersRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCredentialLockersResponse: AWSDecodableShape {
        /// The list of credential lockers.
        public let items: [CredentialLockerSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [CredentialLockerSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListDestinationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDestinationsResponse: AWSDecodableShape {
        /// The list of destinations.
        public let destinationList: [DestinationSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(destinationList: [DestinationSummary]? = nil, nextToken: String? = nil) {
            self.destinationList = destinationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinationList = "DestinationList"
            case nextToken = "NextToken"
        }
    }

    public struct ListDeviceDiscoveriesRequest: AWSEncodableShape {
        /// The maximum number of device discovery jobs to return in a single response.
        public let maxResults: Int?
        /// A token used for pagination of results.
        public let nextToken: String?
        /// The status to filter device discovery jobs by.
        public let statusFilter: DeviceDiscoveryStatus?
        /// The discovery type to filter device discovery jobs by.
        public let typeFilter: DiscoveryType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, statusFilter: DeviceDiscoveryStatus? = nil, typeFilter: DiscoveryType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.statusFilter = statusFilter
            self.typeFilter = typeFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.statusFilter, key: "StatusFilter")
            request.encodeQuery(self.typeFilter, key: "TypeFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDeviceDiscoveriesResponse: AWSDecodableShape {
        /// The list of device discovery jobs that match the specified criteria.
        public let items: [DeviceDiscoverySummary]?
        /// A token used for pagination of results when there are more device discovery jobs than can be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(items: [DeviceDiscoverySummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListDiscoveredDevicesRequest: AWSEncodableShape {
        /// The identifier of the device discovery job to list discovered devices for.
        public let identifier: String
        /// The maximum number of discovered devices to return in a single response.
        public let maxResults: Int?
        /// A token used for pagination of results.
        public let nextToken: String?

        @inlinable
        public init(identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDiscoveredDevicesResponse: AWSDecodableShape {
        /// The list of discovered devices that match the specified criteria.
        public let items: [DiscoveredDeviceSummary]?
        /// A token used for pagination of results when there are more discovered devices than can be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(items: [DiscoveredDeviceSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventLogConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventLogConfigurationsResponse: AWSDecodableShape {
        /// A list of each event log configuration and pertinent information.
        public let eventLogConfigurationList: [EventLogConfigurationSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(eventLogConfigurationList: [EventLogConfigurationSummary]? = nil, nextToken: String? = nil) {
            self.eventLogConfigurationList = eventLogConfigurationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogConfigurationList = "EventLogConfigurationList"
            case nextToken = "NextToken"
        }
    }

    public struct ListManagedThingAccountAssociationsRequest: AWSEncodableShape {
        /// The identifier of the account association to filter results by. When specified, only associations with this account association ID will be returned.
        public let accountAssociationId: String?
        /// The identifier of the managed thing to list account associations for.
        public let managedThingId: String?
        /// The maximum number of account associations to return in a single response.
        public let maxResults: Int?
        /// A token used for pagination of results.
        public let nextToken: String?

        @inlinable
        public init(accountAssociationId: String? = nil, managedThingId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountAssociationId = accountAssociationId
            self.managedThingId = managedThingId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountAssociationId, key: "AccountAssociationId")
            request.encodeQuery(self.managedThingId, key: "ManagedThingId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedThingAccountAssociationsResponse: AWSDecodableShape {
        /// The list of managed thing associations that match the specified criteria, including the managed thing ID and account association ID for each association.
        public let items: [ManagedThingAssociation]?
        /// A token used for pagination of results when there are more account associations than can be returned in a single response.
        public let nextToken: String?

        @inlinable
        public init(items: [ManagedThingAssociation]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListManagedThingSchemasRequest: AWSEncodableShape {
        /// Filter on a capability id.
        public let capabilityIdFilter: String?
        /// Filter on an endpoint id.
        public let endpointIdFilter: String?
        /// The managed thing id.
        public let identifier: String
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(capabilityIdFilter: String? = nil, endpointIdFilter: String? = nil, identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.capabilityIdFilter = capabilityIdFilter
            self.endpointIdFilter = endpointIdFilter
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.capabilityIdFilter, key: "CapabilityIdFilter")
            request.encodeQuery(self.endpointIdFilter, key: "EndpointIdFilter")
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityIdFilter, name: "capabilityIdFilter", parent: name, max: 128)
            try self.validate(self.capabilityIdFilter, name: "capabilityIdFilter", parent: name, min: 1)
            try self.validate(self.capabilityIdFilter, name: "capabilityIdFilter", parent: name, pattern: "^[a-zA-Z0-9./]+(@\\d+\\.\\d+)?$")
            try self.validate(self.endpointIdFilter, name: "endpointIdFilter", parent: name, max: 64)
            try self.validate(self.endpointIdFilter, name: "endpointIdFilter", parent: name, min: 1)
            try self.validate(self.endpointIdFilter, name: "endpointIdFilter", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedThingSchemasResponse: AWSDecodableShape {
        /// The list of managed thing schemas.
        public let items: [ManagedThingSchemaListItem]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ManagedThingSchemaListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListManagedThingsRequest: AWSEncodableShape {
        /// Filter managed things by the connector destination ID they are associated with.
        public let connectorDestinationIdFilter: String?
        /// Filter managed things by the connector device ID they are associated with. When specified, only managed things with this connector device ID will be returned.
        public let connectorDeviceIdFilter: String?
        /// Filter on a connector policy id for a managed thing.
        public let connectorPolicyIdFilter: String?
        /// Filter on a credential locker for a managed thing.
        public let credentialLockerFilter: String?
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// Filter on device owners when listing managed things.
        public let ownerFilter: String?
        /// Filter on a parent controller id for a managed thing.
        public let parentControllerIdentifierFilter: String?
        /// Filter on the status of the device.
        public let provisioningStatusFilter: ProvisioningStatus?
        /// Filter on the type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public let roleFilter: Role?
        /// Filter on the serial number of the device.
        public let serialNumberFilter: String?

        @inlinable
        public init(connectorDestinationIdFilter: String? = nil, connectorDeviceIdFilter: String? = nil, credentialLockerFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, ownerFilter: String? = nil, parentControllerIdentifierFilter: String? = nil, provisioningStatusFilter: ProvisioningStatus? = nil, roleFilter: Role? = nil, serialNumberFilter: String? = nil) {
            self.connectorDestinationIdFilter = connectorDestinationIdFilter
            self.connectorDeviceIdFilter = connectorDeviceIdFilter
            self.connectorPolicyIdFilter = nil
            self.credentialLockerFilter = credentialLockerFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerFilter = ownerFilter
            self.parentControllerIdentifierFilter = parentControllerIdentifierFilter
            self.provisioningStatusFilter = provisioningStatusFilter
            self.roleFilter = roleFilter
            self.serialNumberFilter = serialNumberFilter
        }

        @available(*, deprecated, message: "Members connectorPolicyIdFilter have been deprecated")
        @inlinable
        public init(connectorDestinationIdFilter: String? = nil, connectorDeviceIdFilter: String? = nil, connectorPolicyIdFilter: String? = nil, credentialLockerFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, ownerFilter: String? = nil, parentControllerIdentifierFilter: String? = nil, provisioningStatusFilter: ProvisioningStatus? = nil, roleFilter: Role? = nil, serialNumberFilter: String? = nil) {
            self.connectorDestinationIdFilter = connectorDestinationIdFilter
            self.connectorDeviceIdFilter = connectorDeviceIdFilter
            self.connectorPolicyIdFilter = connectorPolicyIdFilter
            self.credentialLockerFilter = credentialLockerFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerFilter = ownerFilter
            self.parentControllerIdentifierFilter = parentControllerIdentifierFilter
            self.provisioningStatusFilter = provisioningStatusFilter
            self.roleFilter = roleFilter
            self.serialNumberFilter = serialNumberFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectorDestinationIdFilter, key: "ConnectorDestinationIdFilter")
            request.encodeQuery(self.connectorDeviceIdFilter, key: "ConnectorDeviceIdFilter")
            request.encodeQuery(self.connectorPolicyIdFilter, key: "ConnectorPolicyIdFilter")
            request.encodeQuery(self.credentialLockerFilter, key: "CredentialLockerFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.ownerFilter, key: "OwnerFilter")
            request.encodeQuery(self.parentControllerIdentifierFilter, key: "ParentControllerIdentifierFilter")
            request.encodeQuery(self.provisioningStatusFilter, key: "ProvisioningStatusFilter")
            request.encodeQuery(self.roleFilter, key: "RoleFilter")
            request.encodeQuery(self.serialNumberFilter, key: "SerialNumberFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorDestinationIdFilter, name: "connectorDestinationIdFilter", parent: name, max: 64)
            try self.validate(self.connectorDestinationIdFilter, name: "connectorDestinationIdFilter", parent: name, min: 1)
            try self.validate(self.connectorDestinationIdFilter, name: "connectorDestinationIdFilter", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.connectorDeviceIdFilter, name: "connectorDeviceIdFilter", parent: name, max: 256)
            try self.validate(self.connectorDeviceIdFilter, name: "connectorDeviceIdFilter", parent: name, min: 1)
            try self.validate(self.connectorDeviceIdFilter, name: "connectorDeviceIdFilter", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.connectorPolicyIdFilter, name: "connectorPolicyIdFilter", parent: name, max: 64)
            try self.validate(self.connectorPolicyIdFilter, name: "connectorPolicyIdFilter", parent: name, min: 1)
            try self.validate(self.connectorPolicyIdFilter, name: "connectorPolicyIdFilter", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.credentialLockerFilter, name: "credentialLockerFilter", parent: name, max: 64)
            try self.validate(self.credentialLockerFilter, name: "credentialLockerFilter", parent: name, min: 1)
            try self.validate(self.credentialLockerFilter, name: "credentialLockerFilter", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.ownerFilter, name: "ownerFilter", parent: name, max: 64)
            try self.validate(self.ownerFilter, name: "ownerFilter", parent: name, min: 1)
            try self.validate(self.ownerFilter, name: "ownerFilter", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.parentControllerIdentifierFilter, name: "parentControllerIdentifierFilter", parent: name, max: 64)
            try self.validate(self.parentControllerIdentifierFilter, name: "parentControllerIdentifierFilter", parent: name, min: 1)
            try self.validate(self.parentControllerIdentifierFilter, name: "parentControllerIdentifierFilter", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.serialNumberFilter, name: "serialNumberFilter", parent: name, max: 128)
            try self.validate(self.serialNumberFilter, name: "serialNumberFilter", parent: name, min: 1)
            try self.validate(self.serialNumberFilter, name: "serialNumberFilter", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedThingsResponse: AWSDecodableShape {
        /// The list of managed things.
        public let items: [ManagedThingSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ManagedThingSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListNotificationConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationConfigurationsResponse: AWSDecodableShape {
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// The list of notification configurations.
        public let notificationConfigurationList: [NotificationConfigurationSummary]?

        @inlinable
        public init(nextToken: String? = nil, notificationConfigurationList: [NotificationConfigurationSummary]? = nil) {
            self.nextToken = nextToken
            self.notificationConfigurationList = notificationConfigurationList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case notificationConfigurationList = "NotificationConfigurationList"
        }
    }

    public struct ListOtaTaskConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOtaTaskConfigurationsResponse: AWSDecodableShape {
        /// The list of the over-the-air (OTA) task configurations.
        public let items: [OtaTaskConfigurationSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [OtaTaskConfigurationSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListOtaTaskExecutionsRequest: AWSEncodableShape {
        /// The over-the-air (OTA) task id.
        public let identifier: String
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_+/-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOtaTaskExecutionsResponse: AWSDecodableShape {
        /// A list of all of the over-the-air (OTA) task executions.
        public let executionSummaries: [OtaTaskExecutionSummaries]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(executionSummaries: [OtaTaskExecutionSummaries]? = nil, nextToken: String? = nil) {
            self.executionSummaries = executionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case executionSummaries = "ExecutionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListOtaTasksRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_+/-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOtaTasksResponse: AWSDecodableShape {
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// A list of all of the over-the-air (OTA) tasks.
        public let tasks: [OtaTaskSummary]?

        @inlinable
        public init(nextToken: String? = nil, tasks: [OtaTaskSummary]? = nil) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tasks = "Tasks"
        }
    }

    public struct ListProvisioningProfilesRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProvisioningProfilesResponse: AWSDecodableShape {
        /// The list of provisioning profiles.
        public let items: [ProvisioningProfileSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ProvisioningProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListSchemaVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// Filter on the name of the schema version.
        public let namespace: String?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// Filter on the id of the schema version.
        public let schemaId: String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public let semanticVersion: String?
        /// Filter on the type of schema version.
        public let type: SchemaVersionType
        /// The visibility of the schema version.
        public let visibility: SchemaVersionVisibility?

        @inlinable
        public init(maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, schemaId: String? = nil, semanticVersion: String? = nil, type: SchemaVersionType, visibility: SchemaVersionVisibility? = nil) {
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.namespace, key: "NamespaceFilter")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.schemaId, key: "SchemaIdFilter")
            request.encodeQuery(self.semanticVersion, key: "SemanticVersionFilter")
            request.encodePath(self.type, key: "Type")
            request.encodeQuery(self.visibility, key: "VisibilityFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 12)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 3)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-z0-9]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.schemaId, name: "schemaId", parent: name, max: 128)
            try self.validate(self.schemaId, name: "schemaId", parent: name, min: 3)
            try self.validate(self.schemaId, name: "schemaId", parent: name, pattern: "^[a-zA-Z0-9.]+$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, max: 12)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, min: 3)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^(\\d+\\.\\d+(\\.\\d+)?|\\$latest)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemaVersionsResponse: AWSDecodableShape {
        /// The list of schema versions.
        public let items: [SchemaVersionListItem]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [SchemaVersionListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource for which to list tags.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:iotmanagedintegrations:[0-9a-zA-Z-]+:[0-9]+:(managed-thing|provisioning-profile|ota-task|credential-locker|account-association)/[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A set of key/value pairs that are used to manage the resource.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ManagedThingAssociation: AWSDecodableShape {
        /// The identifier of the account association in the association.
        public let accountAssociationId: String?
        /// The identifier of the managed thing in the association.
        public let managedThingId: String?

        @inlinable
        public init(accountAssociationId: String? = nil, managedThingId: String? = nil) {
            self.accountAssociationId = accountAssociationId
            self.managedThingId = managedThingId
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case managedThingId = "ManagedThingId"
        }
    }

    public struct ManagedThingSchemaListItem: AWSDecodableShape {
        /// The id of the capability for a managed thing.
        public let capabilityId: String?
        /// The id of the endpoint for a managed thing.
        public let endpointId: String?
        /// The validation schema for one schema item associated with a managed thing.
        public let schema: AWSDocument?

        @inlinable
        public init(capabilityId: String? = nil, endpointId: String? = nil, schema: AWSDocument? = nil) {
            self.capabilityId = capabilityId
            self.endpointId = endpointId
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityId = "CapabilityId"
            case endpointId = "EndpointId"
            case schema = "Schema"
        }
    }

    public struct ManagedThingSummary: AWSDecodableShape {
        /// The timestampe value of when the managed thing was activated at.
        public let activatedAt: Date?
        /// The id of the advertised product.
        public let advertisedProductId: String?
        /// The Amazon Resource Name (ARN) of the managed thing.
        public let arn: String?
        /// The brand of the device.
        public let brand: String?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// The identifier of the connector destination associated with this managed thing, if applicable.
        public let connectorDestinationId: String?
        /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).  This parameter is used for cloud-to-cloud devices only.
        public let connectorDeviceId: String?
        /// The id of the connector policy.  This parameter is used for cloud-to-cloud devices only.
        public let connectorPolicyId: String?
        /// The timestamp value of when the device creation request occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker for the managed thing.
        public let credentialLockerId: String?
        /// The id of the device.
        public let id: String?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// Id of the controller device used for the discovery job.
        public let parentControllerId: String?
        /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
        public let provisioningStatus: ProvisioningStatus?
        /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public let role: Role?
        /// The serial number of the device.
        public let serialNumber: String?
        /// The timestamp value of when the managed thing was last updated at.
        public let updatedAt: Date?

        @inlinable
        public init(activatedAt: Date? = nil, advertisedProductId: String? = nil, arn: String? = nil, brand: String? = nil, classification: String? = nil, connectorDestinationId: String? = nil, connectorDeviceId: String? = nil, createdAt: Date? = nil, credentialLockerId: String? = nil, id: String? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, parentControllerId: String? = nil, provisioningStatus: ProvisioningStatus? = nil, role: Role? = nil, serialNumber: String? = nil, updatedAt: Date? = nil) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDestinationId = connectorDestinationId
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = nil
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.id = id
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.updatedAt = updatedAt
        }

        @available(*, deprecated, message: "Members connectorPolicyId have been deprecated")
        @inlinable
        public init(activatedAt: Date? = nil, advertisedProductId: String? = nil, arn: String? = nil, brand: String? = nil, classification: String? = nil, connectorDestinationId: String? = nil, connectorDeviceId: String? = nil, connectorPolicyId: String? = nil, createdAt: Date? = nil, credentialLockerId: String? = nil, id: String? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, parentControllerId: String? = nil, provisioningStatus: ProvisioningStatus? = nil, role: Role? = nil, serialNumber: String? = nil, updatedAt: Date? = nil) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDestinationId = connectorDestinationId
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = connectorPolicyId
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.id = id
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case activatedAt = "ActivatedAt"
            case advertisedProductId = "AdvertisedProductId"
            case arn = "Arn"
            case brand = "Brand"
            case classification = "Classification"
            case connectorDestinationId = "ConnectorDestinationId"
            case connectorDeviceId = "ConnectorDeviceId"
            case connectorPolicyId = "ConnectorPolicyId"
            case createdAt = "CreatedAt"
            case credentialLockerId = "CredentialLockerId"
            case id = "Id"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case parentControllerId = "ParentControllerId"
            case provisioningStatus = "ProvisioningStatus"
            case role = "Role"
            case serialNumber = "SerialNumber"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct MatterCapabilityReport: AWSEncodableShape {
        /// The endpoints used in the capability report.
        public let endpoints: [MatterCapabilityReportEndpoint]
        /// The numeric identifier of the node.
        public let nodeId: String?
        /// The version of the capability report.
        public let version: String

        @inlinable
        public init(endpoints: [MatterCapabilityReportEndpoint], nodeId: String? = nil, version: String) {
            self.endpoints = endpoints
            self.nodeId = nodeId
            self.version = version
        }

        public func validate(name: String) throws {
            try self.endpoints.forEach {
                try $0.validate(name: "\(name).endpoints[]")
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 50)
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 64)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
            try self.validate(self.nodeId, name: "nodeId", parent: name, pattern: "^[a-zA-Z0-9=_.,@\\+\\-/]+$")
            try self.validate(self.version, name: "version", parent: name, max: 10)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^1\\.0\\.0$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "endpoints"
            case nodeId = "nodeId"
            case version = "version"
        }
    }

    public struct MatterCapabilityReportAttribute: AWSEncodableShape {
        /// The id of the Matter attribute.
        public let id: String?
        /// Name for the Amazon Web Services Matter capability report attribute.
        public let name: String?
        /// Value for the Amazon Web Services Matter capability report attribute.
        public let value: AWSDocument?

        @inlinable
        public init(id: String? = nil, name: String? = nil, value: AWSDocument? = nil) {
            self.id = id
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 24)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case value = "value"
        }
    }

    public struct MatterCapabilityReportCluster: AWSEncodableShape {
        /// The attributes of the Amazon Web Services Matter capability report.
        public let attributes: [MatterCapabilityReportAttribute]?
        /// The commands used with the Amazon Web Services Matter capability report.
        public let commands: [String]?
        /// The events used with the Amazon Web Services Matter capability report.
        public let events: [String]?
        /// The fabric index for the Amazon Web Services Matter capability report.
        public let fabricIndex: Int?
        /// 32 bit-map used to indicate which features a cluster supports.
        public let featureMap: Int64?
        /// Matter clusters used in capability report.
        public let generatedCommands: [String]?
        /// The id of the Amazon Web Services Matter capability report cluster.
        public let id: String
        /// The capability name used in the Amazon Web Services Matter capability report.
        public let name: String?
        /// The id of the schema version.
        public let publicId: String?
        /// The id of the revision for the Amazon Web Services Matter capability report.
        public let revision: Int
        /// The spec version used in the Amazon Web Services Matter capability report.
        public let specVersion: String?

        @inlinable
        public init(attributes: [MatterCapabilityReportAttribute]? = nil, commands: [String]? = nil, events: [String]? = nil, fabricIndex: Int? = nil, featureMap: Int64? = nil, generatedCommands: [String]? = nil, id: String, name: String? = nil, publicId: String? = nil, revision: Int, specVersion: String? = nil) {
            self.attributes = attributes
            self.commands = commands
            self.events = events
            self.fabricIndex = fabricIndex
            self.featureMap = featureMap
            self.generatedCommands = generatedCommands
            self.id = id
            self.name = name
            self.publicId = publicId
            self.revision = revision
            self.specVersion = specVersion
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 100)
            try self.commands?.forEach {
                try validate($0, name: "commands[]", parent: name, max: 24)
                try validate($0, name: "commands[]", parent: name, min: 1)
                try validate($0, name: "commands[]", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            }
            try self.validate(self.commands, name: "commands", parent: name, max: 100)
            try self.events?.forEach {
                try validate($0, name: "events[]", parent: name, max: 24)
                try validate($0, name: "events[]", parent: name, min: 1)
                try validate($0, name: "events[]", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            }
            try self.validate(self.events, name: "events", parent: name, max: 100)
            try self.validate(self.fabricIndex, name: "fabricIndex", parent: name, max: 4096)
            try self.validate(self.fabricIndex, name: "fabricIndex", parent: name, min: 0)
            try self.validate(self.featureMap, name: "featureMap", parent: name, max: 4294967295)
            try self.validate(self.featureMap, name: "featureMap", parent: name, min: 0)
            try self.generatedCommands?.forEach {
                try validate($0, name: "generatedCommands[]", parent: name, max: 24)
                try validate($0, name: "generatedCommands[]", parent: name, min: 1)
                try validate($0, name: "generatedCommands[]", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            }
            try self.validate(self.generatedCommands, name: "generatedCommands", parent: name, max: 50)
            try self.validate(self.id, name: "id", parent: name, max: 24)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            try self.validate(self.publicId, name: "publicId", parent: name, max: 128)
            try self.validate(self.publicId, name: "publicId", parent: name, min: 7)
            try self.validate(self.publicId, name: "publicId", parent: name, pattern: "^[a-zA-Z0-9.]+@(\\d+\\.\\d+(\\.\\d+)?|\\$latest)$")
            try self.validate(self.revision, name: "revision", parent: name, max: 10)
            try self.validate(self.revision, name: "revision", parent: name, min: 1)
            try self.validate(self.specVersion, name: "specVersion", parent: name, max: 64)
            try self.validate(self.specVersion, name: "specVersion", parent: name, min: 1)
            try self.validate(self.specVersion, name: "specVersion", parent: name, pattern: "^\\d+\\.\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case commands = "commands"
            case events = "events"
            case fabricIndex = "fabricIndex"
            case featureMap = "featureMap"
            case generatedCommands = "generatedCommands"
            case id = "id"
            case name = "name"
            case publicId = "publicId"
            case revision = "revision"
            case specVersion = "specVersion"
        }
    }

    public struct MatterCapabilityReportEndpoint: AWSEncodableShape {
        /// Semantic information related to endpoint.
        public let clientClusters: [String]?
        /// Matter clusters used in capability report.
        public let clusters: [MatterCapabilityReportCluster]
        /// The type of device.
        public let deviceTypes: [String]
        /// The id of the Amazon Web Services Matter capability report endpoint.
        public let id: String
        /// Heirachy of child endpoints contained in the given endpoint.
        public let parts: [String]?
        /// Semantic information related to endpoint.
        public let semanticTags: [String]?

        @inlinable
        public init(clientClusters: [String]? = nil, clusters: [MatterCapabilityReportCluster], deviceTypes: [String], id: String, parts: [String]? = nil, semanticTags: [String]? = nil) {
            self.clientClusters = clientClusters
            self.clusters = clusters
            self.deviceTypes = deviceTypes
            self.id = id
            self.parts = parts
            self.semanticTags = semanticTags
        }

        public func validate(name: String) throws {
            try self.clientClusters?.forEach {
                try validate($0, name: "clientClusters[]", parent: name, max: 24)
                try validate($0, name: "clientClusters[]", parent: name, min: 1)
                try validate($0, name: "clientClusters[]", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            }
            try self.validate(self.clientClusters, name: "clientClusters", parent: name, max: 32)
            try self.clusters.forEach {
                try $0.validate(name: "\(name).clusters[]")
            }
            try self.validate(self.clusters, name: "clusters", parent: name, max: 50)
            try self.deviceTypes.forEach {
                try validate($0, name: "deviceTypes[]", parent: name, max: 256)
                try validate($0, name: "deviceTypes[]", parent: name, pattern: "^[a-zA-Z0-9=_. ,@\\+\\-/]+$")
            }
            try self.validate(self.deviceTypes, name: "deviceTypes", parent: name, max: 50)
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.parts?.forEach {
                try validate($0, name: "parts[]", parent: name, max: 64)
                try validate($0, name: "parts[]", parent: name, min: 1)
                try validate($0, name: "parts[]", parent: name, pattern: "^[0-9a-zA-Z]+$")
            }
            try self.validate(self.parts, name: "parts", parent: name, max: 32)
            try self.semanticTags?.forEach {
                try validate($0, name: "semanticTags[]", parent: name, max: 128)
                try validate($0, name: "semanticTags[]", parent: name, min: 1)
                try validate($0, name: "semanticTags[]", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            }
            try self.validate(self.semanticTags, name: "semanticTags", parent: name, max: 32)
        }

        private enum CodingKeys: String, CodingKey {
            case clientClusters = "clientClusters"
            case clusters = "clusters"
            case deviceTypes = "deviceTypes"
            case id = "id"
            case parts = "parts"
            case semanticTags = "semanticTags"
        }
    }

    public struct MatterCluster: AWSEncodableShape {
        /// The Matter attributes.
        public let attributes: AWSDocument?
        /// Describe the Matter commands with the Matter command identifier mapped to the command fields.
        public let commands: [String: AWSDocument]?
        /// Describe the Matter events with the Matter event identifier mapped to the event fields.
        public let events: [String: AWSDocument]?
        /// The cluster id.
        public let id: String?

        @inlinable
        public init(attributes: AWSDocument? = nil, commands: [String: AWSDocument]? = nil, events: [String: AWSDocument]? = nil, id: String? = nil) {
            self.attributes = attributes
            self.commands = commands
            self.events = events
            self.id = id
        }

        public func validate(name: String) throws {
            try self.commands?.forEach {
                try validate($0.key, name: "commands.key", parent: name, max: 24)
                try validate($0.key, name: "commands.key", parent: name, min: 1)
                try validate($0.key, name: "commands.key", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            }
            try self.validate(self.commands, name: "commands", parent: name, max: 5)
            try self.validate(self.commands, name: "commands", parent: name, min: 1)
            try self.events?.forEach {
                try validate($0.key, name: "events.key", parent: name, max: 24)
                try validate($0.key, name: "events.key", parent: name, min: 1)
                try validate($0.key, name: "events.key", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
            }
            try self.validate(self.events, name: "events", parent: name, max: 5)
            try self.validate(self.events, name: "events", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 24)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^0[xX][0-9a-fA-F]+$|^[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "attributes"
            case commands = "commands"
            case events = "events"
            case id = "id"
        }
    }

    public struct MatterEndpoint: AWSEncodableShape {
        /// A list of Matter clusters for a managed thing.
        public let clusters: [MatterCluster]?
        /// The Matter endpoint id.
        public let id: String?

        @inlinable
        public init(clusters: [MatterCluster]? = nil, id: String? = nil) {
            self.clusters = clusters
            self.id = id
        }

        public func validate(name: String) throws {
            try self.clusters?.forEach {
                try $0.validate(name: "\(name).clusters[]")
            }
            try self.validate(self.clusters, name: "clusters", parent: name, max: 5)
            try self.validate(self.clusters, name: "clusters", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusters = "clusters"
            case id = "id"
        }
    }

    public struct NotificationConfigurationSummary: AWSDecodableShape {
        /// The name of the destination for the notification configuration.
        public let destinationName: String?
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType?

        @inlinable
        public init(destinationName: String? = nil, eventType: EventType? = nil) {
            self.destinationName = destinationName
            self.eventType = eventType
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName = "DestinationName"
            case eventType = "EventType"
        }
    }

    public struct OAuthConfig: AWSEncodableShape & AWSDecodableShape {
        /// The authorization URL for the OAuth service, where users are directed to authenticate and authorize access.
        public let authUrl: String
        /// The URL where users are redirected after completing the OAuth authorization process.
        public let oAuthCompleteRedirectUrl: String?
        /// Configuration for proactively refreshing OAuth tokens before they expire.
        public let proactiveRefreshTokenRenewal: ProactiveRefreshTokenRenewal?
        /// The OAuth scopes requested during authorization, which define the permissions granted to the application.
        public let scope: String?
        /// The authentication scheme used when requesting tokens from the token endpoint.
        public let tokenEndpointAuthenticationScheme: TokenEndpointAuthenticationScheme
        /// The token URL for the OAuth service, where authorization codes are exchanged for access tokens.
        public let tokenUrl: String

        @inlinable
        public init(authUrl: String, oAuthCompleteRedirectUrl: String? = nil, proactiveRefreshTokenRenewal: ProactiveRefreshTokenRenewal? = nil, scope: String? = nil, tokenEndpointAuthenticationScheme: TokenEndpointAuthenticationScheme, tokenUrl: String) {
            self.authUrl = authUrl
            self.oAuthCompleteRedirectUrl = oAuthCompleteRedirectUrl
            self.proactiveRefreshTokenRenewal = proactiveRefreshTokenRenewal
            self.scope = scope
            self.tokenEndpointAuthenticationScheme = tokenEndpointAuthenticationScheme
            self.tokenUrl = tokenUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.authUrl, name: "authUrl", parent: name, max: 1024)
            try self.validate(self.authUrl, name: "authUrl", parent: name, min: 1)
            try self.validate(self.authUrl, name: "authUrl", parent: name, pattern: "^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}([-a-zA-Z0-9()@:%_\\+.~#?&\\/=]*)$")
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, max: 1024)
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, min: 1)
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, pattern: "^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}([-a-zA-Z0-9()@:%_\\+.~#?&\\/=]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case authUrl = "authUrl"
            case oAuthCompleteRedirectUrl = "oAuthCompleteRedirectUrl"
            case proactiveRefreshTokenRenewal = "proactiveRefreshTokenRenewal"
            case scope = "scope"
            case tokenEndpointAuthenticationScheme = "tokenEndpointAuthenticationScheme"
            case tokenUrl = "tokenUrl"
        }
    }

    public struct OAuthUpdate: AWSEncodableShape {
        /// The updated URL where users are redirected after completing the OAuth authorization process.
        public let oAuthCompleteRedirectUrl: String?
        /// Updated configuration for proactively refreshing OAuth tokens before they expire.
        public let proactiveRefreshTokenRenewal: ProactiveRefreshTokenRenewal?

        @inlinable
        public init(oAuthCompleteRedirectUrl: String? = nil, proactiveRefreshTokenRenewal: ProactiveRefreshTokenRenewal? = nil) {
            self.oAuthCompleteRedirectUrl = oAuthCompleteRedirectUrl
            self.proactiveRefreshTokenRenewal = proactiveRefreshTokenRenewal
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthCompleteRedirectUrl = "oAuthCompleteRedirectUrl"
            case proactiveRefreshTokenRenewal = "proactiveRefreshTokenRenewal"
        }
    }

    public struct OtaTaskAbortConfig: AWSEncodableShape & AWSDecodableShape {
        /// The list of criteria for the abort config.
        public let abortConfigCriteriaList: [AbortConfigCriteria]?

        @inlinable
        public init(abortConfigCriteriaList: [AbortConfigCriteria]? = nil) {
            self.abortConfigCriteriaList = abortConfigCriteriaList
        }

        public func validate(name: String) throws {
            try self.abortConfigCriteriaList?.forEach {
                try $0.validate(name: "\(name).abortConfigCriteriaList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case abortConfigCriteriaList = "AbortConfigCriteriaList"
        }
    }

    public struct OtaTaskConfigurationSummary: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
        public let createdAt: Date?
        /// The name of the over-the-air (OTA) task configuration.
        public let name: String?
        /// The id of the over-the-air (OTA) task configuration
        public let taskConfigurationId: String?

        @inlinable
        public init(createdAt: Date? = nil, name: String? = nil, taskConfigurationId: String? = nil) {
            self.createdAt = createdAt
            self.name = name
            self.taskConfigurationId = taskConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case name = "Name"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct OtaTaskExecutionRetryConfig: AWSEncodableShape & AWSDecodableShape {
        /// The list of retry config criteria.
        public let retryConfigCriteria: [RetryConfigCriteria]?

        @inlinable
        public init(retryConfigCriteria: [RetryConfigCriteria]? = nil) {
            self.retryConfigCriteria = retryConfigCriteria
        }

        public func validate(name: String) throws {
            try self.retryConfigCriteria?.forEach {
                try $0.validate(name: "\(name).retryConfigCriteria[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case retryConfigCriteria = "RetryConfigCriteria"
        }
    }

    public struct OtaTaskExecutionRolloutConfig: AWSEncodableShape & AWSDecodableShape {
        /// Structure representing exponential rate of rollout for an over-the-air (OTA) task.
        public let exponentialRolloutRate: ExponentialRolloutRate?
        /// The maximum number of things that will be notified of a pending task, per minute.
        public let maximumPerMinute: Int?

        @inlinable
        public init(exponentialRolloutRate: ExponentialRolloutRate? = nil, maximumPerMinute: Int? = nil) {
            self.exponentialRolloutRate = exponentialRolloutRate
            self.maximumPerMinute = maximumPerMinute
        }

        public func validate(name: String) throws {
            try self.exponentialRolloutRate?.validate(name: "\(name).exponentialRolloutRate")
            try self.validate(self.maximumPerMinute, name: "maximumPerMinute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exponentialRolloutRate = "ExponentialRolloutRate"
            case maximumPerMinute = "MaximumPerMinute"
        }
    }

    public struct OtaTaskExecutionSummaries: AWSDecodableShape {
        /// The id of a managed thing.
        public let managedThingId: String?
        /// Structure representing one over-the-air (OTA) task execution summary
        public let taskExecutionSummary: OtaTaskExecutionSummary?

        @inlinable
        public init(managedThingId: String? = nil, taskExecutionSummary: OtaTaskExecutionSummary? = nil) {
            self.managedThingId = managedThingId
            self.taskExecutionSummary = taskExecutionSummary
        }

        private enum CodingKeys: String, CodingKey {
            case managedThingId = "ManagedThingId"
            case taskExecutionSummary = "TaskExecutionSummary"
        }
    }

    public struct OtaTaskExecutionSummary: AWSDecodableShape {
        /// The execution number of the over-the-air (OTA) task execution summary.
        public let executionNumber: Int64?
        /// The timestamp value of when the over-the-air (OTA) task execution summary was last updated.
        public let lastUpdatedAt: Date?
        /// The timestamp value of when the over-the-air (OTA) task execution summary is targeted to start.
        public let queuedAt: Date?
        /// The number of retry attempts for starting the over-the-air (OTA) task execution summary after a failed attempt.
        public let retryAttempt: Int?
        /// The timestamp value of when the over-the-air (OTA) task execution summary started.
        public let startedAt: Date?
        /// The status of the over-the-air (OTA) task execution summary.
        public let status: OtaTaskExecutionStatus?

        @inlinable
        public init(executionNumber: Int64? = nil, lastUpdatedAt: Date? = nil, queuedAt: Date? = nil, retryAttempt: Int? = nil, startedAt: Date? = nil, status: OtaTaskExecutionStatus? = nil) {
            self.executionNumber = executionNumber
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.retryAttempt = retryAttempt
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case executionNumber = "ExecutionNumber"
            case lastUpdatedAt = "LastUpdatedAt"
            case queuedAt = "QueuedAt"
            case retryAttempt = "RetryAttempt"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct OtaTaskSchedulingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the end behavior for all task executions after a task reaches the selected endTime. If endTime is not selected when creating the task, then endBehavior does not apply.
        public let endBehavior: SchedulingConfigEndBehavior?
        /// The time an over-the-air (OTA) task will stop.
        public let endTime: String?
        /// Maintenance window list for over-the-air (OTA) task scheduling config.
        public let maintenanceWindows: [ScheduleMaintenanceWindow]?
        /// The time an over-the-air (OTA) task will start.
        public let startTime: String?

        @inlinable
        public init(endBehavior: SchedulingConfigEndBehavior? = nil, endTime: String? = nil, maintenanceWindows: [ScheduleMaintenanceWindow]? = nil, startTime: String? = nil) {
            self.endBehavior = endBehavior
            self.endTime = endTime
            self.maintenanceWindows = maintenanceWindows
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.maintenanceWindows?.forEach {
                try $0.validate(name: "\(name).maintenanceWindows[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case endBehavior = "EndBehavior"
            case endTime = "EndTime"
            case maintenanceWindows = "MaintenanceWindows"
            case startTime = "StartTime"
        }
    }

    public struct OtaTaskSummary: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task was created at.
        public let createdAt: Date?
        /// The timestamp value of when the over-the-air (OTA) task was last updated at.
        public let lastUpdatedAt: Date?
        /// The status of the over-the-air (OTA) task summary.
        public let status: OtaStatus?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
        public let taskArn: String?
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?
        /// The id of the over-the-air (OTA) task.
        public let taskId: String?

        @inlinable
        public init(createdAt: Date? = nil, lastUpdatedAt: Date? = nil, status: OtaStatus? = nil, taskArn: String? = nil, taskConfigurationId: String? = nil, taskId: String? = nil) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.taskArn = taskArn
            self.taskConfigurationId = taskConfigurationId
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case lastUpdatedAt = "LastUpdatedAt"
            case status = "Status"
            case taskArn = "TaskArn"
            case taskConfigurationId = "TaskConfigurationId"
            case taskId = "TaskId"
        }
    }

    public struct OtaTaskTimeoutConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the amount of time the device has to finish execution of this task. The timeout interval can be anywhere between 1 minute and 7 days.
        public let inProgressTimeoutInMinutes: Int64?

        @inlinable
        public init(inProgressTimeoutInMinutes: Int64? = nil) {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.inProgressTimeoutInMinutes, name: "inProgressTimeoutInMinutes", parent: name, max: 10080)
            try self.validate(self.inProgressTimeoutInMinutes, name: "inProgressTimeoutInMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case inProgressTimeoutInMinutes = "InProgressTimeoutInMinutes"
        }
    }

    public struct ProactiveRefreshTokenRenewal: AWSEncodableShape & AWSDecodableShape {
        /// The days before token expiration when the system should attempt to renew the token, specified in days.
        public let daysBeforeRenewal: Int?
        /// Indicates whether proactive refresh token renewal is enabled.
        public let enabled: Bool?

        @inlinable
        public init(daysBeforeRenewal: Int? = nil, enabled: Bool? = nil) {
            self.daysBeforeRenewal = daysBeforeRenewal
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case daysBeforeRenewal = "DaysBeforeRenewal"
            case enabled = "enabled"
        }
    }

    public struct ProvisioningProfileSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public let arn: String?
        /// The identifier of the provisioning profile.
        public let id: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil, provisioningType: ProvisioningType? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case provisioningType = "ProvisioningType"
        }
    }

    public struct PushConfig: AWSEncodableShape & AWSDecodableShape {
        /// Structure representing one abort config.
        public let abortConfig: OtaTaskAbortConfig?
        /// Structure representing one rollout config.
        public let rolloutConfig: OtaTaskExecutionRolloutConfig?
        /// Structure representing one timeout config.
        public let timeoutConfig: OtaTaskTimeoutConfig?

        @inlinable
        public init(abortConfig: OtaTaskAbortConfig? = nil, rolloutConfig: OtaTaskExecutionRolloutConfig? = nil, timeoutConfig: OtaTaskTimeoutConfig? = nil) {
            self.abortConfig = abortConfig
            self.rolloutConfig = rolloutConfig
            self.timeoutConfig = timeoutConfig
        }

        public func validate(name: String) throws {
            try self.abortConfig?.validate(name: "\(name).abortConfig")
            try self.rolloutConfig?.validate(name: "\(name).rolloutConfig")
            try self.timeoutConfig?.validate(name: "\(name).timeoutConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case abortConfig = "AbortConfig"
            case rolloutConfig = "RolloutConfig"
            case timeoutConfig = "TimeoutConfig"
        }
    }

    public struct PutDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 200)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[0-9a-zA-Z-]+:[0-9]+:key/[0-9a-zA-Z-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct PutDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// Provides the status of the default encryption configuration for an Amazon Web Services account.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct PutHubConfigurationRequest: AWSEncodableShape {
        /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
        public let hubTokenTimerExpirySettingInSeconds: Int64

        @inlinable
        public init(hubTokenTimerExpirySettingInSeconds: Int64) {
            self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.hubTokenTimerExpirySettingInSeconds, name: "hubTokenTimerExpirySettingInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hubTokenTimerExpirySettingInSeconds = "HubTokenTimerExpirySettingInSeconds"
        }
    }

    public struct PutHubConfigurationResponse: AWSDecodableShape {
        /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
        public let hubTokenTimerExpirySettingInSeconds: Int64?

        @inlinable
        public init(hubTokenTimerExpirySettingInSeconds: Int64? = nil) {
            self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case hubTokenTimerExpirySettingInSeconds = "HubTokenTimerExpirySettingInSeconds"
        }
    }

    public struct PutRuntimeLogConfigurationRequest: AWSEncodableShape {
        /// The id for a managed thing.
        public let managedThingId: String
        /// The runtime log configuration for a managed thing.
        public let runtimeLogConfigurations: RuntimeLogConfigurations

        @inlinable
        public init(managedThingId: String, runtimeLogConfigurations: RuntimeLogConfigurations) {
            self.managedThingId = managedThingId
            self.runtimeLogConfigurations = runtimeLogConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
            try container.encode(self.runtimeLogConfigurations, forKey: .runtimeLogConfigurations)
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeLogConfigurations = "RuntimeLogConfigurations"
        }
    }

    public struct RegisterAccountAssociationRequest: AWSEncodableShape {
        /// The identifier of the account association to register with the managed thing.
        public let accountAssociationId: String
        /// The identifier of the device discovery job associated with this registration.
        public let deviceDiscoveryId: String
        /// The identifier of the managed thing to register with the account association.
        public let managedThingId: String

        @inlinable
        public init(accountAssociationId: String, deviceDiscoveryId: String, managedThingId: String) {
            self.accountAssociationId = accountAssociationId
            self.deviceDiscoveryId = deviceDiscoveryId
            self.managedThingId = managedThingId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.deviceDiscoveryId, name: "deviceDiscoveryId", parent: name, max: 200)
            try self.validate(self.deviceDiscoveryId, name: "deviceDiscoveryId", parent: name, min: 1)
            try self.validate(self.deviceDiscoveryId, name: "deviceDiscoveryId", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case deviceDiscoveryId = "DeviceDiscoveryId"
            case managedThingId = "ManagedThingId"
        }
    }

    public struct RegisterAccountAssociationResponse: AWSDecodableShape {
        /// The identifier of the account association that was registered.
        public let accountAssociationId: String?
        /// The identifier of the device discovery job associated with this registration.
        public let deviceDiscoveryId: String?
        /// The identifier of the managed thing that was registered with the account association.
        public let managedThingId: String?

        @inlinable
        public init(accountAssociationId: String? = nil, deviceDiscoveryId: String? = nil, managedThingId: String? = nil) {
            self.accountAssociationId = accountAssociationId
            self.deviceDiscoveryId = deviceDiscoveryId
            self.managedThingId = managedThingId
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case deviceDiscoveryId = "DeviceDiscoveryId"
            case managedThingId = "ManagedThingId"
        }
    }

    public struct RegisterCustomEndpointRequest: AWSEncodableShape {
        public init() {}
    }

    public struct RegisterCustomEndpointResponse: AWSDecodableShape {
        /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
        public let endpointAddress: String

        @inlinable
        public init(endpointAddress: String) {
            self.endpointAddress = endpointAddress
        }

        private enum CodingKeys: String, CodingKey {
            case endpointAddress = "EndpointAddress"
        }
    }

    public struct ResetRuntimeLogConfigurationRequest: AWSEncodableShape {
        /// The id of a managed thing.
        public let managedThingId: String

        @inlinable
        public init(managedThingId: String) {
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// Id of the affected resource
        public let resourceId: String?
        /// Type of the affected resource
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct RetryConfigCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Over-the-air (OTA) retry criteria failure type.
        public let failureType: RetryCriteriaFailureType?
        /// The number of retries allowed for a failure type for the over-the-air (OTA) task.
        public let minNumberOfRetries: Int?

        @inlinable
        public init(failureType: RetryCriteriaFailureType? = nil, minNumberOfRetries: Int? = nil) {
            self.failureType = failureType
            self.minNumberOfRetries = minNumberOfRetries
        }

        public func validate(name: String) throws {
            try self.validate(self.minNumberOfRetries, name: "minNumberOfRetries", parent: name, max: 10)
            try self.validate(self.minNumberOfRetries, name: "minNumberOfRetries", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case failureType = "FailureType"
            case minNumberOfRetries = "MinNumberOfRetries"
        }
    }

    public struct RolloutRateIncreaseCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The threshold for number of notified things that will initiate the increase in rate of rollout.
        public let numberOfNotifiedThings: Int?
        /// The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        public let numberOfSucceededThings: Int?

        @inlinable
        public init(numberOfNotifiedThings: Int? = nil, numberOfSucceededThings: Int? = nil) {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfNotifiedThings, name: "numberOfNotifiedThings", parent: name, max: 100)
            try self.validate(self.numberOfNotifiedThings, name: "numberOfNotifiedThings", parent: name, min: 1)
            try self.validate(self.numberOfSucceededThings, name: "numberOfSucceededThings", parent: name, max: 100)
            try self.validate(self.numberOfSucceededThings, name: "numberOfSucceededThings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfNotifiedThings = "numberOfNotifiedThings"
            case numberOfSucceededThings = "numberOfSucceededThings"
        }
    }

    public struct RuntimeLogConfigurations: AWSEncodableShape & AWSDecodableShape {
        /// Configuration to enable or disable deleting of runtime logs in the device once uploaded to the cloud.
        public let deleteLocalStoreAfterUpload: Bool?
        /// Configuration to set the maximum bytes of runtime logs that can be stored on the device before the oldest logs are deleted or overwritten.
        public let localStoreFileRotationMaxBytes: Int?
        /// Configuration to set the maximum number of runtime log files that can be stored on the device before the oldest files are deleted or overwritten.
        public let localStoreFileRotationMaxFiles: Int?
        /// Configuration of where to store runtime logs in the device.
        public let localStoreLocation: String?
        /// The different log levels available for configuration.
        public let logFlushLevel: LogLevel?
        /// The different log levels available for configuration.
        public let logLevel: LogLevel?
        /// Configuration to enable or disable uploading of runtime logs to the cloud.
        public let uploadLog: Bool?
        /// Configuration to set the time interval in minutes between each batch of runtime logs that the device uploads to the cloud.
        public let uploadPeriodMinutes: Int?

        @inlinable
        public init(deleteLocalStoreAfterUpload: Bool? = nil, localStoreFileRotationMaxBytes: Int? = nil, localStoreFileRotationMaxFiles: Int? = nil, localStoreLocation: String? = nil, logFlushLevel: LogLevel? = nil, logLevel: LogLevel? = nil, uploadLog: Bool? = nil, uploadPeriodMinutes: Int? = nil) {
            self.deleteLocalStoreAfterUpload = deleteLocalStoreAfterUpload
            self.localStoreFileRotationMaxBytes = localStoreFileRotationMaxBytes
            self.localStoreFileRotationMaxFiles = localStoreFileRotationMaxFiles
            self.localStoreLocation = localStoreLocation
            self.logFlushLevel = logFlushLevel
            self.logLevel = logLevel
            self.uploadLog = uploadLog
            self.uploadPeriodMinutes = uploadPeriodMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case deleteLocalStoreAfterUpload = "DeleteLocalStoreAfterUpload"
            case localStoreFileRotationMaxBytes = "LocalStoreFileRotationMaxBytes"
            case localStoreFileRotationMaxFiles = "LocalStoreFileRotationMaxFiles"
            case localStoreLocation = "LocalStoreLocation"
            case logFlushLevel = "LogFlushLevel"
            case logLevel = "LogLevel"
            case uploadLog = "UploadLog"
            case uploadPeriodMinutes = "UploadPeriodMinutes"
        }
    }

    public struct ScheduleMaintenanceWindow: AWSEncodableShape & AWSDecodableShape {
        /// Displays the duration of the next maintenance window.
        public let durationInMinutes: Int?
        /// Displays the start time of the next maintenance window.
        public let startTime: String?

        @inlinable
        public init(durationInMinutes: Int? = nil, startTime: String? = nil) {
            self.durationInMinutes = durationInMinutes
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.durationInMinutes, name: "durationInMinutes", parent: name, max: 1430)
            try self.validate(self.durationInMinutes, name: "durationInMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case durationInMinutes = "DurationInMinutes"
            case startTime = "StartTime"
        }
    }

    public struct SchemaVersionListItem: AWSDecodableShape {
        /// A description of the schema version.
        public let description: String?
        /// The name of the schema version.
        public let namespace: String?
        /// The identifier of the schema version.
        public let schemaId: String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public let semanticVersion: String?
        /// The type of schema version.
        public let type: SchemaVersionType?
        /// The visibility of the schema version.
        public let visibility: SchemaVersionVisibility?

        @inlinable
        public init(description: String? = nil, namespace: String? = nil, schemaId: String? = nil, semanticVersion: String? = nil, type: SchemaVersionType? = nil, visibility: SchemaVersionVisibility? = nil) {
            self.description = description
            self.namespace = namespace
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case namespace = "Namespace"
            case schemaId = "SchemaId"
            case semanticVersion = "SemanticVersion"
            case type = "Type"
            case visibility = "Visibility"
        }
    }

    public struct SecretsManager: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the AWS Secrets Manager secret.
        public let arn: String
        /// The version ID of the AWS Secrets Manager secret.
        public let versionId: String

        @inlinable
        public init(arn: String, versionId: String) {
            self.arn = arn
            self.versionId = versionId
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:aws:secretsmanager:[0-9a-zA-Z-]{1,32}:\\d{12}:secret:[A-Za-z0-9/_+=.@-]{8,520}$")
            try self.validate(self.versionId, name: "versionId", parent: name, max: 64)
            try self.validate(self.versionId, name: "versionId", parent: name, min: 32)
            try self.validate(self.versionId, name: "versionId", parent: name, pattern: "^[a-zA-Z0-9-_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case versionId = "versionId"
        }
    }

    public struct SendConnectorEventRequest: AWSEncodableShape {
        /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).  This parameter is used for cloud-to-cloud devices only.
        public let connectorDeviceId: String?
        /// The id of the connector between the third-party cloud provider and IoT managed integrations.
        public let connectorId: String
        /// The id for the device discovery job.
        public let deviceDiscoveryId: String?
        /// The list of devices.
        public let devices: [Device]?
        /// The device endpoint.
        public let matterEndpoint: MatterEndpoint?
        /// The device state change event payload. This parameter will include the following three fields:    uri: schema auc://&lt;PARTNER-DEVICE-ID&gt;/ResourcePath (The Resourcepath corresponds to an OCF resource.)    op: For device state changes, this field must populate as n+d.    cn: The content depends on the OCF resource referenced in ResourcePath.
        public let message: String?
        /// The Open Connectivity Foundation (OCF) operation requested to be performed on the managed thing.  The field op can have a value of "I" or "U". The field "cn" will contain the capability types.
        public let operation: ConnectorEventOperation
        /// The Open Connectivity Foundation (OCF) security specification version for the operation being requested on the managed thing. For more information, see OCF Security Specification.
        public let operationVersion: String?
        /// The status code of the Open Connectivity Foundation (OCF) operation being performed on the managed thing.
        public let statusCode: Int?
        /// The trace request identifier used to correlate a command request and response. This is specified by the device owner, but will be generated by IoT managed integrations if not provided by the device owner.
        public let traceId: String?
        /// The id of the third-party cloud provider.
        public let userId: String?

        @inlinable
        public init(connectorDeviceId: String? = nil, connectorId: String, deviceDiscoveryId: String? = nil, devices: [Device]? = nil, matterEndpoint: MatterEndpoint? = nil, message: String? = nil, operation: ConnectorEventOperation, operationVersion: String? = nil, statusCode: Int? = nil, traceId: String? = nil, userId: String? = nil) {
            self.connectorDeviceId = connectorDeviceId
            self.connectorId = connectorId
            self.deviceDiscoveryId = deviceDiscoveryId
            self.devices = devices
            self.matterEndpoint = matterEndpoint
            self.message = message
            self.operation = operation
            self.operationVersion = operationVersion
            self.statusCode = statusCode
            self.traceId = traceId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.connectorDeviceId, forKey: .connectorDeviceId)
            request.encodePath(self.connectorId, key: "ConnectorId")
            try container.encodeIfPresent(self.deviceDiscoveryId, forKey: .deviceDiscoveryId)
            try container.encodeIfPresent(self.devices, forKey: .devices)
            try container.encodeIfPresent(self.matterEndpoint, forKey: .matterEndpoint)
            try container.encodeIfPresent(self.message, forKey: .message)
            try container.encode(self.operation, forKey: .operation)
            try container.encodeIfPresent(self.operationVersion, forKey: .operationVersion)
            try container.encodeIfPresent(self.statusCode, forKey: .statusCode)
            try container.encodeIfPresent(self.traceId, forKey: .traceId)
            try container.encodeIfPresent(self.userId, forKey: .userId)
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorDeviceId, name: "connectorDeviceId", parent: name, max: 256)
            try self.validate(self.connectorDeviceId, name: "connectorDeviceId", parent: name, min: 1)
            try self.validate(self.connectorDeviceId, name: "connectorDeviceId", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.connectorId, name: "connectorId", parent: name, max: 64)
            try self.validate(self.connectorId, name: "connectorId", parent: name, min: 1)
            try self.validate(self.connectorId, name: "connectorId", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.deviceDiscoveryId, name: "deviceDiscoveryId", parent: name, max: 200)
            try self.validate(self.deviceDiscoveryId, name: "deviceDiscoveryId", parent: name, min: 1)
            try self.validate(self.deviceDiscoveryId, name: "deviceDiscoveryId", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.devices?.forEach {
                try $0.validate(name: "\(name).devices[]")
            }
            try self.matterEndpoint?.validate(name: "\(name).matterEndpoint")
            try self.validate(self.message, name: "message", parent: name, max: 256)
            try self.validate(self.message, name: "message", parent: name, min: 1)
            try self.validate(self.message, name: "message", parent: name, pattern: "^[\\sa-zA-Z0-9_.,@-]+$")
            try self.validate(self.operationVersion, name: "operationVersion", parent: name, max: 6)
            try self.validate(self.operationVersion, name: "operationVersion", parent: name, min: 1)
            try self.validate(self.operationVersion, name: "operationVersion", parent: name, pattern: "^[0-9.]+$")
            try self.validate(self.statusCode, name: "statusCode", parent: name, max: 550)
            try self.validate(self.statusCode, name: "statusCode", parent: name, min: 100)
            try self.validate(self.traceId, name: "traceId", parent: name, max: 128)
            try self.validate(self.traceId, name: "traceId", parent: name, min: 1)
            try self.validate(self.traceId, name: "traceId", parent: name, pattern: "^[a-zA-Z0-9:=_-]+$")
            try self.validate(self.userId, name: "userId", parent: name, max: 64)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorDeviceId = "ConnectorDeviceId"
            case deviceDiscoveryId = "DeviceDiscoveryId"
            case devices = "Devices"
            case matterEndpoint = "MatterEndpoint"
            case message = "Message"
            case operation = "Operation"
            case operationVersion = "OperationVersion"
            case statusCode = "StatusCode"
            case traceId = "TraceId"
            case userId = "UserId"
        }
    }

    public struct SendConnectorEventResponse: AWSDecodableShape {
        /// The id of the connector between the third-party cloud provider and IoT managed integrations.
        public let connectorId: String

        @inlinable
        public init(connectorId: String) {
            self.connectorId = connectorId
        }

        private enum CodingKeys: String, CodingKey {
            case connectorId = "ConnectorId"
        }
    }

    public struct SendManagedThingCommandRequest: AWSEncodableShape {
        /// The identifier of the account association to use when sending a command to a managed thing.
        public let accountAssociationId: String?
        /// The ID tracking the current discovery process for one connector association.
        public let connectorAssociationId: String?
        /// The device endpoint.
        public let endpoints: [CommandEndpoint]
        /// The id of the device.
        public let managedThingId: String

        @inlinable
        public init(accountAssociationId: String? = nil, endpoints: [CommandEndpoint], managedThingId: String) {
            self.accountAssociationId = accountAssociationId
            self.connectorAssociationId = nil
            self.endpoints = endpoints
            self.managedThingId = managedThingId
        }

        @available(*, deprecated, message: "Members connectorAssociationId have been deprecated")
        @inlinable
        public init(accountAssociationId: String? = nil, connectorAssociationId: String? = nil, endpoints: [CommandEndpoint], managedThingId: String) {
            self.accountAssociationId = accountAssociationId
            self.connectorAssociationId = connectorAssociationId
            self.endpoints = endpoints
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accountAssociationId, forKey: .accountAssociationId)
            try container.encodeIfPresent(self.connectorAssociationId, forKey: .connectorAssociationId)
            try container.encode(self.endpoints, forKey: .endpoints)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.connectorAssociationId, name: "connectorAssociationId", parent: name, max: 64)
            try self.validate(self.connectorAssociationId, name: "connectorAssociationId", parent: name, min: 1)
            try self.validate(self.connectorAssociationId, name: "connectorAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.endpoints.forEach {
                try $0.validate(name: "\(name).endpoints[]")
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 5)
            try self.validate(self.endpoints, name: "endpoints", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case connectorAssociationId = "ConnectorAssociationId"
            case endpoints = "Endpoints"
        }
    }

    public struct SendManagedThingCommandResponse: AWSDecodableShape {
        /// The trace request identifier. This is specified by the device owner, but will be generated by IoT managed integrations if not provided by the device owner.
        public let traceId: String?

        @inlinable
        public init(traceId: String? = nil) {
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case traceId = "TraceId"
        }
    }

    public struct StartAccountAssociationRefreshRequest: AWSEncodableShape {
        /// The unique identifier of the account association to refresh.
        public let accountAssociationId: String

        @inlinable
        public init(accountAssociationId: String) {
            self.accountAssociationId = accountAssociationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountAssociationId, key: "AccountAssociationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartAccountAssociationRefreshResponse: AWSDecodableShape {
        /// Third-party IoT platform OAuth authorization server URL with all required parameters to perform end-user authentication during the refresh process.
        public let oAuthAuthorizationUrl: String

        @inlinable
        public init(oAuthAuthorizationUrl: String) {
            self.oAuthAuthorizationUrl = oAuthAuthorizationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case oAuthAuthorizationUrl = "OAuthAuthorizationUrl"
        }
    }

    public struct StartDeviceDiscoveryRequest: AWSEncodableShape {
        /// The identifier of the cloud-to-cloud account association to use for discovery of third-party devices.
        public let accountAssociationId: String?
        /// The authentication material required to start the local device discovery job request.
        public let authenticationMaterial: String?
        /// The type of authentication material used for device discovery jobs.
        public let authenticationMaterialType: DiscoveryAuthMaterialType?
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The id of the connector association.
        public let connectorAssociationIdentifier: String?
        /// The id of the end-user's IoT hub.
        public let controllerIdentifier: String?
        /// Additional protocol-specific details required for device discovery, which vary based on the discovery type.  For a DiscoveryType of CUSTOM, the string-to-string map must have a key value of Name set to a non-empty-string.
        public let customProtocolDetail: [String: String]?
        /// The discovery type supporting the type of device to be discovered in the device discovery task request.
        public let discoveryType: DiscoveryType
        /// A set of key/value pairs that are used to manage the device discovery request.
        public let tags: [String: String]?

        @inlinable
        public init(accountAssociationId: String? = nil, authenticationMaterial: String? = nil, authenticationMaterialType: DiscoveryAuthMaterialType? = nil, clientToken: String? = nil, controllerIdentifier: String? = nil, customProtocolDetail: [String: String]? = nil, discoveryType: DiscoveryType) {
            self.accountAssociationId = accountAssociationId
            self.authenticationMaterial = authenticationMaterial
            self.authenticationMaterialType = authenticationMaterialType
            self.clientToken = clientToken
            self.connectorAssociationIdentifier = nil
            self.controllerIdentifier = controllerIdentifier
            self.customProtocolDetail = customProtocolDetail
            self.discoveryType = discoveryType
            self.tags = nil
        }

        @available(*, deprecated, message: "Members connectorAssociationIdentifier, tags have been deprecated")
        @inlinable
        public init(accountAssociationId: String? = nil, authenticationMaterial: String? = nil, authenticationMaterialType: DiscoveryAuthMaterialType? = nil, clientToken: String? = nil, connectorAssociationIdentifier: String? = nil, controllerIdentifier: String? = nil, customProtocolDetail: [String: String]? = nil, discoveryType: DiscoveryType, tags: [String: String]? = nil) {
            self.accountAssociationId = accountAssociationId
            self.authenticationMaterial = authenticationMaterial
            self.authenticationMaterialType = authenticationMaterialType
            self.clientToken = clientToken
            self.connectorAssociationIdentifier = connectorAssociationIdentifier
            self.controllerIdentifier = controllerIdentifier
            self.customProtocolDetail = customProtocolDetail
            self.discoveryType = discoveryType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, max: 64)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, min: 1)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, pattern: "^[0-9A-Za-z_\\-\\+=\\/:; ]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.connectorAssociationIdentifier, name: "connectorAssociationIdentifier", parent: name, max: 64)
            try self.validate(self.connectorAssociationIdentifier, name: "connectorAssociationIdentifier", parent: name, min: 1)
            try self.validate(self.connectorAssociationIdentifier, name: "connectorAssociationIdentifier", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.controllerIdentifier, name: "controllerIdentifier", parent: name, max: 64)
            try self.validate(self.controllerIdentifier, name: "controllerIdentifier", parent: name, min: 1)
            try self.validate(self.controllerIdentifier, name: "controllerIdentifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
            try self.customProtocolDetail?.forEach {
                try validate($0.key, name: "customProtocolDetail.key", parent: name, max: 256)
                try validate($0.key, name: "customProtocolDetail.key", parent: name, min: 1)
                try validate($0.key, name: "customProtocolDetail.key", parent: name, pattern: "^[a-zA-Z0-9 _.-]+$")
                try validate($0.value, name: "customProtocolDetail[\"\($0.key)\"]", parent: name, max: 512)
                try validate($0.value, name: "customProtocolDetail[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "customProtocolDetail[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9 _.{}:\"-]+$")
            }
            try self.validate(self.customProtocolDetail, name: "customProtocolDetail", parent: name, max: 50)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountAssociationId = "AccountAssociationId"
            case authenticationMaterial = "AuthenticationMaterial"
            case authenticationMaterialType = "AuthenticationMaterialType"
            case clientToken = "ClientToken"
            case connectorAssociationIdentifier = "ConnectorAssociationIdentifier"
            case controllerIdentifier = "ControllerIdentifier"
            case customProtocolDetail = "CustomProtocolDetail"
            case discoveryType = "DiscoveryType"
            case tags = "Tags"
        }
    }

    public struct StartDeviceDiscoveryResponse: AWSDecodableShape {
        /// The id of the device discovery job request.
        public let id: String?
        /// The timestamp value for the start time of the device discovery.
        public let startedAt: Date?

        @inlinable
        public init(id: String? = nil, startedAt: Date? = nil) {
            self.id = id
            self.startedAt = startedAt
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case startedAt = "StartedAt"
        }
    }

    public struct StateCapability: AWSDecodableShape {
        /// The id of the managed thing in the capability report.
        public let id: String
        /// Name for the Amazon Web Services capability.
        public let name: String
        /// Describe the command capability with the properties it supports.
        public let properties: AWSDocument?
        /// Version for the Amazon Web Services capability.
        public let version: String

        @inlinable
        public init(id: String, name: String, properties: AWSDocument? = nil, version: String) {
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case properties = "properties"
            case version = "version"
        }
    }

    public struct StateEndpoint: AWSDecodableShape {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for the reporting state.
        public let capabilities: [StateCapability]
        /// Numeric identifier of the endpoint
        public let endpointId: String

        @inlinable
        public init(capabilities: [StateCapability], endpointId: String) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case endpointId = "endpointId"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to which to add tags.
        public let resourceArn: String
        /// A set of key/value pairs that are used to manage the resource
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:iotmanagedintegrations:[0-9a-zA-Z-]+:[0-9]+:(managed-thing|provisioning-profile|ota-task|credential-locker|account-association)/[0-9a-zA-Z]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskProcessingDetails: AWSDecodableShape {
        /// The number of canceled things in an over-the-air (OTA) task.
        public let numberOfCanceledThings: Int?
        /// The number of failed things in an over-the-air (OTA) task.
        public let numberOfFailedThings: Int?
        /// The number of in progress things in an over-the-air (OTA) task.
        public let numberOfInProgressThings: Int?
        /// The number of queued things in an over-the-air (OTA) task.
        public let numberOfQueuedThings: Int?
        /// The number of rejected things in an over-the-air (OTA) task.
        public let numberOfRejectedThings: Int?
        /// The number of removed things in an over-the-air (OTA) task.
        public let numberOfRemovedThings: Int?
        /// The number of succeeded things in an over-the-air (OTA) task.
        public let numberOfSucceededThings: Int?
        /// The number of timed out things in an over-the-air (OTA) task.
        public let numberOfTimedOutThings: Int?
        /// The targets of the over-the-air (OTA) task.
        public let processingTargets: [String]?

        @inlinable
        public init(numberOfCanceledThings: Int? = nil, numberOfFailedThings: Int? = nil, numberOfInProgressThings: Int? = nil, numberOfQueuedThings: Int? = nil, numberOfRejectedThings: Int? = nil, numberOfRemovedThings: Int? = nil, numberOfSucceededThings: Int? = nil, numberOfTimedOutThings: Int? = nil, processingTargets: [String]? = nil) {
            self.numberOfCanceledThings = numberOfCanceledThings
            self.numberOfFailedThings = numberOfFailedThings
            self.numberOfInProgressThings = numberOfInProgressThings
            self.numberOfQueuedThings = numberOfQueuedThings
            self.numberOfRejectedThings = numberOfRejectedThings
            self.numberOfRemovedThings = numberOfRemovedThings
            self.numberOfSucceededThings = numberOfSucceededThings
            self.numberOfTimedOutThings = numberOfTimedOutThings
            self.processingTargets = processingTargets
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfCanceledThings = "NumberOfCanceledThings"
            case numberOfFailedThings = "NumberOfFailedThings"
            case numberOfInProgressThings = "NumberOfInProgressThings"
            case numberOfQueuedThings = "numberOfQueuedThings"
            case numberOfRejectedThings = "numberOfRejectedThings"
            case numberOfRemovedThings = "numberOfRemovedThings"
            case numberOfSucceededThings = "numberOfSucceededThings"
            case numberOfTimedOutThings = "numberOfTimedOutThings"
            case processingTargets = "processingTargets"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the resource to which to add tags.
        public let resourceArn: String
        /// A list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:iotmanagedintegrations:[0-9a-zA-Z-]+:[0-9]+:(managed-thing|provisioning-profile|ota-task|credential-locker|account-association)/[0-9a-zA-Z]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccountAssociationRequest: AWSEncodableShape {
        /// The unique identifier of the account association to update.
        public let accountAssociationId: String
        /// The new description to assign to the account association.
        public let description: String?
        /// The new name to assign to the account association.
        public let name: String?

        @inlinable
        public init(accountAssociationId: String, description: String? = nil, name: String? = nil) {
            self.accountAssociationId = accountAssociationId
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountAssociationId, key: "AccountAssociationId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, max: 64)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, min: 1)
            try self.validate(self.accountAssociationId, name: "accountAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateCloudConnectorRequest: AWSEncodableShape {
        /// The new description to assign to the cloud connector.
        public let description: String?
        /// The unique identifier of the cloud connector to update.
        public let identifier: String
        /// The new display name to assign to the cloud connector.
        public let name: String?

        @inlinable
        public init(description: String? = nil, identifier: String, name: String? = nil) {
            self.description = description
            self.identifier = identifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateConnectorDestinationRequest: AWSEncodableShape {
        /// The updated authentication configuration details for the connector destination.
        public let authConfig: AuthConfigUpdate?
        /// The new authentication type to use for the connector destination.
        public let authType: AuthType?
        /// The new description to assign to the connector destination.
        public let description: String?
        /// The unique identifier of the connector destination to update.
        public let identifier: String
        /// The new display name to assign to the connector destination.
        public let name: String?
        /// The updated AWS Secrets Manager configuration for the connector destination.
        public let secretsManager: SecretsManager?

        @inlinable
        public init(authConfig: AuthConfigUpdate? = nil, authType: AuthType? = nil, description: String? = nil, identifier: String, name: String? = nil, secretsManager: SecretsManager? = nil) {
            self.authConfig = authConfig
            self.authType = authType
            self.description = description
            self.identifier = identifier
            self.name = name
            self.secretsManager = secretsManager
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authConfig, forKey: .authConfig)
            try container.encodeIfPresent(self.authType, forKey: .authType)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.secretsManager, forKey: .secretsManager)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.secretsManager?.validate(name: "\(name).secretsManager")
        }

        private enum CodingKeys: String, CodingKey {
            case authConfig = "AuthConfig"
            case authType = "AuthType"
            case description = "Description"
            case name = "Name"
            case secretsManager = "SecretsManager"
        }
    }

    public struct UpdateDestinationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String?
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String
        /// The Amazon Resource Name (ARN) of the delivery destination role.
        public let roleArn: String?

        @inlinable
        public init(deliveryDestinationArn: String? = nil, deliveryDestinationType: DeliveryDestinationType? = nil, description: String? = nil, name: String, roleArn: String? = nil) {
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deliveryDestinationArn, forKey: .deliveryDestinationArn)
            try container.encodeIfPresent(self.deliveryDestinationType, forKey: .deliveryDestinationType)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, max: 2048)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, min: 20)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, pattern: "^arn:aws:[0-9a-zA-Z]+:[0-9a-zA-Z-]+:[0-9]+:[0-9a-zA-Z]+/[0-9a-zA-Z._-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case roleArn = "RoleArn"
        }
    }

    public struct UpdateEventLogConfigurationRequest: AWSEncodableShape {
        /// The log level for the event in terms of severity.
        public let eventLogLevel: LogLevel
        /// The log configuration id.
        public let id: String

        @inlinable
        public init(eventLogLevel: LogLevel, id: String) {
            self.eventLogLevel = eventLogLevel
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.eventLogLevel, forKey: .eventLogLevel)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 200)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogLevel = "EventLogLevel"
        }
    }

    public struct UpdateManagedThingRequest: AWSEncodableShape {
        /// The brand of the device.
        public let brand: String?
        /// The capabilities of the device such as light bulb.
        public let capabilities: String?
        /// A report of the capabilities for the managed thing.
        public let capabilityReport: CapabilityReport?
        /// The updated capability schemas that define the functionality and features supported by the managed thing.
        public let capabilitySchemas: [CapabilitySchemaItem]?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// The identifier of the credential for the managed thing.
        public let credentialLockerId: String?
        /// The network mode for the hub-connected device.
        public let hubNetworkMode: HubNetworkMode?
        /// The id of the managed thing.
        public let identifier: String
        /// The metadata for the managed thing.
        public let metaData: [String: String]?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// The serial number of the device.
        public let serialNumber: String?

        @inlinable
        public init(brand: String? = nil, capabilities: String? = nil, capabilityReport: CapabilityReport? = nil, capabilitySchemas: [CapabilitySchemaItem]? = nil, classification: String? = nil, credentialLockerId: String? = nil, hubNetworkMode: HubNetworkMode? = nil, identifier: String, metaData: [String: String]? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, serialNumber: String? = nil) {
            self.brand = brand
            self.capabilities = capabilities
            self.capabilityReport = capabilityReport
            self.capabilitySchemas = capabilitySchemas
            self.classification = classification
            self.credentialLockerId = credentialLockerId
            self.hubNetworkMode = hubNetworkMode
            self.identifier = identifier
            self.metaData = metaData
            self.model = model
            self.name = name
            self.owner = owner
            self.serialNumber = serialNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.brand, forKey: .brand)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encodeIfPresent(self.capabilityReport, forKey: .capabilityReport)
            try container.encodeIfPresent(self.capabilitySchemas, forKey: .capabilitySchemas)
            try container.encodeIfPresent(self.classification, forKey: .classification)
            try container.encodeIfPresent(self.credentialLockerId, forKey: .credentialLockerId)
            try container.encodeIfPresent(self.hubNetworkMode, forKey: .hubNetworkMode)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.metaData, forKey: .metaData)
            try container.encodeIfPresent(self.model, forKey: .model)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.owner, forKey: .owner)
            try container.encodeIfPresent(self.serialNumber, forKey: .serialNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.brand, name: "brand", parent: name, max: 128)
            try self.validate(self.brand, name: "brand", parent: name, min: 1)
            try self.validate(self.brand, name: "brand", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 65535)
            try self.validate(self.capabilities, name: "capabilities", parent: name, min: 1)
            try self.validate(self.capabilities, name: "capabilities", parent: name, pattern: "^[a-zA-Z0-9\\s'\\x{0022},.:\\\\\\/{$}\\[\\]=_\\-\\+]+$")
            try self.capabilityReport?.validate(name: "\(name).capabilityReport")
            try self.capabilitySchemas?.forEach {
                try $0.validate(name: "\(name).capabilitySchemas[]")
            }
            try self.validate(self.capabilitySchemas, name: "capabilitySchemas", parent: name, max: 40)
            try self.validate(self.classification, name: "classification", parent: name, max: 64)
            try self.validate(self.classification, name: "classification", parent: name, min: 1)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, max: 64)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, min: 1)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
            try self.metaData?.forEach {
                try validate($0.key, name: "metaData.key", parent: name, max: 128)
                try validate($0.key, name: "metaData.key", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]+")
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]*")
            }
            try self.validate(self.metaData, name: "metaData", parent: name, max: 50)
            try self.validate(self.metaData, name: "metaData", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, max: 128)
            try self.validate(self.model, name: "model", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.validate(self.owner, name: "owner", parent: name, max: 64)
            try self.validate(self.owner, name: "owner", parent: name, min: 1)
            try self.validate(self.owner, name: "owner", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 128)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, min: 1)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case brand = "Brand"
            case capabilities = "Capabilities"
            case capabilityReport = "CapabilityReport"
            case capabilitySchemas = "CapabilitySchemas"
            case classification = "Classification"
            case credentialLockerId = "CredentialLockerId"
            case hubNetworkMode = "HubNetworkMode"
            case metaData = "MetaData"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case serialNumber = "SerialNumber"
        }
    }

    public struct UpdateNotificationConfigurationRequest: AWSEncodableShape {
        /// The name of the destination for the notification configuration.
        public let destinationName: String
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType

        @inlinable
        public init(destinationName: String, eventType: EventType) {
            self.destinationName = destinationName
            self.eventType = eventType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destinationName, forKey: .destinationName)
            request.encodePath(self.eventType, key: "EventType")
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 1)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName = "DestinationName"
        }
    }

    public struct UpdateOtaTaskRequest: AWSEncodableShape {
        /// The description of the over-the-air (OTA) task.
        public let description: String?
        /// The over-the-air (OTA) task id.
        public let identifier: String
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?

        @inlinable
        public init(description: String? = nil, identifier: String, taskConfigurationId: String? = nil) {
            self.description = description
            self.identifier = identifier
            self.taskConfigurationId = taskConfigurationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.taskConfigurationId, forKey: .taskConfigurationId)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, max: 64)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, min: 1)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTManagedIntegrations
public struct IoTManagedIntegrationsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalFailureException = "InternalFailureException"
        case internalServerException = "InternalServerException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTManagedIntegrations
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User is not authorized.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There is a conflict with the request.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error has occurred.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// Internal error from the service that indicates an unexpected error or that the service is unavailable.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request is not valid.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The request exceeds a service limit or quota. Adjust your request parameters and try again.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded for this request.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The service is temporarily unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The rate exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You are not authorized to perform this operation.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// A validation error occurred when performing the API request.
    public static var validationException: Self { .init(.validationException) }
}

extension IoTManagedIntegrationsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ResourceNotFoundException": IoTManagedIntegrations.ResourceNotFoundException.self
    ]
}

extension IoTManagedIntegrationsErrorType: Equatable {
    public static func == (lhs: IoTManagedIntegrationsErrorType, rhs: IoTManagedIntegrationsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTManagedIntegrationsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
