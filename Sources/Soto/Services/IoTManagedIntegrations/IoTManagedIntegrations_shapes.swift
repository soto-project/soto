//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension IoTManagedIntegrations {
    // MARK: Enums

    public enum AbortCriteriaAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancel = "CANCEL"
        public var description: String { return self.rawValue }
    }

    public enum AbortCriteriaFailureType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case failed = "FAILED"
        case rejected = "REJECTED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum AuthMaterialType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case wifiSetupQrBarCode = "WIFI_SETUP_QR_BAR_CODE"
        case zigbeeQrBarCode = "ZIGBEE_QR_BAR_CODE"
        case zwaveQrBarCode = "ZWAVE_QR_BAR_CODE"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enabled = "ENABLED"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DeliveryDestinationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kinesis = "KINESIS"
        public var description: String { return self.rawValue }
    }

    public enum DeviceDiscoveryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum DisconnectReasonValue: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case authError = "AUTH_ERROR"
        case clientError = "CLIENT_ERROR"
        case clientInitiatedDisconnect = "CLIENT_INITIATED_DISCONNECT"
        case connectionLost = "CONNECTION_LOST"
        case customauthTtlExpiration = "CUSTOMAUTH_TTL_EXPIRATION"
        case duplicateClientid = "DUPLICATE_CLIENTID"
        case forbiddenAccess = "FORBIDDEN_ACCESS"
        case mqttKeepAliveTimeout = "MQTT_KEEP_ALIVE_TIMEOUT"
        case none = "NONE"
        case serverError = "SERVER_ERROR"
        case serverInitiatedDisconnect = "SERVER_INITIATED_DISCONNECT"
        case throttled = "THROTTLED"
        case unknown = "UNKNOWN"
        case websocketTtlExpiration = "WEBSOCKET_TTL_EXPIRATION"
        public var description: String { return self.rawValue }
    }

    public enum DiscoveryAuthMaterialType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case zwaveInstallCode = "ZWAVE_INSTALL_CODE"
        public var description: String { return self.rawValue }
    }

    public enum DiscoveryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloud = "CLOUD"
        case zigbee = "ZIGBEE"
        case zwave = "ZWAVE"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case customerKeyEncryption = "CUSTOMER_KEY_ENCRYPTION"
        case managedIntegrationsDefaultEncryption = "MANAGED_INTEGRATIONS_DEFAULT_ENCRYPTION"
        public var description: String { return self.rawValue }
    }

    public enum EventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectorAssociation = "CONNECTOR_ASSOCIATION"
        case connectorErrorReport = "CONNECTOR_ERROR_REPORT"
        case deviceCommand = "DEVICE_COMMAND"
        case deviceCommandRequest = "DEVICE_COMMAND_REQUEST"
        case deviceEvent = "DEVICE_EVENT"
        case deviceLifeCycle = "DEVICE_LIFE_CYCLE"
        case deviceOta = "DEVICE_OTA"
        case deviceState = "DEVICE_STATE"
        public var description: String { return self.rawValue }
    }

    public enum HubNetworkMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case networkWideExclusion = "NETWORK_WIDE_EXCLUSION"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum LogLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case debug = "DEBUG"
        case error = "ERROR"
        case info = "INFO"
        case warn = "WARN"
        public var description: String { return self.rawValue }
    }

    public enum OtaMechanism: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case push = "PUSH"
        public var description: String { return self.rawValue }
    }

    public enum OtaProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case http = "HTTP"
        public var description: String { return self.rawValue }
    }

    public enum OtaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case completed = "COMPLETED"
        case deletionInProgress = "DELETION_IN_PROGRESS"
        case inProgress = "IN_PROGRESS"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum OtaTaskExecutionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case queued = "QUEUED"
        case rejected = "REJECTED"
        case removed = "REMOVED"
        case succeeded = "SUCCEEDED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum OtaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case continuous = "CONTINUOUS"
        case oneTime = "ONE_TIME"
        public var description: String { return self.rawValue }
    }

    public enum ProvisioningStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activated = "ACTIVATED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleted = "DELETED"
        case deletionFailed = "DELETION_FAILED"
        case discovered = "DISCOVERED"
        case isolated = "ISOLATED"
        case preAssociated = "PRE_ASSOCIATED"
        case unassociated = "UNASSOCIATED"
        public var description: String { return self.rawValue }
    }

    public enum ProvisioningType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fleetProvisioning = "FLEET_PROVISIONING"
        case jitr = "JITR"
        public var description: String { return self.rawValue }
    }

    public enum RetryCriteriaFailureType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case failed = "FAILED"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum Role: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case controller = "CONTROLLER"
        case device = "DEVICE"
        public var description: String { return self.rawValue }
    }

    public enum SchedulingConfigEndBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancel = "CANCEL"
        case forceCancel = "FORCE_CANCEL"
        case stopRollout = "STOP_ROLLOUT"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case connector = "CONNECTOR"
        case zcl = "ZCL"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case capability = "capability"
        case definition = "definition"
        public var description: String { return self.rawValue }
    }

    public enum SchemaVersionVisibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AbortConfigCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The action taken by the abort configuration.
        public let action: AbortCriteriaAction?
        /// Over-the-air (OTA) task abort criteria failure type.
        public let failureType: AbortCriteriaFailureType?
        /// The minimum number of things that must receive task execution notifications before the task can be aborted.
        public let minNumberOfExecutedThings: Int?
        /// The minimum percentage of over-the-air (OTA) task execution failures that must occur to initiate the last abort.
        public let thresholdPercentage: Double?

        @inlinable
        public init(action: AbortCriteriaAction? = nil, failureType: AbortCriteriaFailureType? = nil, minNumberOfExecutedThings: Int? = nil, thresholdPercentage: Double? = nil) {
            self.action = action
            self.failureType = failureType
            self.minNumberOfExecutedThings = minNumberOfExecutedThings
            self.thresholdPercentage = thresholdPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.minNumberOfExecutedThings, name: "minNumberOfExecutedThings", parent: name, max: 100)
            try self.validate(self.minNumberOfExecutedThings, name: "minNumberOfExecutedThings", parent: name, min: 1)
            try self.validate(self.thresholdPercentage, name: "thresholdPercentage", parent: name, max: 100.0)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case failureType = "FailureType"
            case minNumberOfExecutedThings = "MinNumberOfExecutedThings"
            case thresholdPercentage = "ThresholdPercentage"
        }
    }

    public struct CapabilityAction: AWSEncodableShape {
        /// Describe a capability action with an actionTraceId for a response command.
        public let actionTraceId: String?
        /// Describe a capability action with a name.
        public let name: String
        /// Describe a capability action with a capability property.
        public let parameters: AWSDocument?
        /// Describe a capability action with an reference.
        public let ref: String?

        @inlinable
        public init(actionTraceId: String? = nil, name: String, parameters: AWSDocument? = nil, ref: String? = nil) {
            self.actionTraceId = actionTraceId
            self.name = name
            self.parameters = parameters
            self.ref = ref
        }

        public func validate(name: String) throws {
            try self.validate(self.actionTraceId, name: "actionTraceId", parent: name, max: 20)
            try self.validate(self.actionTraceId, name: "actionTraceId", parent: name, min: 16)
            try self.validate(self.actionTraceId, name: "actionTraceId", parent: name, pattern: "^[a-zA-Z0-9]+=(?:_[0-9]+)?$")
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z]+$")
            try self.validate(self.ref, name: "ref", parent: name, pattern: "^[a-zA-Z.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionTraceId = "actionTraceId"
            case name = "name"
            case parameters = "parameters"
            case ref = "ref"
        }
    }

    public struct CapabilityReport: AWSEncodableShape & AWSDecodableShape {
        /// The endpoints used in the capability report.
        public let endpoints: [CapabilityReportEndpoint]
        /// The numeric identifier of the node.
        public let nodeId: String?
        /// The version of the capability report.
        public let version: String

        @inlinable
        public init(endpoints: [CapabilityReportEndpoint], nodeId: String? = nil, version: String) {
            self.endpoints = endpoints
            self.nodeId = nodeId
            self.version = version
        }

        public func validate(name: String) throws {
            try self.endpoints.forEach {
                try $0.validate(name: "\(name).endpoints[]")
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 50)
            try self.validate(self.nodeId, name: "nodeId", parent: name, max: 64)
            try self.validate(self.nodeId, name: "nodeId", parent: name, min: 1)
            try self.validate(self.nodeId, name: "nodeId", parent: name, pattern: "^[a-zA-Z0-9=_.,@\\+\\-/]+$")
            try self.validate(self.version, name: "version", parent: name, max: 10)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^1\\.0\\.0$")
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "endpoints"
            case nodeId = "nodeId"
            case version = "version"
        }
    }

    public struct CapabilityReportCapability: AWSEncodableShape & AWSDecodableShape {
        /// The capability actions used in the capability report.
        public let actions: [String]
        /// The capability events used in the capability report.
        public let events: [String]
        /// The id of the schema version.
        public let id: String
        /// The name of the capability.
        public let name: String
        /// The capability properties used in the capability report.
        public let properties: [String]
        /// The version of the capability.
        public let version: String

        @inlinable
        public init(actions: [String], events: [String], id: String, name: String, properties: [String], version: String) {
            self.actions = actions
            self.events = events
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try validate($0, name: "actions[]", parent: name, max: 128)
                try validate($0, name: "actions[]", parent: name, min: 1)
                try validate($0, name: "actions[]", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 100)
            try self.events.forEach {
                try validate($0, name: "events[]", parent: name, max: 128)
                try validate($0, name: "events[]", parent: name, min: 1)
                try validate($0, name: "events[]", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            }
            try self.validate(self.events, name: "events", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9.\\/]+(@(\\d+\\.\\d+|\\$latest))?$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            try self.properties.forEach {
                try validate($0, name: "properties[]", parent: name, max: 128)
                try validate($0, name: "properties[]", parent: name, min: 1)
                try validate($0, name: "properties[]", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            }
            try self.validate(self.properties, name: "properties", parent: name, max: 100)
            try self.validate(self.version, name: "version", parent: name, max: 64)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^(0|[1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case events = "events"
            case id = "id"
            case name = "name"
            case properties = "properties"
            case version = "version"
        }
    }

    public struct CapabilityReportEndpoint: AWSEncodableShape & AWSDecodableShape {
        /// The capabilities used in the capability report.
        public let capabilities: [CapabilityReportCapability]
        /// The type of device.
        public let deviceTypes: [String]
        /// The id of the endpoint used in the capability report.
        public let id: String

        @inlinable
        public init(capabilities: [CapabilityReportCapability], deviceTypes: [String], id: String) {
            self.capabilities = capabilities
            self.deviceTypes = deviceTypes
            self.id = id
        }

        public func validate(name: String) throws {
            try self.capabilities.forEach {
                try $0.validate(name: "\(name).capabilities[]")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 50)
            try self.deviceTypes.forEach {
                try validate($0, name: "deviceTypes[]", parent: name, max: 256)
                try validate($0, name: "deviceTypes[]", parent: name, pattern: "^[a-zA-Z0-9=_. ,@\\+\\-/]+$")
            }
            try self.validate(self.deviceTypes, name: "deviceTypes", parent: name, max: 50)
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case deviceTypes = "deviceTypes"
            case id = "id"
        }
    }

    public struct CommandCapability: AWSEncodableShape {
        /// Describe the command capability with the actions it supports.
        public let actions: [CapabilityAction]
        /// Describe the capability with an id.
        public let id: String
        /// Describe the capability with an name.
        public let name: String
        /// Describe the capability with a version.
        public let version: String

        @inlinable
        public init(actions: [CapabilityAction], id: String, name: String, version: String) {
            self.actions = actions
            self.id = id
            self.name = name
            self.version = version
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 5)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9.\\/]+(@(\\d+\\.\\d+|\\$latest))?$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[/a-zA-Z0-9\\._ ]+$")
            try self.validate(self.version, name: "version", parent: name, max: 64)
            try self.validate(self.version, name: "version", parent: name, min: 1)
            try self.validate(self.version, name: "version", parent: name, pattern: "^(0|[1-9][0-9]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case id = "id"
            case name = "name"
            case version = "version"
        }
    }

    public struct CommandEndpoint: AWSEncodableShape {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for sending commands.
        public let capabilities: [CommandCapability]
        /// The id of the endpoint for a managed thing.
        public let endpointId: String

        @inlinable
        public init(capabilities: [CommandCapability], endpointId: String) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }

        public func validate(name: String) throws {
            try self.capabilities.forEach {
                try $0.validate(name: "\(name).capabilities[]")
            }
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 5)
            try self.validate(self.capabilities, name: "capabilities", parent: name, min: 1)
            try self.validate(self.endpointId, name: "endpointId", parent: name, max: 64)
            try self.validate(self.endpointId, name: "endpointId", parent: name, min: 1)
            try self.validate(self.endpointId, name: "endpointId", parent: name, pattern: "^[0-9a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case endpointId = "endpointId"
        }
    }

    public struct ConfigurationError: AWSDecodableShape {
        /// The error code returned when the default encryption configuration update fails.
        public let code: String?
        /// The error message returned when the default encryption configuration update fails.
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ConfigurationStatus: AWSDecodableShape {
        /// The error details describing a failed default encryption configuration update.
        public let error: ConfigurationError?
        /// The status state describing the default encryption configuration update.
        public let state: ConfigurationState

        @inlinable
        public init(error: ConfigurationError? = nil, state: ConfigurationState) {
            self.error = error
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case state = "state"
        }
    }

    public struct CreateCredentialLockerRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The name of the credential locker.
        public let name: String?
        /// A set of key/value pairs that are used to manage the credential locker.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateCredentialLockerRequest.idempotencyToken(), name: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateCredentialLockerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public let arn: String?
        /// The timestamp value of when the credential locker request occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker creation request.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
        }
    }

    public struct CreateDestinationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String
        /// The Amazon Resource Name (ARN) of the delivery destination role.
        public let roleArn: String
        /// A set of key/value pairs that are used to manage the destination.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateDestinationRequest.idempotencyToken(), deliveryDestinationArn: String, deliveryDestinationType: DeliveryDestinationType, description: String? = nil, name: String, roleArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, max: 2048)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, min: 20)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, pattern: "^arn:aws:[0-9a-zA-Z]+:[0-9a-zA-Z-]+:[0-9]+:[0-9a-zA-Z]+/[0-9a-zA-Z._-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case name = "Name"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateDestinationResponse: AWSDecodableShape {
        /// The name of the customer-managed destination.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct CreateEventLogConfigurationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The logging level for the event log configuration.
        public let eventLogLevel: LogLevel
        /// The identifier of the resource for the event log configuration.
        public let resourceId: String?
        /// The type of resource for the event log configuration.
        public let resourceType: String

        @inlinable
        public init(clientToken: String? = CreateEventLogConfigurationRequest.idempotencyToken(), eventLogLevel: LogLevel, resourceId: String? = nil, resourceType: String) {
            self.clientToken = clientToken
            self.eventLogLevel = eventLogLevel
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 200)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9+*]*$")
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[*]$|^(managed-thing|credential-locker|provisioning-profile|ota-task)$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case eventLogLevel = "EventLogLevel"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct CreateEventLogConfigurationResponse: AWSDecodableShape {
        /// The identifier of the event log configuration request.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct CreateManagedThingRequest: AWSEncodableShape {
        /// The authentication material defining the device connectivity setup requests. The authentication materials used are the device bar code.
        public let authenticationMaterial: String
        /// The type of authentication material used for device connectivity setup requests.
        public let authenticationMaterialType: AuthMaterialType
        /// The brand of the device.
        public let brand: String?
        /// The capabilities of the device such as light bulb.
        public let capabilities: String?
        /// A report of the capabilities for the managed thing.
        public let capabilityReport: CapabilityReport?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The identifier of the credential for the managed thing.
        public let credentialLockerId: String?
        /// The metadata for the managed thing.
        public let metaData: [String: String]?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// The type of device used. This will be the hub controller, cloud device, or AWS IoT device.
        public let role: Role
        /// The serial number of the device.
        public let serialNumber: String?
        /// A set of key/value pairs that are used to manage the managed thing.
        public let tags: [String: String]?

        @inlinable
        public init(authenticationMaterial: String, authenticationMaterialType: AuthMaterialType, brand: String? = nil, capabilities: String? = nil, capabilityReport: CapabilityReport? = nil, classification: String? = nil, clientToken: String? = CreateManagedThingRequest.idempotencyToken(), credentialLockerId: String? = nil, metaData: [String: String]? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, role: Role, serialNumber: String? = nil, tags: [String: String]? = nil) {
            self.authenticationMaterial = authenticationMaterial
            self.authenticationMaterialType = authenticationMaterialType
            self.brand = brand
            self.capabilities = capabilities
            self.capabilityReport = capabilityReport
            self.classification = classification
            self.clientToken = clientToken
            self.credentialLockerId = credentialLockerId
            self.metaData = metaData
            self.model = model
            self.name = name
            self.owner = owner
            self.role = role
            self.serialNumber = serialNumber
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, max: 512)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, min: 1)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, pattern: "^[0-9A-Za-z!#$%&()*\\+\\-;<=>?@^_`{|}~\\/: ]+$")
            try self.validate(self.brand, name: "brand", parent: name, max: 128)
            try self.validate(self.brand, name: "brand", parent: name, min: 1)
            try self.validate(self.brand, name: "brand", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 65535)
            try self.validate(self.capabilities, name: "capabilities", parent: name, min: 1)
            try self.validate(self.capabilities, name: "capabilities", parent: name, pattern: "^[a-zA-Z0-9\\s'\\x{0022},.:\\\\\\/{$}\\[\\]=_\\-\\+]+$")
            try self.capabilityReport?.validate(name: "\(name).capabilityReport")
            try self.validate(self.classification, name: "classification", parent: name, max: 64)
            try self.validate(self.classification, name: "classification", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, max: 64)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, min: 1)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.metaData?.forEach {
                try validate($0.key, name: "metaData.key", parent: name, max: 128)
                try validate($0.key, name: "metaData.key", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]+")
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]*")
            }
            try self.validate(self.metaData, name: "metaData", parent: name, max: 50)
            try self.validate(self.metaData, name: "metaData", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, max: 128)
            try self.validate(self.model, name: "model", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.validate(self.owner, name: "owner", parent: name, max: 64)
            try self.validate(self.owner, name: "owner", parent: name, min: 1)
            try self.validate(self.owner, name: "owner", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 128)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, min: 1)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationMaterial = "AuthenticationMaterial"
            case authenticationMaterialType = "AuthenticationMaterialType"
            case brand = "Brand"
            case capabilities = "Capabilities"
            case capabilityReport = "CapabilityReport"
            case classification = "Classification"
            case clientToken = "ClientToken"
            case credentialLockerId = "CredentialLockerId"
            case metaData = "MetaData"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case role = "Role"
            case serialNumber = "SerialNumber"
            case tags = "Tags"
        }
    }

    public struct CreateManagedThingResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the managed thing.
        public let arn: String?
        /// The timestamp value of when the device creation request occurred.
        public let createdAt: Date?
        /// The id of the managed thing.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
        }
    }

    public struct CreateNotificationConfigurationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The name of the destination for the notification configuration.
        public let destinationName: String
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType
        /// A set of key/value pairs that are used to manage the notification configuration.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateNotificationConfigurationRequest.idempotencyToken(), destinationName: String, eventType: EventType, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.destinationName = destinationName
            self.eventType = eventType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 1)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case destinationName = "DestinationName"
            case eventType = "EventType"
            case tags = "Tags"
        }
    }

    public struct CreateNotificationConfigurationResponse: AWSDecodableShape {
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType?

        @inlinable
        public init(eventType: EventType? = nil) {
            self.eventType = eventType
        }

        private enum CodingKeys: String, CodingKey {
            case eventType = "EventType"
        }
    }

    public struct CreateOtaTaskConfigurationRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// A description of the over-the-air (OTA) task configuration.
        public let description: String?
        /// The name of the over-the-air (OTA) task.
        public let name: String?
        /// Describes the type of configuration used for the over-the-air (OTA) task.
        public let pushConfig: PushConfig?

        @inlinable
        public init(clientToken: String? = CreateOtaTaskConfigurationRequest.idempotencyToken(), description: String? = nil, name: String? = nil, pushConfig: PushConfig? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.pushConfig = pushConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.pushConfig?.validate(name: "\(name).pushConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case name = "Name"
            case pushConfig = "PushConfig"
        }
    }

    public struct CreateOtaTaskConfigurationResponse: AWSDecodableShape {
        /// The identifier of the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?

        @inlinable
        public init(taskConfigurationId: String? = nil) {
            self.taskConfigurationId = taskConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct CreateOtaTaskRequest: AWSEncodableShape {
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The description of the over-the-air (OTA) task.
        public let description: String?
        /// The deployment mechanism for the over-the-air (OTA) task.
        public let otaMechanism: OtaMechanism?
        public let otaSchedulingConfig: OtaTaskSchedulingConfig?
        /// The query string to add things to the thing group.
        public let otaTargetQueryString: String?
        public let otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig?
        /// The frequency type for the over-the-air (OTA) task.
        public let otaType: OtaType
        /// The connection protocol the over-the-air (OTA) task uses to update the device.
        public let `protocol`: OtaProtocol?
        /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
        public let s3Url: String
        /// A set of key/value pairs that are used to manage the over-the-air (OTA) task.
        public let tags: [String: String]?
        /// The device targeted for the over-the-air (OTA) task.
        public let target: [String]?
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?

        @inlinable
        public init(clientToken: String? = CreateOtaTaskRequest.idempotencyToken(), description: String? = nil, otaMechanism: OtaMechanism? = nil, otaSchedulingConfig: OtaTaskSchedulingConfig? = nil, otaTargetQueryString: String? = nil, otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig? = nil, otaType: OtaType, protocol: OtaProtocol? = nil, s3Url: String, tags: [String: String]? = nil, target: [String]? = nil, taskConfigurationId: String? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.otaMechanism = otaMechanism
            self.otaSchedulingConfig = otaSchedulingConfig
            self.otaTargetQueryString = otaTargetQueryString
            self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
            self.otaType = otaType
            self.`protocol` = `protocol`
            self.s3Url = s3Url
            self.tags = tags
            self.target = target
            self.taskConfigurationId = taskConfigurationId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.otaSchedulingConfig?.validate(name: "\(name).otaSchedulingConfig")
            try self.otaTaskExecutionRetryConfig?.validate(name: "\(name).otaTaskExecutionRetryConfig")
            try self.validate(self.s3Url, name: "s3Url", parent: name, max: 1000)
            try self.validate(self.s3Url, name: "s3Url", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, max: 64)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, min: 1)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case otaMechanism = "OtaMechanism"
            case otaSchedulingConfig = "OtaSchedulingConfig"
            case otaTargetQueryString = "OtaTargetQueryString"
            case otaTaskExecutionRetryConfig = "OtaTaskExecutionRetryConfig"
            case otaType = "OtaType"
            case `protocol` = "Protocol"
            case s3Url = "S3Url"
            case tags = "Tags"
            case target = "Target"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct CreateOtaTaskResponse: AWSDecodableShape {
        /// A description of the over-the-air (OTA) task.
        public let description: String?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
        public let taskArn: String?
        /// The identifier of the over-the-air (OTA) task.
        public let taskId: String?

        @inlinable
        public init(description: String? = nil, taskArn: String? = nil, taskId: String? = nil) {
            self.description = description
            self.taskArn = taskArn
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case taskArn = "TaskArn"
            case taskId = "TaskId"
        }
    }

    public struct CreateProvisioningProfileRequest: AWSEncodableShape {
        /// The id of the certificate authority (CA) certificate.
        public let caCertificate: String?
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType
        /// A set of key/value pairs that are used to manage the provisioning profile.
        public let tags: [String: String]?

        @inlinable
        public init(caCertificate: String? = nil, clientToken: String? = CreateProvisioningProfileRequest.idempotencyToken(), name: String? = nil, provisioningType: ProvisioningType, tags: [String: String]? = nil) {
            self.caCertificate = caCertificate
            self.clientToken = clientToken
            self.name = name
            self.provisioningType = provisioningType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.caCertificate, name: "caCertificate", parent: name, pattern: "^-----BEGIN CERTIFICATE-----.*(.|\\n)*-----END CERTIFICATE-----\\n?$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9A-Za-z_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case caCertificate = "CaCertificate"
            case clientToken = "ClientToken"
            case name = "Name"
            case provisioningType = "ProvisioningType"
            case tags = "Tags"
        }
    }

    public struct CreateProvisioningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public let arn: String?
        /// The id of the claim certificate.
        public let claimCertificate: String?
        /// The private key of the claim certificate. This is stored securely on the device for validating the connection endpoint with IoT managed integrations using the public key.
        public let claimCertificatePrivateKey: String?
        /// The identifier of the provisioning profile.
        public let id: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType?

        @inlinable
        public init(arn: String? = nil, claimCertificate: String? = nil, claimCertificatePrivateKey: String? = nil, id: String? = nil, name: String? = nil, provisioningType: ProvisioningType? = nil) {
            self.arn = arn
            self.claimCertificate = claimCertificate
            self.claimCertificatePrivateKey = claimCertificatePrivateKey
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case claimCertificate = "ClaimCertificate"
            case claimCertificatePrivateKey = "ClaimCertificatePrivateKey"
            case id = "Id"
            case name = "Name"
            case provisioningType = "ProvisioningType"
        }
    }

    public struct CredentialLockerSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public let arn: String?
        /// The timestampe value of when the credential locker was created at.
        public let createdAt: Date?
        /// The id of the credential locker.
        public let id: String?
        /// The name of the credential locker.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct DeleteCredentialLockerRequest: AWSEncodableShape {
        /// The identifier of the credential locker.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDestinationRequest: AWSEncodableShape {
        /// The id of the customer-managed destination.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEventLogConfigurationRequest: AWSEncodableShape {
        /// The identifier of the event log configuration.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 200)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteManagedThingRequest: AWSEncodableShape {
        /// When set to TRUE, a forceful deteletion of the managed thing will occur. When set to FALSE, a non-forceful deletion of the managed thing will occur.
        public let force: Bool?
        /// The id of the managed thing.
        public let identifier: String

        @inlinable
        public init(force: Bool? = nil, identifier: String) {
            self.force = force
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.force, key: "Force")
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteNotificationConfigurationRequest: AWSEncodableShape {
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType

        @inlinable
        public init(eventType: EventType) {
            self.eventType = eventType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventType, key: "EventType")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOtaTaskConfigurationRequest: AWSEncodableShape {
        /// The identifier of the over-the-air (OTA) task configuration.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOtaTaskRequest: AWSEncodableShape {
        /// The identifier of the over-the-air (OTA) task.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProvisioningProfileRequest: AWSEncodableShape {
        /// The name of the provisioning template.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DestinationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String?
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the delivery destination.
        public let roleArn: String?

        @inlinable
        public init(deliveryDestinationArn: String? = nil, deliveryDestinationType: DeliveryDestinationType? = nil, description: String? = nil, name: String? = nil, roleArn: String? = nil) {
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case name = "Name"
            case roleArn = "RoleArn"
        }
    }

    public struct EventLogConfigurationSummary: AWSDecodableShape {
        /// The logging level for the event log configuration.
        public let eventLogLevel: LogLevel?
        /// The identifier of the event log configuration.
        public let id: String?
        /// The identifier of the resource for the event log configuration.
        public let resourceId: String?
        /// The type of resource for the event log configuration.
        public let resourceType: String?

        @inlinable
        public init(eventLogLevel: LogLevel? = nil, id: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.eventLogLevel = eventLogLevel
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogLevel = "EventLogLevel"
            case id = "Id"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ExponentialRolloutRate: AWSEncodableShape & AWSDecodableShape {
        /// The base rate per minute for the rollout of an over-the-air (OTA) task.
        public let baseRatePerMinute: Int?
        /// The incremental factor for increasing the rollout rate of an over-the-air (OTA) task.
        public let incrementFactor: Double?
        /// The criteria for increasing the rollout rate of an over-the-air (OTA) task.
        public let rateIncreaseCriteria: RolloutRateIncreaseCriteria?

        @inlinable
        public init(baseRatePerMinute: Int? = nil, incrementFactor: Double? = nil, rateIncreaseCriteria: RolloutRateIncreaseCriteria? = nil) {
            self.baseRatePerMinute = baseRatePerMinute
            self.incrementFactor = incrementFactor
            self.rateIncreaseCriteria = rateIncreaseCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.baseRatePerMinute, name: "baseRatePerMinute", parent: name, max: 100)
            try self.validate(self.baseRatePerMinute, name: "baseRatePerMinute", parent: name, min: 1)
            try self.validate(self.incrementFactor, name: "incrementFactor", parent: name, max: 5.0)
            try self.validate(self.incrementFactor, name: "incrementFactor", parent: name, min: 1.1)
            try self.rateIncreaseCriteria?.validate(name: "\(name).rateIncreaseCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case baseRatePerMinute = "BaseRatePerMinute"
            case incrementFactor = "IncrementFactor"
            case rateIncreaseCriteria = "RateIncreaseCriteria"
        }
    }

    public struct GetCredentialLockerRequest: AWSEncodableShape {
        /// The identifier of the credential locker.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCredentialLockerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the credential locker.
        public let arn: String?
        /// The timestamp value of when the credential locker requset occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker.
        public let id: String?
        /// The name of the credential locker.
        public let name: String?
        /// A set of key/value pairs that are used to manage the credential locker.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdAt = "CreatedAt"
            case id = "Id"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct GetCustomEndpointRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetCustomEndpointResponse: AWSDecodableShape {
        /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
        public let endpointAddress: String

        @inlinable
        public init(endpointAddress: String) {
            self.endpointAddress = endpointAddress
        }

        private enum CodingKeys: String, CodingKey {
            case endpointAddress = "EndpointAddress"
        }
    }

    public struct GetDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// Provides the status of the default encryption configuration for an Amazon Web Services account.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct GetDestinationRequest: AWSEncodableShape {
        /// The name of the customer-managed destination.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDestinationResponse: AWSDecodableShape {
        /// The timestamp value of when the destination creation requset occurred.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String?
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the delivery destination role.
        public let roleArn: String?
        /// A set of key/value pairs that are used to manage the customer-managed destination.
        public let tags: [String: String]?
        /// The timestamp value of when the destination update requset occurred.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, deliveryDestinationArn: String? = nil, deliveryDestinationType: DeliveryDestinationType? = nil, description: String? = nil, name: String? = nil, roleArn: String? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case name = "Name"
            case roleArn = "RoleArn"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetDeviceDiscoveryRequest: AWSEncodableShape {
        /// The id of the device discovery job request.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeviceDiscoveryResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the device discovery job request.
        public let arn: String
        /// The ID tracking the current discovery process for one connector association.
        public let connectorAssociationId: String?
        /// The id of the end-user's IoT hub.
        public let controllerId: String?
        /// The discovery type supporting the type of device to be discovered in the device discovery job request.
        public let discoveryType: DiscoveryType
        /// The timestamp value for the completion time of the device discovery.
        public let finishedAt: Date?
        /// The id of the device discovery job request.
        public let id: String
        /// The timestamp value for the start time of the device discovery.
        public let startedAt: Date
        /// The status of the device discovery job request.
        public let status: DeviceDiscoveryStatus
        /// A set of key/value pairs that are used to manage the device discovery request.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, connectorAssociationId: String? = nil, controllerId: String? = nil, discoveryType: DiscoveryType, finishedAt: Date? = nil, id: String, startedAt: Date, status: DeviceDiscoveryStatus, tags: [String: String]? = nil) {
            self.arn = arn
            self.connectorAssociationId = connectorAssociationId
            self.controllerId = controllerId
            self.discoveryType = discoveryType
            self.finishedAt = finishedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case connectorAssociationId = "ConnectorAssociationId"
            case controllerId = "ControllerId"
            case discoveryType = "DiscoveryType"
            case finishedAt = "FinishedAt"
            case id = "Id"
            case startedAt = "StartedAt"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetEventLogConfigurationRequest: AWSEncodableShape {
        /// The identifier of the event log configuration.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 200)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEventLogConfigurationResponse: AWSDecodableShape {
        /// The logging level for the event log configuration.
        public let eventLogLevel: LogLevel?
        /// The identifier of the event log configuration.
        public let id: String?
        /// The identifier of the resource for the event log configuration.
        public let resourceId: String?
        /// The type of resource for the event log configuration.
        public let resourceType: String?

        @inlinable
        public init(eventLogLevel: LogLevel? = nil, id: String? = nil, resourceId: String? = nil, resourceType: String? = nil) {
            self.eventLogLevel = eventLogLevel
            self.id = id
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogLevel = "EventLogLevel"
            case id = "Id"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct GetHubConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetHubConfigurationResponse: AWSDecodableShape {
        /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
        public let hubTokenTimerExpirySettingInSeconds: Int64?
        /// The timestamp value of when the hub configuration was updated.
        public let updatedAt: Date?

        @inlinable
        public init(hubTokenTimerExpirySettingInSeconds: Int64? = nil, updatedAt: Date? = nil) {
            self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case hubTokenTimerExpirySettingInSeconds = "HubTokenTimerExpirySettingInSeconds"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetManagedThingCapabilitiesRequest: AWSEncodableShape {
        /// The id of the device.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingCapabilitiesResponse: AWSDecodableShape {
        /// The capabilities of the device such as light bulb.
        public let capabilities: String?
        /// A report of the capabilities for the managed thing.
        public let capabilityReport: CapabilityReport?
        /// The id of the device.
        public let managedThingId: String?

        @inlinable
        public init(capabilities: String? = nil, capabilityReport: CapabilityReport? = nil, managedThingId: String? = nil) {
            self.capabilities = capabilities
            self.capabilityReport = capabilityReport
            self.managedThingId = managedThingId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case capabilityReport = "CapabilityReport"
            case managedThingId = "ManagedThingId"
        }
    }

    public struct GetManagedThingConnectivityDataRequest: AWSEncodableShape {
        /// The identifier of a managed thing.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingConnectivityDataResponse: AWSDecodableShape {
        /// The connectivity status for a managed thing.
        public let connected: Bool?
        /// The reason for the connectivity disconnect with the managed thing.
        public let disconnectReason: DisconnectReasonValue?
        /// The id of a managed thing.
        public let managedThingId: String?
        /// The timestamp value of when the connectivity status for a managed thing was last taken.
        public let timestamp: Date?

        @inlinable
        public init(connected: Bool? = nil, disconnectReason: DisconnectReasonValue? = nil, managedThingId: String? = nil, timestamp: Date? = nil) {
            self.connected = connected
            self.disconnectReason = disconnectReason
            self.managedThingId = managedThingId
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case connected = "Connected"
            case disconnectReason = "DisconnectReason"
            case managedThingId = "ManagedThingId"
            case timestamp = "Timestamp"
        }
    }

    public struct GetManagedThingMetaDataRequest: AWSEncodableShape {
        /// The managed thing id.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingMetaDataResponse: AWSDecodableShape {
        /// The managed thing id.
        public let managedThingId: String?
        /// The metadata for the managed thing.
        public let metaData: [String: String]?

        @inlinable
        public init(managedThingId: String? = nil, metaData: [String: String]? = nil) {
            self.managedThingId = managedThingId
            self.metaData = metaData
        }

        private enum CodingKeys: String, CodingKey {
            case managedThingId = "ManagedThingId"
            case metaData = "MetaData"
        }
    }

    public struct GetManagedThingRequest: AWSEncodableShape {
        /// The id of the managed thing.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingResponse: AWSDecodableShape {
        /// The timestampe value of when the device was activated.
        public let activatedAt: Date?
        /// The id of the advertised product.
        public let advertisedProductId: String?
        /// The Amazon Resource Name (ARN) of the managed thing.
        public let arn: String?
        /// The brand of the device.
        public let brand: String?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).  This parameter is used for cloud-to-cloud devices only.
        public let connectorDeviceId: String?
        /// The id of the connector policy.  This parameter is used for cloud-to-cloud devices only.
        public let connectorPolicyId: String?
        /// The timestamp value of when the device creation request occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker for the managed thing.
        public let credentialLockerId: String?
        /// A Zwave device-specific key used during device activation.  This parameter is used for Zwave devices only.
        public let deviceSpecificKey: String?
        /// The network mode for the hub-connected device.
        public let hubNetworkMode: HubNetworkMode?
        /// The id of the managed thing.
        public let id: String?
        /// The unique 13 digit number that identifies the managed thing.
        public let internationalArticleNumber: String?
        /// The media access control (MAC) address for the device represented by the managed thing.  This parameter is used for Zigbee devices only.
        public let macAddress: String?
        /// The metadata for the managed thing.
        public let metaData: [String: String]?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// Id of the controller device used for the discovery job.
        public let parentControllerId: String?
        /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
        public let provisioningStatus: ProvisioningStatus?
        /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public let role: Role?
        /// The serial number of the device.
        public let serialNumber: String?
        /// A set of key/value pairs that are used to manage the managed thing.
        public let tags: [String: String]?
        /// The universal product code (UPC) of the device model. The UPC is typically used in the United States of America and Canada.
        public let universalProductCode: String?
        /// The timestamp value of when the managed thing was last updated at.
        public let updatedAt: Date?

        @inlinable
        public init(activatedAt: Date? = nil, advertisedProductId: String? = nil, arn: String? = nil, brand: String? = nil, classification: String? = nil, connectorDeviceId: String? = nil, connectorPolicyId: String? = nil, createdAt: Date? = nil, credentialLockerId: String? = nil, deviceSpecificKey: String? = nil, hubNetworkMode: HubNetworkMode? = nil, id: String? = nil, internationalArticleNumber: String? = nil, macAddress: String? = nil, metaData: [String: String]? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, parentControllerId: String? = nil, provisioningStatus: ProvisioningStatus? = nil, role: Role? = nil, serialNumber: String? = nil, tags: [String: String]? = nil, universalProductCode: String? = nil, updatedAt: Date? = nil) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = connectorPolicyId
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.deviceSpecificKey = deviceSpecificKey
            self.hubNetworkMode = hubNetworkMode
            self.id = id
            self.internationalArticleNumber = internationalArticleNumber
            self.macAddress = macAddress
            self.metaData = metaData
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.tags = tags
            self.universalProductCode = universalProductCode
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case activatedAt = "ActivatedAt"
            case advertisedProductId = "AdvertisedProductId"
            case arn = "Arn"
            case brand = "Brand"
            case classification = "Classification"
            case connectorDeviceId = "ConnectorDeviceId"
            case connectorPolicyId = "ConnectorPolicyId"
            case createdAt = "CreatedAt"
            case credentialLockerId = "CredentialLockerId"
            case deviceSpecificKey = "DeviceSpecificKey"
            case hubNetworkMode = "HubNetworkMode"
            case id = "Id"
            case internationalArticleNumber = "InternationalArticleNumber"
            case macAddress = "MacAddress"
            case metaData = "MetaData"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case parentControllerId = "ParentControllerId"
            case provisioningStatus = "ProvisioningStatus"
            case role = "Role"
            case serialNumber = "SerialNumber"
            case tags = "Tags"
            case universalProductCode = "UniversalProductCode"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetManagedThingStateRequest: AWSEncodableShape {
        /// The id of the device.
        public let managedThingId: String

        @inlinable
        public init(managedThingId: String) {
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetManagedThingStateResponse: AWSDecodableShape {
        /// The device endpoint.
        public let endpoints: [StateEndpoint]

        @inlinable
        public init(endpoints: [StateEndpoint]) {
            self.endpoints = endpoints
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "Endpoints"
        }
    }

    public struct GetNotificationConfigurationRequest: AWSEncodableShape {
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType

        @inlinable
        public init(eventType: EventType) {
            self.eventType = eventType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventType, key: "EventType")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetNotificationConfigurationResponse: AWSDecodableShape {
        /// The timestamp value of when the notification configuration was created.
        public let createdAt: Date?
        /// The name of the destination for the notification configuration.
        public let destinationName: String?
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType?
        /// A set of key/value pairs that are used to manage the notification configuration.
        public let tags: [String: String]?
        /// The timestamp value of when the notification configuration was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, destinationName: String? = nil, eventType: EventType? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.destinationName = destinationName
            self.eventType = eventType
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case destinationName = "DestinationName"
            case eventType = "EventType"
            case tags = "Tags"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetOtaTaskConfigurationRequest: AWSEncodableShape {
        /// The over-the-air (OTA) task configuration id.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOtaTaskConfigurationResponse: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
        public let createdAt: Date?
        /// A description of the over-the-air (OTA) task configuration.
        public let description: String?
        /// The name of the over-the-air (OTA) task configuration.
        public let name: String?
        /// Describes the type of configuration used for the over-the-air (OTA) task.
        public let pushConfig: PushConfig?
        /// The over-the-air (OTA) task configuration id.
        public let taskConfigurationId: String?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, name: String? = nil, pushConfig: PushConfig? = nil, taskConfigurationId: String? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.pushConfig = pushConfig
            self.taskConfigurationId = taskConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case name = "Name"
            case pushConfig = "PushConfig"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct GetOtaTaskRequest: AWSEncodableShape {
        /// The over-the-air (OTA) task id.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOtaTaskResponse: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task was created.
        public let createdAt: Date?
        /// The description of the over-the-air (OTA) task.
        public let description: String?
        /// The timestamp value of when the over-the-air (OTA) task was last updated at.
        public let lastUpdatedAt: Date?
        /// The deployment mechanism for the over-the-air (OTA) task.
        public let otaMechanism: OtaMechanism?
        public let otaSchedulingConfig: OtaTaskSchedulingConfig?
        /// The query string to add things to the thing group.
        public let otaTargetQueryString: String?
        public let otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig?
        /// The frequency type for the over-the-air (OTA) task.
        public let otaType: OtaType?
        /// The connection protocol the over-the-air (OTA) task uses to update the device.
        public let `protocol`: OtaProtocol?
        /// The URL to the Amazon S3 bucket where the over-the-air (OTA) task is stored.
        public let s3Url: String?
        /// The status of the over-the-air (OTA) task.
        public let status: OtaStatus?
        /// The device targeted for the over-the-air (OTA) task.
        public let target: [String]?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task
        public let taskArn: String?
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?
        /// The id of the over-the-air (OTA) task.
        public let taskId: String?
        /// The processing details of all over-the-air (OTA) tasks.
        public let taskProcessingDetails: TaskProcessingDetails?

        @inlinable
        public init(createdAt: Date? = nil, description: String? = nil, lastUpdatedAt: Date? = nil, otaMechanism: OtaMechanism? = nil, otaSchedulingConfig: OtaTaskSchedulingConfig? = nil, otaTargetQueryString: String? = nil, otaTaskExecutionRetryConfig: OtaTaskExecutionRetryConfig? = nil, otaType: OtaType? = nil, protocol: OtaProtocol? = nil, s3Url: String? = nil, status: OtaStatus? = nil, target: [String]? = nil, taskArn: String? = nil, taskConfigurationId: String? = nil, taskId: String? = nil, taskProcessingDetails: TaskProcessingDetails? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.otaMechanism = otaMechanism
            self.otaSchedulingConfig = otaSchedulingConfig
            self.otaTargetQueryString = otaTargetQueryString
            self.otaTaskExecutionRetryConfig = otaTaskExecutionRetryConfig
            self.otaType = otaType
            self.`protocol` = `protocol`
            self.s3Url = s3Url
            self.status = status
            self.target = target
            self.taskArn = taskArn
            self.taskConfigurationId = taskConfigurationId
            self.taskId = taskId
            self.taskProcessingDetails = taskProcessingDetails
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case lastUpdatedAt = "LastUpdatedAt"
            case otaMechanism = "OtaMechanism"
            case otaSchedulingConfig = "OtaSchedulingConfig"
            case otaTargetQueryString = "OtaTargetQueryString"
            case otaTaskExecutionRetryConfig = "OtaTaskExecutionRetryConfig"
            case otaType = "OtaType"
            case `protocol` = "Protocol"
            case s3Url = "S3Url"
            case status = "Status"
            case target = "Target"
            case taskArn = "TaskArn"
            case taskConfigurationId = "TaskConfigurationId"
            case taskId = "TaskId"
            case taskProcessingDetails = "TaskProcessingDetails"
        }
    }

    public struct GetProvisioningProfileRequest: AWSEncodableShape {
        /// The provisioning template the device uses for the provisioning process.
        public let identifier: String

        @inlinable
        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProvisioningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public let arn: String?
        /// The id of the claim certificate.
        public let claimCertificate: String?
        /// The provisioning profile id..
        public let id: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType?
        /// A set of key/value pairs that are used to manage the provisioning profile.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, claimCertificate: String? = nil, id: String? = nil, name: String? = nil, provisioningType: ProvisioningType? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.claimCertificate = claimCertificate
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case claimCertificate = "ClaimCertificate"
            case id = "Id"
            case name = "Name"
            case provisioningType = "ProvisioningType"
            case tags = "Tags"
        }
    }

    public struct GetRuntimeLogConfigurationRequest: AWSEncodableShape {
        /// The id for a managed thing.
        public let managedThingId: String

        @inlinable
        public init(managedThingId: String) {
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRuntimeLogConfigurationResponse: AWSDecodableShape {
        /// The id for a managed thing.
        public let managedThingId: String?
        /// The runtime log configuration for a managed thing.
        public let runtimeLogConfigurations: RuntimeLogConfigurations?

        @inlinable
        public init(managedThingId: String? = nil, runtimeLogConfigurations: RuntimeLogConfigurations? = nil) {
            self.managedThingId = managedThingId
            self.runtimeLogConfigurations = runtimeLogConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case managedThingId = "ManagedThingId"
            case runtimeLogConfigurations = "RuntimeLogConfigurations"
        }
    }

    public struct GetSchemaVersionRequest: AWSEncodableShape {
        /// The format of the schema version.
        public let format: SchemaVersionFormat?
        /// Schema id with a version specified. If the version is missing, it defaults to latest version.
        public let schemaVersionedId: String
        /// The type of schema version.
        public let type: SchemaVersionType

        @inlinable
        public init(format: SchemaVersionFormat? = nil, schemaVersionedId: String, type: SchemaVersionType) {
            self.format = format
            self.schemaVersionedId = schemaVersionedId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.format, key: "Format")
            request.encodePath(self.schemaVersionedId, key: "SchemaVersionedId")
            request.encodePath(self.type, key: "Type")
        }

        public func validate(name: String) throws {
            try self.validate(self.schemaVersionedId, name: "schemaVersionedId", parent: name, max: 128)
            try self.validate(self.schemaVersionedId, name: "schemaVersionedId", parent: name, min: 1)
            try self.validate(self.schemaVersionedId, name: "schemaVersionedId", parent: name, pattern: "^[a-zA-Z0-9.\\/]+(@(\\d+\\.\\d+|\\$latest))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaVersionResponse: AWSDecodableShape {
        /// The description of the schema version.
        public let description: String?
        /// The name of the schema version.
        public let namespace: String?
        /// The schema of the schema version.
        public let schema: AWSDocument?
        /// The id of the schema version.
        public let schemaId: String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public let semanticVersion: String?
        /// The type of schema version.
        public let type: SchemaVersionType?
        /// The visibility of the schema version.
        public let visibility: SchemaVersionVisibility?

        @inlinable
        public init(description: String? = nil, namespace: String? = nil, schema: AWSDocument? = nil, schemaId: String? = nil, semanticVersion: String? = nil, type: SchemaVersionType? = nil, visibility: SchemaVersionVisibility? = nil) {
            self.description = description
            self.namespace = namespace
            self.schema = schema
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case namespace = "Namespace"
            case schema = "Schema"
            case schemaId = "SchemaId"
            case semanticVersion = "SemanticVersion"
            case type = "Type"
            case visibility = "Visibility"
        }
    }

    public struct ListCredentialLockersRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCredentialLockersResponse: AWSDecodableShape {
        /// The list of credential lockers.
        public let items: [CredentialLockerSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [CredentialLockerSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListDestinationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDestinationsResponse: AWSDecodableShape {
        /// The list of destinations.
        public let destinationList: [DestinationSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(destinationList: [DestinationSummary]? = nil, nextToken: String? = nil) {
            self.destinationList = destinationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinationList = "DestinationList"
            case nextToken = "NextToken"
        }
    }

    public struct ListEventLogConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEventLogConfigurationsResponse: AWSDecodableShape {
        /// A list of each event log configuration and pertinent information.
        public let eventLogConfigurationList: [EventLogConfigurationSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(eventLogConfigurationList: [EventLogConfigurationSummary]? = nil, nextToken: String? = nil) {
            self.eventLogConfigurationList = eventLogConfigurationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogConfigurationList = "EventLogConfigurationList"
            case nextToken = "NextToken"
        }
    }

    public struct ListManagedThingSchemasRequest: AWSEncodableShape {
        /// Filter on a capability id.
        public let capabilityIdFilter: String?
        /// Filter on an endpoint id.
        public let endpointIdFilter: String?
        /// The managed thing id.
        public let identifier: String
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(capabilityIdFilter: String? = nil, endpointIdFilter: String? = nil, identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.capabilityIdFilter = capabilityIdFilter
            self.endpointIdFilter = endpointIdFilter
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.capabilityIdFilter, key: "CapabilityIdFilter")
            request.encodeQuery(self.endpointIdFilter, key: "EndpointIdFilter")
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.capabilityIdFilter, name: "capabilityIdFilter", parent: name, max: 128)
            try self.validate(self.capabilityIdFilter, name: "capabilityIdFilter", parent: name, min: 1)
            try self.validate(self.capabilityIdFilter, name: "capabilityIdFilter", parent: name, pattern: "^[a-zA-Z0-9./]+(@\\d+\\.\\d+)?$")
            try self.validate(self.endpointIdFilter, name: "endpointIdFilter", parent: name, max: 64)
            try self.validate(self.endpointIdFilter, name: "endpointIdFilter", parent: name, min: 1)
            try self.validate(self.endpointIdFilter, name: "endpointIdFilter", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedThingSchemasResponse: AWSDecodableShape {
        /// The list of managed thing schemas.
        public let items: [ManagedThingSchemaListItem]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ManagedThingSchemaListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListManagedThingsRequest: AWSEncodableShape {
        /// Filter on a connector policy id for a managed thing.
        public let connectorPolicyIdFilter: String?
        /// Filter on a credential locker for a managed thing.
        public let credentialLockerFilter: String?
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// Filter on device owners when listing managed things.
        public let ownerFilter: String?
        /// Filter on a parent controller id for a managed thing.
        public let parentControllerIdentifierFilter: String?
        /// Filter on the status of the device.
        public let provisioningStatusFilter: ProvisioningStatus?
        /// Filter on the type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public let roleFilter: Role?
        /// Filter on the serial number of the device.
        public let serialNumberFilter: String?

        @inlinable
        public init(connectorPolicyIdFilter: String? = nil, credentialLockerFilter: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, ownerFilter: String? = nil, parentControllerIdentifierFilter: String? = nil, provisioningStatusFilter: ProvisioningStatus? = nil, roleFilter: Role? = nil, serialNumberFilter: String? = nil) {
            self.connectorPolicyIdFilter = connectorPolicyIdFilter
            self.credentialLockerFilter = credentialLockerFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerFilter = ownerFilter
            self.parentControllerIdentifierFilter = parentControllerIdentifierFilter
            self.provisioningStatusFilter = provisioningStatusFilter
            self.roleFilter = roleFilter
            self.serialNumberFilter = serialNumberFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.connectorPolicyIdFilter, key: "ConnectorPolicyIdFilter")
            request.encodeQuery(self.credentialLockerFilter, key: "CredentialLockerFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.ownerFilter, key: "OwnerFilter")
            request.encodeQuery(self.parentControllerIdentifierFilter, key: "ParentControllerIdentifierFilter")
            request.encodeQuery(self.provisioningStatusFilter, key: "ProvisioningStatusFilter")
            request.encodeQuery(self.roleFilter, key: "RoleFilter")
            request.encodeQuery(self.serialNumberFilter, key: "SerialNumberFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorPolicyIdFilter, name: "connectorPolicyIdFilter", parent: name, max: 64)
            try self.validate(self.connectorPolicyIdFilter, name: "connectorPolicyIdFilter", parent: name, min: 1)
            try self.validate(self.connectorPolicyIdFilter, name: "connectorPolicyIdFilter", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.credentialLockerFilter, name: "credentialLockerFilter", parent: name, max: 64)
            try self.validate(self.credentialLockerFilter, name: "credentialLockerFilter", parent: name, min: 1)
            try self.validate(self.credentialLockerFilter, name: "credentialLockerFilter", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.ownerFilter, name: "ownerFilter", parent: name, max: 64)
            try self.validate(self.ownerFilter, name: "ownerFilter", parent: name, min: 1)
            try self.validate(self.ownerFilter, name: "ownerFilter", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.parentControllerIdentifierFilter, name: "parentControllerIdentifierFilter", parent: name, max: 64)
            try self.validate(self.parentControllerIdentifierFilter, name: "parentControllerIdentifierFilter", parent: name, min: 1)
            try self.validate(self.parentControllerIdentifierFilter, name: "parentControllerIdentifierFilter", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.serialNumberFilter, name: "serialNumberFilter", parent: name, max: 128)
            try self.validate(self.serialNumberFilter, name: "serialNumberFilter", parent: name, min: 1)
            try self.validate(self.serialNumberFilter, name: "serialNumberFilter", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListManagedThingsResponse: AWSDecodableShape {
        /// The list of managed things.
        public let items: [ManagedThingSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ManagedThingSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListNotificationConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNotificationConfigurationsResponse: AWSDecodableShape {
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// The list of notification configurations.
        public let notificationConfigurationList: [NotificationConfigurationSummary]?

        @inlinable
        public init(nextToken: String? = nil, notificationConfigurationList: [NotificationConfigurationSummary]? = nil) {
            self.nextToken = nextToken
            self.notificationConfigurationList = notificationConfigurationList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case notificationConfigurationList = "NotificationConfigurationList"
        }
    }

    public struct ListOtaTaskConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOtaTaskConfigurationsResponse: AWSDecodableShape {
        /// The list of the over-the-air (OTA) task configurations.
        public let items: [OtaTaskConfigurationSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [OtaTaskConfigurationSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListOtaTaskExecutionsRequest: AWSEncodableShape {
        /// The over-the-air (OTA) task id.
        public let identifier: String
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(identifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.identifier = identifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_+/-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOtaTaskExecutionsResponse: AWSDecodableShape {
        /// A list of all of the over-the-air (OTA) task executions.
        public let executionSummaries: [OtaTaskExecutionSummaries]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(executionSummaries: [OtaTaskExecutionSummaries]? = nil, nextToken: String? = nil) {
            self.executionSummaries = executionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case executionSummaries = "ExecutionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListOtaTasksRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_+/-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOtaTasksResponse: AWSDecodableShape {
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// A list of all of the over-the-air (OTA) tasks.
        public let tasks: [OtaTaskSummary]?

        @inlinable
        public init(nextToken: String? = nil, tasks: [OtaTaskSummary]? = nil) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tasks = "Tasks"
        }
    }

    public struct ListProvisioningProfilesRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProvisioningProfilesResponse: AWSDecodableShape {
        /// The list of provisioning profiles.
        public let items: [ProvisioningProfileSummary]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ProvisioningProfileSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListSchemaVersionsRequest: AWSEncodableShape {
        /// The maximum number of results to return at one time.
        public let maxResults: Int?
        /// Filter on the name of the schema version.
        public let namespace: String?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?
        /// Filter on the id of the schema version.
        public let schemaId: String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public let semanticVersion: String?
        /// Filter on the type of schema version.
        public let type: SchemaVersionType
        /// The visibility of the schema version.
        public let visibility: SchemaVersionVisibility?

        @inlinable
        public init(maxResults: Int? = nil, namespace: String? = nil, nextToken: String? = nil, schemaId: String? = nil, semanticVersion: String? = nil, type: SchemaVersionType, visibility: SchemaVersionVisibility? = nil) {
            self.maxResults = maxResults
            self.namespace = namespace
            self.nextToken = nextToken
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.namespace, key: "NamespaceFilter")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.schemaId, key: "SchemaIdFilter")
            request.encodeQuery(self.semanticVersion, key: "SemanticVersionFilter")
            request.encodePath(self.type, key: "Type")
            request.encodeQuery(self.visibility, key: "VisibilityFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 256)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-z]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 65535)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.schemaId, name: "schemaId", parent: name, max: 128)
            try self.validate(self.schemaId, name: "schemaId", parent: name, min: 1)
            try self.validate(self.schemaId, name: "schemaId", parent: name, pattern: "^[a-zA-Z0-9./]+$")
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, max: 256)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, min: 1)
            try self.validate(self.semanticVersion, name: "semanticVersion", parent: name, pattern: "^(\\d+\\.\\d+|\\$latest)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemaVersionsResponse: AWSDecodableShape {
        /// The list of schema versions.
        public let items: [SchemaVersionListItem]?
        /// A token that can be used to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(items: [SchemaVersionListItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ManagedThingSchemaListItem: AWSDecodableShape {
        /// The id of the capability for a managed thing.
        public let capabilityId: String?
        /// The id of the endpoint for a managed thing.
        public let endpointId: String?
        /// The validation schema for one schema item associated with a managed thing.
        public let schema: AWSDocument?

        @inlinable
        public init(capabilityId: String? = nil, endpointId: String? = nil, schema: AWSDocument? = nil) {
            self.capabilityId = capabilityId
            self.endpointId = endpointId
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case capabilityId = "CapabilityId"
            case endpointId = "EndpointId"
            case schema = "Schema"
        }
    }

    public struct ManagedThingSummary: AWSDecodableShape {
        /// The timestampe value of when the managed thing was activated at.
        public let activatedAt: Date?
        /// The id of the advertised product.
        public let advertisedProductId: String?
        /// The Amazon Resource Name (ARN) of the managed thing.
        public let arn: String?
        /// The brand of the device.
        public let brand: String?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// The third-party device id as defined by the connector. This device id must not contain personal identifiable information (PII).  This parameter is used for cloud-to-cloud devices only.
        public let connectorDeviceId: String?
        /// The id of the connector policy.  This parameter is used for cloud-to-cloud devices only.
        public let connectorPolicyId: String?
        /// The timestamp value of when the device creation request occurred.
        public let createdAt: Date?
        /// The identifier of the credential locker for the managed thing.
        public let credentialLockerId: String?
        /// The id of the device.
        public let id: String?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// Id of the controller device used for the discovery job.
        public let parentControllerId: String?
        /// The provisioning status of the device in the provisioning workflow for onboarding to IoT managed integrations.
        public let provisioningStatus: ProvisioningStatus?
        /// The type of device used. This will be the Amazon Web Services hub controller, cloud device, or IoT device.
        public let role: Role?
        /// The serial number of the device.
        public let serialNumber: String?
        /// The timestamp value of when the managed thing was last updated at.
        public let updatedAt: Date?

        @inlinable
        public init(activatedAt: Date? = nil, advertisedProductId: String? = nil, arn: String? = nil, brand: String? = nil, classification: String? = nil, connectorDeviceId: String? = nil, connectorPolicyId: String? = nil, createdAt: Date? = nil, credentialLockerId: String? = nil, id: String? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, parentControllerId: String? = nil, provisioningStatus: ProvisioningStatus? = nil, role: Role? = nil, serialNumber: String? = nil, updatedAt: Date? = nil) {
            self.activatedAt = activatedAt
            self.advertisedProductId = advertisedProductId
            self.arn = arn
            self.brand = brand
            self.classification = classification
            self.connectorDeviceId = connectorDeviceId
            self.connectorPolicyId = connectorPolicyId
            self.createdAt = createdAt
            self.credentialLockerId = credentialLockerId
            self.id = id
            self.model = model
            self.name = name
            self.owner = owner
            self.parentControllerId = parentControllerId
            self.provisioningStatus = provisioningStatus
            self.role = role
            self.serialNumber = serialNumber
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case activatedAt = "ActivatedAt"
            case advertisedProductId = "AdvertisedProductId"
            case arn = "Arn"
            case brand = "Brand"
            case classification = "Classification"
            case connectorDeviceId = "ConnectorDeviceId"
            case connectorPolicyId = "ConnectorPolicyId"
            case createdAt = "CreatedAt"
            case credentialLockerId = "CredentialLockerId"
            case id = "Id"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case parentControllerId = "ParentControllerId"
            case provisioningStatus = "ProvisioningStatus"
            case role = "Role"
            case serialNumber = "SerialNumber"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct NotificationConfigurationSummary: AWSDecodableShape {
        /// The name of the destination for the notification configuration.
        public let destinationName: String?
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType?

        @inlinable
        public init(destinationName: String? = nil, eventType: EventType? = nil) {
            self.destinationName = destinationName
            self.eventType = eventType
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName = "DestinationName"
            case eventType = "EventType"
        }
    }

    public struct OtaTaskAbortConfig: AWSEncodableShape & AWSDecodableShape {
        /// The list of criteria for the abort config.
        public let abortConfigCriteriaList: [AbortConfigCriteria]?

        @inlinable
        public init(abortConfigCriteriaList: [AbortConfigCriteria]? = nil) {
            self.abortConfigCriteriaList = abortConfigCriteriaList
        }

        public func validate(name: String) throws {
            try self.abortConfigCriteriaList?.forEach {
                try $0.validate(name: "\(name).abortConfigCriteriaList[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case abortConfigCriteriaList = "AbortConfigCriteriaList"
        }
    }

    public struct OtaTaskConfigurationSummary: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task configuration was created at.
        public let createdAt: Date?
        /// The name of the over-the-air (OTA) task configuration.
        public let name: String?
        /// The id of the over-the-air (OTA) task configuration
        public let taskConfigurationId: String?

        @inlinable
        public init(createdAt: Date? = nil, name: String? = nil, taskConfigurationId: String? = nil) {
            self.createdAt = createdAt
            self.name = name
            self.taskConfigurationId = taskConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case name = "Name"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }

    public struct OtaTaskExecutionRetryConfig: AWSEncodableShape & AWSDecodableShape {
        /// The list of retry config criteria.
        public let retryConfigCriteria: [RetryConfigCriteria]?

        @inlinable
        public init(retryConfigCriteria: [RetryConfigCriteria]? = nil) {
            self.retryConfigCriteria = retryConfigCriteria
        }

        public func validate(name: String) throws {
            try self.retryConfigCriteria?.forEach {
                try $0.validate(name: "\(name).retryConfigCriteria[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case retryConfigCriteria = "RetryConfigCriteria"
        }
    }

    public struct OtaTaskExecutionRolloutConfig: AWSEncodableShape & AWSDecodableShape {
        /// Structure representing exponential rate of rollout for an over-the-air (OTA) task.
        public let exponentialRolloutRate: ExponentialRolloutRate?
        /// The maximum number of things that will be notified of a pending task, per minute.
        public let maximumPerMinute: Int?

        @inlinable
        public init(exponentialRolloutRate: ExponentialRolloutRate? = nil, maximumPerMinute: Int? = nil) {
            self.exponentialRolloutRate = exponentialRolloutRate
            self.maximumPerMinute = maximumPerMinute
        }

        public func validate(name: String) throws {
            try self.exponentialRolloutRate?.validate(name: "\(name).exponentialRolloutRate")
            try self.validate(self.maximumPerMinute, name: "maximumPerMinute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exponentialRolloutRate = "ExponentialRolloutRate"
            case maximumPerMinute = "MaximumPerMinute"
        }
    }

    public struct OtaTaskExecutionSummaries: AWSDecodableShape {
        /// The id of a managed thing.
        public let managedThingId: String?
        /// Structure representing one over-the-air (OTA) task execution summary
        public let taskExecutionSummary: OtaTaskExecutionSummary?

        @inlinable
        public init(managedThingId: String? = nil, taskExecutionSummary: OtaTaskExecutionSummary? = nil) {
            self.managedThingId = managedThingId
            self.taskExecutionSummary = taskExecutionSummary
        }

        private enum CodingKeys: String, CodingKey {
            case managedThingId = "ManagedThingId"
            case taskExecutionSummary = "TaskExecutionSummary"
        }
    }

    public struct OtaTaskExecutionSummary: AWSDecodableShape {
        /// The execution number of the over-the-air (OTA) task execution summary.
        public let executionNumber: Int64?
        /// The timestamp value of when the over-the-air (OTA) task execution summary was last updated.
        public let lastUpdatedAt: Date?
        /// The timestamp value of when the over-the-air (OTA) task execution summary is targeted to start.
        public let queuedAt: Date?
        /// The number of retry attempts for starting the over-the-air (OTA) task execution summary after a failed attempt.
        public let retryAttempt: Int?
        /// The timestamp value of when the over-the-air (OTA) task execution summary started.
        public let startedAt: Date?
        /// The status of the over-the-air (OTA) task execution summary.
        public let status: OtaTaskExecutionStatus?

        @inlinable
        public init(executionNumber: Int64? = nil, lastUpdatedAt: Date? = nil, queuedAt: Date? = nil, retryAttempt: Int? = nil, startedAt: Date? = nil, status: OtaTaskExecutionStatus? = nil) {
            self.executionNumber = executionNumber
            self.lastUpdatedAt = lastUpdatedAt
            self.queuedAt = queuedAt
            self.retryAttempt = retryAttempt
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case executionNumber = "ExecutionNumber"
            case lastUpdatedAt = "LastUpdatedAt"
            case queuedAt = "QueuedAt"
            case retryAttempt = "RetryAttempt"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct OtaTaskSchedulingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the end behavior for all task executions after a task reaches the selected endTime. If endTime is not selected when creating the task, then endBehavior does not apply.
        public let endBehavior: SchedulingConfigEndBehavior?
        /// The time an over-the-air (OTA) task will stop.
        public let endTime: String?
        /// Maintenance window list for over-the-air (OTA) task scheduling config.
        public let maintenanceWindows: [ScheduleMaintenanceWindow]?
        /// The time an over-the-air (OTA) task will start.
        public let startTime: String?

        @inlinable
        public init(endBehavior: SchedulingConfigEndBehavior? = nil, endTime: String? = nil, maintenanceWindows: [ScheduleMaintenanceWindow]? = nil, startTime: String? = nil) {
            self.endBehavior = endBehavior
            self.endTime = endTime
            self.maintenanceWindows = maintenanceWindows
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.maintenanceWindows?.forEach {
                try $0.validate(name: "\(name).maintenanceWindows[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case endBehavior = "EndBehavior"
            case endTime = "EndTime"
            case maintenanceWindows = "MaintenanceWindows"
            case startTime = "StartTime"
        }
    }

    public struct OtaTaskSummary: AWSDecodableShape {
        /// The timestamp value of when the over-the-air (OTA) task was created at.
        public let createdAt: Date?
        /// The timestamp value of when the over-the-air (OTA) task was last updated at.
        public let lastUpdatedAt: Date?
        /// The status of the over-the-air (OTA) task summary.
        public let status: OtaStatus?
        /// The Amazon Resource Name (ARN) of the over-the-air (OTA) task.
        public let taskArn: String?
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?
        /// The id of the over-the-air (OTA) task.
        public let taskId: String?

        @inlinable
        public init(createdAt: Date? = nil, lastUpdatedAt: Date? = nil, status: OtaStatus? = nil, taskArn: String? = nil, taskConfigurationId: String? = nil, taskId: String? = nil) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.taskArn = taskArn
            self.taskConfigurationId = taskConfigurationId
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case lastUpdatedAt = "LastUpdatedAt"
            case status = "Status"
            case taskArn = "TaskArn"
            case taskConfigurationId = "TaskConfigurationId"
            case taskId = "TaskId"
        }
    }

    public struct OtaTaskTimeoutConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the amount of time the device has to finish execution of this task. The timeout interval can be anywhere between 1 minute and 7 days.
        public let inProgressTimeoutInMinutes: Int64?

        @inlinable
        public init(inProgressTimeoutInMinutes: Int64? = nil) {
            self.inProgressTimeoutInMinutes = inProgressTimeoutInMinutes
        }

        public func validate(name: String) throws {
            try self.validate(self.inProgressTimeoutInMinutes, name: "inProgressTimeoutInMinutes", parent: name, max: 10080)
            try self.validate(self.inProgressTimeoutInMinutes, name: "inProgressTimeoutInMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case inProgressTimeoutInMinutes = "InProgressTimeoutInMinutes"
        }
    }

    public struct ProvisioningProfileSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the provisioning template used in the provisioning profile.
        public let arn: String?
        /// The identifier of the provisioning profile.
        public let id: String?
        /// The name of the provisioning template.
        public let name: String?
        /// The type of provisioning workflow the device uses for onboarding to IoT managed integrations.
        public let provisioningType: ProvisioningType?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil, provisioningType: ProvisioningType? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.provisioningType = provisioningType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case provisioningType = "ProvisioningType"
        }
    }

    public struct PushConfig: AWSEncodableShape & AWSDecodableShape {
        /// Structure representing one abort config.
        public let abortConfig: OtaTaskAbortConfig?
        /// Structure representing one rollout config.
        public let rolloutConfig: OtaTaskExecutionRolloutConfig?
        /// Structure representing one timeout config.
        public let timeoutConfig: OtaTaskTimeoutConfig?

        @inlinable
        public init(abortConfig: OtaTaskAbortConfig? = nil, rolloutConfig: OtaTaskExecutionRolloutConfig? = nil, timeoutConfig: OtaTaskTimeoutConfig? = nil) {
            self.abortConfig = abortConfig
            self.rolloutConfig = rolloutConfig
            self.timeoutConfig = timeoutConfig
        }

        public func validate(name: String) throws {
            try self.abortConfig?.validate(name: "\(name).abortConfig")
            try self.rolloutConfig?.validate(name: "\(name).rolloutConfig")
            try self.timeoutConfig?.validate(name: "\(name).timeoutConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case abortConfig = "AbortConfig"
            case rolloutConfig = "RolloutConfig"
            case timeoutConfig = "TimeoutConfig"
        }
    }

    public struct PutDefaultEncryptionConfigurationRequest: AWSEncodableShape {
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 200)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 1)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[0-9a-zA-Z-]+:[0-9]+:key/[0-9a-zA-Z-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct PutDefaultEncryptionConfigurationResponse: AWSDecodableShape {
        /// Provides the status of the default encryption configuration for an Amazon Web Services account.
        public let configurationStatus: ConfigurationStatus
        /// The type of encryption used for the encryption configuration.
        public let encryptionType: EncryptionType
        /// The Key Amazon Resource Name (ARN) of the AWS KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
        public let kmsKeyArn: String?

        @inlinable
        public init(configurationStatus: ConfigurationStatus, encryptionType: EncryptionType, kmsKeyArn: String? = nil) {
            self.configurationStatus = configurationStatus
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case configurationStatus = "configurationStatus"
            case encryptionType = "encryptionType"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct PutHubConfigurationRequest: AWSEncodableShape {
        /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
        public let hubTokenTimerExpirySettingInSeconds: Int64

        @inlinable
        public init(hubTokenTimerExpirySettingInSeconds: Int64) {
            self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
        }

        public func validate(name: String) throws {
            try self.validate(self.hubTokenTimerExpirySettingInSeconds, name: "hubTokenTimerExpirySettingInSeconds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hubTokenTimerExpirySettingInSeconds = "HubTokenTimerExpirySettingInSeconds"
        }
    }

    public struct PutHubConfigurationResponse: AWSDecodableShape {
        /// A user-defined integer value that represents the hub token timer expiry setting in seconds.
        public let hubTokenTimerExpirySettingInSeconds: Int64?

        @inlinable
        public init(hubTokenTimerExpirySettingInSeconds: Int64? = nil) {
            self.hubTokenTimerExpirySettingInSeconds = hubTokenTimerExpirySettingInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case hubTokenTimerExpirySettingInSeconds = "HubTokenTimerExpirySettingInSeconds"
        }
    }

    public struct PutRuntimeLogConfigurationRequest: AWSEncodableShape {
        /// The id for a managed thing.
        public let managedThingId: String
        /// The runtime log configuration for a managed thing.
        public let runtimeLogConfigurations: RuntimeLogConfigurations

        @inlinable
        public init(managedThingId: String, runtimeLogConfigurations: RuntimeLogConfigurations) {
            self.managedThingId = managedThingId
            self.runtimeLogConfigurations = runtimeLogConfigurations
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
            try container.encode(self.runtimeLogConfigurations, forKey: .runtimeLogConfigurations)
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case runtimeLogConfigurations = "RuntimeLogConfigurations"
        }
    }

    public struct RegisterCustomEndpointRequest: AWSEncodableShape {
        public init() {}
    }

    public struct RegisterCustomEndpointResponse: AWSDecodableShape {
        /// The IoT managed integrations dedicated, custom endpoint for the device to route traffic through.
        public let endpointAddress: String

        @inlinable
        public init(endpointAddress: String) {
            self.endpointAddress = endpointAddress
        }

        private enum CodingKeys: String, CodingKey {
            case endpointAddress = "EndpointAddress"
        }
    }

    public struct ResetRuntimeLogConfigurationRequest: AWSEncodableShape {
        /// The id of a managed thing.
        public let managedThingId: String

        @inlinable
        public init(managedThingId: String) {
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RetryConfigCriteria: AWSEncodableShape & AWSDecodableShape {
        /// Over-the-air (OTA) retry criteria failure type.
        public let failureType: RetryCriteriaFailureType?
        /// The number of retries allowed for a failure type for the over-the-air (OTA) task.
        public let minNumberOfRetries: Int?

        @inlinable
        public init(failureType: RetryCriteriaFailureType? = nil, minNumberOfRetries: Int? = nil) {
            self.failureType = failureType
            self.minNumberOfRetries = minNumberOfRetries
        }

        public func validate(name: String) throws {
            try self.validate(self.minNumberOfRetries, name: "minNumberOfRetries", parent: name, max: 10)
            try self.validate(self.minNumberOfRetries, name: "minNumberOfRetries", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case failureType = "FailureType"
            case minNumberOfRetries = "MinNumberOfRetries"
        }
    }

    public struct RolloutRateIncreaseCriteria: AWSEncodableShape & AWSDecodableShape {
        /// The threshold for number of notified things that will initiate the increase in rate of rollout.
        public let numberOfNotifiedThings: Int?
        /// The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        public let numberOfSucceededThings: Int?

        @inlinable
        public init(numberOfNotifiedThings: Int? = nil, numberOfSucceededThings: Int? = nil) {
            self.numberOfNotifiedThings = numberOfNotifiedThings
            self.numberOfSucceededThings = numberOfSucceededThings
        }

        public func validate(name: String) throws {
            try self.validate(self.numberOfNotifiedThings, name: "numberOfNotifiedThings", parent: name, max: 100)
            try self.validate(self.numberOfNotifiedThings, name: "numberOfNotifiedThings", parent: name, min: 1)
            try self.validate(self.numberOfSucceededThings, name: "numberOfSucceededThings", parent: name, max: 100)
            try self.validate(self.numberOfSucceededThings, name: "numberOfSucceededThings", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfNotifiedThings = "numberOfNotifiedThings"
            case numberOfSucceededThings = "numberOfSucceededThings"
        }
    }

    public struct RuntimeLogConfigurations: AWSEncodableShape & AWSDecodableShape {
        /// Configuration to enable or disable deleting of runtime logs in the device once uploaded to the cloud.
        public let deleteLocalStoreAfterUpload: Bool?
        /// Configuration to set the maximum bytes of runtime logs that can be stored on the device before the oldest logs are deleted or overwritten.
        public let localStoreFileRotationMaxBytes: Int?
        /// Configuration to set the maximum number of runtime log files that can be stored on the device before the oldest files are deleted or overwritten.
        public let localStoreFileRotationMaxFiles: Int?
        /// Configuration of where to store runtime logs in the device.
        public let localStoreLocation: String?
        /// The different log levels available for configuration.
        public let logFlushLevel: LogLevel?
        /// The different log levels available for configuration.
        public let logLevel: LogLevel?
        /// Configuration to enable or disable uploading of runtime logs to the cloud.
        public let uploadLog: Bool?
        /// Configuration to set the time interval in minutes between each batch of runtime logs that the device uploads to the cloud.
        public let uploadPeriodMinutes: Int?

        @inlinable
        public init(deleteLocalStoreAfterUpload: Bool? = nil, localStoreFileRotationMaxBytes: Int? = nil, localStoreFileRotationMaxFiles: Int? = nil, localStoreLocation: String? = nil, logFlushLevel: LogLevel? = nil, logLevel: LogLevel? = nil, uploadLog: Bool? = nil, uploadPeriodMinutes: Int? = nil) {
            self.deleteLocalStoreAfterUpload = deleteLocalStoreAfterUpload
            self.localStoreFileRotationMaxBytes = localStoreFileRotationMaxBytes
            self.localStoreFileRotationMaxFiles = localStoreFileRotationMaxFiles
            self.localStoreLocation = localStoreLocation
            self.logFlushLevel = logFlushLevel
            self.logLevel = logLevel
            self.uploadLog = uploadLog
            self.uploadPeriodMinutes = uploadPeriodMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case deleteLocalStoreAfterUpload = "DeleteLocalStoreAfterUpload"
            case localStoreFileRotationMaxBytes = "LocalStoreFileRotationMaxBytes"
            case localStoreFileRotationMaxFiles = "LocalStoreFileRotationMaxFiles"
            case localStoreLocation = "LocalStoreLocation"
            case logFlushLevel = "LogFlushLevel"
            case logLevel = "LogLevel"
            case uploadLog = "UploadLog"
            case uploadPeriodMinutes = "UploadPeriodMinutes"
        }
    }

    public struct ScheduleMaintenanceWindow: AWSEncodableShape & AWSDecodableShape {
        /// Displays the duration of the next maintenance window.
        public let durationInMinutes: Int?
        /// Displays the start time of the next maintenance window.
        public let startTime: String?

        @inlinable
        public init(durationInMinutes: Int? = nil, startTime: String? = nil) {
            self.durationInMinutes = durationInMinutes
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.validate(self.durationInMinutes, name: "durationInMinutes", parent: name, max: 1430)
            try self.validate(self.durationInMinutes, name: "durationInMinutes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case durationInMinutes = "DurationInMinutes"
            case startTime = "StartTime"
        }
    }

    public struct SchemaVersionListItem: AWSDecodableShape {
        /// A description of the schema version.
        public let description: String?
        /// The name of the schema version.
        public let namespace: String?
        /// The identifier of the schema version.
        public let schemaId: String?
        /// The schema version. If this is left blank, it defaults to the latest version.
        public let semanticVersion: String?
        /// The type of schema version.
        public let type: SchemaVersionType?
        /// The visibility of the schema version.
        public let visibility: SchemaVersionVisibility?

        @inlinable
        public init(description: String? = nil, namespace: String? = nil, schemaId: String? = nil, semanticVersion: String? = nil, type: SchemaVersionType? = nil, visibility: SchemaVersionVisibility? = nil) {
            self.description = description
            self.namespace = namespace
            self.schemaId = schemaId
            self.semanticVersion = semanticVersion
            self.type = type
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case namespace = "Namespace"
            case schemaId = "SchemaId"
            case semanticVersion = "SemanticVersion"
            case type = "Type"
            case visibility = "Visibility"
        }
    }

    public struct SendManagedThingCommandRequest: AWSEncodableShape {
        /// The ID tracking the current discovery process for one connector association.
        public let connectorAssociationId: String?
        /// The device endpoint.
        public let endpoints: [CommandEndpoint]
        /// The id of the device.
        public let managedThingId: String

        @inlinable
        public init(connectorAssociationId: String? = nil, endpoints: [CommandEndpoint], managedThingId: String) {
            self.connectorAssociationId = connectorAssociationId
            self.endpoints = endpoints
            self.managedThingId = managedThingId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.connectorAssociationId, forKey: .connectorAssociationId)
            try container.encode(self.endpoints, forKey: .endpoints)
            request.encodePath(self.managedThingId, key: "ManagedThingId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectorAssociationId, name: "connectorAssociationId", parent: name, max: 64)
            try self.validate(self.connectorAssociationId, name: "connectorAssociationId", parent: name, min: 1)
            try self.validate(self.connectorAssociationId, name: "connectorAssociationId", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.endpoints.forEach {
                try $0.validate(name: "\(name).endpoints[]")
            }
            try self.validate(self.endpoints, name: "endpoints", parent: name, max: 5)
            try self.validate(self.endpoints, name: "endpoints", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, max: 64)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, min: 1)
            try self.validate(self.managedThingId, name: "managedThingId", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case connectorAssociationId = "ConnectorAssociationId"
            case endpoints = "Endpoints"
        }
    }

    public struct SendManagedThingCommandResponse: AWSDecodableShape {
        /// The trace request identifier. This is specified by the device owner, but will be generated by IoT managed integrations if not provided by the device owner.
        public let traceId: String?

        @inlinable
        public init(traceId: String? = nil) {
            self.traceId = traceId
        }

        private enum CodingKeys: String, CodingKey {
            case traceId = "TraceId"
        }
    }

    public struct StartDeviceDiscoveryRequest: AWSEncodableShape {
        /// The authentication material required to start the local device discovery job request.
        public let authenticationMaterial: String?
        /// The type of authentication material used for device discovery jobs.
        public let authenticationMaterialType: DiscoveryAuthMaterialType?
        /// An idempotency token. If you retry a request that completed successfully initially using the same client token and parameters, then the retry attempt will succeed without performing any further actions.
        public let clientToken: String?
        /// The id of the connector association.
        public let connectorAssociationIdentifier: String?
        /// The id of the end-user's IoT hub.
        public let controllerIdentifier: String?
        /// The discovery type supporting the type of device to be discovered in the device discovery job request.
        public let discoveryType: DiscoveryType
        /// A set of key/value pairs that are used to manage the device discovery request.
        public let tags: [String: String]?

        @inlinable
        public init(authenticationMaterial: String? = nil, authenticationMaterialType: DiscoveryAuthMaterialType? = nil, clientToken: String? = nil, connectorAssociationIdentifier: String? = nil, controllerIdentifier: String? = nil, discoveryType: DiscoveryType, tags: [String: String]? = nil) {
            self.authenticationMaterial = authenticationMaterial
            self.authenticationMaterialType = authenticationMaterialType
            self.clientToken = clientToken
            self.connectorAssociationIdentifier = connectorAssociationIdentifier
            self.controllerIdentifier = controllerIdentifier
            self.discoveryType = discoveryType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, max: 64)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, min: 1)
            try self.validate(self.authenticationMaterial, name: "authenticationMaterial", parent: name, pattern: "^[0-9A-Za-z_\\-\\+=\\/:; ]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[a-zA-Z0-9=_-]+$")
            try self.validate(self.connectorAssociationIdentifier, name: "connectorAssociationIdentifier", parent: name, max: 64)
            try self.validate(self.connectorAssociationIdentifier, name: "connectorAssociationIdentifier", parent: name, min: 1)
            try self.validate(self.connectorAssociationIdentifier, name: "connectorAssociationIdentifier", parent: name, pattern: "^[0-9a-zA-Z]+$")
            try self.validate(self.controllerIdentifier, name: "controllerIdentifier", parent: name, max: 64)
            try self.validate(self.controllerIdentifier, name: "controllerIdentifier", parent: name, min: 1)
            try self.validate(self.controllerIdentifier, name: "controllerIdentifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationMaterial = "AuthenticationMaterial"
            case authenticationMaterialType = "AuthenticationMaterialType"
            case clientToken = "ClientToken"
            case connectorAssociationIdentifier = "ConnectorAssociationIdentifier"
            case controllerIdentifier = "ControllerIdentifier"
            case discoveryType = "DiscoveryType"
            case tags = "Tags"
        }
    }

    public struct StartDeviceDiscoveryResponse: AWSDecodableShape {
        /// The id of the device discovery job request.
        public let id: String?
        /// The timestamp value for the start time of the device discovery.
        public let startedAt: Date?

        @inlinable
        public init(id: String? = nil, startedAt: Date? = nil) {
            self.id = id
            self.startedAt = startedAt
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case startedAt = "StartedAt"
        }
    }

    public struct StateCapability: AWSDecodableShape {
        /// The id of the managed thing in the capability report.
        public let id: String
        /// Name for the Amazon Web Services capability.
        public let name: String
        /// Describe the command capability with the properties it supports.
        public let properties: AWSDocument?
        /// Version for the Amazon Web Services capability.
        public let version: String

        @inlinable
        public init(id: String, name: String, properties: AWSDocument? = nil, version: String) {
            self.id = id
            self.name = name
            self.properties = properties
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case properties = "properties"
            case version = "version"
        }
    }

    public struct StateEndpoint: AWSDecodableShape {
        /// Describe the endpoint with an id, a name, and the relevant capabilities for the reporting state.
        public let capabilities: [StateCapability]
        /// Numeric identifier of the endpoint
        public let endpointId: String

        @inlinable
        public init(capabilities: [StateCapability], endpointId: String) {
            self.capabilities = capabilities
            self.endpointId = endpointId
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "capabilities"
            case endpointId = "endpointId"
        }
    }

    public struct TaskProcessingDetails: AWSDecodableShape {
        /// The number of canceled things in an over-the-air (OTA) task.
        public let numberOfCanceledThings: Int?
        /// The number of failed things in an over-the-air (OTA) task.
        public let numberOfFailedThings: Int?
        /// The number of in progress things in an over-the-air (OTA) task.
        public let numberOfInProgressThings: Int?
        /// The number of queued things in an over-the-air (OTA) task.
        public let numberOfQueuedThings: Int?
        /// The number of rejected things in an over-the-air (OTA) task.
        public let numberOfRejectedThings: Int?
        /// The number of removed things in an over-the-air (OTA) task.
        public let numberOfRemovedThings: Int?
        /// The number of succeeded things in an over-the-air (OTA) task.
        public let numberOfSucceededThings: Int?
        /// The number of timed out things in an over-the-air (OTA) task.
        public let numberOfTimedOutThings: Int?
        /// The targets of the over-the-air (OTA) task.
        public let processingTargets: [String]?

        @inlinable
        public init(numberOfCanceledThings: Int? = nil, numberOfFailedThings: Int? = nil, numberOfInProgressThings: Int? = nil, numberOfQueuedThings: Int? = nil, numberOfRejectedThings: Int? = nil, numberOfRemovedThings: Int? = nil, numberOfSucceededThings: Int? = nil, numberOfTimedOutThings: Int? = nil, processingTargets: [String]? = nil) {
            self.numberOfCanceledThings = numberOfCanceledThings
            self.numberOfFailedThings = numberOfFailedThings
            self.numberOfInProgressThings = numberOfInProgressThings
            self.numberOfQueuedThings = numberOfQueuedThings
            self.numberOfRejectedThings = numberOfRejectedThings
            self.numberOfRemovedThings = numberOfRemovedThings
            self.numberOfSucceededThings = numberOfSucceededThings
            self.numberOfTimedOutThings = numberOfTimedOutThings
            self.processingTargets = processingTargets
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfCanceledThings = "NumberOfCanceledThings"
            case numberOfFailedThings = "NumberOfFailedThings"
            case numberOfInProgressThings = "NumberOfInProgressThings"
            case numberOfQueuedThings = "numberOfQueuedThings"
            case numberOfRejectedThings = "numberOfRejectedThings"
            case numberOfRemovedThings = "numberOfRemovedThings"
            case numberOfSucceededThings = "numberOfSucceededThings"
            case numberOfTimedOutThings = "numberOfTimedOutThings"
            case processingTargets = "processingTargets"
        }
    }

    public struct UpdateDestinationRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the customer-managed destination.
        public let deliveryDestinationArn: String?
        /// The destination type for the customer-managed destination.
        public let deliveryDestinationType: DeliveryDestinationType?
        /// The description of the customer-managed destination.
        public let description: String?
        /// The name of the customer-managed destination.
        public let name: String
        /// The Amazon Resource Name (ARN) of the delivery destination role.
        public let roleArn: String?

        @inlinable
        public init(deliveryDestinationArn: String? = nil, deliveryDestinationType: DeliveryDestinationType? = nil, description: String? = nil, name: String, roleArn: String? = nil) {
            self.deliveryDestinationArn = deliveryDestinationArn
            self.deliveryDestinationType = deliveryDestinationType
            self.description = description
            self.name = name
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deliveryDestinationArn, forKey: .deliveryDestinationArn)
            try container.encodeIfPresent(self.deliveryDestinationType, forKey: .deliveryDestinationType)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, max: 2048)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, min: 20)
            try self.validate(self.deliveryDestinationArn, name: "deliveryDestinationArn", parent: name, pattern: "^arn:aws:[0-9a-zA-Z]+:[0-9a-zA-Z-]+:[0-9]+:[0-9a-zA-Z]+/[0-9a-zA-Z._-]+$")
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deliveryDestinationArn = "DeliveryDestinationArn"
            case deliveryDestinationType = "DeliveryDestinationType"
            case description = "Description"
            case roleArn = "RoleArn"
        }
    }

    public struct UpdateEventLogConfigurationRequest: AWSEncodableShape {
        /// The log level for the event in terms of severity.
        public let eventLogLevel: LogLevel
        /// The log configuration id.
        public let id: String

        @inlinable
        public init(eventLogLevel: LogLevel, id: String) {
            self.eventLogLevel = eventLogLevel
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.eventLogLevel, forKey: .eventLogLevel)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 200)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventLogLevel = "EventLogLevel"
        }
    }

    public struct UpdateManagedThingRequest: AWSEncodableShape {
        /// The brand of the device.
        public let brand: String?
        /// The capabilities of the device such as light bulb.
        public let capabilities: String?
        /// A report of the capabilities for the managed thing.
        public let capabilityReport: CapabilityReport?
        /// The classification of the managed thing such as light bulb or thermostat.
        public let classification: String?
        /// The identifier of the credential for the managed thing.
        public let credentialLockerId: String?
        /// The network mode for the hub-connected device.
        public let hubNetworkMode: HubNetworkMode?
        /// The id of the managed thing.
        public let identifier: String
        /// The metadata for the managed thing.
        public let metaData: [String: String]?
        /// The model of the device.
        public let model: String?
        /// The name of the managed thing representing the physical device.
        public let name: String?
        /// Owner of the device, usually an indication of whom the device belongs to. This value should not contain personal identifiable information.
        public let owner: String?
        /// The serial number of the device.
        public let serialNumber: String?

        @inlinable
        public init(brand: String? = nil, capabilities: String? = nil, capabilityReport: CapabilityReport? = nil, classification: String? = nil, credentialLockerId: String? = nil, hubNetworkMode: HubNetworkMode? = nil, identifier: String, metaData: [String: String]? = nil, model: String? = nil, name: String? = nil, owner: String? = nil, serialNumber: String? = nil) {
            self.brand = brand
            self.capabilities = capabilities
            self.capabilityReport = capabilityReport
            self.classification = classification
            self.credentialLockerId = credentialLockerId
            self.hubNetworkMode = hubNetworkMode
            self.identifier = identifier
            self.metaData = metaData
            self.model = model
            self.name = name
            self.owner = owner
            self.serialNumber = serialNumber
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.brand, forKey: .brand)
            try container.encodeIfPresent(self.capabilities, forKey: .capabilities)
            try container.encodeIfPresent(self.capabilityReport, forKey: .capabilityReport)
            try container.encodeIfPresent(self.classification, forKey: .classification)
            try container.encodeIfPresent(self.credentialLockerId, forKey: .credentialLockerId)
            try container.encodeIfPresent(self.hubNetworkMode, forKey: .hubNetworkMode)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.metaData, forKey: .metaData)
            try container.encodeIfPresent(self.model, forKey: .model)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.owner, forKey: .owner)
            try container.encodeIfPresent(self.serialNumber, forKey: .serialNumber)
        }

        public func validate(name: String) throws {
            try self.validate(self.brand, name: "brand", parent: name, max: 128)
            try self.validate(self.brand, name: "brand", parent: name, min: 1)
            try self.validate(self.brand, name: "brand", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.capabilities, name: "capabilities", parent: name, max: 65535)
            try self.validate(self.capabilities, name: "capabilities", parent: name, min: 1)
            try self.validate(self.capabilities, name: "capabilities", parent: name, pattern: "^[a-zA-Z0-9\\s'\\x{0022},.:\\\\\\/{$}\\[\\]=_\\-\\+]+$")
            try self.capabilityReport?.validate(name: "\(name).capabilityReport")
            try self.validate(self.classification, name: "classification", parent: name, max: 64)
            try self.validate(self.classification, name: "classification", parent: name, min: 1)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, max: 64)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, min: 1)
            try self.validate(self.credentialLockerId, name: "credentialLockerId", parent: name, pattern: "^[a-zA-Z0-9]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 64)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[a-zA-Z0-9:_-]*$")
            try self.metaData?.forEach {
                try validate($0.key, name: "metaData.key", parent: name, max: 128)
                try validate($0.key, name: "metaData.key", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]+")
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, max: 800)
                try validate($0.value, name: "metaData[\"\($0.key)\"]", parent: name, pattern: "[a-zA-Z0-9_.,@/:#-]*")
            }
            try self.validate(self.metaData, name: "metaData", parent: name, max: 50)
            try self.validate(self.metaData, name: "metaData", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, max: 128)
            try self.validate(self.model, name: "model", parent: name, min: 1)
            try self.validate(self.model, name: "model", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
            try self.validate(self.owner, name: "owner", parent: name, max: 64)
            try self.validate(self.owner, name: "owner", parent: name, min: 1)
            try self.validate(self.owner, name: "owner", parent: name, pattern: "^[a-zA-Z0-9_.,@-]+$")
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, max: 128)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, min: 1)
            try self.validate(self.serialNumber, name: "serialNumber", parent: name, pattern: "^[A-Za-z0-9-_ ]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case brand = "Brand"
            case capabilities = "Capabilities"
            case capabilityReport = "CapabilityReport"
            case classification = "Classification"
            case credentialLockerId = "CredentialLockerId"
            case hubNetworkMode = "HubNetworkMode"
            case metaData = "MetaData"
            case model = "Model"
            case name = "Name"
            case owner = "Owner"
            case serialNumber = "SerialNumber"
        }
    }

    public struct UpdateNotificationConfigurationRequest: AWSEncodableShape {
        /// The name of the destination for the notification configuration.
        public let destinationName: String
        /// The type of event triggering a device notification to the customer-managed destination.
        public let eventType: EventType

        @inlinable
        public init(destinationName: String, eventType: EventType) {
            self.destinationName = destinationName
            self.eventType = eventType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.destinationName, forKey: .destinationName)
            request.encodePath(self.eventType, key: "EventType")
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationName, name: "destinationName", parent: name, max: 128)
            try self.validate(self.destinationName, name: "destinationName", parent: name, min: 1)
            try self.validate(self.destinationName, name: "destinationName", parent: name, pattern: "^[\\p{L}\\p{N} ._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationName = "DestinationName"
        }
    }

    public struct UpdateOtaTaskRequest: AWSEncodableShape {
        /// The description of the over-the-air (OTA) task.
        public let description: String?
        /// The over-the-air (OTA) task id.
        public let identifier: String
        /// The identifier for the over-the-air (OTA) task configuration.
        public let taskConfigurationId: String?

        @inlinable
        public init(description: String? = nil, identifier: String, taskConfigurationId: String? = nil) {
            self.description = description
            self.identifier = identifier
            self.taskConfigurationId = taskConfigurationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.taskConfigurationId, forKey: .taskConfigurationId)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[0-9A-Za-z_\\- ]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^[A-Za-z0-9]+$")
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, max: 64)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, min: 1)
            try self.validate(self.taskConfigurationId, name: "taskConfigurationId", parent: name, pattern: "^[a-zA-Z0-9]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case taskConfigurationId = "TaskConfigurationId"
        }
    }
}

// MARK: - Errors

/// Error enum for IoTManagedIntegrations
public struct IoTManagedIntegrationsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalFailureException = "InternalFailureException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttlingException = "ThrottlingException"
        case unauthorizedException = "UnauthorizedException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize IoTManagedIntegrations
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// User is not authorized.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// There is a conflict with the request.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error has occurred.
    public static var internalFailureException: Self { .init(.internalFailureException) }
    /// Internal error from the service that indicates an unexpected error or that the service is unavailable.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service quota has been exceeded for this request.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The service is temporarily unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The rate exceeds the limit.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// You are not authorized to perform this operation.
    public static var unauthorizedException: Self { .init(.unauthorizedException) }
    /// A validation error occurred when performing the API request.
    public static var validationException: Self { .init(.validationException) }
}

extension IoTManagedIntegrationsErrorType: Equatable {
    public static func == (lhs: IoTManagedIntegrationsErrorType, rhs: IoTManagedIntegrationsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension IoTManagedIntegrationsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
