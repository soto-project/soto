//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension LaunchWizard {
    // MARK: Enums

    public enum DeploymentFilterKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deploymentStatus = "DEPLOYMENT_STATUS"
        case workloadName = "WORKLOAD_NAME"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteInitiating = "DELETE_INITIATING"
        case deleted = "DELETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum EventStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case canceling = "CANCELING"
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadDeploymentPatternStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateDeploymentInput: AWSEncodableShape {
        /// The name of the deployment pattern supported by a given workload. You can use the  ListWorkloadDeploymentPatterns operation to discover supported values for this parameter.
        public let deploymentPatternName: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The name of the deployment.
        public let name: String
        /// The settings specified for the deployment. These settings define how to deploy and configure your resources created by the deployment. For more information about the specifications required for creating a deployment for a SAP workload, see SAP deployment specifications. To retrieve the specifications required to create a deployment for other workloads, use the  GetWorkloadDeploymentPattern operation.
        public let specifications: [String: String]
        /// The tags to add to the deployment.
        public let tags: [String: String]?
        /// The name of the workload. You can use the  ListWorkloads operation to discover supported values for this parameter.
        public let workloadName: String

        @inlinable
        public init(deploymentPatternName: String, dryRun: Bool? = nil, name: String, specifications: [String: String], tags: [String: String]? = nil, workloadName: String) {
            self.deploymentPatternName = deploymentPatternName
            self.dryRun = dryRun
            self.name = name
            self.specifications = specifications
            self.tags = tags
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, max: 256)
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, min: 1)
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, pattern: "^[A-Za-z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_\\.-]+$")
            try self.specifications.forEach {
                try validate($0.key, name: "specifications.key", parent: name, max: 256)
                try validate($0.key, name: "specifications.key", parent: name, min: 3)
                try validate($0.key, name: "specifications.key", parent: name, pattern: "^[a-zA-Z0-9-:]+$")
                try validate($0.value, name: "specifications[\"\($0.key)\"]", parent: name, max: 1500)
                try validate($0.value, name: "specifications[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.specifications, name: "specifications", parent: name, max: 100)
            try self.validate(self.specifications, name: "specifications", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 100)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentPatternName = "deploymentPatternName"
            case dryRun = "dryRun"
            case name = "name"
            case specifications = "specifications"
            case tags = "tags"
            case workloadName = "workloadName"
        }
    }

    public struct CreateDeploymentOutput: AWSDecodableShape {
        /// The ID of the deployment.
        public let deploymentId: String?

        @inlinable
        public init(deploymentId: String? = nil) {
            self.deploymentId = deploymentId
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
        }
    }

    public struct DeleteDeploymentInput: AWSEncodableShape {
        /// The ID of the deployment.
        public let deploymentId: String

        @inlinable
        public init(deploymentId: String) {
            self.deploymentId = deploymentId
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, max: 128)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, min: 2)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
        }
    }

    public struct DeleteDeploymentOutput: AWSDecodableShape {
        /// The status of the deployment.
        public let status: DeploymentStatus?
        /// The reason for the deployment status.
        public let statusReason: String?

        @inlinable
        public init(status: DeploymentStatus? = nil, statusReason: String? = nil) {
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct DeploymentConditionalField: AWSDecodableShape {
        /// The comparator of the condition. Valid values: Equal | NotEqual
        public let comparator: String?
        /// The name of the deployment condition.
        public let name: String?
        /// The value of the condition.
        public let value: String?

        @inlinable
        public init(comparator: String? = nil, name: String? = nil, value: String? = nil) {
            self.comparator = comparator
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparator = "comparator"
            case name = "name"
            case value = "value"
        }
    }

    public struct DeploymentData: AWSDecodableShape {
        /// The time the deployment was created.
        public let createdAt: Date?
        /// The time the deployment was deleted.
        public let deletedAt: Date?
        /// The Amazon Resource Name (ARN) of the deployment.
        public let deploymentArn: String?
        /// The ID of the deployment.
        public let id: String?
        /// The name of the deployment.
        public let name: String?
        /// The pattern name of the deployment.
        public let patternName: String?
        /// The resource group of the deployment.
        public let resourceGroup: String?
        /// The settings specified for the deployment. These settings define how to deploy and configure your resources created by the deployment. For more information about the specifications required for creating a deployment for a SAP workload, see SAP deployment specifications. To retrieve the specifications required to create a deployment for other workloads, use the  GetWorkloadDeploymentPattern operation.
        public let specifications: [String: String]?
        /// The status of the deployment.
        public let status: DeploymentStatus?
        /// Information about the tags attached to a deployment.
        public let tags: [String: String]?
        /// The name of the workload.
        public let workloadName: String?

        @inlinable
        public init(createdAt: Date? = nil, deletedAt: Date? = nil, deploymentArn: String? = nil, id: String? = nil, name: String? = nil, patternName: String? = nil, resourceGroup: String? = nil, specifications: [String: String]? = nil, status: DeploymentStatus? = nil, tags: [String: String]? = nil, workloadName: String? = nil) {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.deploymentArn = deploymentArn
            self.id = id
            self.name = name
            self.patternName = patternName
            self.resourceGroup = resourceGroup
            self.specifications = specifications
            self.status = status
            self.tags = tags
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case deletedAt = "deletedAt"
            case deploymentArn = "deploymentArn"
            case id = "id"
            case name = "name"
            case patternName = "patternName"
            case resourceGroup = "resourceGroup"
            case specifications = "specifications"
            case status = "status"
            case tags = "tags"
            case workloadName = "workloadName"
        }
    }

    public struct DeploymentDataSummary: AWSDecodableShape {
        /// The time the deployment was created.
        public let createdAt: Date?
        /// The ID of the deployment.
        public let id: String?
        /// The name of the deployment
        public let name: String?
        /// The name of the workload deployment pattern.
        public let patternName: String?
        /// The status of the deployment.
        public let status: DeploymentStatus?
        /// The name of the workload.
        public let workloadName: String?

        @inlinable
        public init(createdAt: Date? = nil, id: String? = nil, name: String? = nil, patternName: String? = nil, status: DeploymentStatus? = nil, workloadName: String? = nil) {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.status = status
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case id = "id"
            case name = "name"
            case patternName = "patternName"
            case status = "status"
            case workloadName = "workloadName"
        }
    }

    public struct DeploymentEventDataSummary: AWSDecodableShape {
        /// The description of the deployment event.
        public let description: String?
        /// The name of the deployment event.
        public let name: String?
        /// The status of the deployment event.
        public let status: EventStatus?
        /// The reason of the deployment event status.
        public let statusReason: String?
        /// The timestamp of the deployment event.
        public let timestamp: Date?

        @inlinable
        public init(description: String? = nil, name: String? = nil, status: EventStatus? = nil, statusReason: String? = nil, timestamp: Date? = nil) {
            self.description = description
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case timestamp = "timestamp"
        }
    }

    public struct DeploymentFilter: AWSEncodableShape {
        /// The name of the filter. Filter names are case-sensitive.
        public let name: DeploymentFilterKey?
        /// The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
        public let values: [String]?

        @inlinable
        public init(name: DeploymentFilterKey? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct DeploymentSpecificationsField: AWSDecodableShape {
        /// The allowed values of the deployment specification.
        public let allowedValues: [String]?
        /// The conditionals used for the deployment specification.
        public let conditionals: [DeploymentConditionalField]?
        /// The description of the deployment specification.
        public let description: String?
        /// The name of the deployment specification.
        public let name: String?
        /// Indicates if the deployment specification is required.
        public let required: String?

        @inlinable
        public init(allowedValues: [String]? = nil, conditionals: [DeploymentConditionalField]? = nil, description: String? = nil, name: String? = nil, required: String? = nil) {
            self.allowedValues = allowedValues
            self.conditionals = conditionals
            self.description = description
            self.name = name
            self.required = required
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case conditionals = "conditionals"
            case description = "description"
            case name = "name"
            case required = "required"
        }
    }

    public struct GetDeploymentInput: AWSEncodableShape {
        /// The ID of the deployment.
        public let deploymentId: String

        @inlinable
        public init(deploymentId: String) {
            self.deploymentId = deploymentId
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, max: 128)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, min: 2)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
        }
    }

    public struct GetDeploymentOutput: AWSDecodableShape {
        /// An object that details the deployment.
        public let deployment: DeploymentData?

        @inlinable
        public init(deployment: DeploymentData? = nil) {
            self.deployment = deployment
        }

        private enum CodingKeys: String, CodingKey {
            case deployment = "deployment"
        }
    }

    public struct GetWorkloadDeploymentPatternInput: AWSEncodableShape {
        /// The name of the deployment pattern.
        public let deploymentPatternName: String
        /// The name of the workload.
        public let workloadName: String

        @inlinable
        public init(deploymentPatternName: String, workloadName: String) {
            self.deploymentPatternName = deploymentPatternName
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, max: 256)
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, min: 1)
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, pattern: "^[A-Za-z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 100)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentPatternName = "deploymentPatternName"
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadDeploymentPatternOutput: AWSDecodableShape {
        /// Details about the workload deployment pattern.
        public let workloadDeploymentPattern: WorkloadDeploymentPatternData?

        @inlinable
        public init(workloadDeploymentPattern: WorkloadDeploymentPatternData? = nil) {
            self.workloadDeploymentPattern = workloadDeploymentPattern
        }

        private enum CodingKeys: String, CodingKey {
            case workloadDeploymentPattern = "workloadDeploymentPattern"
        }
    }

    public struct GetWorkloadInput: AWSEncodableShape {
        /// The name of the workload.
        public let workloadName: String

        @inlinable
        public init(workloadName: String) {
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 100)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadOutput: AWSDecodableShape {
        /// Information about the workload.
        public let workload: WorkloadData?

        @inlinable
        public init(workload: WorkloadData? = nil) {
            self.workload = workload
        }

        private enum CodingKeys: String, CodingKey {
            case workload = "workload"
        }
    }

    public struct ListDeploymentEventsInput: AWSEncodableShape {
        /// The ID of the deployment.
        public let deploymentId: String
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(deploymentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.deploymentId = deploymentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, max: 128)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, min: 2)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentEventsOutput: AWSDecodableShape {
        /// Lists the deployment events.
        public let deploymentEvents: [DeploymentEventDataSummary]?
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(deploymentEvents: [DeploymentEventDataSummary]? = nil, nextToken: String? = nil) {
            self.deploymentEvents = deploymentEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentEvents = "deploymentEvents"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentsInput: AWSEncodableShape {
        /// Filters to scope the results. The following filters are supported:    WORKLOAD_NAME - The name used in deployments.    DEPLOYMENT_STATUS - COMPLETED | CREATING | DELETE_IN_PROGRESS | DELETE_INITIATING | DELETE_FAILED | DELETED | FAILED | IN_PROGRESS | VALIDATING
        public let filters: [DeploymentFilter]?
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(filters: [DeploymentFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentsOutput: AWSDecodableShape {
        /// Lists the deployments.
        public let deployments: [DeploymentDataSummary]?
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        @inlinable
        public init(deployments: [DeploymentDataSummary]? = nil, nextToken: String? = nil) {
            self.deployments = deployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deployments = "deployments"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWorkloadDeploymentPatternsInput: AWSEncodableShape {
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?
        /// The name of the workload.
        public let workloadName: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, workloadName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 100)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[A-Za-z][a-zA-Z0-9-_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case workloadName = "workloadName"
        }
    }

    public struct ListWorkloadDeploymentPatternsOutput: AWSDecodableShape {
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?
        /// Describes the workload deployment patterns.
        public let workloadDeploymentPatterns: [WorkloadDeploymentPatternDataSummary]?

        @inlinable
        public init(nextToken: String? = nil, workloadDeploymentPatterns: [WorkloadDeploymentPatternDataSummary]? = nil) {
            self.nextToken = nextToken
            self.workloadDeploymentPatterns = workloadDeploymentPatterns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workloadDeploymentPatterns = "workloadDeploymentPatterns"
        }
    }

    public struct ListWorkloadsInput: AWSEncodableShape {
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadsOutput: AWSDecodableShape {
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?
        /// Information about the workloads.
        public let workloads: [WorkloadDataSummary]?

        @inlinable
        public init(nextToken: String? = nil, workloads: [WorkloadDataSummary]? = nil) {
            self.nextToken = nextToken
            self.workloads = workloads
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workloads = "workloads"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// One or more tags to attach to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// Keys identifying the tags to remove.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct WorkloadData: AWSDecodableShape {
        /// The description of a workload.
        public let description: String?
        /// The display name of a workload.
        public let displayName: String?
        /// The URL of a workload document.
        public let documentationUrl: String?
        /// The URL of a workload icon.
        public let iconUrl: String?
        /// The status of a workload.
        public let status: WorkloadStatus?
        /// The message about a workload's status.
        public let statusMessage: String?
        /// The name of the workload.
        public let workloadName: String?

        @inlinable
        public init(description: String? = nil, displayName: String? = nil, documentationUrl: String? = nil, iconUrl: String? = nil, status: WorkloadStatus? = nil, statusMessage: String? = nil, workloadName: String? = nil) {
            self.description = description
            self.displayName = displayName
            self.documentationUrl = documentationUrl
            self.iconUrl = iconUrl
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case documentationUrl = "documentationUrl"
            case iconUrl = "iconUrl"
            case status = "status"
            case statusMessage = "statusMessage"
            case workloadName = "workloadName"
        }
    }

    public struct WorkloadDataSummary: AWSDecodableShape {
        /// The display name of the workload data.
        public let displayName: String?
        /// The name of the workload.
        public let workloadName: String?

        @inlinable
        public init(displayName: String? = nil, workloadName: String? = nil) {
            self.displayName = displayName
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case workloadName = "workloadName"
        }
    }

    public struct WorkloadDeploymentPatternData: AWSDecodableShape {
        /// The name of the deployment pattern.
        public let deploymentPatternName: String?
        /// The description of the deployment pattern.
        public let description: String?
        /// The display name of the deployment pattern.
        public let displayName: String?
        /// The settings specified for the deployment. These settings define how to deploy and configure your resources created by the deployment. For more information about the specifications required for creating a deployment for a SAP workload, see SAP deployment specifications. To retrieve the specifications required to create a deployment for other workloads, use the  GetWorkloadDeploymentPattern operation.
        public let specifications: [DeploymentSpecificationsField]?
        /// The status of the deployment pattern.
        public let status: WorkloadDeploymentPatternStatus?
        /// The status message of the deployment pattern.
        public let statusMessage: String?
        /// The workload name of the deployment pattern.
        public let workloadName: String?
        /// The workload version name of the deployment pattern.
        public let workloadVersionName: String?

        @inlinable
        public init(deploymentPatternName: String? = nil, description: String? = nil, displayName: String? = nil, specifications: [DeploymentSpecificationsField]? = nil, status: WorkloadDeploymentPatternStatus? = nil, statusMessage: String? = nil, workloadName: String? = nil, workloadVersionName: String? = nil) {
            self.deploymentPatternName = deploymentPatternName
            self.description = description
            self.displayName = displayName
            self.specifications = specifications
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
            self.workloadVersionName = workloadVersionName
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentPatternName = "deploymentPatternName"
            case description = "description"
            case displayName = "displayName"
            case specifications = "specifications"
            case status = "status"
            case statusMessage = "statusMessage"
            case workloadName = "workloadName"
            case workloadVersionName = "workloadVersionName"
        }
    }

    public struct WorkloadDeploymentPatternDataSummary: AWSDecodableShape {
        /// The name of a workload deployment pattern.
        public let deploymentPatternName: String?
        /// The description of a workload deployment pattern.
        public let description: String?
        /// The display name of a workload deployment pattern.
        public let displayName: String?
        /// The status of a workload deployment pattern.
        public let status: WorkloadDeploymentPatternStatus?
        /// A message about a workload deployment pattern's status.
        public let statusMessage: String?
        /// The name of the workload.
        public let workloadName: String?
        /// The name of the workload deployment pattern version.
        public let workloadVersionName: String?

        @inlinable
        public init(deploymentPatternName: String? = nil, description: String? = nil, displayName: String? = nil, status: WorkloadDeploymentPatternStatus? = nil, statusMessage: String? = nil, workloadName: String? = nil, workloadVersionName: String? = nil) {
            self.deploymentPatternName = deploymentPatternName
            self.description = description
            self.displayName = displayName
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
            self.workloadVersionName = workloadVersionName
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentPatternName = "deploymentPatternName"
            case description = "description"
            case displayName = "displayName"
            case status = "status"
            case statusMessage = "statusMessage"
            case workloadName = "workloadName"
            case workloadVersionName = "workloadVersionName"
        }
    }
}

// MARK: - Errors

/// Error enum for LaunchWizard
public struct LaunchWizardErrorType: AWSErrorType {
    enum Code: String {
        case internalServerException = "InternalServerException"
        case resourceLimitException = "ResourceLimitException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize LaunchWizard
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An internal error has occurred. Retry your request, but if the problem persists, contact us with details by posting a question on re:Post.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// You have exceeded an Launch Wizard resource limit. For example, you might have too many deployments in progress.
    public static var resourceLimitException: Self { .init(.resourceLimitException) }
    /// The specified workload or deployment resource can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension LaunchWizardErrorType: Equatable {
    public static func == (lhs: LaunchWizardErrorType, rhs: LaunchWizardErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LaunchWizardErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
