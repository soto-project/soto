//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension LaunchWizard {
    // MARK: Enums

    public enum DeploymentFilterKey: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deploymentStatus = "DEPLOYMENT_STATUS"
        case workloadName = "WORKLOAD_NAME"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case deleteInitiating = "DELETE_INITIATING"
        case deleted = "DELETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum EventStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case canceling = "CANCELING"
        case completed = "COMPLETED"
        case created = "CREATED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadDeploymentPatternStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum WorkloadStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case deleted = "DELETED"
        case disabled = "DISABLED"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CreateDeploymentInput: AWSEncodableShape {
        /// The name of the deployment pattern supported by a given workload. You can use the  ListWorkloadDeploymentPatterns operation to discover supported values for this parameter.
        public let deploymentPatternName: String
        /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
        public let dryRun: Bool?
        /// The name of the deployment.
        public let name: String
        /// The settings specified for the deployment. For more information on the specifications required for creating a deployment, see Workload specifications.
        public let specifications: [String: String]
        /// The name of the workload. You can use the  ListWorkloadDeploymentPatterns operation to discover supported values for this parameter.
        public let workloadName: String

        public init(deploymentPatternName: String, dryRun: Bool? = nil, name: String, specifications: [String: String], workloadName: String) {
            self.deploymentPatternName = deploymentPatternName
            self.dryRun = dryRun
            self.name = name
            self.specifications = specifications
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, max: 256)
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, min: 1)
            try self.validate(self.deploymentPatternName, name: "deploymentPatternName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.name, name: "name", parent: name, max: 25)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[A-Za-z0-9_\\s\\.-]+$")
            try self.specifications.forEach {
                try validate($0.key, name: "specifications.key", parent: name, max: 256)
                try validate($0.key, name: "specifications.key", parent: name, min: 3)
                try validate($0.key, name: "specifications.key", parent: name, pattern: "^[a-zA-Z0-9-:]+$")
                try validate($0.value, name: "specifications[\"\($0.key)\"]", parent: name, max: 1500)
                try validate($0.value, name: "specifications[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.specifications, name: "specifications", parent: name, max: 100)
            try self.validate(self.specifications, name: "specifications", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 256)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentPatternName = "deploymentPatternName"
            case dryRun = "dryRun"
            case name = "name"
            case specifications = "specifications"
            case workloadName = "workloadName"
        }
    }

    public struct CreateDeploymentOutput: AWSDecodableShape {
        /// The ID of the deployment.
        public let deploymentId: String?

        public init(deploymentId: String? = nil) {
            self.deploymentId = deploymentId
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
        }
    }

    public struct DeleteDeploymentInput: AWSEncodableShape {
        /// The ID of the deployment.
        public let deploymentId: String

        public init(deploymentId: String) {
            self.deploymentId = deploymentId
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, max: 128)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, min: 2)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
        }
    }

    public struct DeleteDeploymentOutput: AWSDecodableShape {
        /// The status of the deployment.
        public let status: DeploymentStatus?
        /// The reason for the deployment status.
        public let statusReason: String?

        public init(status: DeploymentStatus? = nil, statusReason: String? = nil) {
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct DeploymentData: AWSDecodableShape {
        /// The time the deployment was created.
        public let createdAt: Date?
        /// The time the deployment was deleted.
        public let deletedAt: Date?
        /// The ID of the deployment.
        public let id: String?
        /// The name of the deployment.
        public let name: String?
        /// The pattern name of the deployment.
        public let patternName: String?
        /// The resource group of the deployment.
        public let resourceGroup: String?
        /// The specifications of the deployment. For more information on specifications for each deployment, see Workload specifications.
        public let specifications: [String: String]?
        /// The status of the deployment.
        public let status: DeploymentStatus?
        /// The name of the workload.
        public let workloadName: String?

        public init(createdAt: Date? = nil, deletedAt: Date? = nil, id: String? = nil, name: String? = nil, patternName: String? = nil, resourceGroup: String? = nil, specifications: [String: String]? = nil, status: DeploymentStatus? = nil, workloadName: String? = nil) {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.resourceGroup = resourceGroup
            self.specifications = specifications
            self.status = status
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case deletedAt = "deletedAt"
            case id = "id"
            case name = "name"
            case patternName = "patternName"
            case resourceGroup = "resourceGroup"
            case specifications = "specifications"
            case status = "status"
            case workloadName = "workloadName"
        }
    }

    public struct DeploymentDataSummary: AWSDecodableShape {
        /// The time the deployment was created.
        public let createdAt: Date?
        /// The ID of the deployment.
        public let id: String?
        /// The name of the deployment
        public let name: String?
        /// The name of the workload deployment pattern.
        public let patternName: String?
        /// The status of the deployment.
        public let status: DeploymentStatus?
        /// The name of the workload.
        public let workloadName: String?

        public init(createdAt: Date? = nil, id: String? = nil, name: String? = nil, patternName: String? = nil, status: DeploymentStatus? = nil, workloadName: String? = nil) {
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.patternName = patternName
            self.status = status
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case id = "id"
            case name = "name"
            case patternName = "patternName"
            case status = "status"
            case workloadName = "workloadName"
        }
    }

    public struct DeploymentEventDataSummary: AWSDecodableShape {
        /// The description of the deployment event.
        public let description: String?
        /// The name of the deployment event.
        public let name: String?
        /// The status of the deployment event.
        public let status: EventStatus?
        /// The reason of the deployment event status.
        public let statusReason: String?
        /// The timestamp of the deployment event.
        public let timestamp: Date?

        public init(description: String? = nil, name: String? = nil, status: EventStatus? = nil, statusReason: String? = nil, timestamp: Date? = nil) {
            self.description = description
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.timestamp = timestamp
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
            case status = "status"
            case statusReason = "statusReason"
            case timestamp = "timestamp"
        }
    }

    public struct DeploymentFilter: AWSEncodableShape {
        /// The name of the filter. Filter names are case-sensitive.
        public let name: DeploymentFilterKey?
        /// The filter values. Filter values are case-sensitive. If you specify multiple values for a filter, the values are joined with an OR, and the request returns all results that match any of the specified values.
        public let values: [String]?

        public init(name: DeploymentFilterKey? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct GetDeploymentInput: AWSEncodableShape {
        /// The ID of the deployment.
        public let deploymentId: String

        public init(deploymentId: String) {
            self.deploymentId = deploymentId
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, max: 128)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, min: 2)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
        }
    }

    public struct GetDeploymentOutput: AWSDecodableShape {
        /// An object that details the deployment.
        public let deployment: DeploymentData?

        public init(deployment: DeploymentData? = nil) {
            self.deployment = deployment
        }

        private enum CodingKeys: String, CodingKey {
            case deployment = "deployment"
        }
    }

    public struct GetWorkloadInput: AWSEncodableShape {
        /// The name of the workload.
        public let workloadName: String

        public init(workloadName: String) {
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 256)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workloadName = "workloadName"
        }
    }

    public struct GetWorkloadOutput: AWSDecodableShape {
        /// Information about the workload.
        public let workload: WorkloadData?

        public init(workload: WorkloadData? = nil) {
            self.workload = workload
        }

        private enum CodingKeys: String, CodingKey {
            case workload = "workload"
        }
    }

    public struct ListDeploymentEventsInput: AWSEncodableShape {
        /// The ID of the deployment.
        public let deploymentId: String
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        public init(deploymentId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.deploymentId = deploymentId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, max: 128)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, min: 2)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentId = "deploymentId"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentEventsOutput: AWSDecodableShape {
        /// Lists the deployment events.
        public let deploymentEvents: [DeploymentEventDataSummary]?
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        public init(deploymentEvents: [DeploymentEventDataSummary]? = nil, nextToken: String? = nil) {
            self.deploymentEvents = deploymentEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentEvents = "deploymentEvents"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentsInput: AWSEncodableShape {
        /// Filters to scope the results. The following filters are supported:    WORKLOAD_NAME     DEPLOYMENT_STATUS
        public let filters: [DeploymentFilter]?
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        public init(filters: [DeploymentFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListDeploymentsOutput: AWSDecodableShape {
        /// Lists the deployments.
        public let deployments: [DeploymentDataSummary]?
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?

        public init(deployments: [DeploymentDataSummary]? = nil, nextToken: String? = nil) {
            self.deployments = deployments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case deployments = "deployments"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadDeploymentPatternsInput: AWSEncodableShape {
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?
        /// The name of the workload.
        public let workloadName: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, workloadName: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.workloadName = workloadName
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, max: 256)
            try self.validate(self.workloadName, name: "workloadName", parent: name, min: 1)
            try self.validate(self.workloadName, name: "workloadName", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case workloadName = "workloadName"
        }
    }

    public struct ListWorkloadDeploymentPatternsOutput: AWSDecodableShape {
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?
        /// Describes the workload deployment patterns.
        public let workloadDeploymentPatterns: [WorkloadDeploymentPatternDataSummary]?

        public init(nextToken: String? = nil, workloadDeploymentPatterns: [WorkloadDeploymentPatternDataSummary]? = nil) {
            self.nextToken = nextToken
            self.workloadDeploymentPatterns = workloadDeploymentPatterns
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workloadDeploymentPatterns = "workloadDeploymentPatterns"
        }
    }

    public struct ListWorkloadsInput: AWSEncodableShape {
        /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
        public let maxResults: Int?
        /// The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListWorkloadsOutput: AWSDecodableShape {
        /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
        public let nextToken: String?
        /// Information about the workloads.
        public let workloads: [WorkloadDataSummary]?

        public init(nextToken: String? = nil, workloads: [WorkloadDataSummary]? = nil) {
            self.nextToken = nextToken
            self.workloads = workloads
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workloads = "workloads"
        }
    }

    public struct WorkloadData: AWSDecodableShape {
        /// The description of a workload.
        public let description: String?
        /// The display name of a workload.
        public let displayName: String?
        /// The URL of a workload document.
        public let documentationUrl: String?
        /// The URL of a workload icon.
        public let iconUrl: String?
        /// The status of a workload.
        public let status: WorkloadStatus?
        /// The message about a workload's status.
        public let statusMessage: String?
        /// The name of the workload.
        public let workloadName: String?

        public init(description: String? = nil, displayName: String? = nil, documentationUrl: String? = nil, iconUrl: String? = nil, status: WorkloadStatus? = nil, statusMessage: String? = nil, workloadName: String? = nil) {
            self.description = description
            self.displayName = displayName
            self.documentationUrl = documentationUrl
            self.iconUrl = iconUrl
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case displayName = "displayName"
            case documentationUrl = "documentationUrl"
            case iconUrl = "iconUrl"
            case status = "status"
            case statusMessage = "statusMessage"
            case workloadName = "workloadName"
        }
    }

    public struct WorkloadDataSummary: AWSDecodableShape {
        /// The display name of the workload data.
        public let displayName: String?
        /// The name of the workload.
        public let workloadName: String?

        public init(displayName: String? = nil, workloadName: String? = nil) {
            self.displayName = displayName
            self.workloadName = workloadName
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "displayName"
            case workloadName = "workloadName"
        }
    }

    public struct WorkloadDeploymentPatternDataSummary: AWSDecodableShape {
        /// The name of a workload deployment pattern.
        public let deploymentPatternName: String?
        /// The description of a workload deployment pattern.
        public let description: String?
        /// The display name of a workload deployment pattern.
        public let displayName: String?
        /// The status of a workload deployment pattern.
        public let status: WorkloadDeploymentPatternStatus?
        /// A message about a workload deployment pattern's status.
        public let statusMessage: String?
        /// The name of the workload.
        public let workloadName: String?
        /// The name of the workload deployment pattern version.
        public let workloadVersionName: String?

        public init(deploymentPatternName: String? = nil, description: String? = nil, displayName: String? = nil, status: WorkloadDeploymentPatternStatus? = nil, statusMessage: String? = nil, workloadName: String? = nil, workloadVersionName: String? = nil) {
            self.deploymentPatternName = deploymentPatternName
            self.description = description
            self.displayName = displayName
            self.status = status
            self.statusMessage = statusMessage
            self.workloadName = workloadName
            self.workloadVersionName = workloadVersionName
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentPatternName = "deploymentPatternName"
            case description = "description"
            case displayName = "displayName"
            case status = "status"
            case statusMessage = "statusMessage"
            case workloadName = "workloadName"
            case workloadVersionName = "workloadVersionName"
        }
    }
}

// MARK: - Errors

/// Error enum for LaunchWizard
public struct LaunchWizardErrorType: AWSErrorType {
    enum Code: String {
        case internalServerException = "InternalServerException"
        case resourceLimitException = "ResourceLimitException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize LaunchWizard
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// An internal error has occurred. Retry your request, but if the problem persists, contact us with details by posting a question on re:Post.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// You have exceeded an Launch Wizard resource limit. For example, you might have too many deployments in progress.
    public static var resourceLimitException: Self { .init(.resourceLimitException) }
    /// The specified workload or deployment resource can't be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension LaunchWizardErrorType: Equatable {
    public static func == (lhs: LaunchWizardErrorType, rhs: LaunchWizardErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension LaunchWizardErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
