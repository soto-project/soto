//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS LaunchWizard service.
///
/// Launch Wizard offers a guided way of sizing, configuring, and deploying Amazon Web Services resources for third party applications, such as Microsoft SQL Server Always On and HANA based SAP systems, without the need to manually identify and provision individual Amazon Web Services resources.
public struct LaunchWizard: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the LaunchWizard client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "LaunchWizard",
            serviceIdentifier: "launchwizard",
            serviceProtocol: .restjson,
            apiVersion: "2018-05-10",
            endpoint: endpoint,
            errorType: LaunchWizardErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }





    // MARK: API Calls

    /// Creates a deployment for the given workload. Deployments created by this operation are not available in the Launch Wizard console to use the Clone deployment action on.
    @Sendable
    @inlinable
    public func createDeployment(_ input: CreateDeploymentInput, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateDeploymentOutput {
        try await self.client.execute(
            operation: "CreateDeployment", 
            path: "/createDeployment", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a deployment for the given workload. Deployments created by this operation are not available in the Launch Wizard console to use the Clone deployment action on.
    ///
    /// Parameters:
    ///   - deploymentPatternName: The name of the deployment pattern supported by a given workload. You can use the  ListWorkloadDeploymentPatterns operation to discover supported values for this parameter.
    ///   - dryRun: Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    ///   - name: The name of the deployment.
    ///   - specifications: The settings specified for the deployment. These settings define how to deploy and configure your resources created by the deployment. For more information about the specifications required for creating a deployment for a SAP workload, see SAP deployment specifications. To retrieve the specifications required to create a deployment for other workloads, use the  GetWorkloadDeploymentPattern operation.
    ///   - tags: The tags to add to the deployment.
    ///   - workloadName: The name of the workload. You can use the  ListWorkloads operation to discover supported values for this parameter.
    ///   - logger: Logger use during operation
    @inlinable
    public func createDeployment(
        deploymentPatternName: String,
        dryRun: Bool? = nil,
        name: String,
        specifications: [String: String],
        tags: [String: String]? = nil,
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateDeploymentOutput {
        let input = CreateDeploymentInput(
            deploymentPatternName: deploymentPatternName, 
            dryRun: dryRun, 
            name: name, 
            specifications: specifications, 
            tags: tags, 
            workloadName: workloadName
        )
        return try await self.createDeployment(input, logger: logger)
    }

    /// Deletes a deployment.
    @Sendable
    @inlinable
    public func deleteDeployment(_ input: DeleteDeploymentInput, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteDeploymentOutput {
        try await self.client.execute(
            operation: "DeleteDeployment", 
            path: "/deleteDeployment", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a deployment.
    ///
    /// Parameters:
    ///   - deploymentId: The ID of the deployment.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteDeployment(
        deploymentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteDeploymentOutput {
        let input = DeleteDeploymentInput(
            deploymentId: deploymentId
        )
        return try await self.deleteDeployment(input, logger: logger)
    }

    /// Returns information about the deployment.
    @Sendable
    @inlinable
    public func getDeployment(_ input: GetDeploymentInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetDeploymentOutput {
        try await self.client.execute(
            operation: "GetDeployment", 
            path: "/getDeployment", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about the deployment.
    ///
    /// Parameters:
    ///   - deploymentId: The ID of the deployment.
    ///   - logger: Logger use during operation
    @inlinable
    public func getDeployment(
        deploymentId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetDeploymentOutput {
        let input = GetDeploymentInput(
            deploymentId: deploymentId
        )
        return try await self.getDeployment(input, logger: logger)
    }

    /// Returns information about a workload.
    @Sendable
    @inlinable
    public func getWorkload(_ input: GetWorkloadInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadOutput {
        try await self.client.execute(
            operation: "GetWorkload", 
            path: "/getWorkload", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns information about a workload.
    ///
    /// Parameters:
    ///   - workloadName: The name of the workload.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkload(
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadOutput {
        let input = GetWorkloadInput(
            workloadName: workloadName
        )
        return try await self.getWorkload(input, logger: logger)
    }

    /// Returns details for a given workload and deployment pattern, including the available specifications. You can use the ListWorkloads operation to discover the available workload names and the ListWorkloadDeploymentPatterns operation to discover the available deployment pattern names of a given workload.
    @Sendable
    @inlinable
    public func getWorkloadDeploymentPattern(_ input: GetWorkloadDeploymentPatternInput, logger: Logger = AWSClient.loggingDisabled) async throws -> GetWorkloadDeploymentPatternOutput {
        try await self.client.execute(
            operation: "GetWorkloadDeploymentPattern", 
            path: "/getWorkloadDeploymentPattern", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Returns details for a given workload and deployment pattern, including the available specifications. You can use the ListWorkloads operation to discover the available workload names and the ListWorkloadDeploymentPatterns operation to discover the available deployment pattern names of a given workload.
    ///
    /// Parameters:
    ///   - deploymentPatternName: The name of the deployment pattern.
    ///   - workloadName: The name of the workload.
    ///   - logger: Logger use during operation
    @inlinable
    public func getWorkloadDeploymentPattern(
        deploymentPatternName: String,
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetWorkloadDeploymentPatternOutput {
        let input = GetWorkloadDeploymentPatternInput(
            deploymentPatternName: deploymentPatternName, 
            workloadName: workloadName
        )
        return try await self.getWorkloadDeploymentPattern(input, logger: logger)
    }

    /// Lists the events of a deployment.
    @Sendable
    @inlinable
    public func listDeploymentEvents(_ input: ListDeploymentEventsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDeploymentEventsOutput {
        try await self.client.execute(
            operation: "ListDeploymentEvents", 
            path: "/listDeploymentEvents", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the events of a deployment.
    ///
    /// Parameters:
    ///   - deploymentId: The ID of the deployment.
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - nextToken: The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDeploymentEvents(
        deploymentId: String,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDeploymentEventsOutput {
        let input = ListDeploymentEventsInput(
            deploymentId: deploymentId, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDeploymentEvents(input, logger: logger)
    }

    /// Lists the deployments that have been created.
    @Sendable
    @inlinable
    public func listDeployments(_ input: ListDeploymentsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListDeploymentsOutput {
        try await self.client.execute(
            operation: "ListDeployments", 
            path: "/listDeployments", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the deployments that have been created.
    ///
    /// Parameters:
    ///   - filters: Filters to scope the results. The following filters are supported:    WORKLOAD_NAME - The name used in deployments.    DEPLOYMENT_STATUS - COMPLETED | CREATING | DELETE_IN_PROGRESS | DELETE_INITIATING | DELETE_FAILED | DELETED | FAILED | IN_PROGRESS | VALIDATING
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - nextToken: The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listDeployments(
        filters: [DeploymentFilter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListDeploymentsOutput {
        let input = ListDeploymentsInput(
            filters: filters, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listDeployments(input, logger: logger)
    }

    /// Lists the tags associated with a specified resource.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceOutput {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags associated with a specified resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceOutput {
        let input = ListTagsForResourceInput(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists the workload deployment patterns for a given workload name. You can use the ListWorkloads operation to discover the available workload names.
    @Sendable
    @inlinable
    public func listWorkloadDeploymentPatterns(_ input: ListWorkloadDeploymentPatternsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkloadDeploymentPatternsOutput {
        try await self.client.execute(
            operation: "ListWorkloadDeploymentPatterns", 
            path: "/listWorkloadDeploymentPatterns", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the workload deployment patterns for a given workload name. You can use the ListWorkloads operation to discover the available workload names.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - nextToken: The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    ///   - workloadName: The name of the workload.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkloadDeploymentPatterns(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkloadDeploymentPatternsOutput {
        let input = ListWorkloadDeploymentPatternsInput(
            maxResults: maxResults, 
            nextToken: nextToken, 
            workloadName: workloadName
        )
        return try await self.listWorkloadDeploymentPatterns(input, logger: logger)
    }

    /// Lists the available workload names. You can use the ListWorkloadDeploymentPatterns operation to discover the available deployment patterns for a given workload.
    @Sendable
    @inlinable
    public func listWorkloads(_ input: ListWorkloadsInput, logger: Logger = AWSClient.loggingDisabled) async throws -> ListWorkloadsOutput {
        try await self.client.execute(
            operation: "ListWorkloads", 
            path: "/listWorkloads", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the available workload names. You can use the ListWorkloadDeploymentPatterns operation to discover the available deployment patterns for a given workload.
    ///
    /// Parameters:
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - nextToken: The token returned from a previous paginated request. Pagination continues from the end of the items returned by the previous request.
    ///   - logger: Logger use during operation
    @inlinable
    public func listWorkloads(
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListWorkloadsOutput {
        let input = ListWorkloadsInput(
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listWorkloads(input, logger: logger)
    }

    /// Adds the specified tags to the given resource.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceOutput {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Adds the specified tags to the given resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - tags: One or more tags to attach to the resource.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceOutput {
        let input = TagResourceInput(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes the specified tags from the given resource.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceOutput {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes the specified tags from the given resource.
    ///
    /// Parameters:
    ///   - resourceArn: The Amazon Resource Name (ARN) of the resource.
    ///   - tagKeys: Keys identifying the tags to remove.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceOutput {
        let input = UntagResourceInput(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }
}

extension LaunchWizard {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: LaunchWizard, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension LaunchWizard {
    /// Return PaginatorSequence for operation ``listDeploymentEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeploymentEventsPaginator(
        _ input: ListDeploymentEventsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDeploymentEventsInput, ListDeploymentEventsOutput> {
        return .init(
            input: input,
            command: self.listDeploymentEvents,
            inputKey: \ListDeploymentEventsInput.nextToken,
            outputKey: \ListDeploymentEventsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDeploymentEvents(_:logger:)``.
    ///
    /// - Parameters:
    ///   - deploymentId: The ID of the deployment.
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeploymentEventsPaginator(
        deploymentId: String,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDeploymentEventsInput, ListDeploymentEventsOutput> {
        let input = ListDeploymentEventsInput(
            deploymentId: deploymentId, 
            maxResults: maxResults
        )
        return self.listDeploymentEventsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listDeployments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeploymentsPaginator(
        _ input: ListDeploymentsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListDeploymentsInput, ListDeploymentsOutput> {
        return .init(
            input: input,
            command: self.listDeployments,
            inputKey: \ListDeploymentsInput.nextToken,
            outputKey: \ListDeploymentsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listDeployments(_:logger:)``.
    ///
    /// - Parameters:
    ///   - filters: Filters to scope the results. The following filters are supported:    WORKLOAD_NAME - The name used in deployments.    DEPLOYMENT_STATUS - COMPLETED | CREATING | DELETE_IN_PROGRESS | DELETE_INITIATING | DELETE_FAILED | DELETED | FAILED | IN_PROGRESS | VALIDATING
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - logger: Logger used for logging
    @inlinable
    public func listDeploymentsPaginator(
        filters: [DeploymentFilter]? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListDeploymentsInput, ListDeploymentsOutput> {
        let input = ListDeploymentsInput(
            filters: filters, 
            maxResults: maxResults
        )
        return self.listDeploymentsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkloadDeploymentPatterns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadDeploymentPatternsPaginator(
        _ input: ListWorkloadDeploymentPatternsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkloadDeploymentPatternsInput, ListWorkloadDeploymentPatternsOutput> {
        return .init(
            input: input,
            command: self.listWorkloadDeploymentPatterns,
            inputKey: \ListWorkloadDeploymentPatternsInput.nextToken,
            outputKey: \ListWorkloadDeploymentPatternsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkloadDeploymentPatterns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - workloadName: The name of the workload.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadDeploymentPatternsPaginator(
        maxResults: Int? = nil,
        workloadName: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkloadDeploymentPatternsInput, ListWorkloadDeploymentPatternsOutput> {
        let input = ListWorkloadDeploymentPatternsInput(
            maxResults: maxResults, 
            workloadName: workloadName
        )
        return self.listWorkloadDeploymentPatternsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listWorkloads(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadsPaginator(
        _ input: ListWorkloadsInput,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListWorkloadsInput, ListWorkloadsOutput> {
        return .init(
            input: input,
            command: self.listWorkloads,
            inputKey: \ListWorkloadsInput.nextToken,
            outputKey: \ListWorkloadsOutput.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listWorkloads(_:logger:)``.
    ///
    /// - Parameters:
    ///   - maxResults: The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    ///   - logger: Logger used for logging
    @inlinable
    public func listWorkloadsPaginator(
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListWorkloadsInput, ListWorkloadsOutput> {
        let input = ListWorkloadsInput(
            maxResults: maxResults
        )
        return self.listWorkloadsPaginator(input, logger: logger)
    }
}

extension LaunchWizard.ListDeploymentEventsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LaunchWizard.ListDeploymentEventsInput {
        return .init(
            deploymentId: self.deploymentId,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LaunchWizard.ListDeploymentsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LaunchWizard.ListDeploymentsInput {
        return .init(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension LaunchWizard.ListWorkloadDeploymentPatternsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LaunchWizard.ListWorkloadDeploymentPatternsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token,
            workloadName: self.workloadName
        )
    }
}

extension LaunchWizard.ListWorkloadsInput: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> LaunchWizard.ListWorkloadsInput {
        return .init(
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}
