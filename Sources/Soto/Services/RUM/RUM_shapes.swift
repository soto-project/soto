//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension RUM {
    // MARK: Enums

    public enum CustomEventsStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DeobfuscationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MetricDestination: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cloudWatch = "CloudWatch"
        case evidently = "Evidently"
        public var description: String { return self.rawValue }
    }

    public enum StateEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case created = "CREATED"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum Telemetry: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Includes JS error event plugin
        case errors = "errors"
        /// Includes X-Ray Xhr and X-Ray Fetch plugin
        case http = "http"
        /// Includes navigation, paint, resource and web vital event plugins
        case performance = "performance"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AppMonitor: AWSDecodableShape {
        /// A structure that contains much of the configuration data for the app monitor.
        public let appMonitorConfiguration: AppMonitorConfiguration?
        /// The date and time that this app monitor was created.
        public let created: String?
        /// Specifies whether this app monitor allows the web client to define and send custom events. For more information about custom events, see  Send custom events.
        public let customEvents: CustomEvents?
        /// A structure that contains information about whether this app monitor stores a copy of the telemetry data that RUM collects using CloudWatch Logs.
        public let dataStorage: DataStorage?
        ///  A structure that contains the configuration for how an app monitor can deobfuscate stack traces.
        public let deobfuscationConfiguration: DeobfuscationConfiguration?
        /// The top-level internet domain name for which your application has administrative authority.
        public let domain: String?
        ///  List the domain names for which your application has administrative authority.
        public let domainList: [String]?
        /// The unique ID of this app monitor.
        public let id: String?
        /// The date and time of the most recent changes to this app monitor's configuration.
        public let lastModified: String?
        /// The name of the app monitor.
        public let name: String?
        /// The current state of the app monitor.
        public let state: StateEnum?
        /// The list of tag keys and values associated with this app monitor.
        public let tags: [String: String]?

        @inlinable
        public init(appMonitorConfiguration: AppMonitorConfiguration? = nil, created: String? = nil, customEvents: CustomEvents? = nil, dataStorage: DataStorage? = nil, deobfuscationConfiguration: DeobfuscationConfiguration? = nil, domain: String? = nil, domainList: [String]? = nil, id: String? = nil, lastModified: String? = nil, name: String? = nil, state: StateEnum? = nil, tags: [String: String]? = nil) {
            self.appMonitorConfiguration = appMonitorConfiguration
            self.created = created
            self.customEvents = customEvents
            self.dataStorage = dataStorage
            self.deobfuscationConfiguration = deobfuscationConfiguration
            self.domain = domain
            self.domainList = domainList
            self.id = id
            self.lastModified = lastModified
            self.name = name
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case appMonitorConfiguration = "AppMonitorConfiguration"
            case created = "Created"
            case customEvents = "CustomEvents"
            case dataStorage = "DataStorage"
            case deobfuscationConfiguration = "DeobfuscationConfiguration"
            case domain = "Domain"
            case domainList = "DomainList"
            case id = "Id"
            case lastModified = "LastModified"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct AppMonitorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// If you set this to true, the RUM web client sets two cookies, a session cookie and a user cookie. The cookies allow the RUM web client to collect data relating to the number of users an application has and the behavior of the application across a sequence of events. Cookies are stored in the top-level domain of the current page.
        public let allowCookies: Bool?
        /// If you set this to true, RUM enables X-Ray tracing for the user sessions that RUM samples. RUM adds an X-Ray trace header to allowed HTTP requests. It also records an X-Ray segment for allowed HTTP requests. You can see traces and segments from these user sessions in the X-Ray console and the CloudWatch ServiceLens console. For more information, see What is X-Ray?
        public let enableXRay: Bool?
        /// A list of URLs in your website or application to exclude from RUM data collection. You can't include both ExcludedPages and IncludedPages in the same operation.
        public let excludedPages: [String]?
        /// A list of pages in your application that are to be displayed with a "favorite" icon in the CloudWatch RUM console.
        public let favoritePages: [String]?
        /// The ARN of the guest IAM role that is attached to the Amazon Cognito identity pool  that is used to authorize the sending of data to RUM.  It is possible that an app monitor does not have a value for GuestRoleArn. For example,  this can happen when you use the console to create an app monitor and you allow CloudWatch RUM to  create a new identity pool for Authorization. In this case, GuestRoleArn is not present in the  GetAppMonitor response because it is not stored by the service. If this issue affects you, you can take one of the following steps:   Use the Cloud Development Kit (CDK) to create an identity pool and the associated IAM role, and use that for your app monitor.   Make a separate GetIdentityPoolRoles call to Amazon Cognito to retrieve  the GuestRoleArn.
        public let guestRoleArn: String?
        /// The ID of the Amazon Cognito identity pool  that is used to authorize the sending of data to RUM.
        public let identityPoolId: String?
        /// If this app monitor is to collect data from only certain pages in your application, this structure lists those pages.  You can't include both ExcludedPages and IncludedPages in the same operation.
        public let includedPages: [String]?
        /// Specifies the portion of user sessions to use for RUM data collection. Choosing a higher portion gives you more data but also incurs more costs. The range for this value is 0 to 1 inclusive. Setting this to 1 means that 100% of user sessions are sampled, and setting it to 0.1 means that 10% of user sessions are sampled. If you omit this parameter, the default of 0.1 is used, and 10% of sessions will be sampled.
        public let sessionSampleRate: Double?
        /// An array that lists the types of telemetry data that this app monitor is to collect.    errors indicates that RUM collects data about unhandled JavaScript errors raised by your application.    performance indicates that RUM collects performance data about how your application and its resources are loaded and rendered. This includes Core Web Vitals.    http indicates that RUM collects data about HTTP errors thrown by your application.
        public let telemetries: [Telemetry]?

        @inlinable
        public init(allowCookies: Bool? = nil, enableXRay: Bool? = nil, excludedPages: [String]? = nil, favoritePages: [String]? = nil, guestRoleArn: String? = nil, identityPoolId: String? = nil, includedPages: [String]? = nil, sessionSampleRate: Double? = nil, telemetries: [Telemetry]? = nil) {
            self.allowCookies = allowCookies
            self.enableXRay = enableXRay
            self.excludedPages = excludedPages
            self.favoritePages = favoritePages
            self.guestRoleArn = guestRoleArn
            self.identityPoolId = identityPoolId
            self.includedPages = includedPages
            self.sessionSampleRate = sessionSampleRate
            self.telemetries = telemetries
        }

        public func validate(name: String) throws {
            try self.excludedPages?.forEach {
                try validate($0, name: "excludedPages[]", parent: name, max: 1260)
                try validate($0, name: "excludedPages[]", parent: name, min: 1)
                try validate($0, name: "excludedPages[]", parent: name, pattern: "https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&*//=]*)")
            }
            try self.validate(self.excludedPages, name: "excludedPages", parent: name, max: 50)
            try self.validate(self.favoritePages, name: "favoritePages", parent: name, max: 50)
            try self.validate(self.guestRoleArn, name: "guestRoleArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, max: 55)
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, min: 1)
            try self.validate(self.identityPoolId, name: "identityPoolId", parent: name, pattern: "[\\w-]+:[0-9a-f-]+")
            try self.includedPages?.forEach {
                try validate($0, name: "includedPages[]", parent: name, max: 1260)
                try validate($0, name: "includedPages[]", parent: name, min: 1)
                try validate($0, name: "includedPages[]", parent: name, pattern: "https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&*//=]*)")
            }
            try self.validate(self.includedPages, name: "includedPages", parent: name, max: 50)
            try self.validate(self.sessionSampleRate, name: "sessionSampleRate", parent: name, max: 1.0)
            try self.validate(self.sessionSampleRate, name: "sessionSampleRate", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case allowCookies = "AllowCookies"
            case enableXRay = "EnableXRay"
            case excludedPages = "ExcludedPages"
            case favoritePages = "FavoritePages"
            case guestRoleArn = "GuestRoleArn"
            case identityPoolId = "IdentityPoolId"
            case includedPages = "IncludedPages"
            case sessionSampleRate = "SessionSampleRate"
            case telemetries = "Telemetries"
        }
    }

    public struct AppMonitorDetails: AWSEncodableShape {
        /// The unique ID of the app monitor.
        public let id: String?
        /// The name of the app monitor.
        public let name: String?
        /// The version of the app monitor.
        public let version: String?

        @inlinable
        public init(id: String? = nil, name: String? = nil, version: String? = nil) {
            self.id = id
            self.name = name
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case version = "version"
        }
    }

    public struct AppMonitorSummary: AWSDecodableShape {
        /// The date and time that the app monitor was created.
        public let created: String?
        /// The unique ID of this app monitor.
        public let id: String?
        /// The date and time of the most recent changes to this app monitor's configuration.
        public let lastModified: String?
        /// The name of this app monitor.
        public let name: String?
        /// The current state of this app monitor.
        public let state: StateEnum?

        @inlinable
        public init(created: String? = nil, id: String? = nil, lastModified: String? = nil, name: String? = nil, state: StateEnum? = nil) {
            self.created = created
            self.id = id
            self.lastModified = lastModified
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case created = "Created"
            case id = "Id"
            case lastModified = "LastModified"
            case name = "Name"
            case state = "State"
        }
    }

    public struct BatchCreateRumMetricDefinitionsError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String
        /// The error message for this metric definition.
        public let errorMessage: String
        /// The metric definition that caused this error.
        public let metricDefinition: MetricDefinitionRequest

        @inlinable
        public init(errorCode: String, errorMessage: String, metricDefinition: MetricDefinitionRequest) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.metricDefinition = metricDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case metricDefinition = "MetricDefinition"
        }
    }

    public struct BatchCreateRumMetricDefinitionsRequest: AWSEncodableShape {
        /// The name of the CloudWatch RUM app monitor that is to send the metrics.
        public let appMonitorName: String
        /// The destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the Amazon Resource Name (ARN) of the CloudWatchEvidently experiment that will receive the metrics and an IAM role that has permission to write to the experiment.
        public let destination: MetricDestination
        /// This parameter is required if Destination is Evidently. If Destination is  CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that is to receive the metrics. You must have already defined this  experiment as a valid destination. For more information, see PutRumMetricsDestination.
        public let destinationArn: String?
        /// An array of structures which define the metrics that you want to send.
        public let metricDefinitions: [MetricDefinitionRequest]

        @inlinable
        public init(appMonitorName: String, destination: MetricDestination, destinationArn: String? = nil, metricDefinitions: [MetricDefinitionRequest]) {
            self.appMonitorName = appMonitorName
            self.destination = destination
            self.destinationArn = destinationArn
            self.metricDefinitions = metricDefinitions
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appMonitorName, key: "AppMonitorName")
            try container.encode(self.destination, forKey: .destination)
            try container.encodeIfPresent(self.destinationArn, forKey: .destinationArn)
            try container.encode(self.metricDefinitions, forKey: .metricDefinitions)
        }

        public func validate(name: String) throws {
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, max: 255)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, min: 1)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.metricDefinitions.forEach {
                try $0.validate(name: "\(name).metricDefinitions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case destinationArn = "DestinationArn"
            case metricDefinitions = "MetricDefinitions"
        }
    }

    public struct BatchCreateRumMetricDefinitionsResponse: AWSDecodableShape {
        /// An array of error objects, if the operation caused any errors.
        public let errors: [BatchCreateRumMetricDefinitionsError]
        /// An array of structures that define the extended metrics.
        public let metricDefinitions: [MetricDefinition]?

        @inlinable
        public init(errors: [BatchCreateRumMetricDefinitionsError], metricDefinitions: [MetricDefinition]? = nil) {
            self.errors = errors
            self.metricDefinitions = metricDefinitions
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case metricDefinitions = "MetricDefinitions"
        }
    }

    public struct BatchDeleteRumMetricDefinitionsError: AWSDecodableShape {
        /// The error code.
        public let errorCode: String
        /// The error message for this metric definition.
        public let errorMessage: String
        /// The ID of the metric definition that caused this error.
        public let metricDefinitionId: String

        @inlinable
        public init(errorCode: String, errorMessage: String, metricDefinitionId: String) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.metricDefinitionId = metricDefinitionId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case metricDefinitionId = "MetricDefinitionId"
        }
    }

    public struct BatchDeleteRumMetricDefinitionsRequest: AWSEncodableShape {
        /// The name of the CloudWatch RUM app monitor that is sending these metrics.
        public let appMonitorName: String
        /// Defines the destination where you want to stop sending the specified metrics. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the CloudWatchEvidently experiment that is to  be the destination and an IAM role that has permission to write to the experiment.
        public let destination: MetricDestination
        /// This parameter is required if Destination is Evidently. If Destination is  CloudWatch, do not use this parameter.  This parameter specifies the ARN of the Evidently experiment that was receiving the metrics that are being deleted.
        public let destinationArn: String?
        /// An array of structures which define the metrics that you want to stop sending.
        public let metricDefinitionIds: [String]

        @inlinable
        public init(appMonitorName: String, destination: MetricDestination, destinationArn: String? = nil, metricDefinitionIds: [String]) {
            self.appMonitorName = appMonitorName
            self.destination = destination
            self.destinationArn = destinationArn
            self.metricDefinitionIds = metricDefinitionIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appMonitorName, key: "AppMonitorName")
            request.encodeQuery(self.destination, key: "destination")
            request.encodeQuery(self.destinationArn, key: "destinationArn")
            request.encodeQuery(self.metricDefinitionIds, key: "metricDefinitionIds")
        }

        public func validate(name: String) throws {
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, max: 255)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, min: 1)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.metricDefinitionIds.forEach {
                try validate($0, name: "metricDefinitionIds[]", parent: name, max: 255)
                try validate($0, name: "metricDefinitionIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct BatchDeleteRumMetricDefinitionsResponse: AWSDecodableShape {
        /// An array of error objects, if the operation caused any errors.
        public let errors: [BatchDeleteRumMetricDefinitionsError]
        /// The IDs of the metric definitions that were deleted.
        public let metricDefinitionIds: [String]?

        @inlinable
        public init(errors: [BatchDeleteRumMetricDefinitionsError], metricDefinitionIds: [String]? = nil) {
            self.errors = errors
            self.metricDefinitionIds = metricDefinitionIds
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case metricDefinitionIds = "MetricDefinitionIds"
        }
    }

    public struct BatchGetRumMetricDefinitionsRequest: AWSEncodableShape {
        /// The name of the CloudWatch RUM app monitor that is sending the metrics.
        public let appMonitorName: String
        /// The type of destination that you want to view metrics for. Valid values are CloudWatch  and Evidently.
        public let destination: MetricDestination
        /// This parameter is required if Destination is Evidently. If Destination is  CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that corresponds to the destination.
        public let destinationArn: String?
        /// The maximum number of results to return in one operation. The default is 50. The maximum that you can  specify is 100. To retrieve the remaining results, make another call with the returned  NextToken value.
        public let maxResults: Int?
        /// Use the token returned by the previous operation to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appMonitorName: String, destination: MetricDestination, destinationArn: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appMonitorName = appMonitorName
            self.destination = destination
            self.destinationArn = destinationArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appMonitorName, key: "AppMonitorName")
            request.encodeQuery(self.destination, key: "destination")
            request.encodeQuery(self.destinationArn, key: "destinationArn")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, max: 255)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, min: 1)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct BatchGetRumMetricDefinitionsResponse: AWSDecodableShape {
        /// An array of structures that display information about the metrics that are sent by the specified app monitor to the specified destination.
        public let metricDefinitions: [MetricDefinition]?
        /// A token that you can use in a subsequent operation to  retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(metricDefinitions: [MetricDefinition]? = nil, nextToken: String? = nil) {
            self.metricDefinitions = metricDefinitions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricDefinitions = "MetricDefinitions"
            case nextToken = "NextToken"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The name of the resource that is associated with the error.
        public let resourceName: String
        /// The type of the resource that is associated with the error.
        public let resourceType: String?

        @inlinable
        public init(message: String, resourceName: String, resourceType: String? = nil) {
            self.message = message
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
            case resourceType = "resourceType"
        }
    }

    public struct CreateAppMonitorRequest: AWSEncodableShape {
        /// A structure that contains much of the configuration data for the app monitor. If you are using  Amazon Cognito for authorization, you must include this structure in your request, and it must include the ID of the  Amazon Cognito identity pool to use for authorization. If you don't include AppMonitorConfiguration, you must set up your own  authorization method. For more information, see  Authorize your application to send data to Amazon Web Services. If you omit this argument, the sample rate used for RUM is set to 10% of the user sessions.
        public let appMonitorConfiguration: AppMonitorConfiguration?
        /// Specifies whether this app monitor allows the web client to define and send custom events. If you omit this parameter, custom events are DISABLED. For more information about custom events, see  Send custom events.
        public let customEvents: CustomEvents?
        /// Data collected by RUM is kept by RUM for 30 days and then deleted. This parameter specifies whether RUM  sends a copy of this telemetry data to Amazon CloudWatch Logs in your account. This enables you to keep the telemetry data for more than 30 days, but it does incur Amazon CloudWatch Logs charges. If you omit this parameter, the default is false.
        public let cwLogEnabled: Bool?
        ///  A structure that contains the configuration for how an app monitor can deobfuscate stack traces.
        public let deobfuscationConfiguration: DeobfuscationConfiguration?
        /// The top-level internet domain name for which your application has administrative authority.
        public let domain: String?
        ///  List the domain names for which your application has administrative authority. The CreateAppMonitor requires either the domain or the domain list.
        public let domainList: [String]?
        /// A name for the app monitor.
        public let name: String
        /// Assigns one or more tags (key-value pairs) to the app monitor. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values. Tags don't have any semantic meaning to Amazon Web Services and are interpreted strictly as strings of characters. You can associate as many as 50 tags with an app monitor. For more information, see Tagging Amazon Web Services resources.
        public let tags: [String: String]?

        @inlinable
        public init(appMonitorConfiguration: AppMonitorConfiguration? = nil, customEvents: CustomEvents? = nil, cwLogEnabled: Bool? = nil, deobfuscationConfiguration: DeobfuscationConfiguration? = nil, domain: String? = nil, domainList: [String]? = nil, name: String, tags: [String: String]? = nil) {
            self.appMonitorConfiguration = appMonitorConfiguration
            self.customEvents = customEvents
            self.cwLogEnabled = cwLogEnabled
            self.deobfuscationConfiguration = deobfuscationConfiguration
            self.domain = domain
            self.domainList = domainList
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.appMonitorConfiguration?.validate(name: "\(name).appMonitorConfiguration")
            try self.deobfuscationConfiguration?.validate(name: "\(name).deobfuscationConfiguration")
            try self.validate(self.domain, name: "domain", parent: name, max: 253)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^(localhost)$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|(?=^[a-zA-Z0-9\\.\\*-]{4,253}$)(?!.*\\.-)(?!.*-\\.)(?!.*\\.\\.)(?!.*[^\\.]{64,})^(\\*\\.)?(?![-\\.\\*])[^\\*]{1,}\\.(\\*|(?!.*--)(?=.*[a-zA-Z])[^\\*]{1,}[^\\*-])$")
            try self.domainList?.forEach {
                try validate($0, name: "domainList[]", parent: name, max: 253)
                try validate($0, name: "domainList[]", parent: name, min: 1)
                try validate($0, name: "domainList[]", parent: name, pattern: "^(localhost)$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|(?=^[a-zA-Z0-9\\.\\*-]{4,253}$)(?!.*\\.-)(?!.*-\\.)(?!.*\\.\\.)(?!.*[^\\.]{64,})^(\\*\\.)?(?![-\\.\\*])[^\\*]{1,}\\.(\\*|(?!.*--)(?=.*[a-zA-Z])[^\\*]{1,}[^\\*-])$")
            }
            try self.validate(self.domainList, name: "domainList", parent: name, max: 5)
            try self.validate(self.domainList, name: "domainList", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case appMonitorConfiguration = "AppMonitorConfiguration"
            case customEvents = "CustomEvents"
            case cwLogEnabled = "CwLogEnabled"
            case deobfuscationConfiguration = "DeobfuscationConfiguration"
            case domain = "Domain"
            case domainList = "DomainList"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateAppMonitorResponse: AWSDecodableShape {
        /// The unique ID of the new app monitor.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct CustomEvents: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be DISABLED.
        public let status: CustomEventsStatus?

        @inlinable
        public init(status: CustomEventsStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct CwLog: AWSDecodableShape {
        /// Indicated whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs.
        public let cwLogEnabled: Bool?
        /// The name of the log group where the copies are stored.
        public let cwLogGroup: String?

        @inlinable
        public init(cwLogEnabled: Bool? = nil, cwLogGroup: String? = nil) {
            self.cwLogEnabled = cwLogEnabled
            self.cwLogGroup = cwLogGroup
        }

        private enum CodingKeys: String, CodingKey {
            case cwLogEnabled = "CwLogEnabled"
            case cwLogGroup = "CwLogGroup"
        }
    }

    public struct DataStorage: AWSDecodableShape {
        /// A structure that contains the information about whether the app monitor stores copies of the data that RUM collects in CloudWatch Logs. If it does, this structure also contains the name of the log group.
        public let cwLog: CwLog?

        @inlinable
        public init(cwLog: CwLog? = nil) {
            self.cwLog = cwLog
        }

        private enum CodingKeys: String, CodingKey {
            case cwLog = "CwLog"
        }
    }

    public struct DeleteAppMonitorRequest: AWSEncodableShape {
        /// The name of the app monitor to delete.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAppMonitorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The app monitor that you want to remove the resource policy from.
        public let name: String
        /// Specifies a specific policy revision to delete. Provide a PolicyRevisionId to ensure an atomic delete operation.  If the revision ID that you provide doesn't match the latest policy revision ID, the request will be rejected with an InvalidPolicyRevisionIdException error.
        public let policyRevisionId: String?

        @inlinable
        public init(name: String, policyRevisionId: String? = nil) {
            self.name = name
            self.policyRevisionId = policyRevisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            request.encodeQuery(self.policyRevisionId, key: "policyRevisionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.policyRevisionId, name: "policyRevisionId", parent: name, max: 255)
            try self.validate(self.policyRevisionId, name: "policyRevisionId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        /// The revision ID of the policy that was removed, if it had one.
        public let policyRevisionId: String?

        @inlinable
        public init(policyRevisionId: String? = nil) {
            self.policyRevisionId = policyRevisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policyRevisionId = "PolicyRevisionId"
        }
    }

    public struct DeleteRumMetricsDestinationRequest: AWSEncodableShape {
        /// The name of the app monitor that is sending metrics to the destination that you want to delete.
        public let appMonitorName: String
        /// The type of destination to delete. Valid values are CloudWatch and Evidently.
        public let destination: MetricDestination
        /// This parameter is required if Destination is Evidently. If Destination is  CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that corresponds to the destination to delete.
        public let destinationArn: String?

        @inlinable
        public init(appMonitorName: String, destination: MetricDestination, destinationArn: String? = nil) {
            self.appMonitorName = appMonitorName
            self.destination = destination
            self.destinationArn = destinationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appMonitorName, key: "AppMonitorName")
            request.encodeQuery(self.destination, key: "destination")
            request.encodeQuery(self.destinationArn, key: "destinationArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, max: 255)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, min: 1)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRumMetricsDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeobfuscationConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  A structure that contains the configuration for how an app monitor can unminify JavaScript error stack traces using source maps.
        public let javaScriptSourceMaps: JavaScriptSourceMaps?

        @inlinable
        public init(javaScriptSourceMaps: JavaScriptSourceMaps? = nil) {
            self.javaScriptSourceMaps = javaScriptSourceMaps
        }

        public func validate(name: String) throws {
            try self.javaScriptSourceMaps?.validate(name: "\(name).javaScriptSourceMaps")
        }

        private enum CodingKeys: String, CodingKey {
            case javaScriptSourceMaps = "JavaScriptSourceMaps"
        }
    }

    public struct GetAppMonitorDataRequest: AWSEncodableShape {
        /// An array of structures that you can use to filter the results to those that match one or more sets of key-value pairs that you specify.
        public let filters: [QueryFilter]?
        /// The maximum number of results to return in one operation.
        public let maxResults: Int?
        /// The name of the app monitor that collected the data that you want to retrieve.
        public let name: String
        /// Use the token returned by the previous operation to request the next page of results.
        public let nextToken: String?
        /// A structure that defines the time range that you want to retrieve results from.
        public let timeRange: TimeRange

        @inlinable
        public init(filters: [QueryFilter]? = nil, maxResults: Int? = nil, name: String, nextToken: String? = nil, timeRange: TimeRange) {
            self.filters = filters
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.timeRange = timeRange
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.timeRange, forKey: .timeRange)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case timeRange = "TimeRange"
        }
    }

    public struct GetAppMonitorDataResponse: AWSDecodableShape {
        /// The events that RUM collected that match your request.
        public let events: [String]?
        /// A token that you can use in a subsequent operation to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(events: [String]? = nil, nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "Events"
            case nextToken = "NextToken"
        }
    }

    public struct GetAppMonitorRequest: AWSEncodableShape {
        /// The app monitor to retrieve information for.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAppMonitorResponse: AWSDecodableShape {
        /// A structure containing all the configuration information for the app monitor.
        public let appMonitor: AppMonitor?

        @inlinable
        public init(appMonitor: AppMonitor? = nil) {
            self.appMonitor = appMonitor
        }

        private enum CodingKeys: String, CodingKey {
            case appMonitor = "AppMonitor"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The name of the app monitor that is associated with the resource-based policy that you want to view.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The JSON policy document that you requested.
        public let policyDocument: String?
        /// The revision ID information for this version of the policy document that you requested.
        public let policyRevisionId: String?

        @inlinable
        public init(policyDocument: String? = nil, policyRevisionId: String? = nil) {
            self.policyDocument = policyDocument
            self.policyRevisionId = policyRevisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
            case policyRevisionId = "PolicyRevisionId"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The value of a parameter in the request caused an error.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct JavaScriptSourceMaps: AWSEncodableShape & AWSDecodableShape {
        ///  The S3Uri of the bucket or folder that stores the source map files. It is required if status is ENABLED.
        public let s3Uri: String?
        ///  Specifies whether JavaScript error stack traces should be unminified for this app monitor. The default is for JavaScript error stack trace unminification to be DISABLED.
        public let status: DeobfuscationStatus

        @inlinable
        public init(s3Uri: String? = nil, status: DeobfuscationStatus) {
            self.s3Uri = s3Uri
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 1024)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://[a-z0-9][-.a-z0-9]{1,61}(?:/[-!_*'().a-z0-9A-Z]+(?:/[-!_*'().a-z0-9A-Z]+)*)?/?$")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Uri = "S3Uri"
            case status = "Status"
        }
    }

    public struct ListAppMonitorsRequest: AWSEncodableShape {
        /// The maximum number of results to return in one operation. The default is 50. The maximum that you can  specify is 100.
        public let maxResults: Int?
        /// Use the token returned by the previous operation to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAppMonitorsResponse: AWSDecodableShape {
        /// An array of structures that contain information about the returned app monitors.
        public let appMonitorSummaries: [AppMonitorSummary]?
        /// A token that you can use in a subsequent operation to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(appMonitorSummaries: [AppMonitorSummary]? = nil, nextToken: String? = nil) {
            self.appMonitorSummaries = appMonitorSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case appMonitorSummaries = "AppMonitorSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListRumMetricsDestinationsRequest: AWSEncodableShape {
        /// The name of the app monitor associated with the destinations that you want to retrieve.
        public let appMonitorName: String
        /// The maximum number of results to return in one operation. The default is 50. The maximum that you can  specify is 100. To retrieve the remaining results, make another call with the returned  NextToken value.
        public let maxResults: Int?
        /// Use the token returned by the previous operation to request the next page of results.
        public let nextToken: String?

        @inlinable
        public init(appMonitorName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.appMonitorName = appMonitorName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appMonitorName, key: "AppMonitorName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, max: 255)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, min: 1)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRumMetricsDestinationsResponse: AWSDecodableShape {
        /// The list of CloudWatch RUM extended metrics destinations associated with the app monitor that  you specified.
        public let destinations: [MetricDestinationSummary]?
        /// A token that you can use in a subsequent operation to  retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(destinations: [MetricDestinationSummary]? = nil, nextToken: String? = nil) {
            self.destinations = destinations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case destinations = "Destinations"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the resource that you want to see the tags of.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The ARN of the resource that you are viewing.
        public let resourceArn: String
        /// The list of tag keys and values associated with the resource you specified.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct MetricDefinition: AWSDecodableShape {
        /// This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch The value of this field is used only if the metric destination is CloudWatch. If the metric destination is Evidently, the value of DimensionKeys is ignored.
        public let dimensionKeys: [String: String]?
        /// The pattern that defines the metric. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination. If the metrics destination is CloudWatch and the event also matches a value in DimensionKeys, then the metric is published with the specified dimensions.
        public let eventPattern: String?
        /// The ID of this metric definition.
        public let metricDefinitionId: String
        /// The name of the metric that is defined in this structure.
        public let name: String
        /// If this metric definition is for a custom metric instead of an extended metric, this field displays the metric namespace that the custom metric is published to.
        public let namespace: String?
        /// Use this field only if you are sending this metric to CloudWatch. It defines the CloudWatch metric unit that this metric is measured in.
        public let unitLabel: String?
        /// The field within the event object that the metric value is sourced from.
        public let valueKey: String?

        @inlinable
        public init(dimensionKeys: [String: String]? = nil, eventPattern: String? = nil, metricDefinitionId: String, name: String, namespace: String? = nil, unitLabel: String? = nil, valueKey: String? = nil) {
            self.dimensionKeys = dimensionKeys
            self.eventPattern = eventPattern
            self.metricDefinitionId = metricDefinitionId
            self.name = name
            self.namespace = namespace
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionKeys = "DimensionKeys"
            case eventPattern = "EventPattern"
            case metricDefinitionId = "MetricDefinitionId"
            case name = "Name"
            case namespace = "Namespace"
            case unitLabel = "UnitLabel"
            case valueKey = "ValueKey"
        }
    }

    public struct MetricDefinitionRequest: AWSEncodableShape & AWSDecodableShape {
        /// Use this field only if you are sending the metric to CloudWatch. This field is a map of field paths to dimension names. It defines the dimensions to associate with this metric in CloudWatch. For extended metrics, valid values for the entries in this field are the following:    "metadata.pageId": "PageId"     "metadata.browserName": "BrowserName"     "metadata.deviceType": "DeviceType"     "metadata.osName": "OSName"     "metadata.countryCode": "CountryCode"     "event_details.fileType": "FileType"    For both extended metrics and custom metrics,  all dimensions listed in this field must also be included in EventPattern.
        public let dimensionKeys: [String: String]?
        /// The pattern that defines the metric, specified as a JSON object. RUM checks events that happen in a user's session against the pattern, and events that match the pattern are sent to the metric destination. When you define extended metrics, the metric definition is not valid if EventPattern is omitted. Example event patterns:    '{ "event_type": ["com.amazon.rum.js_error_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], } }'     '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Firefox" ] }, "event_details": { "duration": [{ "numeric": [ "&lt;", 2000 ] }] } }'     '{ "event_type": ["com.amazon.rum.performance_navigation_event"], "metadata": { "browserName": [ "Chrome", "Safari" ], "countryCode": [ "US" ] }, "event_details": { "duration": [{ "numeric": [ "&gt;=", 2000, "&lt;", 8000 ] }] } }'    If the metrics destination is CloudWatch and the event also matches a value in DimensionKeys, then the metric is published with the specified dimensions.
        public let eventPattern: String?
        /// The name for the metric that is defined in this structure. For custom metrics, you can specify  any name that you like. For extended metrics, valid values are the following:    PerformanceNavigationDuration     PerformanceResourceDuration      NavigationSatisfiedTransaction     NavigationToleratedTransaction     NavigationFrustratedTransaction     WebVitalsCumulativeLayoutShift     WebVitalsFirstInputDelay     WebVitalsLargestContentfulPaint     JsErrorCount     HttpErrorCount     SessionCount
        public let name: String
        /// If this structure is for a custom metric instead of an extended metrics, use this parameter to define the  metric namespace for that custom metric. Do not specify this parameter if this structure is for an extended metric. You cannot use any string that starts with AWS/ for your namespace.
        public let namespace: String?
        /// The CloudWatch metric unit to use for this metric. If you omit this field, the metric is recorded with no unit.
        public let unitLabel: String?
        /// The field within the event object that the metric value is sourced from. If you omit this field, a hardcoded value of 1 is pushed as the metric value. This is useful if you want to count the number of events that the filter catches.  If this metric is sent to CloudWatch Evidently, this field will be passed to Evidently raw. Evidently will handle data extraction from the event.
        public let valueKey: String?

        @inlinable
        public init(dimensionKeys: [String: String]? = nil, eventPattern: String? = nil, name: String, namespace: String? = nil, unitLabel: String? = nil, valueKey: String? = nil) {
            self.dimensionKeys = dimensionKeys
            self.eventPattern = eventPattern
            self.name = name
            self.namespace = namespace
            self.unitLabel = unitLabel
            self.valueKey = valueKey
        }

        public func validate(name: String) throws {
            try self.dimensionKeys?.forEach {
                try validate($0.key, name: "dimensionKeys.key", parent: name, max: 280)
                try validate($0.key, name: "dimensionKeys.key", parent: name, min: 1)
                try validate($0.value, name: "dimensionKeys[\"\($0.key)\"]", parent: name, max: 255)
                try validate($0.value, name: "dimensionKeys[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "dimensionKeys[\"\($0.key)\"]", parent: name, pattern: "^(?!:).*[^\\s].*")
            }
            try self.validate(self.dimensionKeys, name: "dimensionKeys", parent: name, max: 29)
            try self.validate(self.eventPattern, name: "eventPattern", parent: name, max: 4000)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 237)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "[a-zA-Z0-9-._/#:]+$")
            try self.validate(self.unitLabel, name: "unitLabel", parent: name, max: 256)
            try self.validate(self.unitLabel, name: "unitLabel", parent: name, min: 1)
            try self.validate(self.valueKey, name: "valueKey", parent: name, max: 280)
            try self.validate(self.valueKey, name: "valueKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionKeys = "DimensionKeys"
            case eventPattern = "EventPattern"
            case name = "Name"
            case namespace = "Namespace"
            case unitLabel = "UnitLabel"
            case valueKey = "ValueKey"
        }
    }

    public struct MetricDestinationSummary: AWSDecodableShape {
        /// Specifies whether the destination is CloudWatch or Evidently.
        public let destination: MetricDestination?
        /// If the destination is Evidently, this specifies the ARN of the Evidently experiment that receives the metrics.
        public let destinationArn: String?
        /// This field appears only when the destination is Evidently. It specifies the ARN of the IAM role that is used to write to the Evidently experiment that receives the metrics.
        public let iamRoleArn: String?

        @inlinable
        public init(destination: MetricDestination? = nil, destinationArn: String? = nil, iamRoleArn: String? = nil) {
            self.destination = destination
            self.destinationArn = destinationArn
            self.iamRoleArn = iamRoleArn
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case destinationArn = "DestinationArn"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// The name of the app monitor that you want to apply this resource-based policy to. To find the names of your app monitors, you can use the ListAppMonitors operation.
        public let name: String
        /// The JSON to use as the resource policy. The document can be up to 4 KB in size. For more information about the contents and syntax  for this policy, see Using resource-based policies with CloudWatch RUM.
        public let policyDocument: String
        /// A string value that you can use to conditionally update your policy. You can provide the revision ID of your existing policy to make mutating requests against that policy. When you assign a policy revision ID, then later requests about that policy will be rejected with an InvalidPolicyRevisionIdException error if they don't provide the correct current revision ID.
        public let policyRevisionId: String?

        @inlinable
        public init(name: String, policyDocument: String, policyRevisionId: String? = nil) {
            self.name = name
            self.policyDocument = policyDocument
            self.policyRevisionId = policyRevisionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.name, key: "Name")
            try container.encode(self.policyDocument, forKey: .policyDocument)
            try container.encodeIfPresent(self.policyRevisionId, forKey: .policyRevisionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.policyRevisionId, name: "policyRevisionId", parent: name, max: 255)
            try self.validate(self.policyRevisionId, name: "policyRevisionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
            case policyRevisionId = "PolicyRevisionId"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        /// The JSON policy document that you specified.
        public let policyDocument: String?
        /// The policy revision ID information that you specified.
        public let policyRevisionId: String?

        @inlinable
        public init(policyDocument: String? = nil, policyRevisionId: String? = nil) {
            self.policyDocument = policyDocument
            self.policyRevisionId = policyRevisionId
        }

        private enum CodingKeys: String, CodingKey {
            case policyDocument = "PolicyDocument"
            case policyRevisionId = "PolicyRevisionId"
        }
    }

    public struct PutRumEventsRequest: AWSEncodableShape {
        /// If the app monitor uses a resource-based policy that requires PutRumEvents requests to specify a certain alias, specify that alias here. This alias will be compared to the rum:alias context key in the resource-based policy.  For more information, see Using resource-based policies with CloudWatch RUM.
        public let alias: String?
        /// A structure that contains information about the app monitor that collected this telemetry information.
        public let appMonitorDetails: AppMonitorDetails
        /// A unique identifier for this batch of RUM event data.
        public let batchId: String
        /// The ID of the app monitor that is sending this data.
        public let id: String
        /// An array of structures that contain the telemetry event data.
        public let rumEvents: [RumEvent]
        /// A structure that contains information about the user session that this batch of events was collected from.
        public let userDetails: UserDetails

        @inlinable
        public init(alias: String? = nil, appMonitorDetails: AppMonitorDetails, batchId: String, id: String, rumEvents: [RumEvent], userDetails: UserDetails) {
            self.alias = alias
            self.appMonitorDetails = appMonitorDetails
            self.batchId = batchId
            self.id = id
            self.rumEvents = rumEvents
            self.userDetails = userDetails
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.alias, forKey: .alias)
            try container.encode(self.appMonitorDetails, forKey: .appMonitorDetails)
            try container.encode(self.batchId, forKey: .batchId)
            request.encodePath(self.id, key: "Id")
            try container.encode(self.rumEvents, forKey: .rumEvents)
            try container.encode(self.userDetails, forKey: .userDetails)
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 255)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 36)
            try self.validate(self.id, name: "id", parent: name, min: 36)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case alias = "Alias"
            case appMonitorDetails = "AppMonitorDetails"
            case batchId = "BatchId"
            case rumEvents = "RumEvents"
            case userDetails = "UserDetails"
        }
    }

    public struct PutRumEventsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PutRumMetricsDestinationRequest: AWSEncodableShape {
        /// The name of the CloudWatch RUM app monitor that will send the metrics.
        public let appMonitorName: String
        /// Defines the destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the CloudWatchEvidently experiment that is to  be the destination and an IAM role that has permission to write to the experiment.
        public let destination: MetricDestination
        /// Use this parameter only if Destination is Evidently. This parameter specifies the ARN of the Evidently experiment that will receive the extended metrics.
        public let destinationArn: String?
        /// This parameter is required if Destination is Evidently. If Destination is  CloudWatch, don't use this parameter. This parameter specifies the ARN of an IAM role that RUM will assume to write to the Evidently  experiment that you are sending metrics to. This role must have permission to write to that experiment. If you specify this parameter, you must be signed on to a role that has PassRole permissions attached to it, to allow the role to be passed. The  CloudWatchAmazonCloudWatchRUMFullAccess policy doesn't include PassRole permissions.
        public let iamRoleArn: String?

        @inlinable
        public init(appMonitorName: String, destination: MetricDestination, destinationArn: String? = nil, iamRoleArn: String? = nil) {
            self.appMonitorName = appMonitorName
            self.destination = destination
            self.destinationArn = destinationArn
            self.iamRoleArn = iamRoleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appMonitorName, key: "AppMonitorName")
            try container.encode(self.destination, forKey: .destination)
            try container.encodeIfPresent(self.destinationArn, forKey: .destinationArn)
            try container.encodeIfPresent(self.iamRoleArn, forKey: .iamRoleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, max: 255)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, min: 1)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.validate(self.iamRoleArn, name: "iamRoleArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case destinationArn = "DestinationArn"
            case iamRoleArn = "IamRoleArn"
        }
    }

    public struct PutRumMetricsDestinationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct QueryFilter: AWSEncodableShape {
        /// The name of a key to search for.  The filter returns only the events that match the Name and Values that you specify.  Valid values for Name are Browser | Device | Country | Page | OS | EventType | Invert
        public let name: String?
        /// The values of the Name that are to be be included in the returned results.
        public let values: [String]?

        @inlinable
        public init(name: String? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The name of the resource that is associated with the error.
        public let resourceName: String
        /// The type of the resource that is associated with the error.
        public let resourceType: String?

        @inlinable
        public init(message: String, resourceName: String, resourceType: String? = nil) {
            self.message = message
            self.resourceName = resourceName
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
            case resourceType = "resourceType"
        }
    }

    public struct RumEvent: AWSEncodableShape {
        /// A string containing details about the event.
        public let details: String
        /// A unique ID for this event.
        public let id: String
        /// Metadata about this event, which contains a JSON serialization of the identity of the user for this session. The user information comes from information such as the HTTP user-agent request header and document interface.
        public let metadata: String?
        /// The exact time that this event occurred.
        public let timestamp: Date
        /// The JSON schema that denotes the type of event this is, such as a page load or a new session.
        public let type: String

        @inlinable
        public init(details: String, id: String, metadata: String? = nil, timestamp: Date, type: String) {
            self.details = details
            self.id = id
            self.metadata = metadata
            self.timestamp = timestamp
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case details = "details"
            case id = "id"
            case metadata = "metadata"
            case timestamp = "timestamp"
            case type = "type"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the CloudWatch RUM resource that you're adding tags to.
        public let resourceArn: String
        /// The list of key-value pairs to associate with the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The ID of the service quota that was exceeded.
        public let quotaCode: String?
        /// The value of a parameter in the request caused an error.
        public let retryAfterSeconds: Int?
        /// The ID of the service that is associated with the error.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct TimeRange: AWSEncodableShape {
        /// The beginning of the time range to retrieve performance events from.
        public let after: Int64
        /// The end of the time range to retrieve performance events from. If you omit this, the time  range extends to the time that this operation is performed.
        public let before: Int64?

        @inlinable
        public init(after: Int64 = 0, before: Int64? = nil) {
            self.after = after
            self.before = before
        }

        private enum CodingKeys: String, CodingKey {
            case after = "After"
            case before = "Before"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the CloudWatch RUM resource that you're removing tags from.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAppMonitorRequest: AWSEncodableShape {
        /// A structure that contains much of the configuration data for the app monitor. If you are using  Amazon Cognito for authorization, you must include this structure in your request, and it must include the ID of the  Amazon Cognito identity pool to use for authorization. If you don't include AppMonitorConfiguration, you must set up your own  authorization method. For more information, see  Authorize your application to send data to Amazon Web Services.
        public let appMonitorConfiguration: AppMonitorConfiguration?
        /// Specifies whether this app monitor allows the web client to define and send custom events. The default is for custom events to be DISABLED. For more information about custom events, see  Send custom events.
        public let customEvents: CustomEvents?
        /// Data collected by RUM is kept by RUM for 30 days and then deleted. This parameter specifies whether RUM  sends a copy of this telemetry data to Amazon CloudWatch Logs in your account. This enables you to keep the telemetry data for more than 30 days, but it does incur Amazon CloudWatch Logs charges.
        public let cwLogEnabled: Bool?
        ///  A structure that contains the configuration for how an app monitor can deobfuscate stack traces.
        public let deobfuscationConfiguration: DeobfuscationConfiguration?
        /// The top-level internet domain name for which your application has administrative authority.
        public let domain: String?
        ///  List the domain names for which your application has administrative authority. The UpdateAppMonitor allows either the domain or the domain list.
        public let domainList: [String]?
        /// The name of the app monitor to update.
        public let name: String

        @inlinable
        public init(appMonitorConfiguration: AppMonitorConfiguration? = nil, customEvents: CustomEvents? = nil, cwLogEnabled: Bool? = nil, deobfuscationConfiguration: DeobfuscationConfiguration? = nil, domain: String? = nil, domainList: [String]? = nil, name: String) {
            self.appMonitorConfiguration = appMonitorConfiguration
            self.customEvents = customEvents
            self.cwLogEnabled = cwLogEnabled
            self.deobfuscationConfiguration = deobfuscationConfiguration
            self.domain = domain
            self.domainList = domainList
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.appMonitorConfiguration, forKey: .appMonitorConfiguration)
            try container.encodeIfPresent(self.customEvents, forKey: .customEvents)
            try container.encodeIfPresent(self.cwLogEnabled, forKey: .cwLogEnabled)
            try container.encodeIfPresent(self.deobfuscationConfiguration, forKey: .deobfuscationConfiguration)
            try container.encodeIfPresent(self.domain, forKey: .domain)
            try container.encodeIfPresent(self.domainList, forKey: .domainList)
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.appMonitorConfiguration?.validate(name: "\(name).appMonitorConfiguration")
            try self.deobfuscationConfiguration?.validate(name: "\(name).deobfuscationConfiguration")
            try self.validate(self.domain, name: "domain", parent: name, max: 253)
            try self.validate(self.domain, name: "domain", parent: name, min: 1)
            try self.validate(self.domain, name: "domain", parent: name, pattern: "^(localhost)$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|(?=^[a-zA-Z0-9\\.\\*-]{4,253}$)(?!.*\\.-)(?!.*-\\.)(?!.*\\.\\.)(?!.*[^\\.]{64,})^(\\*\\.)?(?![-\\.\\*])[^\\*]{1,}\\.(\\*|(?!.*--)(?=.*[a-zA-Z])[^\\*]{1,}[^\\*-])$")
            try self.domainList?.forEach {
                try validate($0, name: "domainList[]", parent: name, max: 253)
                try validate($0, name: "domainList[]", parent: name, min: 1)
                try validate($0, name: "domainList[]", parent: name, pattern: "^(localhost)$|^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|(?=^[a-zA-Z0-9\\.\\*-]{4,253}$)(?!.*\\.-)(?!.*-\\.)(?!.*\\.\\.)(?!.*[^\\.]{64,})^(\\*\\.)?(?![-\\.\\*])[^\\*]{1,}\\.(\\*|(?!.*--)(?=.*[a-zA-Z])[^\\*]{1,}[^\\*-])$")
            }
            try self.validate(self.domainList, name: "domainList", parent: name, max: 5)
            try self.validate(self.domainList, name: "domainList", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case appMonitorConfiguration = "AppMonitorConfiguration"
            case customEvents = "CustomEvents"
            case cwLogEnabled = "CwLogEnabled"
            case deobfuscationConfiguration = "DeobfuscationConfiguration"
            case domain = "Domain"
            case domainList = "DomainList"
        }
    }

    public struct UpdateAppMonitorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRumMetricDefinitionRequest: AWSEncodableShape {
        /// The name of the CloudWatch RUM app monitor that sends these metrics.
        public let appMonitorName: String
        /// The destination to send the metrics to. Valid values are CloudWatch and Evidently. If you specify Evidently, you must also specify the ARN of the CloudWatchEvidently experiment  that will receive the metrics and an IAM role that has permission to write to the experiment.
        public let destination: MetricDestination
        /// This parameter is required if Destination is Evidently. If Destination is  CloudWatch, do not use this parameter. This parameter specifies the ARN of the Evidently experiment that is to receive the metrics. You must have already defined this  experiment as a valid destination. For more information, see PutRumMetricsDestination.
        public let destinationArn: String?
        /// A structure that contains the new definition that you want to use for this metric.
        public let metricDefinition: MetricDefinitionRequest
        /// The ID of the metric definition to update.
        public let metricDefinitionId: String

        @inlinable
        public init(appMonitorName: String, destination: MetricDestination, destinationArn: String? = nil, metricDefinition: MetricDefinitionRequest, metricDefinitionId: String) {
            self.appMonitorName = appMonitorName
            self.destination = destination
            self.destinationArn = destinationArn
            self.metricDefinition = metricDefinition
            self.metricDefinitionId = metricDefinitionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.appMonitorName, key: "AppMonitorName")
            try container.encode(self.destination, forKey: .destination)
            try container.encodeIfPresent(self.destinationArn, forKey: .destinationArn)
            try container.encode(self.metricDefinition, forKey: .metricDefinition)
            try container.encode(self.metricDefinitionId, forKey: .metricDefinitionId)
        }

        public func validate(name: String) throws {
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, max: 255)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, min: 1)
            try self.validate(self.appMonitorName, name: "appMonitorName", parent: name, pattern: "^(?!\\.)[\\.\\-_#A-Za-z0-9]+$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "arn:[^:]*:[^:]*:[^:]*:[^:]*:.*")
            try self.metricDefinition.validate(name: "\(name).metricDefinition")
            try self.validate(self.metricDefinitionId, name: "metricDefinitionId", parent: name, max: 255)
            try self.validate(self.metricDefinitionId, name: "metricDefinitionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case destinationArn = "DestinationArn"
            case metricDefinition = "MetricDefinition"
            case metricDefinitionId = "MetricDefinitionId"
        }
    }

    public struct UpdateRumMetricDefinitionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserDetails: AWSEncodableShape {
        /// The session ID that the performance events are from.
        public let sessionId: String?
        /// The ID of the user for this user session. This ID is generated by RUM and does not include any  personally identifiable information about the user.
        public let userId: String?

        @inlinable
        public init(sessionId: String? = nil, userId: String? = nil) {
            self.sessionId = sessionId
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case sessionId = "sessionId"
            case userId = "userId"
        }
    }
}

// MARK: - Errors

/// Error enum for RUM
public struct RUMErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case invalidPolicyRevisionIdException = "InvalidPolicyRevisionIdException"
        case malformedPolicyDocumentException = "MalformedPolicyDocumentException"
        case policyNotFoundException = "PolicyNotFoundException"
        case policySizeLimitExceededException = "PolicySizeLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize RUM
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// This operation attempted to create a resource that already exists.
    public static var conflictException: Self { .init(.conflictException) }
    /// Internal service exception.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The policy revision ID that you provided doeesn't match the latest policy revision ID.
    public static var invalidPolicyRevisionIdException: Self { .init(.invalidPolicyRevisionIdException) }
    /// The policy document that you specified is not formatted correctly.
    public static var malformedPolicyDocumentException: Self { .init(.malformedPolicyDocumentException) }
    /// The resource-based policy doesn't exist on this app monitor.
    public static var policyNotFoundException: Self { .init(.policyNotFoundException) }
    /// The policy document is too large. The limit is 4 KB.
    public static var policySizeLimitExceededException: Self { .init(.policySizeLimitExceededException) }
    /// Resource not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// This request exceeds a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was throttled because of quota limits.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One of the arguments for the request is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension RUMErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": RUM.ConflictException.self,
        "InternalServerException": RUM.InternalServerException.self,
        "ResourceNotFoundException": RUM.ResourceNotFoundException.self,
        "ThrottlingException": RUM.ThrottlingException.self
    ]
}

extension RUMErrorType: Equatable {
    public static func == (lhs: RUMErrorType, rhs: RUMErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RUMErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
