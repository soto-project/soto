//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PCS {
    // MARK: Enums

    public enum ClusterStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum ComputeNodeGroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleted = "DELETED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EndpointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case slurmctld = "SLURMCTLD"
        case slurmdbd = "SLURMDBD"
        public var description: String { return self.rawValue }
    }

    public enum PurchaseOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ondemand = "ONDEMAND"
        case spot = "SPOT"
        public var description: String { return self.rawValue }
    }

    public enum QueueStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case createFailed = "CREATE_FAILED"
        case creating = "CREATING"
        case deleteFailed = "DELETE_FAILED"
        case deleting = "DELETING"
        case updateFailed = "UPDATE_FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum SchedulerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case slurm = "SLURM"
        public var description: String { return self.rawValue }
    }

    public enum Size: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case large = "LARGE"
        case medium = "MEDIUM"
        case small = "SMALL"
        public var description: String { return self.rawValue }
    }

    public enum SpotAllocationStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case capacityOptimized = "capacity-optimized"
        case lowestPrice = "lowest-price"
        case priceCapacityOptimized = "price-capacity-optimized"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Cluster: AWSDecodableShape {
        /// The unique Amazon Resource Name (ARN) of the cluster.
        public let arn: String
        /// The date and time the resource was created.
        public let createdAt: Date
        /// The list of endpoints available for interaction with the scheduler.
        public let endpoints: [Endpoint]?
        /// The list of errors that occurred during cluster provisioning.
        public let errorInfo: [ErrorInfo]?
        /// The generated unique ID of the cluster.
        public let id: String
        /// The date and time the resource was modified.
        public let modifiedAt: Date
        /// The name that identifies the cluster.
        public let name: String
        public let networking: Networking
        public let scheduler: Scheduler
        /// The size of the cluster.    SMALL: 32 compute nodes and 256 jobs    MEDIUM: 512 compute nodes and 8192 jobs    LARGE: 2048 compute nodes and 16,384 jobs
        public let size: Size
        /// Additional options related to the Slurm scheduler.
        public let slurmConfiguration: ClusterSlurmConfiguration?
        /// The provisioning status of the cluster.  The provisioning status doesn't indicate the overall health of the cluster.
        public let status: ClusterStatus

        public init(arn: String, createdAt: Date, endpoints: [Endpoint]? = nil, errorInfo: [ErrorInfo]? = nil, id: String, modifiedAt: Date, name: String, networking: Networking, scheduler: Scheduler, size: Size, slurmConfiguration: ClusterSlurmConfiguration? = nil, status: ClusterStatus) {
            self.arn = arn
            self.createdAt = createdAt
            self.endpoints = endpoints
            self.errorInfo = errorInfo
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.networking = networking
            self.scheduler = scheduler
            self.size = size
            self.slurmConfiguration = slurmConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case endpoints = "endpoints"
            case errorInfo = "errorInfo"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case networking = "networking"
            case scheduler = "scheduler"
            case size = "size"
            case slurmConfiguration = "slurmConfiguration"
            case status = "status"
        }
    }

    public struct ClusterSlurmConfiguration: AWSDecodableShape {
        /// The shared Slurm key for authentication, also known as the cluster secret.
        public let authKey: SlurmAuthKey?
        /// The time before an idle node is scaled down.
        public let scaleDownIdleTimeInSeconds: Int?
        /// Additional Slurm-specific configuration that directly maps to Slurm settings.
        public let slurmCustomSettings: [SlurmCustomSetting]?

        public init(authKey: SlurmAuthKey? = nil, scaleDownIdleTimeInSeconds: Int? = nil, slurmCustomSettings: [SlurmCustomSetting]? = nil) {
            self.authKey = authKey
            self.scaleDownIdleTimeInSeconds = scaleDownIdleTimeInSeconds
            self.slurmCustomSettings = slurmCustomSettings
        }

        private enum CodingKeys: String, CodingKey {
            case authKey = "authKey"
            case scaleDownIdleTimeInSeconds = "scaleDownIdleTimeInSeconds"
            case slurmCustomSettings = "slurmCustomSettings"
        }
    }

    public struct ClusterSlurmConfigurationRequest: AWSEncodableShape {
        /// The time before an idle node is scaled down.
        public let scaleDownIdleTimeInSeconds: Int?
        /// Additional Slurm-specific configuration that directly maps to Slurm settings.
        public let slurmCustomSettings: [SlurmCustomSetting]?

        public init(scaleDownIdleTimeInSeconds: Int? = nil, slurmCustomSettings: [SlurmCustomSetting]? = nil) {
            self.scaleDownIdleTimeInSeconds = scaleDownIdleTimeInSeconds
            self.slurmCustomSettings = slurmCustomSettings
        }

        private enum CodingKeys: String, CodingKey {
            case scaleDownIdleTimeInSeconds = "scaleDownIdleTimeInSeconds"
            case slurmCustomSettings = "slurmCustomSettings"
        }
    }

    public struct ClusterSummary: AWSDecodableShape {
        /// The unique Amazon Resource Name (ARN) of the cluster.
        public let arn: String
        /// The date and time the resource was created.
        public let createdAt: Date
        /// The generated unique ID of the cluster.
        public let id: String
        /// The date and time the resource was modified.
        public let modifiedAt: Date
        /// The name that identifies the cluster.
        public let name: String
        /// The provisioning status of the cluster.  The provisioning status doesn't indicate the overall health of the cluster.
        public let status: ClusterStatus

        public init(arn: String, createdAt: Date, id: String, modifiedAt: Date, name: String, status: ClusterStatus) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct ComputeNodeGroup: AWSDecodableShape {
        /// The ID of the Amazon Machine Image (AMI) that Amazon Web Services PCS uses to launch instances. If not provided, Amazon Web Services PCS uses the AMI ID specified in the custom launch template.
        public let amiId: String?
        /// The unique Amazon Resource Name (ARN) of the compute node group.
        public let arn: String
        /// The ID of the cluster of the compute node group.
        public let clusterId: String
        /// The date and time the resource was created.
        public let createdAt: Date
        public let customLaunchTemplate: CustomLaunchTemplate
        /// The list of errors that occurred during compute node group provisioning.
        public let errorInfo: [ErrorInfo]?
        /// The Amazon Resource Name (ARN) of the  IAM instance profile used to pass an IAM role when launching EC2 instances. The role contained in your instance profile must have pcs:RegisterComputeNodeGroupInstance permissions attached to provision instances correctly.
        public let iamInstanceProfileArn: String
        /// The generated unique ID of the compute node group.
        public let id: String
        /// A list of EC2 instance configurations that Amazon Web Services PCS can provision in the compute node group.
        public let instanceConfigs: [InstanceConfig]
        /// The date and time the resource was modified.
        public let modifiedAt: Date
        /// The name that identifies the compute node group.
        public let name: String
        /// Specifies how EC2 instances are purchased on your behalf. Amazon Web Services PCS supports On-Demand and Spot instances. For more information, see Instance purchasing options in the Amazon Elastic Compute Cloud User Guide. If you don't provide this option, it defaults to On-Demand.
        public let purchaseOption: PurchaseOption?
        public let scalingConfiguration: ScalingConfiguration
        public let slurmConfiguration: ComputeNodeGroupSlurmConfiguration?
        public let spotOptions: SpotOptions?
        /// The provisioning status of the compute node group.  The provisioning status doesn't indicate the overall health of the compute node group.
        public let status: ComputeNodeGroupStatus
        /// The list of subnet IDs where instances are provisioned by the compute node group.  The subnets must be in the same VPC as the cluster.
        public let subnetIds: [String]

        public init(amiId: String? = nil, arn: String, clusterId: String, createdAt: Date, customLaunchTemplate: CustomLaunchTemplate, errorInfo: [ErrorInfo]? = nil, iamInstanceProfileArn: String, id: String, instanceConfigs: [InstanceConfig], modifiedAt: Date, name: String, purchaseOption: PurchaseOption? = nil, scalingConfiguration: ScalingConfiguration, slurmConfiguration: ComputeNodeGroupSlurmConfiguration? = nil, spotOptions: SpotOptions? = nil, status: ComputeNodeGroupStatus, subnetIds: [String]) {
            self.amiId = amiId
            self.arn = arn
            self.clusterId = clusterId
            self.createdAt = createdAt
            self.customLaunchTemplate = customLaunchTemplate
            self.errorInfo = errorInfo
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.id = id
            self.instanceConfigs = instanceConfigs
            self.modifiedAt = modifiedAt
            self.name = name
            self.purchaseOption = purchaseOption
            self.scalingConfiguration = scalingConfiguration
            self.slurmConfiguration = slurmConfiguration
            self.spotOptions = spotOptions
            self.status = status
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "amiId"
            case arn = "arn"
            case clusterId = "clusterId"
            case createdAt = "createdAt"
            case customLaunchTemplate = "customLaunchTemplate"
            case errorInfo = "errorInfo"
            case iamInstanceProfileArn = "iamInstanceProfileArn"
            case id = "id"
            case instanceConfigs = "instanceConfigs"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case purchaseOption = "purchaseOption"
            case scalingConfiguration = "scalingConfiguration"
            case slurmConfiguration = "slurmConfiguration"
            case spotOptions = "spotOptions"
            case status = "status"
            case subnetIds = "subnetIds"
        }
    }

    public struct ComputeNodeGroupConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The compute node group ID for the compute node group configuration.
        public let computeNodeGroupId: String?

        public init(computeNodeGroupId: String? = nil) {
            self.computeNodeGroupId = computeNodeGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case computeNodeGroupId = "computeNodeGroupId"
        }
    }

    public struct ComputeNodeGroupSlurmConfiguration: AWSDecodableShape {
        /// Additional Slurm-specific configuration that directly maps to Slurm settings.
        public let slurmCustomSettings: [SlurmCustomSetting]?

        public init(slurmCustomSettings: [SlurmCustomSetting]? = nil) {
            self.slurmCustomSettings = slurmCustomSettings
        }

        private enum CodingKeys: String, CodingKey {
            case slurmCustomSettings = "slurmCustomSettings"
        }
    }

    public struct ComputeNodeGroupSlurmConfigurationRequest: AWSEncodableShape {
        /// Additional Slurm-specific configuration that directly maps to Slurm settings.
        public let slurmCustomSettings: [SlurmCustomSetting]?

        public init(slurmCustomSettings: [SlurmCustomSetting]? = nil) {
            self.slurmCustomSettings = slurmCustomSettings
        }

        private enum CodingKeys: String, CodingKey {
            case slurmCustomSettings = "slurmCustomSettings"
        }
    }

    public struct ComputeNodeGroupSummary: AWSDecodableShape {
        /// The unique Amazon Resource Name (ARN) of the compute node group.
        public let arn: String
        /// The ID of the cluster of the compute node group.
        public let clusterId: String
        /// The date and time the resource was created.
        public let createdAt: Date
        /// The generated unique ID of the compute node group.
        public let id: String
        /// The date and time the resource was modified.
        public let modifiedAt: Date
        /// The name that identifies the compute node group.
        public let name: String
        /// The provisioning status of the compute node group.  The provisioning status doesn't indicate the overall health of the compute node group.
        public let status: ComputeNodeGroupStatus

        public init(arn: String, clusterId: String, createdAt: Date, id: String, modifiedAt: Date, name: String, status: ComputeNodeGroupStatus) {
            self.arn = arn
            self.clusterId = clusterId
            self.createdAt = createdAt
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clusterId = "clusterId"
            case createdAt = "createdAt"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateClusterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// A name to identify the cluster. Example: MyCluster
        public let clusterName: String
        /// The networking configuration used to set up the cluster's control plane.
        public let networking: NetworkingRequest
        /// The cluster management and job scheduling software associated with the cluster.
        public let scheduler: SchedulerRequest
        /// A value that determines the maximum number of compute nodes in the cluster and the maximum number of jobs (active and queued).    SMALL: 32 compute nodes and 256 jobs    MEDIUM: 512 compute nodes and 8192 jobs    LARGE: 2048 compute nodes and 16,384 jobs
        public let size: Size
        /// Additional options related to the Slurm scheduler.
        public let slurmConfiguration: ClusterSlurmConfigurationRequest?
        /// 1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateClusterRequest.idempotencyToken(), clusterName: String, networking: NetworkingRequest, scheduler: SchedulerRequest, size: Size, slurmConfiguration: ClusterSlurmConfigurationRequest? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.clusterName = clusterName
            self.networking = networking
            self.scheduler = scheduler
            self.size = size
            self.slurmConfiguration = slurmConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterName, name: "clusterName", parent: name, max: 40)
            try self.validate(self.clusterName, name: "clusterName", parent: name, min: 1)
            try self.validate(self.clusterName, name: "clusterName", parent: name, pattern: "^(?!pcs_)^(?![A-Za-z0-9]{10}$)[A-Za-z][A-Za-z0-9-]+$")
            try self.networking.validate(name: "\(name).networking")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case clusterName = "clusterName"
            case networking = "networking"
            case scheduler = "scheduler"
            case size = "size"
            case slurmConfiguration = "slurmConfiguration"
            case tags = "tags"
        }
    }

    public struct CreateClusterResponse: AWSDecodableShape {
        /// The cluster resource.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        private enum CodingKeys: String, CodingKey {
            case cluster = "cluster"
        }
    }

    public struct CreateComputeNodeGroupRequest: AWSEncodableShape {
        ///  The ID of the Amazon Machine Image (AMI) that Amazon Web Services PCS uses to launch compute nodes (Amazon EC2 instances). If you don't provide this value, Amazon Web Services PCS uses the AMI ID specified in the custom launch template.
        public let amiId: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// The name or ID of the cluster to create a compute node group in.
        public let clusterIdentifier: String
        /// A name to identify the cluster. Example: MyCluster
        public let computeNodeGroupName: String
        public let customLaunchTemplate: CustomLaunchTemplate
        /// The Amazon Resource Name (ARN) of the  IAM instance profile used to pass an IAM role when launching EC2 instances. The role contained in your instance profile must have pcs:RegisterComputeNodeGroupInstance permissions attached in order to provision instances correctly. The resource identifier of the ARN must start with  AWSPCS. For example, arn:aws:iam:123456789012:instance-profile/AWSPCSMyComputeNodeInstanceProfile.
        public let iamInstanceProfileArn: String
        /// A list of EC2 instance configurations that Amazon Web Services PCS can provision in the compute node group.
        public let instanceConfigs: [InstanceConfig]
        /// Specifies how EC2 instances are purchased on your behalf. Amazon Web Services PCS supports On-Demand and Spot instances. For more information, see Instance purchasing options in the Amazon Elastic Compute Cloud User Guide. If you don't provide this option, it defaults to On-Demand.
        public let purchaseOption: PurchaseOption?
        /// Specifies the boundaries of the compute node group auto scaling.
        public let scalingConfiguration: ScalingConfigurationRequest
        /// Additional options related to the Slurm scheduler.
        public let slurmConfiguration: ComputeNodeGroupSlurmConfigurationRequest?
        public let spotOptions: SpotOptions?
        /// The list of subnet IDs where the compute node group launches instances. Subnets must be in the same VPC as the cluster.
        public let subnetIds: [String]
        /// 1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.
        public let tags: [String: String]?

        public init(amiId: String? = nil, clientToken: String? = CreateComputeNodeGroupRequest.idempotencyToken(), clusterIdentifier: String, computeNodeGroupName: String, customLaunchTemplate: CustomLaunchTemplate, iamInstanceProfileArn: String, instanceConfigs: [InstanceConfig], purchaseOption: PurchaseOption? = nil, scalingConfiguration: ScalingConfigurationRequest, slurmConfiguration: ComputeNodeGroupSlurmConfigurationRequest? = nil, spotOptions: SpotOptions? = nil, subnetIds: [String], tags: [String: String]? = nil) {
            self.amiId = amiId
            self.clientToken = clientToken
            self.clusterIdentifier = clusterIdentifier
            self.computeNodeGroupName = computeNodeGroupName
            self.customLaunchTemplate = customLaunchTemplate
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.instanceConfigs = instanceConfigs
            self.purchaseOption = purchaseOption
            self.scalingConfiguration = scalingConfiguration
            self.slurmConfiguration = slurmConfiguration
            self.spotOptions = spotOptions
            self.subnetIds = subnetIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.amiId, name: "amiId", parent: name, pattern: "^ami-[a-z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.computeNodeGroupName, name: "computeNodeGroupName", parent: name, max: 25)
            try self.validate(self.computeNodeGroupName, name: "computeNodeGroupName", parent: name, min: 1)
            try self.validate(self.computeNodeGroupName, name: "computeNodeGroupName", parent: name, pattern: "^(?!pcs_)^(?![A-Za-z0-9]{10}$)[A-Za-z][A-Za-z0-9-]+$")
            try self.validate(self.iamInstanceProfileArn, name: "iamInstanceProfileArn", parent: name, pattern: "^arn:aws([a-zA-Z-]{0,10})?:iam::[0-9]{12}:instance-profile/.{1,128}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "amiId"
            case clientToken = "clientToken"
            case clusterIdentifier = "clusterIdentifier"
            case computeNodeGroupName = "computeNodeGroupName"
            case customLaunchTemplate = "customLaunchTemplate"
            case iamInstanceProfileArn = "iamInstanceProfileArn"
            case instanceConfigs = "instanceConfigs"
            case purchaseOption = "purchaseOption"
            case scalingConfiguration = "scalingConfiguration"
            case slurmConfiguration = "slurmConfiguration"
            case spotOptions = "spotOptions"
            case subnetIds = "subnetIds"
            case tags = "tags"
        }
    }

    public struct CreateComputeNodeGroupResponse: AWSDecodableShape {
        public let computeNodeGroup: ComputeNodeGroup?

        public init(computeNodeGroup: ComputeNodeGroup? = nil) {
            self.computeNodeGroup = computeNodeGroup
        }

        private enum CodingKeys: String, CodingKey {
            case computeNodeGroup = "computeNodeGroup"
        }
    }

    public struct CreateQueueRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// The name or ID of the cluster for which to create a queue.
        public let clusterIdentifier: String
        /// The list of compute node group configurations to associate with the queue. Queues assign jobs to associated compute node groups.
        public let computeNodeGroupConfigurations: [ComputeNodeGroupConfiguration]?
        /// A name to identify the queue.
        public let queueName: String
        /// 1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateQueueRequest.idempotencyToken(), clusterIdentifier: String, computeNodeGroupConfigurations: [ComputeNodeGroupConfiguration]? = nil, queueName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.clusterIdentifier = clusterIdentifier
            self.computeNodeGroupConfigurations = computeNodeGroupConfigurations
            self.queueName = queueName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.queueName, name: "queueName", parent: name, max: 25)
            try self.validate(self.queueName, name: "queueName", parent: name, min: 1)
            try self.validate(self.queueName, name: "queueName", parent: name, pattern: "^(?!pcs_)^(?![A-Za-z0-9]{10}$)[A-Za-z][A-Za-z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case clusterIdentifier = "clusterIdentifier"
            case computeNodeGroupConfigurations = "computeNodeGroupConfigurations"
            case queueName = "queueName"
            case tags = "tags"
        }
    }

    public struct CreateQueueResponse: AWSDecodableShape {
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public struct CustomLaunchTemplate: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the EC2 launch template to use to provision instances. Example: lt-xxxx
        public let id: String
        /// The version of the EC2 launch template to use to provision instances.
        public let version: String

        public init(id: String, version: String) {
            self.id = id
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case version = "version"
        }
    }

    public struct DeleteClusterRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// The name or ID of the cluster to delete.
        public let clusterIdentifier: String

        public init(clientToken: String? = DeleteClusterRequest.idempotencyToken(), clusterIdentifier: String) {
            self.clientToken = clientToken
            self.clusterIdentifier = clusterIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case clusterIdentifier = "clusterIdentifier"
        }
    }

    public struct DeleteClusterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteComputeNodeGroupRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// The name or ID of the cluster of the compute node group.
        public let clusterIdentifier: String
        /// The name or ID of the compute node group to delete.
        public let computeNodeGroupIdentifier: String

        public init(clientToken: String? = DeleteComputeNodeGroupRequest.idempotencyToken(), clusterIdentifier: String, computeNodeGroupIdentifier: String) {
            self.clientToken = clientToken
            self.clusterIdentifier = clusterIdentifier
            self.computeNodeGroupIdentifier = computeNodeGroupIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.computeNodeGroupIdentifier, name: "computeNodeGroupIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,25})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case clusterIdentifier = "clusterIdentifier"
            case computeNodeGroupIdentifier = "computeNodeGroupIdentifier"
        }
    }

    public struct DeleteComputeNodeGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQueueRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// The name or ID of the cluster of the queue.
        public let clusterIdentifier: String
        /// The name or ID of the queue to delete.
        public let queueIdentifier: String

        public init(clientToken: String? = DeleteQueueRequest.idempotencyToken(), clusterIdentifier: String, queueIdentifier: String) {
            self.clientToken = clientToken
            self.clusterIdentifier = clusterIdentifier
            self.queueIdentifier = queueIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.queueIdentifier, name: "queueIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,25})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case clusterIdentifier = "clusterIdentifier"
            case queueIdentifier = "queueIdentifier"
        }
    }

    public struct DeleteQueueResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Endpoint: AWSDecodableShape {
        /// The endpoint's connection port number. Example: 1234
        public let port: String
        /// The endpoint's private IP address. Example: 2.2.2.2
        public let privateIpAddress: String
        /// The endpoint's public IP address. Example: 1.1.1.1
        public let publicIpAddress: String?
        /// Indicates the type of endpoint running at the specific IP address.
        public let type: EndpointType

        public init(port: String, privateIpAddress: String, publicIpAddress: String? = nil, type: EndpointType) {
            self.port = port
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case port = "port"
            case privateIpAddress = "privateIpAddress"
            case publicIpAddress = "publicIpAddress"
            case type = "type"
        }
    }

    public struct ErrorInfo: AWSDecodableShape {
        /// The short-form error code.
        public let code: String?
        /// The detailed error information.
        public let message: String?

        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct GetClusterRequest: AWSEncodableShape {
        /// The name or ID of the cluster of the queue.
        public let clusterIdentifier: String

        public init(clusterIdentifier: String) {
            self.clusterIdentifier = clusterIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterIdentifier = "clusterIdentifier"
        }
    }

    public struct GetClusterResponse: AWSDecodableShape {
        /// The cluster resource.
        public let cluster: Cluster?

        public init(cluster: Cluster? = nil) {
            self.cluster = cluster
        }

        private enum CodingKeys: String, CodingKey {
            case cluster = "cluster"
        }
    }

    public struct GetComputeNodeGroupRequest: AWSEncodableShape {
        /// The name or ID of the cluster.
        public let clusterIdentifier: String
        /// The name or ID of the compute node group.
        public let computeNodeGroupIdentifier: String

        public init(clusterIdentifier: String, computeNodeGroupIdentifier: String) {
            self.clusterIdentifier = clusterIdentifier
            self.computeNodeGroupIdentifier = computeNodeGroupIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.computeNodeGroupIdentifier, name: "computeNodeGroupIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,25})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterIdentifier = "clusterIdentifier"
            case computeNodeGroupIdentifier = "computeNodeGroupIdentifier"
        }
    }

    public struct GetComputeNodeGroupResponse: AWSDecodableShape {
        public let computeNodeGroup: ComputeNodeGroup?

        public init(computeNodeGroup: ComputeNodeGroup? = nil) {
            self.computeNodeGroup = computeNodeGroup
        }

        private enum CodingKeys: String, CodingKey {
            case computeNodeGroup = "computeNodeGroup"
        }
    }

    public struct GetQueueRequest: AWSEncodableShape {
        /// The name or ID of the cluster of the queue.
        public let clusterIdentifier: String
        /// The name or ID of the queue.
        public let queueIdentifier: String

        public init(clusterIdentifier: String, queueIdentifier: String) {
            self.clusterIdentifier = clusterIdentifier
            self.queueIdentifier = queueIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.queueIdentifier, name: "queueIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,25})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clusterIdentifier = "clusterIdentifier"
            case queueIdentifier = "queueIdentifier"
        }
    }

    public struct GetQueueResponse: AWSDecodableShape {
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }

    public struct InstanceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The EC2 instance type that Amazon Web Services PCS can provision in the compute node group. Example: t2.xlarge
        public let instanceType: String?

        public init(instanceType: String? = nil) {
            self.instanceType = instanceType
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "instanceType"
        }
    }

    public struct ListClustersRequest: AWSEncodableShape {
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default  is 10 results, and the maximum allowed page size is 100 results. A value of 0 uses  the default.
        public let maxResults: Int?
        /// The value of nextToken is a unique pagination token for each page of results returned. If nextToken is returned, there are more results available. Make the call again using the returned token to retrieve the next page.  Keep all other arguments unchanged. Each pagination token expires after 24 hours.  Using an expired pagination token returns an HTTP 400 InvalidToken  error.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListClustersResponse: AWSDecodableShape {
        /// The list of clusters.
        public let clusters: [ClusterSummary]
        /// The value of nextToken is a unique pagination token for each page of results returned. If nextToken is returned, there are more results available. Make the call again using the returned token to retrieve the next page.  Keep all other arguments unchanged. Each pagination token expires after 24 hours.  Using an expired pagination token returns an HTTP 400 InvalidToken  error.
        public let nextToken: String?

        public init(clusters: [ClusterSummary], nextToken: String? = nil) {
            self.clusters = clusters
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case clusters = "clusters"
            case nextToken = "nextToken"
        }
    }

    public struct ListComputeNodeGroupsRequest: AWSEncodableShape {
        /// The name or ID of the cluster to list compute node groups for.
        public let clusterIdentifier: String
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default  is 10 results, and the maximum allowed page size is 100 results. A value of 0 uses  the default.
        public let maxResults: Int?
        /// The value of nextToken is a unique pagination token for each page of results returned. If nextToken is returned, there are more results available. Make the call again using the returned token to retrieve the next page.  Keep all other arguments unchanged. Each pagination token expires after 24 hours.  Using an expired pagination token returns an HTTP 400 InvalidToken  error.
        public let nextToken: String?

        public init(clusterIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterIdentifier = clusterIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clusterIdentifier = "clusterIdentifier"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListComputeNodeGroupsResponse: AWSDecodableShape {
        /// The list of compute node groups for the cluster.
        public let computeNodeGroups: [ComputeNodeGroupSummary]
        /// The value of nextToken is a unique pagination token for each page of results returned. If nextToken is returned, there are more results available. Make the call again using the returned token to retrieve the next page.  Keep all other arguments unchanged. Each pagination token expires after 24 hours.  Using an expired pagination token returns an HTTP 400 InvalidToken  error.
        public let nextToken: String?

        public init(computeNodeGroups: [ComputeNodeGroupSummary], nextToken: String? = nil) {
            self.computeNodeGroups = computeNodeGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case computeNodeGroups = "computeNodeGroups"
            case nextToken = "nextToken"
        }
    }

    public struct ListQueuesRequest: AWSEncodableShape {
        /// The name or ID of the cluster to list queues for.
        public let clusterIdentifier: String
        /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. The default  is 10 results, and the maximum allowed page size is 100 results. A value of 0 uses  the default.
        public let maxResults: Int?
        /// The value of nextToken is a unique pagination token for each page of results returned. If nextToken is returned, there are more results available. Make the call again using the returned token to retrieve the next page.  Keep all other arguments unchanged. Each pagination token expires after 24 hours.  Using an expired pagination token returns an HTTP 400 InvalidToken  error.
        public let nextToken: String?

        public init(clusterIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.clusterIdentifier = clusterIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clusterIdentifier = "clusterIdentifier"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListQueuesResponse: AWSDecodableShape {
        /// The value of nextToken is a unique pagination token for each page of results returned. If nextToken is returned, there are more results available. Make the call again using the returned token to retrieve the next page.  Keep all other arguments unchanged. Each pagination token expires after 24 hours.  Using an expired pagination token returns an HTTP 400 InvalidToken  error.
        public let nextToken: String?
        /// The list of queues associated with the cluster.
        public let queues: [QueueSummary]

        public init(nextToken: String? = nil, queues: [QueueSummary]) {
            self.nextToken = nextToken
            self.queues = queues
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case queues = "queues"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource for which to list tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws*:pcs:.*:[0-9]{12}:.*/[a-z0-9_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// 1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Networking: AWSDecodableShape {
        /// The list of security group IDs associated  with the Elastic Network Interface (ENI) created in subnets. The following rules are required:   Inbound rule 1   Protocol: All   Ports: All   Source: Self     Outbound rule 1   Protocol: All   Ports: All   Destination: 0.0.0.0/0 (IPv4)     Outbound rule 2   Protocol: All   Ports: All   Destination: Self
        public let securityGroupIds: [String]?
        /// The ID of the subnet where Amazon Web Services PCS creates an Elastic Network Interface (ENI) to enable communication between managed controllers and Amazon Web Services PCS resources. The subnet must have an available IP address, cannot reside in AWS Outposts, AWS Wavelength, or an AWS Local Zone. Example: subnet-abcd1234
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct NetworkingRequest: AWSEncodableShape {
        /// A list of security group IDs associated with the Elastic Network Interface (ENI) created in subnets.
        public let securityGroupIds: [String]?
        /// The list of subnet IDs where Amazon Web Services PCS creates an  Elastic Network Interface (ENI) to enable communication between managed controllers  and Amazon Web Services PCS resources. Subnet IDs have the form subnet-0123456789abcdef0. Subnets can't be in Outposts, Wavelength or an Amazon Web Services Local Zone.  Amazon Web Services PCS currently supports only 1 subnet in this list.
        public let subnetIds: [String]?

        public init(securityGroupIds: [String]? = nil, subnetIds: [String]? = nil) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-\\w{8,17}$")
            }
            try self.subnetIds?.forEach {
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-\\w{8,17}$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct Queue: AWSDecodableShape {
        /// The unique Amazon Resource Name (ARN) of the queue.
        public let arn: String
        /// The ID of the cluster of the queue.
        public let clusterId: String
        /// The list of compute node group configurations associated with the queue. Queues  assign jobs to associated compute node groups.
        public let computeNodeGroupConfigurations: [ComputeNodeGroupConfiguration]
        /// The date and time the resource was created.
        public let createdAt: Date
        /// The list of errors that occurred during queue provisioning.
        public let errorInfo: [ErrorInfo]?
        /// The generated unique ID of the queue.
        public let id: String
        /// The date and time the resource was modified.
        public let modifiedAt: Date
        /// The name that identifies the queue.
        public let name: String
        /// The provisioning status of the queue.  The provisioning status doesn't indicate the overall health of the queue.
        public let status: QueueStatus

        public init(arn: String, clusterId: String, computeNodeGroupConfigurations: [ComputeNodeGroupConfiguration], createdAt: Date, errorInfo: [ErrorInfo]? = nil, id: String, modifiedAt: Date, name: String, status: QueueStatus) {
            self.arn = arn
            self.clusterId = clusterId
            self.computeNodeGroupConfigurations = computeNodeGroupConfigurations
            self.createdAt = createdAt
            self.errorInfo = errorInfo
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clusterId = "clusterId"
            case computeNodeGroupConfigurations = "computeNodeGroupConfigurations"
            case createdAt = "createdAt"
            case errorInfo = "errorInfo"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct QueueSummary: AWSDecodableShape {
        /// The unique Amazon Resource Name (ARN) of the queue.
        public let arn: String
        /// The ID of the cluster of the queue.
        public let clusterId: String
        /// The date and time the resource was created.
        public let createdAt: Date
        /// The generated unique ID of the queue.
        public let id: String
        /// The date and time the resource was modified.
        public let modifiedAt: Date
        /// The name that identifies the queue.
        public let name: String
        /// The provisioning status of the queue.  The provisioning status doesn't indicate the overall health of the queue.
        public let status: QueueStatus

        public init(arn: String, clusterId: String, createdAt: Date, id: String, modifiedAt: Date, name: String, status: QueueStatus) {
            self.arn = arn
            self.clusterId = clusterId
            self.createdAt = createdAt
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case clusterId = "clusterId"
            case createdAt = "createdAt"
            case id = "id"
            case modifiedAt = "modifiedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct RegisterComputeNodeGroupInstanceRequest: AWSEncodableShape {
        /// The client-generated token to allow for retries.
        public let bootstrapId: String
        /// The name or ID of the cluster to register the compute node group instance in.
        public let clusterIdentifier: String

        public init(bootstrapId: String, clusterIdentifier: String) {
            self.bootstrapId = bootstrapId
            self.clusterIdentifier = clusterIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.bootstrapId, name: "bootstrapId", parent: name, max: 1000)
            try self.validate(self.bootstrapId, name: "bootstrapId", parent: name, min: 1)
            try self.validate(self.bootstrapId, name: "bootstrapId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
        }

        private enum CodingKeys: String, CodingKey {
            case bootstrapId = "bootstrapId"
            case clusterIdentifier = "clusterIdentifier"
        }
    }

    public struct RegisterComputeNodeGroupInstanceResponse: AWSDecodableShape {
        /// The list of endpoints available for interaction with the scheduler.
        public let endpoints: [Endpoint]
        /// The scheduler node ID for this instance.
        public let nodeID: String
        /// For the Slurm scheduler, this is the shared Munge key the scheduler uses to authenticate compute node group instances.
        public let sharedSecret: String

        public init(endpoints: [Endpoint], nodeID: String, sharedSecret: String) {
            self.endpoints = endpoints
            self.nodeID = nodeID
            self.sharedSecret = sharedSecret
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "endpoints"
            case nodeID = "nodeID"
            case sharedSecret = "sharedSecret"
        }
    }

    public struct ScalingConfiguration: AWSDecodableShape {
        /// The upper bound of the number of instances allowed in the compute fleet.
        public let maxInstanceCount: Int
        /// The lower bound of the number of instances allowed in the compute fleet.
        public let minInstanceCount: Int

        public init(maxInstanceCount: Int, minInstanceCount: Int) {
            self.maxInstanceCount = maxInstanceCount
            self.minInstanceCount = minInstanceCount
        }

        private enum CodingKeys: String, CodingKey {
            case maxInstanceCount = "maxInstanceCount"
            case minInstanceCount = "minInstanceCount"
        }
    }

    public struct ScalingConfigurationRequest: AWSEncodableShape {
        /// The upper bound of the number of instances allowed in the compute fleet.
        public let maxInstanceCount: Int
        /// The lower bound of the number of instances allowed in the compute fleet.
        public let minInstanceCount: Int

        public init(maxInstanceCount: Int = 0, minInstanceCount: Int = 0) {
            self.maxInstanceCount = maxInstanceCount
            self.minInstanceCount = minInstanceCount
        }

        private enum CodingKeys: String, CodingKey {
            case maxInstanceCount = "maxInstanceCount"
            case minInstanceCount = "minInstanceCount"
        }
    }

    public struct Scheduler: AWSDecodableShape {
        /// The software Amazon Web Services PCS uses to manage cluster scaling and job scheduling.
        public let type: SchedulerType
        /// The version of the specified scheduling software that Amazon Web Services PCS uses to manage cluster scaling and job scheduling.
        public let version: String

        public init(type: SchedulerType, version: String) {
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case version = "version"
        }
    }

    public struct SchedulerRequest: AWSEncodableShape {
        /// The software Amazon Web Services PCS uses to manage cluster scaling and job scheduling.
        public let type: SchedulerType
        /// The version of the specified scheduling software that Amazon Web Services PCS uses to manage cluster scaling and job scheduling.
        public let version: String

        public init(type: SchedulerType, version: String) {
            self.type = type
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case version = "version"
        }
    }

    public struct SlurmAuthKey: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the the shared Slurm key.
        public let secretArn: String
        /// The version of the shared Slurm key.
        public let secretVersion: String

        public init(secretArn: String, secretVersion: String) {
            self.secretArn = secretArn
            self.secretVersion = secretVersion
        }

        private enum CodingKeys: String, CodingKey {
            case secretArn = "secretArn"
            case secretVersion = "secretVersion"
        }
    }

    public struct SlurmCustomSetting: AWSEncodableShape & AWSDecodableShape {
        /// Amazon Web Services PCS supports configuration of the following Slurm parameters:  Prolog ,  Epilog , and  SelectTypeParameters .
        public let parameterName: String
        /// The values for the configured Slurm settings.
        public let parameterValue: String

        public init(parameterName: String, parameterValue: String) {
            self.parameterName = parameterName
            self.parameterValue = parameterValue
        }

        private enum CodingKeys: String, CodingKey {
            case parameterName = "parameterName"
            case parameterValue = "parameterValue"
        }
    }

    public struct SpotOptions: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon EC2 allocation strategy Amazon Web Services PCS uses to provision EC2 instances.  Amazon Web Services PCS supports lowest price,  capacity optimized, and  price capacity optimized.  For more information, see Use  allocation strategies to determine how EC2 Fleet or Spot Fleet fulfills Spot and On-Demand capacity in the Amazon Elastic Compute Cloud User Guide. If you don't provide this option, it defaults to price capacity optimized.
        public let allocationStrategy: SpotAllocationStrategy?

        public init(allocationStrategy: SpotAllocationStrategy? = nil) {
            self.allocationStrategy = allocationStrategy
        }

        private enum CodingKeys: String, CodingKey {
            case allocationStrategy = "allocationStrategy"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// 1 or more tags added to the resource. Each tag consists of a tag key and tag value. The tag value is optional and can be an empty string.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws*:pcs:.*:[0-9]{12}:.*/[a-z0-9_\\-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// 1 or more tag keys to remove from the resource. Specify only tag keys and not tag values.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tagKeys, forKey: .tagKeys)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws*:pcs:.*:[0-9]{12}:.*/[a-z0-9_\\-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKeys = "tagKeys"
        }
    }

    public struct UpdateComputeNodeGroupRequest: AWSEncodableShape {
        /// The ID of the Amazon Machine Image (AMI) that Amazon Web Services PCS uses to launch instances. If not provided, Amazon Web Services PCS uses the AMI ID specified in the custom launch template.
        public let amiId: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// The name or ID of the cluster of the compute node group.
        public let clusterIdentifier: String
        /// The name or ID of the compute node group.
        public let computeNodeGroupIdentifier: String
        public let customLaunchTemplate: CustomLaunchTemplate?
        /// The Amazon Resource Name (ARN) of the  IAM instance profile used to pass an IAM role when launching EC2 instances. The role contained in your instance profile must have pcs:RegisterComputeNodeGroupInstance permissions attached to provision instances correctly.
        public let iamInstanceProfileArn: String?
        /// Specifies how EC2 instances are purchased on your behalf. Amazon Web Services PCS supports On-Demand and Spot instances. For more information, see Instance purchasing options in the Amazon Elastic Compute Cloud User Guide. If you don't provide this option, it defaults to On-Demand.
        public let purchaseOption: PurchaseOption?
        /// Specifies the boundaries of the compute node group auto scaling.
        public let scalingConfiguration: ScalingConfigurationRequest?
        /// Additional options related to the Slurm scheduler.
        public let slurmConfiguration: UpdateComputeNodeGroupSlurmConfigurationRequest?
        public let spotOptions: SpotOptions?
        /// The list of subnet IDs where the compute node group provisions instances. The subnets must be in the same VPC as the cluster.
        public let subnetIds: [String]?

        public init(amiId: String? = nil, clientToken: String? = UpdateComputeNodeGroupRequest.idempotencyToken(), clusterIdentifier: String, computeNodeGroupIdentifier: String, customLaunchTemplate: CustomLaunchTemplate? = nil, iamInstanceProfileArn: String? = nil, purchaseOption: PurchaseOption? = nil, scalingConfiguration: ScalingConfigurationRequest? = nil, slurmConfiguration: UpdateComputeNodeGroupSlurmConfigurationRequest? = nil, spotOptions: SpotOptions? = nil, subnetIds: [String]? = nil) {
            self.amiId = amiId
            self.clientToken = clientToken
            self.clusterIdentifier = clusterIdentifier
            self.computeNodeGroupIdentifier = computeNodeGroupIdentifier
            self.customLaunchTemplate = customLaunchTemplate
            self.iamInstanceProfileArn = iamInstanceProfileArn
            self.purchaseOption = purchaseOption
            self.scalingConfiguration = scalingConfiguration
            self.slurmConfiguration = slurmConfiguration
            self.spotOptions = spotOptions
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.validate(self.amiId, name: "amiId", parent: name, pattern: "^ami-[a-z0-9]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.computeNodeGroupIdentifier, name: "computeNodeGroupIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,25})$")
            try self.validate(self.iamInstanceProfileArn, name: "iamInstanceProfileArn", parent: name, pattern: "^arn:aws([a-zA-Z-]{0,10})?:iam::[0-9]{12}:instance-profile/.{1,128}$")
        }

        private enum CodingKeys: String, CodingKey {
            case amiId = "amiId"
            case clientToken = "clientToken"
            case clusterIdentifier = "clusterIdentifier"
            case computeNodeGroupIdentifier = "computeNodeGroupIdentifier"
            case customLaunchTemplate = "customLaunchTemplate"
            case iamInstanceProfileArn = "iamInstanceProfileArn"
            case purchaseOption = "purchaseOption"
            case scalingConfiguration = "scalingConfiguration"
            case slurmConfiguration = "slurmConfiguration"
            case spotOptions = "spotOptions"
            case subnetIds = "subnetIds"
        }
    }

    public struct UpdateComputeNodeGroupResponse: AWSDecodableShape {
        public let computeNodeGroup: ComputeNodeGroup?

        public init(computeNodeGroup: ComputeNodeGroup? = nil) {
            self.computeNodeGroup = computeNodeGroup
        }

        private enum CodingKeys: String, CodingKey {
            case computeNodeGroup = "computeNodeGroup"
        }
    }

    public struct UpdateComputeNodeGroupSlurmConfigurationRequest: AWSEncodableShape {
        /// Additional Slurm-specific configuration that directly maps to Slurm settings.
        public let slurmCustomSettings: [SlurmCustomSetting]?

        public init(slurmCustomSettings: [SlurmCustomSetting]? = nil) {
            self.slurmCustomSettings = slurmCustomSettings
        }

        private enum CodingKeys: String, CodingKey {
            case slurmCustomSettings = "slurmCustomSettings"
        }
    }

    public struct UpdateQueueRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original  request completes successfully, the subsequent retries with the same  client token return the result from the original successful request and  they have no additional effect. If you don't specify a client token, the  CLI and SDK automatically generate 1 for you.
        public let clientToken: String?
        /// The name or ID of the cluster of the queue.
        public let clusterIdentifier: String
        /// The list of compute node group configurations to associate with the queue. Queues assign jobs to associated compute node groups.
        public let computeNodeGroupConfigurations: [ComputeNodeGroupConfiguration]?
        /// The name or ID of the queue.
        public let queueIdentifier: String

        public init(clientToken: String? = UpdateQueueRequest.idempotencyToken(), clusterIdentifier: String, computeNodeGroupConfigurations: [ComputeNodeGroupConfiguration]? = nil, queueIdentifier: String) {
            self.clientToken = clientToken
            self.clusterIdentifier = clusterIdentifier
            self.computeNodeGroupConfigurations = computeNodeGroupConfigurations
            self.queueIdentifier = queueIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 8)
            try self.validate(self.clusterIdentifier, name: "clusterIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,40})$")
            try self.validate(self.queueIdentifier, name: "queueIdentifier", parent: name, pattern: "^(pcs_[a-zA-Z0-9]+|[A-Za-z][A-Za-z0-9-]{1,25})$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case clusterIdentifier = "clusterIdentifier"
            case computeNodeGroupConfigurations = "computeNodeGroupConfigurations"
            case queueIdentifier = "queueIdentifier"
        }
    }

    public struct UpdateQueueResponse: AWSDecodableShape {
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "queue"
        }
    }
}

// MARK: - Errors

/// Error enum for PCS
public struct PCSErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PCS
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have permission to perform the action.  Examples    The launch template instance profile doesn't pass iam:PassRole verification.   There is a mismatch between the account ID and cluster ID.   The cluster ID doesn't exist.   The EC2 instance isn't present.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Your request has conflicting operations. This can occur if you're trying to perform more than 1 operation on the same resource at the same time.  Examples    A cluster with the same name already exists.   A cluster isn't in ACTIVE status.   A cluster to delete is in an unstable state. For example, because it still has ACTIVE node groups or queues.   A queue already exists in a cluster.
    public static var conflictException: Self { .init(.conflictException) }
    /// Amazon Web Services PCS can't process your request right now. Try again later.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The requested resource can't be found. The cluster, node group, or queue you're attempting to get, update, list, or delete doesn't exist.  Examples
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account. To learn how to increase your service quota, see Requesting a quota increase in the Service Quotas User Guide   Examples    The max number of clusters or queues has been reached for the account.   The max number of compute node groups has been reached for the associated cluster.   The total of maxInstances across all compute node groups has been reached for associated cluster.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Your request exceeded a request rate quota. Check the resource's request rate quota and try again.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request isn't valid.  Examples    Your request contains malformed JSON or unsupported characters.   The scheduler version isn't supported.   There are networking related errors, such as network validation failure.   AMI type is CUSTOM and the launch template doesn't define the AMI ID, or the AMI type is AL2 and the launch template defines the AMI.
    public static var validationException: Self { .init(.validationException) }
}

extension PCSErrorType: Equatable {
    public static func == (lhs: PCSErrorType, rhs: PCSErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PCSErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
