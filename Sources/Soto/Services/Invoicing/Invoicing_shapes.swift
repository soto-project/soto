//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Invoicing {
    // MARK: Enums

    public enum InvoiceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creditMemo = "CREDIT_MEMO"
        case invoice = "INVOICE"
        public var description: String { return self.rawValue }
    }

    public enum ListInvoiceSummariesResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountId = "ACCOUNT_ID"
        case invoiceId = "INVOICE_ID"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountMembershipError = "accountMembershipError"
        case cannotParse = "cannotParse"
        case duplicateInvoiceUnit = "duplicateInvoiceUnit"
        case expiredNextToken = "expiredNextToken"
        case fieldValidationFailed = "fieldValidationFailed"
        case invalidInput = "invalidInput"
        case invalidNextToken = "invalidNextToken"
        case maxAccountsExceeded = "maxAccountsExceeded"
        case maxInvoiceUnitsExceeded = "maxInvoiceUnitsExceeded"
        case mutualExclusionError = "mutualExclusionError"
        case nonMembersPresent = "nonMemberPresent"
        case other = "other"
        case taxSettingsError = "taxSettingsError"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let message: String?
        /// You don't have sufficient access to perform this action.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct AmountBreakdown: AWSDecodableShape {
        ///  The discounted amount.
        public let discounts: DiscountsBreakdown?
        ///  The fee amount.
        public let fees: FeesBreakdown?
        ///  The total of a set of the breakdown.
        public let subTotalAmount: String?
        ///  The tax amount.
        public let taxes: TaxesBreakdown?

        @inlinable
        public init(discounts: DiscountsBreakdown? = nil, fees: FeesBreakdown? = nil, subTotalAmount: String? = nil, taxes: TaxesBreakdown? = nil) {
            self.discounts = discounts
            self.fees = fees
            self.subTotalAmount = subTotalAmount
            self.taxes = taxes
        }

        private enum CodingKeys: String, CodingKey {
            case discounts = "Discounts"
            case fees = "Fees"
            case subTotalAmount = "SubTotalAmount"
            case taxes = "Taxes"
        }
    }

    public struct BatchGetInvoiceProfileRequest: AWSEncodableShape {
        /// Retrieves the corresponding invoice profile data for these account IDs.
        public let accountIds: [String]

        @inlinable
        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 1000)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct BatchGetInvoiceProfileResponse: AWSDecodableShape {
        ///  A list of invoice profiles corresponding to the requested accounts.
        public let profiles: [InvoiceProfile]?

        @inlinable
        public init(profiles: [InvoiceProfile]? = nil) {
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case profiles = "Profiles"
        }
    }

    public struct BillingPeriod: AWSEncodableShape & AWSDecodableShape {
        ///  The billing period month.
        public let month: Int
        ///  The billing period year.
        public let year: Int

        @inlinable
        public init(month: Int, year: Int) {
            self.month = month
            self.year = year
        }

        public func validate(name: String) throws {
            try self.validate(self.month, name: "month", parent: name, max: 12)
            try self.validate(self.month, name: "month", parent: name, min: 1)
            try self.validate(self.year, name: "year", parent: name, max: 2050)
            try self.validate(self.year, name: "year", parent: name, min: 2005)
        }

        private enum CodingKeys: String, CodingKey {
            case month = "Month"
            case year = "Year"
        }
    }

    public struct CreateInvoiceUnitRequest: AWSEncodableShape {
        ///  The invoice unit's description. This can be changed at a later time.
        public let description: String?
        ///  The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
        public let invoiceReceiver: String
        ///  The unique name of the invoice unit that is shown on the generated invoice. This can't be changed once it is set. To change this name, you must delete the invoice unit recreate.
        public let name: String
        ///  The tag structure that contains a tag key and value.
        public let resourceTags: [ResourceTag]?
        /// The InvoiceUnitRule object used to create invoice units.
        public let rule: InvoiceUnitRule
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceReceiver: String, name: String, resourceTags: [ResourceTag]? = nil, rule: InvoiceUnitRule, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.name = name
            self.resourceTags = resourceTags
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.invoiceReceiver, name: "invoiceReceiver", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceReceiver = "InvoiceReceiver"
            case name = "Name"
            case resourceTags = "ResourceTags"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct CreateInvoiceUnitResponse: AWSDecodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?

        @inlinable
        public init(invoiceUnitArn: String? = nil) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct CurrencyExchangeDetails: AWSDecodableShape {
        /// The currency exchange rate.
        public let rate: String?
        /// The exchange source currency.
        public let sourceCurrencyCode: String?
        /// The exchange target currency.
        public let targetCurrencyCode: String?

        @inlinable
        public init(rate: String? = nil, sourceCurrencyCode: String? = nil, targetCurrencyCode: String? = nil) {
            self.rate = rate
            self.sourceCurrencyCode = sourceCurrencyCode
            self.targetCurrencyCode = targetCurrencyCode
        }

        private enum CodingKeys: String, CodingKey {
            case rate = "Rate"
            case sourceCurrencyCode = "SourceCurrencyCode"
            case targetCurrencyCode = "TargetCurrencyCode"
        }
    }

    public struct DateInterval: AWSEncodableShape {
        ///  The end of the time period that you want invoice-related documents for. The end date is exclusive. For example, if end is 2019-01-10, Amazon Web Services retrieves invoice-related documents from the start date up to, but not including, 2018-01-10.
        public let endDate: Date
        ///  The beginning of the time period that you want invoice-related documents for. The start date is inclusive. For example, if start is 2019-01-01, AWS retrieves invoices starting at 2019-01-01 up to the end date.
        public let startDate: Date

        @inlinable
        public init(endDate: Date, startDate: Date) {
            self.endDate = endDate
            self.startDate = startDate
        }

        private enum CodingKeys: String, CodingKey {
            case endDate = "EndDate"
            case startDate = "StartDate"
        }
    }

    public struct DeleteInvoiceUnitRequest: AWSEncodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String

        @inlinable
        public init(invoiceUnitArn: String) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        public func validate(name: String) throws {
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, max: 256)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, min: 1)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct DeleteInvoiceUnitResponse: AWSDecodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?

        @inlinable
        public init(invoiceUnitArn: String? = nil) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct DiscountsBreakdown: AWSDecodableShape {
        /// The list of discounts information.
        public let breakdown: [DiscountsBreakdownAmount]?
        ///  The discount's total amount.
        public let totalAmount: String?

        @inlinable
        public init(breakdown: [DiscountsBreakdownAmount]? = nil, totalAmount: String? = nil) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }

        private enum CodingKeys: String, CodingKey {
            case breakdown = "Breakdown"
            case totalAmount = "TotalAmount"
        }
    }

    public struct DiscountsBreakdownAmount: AWSDecodableShape {
        /// The discounted amount.
        public let amount: String?
        ///  The list of discounts information.
        public let description: String?
        ///  The details for the discount rate..
        public let rate: String?

        @inlinable
        public init(amount: String? = nil, description: String? = nil, rate: String? = nil) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "Amount"
            case description = "Description"
            case rate = "Rate"
        }
    }

    public struct Entity: AWSDecodableShape {
        /// The name of the entity that issues the Amazon Web Services invoice.
        public let invoicingEntity: String?

        @inlinable
        public init(invoicingEntity: String? = nil) {
            self.invoicingEntity = invoicingEntity
        }

        private enum CodingKeys: String, CodingKey {
            case invoicingEntity = "InvoicingEntity"
        }
    }

    public struct FeesBreakdown: AWSDecodableShape {
        /// The list of fees information.
        public let breakdown: [FeesBreakdownAmount]?
        ///  The total amount of fees.
        public let totalAmount: String?

        @inlinable
        public init(breakdown: [FeesBreakdownAmount]? = nil, totalAmount: String? = nil) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }

        private enum CodingKeys: String, CodingKey {
            case breakdown = "Breakdown"
            case totalAmount = "TotalAmount"
        }
    }

    public struct FeesBreakdownAmount: AWSDecodableShape {
        ///  The fee amount.
        public let amount: String?
        ///  The list of fees information.
        public let description: String?
        ///  Details about the rate amount.
        public let rate: String?

        @inlinable
        public init(amount: String? = nil, description: String? = nil, rate: String? = nil) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "Amount"
            case description = "Description"
            case rate = "Rate"
        }
    }

    public struct Filters: AWSEncodableShape {
        ///  You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. The specified account IDs are matched with either the receiver or the linked accounts in the rules.
        public let accounts: [String]?
        ///  You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. This filter only matches the specified accounts on the invoice receivers of the invoice units.
        public let invoiceReceivers: [String]?
        ///  An optional input to the list API. You can specify a list of invoice unit names inside filters to return invoice units that match only the specified invoice unit names. If multiple names are provided, the result is an OR condition (match any) of the specified invoice unit names.
        public let names: [String]?

        @inlinable
        public init(accounts: [String]? = nil, invoiceReceivers: [String]? = nil, names: [String]? = nil) {
            self.accounts = accounts
            self.invoiceReceivers = invoiceReceivers
            self.names = names
        }

        public func validate(name: String) throws {
            try self.accounts?.forEach {
                try validate($0, name: "accounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accounts, name: "accounts", parent: name, max: 1000)
            try self.validate(self.accounts, name: "accounts", parent: name, min: 1)
            try self.invoiceReceivers?.forEach {
                try validate($0, name: "invoiceReceivers[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.invoiceReceivers, name: "invoiceReceivers", parent: name, max: 1000)
            try self.validate(self.invoiceReceivers, name: "invoiceReceivers", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, max: 50)
                try validate($0, name: "names[]", parent: name, min: 1)
                try validate($0, name: "names[]", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "Accounts"
            case invoiceReceivers = "InvoiceReceivers"
            case names = "Names"
        }
    }

    public struct GetInvoiceUnitRequest: AWSEncodableShape {
        ///  The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
        public let asOf: Date?
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String

        @inlinable
        public init(asOf: Date? = nil, invoiceUnitArn: String) {
            self.asOf = asOf
            self.invoiceUnitArn = invoiceUnitArn
        }

        public func validate(name: String) throws {
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, max: 256)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, min: 1)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case asOf = "AsOf"
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct GetInvoiceUnitResponse: AWSDecodableShape {
        ///  The assigned description for an invoice unit.
        public let description: String?
        ///  The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
        public let invoiceReceiver: String?
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?
        ///  The most recent date the invoice unit response was updated.
        public let lastModified: Date?
        ///  The unique name of the invoice unit that is shown on the generated invoice.
        public let name: String?
        public let rule: InvoiceUnitRule?
        ///  Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceReceiver: String? = nil, invoiceUnitArn: String? = nil, lastModified: Date? = nil, name: String? = nil, rule: InvoiceUnitRule? = nil, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.invoiceUnitArn = invoiceUnitArn
            self.lastModified = lastModified
            self.name = name
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceReceiver = "InvoiceReceiver"
            case invoiceUnitArn = "InvoiceUnitArn"
            case lastModified = "LastModified"
            case name = "Name"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String?
        /// The processing request failed because of an unknown error, exception, or failure.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String? = nil, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvoiceCurrencyAmount: AWSDecodableShape {
        ///  Details about the invoice currency amount.
        public let amountBreakdown: AmountBreakdown?
        /// The currency dominion of the invoice document.
        public let currencyCode: String?
        ///  The details of currency exchange.
        public let currencyExchangeDetails: CurrencyExchangeDetails?
        ///  The invoice currency amount.
        public let totalAmount: String?
        ///  Details about the invoice total amount before tax.
        public let totalAmountBeforeTax: String?

        @inlinable
        public init(amountBreakdown: AmountBreakdown? = nil, currencyCode: String? = nil, currencyExchangeDetails: CurrencyExchangeDetails? = nil, totalAmount: String? = nil, totalAmountBeforeTax: String? = nil) {
            self.amountBreakdown = amountBreakdown
            self.currencyCode = currencyCode
            self.currencyExchangeDetails = currencyExchangeDetails
            self.totalAmount = totalAmount
            self.totalAmountBeforeTax = totalAmountBeforeTax
        }

        private enum CodingKeys: String, CodingKey {
            case amountBreakdown = "AmountBreakdown"
            case currencyCode = "CurrencyCode"
            case currencyExchangeDetails = "CurrencyExchangeDetails"
            case totalAmount = "TotalAmount"
            case totalAmountBeforeTax = "TotalAmountBeforeTax"
        }
    }

    public struct InvoiceProfile: AWSDecodableShape {
        ///  The account ID the invoice profile is generated for.
        public let accountId: String?
        ///  This specifies the issuing entity of the invoice.
        public let issuer: String?
        /// The address of the receiver that will be printed on the invoice.
        public let receiverAddress: ReceiverAddress?
        /// The email address for the invoice profile receiver.
        public let receiverEmail: String?
        ///  The name of the person receiving the invoice profile.
        public let receiverName: String?
        ///  Your Tax Registration Number (TRN) information.
        public let taxRegistrationNumber: String?

        @inlinable
        public init(accountId: String? = nil, issuer: String? = nil, receiverAddress: ReceiverAddress? = nil, receiverEmail: String? = nil, receiverName: String? = nil, taxRegistrationNumber: String? = nil) {
            self.accountId = accountId
            self.issuer = issuer
            self.receiverAddress = receiverAddress
            self.receiverEmail = receiverEmail
            self.receiverName = receiverName
            self.taxRegistrationNumber = taxRegistrationNumber
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case issuer = "Issuer"
            case receiverAddress = "ReceiverAddress"
            case receiverEmail = "ReceiverEmail"
            case receiverName = "ReceiverName"
            case taxRegistrationNumber = "TaxRegistrationNumber"
        }
    }

    public struct InvoiceSummariesFilter: AWSEncodableShape {
        /// The billing period associated with the invoice documents.
        public let billingPeriod: BillingPeriod?
        /// The name of the entity that issues the Amazon Web Services invoice.
        public let invoicingEntity: String?
        /// The date range for invoice summary retrieval.
        public let timeInterval: DateInterval?

        @inlinable
        public init(billingPeriod: BillingPeriod? = nil, invoicingEntity: String? = nil, timeInterval: DateInterval? = nil) {
            self.billingPeriod = billingPeriod
            self.invoicingEntity = invoicingEntity
            self.timeInterval = timeInterval
        }

        public func validate(name: String) throws {
            try self.billingPeriod?.validate(name: "\(name).billingPeriod")
            try self.validate(self.invoicingEntity, name: "invoicingEntity", parent: name, max: 1024)
            try self.validate(self.invoicingEntity, name: "invoicingEntity", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case billingPeriod = "BillingPeriod"
            case invoicingEntity = "InvoicingEntity"
            case timeInterval = "TimeInterval"
        }
    }

    public struct InvoiceSummariesSelector: AWSEncodableShape {
        /// The query identifier type (INVOICE_ID or ACCOUNT_ID).
        public let resourceType: ListInvoiceSummariesResourceType
        /// The value of the query identifier.
        public let value: String

        @inlinable
        public init(resourceType: ListInvoiceSummariesResourceType, value: String) {
            self.resourceType = resourceType
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, pattern: "^.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case value = "Value"
        }
    }

    public struct InvoiceSummary: AWSDecodableShape {
        ///  The Amazon Web Services account ID.
        public let accountId: String?
        ///  The summary with the product and service currency.
        public let baseCurrencyAmount: InvoiceCurrencyAmount?
        ///  The billing period of the invoice-related document.
        public let billingPeriod: BillingPeriod?
        ///  The invoice due date.
        public let dueDate: Date?
        /// The organization name providing Amazon Web Services services.
        public let entity: Entity?
        ///  The invoice ID.
        public let invoiceId: String?
        ///  The type of invoice.
        public let invoiceType: InvoiceType?
        ///  The issued date of the invoice.
        public let issuedDate: Date?
        /// The initial or original invoice ID.
        public let originalInvoiceId: String?
        ///  The summary with the customer configured currency.
        public let paymentCurrencyAmount: InvoiceCurrencyAmount?
        ///  The purchase order number associated to the invoice.
        public let purchaseOrderNumber: String?
        ///  The summary with the tax currency.
        public let taxCurrencyAmount: InvoiceCurrencyAmount?

        @inlinable
        public init(accountId: String? = nil, baseCurrencyAmount: InvoiceCurrencyAmount? = nil, billingPeriod: BillingPeriod? = nil, dueDate: Date? = nil, entity: Entity? = nil, invoiceId: String? = nil, invoiceType: InvoiceType? = nil, issuedDate: Date? = nil, originalInvoiceId: String? = nil, paymentCurrencyAmount: InvoiceCurrencyAmount? = nil, purchaseOrderNumber: String? = nil, taxCurrencyAmount: InvoiceCurrencyAmount? = nil) {
            self.accountId = accountId
            self.baseCurrencyAmount = baseCurrencyAmount
            self.billingPeriod = billingPeriod
            self.dueDate = dueDate
            self.entity = entity
            self.invoiceId = invoiceId
            self.invoiceType = invoiceType
            self.issuedDate = issuedDate
            self.originalInvoiceId = originalInvoiceId
            self.paymentCurrencyAmount = paymentCurrencyAmount
            self.purchaseOrderNumber = purchaseOrderNumber
            self.taxCurrencyAmount = taxCurrencyAmount
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case baseCurrencyAmount = "BaseCurrencyAmount"
            case billingPeriod = "BillingPeriod"
            case dueDate = "DueDate"
            case entity = "Entity"
            case invoiceId = "InvoiceId"
            case invoiceType = "InvoiceType"
            case issuedDate = "IssuedDate"
            case originalInvoiceId = "OriginalInvoiceId"
            case paymentCurrencyAmount = "PaymentCurrencyAmount"
            case purchaseOrderNumber = "PurchaseOrderNumber"
            case taxCurrencyAmount = "TaxCurrencyAmount"
        }
    }

    public struct InvoiceUnit: AWSDecodableShape {
        /// The assigned description for an invoice unit. This information can't be modified or deleted.
        public let description: String?
        /// The account that receives invoices related to the invoice unit.
        public let invoiceReceiver: String?
        /// ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?
        ///  The last time the invoice unit was updated. This is important to determine the version of invoice unit configuration used to create the invoices. Any invoice created after this modified time will use this invoice unit configuration.
        public let lastModified: Date?
        ///  A unique name that is distinctive within your Amazon Web Services.
        public let name: String?
        ///  An InvoiceUnitRule object used the categorize invoice units.
        public let rule: InvoiceUnitRule?
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceReceiver: String? = nil, invoiceUnitArn: String? = nil, lastModified: Date? = nil, name: String? = nil, rule: InvoiceUnitRule? = nil, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.invoiceUnitArn = invoiceUnitArn
            self.lastModified = lastModified
            self.name = name
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceReceiver = "InvoiceReceiver"
            case invoiceUnitArn = "InvoiceUnitArn"
            case lastModified = "LastModified"
            case name = "Name"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct InvoiceUnitRule: AWSEncodableShape & AWSDecodableShape {
        /// The list of LINKED_ACCOUNT IDs where charges are included within the invoice unit.
        public let linkedAccounts: [String]?

        @inlinable
        public init(linkedAccounts: [String]? = nil) {
            self.linkedAccounts = linkedAccounts
        }

        public func validate(name: String) throws {
            try self.linkedAccounts?.forEach {
                try validate($0, name: "linkedAccounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.linkedAccounts, name: "linkedAccounts", parent: name, max: 1000)
            try self.validate(self.linkedAccounts, name: "linkedAccounts", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case linkedAccounts = "LinkedAccounts"
        }
    }

    public struct ListInvoiceSummariesRequest: AWSEncodableShape {
        /// Filters you can use to customize your invoice summary.
        public let filter: InvoiceSummariesFilter?
        /// The maximum number of invoice summaries a paginated response can contain.
        public let maxResults: Int?
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?
        /// The option to retrieve details for a specific invoice by providing its unique ID. Alternatively, access information for all invoices linked to the account by providing an account ID.
        public let selector: InvoiceSummariesSelector

        @inlinable
        public init(filter: InvoiceSummariesFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil, selector: InvoiceSummariesSelector) {
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.selector = selector
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
            try self.selector.validate(name: "\(name).selector")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "Filter"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case selector = "Selector"
        }
    }

    public struct ListInvoiceSummariesResponse: AWSDecodableShape {
        /// List of key (summary level) invoice details without line item details.
        public let invoiceSummaries: [InvoiceSummary]
        /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
        public let nextToken: String?

        @inlinable
        public init(invoiceSummaries: [InvoiceSummary], nextToken: String? = nil) {
            self.invoiceSummaries = invoiceSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceSummaries = "InvoiceSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListInvoiceUnitsRequest: AWSEncodableShape {
        ///  The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
        public let asOf: Date?
        ///  An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
        public let filters: Filters?
        /// The maximum number of invoice units that can be returned.
        public let maxResults: Int?
        /// The next token used to indicate where the returned list should start from.
        public let nextToken: String?

        @inlinable
        public init(asOf: Date? = nil, filters: Filters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.asOf = asOf
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case asOf = "AsOf"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListInvoiceUnitsResponse: AWSDecodableShape {
        ///  An invoice unit is a set of mutually exclusive accounts that correspond to your business entity.
        public let invoiceUnits: [InvoiceUnit]?
        /// The next token used to indicate where the returned list should start from.
        public let nextToken: String?

        @inlinable
        public init(invoiceUnits: [InvoiceUnit]? = nil, nextToken: String? = nil) {
            self.invoiceUnits = invoiceUnits
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnits = "InvoiceUnits"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of tags to list.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:(invoicing)::[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  Adds a tag to a resource.
        public let resourceTags: [ResourceTag]?

        @inlinable
        public init(resourceTags: [ResourceTag]? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "ResourceTags"
        }
    }

    public struct ReceiverAddress: AWSDecodableShape {
        ///  The first line of the address.
        public let addressLine1: String?
        ///  The second line of the address, if applicable.
        public let addressLine2: String?
        ///  The third line of the address, if applicable.
        public let addressLine3: String?
        ///  The city that the address is in.
        public let city: String?
        ///  A unique company name.
        public let companyName: String?
        ///  The country code for the country the address is in.
        public let countryCode: String?
        ///  The district or country the address is located in.
        public let districtOrCounty: String?
        ///  The postal code associated with the address.
        public let postalCode: String?
        ///  The state, region, or province the address is located.
        public let stateOrRegion: String?

        @inlinable
        public init(addressLine1: String? = nil, addressLine2: String? = nil, addressLine3: String? = nil, city: String? = nil, companyName: String? = nil, countryCode: String? = nil, districtOrCounty: String? = nil, postalCode: String? = nil, stateOrRegion: String? = nil) {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.companyName = companyName
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressLine1 = "AddressLine1"
            case addressLine2 = "AddressLine2"
            case addressLine3 = "AddressLine3"
            case city = "City"
            case companyName = "CompanyName"
            case countryCode = "CountryCode"
            case districtOrCounty = "DistrictOrCounty"
            case postalCode = "PostalCode"
            case stateOrRegion = "StateOrRegion"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The resource could not be found.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct ResourceTag: AWSEncodableShape & AWSDecodableShape {
        /// The object key of your of your resource tag.
        public let key: String
        ///  The specific value of the resource tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the tags.
        public let resourceArn: String
        ///  Adds a tag to a resource.
        public let resourceTags: [ResourceTag]

        @inlinable
        public init(resourceArn: String, resourceTags: [ResourceTag]) {
            self.resourceArn = resourceArn
            self.resourceTags = resourceTags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:(invoicing)::[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.resourceTags.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceTags = "ResourceTags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaxesBreakdown: AWSDecodableShape {
        ///  A list of tax information.
        public let breakdown: [TaxesBreakdownAmount]?
        ///  The total amount for your taxes.
        public let totalAmount: String?

        @inlinable
        public init(breakdown: [TaxesBreakdownAmount]? = nil, totalAmount: String? = nil) {
            self.breakdown = breakdown
            self.totalAmount = totalAmount
        }

        private enum CodingKeys: String, CodingKey {
            case breakdown = "Breakdown"
            case totalAmount = "TotalAmount"
        }
    }

    public struct TaxesBreakdownAmount: AWSDecodableShape {
        ///  The tax amount.
        public let amount: String?
        ///  The details of the taxes.
        public let description: String?
        ///  The details of the tax rate.
        public let rate: String?

        @inlinable
        public init(amount: String? = nil, description: String? = nil, rate: String? = nil) {
            self.amount = amount
            self.description = description
            self.rate = rate
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "Amount"
            case description = "Description"
            case rate = "Rate"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) to untag.
        public let resourceArn: String
        ///  Keys for the tags to be removed.
        public let resourceTagKeys: [String]

        @inlinable
        public init(resourceArn: String, resourceTagKeys: [String]) {
            self.resourceArn = resourceArn
            self.resourceTagKeys = resourceTagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:(invoicing)::[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.resourceTagKeys.forEach {
                try validate($0, name: "resourceTagKeys[]", parent: name, max: 128)
                try validate($0, name: "resourceTagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTagKeys, name: "resourceTagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceTagKeys = "ResourceTagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateInvoiceUnitRequest: AWSEncodableShape {
        /// The assigned description for an invoice unit. This information can't be modified or deleted.
        public let description: String?
        /// The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String
        /// The InvoiceUnitRule object used to update invoice units.
        public let rule: InvoiceUnitRule?
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceUnitArn: String, rule: InvoiceUnitRule? = nil, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceUnitArn = invoiceUnitArn
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, max: 256)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, min: 1)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.rule?.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceUnitArn = "InvoiceUnitArn"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct UpdateInvoiceUnitResponse: AWSDecodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?

        @inlinable
        public init(invoiceUnitArn: String? = nil) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct ValidationException: AWSErrorShape {
        ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public let fieldList: [ValidationExceptionField]?
        public let message: String?
        /// You don't have sufficient access to perform this action.
        public let reason: ValidationExceptionReason?
        /// You don't have sufficient access to perform this action.
        public let resourceName: String?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String? = nil, reason: ValidationExceptionReason? = nil, resourceName: String? = nil) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
            case resourceName = "resourceName"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public let message: String
        ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for Invoicing
public struct InvoicingErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Invoicing
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The processing request failed because of an unknown error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension InvoicingErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": Invoicing.AccessDeniedException.self,
        "InternalServerException": Invoicing.InternalServerException.self,
        "ResourceNotFoundException": Invoicing.ResourceNotFoundException.self,
        "ValidationException": Invoicing.ValidationException.self
    ]
}

extension InvoicingErrorType: Equatable {
    public static func == (lhs: InvoicingErrorType, rhs: InvoicingErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension InvoicingErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
