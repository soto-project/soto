//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Invoicing {
    // MARK: Enums

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountMembershipError = "accountMembershipError"
        case cannotParse = "cannotParse"
        case duplicateInvoiceUnit = "duplicateInvoiceUnit"
        case expiredNextToken = "expiredNextToken"
        case fieldValidationFailed = "fieldValidationFailed"
        case invalidInput = "invalidInput"
        case invalidNextToken = "invalidNextToken"
        case maxAccountsExceeded = "maxAccountsExceeded"
        case maxInvoiceUnitsExceeded = "maxInvoiceUnitsExceeded"
        case mutualExclusionError = "mutualExclusionError"
        case nonMembersPresent = "nonMemberPresent"
        case other = "other"
        case taxSettingsError = "taxSettingsError"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let message: String?
        /// You don't have sufficient access to perform this action.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct BatchGetInvoiceProfileRequest: AWSEncodableShape {
        /// Retrieves the corresponding invoice profile data for these account IDs.
        public let accountIds: [String]

        @inlinable
        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        public func validate(name: String) throws {
            try self.accountIds.forEach {
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accountIds, name: "accountIds", parent: name, max: 1000)
            try self.validate(self.accountIds, name: "accountIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
        }
    }

    public struct BatchGetInvoiceProfileResponse: AWSDecodableShape {
        ///  A list of invoice profiles corresponding to the requested accounts.
        public let profiles: [InvoiceProfile]?

        @inlinable
        public init(profiles: [InvoiceProfile]? = nil) {
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case profiles = "Profiles"
        }
    }

    public struct CreateInvoiceUnitRequest: AWSEncodableShape {
        ///  The invoice unit's description. This can be changed at a later time.
        public let description: String?
        ///  The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
        public let invoiceReceiver: String
        ///  The unique name of the invoice unit that is shown on the generated invoice. This can't be changed once it is set. To change this name, you must delete the invoice unit recreate.
        public let name: String
        ///  The tag structure that contains a tag key and value.
        public let resourceTags: [ResourceTag]?
        /// The InvoiceUnitRule object used to create invoice units.
        public let rule: InvoiceUnitRule
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceReceiver: String, name: String, resourceTags: [ResourceTag]? = nil, rule: InvoiceUnitRule, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.name = name
            self.resourceTags = resourceTags
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.invoiceReceiver, name: "invoiceReceiver", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 50)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            try self.resourceTags?.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
            try self.rule.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceReceiver = "InvoiceReceiver"
            case name = "Name"
            case resourceTags = "ResourceTags"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct CreateInvoiceUnitResponse: AWSDecodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?

        @inlinable
        public init(invoiceUnitArn: String? = nil) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct DeleteInvoiceUnitRequest: AWSEncodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String

        @inlinable
        public init(invoiceUnitArn: String) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        public func validate(name: String) throws {
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, max: 256)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, min: 1)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct DeleteInvoiceUnitResponse: AWSDecodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?

        @inlinable
        public init(invoiceUnitArn: String? = nil) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct Filters: AWSEncodableShape {
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. The specified account IDs are matched with either the receiver or the linked accounts in the rules.
        public let accounts: [String]?
        /// You can specify a list of Amazon Web Services account IDs inside filters to return invoice units that match only the specified accounts. If multiple accounts are provided, the result is an OR condition (match any) of the specified accounts. This filter only matches the specified accounts on the invoice receivers of the invoice units.
        public let invoiceReceivers: [String]?
        ///  An optional input to the list API. You can specify a list of invoice unit names inside filters to return invoice units that match only the specified invoice unit names. If multiple names are provided, the result is an OR condition (match any) of the specified invoice unit names.
        public let names: [String]?

        @inlinable
        public init(accounts: [String]? = nil, invoiceReceivers: [String]? = nil, names: [String]? = nil) {
            self.accounts = accounts
            self.invoiceReceivers = invoiceReceivers
            self.names = names
        }

        public func validate(name: String) throws {
            try self.accounts?.forEach {
                try validate($0, name: "accounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.accounts, name: "accounts", parent: name, max: 1000)
            try self.validate(self.accounts, name: "accounts", parent: name, min: 1)
            try self.invoiceReceivers?.forEach {
                try validate($0, name: "invoiceReceivers[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.invoiceReceivers, name: "invoiceReceivers", parent: name, max: 1000)
            try self.validate(self.invoiceReceivers, name: "invoiceReceivers", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, max: 50)
                try validate($0, name: "names[]", parent: name, min: 1)
                try validate($0, name: "names[]", parent: name, pattern: "^(?! )[\\p{L}\\p{N}\\p{Z}-_]*(?<! )$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "Accounts"
            case invoiceReceivers = "InvoiceReceivers"
            case names = "Names"
        }
    }

    public struct GetInvoiceUnitRequest: AWSEncodableShape {
        ///  The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
        public let asOf: Date?
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String

        @inlinable
        public init(asOf: Date? = nil, invoiceUnitArn: String) {
            self.asOf = asOf
            self.invoiceUnitArn = invoiceUnitArn
        }

        public func validate(name: String) throws {
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, max: 256)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, min: 1)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case asOf = "AsOf"
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct GetInvoiceUnitResponse: AWSDecodableShape {
        ///  The assigned description for an invoice unit.
        public let description: String?
        ///  The Amazon Web Services account ID chosen to be the receiver of an invoice unit. All invoices generated for that invoice unit will be sent to this account ID.
        public let invoiceReceiver: String?
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?
        ///  The most recent date the invoice unit response was updated.
        public let lastModified: Date?
        ///  The unique name of the invoice unit that is shown on the generated invoice.
        public let name: String?
        public let rule: InvoiceUnitRule?
        ///  Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceReceiver: String? = nil, invoiceUnitArn: String? = nil, lastModified: Date? = nil, name: String? = nil, rule: InvoiceUnitRule? = nil, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.invoiceUnitArn = invoiceUnitArn
            self.lastModified = lastModified
            self.name = name
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceReceiver = "InvoiceReceiver"
            case invoiceUnitArn = "InvoiceUnitArn"
            case lastModified = "LastModified"
            case name = "Name"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String?
        /// The processing request failed because of an unknown error, exception, or failure.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String? = nil, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct InvoiceProfile: AWSDecodableShape {
        /// The account ID the invoice profile is generated for.
        public let accountId: String?
        /// This specifies the issuing entity of the invoice.
        public let issuer: String?
        /// The address of the receiver that will be printed on the invoice.
        public let receiverAddress: ReceiverAddress?
        /// The email address for the invoice profile receiver.
        public let receiverEmail: String?
        /// The name of the person receiving the invoice profile.
        public let receiverName: String?
        /// Your Tax Registration Number (TRN) information.
        public let taxRegistrationNumber: String?

        @inlinable
        public init(accountId: String? = nil, issuer: String? = nil, receiverAddress: ReceiverAddress? = nil, receiverEmail: String? = nil, receiverName: String? = nil, taxRegistrationNumber: String? = nil) {
            self.accountId = accountId
            self.issuer = issuer
            self.receiverAddress = receiverAddress
            self.receiverEmail = receiverEmail
            self.receiverName = receiverName
            self.taxRegistrationNumber = taxRegistrationNumber
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case issuer = "Issuer"
            case receiverAddress = "ReceiverAddress"
            case receiverEmail = "ReceiverEmail"
            case receiverName = "ReceiverName"
            case taxRegistrationNumber = "TaxRegistrationNumber"
        }
    }

    public struct InvoiceUnit: AWSDecodableShape {
        /// The assigned description for an invoice unit. This information can't be modified or deleted.
        public let description: String?
        /// The account that receives invoices related to the invoice unit.
        public let invoiceReceiver: String?
        /// ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?
        /// The last time the invoice unit was updated. This is important to determine the version of invoice unit configuration used to create the invoices. Any invoice created after this modified time will use this invoice unit configuration.
        public let lastModified: Date?
        ///  A unique name that is distinctive within your Amazon Web Services.
        public let name: String?
        /// An InvoiceUnitRule object used the categorize invoice units.
        public let rule: InvoiceUnitRule?
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceReceiver: String? = nil, invoiceUnitArn: String? = nil, lastModified: Date? = nil, name: String? = nil, rule: InvoiceUnitRule? = nil, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceReceiver = invoiceReceiver
            self.invoiceUnitArn = invoiceUnitArn
            self.lastModified = lastModified
            self.name = name
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceReceiver = "InvoiceReceiver"
            case invoiceUnitArn = "InvoiceUnitArn"
            case lastModified = "LastModified"
            case name = "Name"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct InvoiceUnitRule: AWSEncodableShape & AWSDecodableShape {
        /// The list of LINKED_ACCOUNT IDs where charges are included within the invoice unit.
        public let linkedAccounts: [String]?

        @inlinable
        public init(linkedAccounts: [String]? = nil) {
            self.linkedAccounts = linkedAccounts
        }

        public func validate(name: String) throws {
            try self.linkedAccounts?.forEach {
                try validate($0, name: "linkedAccounts[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.validate(self.linkedAccounts, name: "linkedAccounts", parent: name, max: 1000)
            try self.validate(self.linkedAccounts, name: "linkedAccounts", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case linkedAccounts = "LinkedAccounts"
        }
    }

    public struct ListInvoiceUnitsRequest: AWSEncodableShape {
        ///  The state of an invoice unit at a specified time. You can see legacy invoice units that are currently deleted if the AsOf time is set to before it was deleted. If an AsOf is not provided, the default value is the current time.
        public let asOf: Date?
        ///  An optional input to the list API. If multiple filters are specified, the returned list will be a configuration that match all of the provided filters. Supported filter types are InvoiceReceivers, Names, and Accounts.
        public let filters: Filters?
        /// The maximum number of invoice units that can be returned.
        public let maxResults: Int?
        /// The next token used to indicate where the returned list should start from.
        public let nextToken: String?

        @inlinable
        public init(asOf: Date? = nil, filters: Filters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.asOf = asOf
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S\\s]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case asOf = "AsOf"
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListInvoiceUnitsResponse: AWSDecodableShape {
        ///  An invoice unit is a set of mutually exclusive accounts that correspond to your business entity.
        public let invoiceUnits: [InvoiceUnit]?
        /// The next token used to indicate where the returned list should start from.
        public let nextToken: String?

        @inlinable
        public init(invoiceUnits: [InvoiceUnit]? = nil, nextToken: String? = nil) {
            self.invoiceUnits = invoiceUnits
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnits = "InvoiceUnits"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of tags to list.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        ///  Adds a tag to a resource.
        public let resourceTags: [ResourceTag]?

        @inlinable
        public init(resourceTags: [ResourceTag]? = nil) {
            self.resourceTags = resourceTags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceTags = "ResourceTags"
        }
    }

    public struct ReceiverAddress: AWSDecodableShape {
        /// The first line of the address.
        public let addressLine1: String?
        /// The second line of the address, if applicable.
        public let addressLine2: String?
        /// The third line of the address, if applicable.
        public let addressLine3: String?
        /// The city that the address is in.
        public let city: String?
        /// A unique company name.
        public let companyName: String?
        /// The country code for the country the address is in.
        public let countryCode: String?
        /// The district or country the address is located in.
        public let districtOrCounty: String?
        /// The postal code associated with the address.
        public let postalCode: String?
        /// The state, region, or province the address is located.
        public let stateOrRegion: String?

        @inlinable
        public init(addressLine1: String? = nil, addressLine2: String? = nil, addressLine3: String? = nil, city: String? = nil, companyName: String? = nil, countryCode: String? = nil, districtOrCounty: String? = nil, postalCode: String? = nil, stateOrRegion: String? = nil) {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.companyName = companyName
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }

        private enum CodingKeys: String, CodingKey {
            case addressLine1 = "AddressLine1"
            case addressLine2 = "AddressLine2"
            case addressLine3 = "AddressLine3"
            case city = "City"
            case companyName = "CompanyName"
            case countryCode = "CountryCode"
            case districtOrCounty = "DistrictOrCounty"
            case postalCode = "PostalCode"
            case stateOrRegion = "StateOrRegion"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String?
        /// The resource could not be found.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct ResourceTag: AWSEncodableShape & AWSDecodableShape {
        /// The object key of your of your resource tag.
        public let key: String
        /// The specific value of the resource tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the tags.
        public let resourceArn: String
        ///  Adds a tag to a resource.
        public let resourceTags: [ResourceTag]

        @inlinable
        public init(resourceArn: String, resourceTags: [ResourceTag]) {
            self.resourceArn = resourceArn
            self.resourceTags = resourceTags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.resourceTags.forEach {
                try $0.validate(name: "\(name).resourceTags[]")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceTags = "ResourceTags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        ///  The Amazon Resource Name (ARN) to untag.
        public let resourceArn: String
        ///  Keys for the tags to be removed.
        public let resourceTagKeys: [String]

        @inlinable
        public init(resourceArn: String, resourceTagKeys: [String]) {
            self.resourceArn = resourceArn
            self.resourceTagKeys = resourceTagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.resourceTagKeys.forEach {
                try validate($0, name: "resourceTagKeys[]", parent: name, max: 128)
                try validate($0, name: "resourceTagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.resourceTagKeys, name: "resourceTagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case resourceTagKeys = "ResourceTagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateInvoiceUnitRequest: AWSEncodableShape {
        /// The assigned description for an invoice unit. This information can't be modified or deleted.
        public let description: String?
        /// The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String
        /// The InvoiceUnitRule object used to update invoice units.
        public let rule: InvoiceUnitRule?
        /// Whether the invoice unit based tax inheritance is/ should be enabled or disabled.
        public let taxInheritanceDisabled: Bool?

        @inlinable
        public init(description: String? = nil, invoiceUnitArn: String, rule: InvoiceUnitRule? = nil, taxInheritanceDisabled: Bool? = nil) {
            self.description = description
            self.invoiceUnitArn = invoiceUnitArn
            self.rule = rule
            self.taxInheritanceDisabled = taxInheritanceDisabled
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S\\s]*$")
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, max: 256)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, min: 1)
            try self.validate(self.invoiceUnitArn, name: "invoiceUnitArn", parent: name, pattern: "^arn:aws[-a-z0-9]*:[a-z0-9]+:[-a-z0-9]*:[0-9]{12}:[-a-zA-Z0-9/:_]+$")
            try self.rule?.validate(name: "\(name).rule")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case invoiceUnitArn = "InvoiceUnitArn"
            case rule = "Rule"
            case taxInheritanceDisabled = "TaxInheritanceDisabled"
        }
    }

    public struct UpdateInvoiceUnitResponse: AWSDecodableShape {
        ///  The ARN to identify an invoice unit. This information can't be modified or deleted.
        public let invoiceUnitArn: String?

        @inlinable
        public init(invoiceUnitArn: String? = nil) {
            self.invoiceUnitArn = invoiceUnitArn
        }

        private enum CodingKeys: String, CodingKey {
            case invoiceUnitArn = "InvoiceUnitArn"
        }
    }

    public struct ValidationException: AWSErrorShape {
        ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public let fieldList: [ValidationExceptionField]?
        public let message: String?
        /// You don't have sufficient access to perform this action.
        public let reason: ValidationExceptionReason?
        /// You don't have sufficient access to perform this action.
        public let resourceName: String?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String? = nil, reason: ValidationExceptionReason? = nil, resourceName: String? = nil) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
            case resourceName = "resourceName"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public let message: String
        ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }
}

// MARK: - Errors

/// Error enum for Invoicing
public struct InvoicingErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Invoicing
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The processing request failed because of an unknown error, exception, or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was rejected because it attempted to create resources beyond the current Amazon Web Services account limits. The error message describes the limit exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    ///  The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension InvoicingErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": Invoicing.AccessDeniedException.self,
        "InternalServerException": Invoicing.InternalServerException.self,
        "ResourceNotFoundException": Invoicing.ResourceNotFoundException.self,
        "ValidationException": Invoicing.ValidationException.self
    ]
}

extension InvoicingErrorType: Equatable {
    public static func == (lhs: InvoicingErrorType, rhs: InvoicingErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension InvoicingErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
