//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension FIS {
    // MARK: Enums

    public enum AccountTargeting: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiAccount = "multi-account"
        case singleAccount = "single-account"
        public var description: String { return self.rawValue }
    }

    public enum ActionsMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case runAll = "run-all"
        case skipAll = "skip-all"
        public var description: String { return self.rawValue }
    }

    public enum EmptyTargetResolutionMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fail = "fail"
        case skip = "skip"
        public var description: String { return self.rawValue }
    }

    public enum ExperimentActionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "cancelled"
        case completed = "completed"
        case failed = "failed"
        case initiating = "initiating"
        case pending = "pending"
        case running = "running"
        case skipped = "skipped"
        case stopped = "stopped"
        case stopping = "stopping"
        public var description: String { return self.rawValue }
    }

    public enum ExperimentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "completed"
        case failed = "failed"
        case initiating = "initiating"
        case pending = "pending"
        case running = "running"
        case stopped = "stopped"
        case stopping = "stopping"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the action.
        public let arn: String?
        /// The description for the action.
        public let description: String?
        /// The ID of the action.
        public let id: String?
        /// The action parameters, if applicable.
        public let parameters: [String: ActionParameter]?
        /// The tags for the action.
        public let tags: [String: String]?
        /// The supported targets for the action.
        public let targets: [String: ActionTarget]?

        public init(arn: String? = nil, description: String? = nil, id: String? = nil, parameters: [String: ActionParameter]? = nil, tags: [String: String]? = nil, targets: [String: ActionTarget]? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.parameters = parameters
            self.tags = tags
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case id = "id"
            case parameters = "parameters"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct ActionParameter: AWSDecodableShape {
        /// The parameter description.
        public let description: String?
        /// Indicates whether the parameter is required.
        public let required: Bool?

        public init(description: String? = nil, required: Bool? = nil) {
            self.description = description
            self.required = required
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case required = "required"
        }
    }

    public struct ActionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the action.
        public let arn: String?
        /// The description for the action.
        public let description: String?
        /// The ID of the action.
        public let id: String?
        /// The tags for the action.
        public let tags: [String: String]?
        /// The targets for the action.
        public let targets: [String: ActionTarget]?

        public init(arn: String? = nil, description: String? = nil, id: String? = nil, tags: [String: String]? = nil, targets: [String: ActionTarget]? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.tags = tags
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case description = "description"
            case id = "id"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct ActionTarget: AWSDecodableShape {
        /// The resource type of the target.
        public let resourceType: String?

        public init(resourceType: String? = nil) {
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "resourceType"
        }
    }

    public struct CreateExperimentTemplateActionInput: AWSEncodableShape {
        /// The ID of the action. The format of the action ID is: aws:service-name:action-type.
        public let actionId: String
        /// A description for the action.
        public let description: String?
        /// The parameters for the action, if applicable.
        public let parameters: [String: String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public let startAfter: [String]?
        /// The targets for the action.
        public let targets: [String: String]?

        public init(actionId: String, description: String? = nil, parameters: [String: String]? = nil, startAfter: [String]? = nil, targets: [String: String]? = nil) {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.validate(self.actionId, name: "actionId", parent: name, max: 128)
            try self.validate(self.actionId, name: "actionId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 64)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\S]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, pattern: "^[\\S]+$")
            }
            try self.startAfter?.forEach {
                try validate($0, name: "startAfter[]", parent: name, max: 64)
                try validate($0, name: "startAfter[]", parent: name, pattern: "^[\\S]+$")
            }
            try self.targets?.forEach {
                try validate($0.key, name: "targets.key", parent: name, max: 64)
                try validate($0.key, name: "targets.key", parent: name, pattern: "^[\\S]+$")
                try validate($0.value, name: "targets[\"\($0.key)\"]", parent: name, max: 64)
                try validate($0.value, name: "targets[\"\($0.key)\"]", parent: name, pattern: "^[\\S]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "actionId"
            case description = "description"
            case parameters = "parameters"
            case startAfter = "startAfter"
            case targets = "targets"
        }
    }

    public struct CreateExperimentTemplateExperimentOptionsInput: AWSEncodableShape {
        /// Specifies the account targeting setting for experiment options.
        public let accountTargeting: AccountTargeting?
        /// Specifies the empty target resolution mode for experiment options.
        public let emptyTargetResolutionMode: EmptyTargetResolutionMode?

        public init(accountTargeting: AccountTargeting? = nil, emptyTargetResolutionMode: EmptyTargetResolutionMode? = nil) {
            self.accountTargeting = accountTargeting
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }

        private enum CodingKeys: String, CodingKey {
            case accountTargeting = "accountTargeting"
            case emptyTargetResolutionMode = "emptyTargetResolutionMode"
        }
    }

    public struct CreateExperimentTemplateLogConfigurationInput: AWSEncodableShape {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public let cloudWatchLogsConfiguration: ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        public let logSchemaVersion: Int
        /// The configuration for experiment logging to Amazon S3.
        public let s3Configuration: ExperimentTemplateS3LogConfigurationInput?

        public init(cloudWatchLogsConfiguration: ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil, logSchemaVersion: Int, s3Configuration: ExperimentTemplateS3LogConfigurationInput? = nil) {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsConfiguration?.validate(name: "\(name).cloudWatchLogsConfiguration")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsConfiguration = "cloudWatchLogsConfiguration"
            case logSchemaVersion = "logSchemaVersion"
            case s3Configuration = "s3Configuration"
        }
    }

    public struct CreateExperimentTemplateRequest: AWSEncodableShape {
        /// The actions for the experiment.
        public let actions: [String: CreateExperimentTemplateActionInput]
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String
        /// A description for the experiment template.
        public let description: String
        /// The experiment options for the experiment template.
        public let experimentOptions: CreateExperimentTemplateExperimentOptionsInput?
        /// The configuration for experiment logging.
        public let logConfiguration: CreateExperimentTemplateLogConfigurationInput?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
        public let roleArn: String
        /// The stop conditions.
        public let stopConditions: [CreateExperimentTemplateStopConditionInput]
        /// The tags to apply to the experiment template.
        public let tags: [String: String]?
        /// The targets for the experiment.
        public let targets: [String: CreateExperimentTemplateTargetInput]?

        public init(actions: [String: CreateExperimentTemplateActionInput], clientToken: String = CreateExperimentTemplateRequest.idempotencyToken(), description: String, experimentOptions: CreateExperimentTemplateExperimentOptionsInput? = nil, logConfiguration: CreateExperimentTemplateLogConfigurationInput? = nil, roleArn: String, stopConditions: [CreateExperimentTemplateStopConditionInput], tags: [String: String]? = nil, targets: [String: CreateExperimentTemplateTargetInput]? = nil) {
            self.actions = actions
            self.clientToken = clientToken
            self.description = description
            self.experimentOptions = experimentOptions
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.tags = tags
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try validate($0.key, name: "actions.key", parent: name, max: 64)
                try validate($0.key, name: "actions.key", parent: name, pattern: "^[\\S]+$")
                try $0.value.validate(name: "\(name).actions[\"\($0.key)\"]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 1024)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]+$")
            try self.logConfiguration?.validate(name: "\(name).logConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[\\S]+$")
            try self.stopConditions.forEach {
                try $0.validate(name: "\(name).stopConditions[]")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\s\\S]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.targets?.forEach {
                try validate($0.key, name: "targets.key", parent: name, max: 64)
                try validate($0.key, name: "targets.key", parent: name, pattern: "^[\\S]+$")
                try $0.value.validate(name: "\(name).targets[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case clientToken = "clientToken"
            case description = "description"
            case experimentOptions = "experimentOptions"
            case logConfiguration = "logConfiguration"
            case roleArn = "roleArn"
            case stopConditions = "stopConditions"
            case tags = "tags"
            case targets = "targets"
        }
    }

    public struct CreateExperimentTemplateResponse: AWSDecodableShape {
        /// Information about the experiment template.
        public let experimentTemplate: ExperimentTemplate?

        public init(experimentTemplate: ExperimentTemplate? = nil) {
            self.experimentTemplate = experimentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case experimentTemplate = "experimentTemplate"
        }
    }

    public struct CreateExperimentTemplateStopConditionInput: AWSEncodableShape {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        public let source: String
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm. This is required if the source is a CloudWatch alarm.
        public let value: String?

        public init(source: String, value: String? = nil) {
            self.source = source
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, max: 64)
            try self.validate(self.source, name: "source", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.value, name: "value", parent: name, max: 2048)
            try self.validate(self.value, name: "value", parent: name, min: 20)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[\\s\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case value = "value"
        }
    }

    public struct CreateExperimentTemplateTargetInput: AWSEncodableShape {
        /// The filters to apply to identify target resources using specific attributes.
        public let filters: [ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public let parameters: [String: String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public let resourceArns: [String]?
        /// The tags for the target resources.
        public let resourceTags: [String: String]?
        /// The resource type. The resource type must be supported for the specified action.
        public let resourceType: String
        /// Scopes the identified resources to a specific count of the resources at random, or a percentage of the resources. All identified resources are included in the target.   ALL - Run the action on all identified targets. This is the default.   COUNT(n) - Run the action on the specified number of targets, chosen from the identified targets at random. For example, COUNT(1) selects one of the targets.   PERCENT(n) - Run the action on the specified percentage of targets, chosen from the identified targets  at random. For example, PERCENT(25) selects 25% of the targets.
        public let selectionMode: String

        public init(filters: [ExperimentTemplateTargetInputFilter]? = nil, parameters: [String: String]? = nil, resourceArns: [String]? = nil, resourceTags: [String: String]? = nil, resourceType: String, selectionMode: String) {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 64)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\S]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, pattern: "^[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+$")
            }
            try self.resourceArns?.forEach {
                try validate($0, name: "resourceArns[]", parent: name, max: 2048)
                try validate($0, name: "resourceArns[]", parent: name, min: 20)
                try validate($0, name: "resourceArns[]", parent: name, pattern: "^[\\S]+$")
            }
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 5)
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^[\\s\\S]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 50)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 128)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.selectionMode, name: "selectionMode", parent: name, max: 64)
            try self.validate(self.selectionMode, name: "selectionMode", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case parameters = "parameters"
            case resourceArns = "resourceArns"
            case resourceTags = "resourceTags"
            case resourceType = "resourceType"
            case selectionMode = "selectionMode"
        }
    }

    public struct CreateTargetAccountConfigurationRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The description of the target account.
        public let description: String?
        /// The experiment template ID.
        public let experimentTemplateId: String
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public let roleArn: String

        public init(accountId: String, clientToken: String? = CreateTargetAccountConfigurationRequest.idempotencyToken(), description: String? = nil, experimentTemplateId: String, roleArn: String) {
            self.accountId = accountId
            self.clientToken = clientToken
            self.description = description
            self.experimentTemplateId = experimentTemplateId
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.experimentTemplateId, key: "experimentTemplateId")
            try container.encode(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 48)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 1024)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, max: 64)
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct CreateTargetAccountConfigurationResponse: AWSDecodableShape {
        /// Information about the target account configuration.
        public let targetAccountConfiguration: TargetAccountConfiguration?

        public init(targetAccountConfiguration: TargetAccountConfiguration? = nil) {
            self.targetAccountConfiguration = targetAccountConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case targetAccountConfiguration = "targetAccountConfiguration"
        }
    }

    public struct DeleteExperimentTemplateRequest: AWSEncodableShape {
        /// The ID of the experiment template.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteExperimentTemplateResponse: AWSDecodableShape {
        /// Information about the experiment template.
        public let experimentTemplate: ExperimentTemplate?

        public init(experimentTemplate: ExperimentTemplate? = nil) {
            self.experimentTemplate = experimentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case experimentTemplate = "experimentTemplate"
        }
    }

    public struct DeleteTargetAccountConfigurationRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String
        /// The ID of the experiment template.
        public let experimentTemplateId: String

        public init(accountId: String, experimentTemplateId: String) {
            self.accountId = accountId
            self.experimentTemplateId = experimentTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.experimentTemplateId, key: "experimentTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 48)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, max: 64)
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTargetAccountConfigurationResponse: AWSDecodableShape {
        /// Information about the target account configuration.
        public let targetAccountConfiguration: TargetAccountConfiguration?

        public init(targetAccountConfiguration: TargetAccountConfiguration? = nil) {
            self.targetAccountConfiguration = targetAccountConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case targetAccountConfiguration = "targetAccountConfiguration"
        }
    }

    public struct Experiment: AWSDecodableShape {
        /// The actions for the experiment.
        public let actions: [String: ExperimentAction]?
        /// The Amazon Resource Name (ARN) of the experiment.
        public let arn: String?
        /// The time that the experiment was created.
        public let creationTime: Date?
        /// The time that the experiment ended.
        public let endTime: Date?
        /// The experiment options for the experiment.
        public let experimentOptions: ExperimentOptions?
        /// The ID of the experiment template.
        public let experimentTemplateId: String?
        /// The ID of the experiment.
        public let id: String?
        /// The configuration for experiment logging.
        public let logConfiguration: ExperimentLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
        public let roleArn: String?
        /// The time that the experiment started.
        public let startTime: Date?
        /// The state of the experiment.
        public let state: ExperimentState?
        /// The stop conditions for the experiment.
        public let stopConditions: [ExperimentStopCondition]?
        /// The tags for the experiment.
        public let tags: [String: String]?
        /// The count of target account configurations for the experiment.
        public let targetAccountConfigurationsCount: Int64?
        /// The targets for the experiment.
        public let targets: [String: ExperimentTarget]?

        public init(actions: [String: ExperimentAction]? = nil, arn: String? = nil, creationTime: Date? = nil, endTime: Date? = nil, experimentOptions: ExperimentOptions? = nil, experimentTemplateId: String? = nil, id: String? = nil, logConfiguration: ExperimentLogConfiguration? = nil, roleArn: String? = nil, startTime: Date? = nil, state: ExperimentState? = nil, stopConditions: [ExperimentStopCondition]? = nil, tags: [String: String]? = nil, targetAccountConfigurationsCount: Int64? = nil, targets: [String: ExperimentTarget]? = nil) {
            self.actions = actions
            self.arn = arn
            self.creationTime = creationTime
            self.endTime = endTime
            self.experimentOptions = experimentOptions
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.startTime = startTime
            self.state = state
            self.stopConditions = stopConditions
            self.tags = tags
            self.targetAccountConfigurationsCount = targetAccountConfigurationsCount
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case arn = "arn"
            case creationTime = "creationTime"
            case endTime = "endTime"
            case experimentOptions = "experimentOptions"
            case experimentTemplateId = "experimentTemplateId"
            case id = "id"
            case logConfiguration = "logConfiguration"
            case roleArn = "roleArn"
            case startTime = "startTime"
            case state = "state"
            case stopConditions = "stopConditions"
            case tags = "tags"
            case targetAccountConfigurationsCount = "targetAccountConfigurationsCount"
            case targets = "targets"
        }
    }

    public struct ExperimentAction: AWSDecodableShape {
        /// The ID of the action.
        public let actionId: String?
        /// The description for the action.
        public let description: String?
        /// The time that the action ended.
        public let endTime: Date?
        /// The parameters for the action.
        public let parameters: [String: String]?
        /// The name of the action that must be completed before this action starts.
        public let startAfter: [String]?
        /// The time that the action started.
        public let startTime: Date?
        /// The state of the action.
        public let state: ExperimentActionState?
        /// The targets for the action.
        public let targets: [String: String]?

        public init(actionId: String? = nil, description: String? = nil, endTime: Date? = nil, parameters: [String: String]? = nil, startAfter: [String]? = nil, startTime: Date? = nil, state: ExperimentActionState? = nil, targets: [String: String]? = nil) {
            self.actionId = actionId
            self.description = description
            self.endTime = endTime
            self.parameters = parameters
            self.startAfter = startAfter
            self.startTime = startTime
            self.state = state
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "actionId"
            case description = "description"
            case endTime = "endTime"
            case parameters = "parameters"
            case startAfter = "startAfter"
            case startTime = "startTime"
            case state = "state"
            case targets = "targets"
        }
    }

    public struct ExperimentActionState: AWSDecodableShape {
        /// The reason for the state.
        public let reason: String?
        /// The state of the action.
        public let status: ExperimentActionStatus?

        public init(reason: String? = nil, status: ExperimentActionStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct ExperimentCloudWatchLogsLogConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public let logGroupArn: String?

        public init(logGroupArn: String? = nil) {
            self.logGroupArn = logGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "logGroupArn"
        }
    }

    public struct ExperimentLogConfiguration: AWSDecodableShape {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public let cloudWatchLogsConfiguration: ExperimentCloudWatchLogsLogConfiguration?
        /// The schema version.
        public let logSchemaVersion: Int?
        /// The configuration for experiment logging to Amazon S3.
        public let s3Configuration: ExperimentS3LogConfiguration?

        public init(cloudWatchLogsConfiguration: ExperimentCloudWatchLogsLogConfiguration? = nil, logSchemaVersion: Int? = nil, s3Configuration: ExperimentS3LogConfiguration? = nil) {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsConfiguration = "cloudWatchLogsConfiguration"
            case logSchemaVersion = "logSchemaVersion"
            case s3Configuration = "s3Configuration"
        }
    }

    public struct ExperimentOptions: AWSDecodableShape {
        /// The account targeting setting for an experiment.
        public let accountTargeting: AccountTargeting?
        /// The actions mode of the experiment that is set from the StartExperiment API command.
        public let actionsMode: ActionsMode?
        /// The empty target resolution mode for an experiment.
        public let emptyTargetResolutionMode: EmptyTargetResolutionMode?

        public init(accountTargeting: AccountTargeting? = nil, actionsMode: ActionsMode? = nil, emptyTargetResolutionMode: EmptyTargetResolutionMode? = nil) {
            self.accountTargeting = accountTargeting
            self.actionsMode = actionsMode
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }

        private enum CodingKeys: String, CodingKey {
            case accountTargeting = "accountTargeting"
            case actionsMode = "actionsMode"
            case emptyTargetResolutionMode = "emptyTargetResolutionMode"
        }
    }

    public struct ExperimentS3LogConfiguration: AWSDecodableShape {
        /// The name of the destination bucket.
        public let bucketName: String?
        /// The bucket prefix.
        public let prefix: String?

        public init(bucketName: String? = nil, prefix: String? = nil) {
            self.bucketName = bucketName
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case prefix = "prefix"
        }
    }

    public struct ExperimentState: AWSDecodableShape {
        /// The reason for the state.
        public let reason: String?
        /// The state of the experiment.
        public let status: ExperimentStatus?

        public init(reason: String? = nil, status: ExperimentStatus? = nil) {
            self.reason = reason
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case status = "status"
        }
    }

    public struct ExperimentStopCondition: AWSDecodableShape {
        /// The source for the stop condition.
        public let source: String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public let value: String?

        public init(source: String? = nil, value: String? = nil) {
            self.source = source
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case value = "value"
        }
    }

    public struct ExperimentSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the experiment.
        public let arn: String?
        /// The time that the experiment was created.
        public let creationTime: Date?
        /// The experiment options for the experiment.
        public let experimentOptions: ExperimentOptions?
        /// The ID of the experiment template.
        public let experimentTemplateId: String?
        /// The ID of the experiment.
        public let id: String?
        /// The state of the experiment.
        public let state: ExperimentState?
        /// The tags for the experiment.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationTime: Date? = nil, experimentOptions: ExperimentOptions? = nil, experimentTemplateId: String? = nil, id: String? = nil, state: ExperimentState? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.experimentOptions = experimentOptions
            self.experimentTemplateId = experimentTemplateId
            self.id = id
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case experimentOptions = "experimentOptions"
            case experimentTemplateId = "experimentTemplateId"
            case id = "id"
            case state = "state"
            case tags = "tags"
        }
    }

    public struct ExperimentTarget: AWSDecodableShape {
        /// The filters to apply to identify target resources using specific attributes.
        public let filters: [ExperimentTargetFilter]?
        /// The resource type parameters.
        public let parameters: [String: String]?
        /// The Amazon Resource Names (ARNs) of the resources.
        public let resourceArns: [String]?
        /// The tags for the target resources.
        public let resourceTags: [String: String]?
        /// The resource type.
        public let resourceType: String?
        /// Scopes the identified resources to a specific count or percentage.
        public let selectionMode: String?

        public init(filters: [ExperimentTargetFilter]? = nil, parameters: [String: String]? = nil, resourceArns: [String]? = nil, resourceTags: [String: String]? = nil, resourceType: String? = nil, selectionMode: String? = nil) {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case parameters = "parameters"
            case resourceArns = "resourceArns"
            case resourceTags = "resourceTags"
            case resourceType = "resourceType"
            case selectionMode = "selectionMode"
        }
    }

    public struct ExperimentTargetAccountConfiguration: AWSDecodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String?
        /// The description of the target account.
        public let description: String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public let roleArn: String?

        public init(accountId: String? = nil, description: String? = nil, roleArn: String? = nil) {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct ExperimentTargetAccountConfigurationSummary: AWSDecodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String?
        /// The description of the target account.
        public let description: String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public let roleArn: String?

        public init(accountId: String? = nil, description: String? = nil, roleArn: String? = nil) {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct ExperimentTargetFilter: AWSDecodableShape {
        /// The attribute path for the filter.
        public let path: String?
        /// The attribute values for the filter.
        public let values: [String]?

        public init(path: String? = nil, values: [String]? = nil) {
            self.path = path
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
            case values = "values"
        }
    }

    public struct ExperimentTemplate: AWSDecodableShape {
        /// The actions for the experiment.
        public let actions: [String: ExperimentTemplateAction]?
        /// The Amazon Resource Name (ARN) of the experiment template.
        public let arn: String?
        /// The time the experiment template was created.
        public let creationTime: Date?
        /// The description for the experiment template.
        public let description: String?
        /// The experiment options for an experiment template.
        public let experimentOptions: ExperimentTemplateExperimentOptions?
        /// The ID of the experiment template.
        public let id: String?
        /// The time the experiment template was last updated.
        public let lastUpdateTime: Date?
        /// The configuration for experiment logging.
        public let logConfiguration: ExperimentTemplateLogConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role.
        public let roleArn: String?
        /// The stop conditions for the experiment.
        public let stopConditions: [ExperimentTemplateStopCondition]?
        /// The tags for the experiment template.
        public let tags: [String: String]?
        /// The count of target account configurations for the experiment template.
        public let targetAccountConfigurationsCount: Int64?
        /// The targets for the experiment.
        public let targets: [String: ExperimentTemplateTarget]?

        public init(actions: [String: ExperimentTemplateAction]? = nil, arn: String? = nil, creationTime: Date? = nil, description: String? = nil, experimentOptions: ExperimentTemplateExperimentOptions? = nil, id: String? = nil, lastUpdateTime: Date? = nil, logConfiguration: ExperimentTemplateLogConfiguration? = nil, roleArn: String? = nil, stopConditions: [ExperimentTemplateStopCondition]? = nil, tags: [String: String]? = nil, targetAccountConfigurationsCount: Int64? = nil, targets: [String: ExperimentTemplateTarget]? = nil) {
            self.actions = actions
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.experimentOptions = experimentOptions
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.tags = tags
            self.targetAccountConfigurationsCount = targetAccountConfigurationsCount
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case experimentOptions = "experimentOptions"
            case id = "id"
            case lastUpdateTime = "lastUpdateTime"
            case logConfiguration = "logConfiguration"
            case roleArn = "roleArn"
            case stopConditions = "stopConditions"
            case tags = "tags"
            case targetAccountConfigurationsCount = "targetAccountConfigurationsCount"
            case targets = "targets"
        }
    }

    public struct ExperimentTemplateAction: AWSDecodableShape {
        /// The ID of the action.
        public let actionId: String?
        /// A description for the action.
        public let description: String?
        /// The parameters for the action.
        public let parameters: [String: String]?
        /// The name of the action that must be completed before the current action starts.
        public let startAfter: [String]?
        /// The targets for the action.
        public let targets: [String: String]?

        public init(actionId: String? = nil, description: String? = nil, parameters: [String: String]? = nil, startAfter: [String]? = nil, targets: [String: String]? = nil) {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "actionId"
            case description = "description"
            case parameters = "parameters"
            case startAfter = "startAfter"
            case targets = "targets"
        }
    }

    public struct ExperimentTemplateCloudWatchLogsLogConfiguration: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public let logGroupArn: String?

        public init(logGroupArn: String? = nil) {
            self.logGroupArn = logGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "logGroupArn"
        }
    }

    public struct ExperimentTemplateCloudWatchLogsLogConfigurationInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the destination Amazon CloudWatch Logs log group.
        public let logGroupArn: String

        public init(logGroupArn: String) {
            self.logGroupArn = logGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, max: 2048)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, min: 20)
            try self.validate(self.logGroupArn, name: "logGroupArn", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case logGroupArn = "logGroupArn"
        }
    }

    public struct ExperimentTemplateExperimentOptions: AWSDecodableShape {
        /// The account targeting setting for an experiment template.
        public let accountTargeting: AccountTargeting?
        /// The empty target resolution mode for an experiment template.
        public let emptyTargetResolutionMode: EmptyTargetResolutionMode?

        public init(accountTargeting: AccountTargeting? = nil, emptyTargetResolutionMode: EmptyTargetResolutionMode? = nil) {
            self.accountTargeting = accountTargeting
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }

        private enum CodingKeys: String, CodingKey {
            case accountTargeting = "accountTargeting"
            case emptyTargetResolutionMode = "emptyTargetResolutionMode"
        }
    }

    public struct ExperimentTemplateLogConfiguration: AWSDecodableShape {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public let cloudWatchLogsConfiguration: ExperimentTemplateCloudWatchLogsLogConfiguration?
        /// The schema version.
        public let logSchemaVersion: Int?
        /// The configuration for experiment logging to Amazon S3.
        public let s3Configuration: ExperimentTemplateS3LogConfiguration?

        public init(cloudWatchLogsConfiguration: ExperimentTemplateCloudWatchLogsLogConfiguration? = nil, logSchemaVersion: Int? = nil, s3Configuration: ExperimentTemplateS3LogConfiguration? = nil) {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsConfiguration = "cloudWatchLogsConfiguration"
            case logSchemaVersion = "logSchemaVersion"
            case s3Configuration = "s3Configuration"
        }
    }

    public struct ExperimentTemplateS3LogConfiguration: AWSDecodableShape {
        /// The name of the destination bucket.
        public let bucketName: String?
        /// The bucket prefix.
        public let prefix: String?

        public init(bucketName: String? = nil, prefix: String? = nil) {
            self.bucketName = bucketName
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case prefix = "prefix"
        }
    }

    public struct ExperimentTemplateS3LogConfigurationInput: AWSEncodableShape {
        /// The name of the destination bucket.
        public let bucketName: String
        /// The bucket prefix.
        public let prefix: String?

        public init(bucketName: String, prefix: String? = nil) {
            self.bucketName = bucketName
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 1024)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.prefix, name: "prefix", parent: name, pattern: "^[\\s\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case prefix = "prefix"
        }
    }

    public struct ExperimentTemplateStopCondition: AWSDecodableShape {
        /// The source for the stop condition.
        public let source: String?
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm, if applicable.
        public let value: String?

        public init(source: String? = nil, value: String? = nil) {
            self.source = source
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case value = "value"
        }
    }

    public struct ExperimentTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the experiment template.
        public let arn: String?
        /// The time that the experiment template was created.
        public let creationTime: Date?
        /// The description of the experiment template.
        public let description: String?
        /// The ID of the experiment template.
        public let id: String?
        /// The time that the experiment template was last updated.
        public let lastUpdateTime: Date?
        /// The tags for the experiment template.
        public let tags: [String: String]?

        public init(arn: String? = nil, creationTime: Date? = nil, description: String? = nil, id: String? = nil, lastUpdateTime: Date? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case creationTime = "creationTime"
            case description = "description"
            case id = "id"
            case lastUpdateTime = "lastUpdateTime"
            case tags = "tags"
        }
    }

    public struct ExperimentTemplateTarget: AWSDecodableShape {
        /// The filters to apply to identify target resources using specific attributes.
        public let filters: [ExperimentTemplateTargetFilter]?
        /// The resource type parameters.
        public let parameters: [String: String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public let resourceArns: [String]?
        /// The tags for the target resources.
        public let resourceTags: [String: String]?
        /// The resource type.
        public let resourceType: String?
        /// Scopes the identified resources to a specific count or percentage.
        public let selectionMode: String?

        public init(filters: [ExperimentTemplateTargetFilter]? = nil, parameters: [String: String]? = nil, resourceArns: [String]? = nil, resourceTags: [String: String]? = nil, resourceType: String? = nil, selectionMode: String? = nil) {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case parameters = "parameters"
            case resourceArns = "resourceArns"
            case resourceTags = "resourceTags"
            case resourceType = "resourceType"
            case selectionMode = "selectionMode"
        }
    }

    public struct ExperimentTemplateTargetFilter: AWSDecodableShape {
        /// The attribute path for the filter.
        public let path: String?
        /// The attribute values for the filter.
        public let values: [String]?

        public init(path: String? = nil, values: [String]? = nil) {
            self.path = path
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
            case values = "values"
        }
    }

    public struct ExperimentTemplateTargetInputFilter: AWSEncodableShape {
        /// The attribute path for the filter.
        public let path: String
        /// The attribute values for the filter.
        public let values: [String]

        public init(path: String, values: [String]) {
            self.path = path
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.path, name: "path", parent: name, max: 256)
            try self.validate(self.path, name: "path", parent: name, pattern: "^[\\S]+$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
                try validate($0, name: "values[]", parent: name, pattern: "^[\\S]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case path = "path"
            case values = "values"
        }
    }

    public struct GetActionRequest: AWSEncodableShape {
        /// The ID of the action.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 128)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetActionResponse: AWSDecodableShape {
        /// Information about the action.
        public let action: Action?

        public init(action: Action? = nil) {
            self.action = action
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
        }
    }

    public struct GetExperimentRequest: AWSEncodableShape {
        /// The ID of the experiment.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExperimentResponse: AWSDecodableShape {
        /// Information about the experiment.
        public let experiment: Experiment?

        public init(experiment: Experiment? = nil) {
            self.experiment = experiment
        }

        private enum CodingKeys: String, CodingKey {
            case experiment = "experiment"
        }
    }

    public struct GetExperimentTargetAccountConfigurationRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String
        /// The ID of the experiment.
        public let experimentId: String

        public init(accountId: String, experimentId: String) {
            self.accountId = accountId
            self.experimentId = experimentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.experimentId, key: "experimentId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 48)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.experimentId, name: "experimentId", parent: name, max: 64)
            try self.validate(self.experimentId, name: "experimentId", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExperimentTargetAccountConfigurationResponse: AWSDecodableShape {
        /// Information about the target account configuration.
        public let targetAccountConfiguration: ExperimentTargetAccountConfiguration?

        public init(targetAccountConfiguration: ExperimentTargetAccountConfiguration? = nil) {
            self.targetAccountConfiguration = targetAccountConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case targetAccountConfiguration = "targetAccountConfiguration"
        }
    }

    public struct GetExperimentTemplateRequest: AWSEncodableShape {
        /// The ID of the experiment template.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExperimentTemplateResponse: AWSDecodableShape {
        /// Information about the experiment template.
        public let experimentTemplate: ExperimentTemplate?

        public init(experimentTemplate: ExperimentTemplate? = nil) {
            self.experimentTemplate = experimentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case experimentTemplate = "experimentTemplate"
        }
    }

    public struct GetTargetAccountConfigurationRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String
        /// The ID of the experiment template.
        public let experimentTemplateId: String

        public init(accountId: String, experimentTemplateId: String) {
            self.accountId = accountId
            self.experimentTemplateId = experimentTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.experimentTemplateId, key: "experimentTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 48)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, max: 64)
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTargetAccountConfigurationResponse: AWSDecodableShape {
        /// Information about the target account configuration.
        public let targetAccountConfiguration: TargetAccountConfiguration?

        public init(targetAccountConfiguration: TargetAccountConfiguration? = nil) {
            self.targetAccountConfiguration = targetAccountConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case targetAccountConfiguration = "targetAccountConfiguration"
        }
    }

    public struct GetTargetResourceTypeRequest: AWSEncodableShape {
        /// The resource type.
        public let resourceType: String

        public init(resourceType: String) {
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 128)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTargetResourceTypeResponse: AWSDecodableShape {
        /// Information about the resource type.
        public let targetResourceType: TargetResourceType?

        public init(targetResourceType: TargetResourceType? = nil) {
            self.targetResourceType = targetResourceType
        }

        private enum CodingKeys: String, CodingKey {
            case targetResourceType = "targetResourceType"
        }
    }

    public struct ListActionsRequest: AWSEncodableShape {
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListActionsResponse: AWSDecodableShape {
        /// The actions.
        public let actions: [ActionSummary]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(actions: [ActionSummary]? = nil, nextToken: String? = nil) {
            self.actions = actions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case nextToken = "nextToken"
        }
    }

    public struct ListExperimentResolvedTargetsRequest: AWSEncodableShape {
        /// The ID of the experiment.
        public let experimentId: String
        /// The maximum number of results to return with a single call. To retrieve the remaining results,  make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?
        /// The name of the target.
        public let targetName: String?

        public init(experimentId: String, maxResults: Int? = nil, nextToken: String? = nil, targetName: String? = nil) {
            self.experimentId = experimentId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetName = targetName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.experimentId, key: "experimentId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.targetName, key: "targetName")
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentId, name: "experimentId", parent: name, max: 64)
            try self.validate(self.experimentId, name: "experimentId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.targetName, name: "targetName", parent: name, max: 64)
            try self.validate(self.targetName, name: "targetName", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExperimentResolvedTargetsResponse: AWSDecodableShape {
        /// The token to use to retrieve the next page of results.  This value is null when there are no more results to return.
        public let nextToken: String?
        /// The resolved targets.
        public let resolvedTargets: [ResolvedTarget]?

        public init(nextToken: String? = nil, resolvedTargets: [ResolvedTarget]? = nil) {
            self.nextToken = nextToken
            self.resolvedTargets = resolvedTargets
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case resolvedTargets = "resolvedTargets"
        }
    }

    public struct ListExperimentTargetAccountConfigurationsRequest: AWSEncodableShape {
        /// The ID of the experiment.
        public let experimentId: String
        /// The token for the next page of results.
        public let nextToken: String?

        public init(experimentId: String, nextToken: String? = nil) {
            self.experimentId = experimentId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.experimentId, key: "experimentId")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentId, name: "experimentId", parent: name, max: 64)
            try self.validate(self.experimentId, name: "experimentId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExperimentTargetAccountConfigurationsResponse: AWSDecodableShape {
        /// The token to use to retrieve the next page of results.  This value is null when there are no more results to return.
        public let nextToken: String?
        /// The target account configurations.
        public let targetAccountConfigurations: [ExperimentTargetAccountConfigurationSummary]?

        public init(nextToken: String? = nil, targetAccountConfigurations: [ExperimentTargetAccountConfigurationSummary]? = nil) {
            self.nextToken = nextToken
            self.targetAccountConfigurations = targetAccountConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case targetAccountConfigurations = "targetAccountConfigurations"
        }
    }

    public struct ListExperimentTemplatesRequest: AWSEncodableShape {
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExperimentTemplatesResponse: AWSDecodableShape {
        /// The experiment templates.
        public let experimentTemplates: [ExperimentTemplateSummary]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(experimentTemplates: [ExperimentTemplateSummary]? = nil, nextToken: String? = nil) {
            self.experimentTemplates = experimentTemplates
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case experimentTemplates = "experimentTemplates"
            case nextToken = "nextToken"
        }
    }

    public struct ListExperimentsRequest: AWSEncodableShape {
        /// The ID of the experiment template.
        public let experimentTemplateId: String?
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(experimentTemplateId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.experimentTemplateId = experimentTemplateId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.experimentTemplateId, key: "experimentTemplateId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, max: 64)
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExperimentsResponse: AWSDecodableShape {
        /// The experiments.
        public let experiments: [ExperimentSummary]?
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(experiments: [ExperimentSummary]? = nil, nextToken: String? = nil) {
            self.experiments = experiments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case experiments = "experiments"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTargetAccountConfigurationsRequest: AWSEncodableShape {
        /// The ID of the experiment template.
        public let experimentTemplateId: String
        /// The maximum number of results to return with a single call. To retrieve the remaining results,  make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(experimentTemplateId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.experimentTemplateId = experimentTemplateId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.experimentTemplateId, key: "experimentTemplateId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, max: 64)
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTargetAccountConfigurationsResponse: AWSDecodableShape {
        /// The token to use to retrieve the next page of results.  This value is null when there are no more results to return.
        public let nextToken: String?
        /// The target account configurations.
        public let targetAccountConfigurations: [TargetAccountConfigurationSummary]?

        public init(nextToken: String? = nil, targetAccountConfigurations: [TargetAccountConfigurationSummary]? = nil) {
            self.nextToken = nextToken
            self.targetAccountConfigurations = targetAccountConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case targetAccountConfigurations = "targetAccountConfigurations"
        }
    }

    public struct ListTargetResourceTypesRequest: AWSEncodableShape {
        /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value.
        public let maxResults: Int?
        /// The token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTargetResourceTypesResponse: AWSDecodableShape {
        /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?
        /// The target resource types.
        public let targetResourceTypes: [TargetResourceTypeSummary]?

        public init(nextToken: String? = nil, targetResourceTypes: [TargetResourceTypeSummary]? = nil) {
            self.nextToken = nextToken
            self.targetResourceTypes = targetResourceTypes
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case targetResourceTypes = "targetResourceTypes"
        }
    }

    public struct ResolvedTarget: AWSDecodableShape {
        /// The resource type of the target.
        public let resourceType: String?
        /// Information about the target.
        public let targetInformation: [String: String]?
        /// The name of the target.
        public let targetName: String?

        public init(resourceType: String? = nil, targetInformation: [String: String]? = nil, targetName: String? = nil) {
            self.resourceType = resourceType
            self.targetInformation = targetInformation
            self.targetName = targetName
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "resourceType"
            case targetInformation = "targetInformation"
            case targetName = "targetName"
        }
    }

    public struct StartExperimentExperimentOptionsInput: AWSEncodableShape {
        /// Specifies the actions mode for experiment options.
        public let actionsMode: ActionsMode?

        public init(actionsMode: ActionsMode? = nil) {
            self.actionsMode = actionsMode
        }

        private enum CodingKeys: String, CodingKey {
            case actionsMode = "actionsMode"
        }
    }

    public struct StartExperimentRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String
        /// The experiment options for running the experiment.
        public let experimentOptions: StartExperimentExperimentOptionsInput?
        /// The ID of the experiment template.
        public let experimentTemplateId: String
        /// The tags to apply to the experiment.
        public let tags: [String: String]?

        public init(clientToken: String = StartExperimentRequest.idempotencyToken(), experimentOptions: StartExperimentExperimentOptionsInput? = nil, experimentTemplateId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.experimentOptions = experimentOptions
            self.experimentTemplateId = experimentTemplateId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 1024)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, max: 64)
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, pattern: "^[\\S]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\s\\S]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case experimentOptions = "experimentOptions"
            case experimentTemplateId = "experimentTemplateId"
            case tags = "tags"
        }
    }

    public struct StartExperimentResponse: AWSDecodableShape {
        /// Information about the experiment.
        public let experiment: Experiment?

        public init(experiment: Experiment? = nil) {
            self.experiment = experiment
        }

        private enum CodingKeys: String, CodingKey {
            case experiment = "experiment"
        }
    }

    public struct StopExperimentRequest: AWSEncodableShape {
        /// The ID of the experiment.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopExperimentResponse: AWSDecodableShape {
        /// Information about the experiment.
        public let experiment: Experiment?

        public init(experiment: Experiment? = nil) {
            self.experiment = experiment
        }

        private enum CodingKeys: String, CodingKey {
            case experiment = "experiment"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags for the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\S]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^[\\s\\S]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TargetAccountConfiguration: AWSDecodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String?
        /// The description of the target account.
        public let description: String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public let roleArn: String?

        public init(accountId: String? = nil, description: String? = nil, roleArn: String? = nil) {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct TargetAccountConfigurationSummary: AWSDecodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String?
        /// The description of the target account.
        public let description: String?
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public let roleArn: String?

        public init(accountId: String? = nil, description: String? = nil, roleArn: String? = nil) {
            self.accountId = accountId
            self.description = description
            self.roleArn = roleArn
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct TargetResourceType: AWSDecodableShape {
        /// A description of the resource type.
        public let description: String?
        /// The parameters for the resource type.
        public let parameters: [String: TargetResourceTypeParameter]?
        /// The resource type.
        public let resourceType: String?

        public init(description: String? = nil, parameters: [String: TargetResourceTypeParameter]? = nil, resourceType: String? = nil) {
            self.description = description
            self.parameters = parameters
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case parameters = "parameters"
            case resourceType = "resourceType"
        }
    }

    public struct TargetResourceTypeParameter: AWSDecodableShape {
        /// A description of the parameter.
        public let description: String?
        /// Indicates whether the parameter is required.
        public let required: Bool?

        public init(description: String? = nil, required: Bool? = nil) {
            self.description = description
            self.required = required
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case required = "required"
        }
    }

    public struct TargetResourceTypeSummary: AWSDecodableShape {
        /// A description of the resource type.
        public let description: String?
        /// The resource type.
        public let resourceType: String?

        public init(description: String? = nil, resourceType: String? = nil) {
            self.description = description
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case resourceType = "resourceType"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys to remove.
        public let tagKeys: [String]?

        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[\\S]+$")
            try self.tagKeys?.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^[\\s\\S]+$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateExperimentTemplateActionInputItem: AWSEncodableShape {
        /// The ID of the action.
        public let actionId: String?
        /// A description for the action.
        public let description: String?
        /// The parameters for the action, if applicable.
        public let parameters: [String: String]?
        /// The name of the action that must be completed before the current action starts. Omit this parameter to run the action at the start of the experiment.
        public let startAfter: [String]?
        /// The targets for the action.
        public let targets: [String: String]?

        public init(actionId: String? = nil, description: String? = nil, parameters: [String: String]? = nil, startAfter: [String]? = nil, targets: [String: String]? = nil) {
            self.actionId = actionId
            self.description = description
            self.parameters = parameters
            self.startAfter = startAfter
            self.targets = targets
        }

        public func validate(name: String) throws {
            try self.validate(self.actionId, name: "actionId", parent: name, max: 128)
            try self.validate(self.actionId, name: "actionId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 64)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\S]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, pattern: "^[\\S]+$")
            }
            try self.startAfter?.forEach {
                try validate($0, name: "startAfter[]", parent: name, max: 64)
                try validate($0, name: "startAfter[]", parent: name, pattern: "^[\\S]+$")
            }
            try self.targets?.forEach {
                try validate($0.key, name: "targets.key", parent: name, max: 64)
                try validate($0.key, name: "targets.key", parent: name, pattern: "^[\\S]+$")
                try validate($0.value, name: "targets[\"\($0.key)\"]", parent: name, max: 64)
                try validate($0.value, name: "targets[\"\($0.key)\"]", parent: name, pattern: "^[\\S]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actionId = "actionId"
            case description = "description"
            case parameters = "parameters"
            case startAfter = "startAfter"
            case targets = "targets"
        }
    }

    public struct UpdateExperimentTemplateExperimentOptionsInput: AWSEncodableShape {
        /// The empty target resolution mode of the experiment template.
        public let emptyTargetResolutionMode: EmptyTargetResolutionMode?

        public init(emptyTargetResolutionMode: EmptyTargetResolutionMode? = nil) {
            self.emptyTargetResolutionMode = emptyTargetResolutionMode
        }

        private enum CodingKeys: String, CodingKey {
            case emptyTargetResolutionMode = "emptyTargetResolutionMode"
        }
    }

    public struct UpdateExperimentTemplateLogConfigurationInput: AWSEncodableShape {
        /// The configuration for experiment logging to Amazon CloudWatch Logs.
        public let cloudWatchLogsConfiguration: ExperimentTemplateCloudWatchLogsLogConfigurationInput?
        /// The schema version.
        public let logSchemaVersion: Int?
        /// The configuration for experiment logging to Amazon S3.
        public let s3Configuration: ExperimentTemplateS3LogConfigurationInput?

        public init(cloudWatchLogsConfiguration: ExperimentTemplateCloudWatchLogsLogConfigurationInput? = nil, logSchemaVersion: Int? = nil, s3Configuration: ExperimentTemplateS3LogConfigurationInput? = nil) {
            self.cloudWatchLogsConfiguration = cloudWatchLogsConfiguration
            self.logSchemaVersion = logSchemaVersion
            self.s3Configuration = s3Configuration
        }

        public func validate(name: String) throws {
            try self.cloudWatchLogsConfiguration?.validate(name: "\(name).cloudWatchLogsConfiguration")
            try self.s3Configuration?.validate(name: "\(name).s3Configuration")
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchLogsConfiguration = "cloudWatchLogsConfiguration"
            case logSchemaVersion = "logSchemaVersion"
            case s3Configuration = "s3Configuration"
        }
    }

    public struct UpdateExperimentTemplateRequest: AWSEncodableShape {
        /// The actions for the experiment.
        public let actions: [String: UpdateExperimentTemplateActionInputItem]?
        /// A description for the template.
        public let description: String?
        /// The experiment options for the experiment template.
        public let experimentOptions: UpdateExperimentTemplateExperimentOptionsInput?
        /// The ID of the experiment template.
        public let id: String
        /// The configuration for experiment logging.
        public let logConfiguration: UpdateExperimentTemplateLogConfigurationInput?
        /// The Amazon Resource Name (ARN) of an IAM role that grants the FIS service permission to perform service actions on your behalf.
        public let roleArn: String?
        /// The stop conditions for the experiment.
        public let stopConditions: [UpdateExperimentTemplateStopConditionInput]?
        /// The targets for the experiment.
        public let targets: [String: UpdateExperimentTemplateTargetInput]?

        public init(actions: [String: UpdateExperimentTemplateActionInputItem]? = nil, description: String? = nil, experimentOptions: UpdateExperimentTemplateExperimentOptionsInput? = nil, id: String, logConfiguration: UpdateExperimentTemplateLogConfigurationInput? = nil, roleArn: String? = nil, stopConditions: [UpdateExperimentTemplateStopConditionInput]? = nil, targets: [String: UpdateExperimentTemplateTargetInput]? = nil) {
            self.actions = actions
            self.description = description
            self.experimentOptions = experimentOptions
            self.id = id
            self.logConfiguration = logConfiguration
            self.roleArn = roleArn
            self.stopConditions = stopConditions
            self.targets = targets
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actions, forKey: .actions)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.experimentOptions, forKey: .experimentOptions)
            request.encodePath(self.id, key: "id")
            try container.encodeIfPresent(self.logConfiguration, forKey: .logConfiguration)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.stopConditions, forKey: .stopConditions)
            try container.encodeIfPresent(self.targets, forKey: .targets)
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try validate($0.key, name: "actions.key", parent: name, max: 64)
                try validate($0.key, name: "actions.key", parent: name, pattern: "^[\\S]+$")
                try $0.value.validate(name: "\(name).actions[\"\($0.key)\"]")
            }
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]+$")
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[\\S]+$")
            try self.logConfiguration?.validate(name: "\(name).logConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[\\S]+$")
            try self.stopConditions?.forEach {
                try $0.validate(name: "\(name).stopConditions[]")
            }
            try self.targets?.forEach {
                try validate($0.key, name: "targets.key", parent: name, max: 64)
                try validate($0.key, name: "targets.key", parent: name, pattern: "^[\\S]+$")
                try $0.value.validate(name: "\(name).targets[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case description = "description"
            case experimentOptions = "experimentOptions"
            case logConfiguration = "logConfiguration"
            case roleArn = "roleArn"
            case stopConditions = "stopConditions"
            case targets = "targets"
        }
    }

    public struct UpdateExperimentTemplateResponse: AWSDecodableShape {
        /// Information about the experiment template.
        public let experimentTemplate: ExperimentTemplate?

        public init(experimentTemplate: ExperimentTemplate? = nil) {
            self.experimentTemplate = experimentTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case experimentTemplate = "experimentTemplate"
        }
    }

    public struct UpdateExperimentTemplateStopConditionInput: AWSEncodableShape {
        /// The source for the stop condition. Specify aws:cloudwatch:alarm if the stop condition is defined by a CloudWatch alarm. Specify none if there is no stop condition.
        public let source: String
        /// The Amazon Resource Name (ARN) of the CloudWatch alarm.
        public let value: String?

        public init(source: String, value: String? = nil) {
            self.source = source
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.source, name: "source", parent: name, max: 64)
            try self.validate(self.source, name: "source", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.value, name: "value", parent: name, max: 2048)
            try self.validate(self.value, name: "value", parent: name, min: 20)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[\\s\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case source = "source"
            case value = "value"
        }
    }

    public struct UpdateExperimentTemplateTargetInput: AWSEncodableShape {
        /// The filters to apply to identify target resources using specific attributes.
        public let filters: [ExperimentTemplateTargetInputFilter]?
        /// The resource type parameters.
        public let parameters: [String: String]?
        /// The Amazon Resource Names (ARNs) of the targets.
        public let resourceArns: [String]?
        /// The tags for the target resources.
        public let resourceTags: [String: String]?
        /// The resource type. The resource type must be supported for the specified action.
        public let resourceType: String
        /// Scopes the identified resources to a specific count or percentage.
        public let selectionMode: String

        public init(filters: [ExperimentTemplateTargetInputFilter]? = nil, parameters: [String: String]? = nil, resourceArns: [String]? = nil, resourceTags: [String: String]? = nil, resourceType: String, selectionMode: String) {
            self.filters = filters
            self.parameters = parameters
            self.resourceArns = resourceArns
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.selectionMode = selectionMode
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 64)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[\\S]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 1)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, pattern: "^[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]+$")
            }
            try self.resourceArns?.forEach {
                try validate($0, name: "resourceArns[]", parent: name, max: 2048)
                try validate($0, name: "resourceArns[]", parent: name, min: 20)
                try validate($0, name: "resourceArns[]", parent: name, pattern: "^[\\S]+$")
            }
            try self.validate(self.resourceArns, name: "resourceArns", parent: name, max: 5)
            try self.resourceTags?.forEach {
                try validate($0.key, name: "resourceTags.key", parent: name, max: 128)
                try validate($0.key, name: "resourceTags.key", parent: name, pattern: "^[\\s\\S]+$")
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "resourceTags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*$")
            }
            try self.validate(self.resourceTags, name: "resourceTags", parent: name, max: 50)
            try self.validate(self.resourceType, name: "resourceType", parent: name, max: 128)
            try self.validate(self.resourceType, name: "resourceType", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.selectionMode, name: "selectionMode", parent: name, max: 64)
            try self.validate(self.selectionMode, name: "selectionMode", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case parameters = "parameters"
            case resourceArns = "resourceArns"
            case resourceTags = "resourceTags"
            case resourceType = "resourceType"
            case selectionMode = "selectionMode"
        }
    }

    public struct UpdateTargetAccountConfigurationRequest: AWSEncodableShape {
        /// The Amazon Web Services account ID of the target account.
        public let accountId: String
        /// The description of the target account.
        public let description: String?
        /// The ID of the experiment template.
        public let experimentTemplateId: String
        /// The Amazon Resource Name (ARN) of an IAM role for the target account.
        public let roleArn: String?

        public init(accountId: String, description: String? = nil, experimentTemplateId: String, roleArn: String? = nil) {
            self.accountId = accountId
            self.description = description
            self.experimentTemplateId = experimentTemplateId
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.experimentTemplateId, key: "experimentTemplateId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 48)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.description, name: "description", parent: name, max: 512)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, max: 64)
            try self.validate(self.experimentTemplateId, name: "experimentTemplateId", parent: name, pattern: "^[\\S]+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateTargetAccountConfigurationResponse: AWSDecodableShape {
        /// Information about the target account configuration.
        public let targetAccountConfiguration: TargetAccountConfiguration?

        public init(targetAccountConfiguration: TargetAccountConfiguration? = nil) {
            self.targetAccountConfiguration = targetAccountConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case targetAccountConfiguration = "targetAccountConfiguration"
        }
    }
}

// MARK: - Errors

/// Error enum for FIS
public struct FISErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize FIS
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request could not be processed because of a conflict.
    public static var conflictException: Self { .init(.conflictException) }
    /// The specified resource cannot be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded your service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The specified input is not valid, or fails to satisfy the constraints for the request.
    public static var validationException: Self { .init(.validationException) }
}

extension FISErrorType: Equatable {
    public static func == (lhs: FISErrorType, rhs: FISErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension FISErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
