//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension OpenSearchServerless {
    // MARK: Enums

    public enum AccessPolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// data policy type
        case data = "data"
        public var description: String { return self.rawValue }
    }

    public enum CollectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Collection resource is ready to use
        case active = "ACTIVE"
        /// Creating collection resource
        case creating = "CREATING"
        /// Deleting collection resource
        case deleting = "DELETING"
        /// Collection resource create or delete failed
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum CollectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Search collection type
        case search = "SEARCH"
        /// Timeseries collection type
        case timeseries = "TIMESERIES"
        /// Vectorsearch collection type
        case vectorsearch = "VECTORSEARCH"
        public var description: String { return self.rawValue }
    }

    public enum IamIdentityCenterGroupAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Group ID
        case groupId = "GroupId"
        /// Group Name
        case groupName = "GroupName"
        public var description: String { return self.rawValue }
    }

    public enum IamIdentityCenterUserAttribute: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Email
        case email = "Email"
        /// User ID
        case userId = "UserId"
        /// User Name
        case userName = "UserName"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// retention policy type
        case retention = "retention"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// index resource type
        case index = "index"
        public var description: String { return self.rawValue }
    }

    public enum SecurityConfigType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// iam identity center
        case iamidentitycenter = "iamidentitycenter"
        /// saml provider
        case saml = "saml"
        public var description: String { return self.rawValue }
    }

    public enum SecurityPolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// encryption policy type
        case encryption = "encryption"
        /// network policy type
        case network = "network"
        public var description: String { return self.rawValue }
    }

    public enum StandbyReplicas: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Standby replicas disabled
        case disabled = "DISABLED"
        /// Standby replicas enabled
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum VpcEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// VPCEndpoint resource is ready to use
        case active = "ACTIVE"
        /// Deleting VPCEndpoint resource
        case deleting = "DELETING"
        /// VPCEndpoint resource create or delete failed
        case failed = "FAILED"
        /// Pending VPCEndpoint resource
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPolicyDetail: AWSDecodableShape {
        /// The date the policy was created.
        public let createdDate: Int64?
        /// The description of the policy.
        public let description: String?
        /// The timestamp of when the policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the policy.
        public let name: String?
        /// The JSON policy document without any whitespaces.
        public let policy: AWSDocument?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of access policy.
        public let type: AccessPolicyType?

        @inlinable
        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policy: AWSDocument? = nil, policyVersion: String? = nil, type: AccessPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct AccessPolicyStats: AWSDecodableShape {
        /// The number of data access policies in the current account.
        public let dataPolicyCount: Int64?

        @inlinable
        public init(dataPolicyCount: Int64? = nil) {
            self.dataPolicyCount = dataPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case dataPolicyCount = "DataPolicyCount"
        }
    }

    public struct AccessPolicySummary: AWSDecodableShape {
        /// The Epoch time when the access policy was created.
        public let createdDate: Int64?
        /// The description of the access policy.
        public let description: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the access policy.
        public let name: String?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of access policy. Currently, the only available type is data.
        public let type: AccessPolicyType?

        @inlinable
        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policyVersion: String? = nil, type: AccessPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct AccountSettingsDetail: AWSDecodableShape {
        public let capacityLimits: CapacityLimits?

        @inlinable
        public init(capacityLimits: CapacityLimits? = nil) {
            self.capacityLimits = capacityLimits
        }

        private enum CodingKeys: String, CodingKey {
            case capacityLimits = "capacityLimits"
        }
    }

    public struct BatchGetCollectionRequest: AWSEncodableShape {
        /// A list of collection IDs. You can't provide names and IDs in the same request. The ID is part of the collection endpoint. You can also retrieve it using the ListCollections API.
        public let ids: [String]?
        /// A list of collection names. You can't provide names and IDs in the same request.
        public let names: [String]?

        @inlinable
        public init(ids: [String]? = nil, names: [String]? = nil) {
            self.ids = ids
            self.names = names
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 40)
                try validate($0, name: "ids[]", parent: name, min: 3)
                try validate($0, name: "ids[]", parent: name, pattern: "^[a-z0-9]{3,40}$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 100)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, max: 32)
                try validate($0, name: "names[]", parent: name, min: 3)
                try validate($0, name: "names[]", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 100)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
            case names = "names"
        }
    }

    public struct BatchGetCollectionResponse: AWSDecodableShape {
        /// Details about each collection.
        public let collectionDetails: [CollectionDetail]?
        /// Error information for the request.
        public let collectionErrorDetails: [CollectionErrorDetail]?

        @inlinable
        public init(collectionDetails: [CollectionDetail]? = nil, collectionErrorDetails: [CollectionErrorDetail]? = nil) {
            self.collectionDetails = collectionDetails
            self.collectionErrorDetails = collectionErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case collectionDetails = "collectionDetails"
            case collectionErrorDetails = "collectionErrorDetails"
        }
    }

    public struct BatchGetEffectiveLifecyclePolicyRequest: AWSEncodableShape {
        /// The unique identifiers of policy types and resource names.
        public let resourceIdentifiers: [LifecyclePolicyResourceIdentifier]

        @inlinable
        public init(resourceIdentifiers: [LifecyclePolicyResourceIdentifier]) {
            self.resourceIdentifiers = resourceIdentifiers
        }

        public func validate(name: String) throws {
            try self.resourceIdentifiers.forEach {
                try $0.validate(name: "\(name).resourceIdentifiers[]")
            }
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, max: 100)
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIdentifiers = "resourceIdentifiers"
        }
    }

    public struct BatchGetEffectiveLifecyclePolicyResponse: AWSDecodableShape {
        /// A list of lifecycle policies applied to the OpenSearch Serverless indexes.
        public let effectiveLifecyclePolicyDetails: [EffectiveLifecyclePolicyDetail]?
        /// A list of resources for which retrieval failed.
        public let effectiveLifecyclePolicyErrorDetails: [EffectiveLifecyclePolicyErrorDetail]?

        @inlinable
        public init(effectiveLifecyclePolicyDetails: [EffectiveLifecyclePolicyDetail]? = nil, effectiveLifecyclePolicyErrorDetails: [EffectiveLifecyclePolicyErrorDetail]? = nil) {
            self.effectiveLifecyclePolicyDetails = effectiveLifecyclePolicyDetails
            self.effectiveLifecyclePolicyErrorDetails = effectiveLifecyclePolicyErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveLifecyclePolicyDetails = "effectiveLifecyclePolicyDetails"
            case effectiveLifecyclePolicyErrorDetails = "effectiveLifecyclePolicyErrorDetails"
        }
    }

    public struct BatchGetLifecyclePolicyRequest: AWSEncodableShape {
        /// The unique identifiers of policy types and policy names.
        public let identifiers: [LifecyclePolicyIdentifier]

        @inlinable
        public init(identifiers: [LifecyclePolicyIdentifier]) {
            self.identifiers = identifiers
        }

        public func validate(name: String) throws {
            try self.identifiers.forEach {
                try $0.validate(name: "\(name).identifiers[]")
            }
            try self.validate(self.identifiers, name: "identifiers", parent: name, max: 40)
            try self.validate(self.identifiers, name: "identifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identifiers = "identifiers"
        }
    }

    public struct BatchGetLifecyclePolicyResponse: AWSDecodableShape {
        /// A list of lifecycle policies matched to the input policy name and policy type.
        public let lifecyclePolicyDetails: [LifecyclePolicyDetail]?
        /// A list of lifecycle policy names and policy types for which retrieval failed.
        public let lifecyclePolicyErrorDetails: [LifecyclePolicyErrorDetail]?

        @inlinable
        public init(lifecyclePolicyDetails: [LifecyclePolicyDetail]? = nil, lifecyclePolicyErrorDetails: [LifecyclePolicyErrorDetail]? = nil) {
            self.lifecyclePolicyDetails = lifecyclePolicyDetails
            self.lifecyclePolicyErrorDetails = lifecyclePolicyErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyDetails = "lifecyclePolicyDetails"
            case lifecyclePolicyErrorDetails = "lifecyclePolicyErrorDetails"
        }
    }

    public struct BatchGetVpcEndpointRequest: AWSEncodableShape {
        /// A list of VPC endpoint identifiers.
        public let ids: [String]

        @inlinable
        public init(ids: [String]) {
            self.ids = ids
        }

        public func validate(name: String) throws {
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 255)
                try validate($0, name: "ids[]", parent: name, min: 1)
                try validate($0, name: "ids[]", parent: name, pattern: "^vpce-[0-9a-z]*$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 100)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
        }
    }

    public struct BatchGetVpcEndpointResponse: AWSDecodableShape {
        /// Details about the specified VPC endpoint.
        public let vpcEndpointDetails: [VpcEndpointDetail]?
        /// Error information for a failed request.
        public let vpcEndpointErrorDetails: [VpcEndpointErrorDetail]?

        @inlinable
        public init(vpcEndpointDetails: [VpcEndpointDetail]? = nil, vpcEndpointErrorDetails: [VpcEndpointErrorDetail]? = nil) {
            self.vpcEndpointDetails = vpcEndpointDetails
            self.vpcEndpointErrorDetails = vpcEndpointErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointDetails = "vpcEndpointDetails"
            case vpcEndpointErrorDetails = "vpcEndpointErrorDetails"
        }
    }

    public struct CapacityLimits: AWSEncodableShape & AWSDecodableShape {
        /// The maximum indexing capacity for collections.
        public let maxIndexingCapacityInOCU: Int?
        /// The maximum search capacity for collections.
        public let maxSearchCapacityInOCU: Int?

        @inlinable
        public init(maxIndexingCapacityInOCU: Int? = nil, maxSearchCapacityInOCU: Int? = nil) {
            self.maxIndexingCapacityInOCU = maxIndexingCapacityInOCU
            self.maxSearchCapacityInOCU = maxSearchCapacityInOCU
        }

        public func validate(name: String) throws {
            try self.validate(self.maxIndexingCapacityInOCU, name: "maxIndexingCapacityInOCU", parent: name, min: 2)
            try self.validate(self.maxSearchCapacityInOCU, name: "maxSearchCapacityInOCU", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maxIndexingCapacityInOCU = "maxIndexingCapacityInOCU"
            case maxSearchCapacityInOCU = "maxSearchCapacityInOCU"
        }
    }

    public struct CollectionDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// Collection-specific endpoint used to submit index, search, and data upload requests to an OpenSearch Serverless collection.
        public let collectionEndpoint: String?
        /// The Epoch time when the collection was created.
        public let createdDate: Int64?
        /// Collection-specific endpoint used to access OpenSearch Dashboards.
        public let dashboardEndpoint: String?
        /// A description of the collection.
        public let description: String?
        /// A failure code associated with the request.
        public let failureCode: String?
        /// A message associated with the failure code.
        public let failureMessage: String?
        /// A unique identifier for the collection.
        public let id: String?
        /// The ARN of the Amazon Web Services KMS key used to encrypt the collection.
        public let kmsKeyArn: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the collection.
        public let name: String?
        /// Details about an OpenSearch Serverless collection.
        public let standbyReplicas: StandbyReplicas?
        /// The current status of the collection.
        public let status: CollectionStatus?
        /// The type of collection.
        public let type: CollectionType?

        @inlinable
        public init(arn: String? = nil, collectionEndpoint: String? = nil, createdDate: Int64? = nil, dashboardEndpoint: String? = nil, description: String? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, kmsKeyArn: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, standbyReplicas: StandbyReplicas? = nil, status: CollectionStatus? = nil, type: CollectionType? = nil) {
            self.arn = arn
            self.collectionEndpoint = collectionEndpoint
            self.createdDate = createdDate
            self.dashboardEndpoint = dashboardEndpoint
            self.description = description
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collectionEndpoint = "collectionEndpoint"
            case createdDate = "createdDate"
            case dashboardEndpoint = "dashboardEndpoint"
            case description = "description"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case kmsKeyArn = "kmsKeyArn"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case standbyReplicas = "standbyReplicas"
            case status = "status"
            case type = "type"
        }
    }

    public struct CollectionErrorDetail: AWSDecodableShape {
        /// The error code for the request. For example, NOT_FOUND.
        public let errorCode: String?
        /// A description of the error. For example, The specified Collection is not found.
        public let errorMessage: String?
        /// If the request contains collection IDs, the response includes the IDs provided in the request.
        public let id: String?
        /// If the request contains collection names, the response includes the names provided in the request.
        public let name: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, id: String? = nil, name: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
            case name = "name"
        }
    }

    public struct CollectionFilters: AWSEncodableShape {
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?

        @inlinable
        public init(name: String? = nil, status: CollectionStatus? = nil) {
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
        }
    }

    public struct CollectionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// The unique identifier of the collection.
        public let id: String?
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil, status: CollectionStatus? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateAccessPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the policy.
        public let policy: String
        /// The type of policy.
        public let type: AccessPolicyType

        @inlinable
        public init(clientToken: String? = CreateAccessPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String, type: AccessPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case type = "type"
        }
    }

    public struct CreateAccessPolicyResponse: AWSDecodableShape {
        /// Details about the created access policy.
        public let accessPolicyDetail: AccessPolicyDetail?

        @inlinable
        public init(accessPolicyDetail: AccessPolicyDetail? = nil) {
            self.accessPolicyDetail = accessPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyDetail = "accessPolicyDetail"
        }
    }

    public struct CreateCollectionDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// The Epoch time when the collection was created.
        public let createdDate: Int64?
        /// A description of the collection.
        public let description: String?
        /// The unique identifier of the collection.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the collection.
        public let kmsKeyArn: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the collection.
        public let name: String?
        /// Creates details about an OpenSearch Serverless collection.
        public let standbyReplicas: StandbyReplicas?
        /// The current status of the collection.
        public let status: CollectionStatus?
        /// The type of collection.
        public let type: CollectionType?

        @inlinable
        public init(arn: String? = nil, createdDate: Int64? = nil, description: String? = nil, id: String? = nil, kmsKeyArn: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, standbyReplicas: StandbyReplicas? = nil, status: CollectionStatus? = nil, type: CollectionType? = nil) {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdDate = "createdDate"
            case description = "description"
            case id = "id"
            case kmsKeyArn = "kmsKeyArn"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case standbyReplicas = "standbyReplicas"
            case status = "status"
            case type = "type"
        }
    }

    public struct CreateCollectionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// Description of the collection.
        public let description: String?
        /// Name of the collection.
        public let name: String
        /// Indicates whether standby replicas should be used for a collection.
        public let standbyReplicas: StandbyReplicas?
        /// An arbitrary set of tags (keyâ€“value pairs) to associate with the OpenSearch Serverless collection.
        public let tags: [Tag]?
        /// The type of collection.
        public let type: CollectionType?

        @inlinable
        public init(clientToken: String? = CreateCollectionRequest.idempotencyToken(), description: String? = nil, name: String, standbyReplicas: StandbyReplicas? = nil, tags: [Tag]? = nil, type: CollectionType? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case standbyReplicas = "standbyReplicas"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateCollectionResponse: AWSDecodableShape {
        /// Details about the collection.
        public let createCollectionDetail: CreateCollectionDetail?

        @inlinable
        public init(createCollectionDetail: CreateCollectionDetail? = nil) {
            self.createCollectionDetail = createCollectionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case createCollectionDetail = "createCollectionDetail"
        }
    }

    public struct CreateIamIdentityCenterConfigOptions: AWSEncodableShape {
        /// The group attribute for this IAM Identity Center integration. Defaults to GroupId.
        public let groupAttribute: IamIdentityCenterGroupAttribute?
        /// The ARN of the IAM Identity Center instance used to integrate with OpenSearch Serverless.
        public let instanceArn: String
        /// The user attribute for this IAM Identity Center integration. Defaults to UserId.
        public let userAttribute: IamIdentityCenterUserAttribute?

        @inlinable
        public init(groupAttribute: IamIdentityCenterGroupAttribute? = nil, instanceArn: String, userAttribute: IamIdentityCenterUserAttribute? = nil) {
            self.groupAttribute = groupAttribute
            self.instanceArn = instanceArn
            self.userAttribute = userAttribute
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, max: 1224)
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, min: 10)
            try self.validate(self.instanceArn, name: "instanceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn|aws-iso|aws-iso-b):sso:::instance/(sso)?ins-[a-zA-Z0-9-.]{16}$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupAttribute = "groupAttribute"
            case instanceArn = "instanceArn"
            case userAttribute = "userAttribute"
        }
    }

    public struct CreateLifecyclePolicyRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the lifecycle policy.
        public let description: String?
        /// The name of the lifecycle policy.
        public let name: String
        /// The JSON policy document to use as the content for the lifecycle policy.
        public let policy: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        @inlinable
        public init(clientToken: String? = CreateLifecyclePolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String, type: LifecyclePolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case type = "type"
        }
    }

    public struct CreateLifecyclePolicyResponse: AWSDecodableShape {
        /// Details about the created lifecycle policy.
        public let lifecyclePolicyDetail: LifecyclePolicyDetail?

        @inlinable
        public init(lifecyclePolicyDetail: LifecyclePolicyDetail? = nil) {
            self.lifecyclePolicyDetail = lifecyclePolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyDetail = "lifecyclePolicyDetail"
        }
    }

    public struct CreateSecurityConfigRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the security configuration.
        public let description: String?
        /// Describes IAM Identity Center options in the form of a key-value map. This field is required if you specify iamidentitycenter for the type parameter.
        public let iamIdentityCenterOptions: CreateIamIdentityCenterConfigOptions?
        /// The name of the security configuration.
        public let name: String
        /// Describes SAML options in in the form of a key-value map. This field is required if you specify saml for the type parameter.
        public let samlOptions: SamlConfigOptions?
        /// The type of security configuration.
        public let type: SecurityConfigType

        @inlinable
        public init(clientToken: String? = CreateSecurityConfigRequest.idempotencyToken(), description: String? = nil, iamIdentityCenterOptions: CreateIamIdentityCenterConfigOptions? = nil, name: String, samlOptions: SamlConfigOptions? = nil, type: SecurityConfigType) {
            self.clientToken = clientToken
            self.description = description
            self.iamIdentityCenterOptions = iamIdentityCenterOptions
            self.name = name
            self.samlOptions = samlOptions
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.iamIdentityCenterOptions?.validate(name: "\(name).iamIdentityCenterOptions")
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.samlOptions?.validate(name: "\(name).samlOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case iamIdentityCenterOptions = "iamIdentityCenterOptions"
            case name = "name"
            case samlOptions = "samlOptions"
            case type = "type"
        }
    }

    public struct CreateSecurityConfigResponse: AWSDecodableShape {
        /// Details about the created security configuration.
        public let securityConfigDetail: SecurityConfigDetail?

        @inlinable
        public init(securityConfigDetail: SecurityConfigDetail? = nil) {
            self.securityConfigDetail = securityConfigDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfigDetail = "securityConfigDetail"
        }
    }

    public struct CreateSecurityPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the new policy.
        public let policy: String
        /// The type of security policy.
        public let type: SecurityPolicyType

        @inlinable
        public init(clientToken: String? = CreateSecurityPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String, type: SecurityPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case type = "type"
        }
    }

    public struct CreateSecurityPolicyResponse: AWSDecodableShape {
        /// Details about the created security policy.
        public let securityPolicyDetail: SecurityPolicyDetail?

        @inlinable
        public init(securityPolicyDetail: SecurityPolicyDetail? = nil) {
            self.securityPolicyDetail = securityPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityPolicyDetail = "securityPolicyDetail"
        }
    }

    public struct CreateVpcEndpointDetail: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The current status in the endpoint creation process.
        public let status: VpcEndpointStatus?

        @inlinable
        public init(id: String? = nil, name: String? = nil, status: VpcEndpointStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateVpcEndpointRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the interface endpoint.
        public let name: String
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let securityGroupIds: [String]?
        /// The ID of one or more subnets from which you'll access OpenSearch Serverless.
        public let subnetIds: [String]
        /// The ID of the VPC from which you'll access OpenSearch Serverless.
        public let vpcId: String

        @inlinable
        public init(clientToken: String? = CreateVpcEndpointRequest.idempotencyToken(), name: String, securityGroupIds: [String]? = nil, subnetIds: [String], vpcId: String) {
            self.clientToken = clientToken
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 6)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 255)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct CreateVpcEndpointResponse: AWSDecodableShape {
        /// Details about the created interface VPC endpoint.
        public let createVpcEndpointDetail: CreateVpcEndpointDetail?

        @inlinable
        public init(createVpcEndpointDetail: CreateVpcEndpointDetail? = nil) {
            self.createVpcEndpointDetail = createVpcEndpointDetail
        }

        private enum CodingKeys: String, CodingKey {
            case createVpcEndpointDetail = "createVpcEndpointDetail"
        }
    }

    public struct DeleteAccessPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the policy to delete.
        public let name: String
        /// The type of policy.
        public let type: AccessPolicyType

        @inlinable
        public init(clientToken: String? = DeleteAccessPolicyRequest.idempotencyToken(), name: String, type: AccessPolicyType) {
            self.clientToken = clientToken
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case type = "type"
        }
    }

    public struct DeleteAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCollectionDetail: AWSDecodableShape {
        /// The unique identifier of the collection.
        public let id: String?
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?

        @inlinable
        public init(id: String? = nil, name: String? = nil, status: CollectionStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteCollectionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the collection. For example, 1iu5usc406kd. The ID is part of the collection endpoint. You can also retrieve it using the ListCollections API.
        public let id: String

        @inlinable
        public init(clientToken: String? = DeleteCollectionRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 40)
            try self.validate(self.id, name: "id", parent: name, min: 3)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-z0-9]{3,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct DeleteCollectionResponse: AWSDecodableShape {
        /// Details of the deleted collection.
        public let deleteCollectionDetail: DeleteCollectionDetail?

        @inlinable
        public init(deleteCollectionDetail: DeleteCollectionDetail? = nil) {
            self.deleteCollectionDetail = deleteCollectionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case deleteCollectionDetail = "deleteCollectionDetail"
        }
    }

    public struct DeleteLifecyclePolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the policy to delete.
        public let name: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        @inlinable
        public init(clientToken: String? = DeleteLifecyclePolicyRequest.idempotencyToken(), name: String, type: LifecyclePolicyType) {
            self.clientToken = clientToken
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case type = "type"
        }
    }

    public struct DeleteLifecyclePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSecurityConfigRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The security configuration identifier. For SAML the ID will be saml/&lt;accountId&gt;/&lt;idpProviderName&gt;. For example, saml/123456789123/OKTADev.
        public let id: String

        @inlinable
        public init(clientToken: String? = DeleteSecurityConfigRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct DeleteSecurityConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSecurityPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the policy to delete.
        public let name: String
        /// The type of policy.
        public let type: SecurityPolicyType

        @inlinable
        public init(clientToken: String? = DeleteSecurityPolicyRequest.idempotencyToken(), name: String, type: SecurityPolicyType) {
            self.clientToken = clientToken
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case type = "type"
        }
    }

    public struct DeleteSecurityPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVpcEndpointDetail: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The current status of the endpoint deletion process.
        public let status: VpcEndpointStatus?

        @inlinable
        public init(id: String? = nil, name: String? = nil, status: VpcEndpointStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteVpcEndpointRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The VPC endpoint identifier.
        public let id: String

        @inlinable
        public init(clientToken: String? = DeleteVpcEndpointRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^vpce-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct DeleteVpcEndpointResponse: AWSDecodableShape {
        /// Details about the deleted endpoint.
        public let deleteVpcEndpointDetail: DeleteVpcEndpointDetail?

        @inlinable
        public init(deleteVpcEndpointDetail: DeleteVpcEndpointDetail? = nil) {
            self.deleteVpcEndpointDetail = deleteVpcEndpointDetail
        }

        private enum CodingKeys: String, CodingKey {
            case deleteVpcEndpointDetail = "deleteVpcEndpointDetail"
        }
    }

    public struct EffectiveLifecyclePolicyDetail: AWSDecodableShape {
        /// The minimum number of index retention days set. That is an optional param that will return as true if the minimum number of days or  hours is not set to a index resource.
        public let noMinRetentionPeriod: Bool?
        /// The name of the lifecycle policy.
        public let policyName: String?
        /// The name of the OpenSearch Serverless index resource.
        public let resource: String?
        /// The type of OpenSearch Serverless resource. Currently, the only supported resource is index.
        public let resourceType: ResourceType?
        /// The minimum number of index retention in days or hours. This is an optional parameter that will return only if itâ€™s set.
        public let retentionPeriod: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        @inlinable
        public init(noMinRetentionPeriod: Bool? = nil, policyName: String? = nil, resource: String? = nil, resourceType: ResourceType? = nil, retentionPeriod: String? = nil, type: LifecyclePolicyType? = nil) {
            self.noMinRetentionPeriod = noMinRetentionPeriod
            self.policyName = policyName
            self.resource = resource
            self.resourceType = resourceType
            self.retentionPeriod = retentionPeriod
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case noMinRetentionPeriod = "noMinRetentionPeriod"
            case policyName = "policyName"
            case resource = "resource"
            case resourceType = "resourceType"
            case retentionPeriod = "retentionPeriod"
            case type = "type"
        }
    }

    public struct EffectiveLifecyclePolicyErrorDetail: AWSDecodableShape {
        /// The error code for the request.
        public let errorCode: String?
        /// A description of the error. For example, The specified Index resource is not found.
        public let errorMessage: String?
        /// The name of OpenSearch Serverless index resource.
        public let resource: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, resource: String? = nil, type: LifecyclePolicyType? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resource = resource
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case resource = "resource"
            case type = "type"
        }
    }

    public struct GetAccessPolicyRequest: AWSEncodableShape {
        /// The name of the access policy.
        public let name: String
        /// Tye type of policy. Currently, the only supported value is data.
        public let type: AccessPolicyType

        @inlinable
        public init(name: String, type: AccessPolicyType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct GetAccessPolicyResponse: AWSDecodableShape {
        /// Details about the requested access policy.
        public let accessPolicyDetail: AccessPolicyDetail?

        @inlinable
        public init(accessPolicyDetail: AccessPolicyDetail? = nil) {
            self.accessPolicyDetail = accessPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyDetail = "accessPolicyDetail"
        }
    }

    public struct GetAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsResponse: AWSDecodableShape {
        /// OpenSearch Serverless-related details for the current account.
        public let accountSettingsDetail: AccountSettingsDetail?

        @inlinable
        public init(accountSettingsDetail: AccountSettingsDetail? = nil) {
            self.accountSettingsDetail = accountSettingsDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettingsDetail = "accountSettingsDetail"
        }
    }

    public struct GetPoliciesStatsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPoliciesStatsResponse: AWSDecodableShape {
        /// Information about the data access policies in your account.
        public let accessPolicyStats: AccessPolicyStats?
        /// Information about the lifecycle policies in your account.
        public let lifecyclePolicyStats: LifecyclePolicyStats?
        /// Information about the security configurations in your account.
        public let securityConfigStats: SecurityConfigStats?
        /// Information about the security policies in your account.
        public let securityPolicyStats: SecurityPolicyStats?
        /// The total number of OpenSearch Serverless security policies and configurations in your account.
        public let totalPolicyCount: Int64?

        @inlinable
        public init(accessPolicyStats: AccessPolicyStats? = nil, lifecyclePolicyStats: LifecyclePolicyStats? = nil, securityConfigStats: SecurityConfigStats? = nil, securityPolicyStats: SecurityPolicyStats? = nil, totalPolicyCount: Int64? = nil) {
            self.accessPolicyStats = accessPolicyStats
            self.lifecyclePolicyStats = lifecyclePolicyStats
            self.securityConfigStats = securityConfigStats
            self.securityPolicyStats = securityPolicyStats
            self.totalPolicyCount = totalPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyStats = "AccessPolicyStats"
            case lifecyclePolicyStats = "LifecyclePolicyStats"
            case securityConfigStats = "SecurityConfigStats"
            case securityPolicyStats = "SecurityPolicyStats"
            case totalPolicyCount = "TotalPolicyCount"
        }
    }

    public struct GetSecurityConfigRequest: AWSEncodableShape {
        /// The unique identifier of the security configuration.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct GetSecurityConfigResponse: AWSDecodableShape {
        /// Details of the requested security configuration.
        public let securityConfigDetail: SecurityConfigDetail?

        @inlinable
        public init(securityConfigDetail: SecurityConfigDetail? = nil) {
            self.securityConfigDetail = securityConfigDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfigDetail = "securityConfigDetail"
        }
    }

    public struct GetSecurityPolicyRequest: AWSEncodableShape {
        /// The name of the security policy.
        public let name: String
        /// The type of security policy.
        public let type: SecurityPolicyType

        @inlinable
        public init(name: String, type: SecurityPolicyType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct GetSecurityPolicyResponse: AWSDecodableShape {
        /// Details about the requested security policy.
        public let securityPolicyDetail: SecurityPolicyDetail?

        @inlinable
        public init(securityPolicyDetail: SecurityPolicyDetail? = nil) {
            self.securityPolicyDetail = securityPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityPolicyDetail = "securityPolicyDetail"
        }
    }

    public struct IamIdentityCenterConfigOptions: AWSDecodableShape {
        /// The ARN of the IAM Identity Center application used to integrate with OpenSearch Serverless.
        public let applicationArn: String?
        /// The description of the IAM Identity Center application used to integrate with OpenSearch Serverless.
        public let applicationDescription: String?
        /// The name of the IAM Identity Center application used to integrate with OpenSearch Serverless.
        public let applicationName: String?
        /// The group attribute for this IAM Identity Center integration. Defaults to GroupId.
        public let groupAttribute: IamIdentityCenterGroupAttribute?
        /// The ARN of the IAM Identity Center instance used to integrate with OpenSearch Serverless.
        public let instanceArn: String?
        /// The user attribute for this IAM Identity Center integration. Defaults to UserId
        public let userAttribute: IamIdentityCenterUserAttribute?

        @inlinable
        public init(applicationArn: String? = nil, applicationDescription: String? = nil, applicationName: String? = nil, groupAttribute: IamIdentityCenterGroupAttribute? = nil, instanceArn: String? = nil, userAttribute: IamIdentityCenterUserAttribute? = nil) {
            self.applicationArn = applicationArn
            self.applicationDescription = applicationDescription
            self.applicationName = applicationName
            self.groupAttribute = groupAttribute
            self.instanceArn = instanceArn
            self.userAttribute = userAttribute
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationDescription = "applicationDescription"
            case applicationName = "applicationName"
            case groupAttribute = "groupAttribute"
            case instanceArn = "instanceArn"
            case userAttribute = "userAttribute"
        }
    }

    public struct LifecyclePolicyDetail: AWSDecodableShape {
        /// The date the lifecycle policy was created.
        public let createdDate: Int64?
        /// The description of the lifecycle policy.
        public let description: String?
        /// The timestamp of when the lifecycle policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The JSON policy document without any whitespaces.
        public let policy: AWSDocument?
        /// The version of the lifecycle policy.
        public let policyVersion: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        @inlinable
        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policy: AWSDocument? = nil, policyVersion: String? = nil, type: LifecyclePolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct LifecyclePolicyErrorDetail: AWSDecodableShape {
        /// The error code for the request. For example, NOT_FOUND.
        public let errorCode: String?
        /// A description of the error. For example, The specified Lifecycle Policy is not found.
        public let errorMessage: String?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, name: String? = nil, type: LifecyclePolicyType? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case name = "name"
            case type = "type"
        }
    }

    public struct LifecyclePolicyIdentifier: AWSEncodableShape {
        /// The name of the lifecycle policy.
        public let name: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        @inlinable
        public init(name: String, type: LifecyclePolicyType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct LifecyclePolicyResourceIdentifier: AWSEncodableShape {
        /// The name of the OpenSearch Serverless ilndex resource.
        public let resource: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        @inlinable
        public init(resource: String, type: LifecyclePolicyType) {
            self.resource = resource
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^index/[a-z][a-z0-9-]{3,32}/([a-z;0-9&$%][+.~=\\-_a-z;0-9&$%]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
            case type = "type"
        }
    }

    public struct LifecyclePolicyStats: AWSDecodableShape {
        /// The number of retention lifecycle policies in the current account.
        public let retentionPolicyCount: Int64?

        @inlinable
        public init(retentionPolicyCount: Int64? = nil) {
            self.retentionPolicyCount = retentionPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case retentionPolicyCount = "RetentionPolicyCount"
        }
    }

    public struct LifecyclePolicySummary: AWSDecodableShape {
        /// The Epoch time when the lifecycle policy was created.
        public let createdDate: Int64?
        /// The description of the lifecycle policy.
        public let description: String?
        /// The date and time when the lifecycle policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The version of the lifecycle policy.
        public let policyVersion: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        @inlinable
        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policyVersion: String? = nil, type: LifecyclePolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct ListAccessPoliciesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListAccessPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListAccessPolicies operations, which returns results in the next page.
        public let nextToken: String?
        /// Resource filters (can be collections or indexes) that policies can apply to.
        public let resource: [String]?
        /// The type of access policy.
        public let type: AccessPolicyType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resource: [String]? = nil, type: AccessPolicyType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resource = resource
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resource = "resource"
            case type = "type"
        }
    }

    public struct ListAccessPoliciesResponse: AWSDecodableShape {
        /// Details about the requested access policies.
        public let accessPolicySummaries: [AccessPolicySummary]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(accessPolicySummaries: [AccessPolicySummary]? = nil, nextToken: String? = nil) {
            self.accessPolicySummaries = accessPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicySummaries = "accessPolicySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollectionsRequest: AWSEncodableShape {
        ///  A list of filter names and values that you can use for requests.
        public let collectionFilters: CollectionFilters?
        /// The maximum number of results to return. Default is 20. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListCollections operation returns a nextToken, you can include the returned nextToken in subsequent ListCollections operations, which returns results in the next page.
        public let nextToken: String?

        @inlinable
        public init(collectionFilters: CollectionFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collectionFilters = collectionFilters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.collectionFilters?.validate(name: "\(name).collectionFilters")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionFilters = "collectionFilters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollectionsResponse: AWSDecodableShape {
        /// Details about each collection.
        public let collectionSummaries: [CollectionSummary]?
        /// When nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(collectionSummaries: [CollectionSummary]? = nil, nextToken: String? = nil) {
            self.collectionSummaries = collectionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collectionSummaries = "collectionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListLifecyclePoliciesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use use nextToken to get the next page of results. The default is 10.
        public let maxResults: Int?
        /// If your initial ListLifecyclePolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListLifecyclePolicies operations, which returns results in the next page.
        public let nextToken: String?
        /// Resource filters that policies can apply to. Currently, the only supported resource type is index.
        public let resources: [String]?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resources: [String]? = nil, type: LifecyclePolicyType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resources = resources
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resources = "resources"
            case type = "type"
        }
    }

    public struct ListLifecyclePoliciesResponse: AWSDecodableShape {
        /// Details about the requested lifecycle policies.
        public let lifecyclePolicySummaries: [LifecyclePolicySummary]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(lifecyclePolicySummaries: [LifecyclePolicySummary]? = nil, nextToken: String? = nil) {
            self.lifecyclePolicySummaries = lifecyclePolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicySummaries = "lifecyclePolicySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListSecurityConfigsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListSecurityConfigs operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityConfigs operations, which returns results in the next page.
        public let nextToken: String?
        /// The type of security configuration.
        public let type: SecurityConfigType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, type: SecurityConfigType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case type = "type"
        }
    }

    public struct ListSecurityConfigsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// Details about the security configurations in your account.
        public let securityConfigSummaries: [SecurityConfigSummary]?

        @inlinable
        public init(nextToken: String? = nil, securityConfigSummaries: [SecurityConfigSummary]? = nil) {
            self.nextToken = nextToken
            self.securityConfigSummaries = securityConfigSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case securityConfigSummaries = "securityConfigSummaries"
        }
    }

    public struct ListSecurityPoliciesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListSecurityPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityPolicies operations, which returns results in the next page.
        public let nextToken: String?
        /// Resource filters (can be collection or indexes) that policies can apply to.
        public let resource: [String]?
        /// The type of policy.
        public let type: SecurityPolicyType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resource: [String]? = nil, type: SecurityPolicyType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resource = resource
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resource = "resource"
            case type = "type"
        }
    }

    public struct ListSecurityPoliciesResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// Details about the security policies in your account.
        public let securityPolicySummaries: [SecurityPolicySummary]?

        @inlinable
        public init(nextToken: String? = nil, securityPolicySummaries: [SecurityPolicySummary]? = nil) {
            self.nextToken = nextToken
            self.securityPolicySummaries = securityPolicySummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case securityPolicySummaries = "securityPolicySummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListVpcEndpointsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListVpcEndpoints operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpoints operations, which returns results in the next page.
        public let nextToken: String?
        /// Filter the results according to the current status of the VPC endpoint. Possible statuses are CREATING, DELETING, UPDATING, ACTIVE, and FAILED.
        public let vpcEndpointFilters: VpcEndpointFilters?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, vpcEndpointFilters: VpcEndpointFilters? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vpcEndpointFilters = vpcEndpointFilters
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case vpcEndpointFilters = "vpcEndpointFilters"
        }
    }

    public struct ListVpcEndpointsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// Details about each VPC endpoint, including the name and current status.
        public let vpcEndpointSummaries: [VpcEndpointSummary]?

        @inlinable
        public init(nextToken: String? = nil, vpcEndpointSummaries: [VpcEndpointSummary]? = nil) {
            self.nextToken = nextToken
            self.vpcEndpointSummaries = vpcEndpointSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vpcEndpointSummaries = "vpcEndpointSummaries"
        }
    }

    public struct SamlConfigOptions: AWSEncodableShape & AWSDecodableShape {
        /// The group attribute for this SAML integration.
        public let groupAttribute: String?
        /// The XML IdP metadata file generated from your identity provider.
        public let metadata: String
        /// Custom entity id attribute to override default entity id for this saml integration.
        public let openSearchServerlessEntityId: String?
        /// The session timeout, in minutes. Default is 60 minutes (12 hours).
        public let sessionTimeout: Int?
        /// A user attribute for this SAML integration.
        public let userAttribute: String?

        @inlinable
        public init(groupAttribute: String? = nil, metadata: String, openSearchServerlessEntityId: String? = nil, sessionTimeout: Int? = nil, userAttribute: String? = nil) {
            self.groupAttribute = groupAttribute
            self.metadata = metadata
            self.openSearchServerlessEntityId = openSearchServerlessEntityId
            self.sessionTimeout = sessionTimeout
            self.userAttribute = userAttribute
        }

        public func validate(name: String) throws {
            try self.validate(self.groupAttribute, name: "groupAttribute", parent: name, max: 2048)
            try self.validate(self.groupAttribute, name: "groupAttribute", parent: name, min: 1)
            try self.validate(self.groupAttribute, name: "groupAttribute", parent: name, pattern: "[\\w+=,.@-]+")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 51200)
            try self.validate(self.metadata, name: "metadata", parent: name, min: 1)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.openSearchServerlessEntityId, name: "openSearchServerlessEntityId", parent: name, max: 1024)
            try self.validate(self.openSearchServerlessEntityId, name: "openSearchServerlessEntityId", parent: name, min: 1)
            try self.validate(self.openSearchServerlessEntityId, name: "openSearchServerlessEntityId", parent: name, pattern: "^aws:opensearch:[0-9]{12}:*")
            try self.validate(self.userAttribute, name: "userAttribute", parent: name, max: 2048)
            try self.validate(self.userAttribute, name: "userAttribute", parent: name, min: 1)
            try self.validate(self.userAttribute, name: "userAttribute", parent: name, pattern: "[\\w+=,.@-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case groupAttribute = "groupAttribute"
            case metadata = "metadata"
            case openSearchServerlessEntityId = "openSearchServerlessEntityId"
            case sessionTimeout = "sessionTimeout"
            case userAttribute = "userAttribute"
        }
    }

    public struct SecurityConfigDetail: AWSDecodableShape {
        /// The version of the security configuration.
        public let configVersion: String?
        /// The date the configuration was created.
        public let createdDate: Int64?
        /// The description of the security configuration.
        public let description: String?
        /// Describes IAM Identity Center options in the form of a key-value map.
        public let iamIdentityCenterOptions: IamIdentityCenterConfigOptions?
        /// The unique identifier of the security configuration.
        public let id: String?
        /// The timestamp of when the configuration was last modified.
        public let lastModifiedDate: Int64?
        /// SAML options for the security configuration in the form of a key-value map.
        public let samlOptions: SamlConfigOptions?
        /// The type of security configuration.
        public let type: SecurityConfigType?

        @inlinable
        public init(configVersion: String? = nil, createdDate: Int64? = nil, description: String? = nil, iamIdentityCenterOptions: IamIdentityCenterConfigOptions? = nil, id: String? = nil, lastModifiedDate: Int64? = nil, samlOptions: SamlConfigOptions? = nil, type: SecurityConfigType? = nil) {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.iamIdentityCenterOptions = iamIdentityCenterOptions
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.samlOptions = samlOptions
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case configVersion = "configVersion"
            case createdDate = "createdDate"
            case description = "description"
            case iamIdentityCenterOptions = "iamIdentityCenterOptions"
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case samlOptions = "samlOptions"
            case type = "type"
        }
    }

    public struct SecurityConfigStats: AWSDecodableShape {
        /// The number of security configurations in the current account.
        public let samlConfigCount: Int64?

        @inlinable
        public init(samlConfigCount: Int64? = nil) {
            self.samlConfigCount = samlConfigCount
        }

        private enum CodingKeys: String, CodingKey {
            case samlConfigCount = "SamlConfigCount"
        }
    }

    public struct SecurityConfigSummary: AWSDecodableShape {
        /// The version of the security configuration.
        public let configVersion: String?
        /// The Epoch time when the security configuration was created.
        public let createdDate: Int64?
        /// The description of the security configuration.
        public let description: String?
        /// The unique identifier of the security configuration.
        public let id: String?
        /// The timestamp of when the configuration was last modified.
        public let lastModifiedDate: Int64?
        /// The type of security configuration.
        public let type: SecurityConfigType?

        @inlinable
        public init(configVersion: String? = nil, createdDate: Int64? = nil, description: String? = nil, id: String? = nil, lastModifiedDate: Int64? = nil, type: SecurityConfigType? = nil) {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case configVersion = "configVersion"
            case createdDate = "createdDate"
            case description = "description"
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case type = "type"
        }
    }

    public struct SecurityPolicyDetail: AWSDecodableShape {
        /// The date the policy was created.
        public let createdDate: Int64?
        /// The description of the security policy.
        public let description: String?
        /// The timestamp of when the policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the policy.
        public let name: String?
        /// The JSON policy document without any whitespaces.
        public let policy: AWSDocument?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of security policy.
        public let type: SecurityPolicyType?

        @inlinable
        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policy: AWSDocument? = nil, policyVersion: String? = nil, type: SecurityPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct SecurityPolicyStats: AWSDecodableShape {
        /// The number of encryption policies in the current account.
        public let encryptionPolicyCount: Int64?
        /// The number of network policies in the current account.
        public let networkPolicyCount: Int64?

        @inlinable
        public init(encryptionPolicyCount: Int64? = nil, networkPolicyCount: Int64? = nil) {
            self.encryptionPolicyCount = encryptionPolicyCount
            self.networkPolicyCount = networkPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionPolicyCount = "EncryptionPolicyCount"
            case networkPolicyCount = "NetworkPolicyCount"
        }
    }

    public struct SecurityPolicySummary: AWSDecodableShape {
        /// The date the policy was created.
        public let createdDate: Int64?
        /// The description of the security policy.
        public let description: String?
        /// The timestamp of when the policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the policy.
        public let name: String?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of security policy.
        public let type: SecurityPolicyType?

        @inlinable
        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policyVersion: String? = nil, type: SecurityPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// Description of the error.
        public let message: String
        /// Service Quotas requirement to identify originating quota.
        public let quotaCode: String?
        /// Identifier of the resource affected.
        public let resourceId: String?
        /// Type of the resource affected.
        public let resourceType: String?
        /// Service Quotas requirement to identify originating service.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String? = nil, resourceId: String? = nil, resourceType: String? = nil, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key to use in the tag.
        public let key: String
        /// The value of the tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
        public let resourceArn: String
        /// A list of tags (key-value pairs) to add to the resource. All tag keys in the request must be unique.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove tags from. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
        public let resourceArn: String
        /// The tag or set of tags to remove from the resource. All tag keys in the request must be unique.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the policy.
        public let policy: String?
        /// The version of the policy being updated.
        public let policyVersion: String
        /// The type of policy.
        public let type: AccessPolicyType

        @inlinable
        public init(clientToken: String? = UpdateAccessPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String? = nil, policyVersion: String, type: AccessPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, max: 36)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, min: 20)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct UpdateAccessPolicyResponse: AWSDecodableShape {
        /// Details about the updated access policy.
        public let accessPolicyDetail: AccessPolicyDetail?

        @inlinable
        public init(accessPolicyDetail: AccessPolicyDetail? = nil) {
            self.accessPolicyDetail = accessPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyDetail = "accessPolicyDetail"
        }
    }

    public struct UpdateAccountSettingsRequest: AWSEncodableShape {
        public let capacityLimits: CapacityLimits?

        @inlinable
        public init(capacityLimits: CapacityLimits? = nil) {
            self.capacityLimits = capacityLimits
        }

        public func validate(name: String) throws {
            try self.capacityLimits?.validate(name: "\(name).capacityLimits")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityLimits = "capacityLimits"
        }
    }

    public struct UpdateAccountSettingsResponse: AWSDecodableShape {
        /// OpenSearch Serverless-related settings for the current Amazon Web Services account.
        public let accountSettingsDetail: AccountSettingsDetail?

        @inlinable
        public init(accountSettingsDetail: AccountSettingsDetail? = nil) {
            self.accountSettingsDetail = accountSettingsDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettingsDetail = "accountSettingsDetail"
        }
    }

    public struct UpdateCollectionDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// The date and time when the collection was created.
        public let createdDate: Int64?
        /// The description of the collection.
        public let description: String?
        /// The unique identifier of the collection.
        public let id: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?
        /// The collection type.
        public let type: CollectionType?

        @inlinable
        public init(arn: String? = nil, createdDate: Int64? = nil, description: String? = nil, id: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, status: CollectionStatus? = nil, type: CollectionType? = nil) {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdDate = "createdDate"
            case description = "description"
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct UpdateCollectionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the collection.
        public let description: String?
        /// The unique identifier of the collection.
        public let id: String

        @inlinable
        public init(clientToken: String? = UpdateCollectionRequest.idempotencyToken(), description: String? = nil, id: String) {
            self.clientToken = clientToken
            self.description = description
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 40)
            try self.validate(self.id, name: "id", parent: name, min: 3)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-z0-9]{3,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case id = "id"
        }
    }

    public struct UpdateCollectionResponse: AWSDecodableShape {
        /// Details about the updated collection.
        public let updateCollectionDetail: UpdateCollectionDetail?

        @inlinable
        public init(updateCollectionDetail: UpdateCollectionDetail? = nil) {
            self.updateCollectionDetail = updateCollectionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case updateCollectionDetail = "updateCollectionDetail"
        }
    }

    public struct UpdateIamIdentityCenterConfigOptions: AWSEncodableShape {
        /// The group attribute for this IAM Identity Center integration. Defaults to GroupId.
        public let groupAttribute: IamIdentityCenterGroupAttribute?
        /// The user attribute for this IAM Identity Center integration. Defaults to UserId.
        public let userAttribute: IamIdentityCenterUserAttribute?

        @inlinable
        public init(groupAttribute: IamIdentityCenterGroupAttribute? = nil, userAttribute: IamIdentityCenterUserAttribute? = nil) {
            self.groupAttribute = groupAttribute
            self.userAttribute = userAttribute
        }

        private enum CodingKeys: String, CodingKey {
            case groupAttribute = "groupAttribute"
            case userAttribute = "userAttribute"
        }
    }

    public struct UpdateLifecyclePolicyRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the lifecycle policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the lifecycle policy.
        public let policy: String?
        /// The version of the policy being updated.
        public let policyVersion: String
        ///  The type of lifecycle policy.
        public let type: LifecyclePolicyType

        @inlinable
        public init(clientToken: String? = UpdateLifecyclePolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String? = nil, policyVersion: String, type: LifecyclePolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, max: 36)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, min: 20)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct UpdateLifecyclePolicyResponse: AWSDecodableShape {
        /// Details about the updated lifecycle policy.
        public let lifecyclePolicyDetail: LifecyclePolicyDetail?

        @inlinable
        public init(lifecyclePolicyDetail: LifecyclePolicyDetail? = nil) {
            self.lifecyclePolicyDetail = lifecyclePolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyDetail = "lifecyclePolicyDetail"
        }
    }

    public struct UpdateSecurityConfigRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The version of the security configuration to be updated. You can find the most recent version of a security configuration using the GetSecurityPolicy command.
        public let configVersion: String
        /// A description of the security configuration.
        public let description: String?
        /// Describes IAM Identity Center options in the form of a key-value map.
        public let iamIdentityCenterOptionsUpdates: UpdateIamIdentityCenterConfigOptions?
        /// The security configuration identifier. For SAML the ID will be saml/&lt;accountId&gt;/&lt;idpProviderName&gt;. For example, saml/123456789123/OKTADev.
        public let id: String
        /// SAML options in in the form of a key-value map.
        public let samlOptions: SamlConfigOptions?

        @inlinable
        public init(clientToken: String? = UpdateSecurityConfigRequest.idempotencyToken(), configVersion: String, description: String? = nil, iamIdentityCenterOptionsUpdates: UpdateIamIdentityCenterConfigOptions? = nil, id: String, samlOptions: SamlConfigOptions? = nil) {
            self.clientToken = clientToken
            self.configVersion = configVersion
            self.description = description
            self.iamIdentityCenterOptionsUpdates = iamIdentityCenterOptionsUpdates
            self.id = id
            self.samlOptions = samlOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.configVersion, name: "configVersion", parent: name, max: 36)
            try self.validate(self.configVersion, name: "configVersion", parent: name, min: 20)
            try self.validate(self.configVersion, name: "configVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.samlOptions?.validate(name: "\(name).samlOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configVersion = "configVersion"
            case description = "description"
            case iamIdentityCenterOptionsUpdates = "iamIdentityCenterOptionsUpdates"
            case id = "id"
            case samlOptions = "samlOptions"
        }
    }

    public struct UpdateSecurityConfigResponse: AWSDecodableShape {
        /// Details about the updated security configuration.
        public let securityConfigDetail: SecurityConfigDetail?

        @inlinable
        public init(securityConfigDetail: SecurityConfigDetail? = nil) {
            self.securityConfigDetail = securityConfigDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfigDetail = "securityConfigDetail"
        }
    }

    public struct UpdateSecurityPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the new policy.
        public let policy: String?
        /// The version of the policy being updated.
        public let policyVersion: String
        /// The type of access policy.
        public let type: SecurityPolicyType

        @inlinable
        public init(clientToken: String? = UpdateSecurityPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String? = nil, policyVersion: String, type: SecurityPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, max: 36)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, min: 20)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct UpdateSecurityPolicyResponse: AWSDecodableShape {
        /// Details about the updated security policy.
        public let securityPolicyDetail: SecurityPolicyDetail?

        @inlinable
        public init(securityPolicyDetail: SecurityPolicyDetail? = nil) {
            self.securityPolicyDetail = securityPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityPolicyDetail = "securityPolicyDetail"
        }
    }

    public struct UpdateVpcEndpointDetail: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The timestamp of when the endpoint was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the endpoint.
        public let name: String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let securityGroupIds: [String]?
        /// The current status of the endpoint update process.
        public let status: VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public let subnetIds: [String]?

        @inlinable
        public init(id: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: VpcEndpointStatus? = nil, subnetIds: [String]? = nil) {
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
        }
    }

    public struct UpdateVpcEndpointRequest: AWSEncodableShape {
        /// The unique identifiers of the security groups to add to the endpoint. Security groups define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let addSecurityGroupIds: [String]?
        /// The ID of one or more subnets to add to the endpoint.
        public let addSubnetIds: [String]?
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the interface endpoint to update.
        public let id: String
        /// The unique identifiers of the security groups to remove from the endpoint.
        public let removeSecurityGroupIds: [String]?
        /// The unique identifiers of the subnets to remove from the endpoint.
        public let removeSubnetIds: [String]?

        @inlinable
        public init(addSecurityGroupIds: [String]? = nil, addSubnetIds: [String]? = nil, clientToken: String? = UpdateVpcEndpointRequest.idempotencyToken(), id: String, removeSecurityGroupIds: [String]? = nil, removeSubnetIds: [String]? = nil) {
            self.addSecurityGroupIds = addSecurityGroupIds
            self.addSubnetIds = addSubnetIds
            self.clientToken = clientToken
            self.id = id
            self.removeSecurityGroupIds = removeSecurityGroupIds
            self.removeSubnetIds = removeSubnetIds
        }

        public func validate(name: String) throws {
            try self.addSecurityGroupIds?.forEach {
                try validate($0, name: "addSecurityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "addSecurityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "addSecurityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.addSecurityGroupIds, name: "addSecurityGroupIds", parent: name, max: 5)
            try self.validate(self.addSecurityGroupIds, name: "addSecurityGroupIds", parent: name, min: 1)
            try self.addSubnetIds?.forEach {
                try validate($0, name: "addSubnetIds[]", parent: name, max: 32)
                try validate($0, name: "addSubnetIds[]", parent: name, min: 1)
                try validate($0, name: "addSubnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.addSubnetIds, name: "addSubnetIds", parent: name, max: 6)
            try self.validate(self.addSubnetIds, name: "addSubnetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^vpce-[0-9a-z]*$")
            try self.removeSecurityGroupIds?.forEach {
                try validate($0, name: "removeSecurityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "removeSecurityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "removeSecurityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.removeSecurityGroupIds, name: "removeSecurityGroupIds", parent: name, max: 5)
            try self.validate(self.removeSecurityGroupIds, name: "removeSecurityGroupIds", parent: name, min: 1)
            try self.removeSubnetIds?.forEach {
                try validate($0, name: "removeSubnetIds[]", parent: name, max: 32)
                try validate($0, name: "removeSubnetIds[]", parent: name, min: 1)
                try validate($0, name: "removeSubnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.removeSubnetIds, name: "removeSubnetIds", parent: name, max: 6)
            try self.validate(self.removeSubnetIds, name: "removeSubnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addSecurityGroupIds = "addSecurityGroupIds"
            case addSubnetIds = "addSubnetIds"
            case clientToken = "clientToken"
            case id = "id"
            case removeSecurityGroupIds = "removeSecurityGroupIds"
            case removeSubnetIds = "removeSubnetIds"
        }
    }

    public struct UpdateVpcEndpointResponse: AWSDecodableShape {
        /// Details about the updated VPC endpoint.
        public let updateVpcEndpointDetail: UpdateVpcEndpointDetail?

        @inlinable
        public init(updateVpcEndpointDetail: UpdateVpcEndpointDetail? = nil) {
            self.updateVpcEndpointDetail = updateVpcEndpointDetail
        }

        private enum CodingKeys: String, CodingKey {
            case updateVpcEndpointDetail = "UpdateVpcEndpointDetail"
        }
    }

    public struct VpcEndpointDetail: AWSDecodableShape {
        /// The date the endpoint was created.
        public let createdDate: Int64?
        /// A failure code associated with the request.
        public let failureCode: String?
        /// A message associated with the failure code.
        public let failureMessage: String?
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let securityGroupIds: [String]?
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public let subnetIds: [String]?
        /// The ID of the VPC from which you access OpenSearch Serverless.
        public let vpcId: String?

        @inlinable
        public init(createdDate: Int64? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: VpcEndpointStatus? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.createdDate = createdDate
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct VpcEndpointErrorDetail: AWSDecodableShape {
        /// The error code for the failed request.
        public let errorCode: String?
        /// An error message describing the reason for the failure.
        public let errorMessage: String?
        /// The unique identifier of the VPC endpoint.
        public let id: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct VpcEndpointFilters: AWSEncodableShape {
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?

        @inlinable
        public init(status: VpcEndpointStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VpcEndpointSummary: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?

        @inlinable
        public init(id: String? = nil, name: String? = nil, status: VpcEndpointStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }
}

// MARK: - Errors

/// Error enum for OpenSearchServerless
public struct OpenSearchServerlessErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case ocuLimitExceededException = "OcuLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize OpenSearchServerless
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// When creating a resource, thrown when a resource with the same name already exists or is being created. When deleting a resource, thrown when the resource is not in the ACTIVE or FAILED state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Thrown when an error internal to the service occurs while processing a request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Thrown when the collection you're attempting to create results in a number of search or indexing OCUs that exceeds the account limit.
    public static var ocuLimitExceededException: Self { .init(.ocuLimitExceededException) }
    /// Thrown when accessing or deleting a resource that does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Thrown when you attempt to create more resources than the service allows based on service quotas.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Thrown when the HTTP request contains invalid input or is missing required input.
    public static var validationException: Self { .init(.validationException) }
}

extension OpenSearchServerlessErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ServiceQuotaExceededException": OpenSearchServerless.ServiceQuotaExceededException.self
    ]
}

extension OpenSearchServerlessErrorType: Equatable {
    public static func == (lhs: OpenSearchServerlessErrorType, rhs: OpenSearchServerlessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OpenSearchServerlessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
