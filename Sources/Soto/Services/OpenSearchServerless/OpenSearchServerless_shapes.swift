//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension OpenSearchServerless {
    // MARK: Enums

    public enum AccessPolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// data policy type
        case data = "data"
        public var description: String { return self.rawValue }
    }

    public enum CollectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Collection resource is ready to use
        case active = "ACTIVE"
        /// Creating collection resource
        case creating = "CREATING"
        /// Deleting collection resource
        case deleting = "DELETING"
        /// Collection resource create or delete failed
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum CollectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Search collection type
        case search = "SEARCH"
        /// Timeseries collection type
        case timeseries = "TIMESERIES"
        /// Vectorsearch collection type
        case vectorsearch = "VECTORSEARCH"
        public var description: String { return self.rawValue }
    }

    public enum LifecyclePolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// retention policy type
        case retention = "retention"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// index resource type
        case index = "index"
        public var description: String { return self.rawValue }
    }

    public enum SecurityConfigType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// saml provider
        case saml = "saml"
        public var description: String { return self.rawValue }
    }

    public enum SecurityPolicyType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// encryption policy type
        case encryption = "encryption"
        /// network policy type
        case network = "network"
        public var description: String { return self.rawValue }
    }

    public enum StandbyReplicas: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Standby replicas disabled
        case disabled = "DISABLED"
        /// Standby replicas enabled
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum VpcEndpointStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// VPCEndpoint resource is ready to use
        case active = "ACTIVE"
        /// Deleting VPCEndpoint resource
        case deleting = "DELETING"
        /// VPCEndpoint resource create or delete failed
        case failed = "FAILED"
        /// Pending VPCEndpoint resource
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessPolicyDetail: AWSDecodableShape {
        /// The date the policy was created.
        public let createdDate: Int64?
        /// The description of the policy.
        public let description: String?
        /// The timestamp of when the policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the policy.
        public let name: String?
        /// The JSON policy document without any whitespaces.
        public let policy: String?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of access policy.
        public let type: AccessPolicyType?

        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policy: String? = nil, policyVersion: String? = nil, type: AccessPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct AccessPolicyStats: AWSDecodableShape {
        /// The number of data access policies in the current account.
        public let dataPolicyCount: Int64?

        public init(dataPolicyCount: Int64? = nil) {
            self.dataPolicyCount = dataPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case dataPolicyCount = "DataPolicyCount"
        }
    }

    public struct AccessPolicySummary: AWSDecodableShape {
        /// The Epoch time when the access policy was created.
        public let createdDate: Int64?
        /// The description of the access policy.
        public let description: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the access policy.
        public let name: String?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of access policy. Currently, the only available type is data.
        public let type: AccessPolicyType?

        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policyVersion: String? = nil, type: AccessPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct AccountSettingsDetail: AWSDecodableShape {
        public let capacityLimits: CapacityLimits?

        public init(capacityLimits: CapacityLimits? = nil) {
            self.capacityLimits = capacityLimits
        }

        private enum CodingKeys: String, CodingKey {
            case capacityLimits = "capacityLimits"
        }
    }

    public struct BatchGetCollectionRequest: AWSEncodableShape {
        /// A list of collection IDs. You can't provide names and IDs in the same request. The ID is part of the collection endpoint. You can also retrieve it using the ListCollections API.
        public let ids: [String]?
        /// A list of collection names. You can't provide names and IDs in the same request.
        public let names: [String]?

        public init(ids: [String]? = nil, names: [String]? = nil) {
            self.ids = ids
            self.names = names
        }

        public func validate(name: String) throws {
            try self.ids?.forEach {
                try validate($0, name: "ids[]", parent: name, max: 40)
                try validate($0, name: "ids[]", parent: name, min: 3)
                try validate($0, name: "ids[]", parent: name, pattern: "^[a-z0-9]{3,40}$")
            }
            try self.validate(self.ids, name: "ids", parent: name, max: 100)
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
            try self.names?.forEach {
                try validate($0, name: "names[]", parent: name, max: 32)
                try validate($0, name: "names[]", parent: name, min: 3)
                try validate($0, name: "names[]", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 100)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
            case names = "names"
        }
    }

    public struct BatchGetCollectionResponse: AWSDecodableShape {
        /// Details about each collection.
        public let collectionDetails: [CollectionDetail]?
        /// Error information for the request.
        public let collectionErrorDetails: [CollectionErrorDetail]?

        public init(collectionDetails: [CollectionDetail]? = nil, collectionErrorDetails: [CollectionErrorDetail]? = nil) {
            self.collectionDetails = collectionDetails
            self.collectionErrorDetails = collectionErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case collectionDetails = "collectionDetails"
            case collectionErrorDetails = "collectionErrorDetails"
        }
    }

    public struct BatchGetEffectiveLifecyclePolicyRequest: AWSEncodableShape {
        /// The unique identifiers of policy types and resource names.
        public let resourceIdentifiers: [LifecyclePolicyResourceIdentifier]

        public init(resourceIdentifiers: [LifecyclePolicyResourceIdentifier]) {
            self.resourceIdentifiers = resourceIdentifiers
        }

        public func validate(name: String) throws {
            try self.resourceIdentifiers.forEach {
                try $0.validate(name: "\(name).resourceIdentifiers[]")
            }
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, max: 100)
            try self.validate(self.resourceIdentifiers, name: "resourceIdentifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIdentifiers = "resourceIdentifiers"
        }
    }

    public struct BatchGetEffectiveLifecyclePolicyResponse: AWSDecodableShape {
        /// A list of lifecycle policies applied to the OpenSearch Serverless indexes.
        public let effectiveLifecyclePolicyDetails: [EffectiveLifecyclePolicyDetail]?
        /// A list of resources for which retrieval failed.
        public let effectiveLifecyclePolicyErrorDetails: [EffectiveLifecyclePolicyErrorDetail]?

        public init(effectiveLifecyclePolicyDetails: [EffectiveLifecyclePolicyDetail]? = nil, effectiveLifecyclePolicyErrorDetails: [EffectiveLifecyclePolicyErrorDetail]? = nil) {
            self.effectiveLifecyclePolicyDetails = effectiveLifecyclePolicyDetails
            self.effectiveLifecyclePolicyErrorDetails = effectiveLifecyclePolicyErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveLifecyclePolicyDetails = "effectiveLifecyclePolicyDetails"
            case effectiveLifecyclePolicyErrorDetails = "effectiveLifecyclePolicyErrorDetails"
        }
    }

    public struct BatchGetLifecyclePolicyRequest: AWSEncodableShape {
        /// The unique identifiers of policy types and policy names.
        public let identifiers: [LifecyclePolicyIdentifier]

        public init(identifiers: [LifecyclePolicyIdentifier]) {
            self.identifiers = identifiers
        }

        public func validate(name: String) throws {
            try self.identifiers.forEach {
                try $0.validate(name: "\(name).identifiers[]")
            }
            try self.validate(self.identifiers, name: "identifiers", parent: name, max: 40)
            try self.validate(self.identifiers, name: "identifiers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identifiers = "identifiers"
        }
    }

    public struct BatchGetLifecyclePolicyResponse: AWSDecodableShape {
        /// A list of lifecycle policies matched to the input policy name and policy type.
        public let lifecyclePolicyDetails: [LifecyclePolicyDetail]?
        /// A list of lifecycle policy names and policy types for which retrieval failed.
        public let lifecyclePolicyErrorDetails: [LifecyclePolicyErrorDetail]?

        public init(lifecyclePolicyDetails: [LifecyclePolicyDetail]? = nil, lifecyclePolicyErrorDetails: [LifecyclePolicyErrorDetail]? = nil) {
            self.lifecyclePolicyDetails = lifecyclePolicyDetails
            self.lifecyclePolicyErrorDetails = lifecyclePolicyErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyDetails = "lifecyclePolicyDetails"
            case lifecyclePolicyErrorDetails = "lifecyclePolicyErrorDetails"
        }
    }

    public struct BatchGetVpcEndpointRequest: AWSEncodableShape {
        /// A list of VPC endpoint identifiers.
        public let ids: [String]

        public init(ids: [String]) {
            self.ids = ids
        }

        public func validate(name: String) throws {
            try self.ids.forEach {
                try validate($0, name: "ids[]", parent: name, max: 255)
                try validate($0, name: "ids[]", parent: name, min: 1)
                try validate($0, name: "ids[]", parent: name, pattern: "^vpce-[0-9a-z]*$")
            }
            try self.validate(self.ids, name: "ids", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ids = "ids"
        }
    }

    public struct BatchGetVpcEndpointResponse: AWSDecodableShape {
        /// Details about the specified VPC endpoint.
        public let vpcEndpointDetails: [VpcEndpointDetail]?
        /// Error information for a failed request.
        public let vpcEndpointErrorDetails: [VpcEndpointErrorDetail]?

        public init(vpcEndpointDetails: [VpcEndpointDetail]? = nil, vpcEndpointErrorDetails: [VpcEndpointErrorDetail]? = nil) {
            self.vpcEndpointDetails = vpcEndpointDetails
            self.vpcEndpointErrorDetails = vpcEndpointErrorDetails
        }

        private enum CodingKeys: String, CodingKey {
            case vpcEndpointDetails = "vpcEndpointDetails"
            case vpcEndpointErrorDetails = "vpcEndpointErrorDetails"
        }
    }

    public struct CapacityLimits: AWSEncodableShape & AWSDecodableShape {
        /// The maximum indexing capacity for collections.
        public let maxIndexingCapacityInOCU: Int?
        /// The maximum search capacity for collections.
        public let maxSearchCapacityInOCU: Int?

        public init(maxIndexingCapacityInOCU: Int? = nil, maxSearchCapacityInOCU: Int? = nil) {
            self.maxIndexingCapacityInOCU = maxIndexingCapacityInOCU
            self.maxSearchCapacityInOCU = maxSearchCapacityInOCU
        }

        public func validate(name: String) throws {
            try self.validate(self.maxIndexingCapacityInOCU, name: "maxIndexingCapacityInOCU", parent: name, min: 2)
            try self.validate(self.maxSearchCapacityInOCU, name: "maxSearchCapacityInOCU", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maxIndexingCapacityInOCU = "maxIndexingCapacityInOCU"
            case maxSearchCapacityInOCU = "maxSearchCapacityInOCU"
        }
    }

    public struct CollectionDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// Collection-specific endpoint used to submit index, search, and data upload requests to an OpenSearch Serverless collection.
        public let collectionEndpoint: String?
        /// The Epoch time when the collection was created.
        public let createdDate: Int64?
        /// Collection-specific endpoint used to access OpenSearch Dashboards.
        public let dashboardEndpoint: String?
        /// A description of the collection.
        public let description: String?
        /// A unique identifier for the collection.
        public let id: String?
        /// The ARN of the Amazon Web Services KMS key used to encrypt the collection.
        public let kmsKeyArn: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the collection.
        public let name: String?
        /// Details about an OpenSearch Serverless collection.
        public let standbyReplicas: StandbyReplicas?
        /// The current status of the collection.
        public let status: CollectionStatus?
        /// The type of collection.
        public let type: CollectionType?

        public init(arn: String? = nil, collectionEndpoint: String? = nil, createdDate: Int64? = nil, dashboardEndpoint: String? = nil, description: String? = nil, id: String? = nil, kmsKeyArn: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, standbyReplicas: StandbyReplicas? = nil, status: CollectionStatus? = nil, type: CollectionType? = nil) {
            self.arn = arn
            self.collectionEndpoint = collectionEndpoint
            self.createdDate = createdDate
            self.dashboardEndpoint = dashboardEndpoint
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collectionEndpoint = "collectionEndpoint"
            case createdDate = "createdDate"
            case dashboardEndpoint = "dashboardEndpoint"
            case description = "description"
            case id = "id"
            case kmsKeyArn = "kmsKeyArn"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case standbyReplicas = "standbyReplicas"
            case status = "status"
            case type = "type"
        }
    }

    public struct CollectionErrorDetail: AWSDecodableShape {
        /// The error code for the request. For example, NOT_FOUND.
        public let errorCode: String?
        /// A description of the error. For example, The specified Collection is not found.
        public let errorMessage: String?
        /// If the request contains collection IDs, the response includes the IDs provided in the request.
        public let id: String?
        /// If the request contains collection names, the response includes the names provided in the request.
        public let name: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, id: String? = nil, name: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
            case name = "name"
        }
    }

    public struct CollectionFilters: AWSEncodableShape {
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?

        public init(name: String? = nil, status: CollectionStatus? = nil) {
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case status = "status"
        }
    }

    public struct CollectionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// The unique identifier of the collection.
        public let id: String?
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, status: CollectionStatus? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateAccessPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the policy.
        public let policy: String
        /// The type of policy.
        public let type: AccessPolicyType

        public init(clientToken: String? = CreateAccessPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String, type: AccessPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case type = "type"
        }
    }

    public struct CreateAccessPolicyResponse: AWSDecodableShape {
        /// Details about the created access policy.
        public let accessPolicyDetail: AccessPolicyDetail?

        public init(accessPolicyDetail: AccessPolicyDetail? = nil) {
            self.accessPolicyDetail = accessPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyDetail = "accessPolicyDetail"
        }
    }

    public struct CreateCollectionDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// The Epoch time when the collection was created.
        public let createdDate: Int64?
        /// A description of the collection.
        public let description: String?
        /// The unique identifier of the collection.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the collection.
        public let kmsKeyArn: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the collection.
        public let name: String?
        /// Creates details about an OpenSearch Serverless collection.
        public let standbyReplicas: StandbyReplicas?
        /// The current status of the collection.
        public let status: CollectionStatus?
        /// The type of collection.
        public let type: CollectionType?

        public init(arn: String? = nil, createdDate: Int64? = nil, description: String? = nil, id: String? = nil, kmsKeyArn: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, standbyReplicas: StandbyReplicas? = nil, status: CollectionStatus? = nil, type: CollectionType? = nil) {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdDate = "createdDate"
            case description = "description"
            case id = "id"
            case kmsKeyArn = "kmsKeyArn"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case standbyReplicas = "standbyReplicas"
            case status = "status"
            case type = "type"
        }
    }

    public struct CreateCollectionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// Description of the collection.
        public let description: String?
        /// Name of the collection.
        public let name: String
        /// Indicates whether standby replicas should be used for a collection.
        public let standbyReplicas: StandbyReplicas?
        /// An arbitrary set of tags (key–value pairs) to associate with the OpenSearch Serverless collection.
        public let tags: [Tag]?
        /// The type of collection.
        public let type: CollectionType?

        public init(clientToken: String? = CreateCollectionRequest.idempotencyToken(), description: String? = nil, name: String, standbyReplicas: StandbyReplicas? = nil, tags: [Tag]? = nil, type: CollectionType? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.standbyReplicas = standbyReplicas
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case standbyReplicas = "standbyReplicas"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateCollectionResponse: AWSDecodableShape {
        /// Details about the collection.
        public let createCollectionDetail: CreateCollectionDetail?

        public init(createCollectionDetail: CreateCollectionDetail? = nil) {
            self.createCollectionDetail = createCollectionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case createCollectionDetail = "createCollectionDetail"
        }
    }

    public struct CreateLifecyclePolicyRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the lifecycle policy.
        public let description: String?
        /// The name of the lifecycle policy.
        public let name: String
        /// The JSON policy document to use as the content for the lifecycle policy.
        public let policy: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        public init(clientToken: String? = CreateLifecyclePolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String, type: LifecyclePolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case type = "type"
        }
    }

    public struct CreateLifecyclePolicyResponse: AWSDecodableShape {
        /// Details about the created lifecycle policy.
        public let lifecyclePolicyDetail: LifecyclePolicyDetail?

        public init(lifecyclePolicyDetail: LifecyclePolicyDetail? = nil) {
            self.lifecyclePolicyDetail = lifecyclePolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyDetail = "lifecyclePolicyDetail"
        }
    }

    public struct CreateSecurityConfigRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the security configuration.
        public let description: String?
        /// The name of the security configuration.
        public let name: String
        /// Describes SAML options in in the form of a key-value map. This field is required if you specify saml for the type parameter.
        public let samlOptions: SamlConfigOptions?
        /// The type of security configuration.
        public let type: SecurityConfigType

        public init(clientToken: String? = CreateSecurityConfigRequest.idempotencyToken(), description: String? = nil, name: String, samlOptions: SamlConfigOptions? = nil, type: SecurityConfigType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.samlOptions = samlOptions
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.samlOptions?.validate(name: "\(name).samlOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case samlOptions = "samlOptions"
            case type = "type"
        }
    }

    public struct CreateSecurityConfigResponse: AWSDecodableShape {
        /// Details about the created security configuration.
        public let securityConfigDetail: SecurityConfigDetail?

        public init(securityConfigDetail: SecurityConfigDetail? = nil) {
            self.securityConfigDetail = securityConfigDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfigDetail = "securityConfigDetail"
        }
    }

    public struct CreateSecurityPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the new policy.
        public let policy: String
        /// The type of security policy.
        public let type: SecurityPolicyType

        public init(clientToken: String? = CreateSecurityPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String, type: SecurityPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case type = "type"
        }
    }

    public struct CreateSecurityPolicyResponse: AWSDecodableShape {
        /// Details about the created security policy.
        public let securityPolicyDetail: SecurityPolicyDetail?

        public init(securityPolicyDetail: SecurityPolicyDetail? = nil) {
            self.securityPolicyDetail = securityPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityPolicyDetail = "securityPolicyDetail"
        }
    }

    public struct CreateVpcEndpointDetail: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The current status in the endpoint creation process.
        public let status: VpcEndpointStatus?

        public init(id: String? = nil, name: String? = nil, status: VpcEndpointStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateVpcEndpointRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the interface endpoint.
        public let name: String
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let securityGroupIds: [String]?
        /// The ID of one or more subnets from which you'll access OpenSearch Serverless.
        public let subnetIds: [String]
        /// The ID of the VPC from which you'll access OpenSearch Serverless.
        public let vpcId: String

        public init(clientToken: String? = CreateVpcEndpointRequest.idempotencyToken(), name: String, securityGroupIds: [String]? = nil, subnetIds: [String], vpcId: String) {
            self.clientToken = clientToken
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 5)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 32)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, max: 6)
            try self.validate(self.subnetIds, name: "subnetIds", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 255)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
            try self.validate(self.vpcId, name: "vpcId", parent: name, pattern: "^vpc-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct CreateVpcEndpointResponse: AWSDecodableShape {
        /// Details about the created interface VPC endpoint.
        public let createVpcEndpointDetail: CreateVpcEndpointDetail?

        public init(createVpcEndpointDetail: CreateVpcEndpointDetail? = nil) {
            self.createVpcEndpointDetail = createVpcEndpointDetail
        }

        private enum CodingKeys: String, CodingKey {
            case createVpcEndpointDetail = "createVpcEndpointDetail"
        }
    }

    public struct DeleteAccessPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the policy to delete.
        public let name: String
        /// The type of policy.
        public let type: AccessPolicyType

        public init(clientToken: String? = DeleteAccessPolicyRequest.idempotencyToken(), name: String, type: AccessPolicyType) {
            self.clientToken = clientToken
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case type = "type"
        }
    }

    public struct DeleteAccessPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCollectionDetail: AWSDecodableShape {
        /// The unique identifier of the collection.
        public let id: String?
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?

        public init(id: String? = nil, name: String? = nil, status: CollectionStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteCollectionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the collection. For example, 1iu5usc406kd. The ID is part of the collection endpoint. You can also retrieve it using the ListCollections API.
        public let id: String

        public init(clientToken: String? = DeleteCollectionRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 40)
            try self.validate(self.id, name: "id", parent: name, min: 3)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-z0-9]{3,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct DeleteCollectionResponse: AWSDecodableShape {
        /// Details of the deleted collection.
        public let deleteCollectionDetail: DeleteCollectionDetail?

        public init(deleteCollectionDetail: DeleteCollectionDetail? = nil) {
            self.deleteCollectionDetail = deleteCollectionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case deleteCollectionDetail = "deleteCollectionDetail"
        }
    }

    public struct DeleteLifecyclePolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the policy to delete.
        public let name: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        public init(clientToken: String? = DeleteLifecyclePolicyRequest.idempotencyToken(), name: String, type: LifecyclePolicyType) {
            self.clientToken = clientToken
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case type = "type"
        }
    }

    public struct DeleteLifecyclePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSecurityConfigRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The security configuration identifier. For SAML the ID will be saml/&lt;accountId&gt;/&lt;idpProviderName&gt;. For example, saml/123456789123/OKTADev.
        public let id: String

        public init(clientToken: String? = DeleteSecurityConfigRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct DeleteSecurityConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSecurityPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The name of the policy to delete.
        public let name: String
        /// The type of policy.
        public let type: SecurityPolicyType

        public init(clientToken: String? = DeleteSecurityPolicyRequest.idempotencyToken(), name: String, type: SecurityPolicyType) {
            self.clientToken = clientToken
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case name = "name"
            case type = "type"
        }
    }

    public struct DeleteSecurityPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVpcEndpointDetail: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The current status of the endpoint deletion process.
        public let status: VpcEndpointStatus?

        public init(id: String? = nil, name: String? = nil, status: VpcEndpointStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteVpcEndpointRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The VPC endpoint identifier.
        public let id: String

        public init(clientToken: String? = DeleteVpcEndpointRequest.idempotencyToken(), id: String) {
            self.clientToken = clientToken
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^vpce-[0-9a-z]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case id = "id"
        }
    }

    public struct DeleteVpcEndpointResponse: AWSDecodableShape {
        /// Details about the deleted endpoint.
        public let deleteVpcEndpointDetail: DeleteVpcEndpointDetail?

        public init(deleteVpcEndpointDetail: DeleteVpcEndpointDetail? = nil) {
            self.deleteVpcEndpointDetail = deleteVpcEndpointDetail
        }

        private enum CodingKeys: String, CodingKey {
            case deleteVpcEndpointDetail = "deleteVpcEndpointDetail"
        }
    }

    public struct EffectiveLifecyclePolicyDetail: AWSDecodableShape {
        /// The minimum number of index retention days set. That is an optional param that will return as true if the minimum number of days or  hours is not set to a index resource.
        public let noMinRetentionPeriod: Bool?
        /// The name of the lifecycle policy.
        public let policyName: String?
        /// The name of the OpenSearch Serverless index resource.
        public let resource: String?
        /// The type of OpenSearch Serverless resource. Currently, the only supported resource is index.
        public let resourceType: ResourceType?
        /// The minimum number of index retention in days or hours. This is an optional parameter that will return only if it’s set.
        public let retentionPeriod: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        public init(noMinRetentionPeriod: Bool? = nil, policyName: String? = nil, resource: String? = nil, resourceType: ResourceType? = nil, retentionPeriod: String? = nil, type: LifecyclePolicyType? = nil) {
            self.noMinRetentionPeriod = noMinRetentionPeriod
            self.policyName = policyName
            self.resource = resource
            self.resourceType = resourceType
            self.retentionPeriod = retentionPeriod
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case noMinRetentionPeriod = "noMinRetentionPeriod"
            case policyName = "policyName"
            case resource = "resource"
            case resourceType = "resourceType"
            case retentionPeriod = "retentionPeriod"
            case type = "type"
        }
    }

    public struct EffectiveLifecyclePolicyErrorDetail: AWSDecodableShape {
        /// The error code for the request.
        public let errorCode: String?
        /// A description of the error. For example, The specified Index resource is not found.
        public let errorMessage: String?
        /// The name of OpenSearch Serverless index resource.
        public let resource: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        public init(errorCode: String? = nil, errorMessage: String? = nil, resource: String? = nil, type: LifecyclePolicyType? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.resource = resource
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case resource = "resource"
            case type = "type"
        }
    }

    public struct GetAccessPolicyRequest: AWSEncodableShape {
        /// The name of the access policy.
        public let name: String
        /// Tye type of policy. Currently, the only supported value is data.
        public let type: AccessPolicyType

        public init(name: String, type: AccessPolicyType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct GetAccessPolicyResponse: AWSDecodableShape {
        /// Details about the requested access policy.
        public let accessPolicyDetail: AccessPolicyDetail?

        public init(accessPolicyDetail: AccessPolicyDetail? = nil) {
            self.accessPolicyDetail = accessPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyDetail = "accessPolicyDetail"
        }
    }

    public struct GetAccountSettingsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAccountSettingsResponse: AWSDecodableShape {
        /// OpenSearch Serverless-related details for the current account.
        public let accountSettingsDetail: AccountSettingsDetail?

        public init(accountSettingsDetail: AccountSettingsDetail? = nil) {
            self.accountSettingsDetail = accountSettingsDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettingsDetail = "accountSettingsDetail"
        }
    }

    public struct GetPoliciesStatsRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetPoliciesStatsResponse: AWSDecodableShape {
        /// Information about the data access policies in your account.
        public let accessPolicyStats: AccessPolicyStats?
        /// Information about the lifecycle policies in your account.
        public let lifecyclePolicyStats: LifecyclePolicyStats?
        /// Information about the security configurations in your account.
        public let securityConfigStats: SecurityConfigStats?
        /// Information about the security policies in your account.
        public let securityPolicyStats: SecurityPolicyStats?
        /// The total number of OpenSearch Serverless security policies and configurations in your account.
        public let totalPolicyCount: Int64?

        public init(accessPolicyStats: AccessPolicyStats? = nil, lifecyclePolicyStats: LifecyclePolicyStats? = nil, securityConfigStats: SecurityConfigStats? = nil, securityPolicyStats: SecurityPolicyStats? = nil, totalPolicyCount: Int64? = nil) {
            self.accessPolicyStats = accessPolicyStats
            self.lifecyclePolicyStats = lifecyclePolicyStats
            self.securityConfigStats = securityConfigStats
            self.securityPolicyStats = securityPolicyStats
            self.totalPolicyCount = totalPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyStats = "AccessPolicyStats"
            case lifecyclePolicyStats = "LifecyclePolicyStats"
            case securityConfigStats = "SecurityConfigStats"
            case securityPolicyStats = "SecurityPolicyStats"
            case totalPolicyCount = "TotalPolicyCount"
        }
    }

    public struct GetSecurityConfigRequest: AWSEncodableShape {
        /// The unique identifier of the security configuration.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }

    public struct GetSecurityConfigResponse: AWSDecodableShape {
        /// Details of the requested security configuration.
        public let securityConfigDetail: SecurityConfigDetail?

        public init(securityConfigDetail: SecurityConfigDetail? = nil) {
            self.securityConfigDetail = securityConfigDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfigDetail = "securityConfigDetail"
        }
    }

    public struct GetSecurityPolicyRequest: AWSEncodableShape {
        /// The name of the security policy.
        public let name: String
        /// The type of security policy.
        public let type: SecurityPolicyType

        public init(name: String, type: SecurityPolicyType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct GetSecurityPolicyResponse: AWSDecodableShape {
        /// Details about the requested security policy.
        public let securityPolicyDetail: SecurityPolicyDetail?

        public init(securityPolicyDetail: SecurityPolicyDetail? = nil) {
            self.securityPolicyDetail = securityPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityPolicyDetail = "securityPolicyDetail"
        }
    }

    public struct LifecyclePolicyDetail: AWSDecodableShape {
        /// The date the lifecycle policy was created.
        public let createdDate: Int64?
        /// The description of the lifecycle policy.
        public let description: String?
        /// The timestamp of when the lifecycle policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The JSON policy document without any whitespaces.
        public let policy: String?
        /// The version of the lifecycle policy.
        public let policyVersion: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policy: String? = nil, policyVersion: String? = nil, type: LifecyclePolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct LifecyclePolicyErrorDetail: AWSDecodableShape {
        /// The error code for the request. For example, NOT_FOUND.
        public let errorCode: String?
        /// A description of the error. For example, The specified Lifecycle Policy is not found.
        public let errorMessage: String?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        public init(errorCode: String? = nil, errorMessage: String? = nil, name: String? = nil, type: LifecyclePolicyType? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case name = "name"
            case type = "type"
        }
    }

    public struct LifecyclePolicyIdentifier: AWSEncodableShape {
        /// The name of the lifecycle policy.
        public let name: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        public init(name: String, type: LifecyclePolicyType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct LifecyclePolicyResourceIdentifier: AWSEncodableShape {
        /// The name of the OpenSearch Serverless ilndex resource.
        public let resource: String
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        public init(resource: String, type: LifecyclePolicyType) {
            self.resource = resource
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.resource, name: "resource", parent: name, pattern: "^index/[a-z][a-z0-9-]{3,32}/([a-z;0-9&$%][+.~=\\-_a-z;0-9&$%]*|\\*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case resource = "resource"
            case type = "type"
        }
    }

    public struct LifecyclePolicyStats: AWSDecodableShape {
        /// The number of retention lifecycle policies in the current account.
        public let retentionPolicyCount: Int64?

        public init(retentionPolicyCount: Int64? = nil) {
            self.retentionPolicyCount = retentionPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case retentionPolicyCount = "RetentionPolicyCount"
        }
    }

    public struct LifecyclePolicySummary: AWSDecodableShape {
        /// The Epoch time when the lifecycle policy was created.
        public let createdDate: Int64?
        /// The description of the lifecycle policy.
        public let description: String?
        /// The date and time when the lifecycle policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the lifecycle policy.
        public let name: String?
        /// The version of the lifecycle policy.
        public let policyVersion: String?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType?

        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policyVersion: String? = nil, type: LifecyclePolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct ListAccessPoliciesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListAccessPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListAccessPolicies operations, which returns results in the next page.
        public let nextToken: String?
        /// Resource filters (can be collections or indexes) that policies can apply to.
        public let resource: [String]?
        /// The type of access policy.
        public let type: AccessPolicyType

        public init(maxResults: Int? = nil, nextToken: String? = nil, resource: [String]? = nil, type: AccessPolicyType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resource = resource
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resource = "resource"
            case type = "type"
        }
    }

    public struct ListAccessPoliciesResponse: AWSDecodableShape {
        /// Details about the requested access policies.
        public let accessPolicySummaries: [AccessPolicySummary]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(accessPolicySummaries: [AccessPolicySummary]? = nil, nextToken: String? = nil) {
            self.accessPolicySummaries = accessPolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicySummaries = "accessPolicySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollectionsRequest: AWSEncodableShape {
        ///  A list of filter names and values that you can use for requests.
        public let collectionFilters: CollectionFilters?
        /// The maximum number of results to return. Default is 20. You can use nextToken to get the next page of results.
        public let maxResults: Int?
        /// If your initial ListCollections operation returns a nextToken, you can include the returned nextToken in subsequent ListCollections operations, which returns results in the next page.
        public let nextToken: String?

        public init(collectionFilters: CollectionFilters? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collectionFilters = collectionFilters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.collectionFilters?.validate(name: "\(name).collectionFilters")
        }

        private enum CodingKeys: String, CodingKey {
            case collectionFilters = "collectionFilters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollectionsResponse: AWSDecodableShape {
        /// Details about each collection.
        public let collectionSummaries: [CollectionSummary]?
        /// When nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(collectionSummaries: [CollectionSummary]? = nil, nextToken: String? = nil) {
            self.collectionSummaries = collectionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collectionSummaries = "collectionSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListLifecyclePoliciesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use use nextToken to get the next page of results. The default is 10.
        public let maxResults: Int?
        /// If your initial ListLifecyclePolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListLifecyclePolicies operations, which returns results in the next page.
        public let nextToken: String?
        /// Resource filters that policies can apply to. Currently, the only supported resource type is index.
        public let resources: [String]?
        /// The type of lifecycle policy.
        public let type: LifecyclePolicyType

        public init(maxResults: Int? = nil, nextToken: String? = nil, resources: [String]? = nil, type: LifecyclePolicyType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resources = resources
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resources = "resources"
            case type = "type"
        }
    }

    public struct ListLifecyclePoliciesResponse: AWSDecodableShape {
        /// Details about the requested lifecycle policies.
        public let lifecyclePolicySummaries: [LifecyclePolicySummary]?
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        public init(lifecyclePolicySummaries: [LifecyclePolicySummary]? = nil, nextToken: String? = nil) {
            self.lifecyclePolicySummaries = lifecyclePolicySummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicySummaries = "lifecyclePolicySummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListSecurityConfigsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListSecurityConfigs operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityConfigs operations, which returns results in the next page.
        public let nextToken: String?
        /// The type of security configuration.
        public let type: SecurityConfigType

        public init(maxResults: Int? = nil, nextToken: String? = nil, type: SecurityConfigType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case type = "type"
        }
    }

    public struct ListSecurityConfigsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// Details about the security configurations in your account.
        public let securityConfigSummaries: [SecurityConfigSummary]?

        public init(nextToken: String? = nil, securityConfigSummaries: [SecurityConfigSummary]? = nil) {
            self.nextToken = nextToken
            self.securityConfigSummaries = securityConfigSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case securityConfigSummaries = "securityConfigSummaries"
        }
    }

    public struct ListSecurityPoliciesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListSecurityPolicies operation returns a nextToken, you can include the returned nextToken in subsequent ListSecurityPolicies operations, which returns results in the next page.
        public let nextToken: String?
        /// Resource filters (can be collection or indexes) that policies can apply to.
        public let resource: [String]?
        /// The type of policy.
        public let type: SecurityPolicyType

        public init(maxResults: Int? = nil, nextToken: String? = nil, resource: [String]? = nil, type: SecurityPolicyType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resource = resource
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case resource = "resource"
            case type = "type"
        }
    }

    public struct ListSecurityPoliciesResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// Details about the security policies in your account.
        public let securityPolicySummaries: [SecurityPolicySummary]?

        public init(nextToken: String? = nil, securityPolicySummaries: [SecurityPolicySummary]? = nil) {
            self.nextToken = nextToken
            self.securityPolicySummaries = securityPolicySummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case securityPolicySummaries = "securityPolicySummaries"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListVpcEndpointsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 20.
        public let maxResults: Int?
        /// If your initial ListVpcEndpoints operation returns a nextToken, you can include the returned nextToken in subsequent ListVpcEndpoints operations, which returns results in the next page.
        public let nextToken: String?
        /// Filter the results according to the current status of the VPC endpoint. Possible statuses are CREATING, DELETING, UPDATING, ACTIVE, and FAILED.
        public let vpcEndpointFilters: VpcEndpointFilters?

        public init(maxResults: Int? = nil, nextToken: String? = nil, vpcEndpointFilters: VpcEndpointFilters? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.vpcEndpointFilters = vpcEndpointFilters
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case vpcEndpointFilters = "vpcEndpointFilters"
        }
    }

    public struct ListVpcEndpointsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// Details about each VPC endpoint, including the name and current status.
        public let vpcEndpointSummaries: [VpcEndpointSummary]?

        public init(nextToken: String? = nil, vpcEndpointSummaries: [VpcEndpointSummary]? = nil) {
            self.nextToken = nextToken
            self.vpcEndpointSummaries = vpcEndpointSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case vpcEndpointSummaries = "vpcEndpointSummaries"
        }
    }

    public struct SamlConfigOptions: AWSEncodableShape & AWSDecodableShape {
        /// The group attribute for this SAML integration.
        public let groupAttribute: String?
        /// The XML IdP metadata file generated from your identity provider.
        public let metadata: String
        /// The session timeout, in minutes. Default is 60 minutes (12 hours).
        public let sessionTimeout: Int?
        /// A user attribute for this SAML integration.
        public let userAttribute: String?

        public init(groupAttribute: String? = nil, metadata: String, sessionTimeout: Int? = nil, userAttribute: String? = nil) {
            self.groupAttribute = groupAttribute
            self.metadata = metadata
            self.sessionTimeout = sessionTimeout
            self.userAttribute = userAttribute
        }

        public func validate(name: String) throws {
            try self.validate(self.groupAttribute, name: "groupAttribute", parent: name, max: 2048)
            try self.validate(self.groupAttribute, name: "groupAttribute", parent: name, min: 1)
            try self.validate(self.groupAttribute, name: "groupAttribute", parent: name, pattern: "[\\w+=,.@-]+")
            try self.validate(self.metadata, name: "metadata", parent: name, max: 51200)
            try self.validate(self.metadata, name: "metadata", parent: name, min: 1)
            try self.validate(self.metadata, name: "metadata", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.userAttribute, name: "userAttribute", parent: name, max: 2048)
            try self.validate(self.userAttribute, name: "userAttribute", parent: name, min: 1)
            try self.validate(self.userAttribute, name: "userAttribute", parent: name, pattern: "[\\w+=,.@-]+")
        }

        private enum CodingKeys: String, CodingKey {
            case groupAttribute = "groupAttribute"
            case metadata = "metadata"
            case sessionTimeout = "sessionTimeout"
            case userAttribute = "userAttribute"
        }
    }

    public struct SecurityConfigDetail: AWSDecodableShape {
        /// The version of the security configuration.
        public let configVersion: String?
        /// The date the configuration was created.
        public let createdDate: Int64?
        /// The description of the security configuration.
        public let description: String?
        /// The unique identifier of the security configuration.
        public let id: String?
        /// The timestamp of when the configuration was last modified.
        public let lastModifiedDate: Int64?
        /// SAML options for the security configuration in the form of a key-value map.
        public let samlOptions: SamlConfigOptions?
        /// The type of security configuration.
        public let type: SecurityConfigType?

        public init(configVersion: String? = nil, createdDate: Int64? = nil, description: String? = nil, id: String? = nil, lastModifiedDate: Int64? = nil, samlOptions: SamlConfigOptions? = nil, type: SecurityConfigType? = nil) {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.samlOptions = samlOptions
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case configVersion = "configVersion"
            case createdDate = "createdDate"
            case description = "description"
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case samlOptions = "samlOptions"
            case type = "type"
        }
    }

    public struct SecurityConfigStats: AWSDecodableShape {
        /// The number of security configurations in the current account.
        public let samlConfigCount: Int64?

        public init(samlConfigCount: Int64? = nil) {
            self.samlConfigCount = samlConfigCount
        }

        private enum CodingKeys: String, CodingKey {
            case samlConfigCount = "SamlConfigCount"
        }
    }

    public struct SecurityConfigSummary: AWSDecodableShape {
        /// The version of the security configuration.
        public let configVersion: String?
        /// The Epoch time when the security configuration was created.
        public let createdDate: Int64?
        /// The description of the security configuration.
        public let description: String?
        /// The unique identifier of the security configuration.
        public let id: String?
        /// The timestamp of when the configuration was last modified.
        public let lastModifiedDate: Int64?
        /// The type of security configuration.
        public let type: SecurityConfigType?

        public init(configVersion: String? = nil, createdDate: Int64? = nil, description: String? = nil, id: String? = nil, lastModifiedDate: Int64? = nil, type: SecurityConfigType? = nil) {
            self.configVersion = configVersion
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case configVersion = "configVersion"
            case createdDate = "createdDate"
            case description = "description"
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case type = "type"
        }
    }

    public struct SecurityPolicyDetail: AWSDecodableShape {
        /// The date the policy was created.
        public let createdDate: Int64?
        /// The description of the security policy.
        public let description: String?
        /// The timestamp of when the policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the policy.
        public let name: String?
        /// The JSON policy document without any whitespaces.
        public let policy: String?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of security policy.
        public let type: SecurityPolicyType?

        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policy: String? = nil, policyVersion: String? = nil, type: SecurityPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct SecurityPolicyStats: AWSDecodableShape {
        /// The number of encryption policies in the current account.
        public let encryptionPolicyCount: Int64?
        /// The number of network policies in the current account.
        public let networkPolicyCount: Int64?

        public init(encryptionPolicyCount: Int64? = nil, networkPolicyCount: Int64? = nil) {
            self.encryptionPolicyCount = encryptionPolicyCount
            self.networkPolicyCount = networkPolicyCount
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionPolicyCount = "EncryptionPolicyCount"
            case networkPolicyCount = "NetworkPolicyCount"
        }
    }

    public struct SecurityPolicySummary: AWSDecodableShape {
        /// The date the policy was created.
        public let createdDate: Int64?
        /// The description of the security policy.
        public let description: String?
        /// The timestamp of when the policy was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the policy.
        public let name: String?
        /// The version of the policy.
        public let policyVersion: String?
        /// The type of security policy.
        public let type: SecurityPolicyType?

        public init(createdDate: Int64? = nil, description: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, policyVersion: String? = nil, type: SecurityPolicyType? = nil) {
            self.createdDate = createdDate
            self.description = description
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.policyVersion = policyVersion
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case description = "description"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key to use in the tag.
        public let key: String
        /// The value of the tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
        public let resourceArn: String
        /// A list of tags (key-value pairs) to add to the resource. All tag keys in the request must be unique.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove tags from. The resource must be active (not in the DELETING state), and must be owned by the account ID included in the request.
        public let resourceArn: String
        /// The tag or set of tags to remove from the resource. All tag keys in the request must be unique.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the policy.
        public let policy: String?
        /// The version of the policy being updated.
        public let policyVersion: String
        /// The type of policy.
        public let type: AccessPolicyType

        public init(clientToken: String? = UpdateAccessPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String? = nil, policyVersion: String, type: AccessPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, max: 36)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, min: 20)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct UpdateAccessPolicyResponse: AWSDecodableShape {
        /// Details about the updated access policy.
        public let accessPolicyDetail: AccessPolicyDetail?

        public init(accessPolicyDetail: AccessPolicyDetail? = nil) {
            self.accessPolicyDetail = accessPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accessPolicyDetail = "accessPolicyDetail"
        }
    }

    public struct UpdateAccountSettingsRequest: AWSEncodableShape {
        public let capacityLimits: CapacityLimits?

        public init(capacityLimits: CapacityLimits? = nil) {
            self.capacityLimits = capacityLimits
        }

        public func validate(name: String) throws {
            try self.capacityLimits?.validate(name: "\(name).capacityLimits")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityLimits = "capacityLimits"
        }
    }

    public struct UpdateAccountSettingsResponse: AWSDecodableShape {
        /// OpenSearch Serverless-related settings for the current Amazon Web Services account.
        public let accountSettingsDetail: AccountSettingsDetail?

        public init(accountSettingsDetail: AccountSettingsDetail? = nil) {
            self.accountSettingsDetail = accountSettingsDetail
        }

        private enum CodingKeys: String, CodingKey {
            case accountSettingsDetail = "accountSettingsDetail"
        }
    }

    public struct UpdateCollectionDetail: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collection.
        public let arn: String?
        /// The date and time when the collection was created.
        public let createdDate: Int64?
        /// The description of the collection.
        public let description: String?
        /// The unique identifier of the collection.
        public let id: String?
        /// The date and time when the collection was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the collection.
        public let name: String?
        /// The current status of the collection.
        public let status: CollectionStatus?
        /// The collection type.
        public let type: CollectionType?

        public init(arn: String? = nil, createdDate: Int64? = nil, description: String? = nil, id: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, status: CollectionStatus? = nil, type: CollectionType? = nil) {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdDate = "createdDate"
            case description = "description"
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct UpdateCollectionRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the collection.
        public let description: String?
        /// The unique identifier of the collection.
        public let id: String

        public init(clientToken: String? = UpdateCollectionRequest.idempotencyToken(), description: String? = nil, id: String) {
            self.clientToken = clientToken
            self.description = description
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 40)
            try self.validate(self.id, name: "id", parent: name, min: 3)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-z0-9]{3,40}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case id = "id"
        }
    }

    public struct UpdateCollectionResponse: AWSDecodableShape {
        /// Details about the updated collection.
        public let updateCollectionDetail: UpdateCollectionDetail?

        public init(updateCollectionDetail: UpdateCollectionDetail? = nil) {
            self.updateCollectionDetail = updateCollectionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case updateCollectionDetail = "updateCollectionDetail"
        }
    }

    public struct UpdateLifecyclePolicyRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the lifecycle policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the lifecycle policy.
        public let policy: String?
        /// The version of the policy being updated.
        public let policyVersion: String
        ///  The type of lifecycle policy.
        public let type: LifecyclePolicyType

        public init(clientToken: String? = UpdateLifecyclePolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String? = nil, policyVersion: String, type: LifecyclePolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, max: 36)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, min: 20)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct UpdateLifecyclePolicyResponse: AWSDecodableShape {
        /// Details about the updated lifecycle policy.
        public let lifecyclePolicyDetail: LifecyclePolicyDetail?

        public init(lifecyclePolicyDetail: LifecyclePolicyDetail? = nil) {
            self.lifecyclePolicyDetail = lifecyclePolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case lifecyclePolicyDetail = "lifecyclePolicyDetail"
        }
    }

    public struct UpdateSecurityConfigRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The version of the security configuration to be updated. You can find the most recent version of a security configuration using the GetSecurityPolicy command.
        public let configVersion: String
        /// A description of the security configuration.
        public let description: String?
        /// The security configuration identifier. For SAML the ID will be saml/&lt;accountId&gt;/&lt;idpProviderName&gt;. For example, saml/123456789123/OKTADev.
        public let id: String
        /// SAML options in in the form of a key-value map.
        public let samlOptions: SamlConfigOptions?

        public init(clientToken: String? = UpdateSecurityConfigRequest.idempotencyToken(), configVersion: String, description: String? = nil, id: String, samlOptions: SamlConfigOptions? = nil) {
            self.clientToken = clientToken
            self.configVersion = configVersion
            self.description = description
            self.id = id
            self.samlOptions = samlOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.configVersion, name: "configVersion", parent: name, max: 36)
            try self.validate(self.configVersion, name: "configVersion", parent: name, min: 20)
            try self.validate(self.configVersion, name: "configVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.samlOptions?.validate(name: "\(name).samlOptions")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configVersion = "configVersion"
            case description = "description"
            case id = "id"
            case samlOptions = "samlOptions"
        }
    }

    public struct UpdateSecurityConfigResponse: AWSDecodableShape {
        /// Details about the updated security configuration.
        public let securityConfigDetail: SecurityConfigDetail?

        public init(securityConfigDetail: SecurityConfigDetail? = nil) {
            self.securityConfigDetail = securityConfigDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityConfigDetail = "securityConfigDetail"
        }
    }

    public struct UpdateSecurityPolicyRequest: AWSEncodableShape {
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// A description of the policy. Typically used to store information about the permissions defined in the policy.
        public let description: String?
        /// The name of the policy.
        public let name: String
        /// The JSON policy document to use as the content for the new policy.
        public let policy: String?
        /// The version of the policy being updated.
        public let policyVersion: String
        /// The type of access policy.
        public let type: SecurityPolicyType

        public init(clientToken: String? = UpdateSecurityPolicyRequest.idempotencyToken(), description: String? = nil, name: String, policy: String? = nil, policyVersion: String, type: SecurityPolicyType) {
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.policy = policy
            self.policyVersion = policyVersion
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, max: 32)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z][a-z0-9-]+$")
            try self.validate(self.policy, name: "policy", parent: name, max: 20480)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "[\\u0009\\u000A\\u000D\\u0020-\\u007E\\u00A1-\\u00FF]+")
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, max: 36)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, min: 20)
            try self.validate(self.policyVersion, name: "policyVersion", parent: name, pattern: "^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case description = "description"
            case name = "name"
            case policy = "policy"
            case policyVersion = "policyVersion"
            case type = "type"
        }
    }

    public struct UpdateSecurityPolicyResponse: AWSDecodableShape {
        /// Details about the updated security policy.
        public let securityPolicyDetail: SecurityPolicyDetail?

        public init(securityPolicyDetail: SecurityPolicyDetail? = nil) {
            self.securityPolicyDetail = securityPolicyDetail
        }

        private enum CodingKeys: String, CodingKey {
            case securityPolicyDetail = "securityPolicyDetail"
        }
    }

    public struct UpdateVpcEndpointDetail: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The timestamp of when the endpoint was last modified.
        public let lastModifiedDate: Int64?
        /// The name of the endpoint.
        public let name: String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let securityGroupIds: [String]?
        /// The current status of the endpoint update process.
        public let status: VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public let subnetIds: [String]?

        public init(id: String? = nil, lastModifiedDate: Int64? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: VpcEndpointStatus? = nil, subnetIds: [String]? = nil) {
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case lastModifiedDate = "lastModifiedDate"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
        }
    }

    public struct UpdateVpcEndpointRequest: AWSEncodableShape {
        /// The unique identifiers of the security groups to add to the endpoint. Security groups define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let addSecurityGroupIds: [String]?
        /// The ID of one or more subnets to add to the endpoint.
        public let addSubnetIds: [String]?
        /// Unique, case-sensitive identifier to ensure idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the interface endpoint to update.
        public let id: String
        /// The unique identifiers of the security groups to remove from the endpoint.
        public let removeSecurityGroupIds: [String]?
        /// The unique identifiers of the subnets to remove from the endpoint.
        public let removeSubnetIds: [String]?

        public init(addSecurityGroupIds: [String]? = nil, addSubnetIds: [String]? = nil, clientToken: String? = UpdateVpcEndpointRequest.idempotencyToken(), id: String, removeSecurityGroupIds: [String]? = nil, removeSubnetIds: [String]? = nil) {
            self.addSecurityGroupIds = addSecurityGroupIds
            self.addSubnetIds = addSubnetIds
            self.clientToken = clientToken
            self.id = id
            self.removeSecurityGroupIds = removeSecurityGroupIds
            self.removeSubnetIds = removeSubnetIds
        }

        public func validate(name: String) throws {
            try self.addSecurityGroupIds?.forEach {
                try validate($0, name: "addSecurityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "addSecurityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "addSecurityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.addSecurityGroupIds, name: "addSecurityGroupIds", parent: name, max: 5)
            try self.validate(self.addSecurityGroupIds, name: "addSecurityGroupIds", parent: name, min: 1)
            try self.addSubnetIds?.forEach {
                try validate($0, name: "addSubnetIds[]", parent: name, max: 32)
                try validate($0, name: "addSubnetIds[]", parent: name, min: 1)
                try validate($0, name: "addSubnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.addSubnetIds, name: "addSubnetIds", parent: name, max: 6)
            try self.validate(self.addSubnetIds, name: "addSubnetIds", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 512)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 255)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^vpce-[0-9a-z]*$")
            try self.removeSecurityGroupIds?.forEach {
                try validate($0, name: "removeSecurityGroupIds[]", parent: name, max: 128)
                try validate($0, name: "removeSecurityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "removeSecurityGroupIds[]", parent: name, pattern: "^[\\w+\\-]+$")
            }
            try self.validate(self.removeSecurityGroupIds, name: "removeSecurityGroupIds", parent: name, max: 5)
            try self.validate(self.removeSecurityGroupIds, name: "removeSecurityGroupIds", parent: name, min: 1)
            try self.removeSubnetIds?.forEach {
                try validate($0, name: "removeSubnetIds[]", parent: name, max: 32)
                try validate($0, name: "removeSubnetIds[]", parent: name, min: 1)
                try validate($0, name: "removeSubnetIds[]", parent: name, pattern: "^subnet-([0-9a-f]{8}|[0-9a-f]{17})$")
            }
            try self.validate(self.removeSubnetIds, name: "removeSubnetIds", parent: name, max: 6)
            try self.validate(self.removeSubnetIds, name: "removeSubnetIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case addSecurityGroupIds = "addSecurityGroupIds"
            case addSubnetIds = "addSubnetIds"
            case clientToken = "clientToken"
            case id = "id"
            case removeSecurityGroupIds = "removeSecurityGroupIds"
            case removeSubnetIds = "removeSubnetIds"
        }
    }

    public struct UpdateVpcEndpointResponse: AWSDecodableShape {
        /// Details about the updated VPC endpoint.
        public let updateVpcEndpointDetail: UpdateVpcEndpointDetail?

        public init(updateVpcEndpointDetail: UpdateVpcEndpointDetail? = nil) {
            self.updateVpcEndpointDetail = updateVpcEndpointDetail
        }

        private enum CodingKeys: String, CodingKey {
            case updateVpcEndpointDetail = "UpdateVpcEndpointDetail"
        }
    }

    public struct VpcEndpointDetail: AWSDecodableShape {
        /// The date the endpoint was created.
        public let createdDate: Int64?
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The unique identifiers of the security groups that define the ports, protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let securityGroupIds: [String]?
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?
        /// The ID of the subnets from which you access OpenSearch Serverless.
        public let subnetIds: [String]?
        /// The ID of the VPC from which you access OpenSearch Serverless.
        public let vpcId: String?

        public init(createdDate: Int64? = nil, id: String? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: VpcEndpointStatus? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.createdDate = createdDate
            self.id = id
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case id = "id"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct VpcEndpointErrorDetail: AWSDecodableShape {
        /// The error code for the failed request.
        public let errorCode: String?
        /// An error message describing the reason for the failure.
        public let errorMessage: String?
        /// The unique identifier of the VPC endpoint.
        public let id: String?

        public init(errorCode: String? = nil, errorMessage: String? = nil, id: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
            case id = "id"
        }
    }

    public struct VpcEndpointFilters: AWSEncodableShape {
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?

        public init(status: VpcEndpointStatus? = nil) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
        }
    }

    public struct VpcEndpointSummary: AWSDecodableShape {
        /// The unique identifier of the endpoint.
        public let id: String?
        /// The name of the endpoint.
        public let name: String?
        /// The current status of the endpoint.
        public let status: VpcEndpointStatus?

        public init(id: String? = nil, name: String? = nil, status: VpcEndpointStatus? = nil) {
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }
}

// MARK: - Errors

/// Error enum for OpenSearchServerless
public struct OpenSearchServerlessErrorType: AWSErrorType {
    enum Code: String {
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case ocuLimitExceededException = "OcuLimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize OpenSearchServerless
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// When creating a resource, thrown when a resource with the same name already exists or is being created. When deleting a resource, thrown when the resource is not in the ACTIVE or FAILED state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Thrown when an error internal to the service occurs while processing a request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Thrown when the collection you're attempting to create results in a number of search or indexing OCUs that exceeds the account limit.
    public static var ocuLimitExceededException: Self { .init(.ocuLimitExceededException) }
    /// Thrown when accessing or deleting a resource that does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Thrown when you attempt to create more resources than the service allows based on service quotas.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Thrown when the HTTP request contains invalid input or is missing required input.
    public static var validationException: Self { .init(.validationException) }
}

extension OpenSearchServerlessErrorType: Equatable {
    public static func == (lhs: OpenSearchServerlessErrorType, rhs: OpenSearchServerlessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OpenSearchServerlessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
