//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Signer {
    // MARK: Enums

    public enum Category: String, CustomStringConvertible, Codable {
        case awsiot = "AWSIoT"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionAlgorithm: String, CustomStringConvertible, Codable {
        case ecdsa = "ECDSA"
        case rsa = "RSA"
        public var description: String { return self.rawValue }
    }

    public enum HashAlgorithm: String, CustomStringConvertible, Codable {
        case sha1 = "SHA1"
        case sha256 = "SHA256"
        public var description: String { return self.rawValue }
    }

    public enum ImageFormat: String, CustomStringConvertible, Codable {
        case json = "JSON"
        case jsondetached = "JSONDetached"
        case jsonembedded = "JSONEmbedded"
        public var description: String { return self.rawValue }
    }

    public enum SigningProfileStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case canceled = "Canceled"
        case revoked = "Revoked"
        public var description: String { return self.rawValue }
    }

    public enum SigningStatus: String, CustomStringConvertible, Codable {
        case failed = "Failed"
        case inprogress = "InProgress"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum ValidityType: String, CustomStringConvertible, Codable {
        case days = "DAYS"
        case months = "MONTHS"
        case years = "YEARS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddProfilePermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profileName", location: .uri(locationName: "profileName"))
        ]

        /// The AWS Signer action permitted as part of cross-account permissions.
        public let action: String
        /// The AWS principal receiving cross-account permissions. This may be an IAM role or another AWS account ID.
        public let principal: String
        /// The human-readable name of the signing profile.
        public let profileName: String
        /// The version of the signing profile.
        public let profileVersion: String?
        /// A unique identifier for the current profile revision.
        public let revisionId: String?
        /// A unique identifier for the cross-account permission statement.
        public let statementId: String

        public init(action: String, principal: String, profileName: String, profileVersion: String? = nil, revisionId: String? = nil, statementId: String) {
            self.action = action
            self.principal = principal
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.revisionId = revisionId
            self.statementId = statementId
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, max: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, min: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, pattern: "^[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case principal
            case profileVersion
            case revisionId
            case statementId
        }
    }

    public struct AddProfilePermissionResponse: AWSDecodableShape {
        /// A unique identifier for the current profile revision.
        public let revisionId: String?

        public init(revisionId: String? = nil) {
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case revisionId
        }
    }

    public struct CancelSigningProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profileName", location: .uri(locationName: "profileName"))
        ]

        /// The name of the signing profile to be canceled.
        public let profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSigningJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        /// The ID of the signing job on input.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSigningJobResponse: AWSDecodableShape {
        /// Date and time that the signing job was completed.
        public let completedAt: Date?
        /// Date and time that the signing job was created.
        public let createdAt: Date?
        /// The ID of the signing job on output.
        public let jobId: String?
        /// The IAM entity that initiated the signing job.
        public let jobInvoker: String?
        /// The AWS account ID of the job owner.
        public let jobOwner: String?
        /// A list of any overrides that were applied to the signing operation.
        public let overrides: SigningPlatformOverrides?
        /// A human-readable name for the signing platform associated with the signing job.
        public let platformDisplayName: String?
        /// The microcontroller platform to which your signed code image will be distributed.
        public let platformId: String?
        /// The name of the profile that initiated the signing operation.
        public let profileName: String?
        /// The version of the signing profile used to initiate the signing job.
        public let profileVersion: String?
        /// The IAM principal that requested the signing job.
        public let requestedBy: String?
        /// A revocation record if the signature generated by the signing job has been revoked. Contains a timestamp and the ID of the IAM entity that revoked the signature.
        public let revocationRecord: SigningJobRevocationRecord?
        /// Thr expiration timestamp for the signature generated by the signing job.
        public let signatureExpiresAt: Date?
        /// Name of the S3 bucket where the signed code image is saved by code signing.
        public let signedObject: SignedObject?
        /// The Amazon Resource Name (ARN) of your code signing certificate.
        public let signingMaterial: SigningMaterial?
        /// Map of user-assigned key-value pairs used during signing. These values contain any information that you specified for use in your signing job.
        public let signingParameters: [String: String]?
        /// The object that contains the name of your S3 bucket or your raw code.
        public let source: Source?
        /// Status of the signing job.
        public let status: SigningStatus?
        /// String value that contains the status reason.
        public let statusReason: String?

        public init(completedAt: Date? = nil, createdAt: Date? = nil, jobId: String? = nil, jobInvoker: String? = nil, jobOwner: String? = nil, overrides: SigningPlatformOverrides? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, requestedBy: String? = nil, revocationRecord: SigningJobRevocationRecord? = nil, signatureExpiresAt: Date? = nil, signedObject: SignedObject? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, source: Source? = nil, status: SigningStatus? = nil, statusReason: String? = nil) {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.jobId = jobId
            self.jobInvoker = jobInvoker
            self.jobOwner = jobOwner
            self.overrides = overrides
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.requestedBy = requestedBy
            self.revocationRecord = revocationRecord
            self.signatureExpiresAt = signatureExpiresAt
            self.signedObject = signedObject
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.source = source
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case completedAt
            case createdAt
            case jobId
            case jobInvoker
            case jobOwner
            case overrides
            case platformDisplayName
            case platformId
            case profileName
            case profileVersion
            case requestedBy
            case revocationRecord
            case signatureExpiresAt
            case signedObject
            case signingMaterial
            case signingParameters
            case source
            case status
            case statusReason
        }
    }

    public struct Destination: AWSEncodableShape {
        /// The S3Destination object.
        public let s3: S3Destination?

        public init(s3: S3Destination? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3
        }
    }

    public struct EncryptionAlgorithmOptions: AWSDecodableShape {
        /// The set of accepted encryption algorithms that are allowed in a code signing job.
        public let allowedValues: [EncryptionAlgorithm]
        /// The default encryption algorithm that is used by a code signing job.
        public let defaultValue: EncryptionAlgorithm

        public init(allowedValues: [EncryptionAlgorithm], defaultValue: EncryptionAlgorithm) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues
            case defaultValue
        }
    }

    public struct GetSigningPlatformRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "platformId", location: .uri(locationName: "platformId"))
        ]

        /// The ID of the target signing platform.
        public let platformId: String

        public init(platformId: String) {
            self.platformId = platformId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSigningPlatformResponse: AWSDecodableShape {
        /// The category type of the target signing platform.
        public let category: Category?
        /// The display name of the target signing platform.
        public let displayName: String?
        /// The maximum size (in MB) of the payload that can be signed by the target platform.
        public let maxSizeInMB: Int?
        /// A list of partner entities that use the target signing platform.
        public let partner: String?
        /// The ID of the target signing platform.
        public let platformId: String?
        /// A flag indicating whether signatures generated for the signing platform can be revoked.
        public let revocationSupported: Bool?
        /// A list of configurations applied to the target platform at signing.
        public let signingConfiguration: SigningConfiguration?
        /// The format of the target platform's signing image.
        public let signingImageFormat: SigningImageFormat?
        /// The validation template that is used by the target signing platform.
        public let target: String?

        public init(category: Category? = nil, displayName: String? = nil, maxSizeInMB: Int? = nil, partner: String? = nil, platformId: String? = nil, revocationSupported: Bool? = nil, signingConfiguration: SigningConfiguration? = nil, signingImageFormat: SigningImageFormat? = nil, target: String? = nil) {
            self.category = category
            self.displayName = displayName
            self.maxSizeInMB = maxSizeInMB
            self.partner = partner
            self.platformId = platformId
            self.revocationSupported = revocationSupported
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case category
            case displayName
            case maxSizeInMB
            case partner
            case platformId
            case revocationSupported
            case signingConfiguration
            case signingImageFormat
            case target
        }
    }

    public struct GetSigningProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profileName", location: .uri(locationName: "profileName")),
            AWSMemberEncoding(label: "profileOwner", location: .querystring(locationName: "profileOwner"))
        ]

        /// The name of the target signing profile.
        public let profileName: String
        /// The AWS account ID of the profile owner.
        public let profileOwner: String?

        public init(profileName: String, profileOwner: String? = nil) {
            self.profileName = profileName
            self.profileOwner = profileOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, max: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, min: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSigningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public let arn: String?
        /// A list of overrides applied by the target signing profile for signing operations.
        public let overrides: SigningPlatformOverrides?
        /// A human-readable name for the signing platform associated with the signing profile.
        public let platformDisplayName: String?
        /// The ID of the platform that is used by the target signing profile.
        public let platformId: String?
        /// The name of the target signing profile.
        public let profileName: String?
        /// The current version of the signing profile.
        public let profileVersion: String?
        /// The signing profile ARN, including the profile version.
        public let profileVersionArn: String?
        public let revocationRecord: SigningProfileRevocationRecord?
        public let signatureValidityPeriod: SignatureValidityPeriod?
        /// The ARN of the certificate that the target profile uses for signing operations.
        public let signingMaterial: SigningMaterial?
        /// A map of key-value pairs for signing operations that is attached to the target signing profile.
        public let signingParameters: [String: String]?
        /// The status of the target signing profile.
        public let status: SigningProfileStatus?
        /// Reason for the status of the target signing profile.
        public let statusReason: String?
        /// A list of tags associated with the signing profile.
        public let tags: [String: String]?

        public init(arn: String? = nil, overrides: SigningPlatformOverrides? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, profileVersionArn: String? = nil, revocationRecord: SigningProfileRevocationRecord? = nil, signatureValidityPeriod: SignatureValidityPeriod? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, status: SigningProfileStatus? = nil, statusReason: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.overrides = overrides
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
            self.revocationRecord = revocationRecord
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case overrides
            case platformDisplayName
            case platformId
            case profileName
            case profileVersion
            case profileVersionArn
            case revocationRecord
            case signatureValidityPeriod
            case signingMaterial
            case signingParameters
            case status
            case statusReason
            case tags
        }
    }

    public struct HashAlgorithmOptions: AWSDecodableShape {
        /// The set of accepted hash algorithms allowed in a code signing job.
        public let allowedValues: [HashAlgorithm]
        /// The default hash algorithm that is used in a code signing job.
        public let defaultValue: HashAlgorithm

        public init(allowedValues: [HashAlgorithm], defaultValue: HashAlgorithm) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues
            case defaultValue
        }
    }

    public struct ListProfilePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "profileName", location: .uri(locationName: "profileName"))
        ]

        /// String for specifying the next set of paginated results.
        public let nextToken: String?
        /// Name of the signing profile containing the cross-account permissions.
        public let profileName: String

        public init(nextToken: String? = nil, profileName: String) {
            self.nextToken = nextToken
            self.profileName = profileName
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfilePermissionsResponse: AWSDecodableShape {
        /// String for specifying the next set of paginated results.
        public let nextToken: String?
        /// List of permissions associated with the Signing Profile.
        public let permissions: [Permission]?
        /// Total size of the policy associated with the Signing Profile in bytes.
        public let policySizeBytes: Int?
        /// The identifier for the current revision of profile permissions.
        public let revisionId: String?

        public init(nextToken: String? = nil, permissions: [Permission]? = nil, policySizeBytes: Int? = nil, revisionId: String? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
            self.policySizeBytes = policySizeBytes
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case permissions
            case policySizeBytes
            case revisionId
        }
    }

    public struct ListSigningJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "isRevoked", location: .querystring(locationName: "isRevoked")),
            AWSMemberEncoding(label: "jobInvoker", location: .querystring(locationName: "jobInvoker")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "platformId", location: .querystring(locationName: "platformId")),
            AWSMemberEncoding(label: "requestedBy", location: .querystring(locationName: "requestedBy")),
            AWSMemberEncoding(label: "signatureExpiresAfter", location: .querystring(locationName: "signatureExpiresAfter")),
            AWSMemberEncoding(label: "signatureExpiresBefore", location: .querystring(locationName: "signatureExpiresBefore")),
            AWSMemberEncoding(label: "status", location: .querystring(locationName: "status"))
        ]

        /// Filters results to return only signing jobs with revoked signatures.
        public let isRevoked: Bool?
        /// Filters results to return only signing jobs initiated by a specified IAM entity.
        public let jobInvoker: String?
        /// Specifies the maximum number of items to return in the response. Use this parameter when paginating results. If additional items exist beyond the number you specify, the nextToken element is set in the response. Use the nextToken value in a subsequent request to retrieve additional items.
        public let maxResults: Int?
        /// String for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// The ID of microcontroller platform that you specified for the distribution of your code image.
        public let platformId: String?
        /// The IAM principal that requested the signing job.
        public let requestedBy: String?
        /// Filters results to return only signing jobs with signatures expiring after a specified timestamp.
        public let signatureExpiresAfter: Date?
        /// Filters results to return only signing jobs with signatures expiring before a specified timestamp.
        public let signatureExpiresBefore: Date?
        /// A status value with which to filter your results.
        public let status: SigningStatus?

        public init(isRevoked: Bool? = nil, jobInvoker: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, platformId: String? = nil, requestedBy: String? = nil, signatureExpiresAfter: Date? = nil, signatureExpiresBefore: Date? = nil, status: SigningStatus? = nil) {
            self.isRevoked = isRevoked
            self.jobInvoker = jobInvoker
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.platformId = platformId
            self.requestedBy = requestedBy
            self.signatureExpiresAfter = signatureExpiresAfter
            self.signatureExpiresBefore = signatureExpiresBefore
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.jobInvoker, name: "jobInvoker", parent: name, max: 12)
            try self.validate(self.jobInvoker, name: "jobInvoker", parent: name, min: 12)
            try self.validate(self.jobInvoker, name: "jobInvoker", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSigningJobsResponse: AWSDecodableShape {
        /// A list of your signing jobs.
        public let jobs: [SigningJob]?
        /// String for specifying the next set of paginated results.
        public let nextToken: String?

        public init(jobs: [SigningJob]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs
            case nextToken
        }
    }

    public struct ListSigningPlatformsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "category", location: .querystring(locationName: "category")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "partner", location: .querystring(locationName: "partner")),
            AWSMemberEncoding(label: "target", location: .querystring(locationName: "target"))
        ]

        /// The category type of a signing platform.
        public let category: String?
        /// The maximum number of results to be returned by this operation.
        public let maxResults: Int?
        /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// Any partner entities connected to a signing platform.
        public let partner: String?
        /// The validation template that is used by the target signing platform.
        public let target: String?

        public init(category: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, partner: String? = nil, target: String? = nil) {
            self.category = category
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.partner = partner
            self.target = target
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSigningPlatformsResponse: AWSDecodableShape {
        /// Value for specifying the next set of paginated results to return.
        public let nextToken: String?
        /// A list of all platforms that match the request parameters.
        public let platforms: [SigningPlatform]?

        public init(nextToken: String? = nil, platforms: [SigningPlatform]? = nil) {
            self.nextToken = nextToken
            self.platforms = platforms
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case platforms
        }
    }

    public struct ListSigningProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "includeCanceled", location: .querystring(locationName: "includeCanceled")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "platformId", location: .querystring(locationName: "platformId")),
            AWSMemberEncoding(label: "statuses", location: .querystring(locationName: "statuses"))
        ]

        /// Designates whether to include profiles with the status of CANCELED.
        public let includeCanceled: Bool?
        /// The maximum number of profiles to be returned.
        public let maxResults: Int?
        /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// Filters results to return only signing jobs initiated for a specified signing platform.
        public let platformId: String?
        /// Filters results to return only signing jobs with statuses in the specified list.
        public let statuses: [SigningProfileStatus]?

        public init(includeCanceled: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, platformId: String? = nil, statuses: [SigningProfileStatus]? = nil) {
            self.includeCanceled = includeCanceled
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.platformId = platformId
            self.statuses = statuses
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSigningProfilesResponse: AWSDecodableShape {
        /// Value for specifying the next set of paginated results to return.
        public let nextToken: String?
        /// A list of profiles that are available in the AWS account. This includes profiles with the status of CANCELED if the includeCanceled parameter is set to true.
        public let profiles: [SigningProfile]?

        public init(nextToken: String? = nil, profiles: [SigningProfile]? = nil) {
            self.nextToken = nextToken
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case profiles
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) for the signing profile.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the signing profile.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Permission: AWSDecodableShape {
        /// An AWS Signer action permitted as part of cross-account permissions.
        public let action: String?
        /// The AWS principal that has been granted a cross-account permission.
        public let principal: String?
        /// The signing profile version that a permission applies to.
        public let profileVersion: String?
        /// A unique identifier for a cross-account permission statement.
        public let statementId: String?

        public init(action: String? = nil, principal: String? = nil, profileVersion: String? = nil, statementId: String? = nil) {
            self.action = action
            self.principal = principal
            self.profileVersion = profileVersion
            self.statementId = statementId
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case principal
            case profileVersion
            case statementId
        }
    }

    public struct PutSigningProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profileName", location: .uri(locationName: "profileName"))
        ]

        /// A subfield of platform. This specifies any different configuration options that you want to apply to the chosen platform (such as a different hash-algorithm or signing-algorithm).
        public let overrides: SigningPlatformOverrides?
        /// The ID of the signing platform to be created.
        public let platformId: String
        /// The name of the signing profile to be created.
        public let profileName: String
        /// The default validity period override for any signature generated using this signing profile. If unspecified, the default is 135 months.
        public let signatureValidityPeriod: SignatureValidityPeriod?
        /// The AWS Certificate Manager certificate that will be used to sign code with the new signing profile.
        public let signingMaterial: SigningMaterial?
        /// Map of key-value pairs for signing. These can include any information that you want to use during signing.
        public let signingParameters: [String: String]?
        /// Tags to be associated with the signing profile that is being created.
        public let tags: [String: String]?

        public init(overrides: SigningPlatformOverrides? = nil, platformId: String, profileName: String, signatureValidityPeriod: SignatureValidityPeriod? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, tags: [String: String]? = nil) {
            self.overrides = overrides
            self.platformId = platformId
            self.profileName = profileName
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case overrides
            case platformId
            case signatureValidityPeriod
            case signingMaterial
            case signingParameters
            case tags
        }
    }

    public struct PutSigningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the signing profile created.
        public let arn: String?
        /// The version of the signing profile being created.
        public let profileVersion: String?
        /// The signing profile ARN, including the profile version.
        public let profileVersionArn: String?

        public init(arn: String? = nil, profileVersion: String? = nil, profileVersionArn: String? = nil) {
            self.arn = arn
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case profileVersion
            case profileVersionArn
        }
    }

    public struct RemoveProfilePermissionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profileName", location: .uri(locationName: "profileName")),
            AWSMemberEncoding(label: "revisionId", location: .querystring(locationName: "revisionId")),
            AWSMemberEncoding(label: "statementId", location: .uri(locationName: "statementId"))
        ]

        /// A human-readable name for the signing profile with permissions to be removed.
        public let profileName: String
        /// An identifier for the current revision of the signing profile permissions.
        public let revisionId: String
        /// A unique identifier for the cross-account permissions statement.
        public let statementId: String

        public init(profileName: String, revisionId: String, statementId: String) {
            self.profileName = profileName
            self.revisionId = revisionId
            self.statementId = statementId
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveProfilePermissionResponse: AWSDecodableShape {
        /// An identifier for the current revision of the profile permissions.
        public let revisionId: String?

        public init(revisionId: String? = nil) {
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case revisionId
        }
    }

    public struct RevokeSignatureRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        /// ID of the signing job to be revoked.
        public let jobId: String
        /// AWS account ID of the job owner.
        public let jobOwner: String?
        /// The reason for revoking the signing job.
        public let reason: String

        public init(jobId: String, jobOwner: String? = nil, reason: String) {
            self.jobId = jobId
            self.jobOwner = jobOwner
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.jobOwner, name: "jobOwner", parent: name, max: 12)
            try self.validate(self.jobOwner, name: "jobOwner", parent: name, min: 12)
            try self.validate(self.jobOwner, name: "jobOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.reason, name: "reason", parent: name, max: 500)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobOwner
            case reason
        }
    }

    public struct RevokeSigningProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "profileName", location: .uri(locationName: "profileName"))
        ]

        /// A timestamp for when revocation of a Signing Profile should become effective. Signatures generated using the signing profile after this timestamp are not trusted.
        public let effectiveTime: Date
        /// The name of the signing profile to be revoked.
        public let profileName: String
        /// The version of the signing profile to be revoked.
        public let profileVersion: String
        /// The reason for revoking a signing profile.
        public let reason: String

        public init(effectiveTime: Date, profileName: String, profileVersion: String, reason: String) {
            self.effectiveTime = effectiveTime
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, max: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, min: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, pattern: "^[a-zA-Z0-9]{10}$")
            try self.validate(self.reason, name: "reason", parent: name, max: 500)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveTime
            case profileVersion
            case reason
        }
    }

    public struct S3Destination: AWSEncodableShape {
        /// Name of the S3 bucket.
        public let bucketName: String?
        /// An Amazon S3 prefix that you can use to limit responses to those that begin with the specified prefix.
        public let prefix: String?

        public init(bucketName: String? = nil, prefix: String? = nil) {
            self.bucketName = bucketName
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case prefix
        }
    }

    public struct S3SignedObject: AWSDecodableShape {
        /// Name of the S3 bucket.
        public let bucketName: String?
        /// Key name that uniquely identifies a signed code image in your bucket.
        public let key: String?

        public init(bucketName: String? = nil, key: String? = nil) {
            self.bucketName = bucketName
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case key
        }
    }

    public struct S3Source: AWSEncodableShape & AWSDecodableShape {
        /// Name of the S3 bucket.
        public let bucketName: String
        /// Key name of the bucket object that contains your unsigned code.
        public let key: String
        /// Version of your source image in your version enabled S3 bucket.
        public let version: String

        public init(bucketName: String, key: String, version: String) {
            self.bucketName = bucketName
            self.key = key
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case key
            case version
        }
    }

    public struct SignatureValidityPeriod: AWSEncodableShape & AWSDecodableShape {
        /// The time unit for signature validity.
        public let type: ValidityType?
        /// The numerical value of the time unit for signature validity.
        public let value: Int?

        public init(type: ValidityType? = nil, value: Int? = nil) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type
            case value
        }
    }

    public struct SignedObject: AWSDecodableShape {
        /// The S3SignedObject.
        public let s3: S3SignedObject?

        public init(s3: S3SignedObject? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3
        }
    }

    public struct SigningConfiguration: AWSDecodableShape {
        /// The encryption algorithm options that are available for a code signing job.
        public let encryptionAlgorithmOptions: EncryptionAlgorithmOptions
        /// The hash algorithm options that are available for a code signing job.
        public let hashAlgorithmOptions: HashAlgorithmOptions

        public init(encryptionAlgorithmOptions: EncryptionAlgorithmOptions, hashAlgorithmOptions: HashAlgorithmOptions) {
            self.encryptionAlgorithmOptions = encryptionAlgorithmOptions
            self.hashAlgorithmOptions = hashAlgorithmOptions
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAlgorithmOptions
            case hashAlgorithmOptions
        }
    }

    public struct SigningConfigurationOverrides: AWSEncodableShape & AWSDecodableShape {
        /// A specified override of the default encryption algorithm that is used in a code signing job.
        public let encryptionAlgorithm: EncryptionAlgorithm?
        /// A specified override of the default hash algorithm that is used in a code signing job.
        public let hashAlgorithm: HashAlgorithm?

        public init(encryptionAlgorithm: EncryptionAlgorithm? = nil, hashAlgorithm: HashAlgorithm? = nil) {
            self.encryptionAlgorithm = encryptionAlgorithm
            self.hashAlgorithm = hashAlgorithm
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAlgorithm
            case hashAlgorithm
        }
    }

    public struct SigningImageFormat: AWSDecodableShape {
        /// The default format of a code signing image.
        public let defaultFormat: ImageFormat
        /// The supported formats of a code signing image.
        public let supportedFormats: [ImageFormat]

        public init(defaultFormat: ImageFormat, supportedFormats: [ImageFormat]) {
            self.defaultFormat = defaultFormat
            self.supportedFormats = supportedFormats
        }

        private enum CodingKeys: String, CodingKey {
            case defaultFormat
            case supportedFormats
        }
    }

    public struct SigningJob: AWSDecodableShape {
        /// The date and time that the signing job was created.
        public let createdAt: Date?
        /// Indicates whether the signing job is revoked.
        public let isRevoked: Bool?
        /// The ID of the signing job.
        public let jobId: String?
        /// The AWS account ID of the job invoker.
        public let jobInvoker: String?
        /// The AWS account ID of the job owner.
        public let jobOwner: String?
        /// The name of a signing platform.
        public let platformDisplayName: String?
        /// The unique identifier for a signing platform.
        public let platformId: String?
        /// The name of the signing profile that created a signing job.
        public let profileName: String?
        /// The version of the signing profile that created a signing job.
        public let profileVersion: String?
        /// The time when the signature of a signing job expires.
        public let signatureExpiresAt: Date?
        /// A SignedObject structure that contains information about a signing job's signed code image.
        public let signedObject: SignedObject?
        /// A SigningMaterial object that contains the Amazon Resource Name (ARN) of the certificate used for the signing job.
        public let signingMaterial: SigningMaterial?
        /// A Source that contains information about a signing job's code image source.
        public let source: Source?
        /// The status of the signing job.
        public let status: SigningStatus?

        public init(createdAt: Date? = nil, isRevoked: Bool? = nil, jobId: String? = nil, jobInvoker: String? = nil, jobOwner: String? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, signatureExpiresAt: Date? = nil, signedObject: SignedObject? = nil, signingMaterial: SigningMaterial? = nil, source: Source? = nil, status: SigningStatus? = nil) {
            self.createdAt = createdAt
            self.isRevoked = isRevoked
            self.jobId = jobId
            self.jobInvoker = jobInvoker
            self.jobOwner = jobOwner
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.signatureExpiresAt = signatureExpiresAt
            self.signedObject = signedObject
            self.signingMaterial = signingMaterial
            self.source = source
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case isRevoked
            case jobId
            case jobInvoker
            case jobOwner
            case platformDisplayName
            case platformId
            case profileName
            case profileVersion
            case signatureExpiresAt
            case signedObject
            case signingMaterial
            case source
            case status
        }
    }

    public struct SigningJobRevocationRecord: AWSDecodableShape {
        /// A caller-supplied reason for revocation.
        public let reason: String?
        /// The time of revocation.
        public let revokedAt: Date?
        /// The identity of the revoker.
        public let revokedBy: String?

        public init(reason: String? = nil, revokedAt: Date? = nil, revokedBy: String? = nil) {
            self.reason = reason
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }

        private enum CodingKeys: String, CodingKey {
            case reason
            case revokedAt
            case revokedBy
        }
    }

    public struct SigningMaterial: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificates that is used to sign your code.
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn
        }
    }

    public struct SigningPlatform: AWSDecodableShape {
        /// The category of a code signing platform.
        public let category: Category?
        /// The display name of a code signing platform.
        public let displayName: String?
        /// The maximum size (in MB) of code that can be signed by a code signing platform.
        public let maxSizeInMB: Int?
        /// Any partner entities linked to a code signing platform.
        public let partner: String?
        /// The ID of a code signing; platform.
        public let platformId: String?
        /// Indicates whether revocation is supported for the platform.
        public let revocationSupported: Bool?
        /// The configuration of a code signing platform. This includes the designated hash algorithm and encryption algorithm of a signing platform.
        public let signingConfiguration: SigningConfiguration?
        public let signingImageFormat: SigningImageFormat?
        /// The types of targets that can be signed by a code signing platform.
        public let target: String?

        public init(category: Category? = nil, displayName: String? = nil, maxSizeInMB: Int? = nil, partner: String? = nil, platformId: String? = nil, revocationSupported: Bool? = nil, signingConfiguration: SigningConfiguration? = nil, signingImageFormat: SigningImageFormat? = nil, target: String? = nil) {
            self.category = category
            self.displayName = displayName
            self.maxSizeInMB = maxSizeInMB
            self.partner = partner
            self.platformId = platformId
            self.revocationSupported = revocationSupported
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case category
            case displayName
            case maxSizeInMB
            case partner
            case platformId
            case revocationSupported
            case signingConfiguration
            case signingImageFormat
            case target
        }
    }

    public struct SigningPlatformOverrides: AWSEncodableShape & AWSDecodableShape {
        /// A signing configuration that overrides the default encryption or hash algorithm of a signing job.
        public let signingConfiguration: SigningConfigurationOverrides?
        /// A signed image is a JSON object. When overriding the default signing platform configuration, a customer can select either of two signing formats, JSONEmbedded or JSONDetached. (A third format value, JSON, is reserved for future use.) With JSONEmbedded, the signing image has the payload embedded in it. With JSONDetached, the payload is not be embedded in the signing image.
        public let signingImageFormat: ImageFormat?

        public init(signingConfiguration: SigningConfigurationOverrides? = nil, signingImageFormat: ImageFormat? = nil) {
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
        }

        private enum CodingKeys: String, CodingKey {
            case signingConfiguration
            case signingImageFormat
        }
    }

    public struct SigningProfile: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public let arn: String?
        /// The name of the signing platform.
        public let platformDisplayName: String?
        /// The ID of a platform that is available for use by a signing profile.
        public let platformId: String?
        /// The name of the signing profile.
        public let profileName: String?
        /// The version of a signing profile.
        public let profileVersion: String?
        /// The ARN of a signing profile, including the profile version.
        public let profileVersionArn: String?
        /// The validity period for a signing job created using this signing profile.
        public let signatureValidityPeriod: SignatureValidityPeriod?
        /// The ACM certificate that is available for use by a signing profile.
        public let signingMaterial: SigningMaterial?
        /// The parameters that are available for use by a code signing user.
        public let signingParameters: [String: String]?
        /// The status of a code signing profile.
        public let status: SigningProfileStatus?
        /// A list of tags associated with the signing profile.
        public let tags: [String: String]?

        public init(arn: String? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, profileVersionArn: String? = nil, signatureValidityPeriod: SignatureValidityPeriod? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, status: SigningProfileStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case platformDisplayName
            case platformId
            case profileName
            case profileVersion
            case profileVersionArn
            case signatureValidityPeriod
            case signingMaterial
            case signingParameters
            case status
            case tags
        }
    }

    public struct SigningProfileRevocationRecord: AWSDecodableShape {
        /// The time when revocation becomes effective.
        public let revocationEffectiveFrom: Date?
        /// The time when the signing profile was revoked.
        public let revokedAt: Date?
        /// The identity of the revoker.
        public let revokedBy: String?

        public init(revocationEffectiveFrom: Date? = nil, revokedAt: Date? = nil, revokedBy: String? = nil) {
            self.revocationEffectiveFrom = revocationEffectiveFrom
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }

        private enum CodingKeys: String, CodingKey {
            case revocationEffectiveFrom
            case revokedAt
            case revokedBy
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        /// The S3Source object.
        public let s3: S3Source?

        public init(s3: S3Source? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3
        }
    }

    public struct StartSigningJobRequest: AWSEncodableShape {
        /// String that identifies the signing request. All calls after the first that use this token return the same response as the first call.
        public let clientRequestToken: String
        /// The S3 bucket in which to save your signed object. The destination contains the name of your bucket and an optional prefix.
        public let destination: Destination
        /// The name of the signing profile.
        public let profileName: String
        /// The AWS account ID of the signing profile owner.
        public let profileOwner: String?
        /// The S3 bucket that contains the object to sign or a BLOB that contains your raw code.
        public let source: Source

        public init(clientRequestToken: String = StartSigningJobRequest.idempotencyToken(), destination: Destination, profileName: String, profileOwner: String? = nil, source: Source) {
            self.clientRequestToken = clientRequestToken
            self.destination = destination
            self.profileName = profileName
            self.profileOwner = profileOwner
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}")
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, max: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, min: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken
            case destination
            case profileName
            case profileOwner
            case source
        }
    }

    public struct StartSigningJobResponse: AWSDecodableShape {
        /// The ID of your signing job.
        public let jobId: String?
        /// The AWS account ID of the signing job owner.
        public let jobOwner: String?

        public init(jobId: String? = nil, jobOwner: String? = nil) {
            self.jobId = jobId
            self.jobOwner = jobOwner
        }

        private enum CodingKeys: String, CodingKey {
            case jobId
            case jobOwner
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) for the signing profile.
        public let resourceArn: String
        /// One or more tags to be associated with the signing profile.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) for the signing profile.
        public let resourceArn: String
        /// A list of tag keys to be removed from the signing profile.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }
}
