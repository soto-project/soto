//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Signer {
    // MARK: Enums

    public enum Category: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIoT = "AWSIoT"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ecdsa = "ECDSA"
        case rsa = "RSA"
        public var description: String { return self.rawValue }
    }

    public enum HashAlgorithm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sha1 = "SHA1"
        case sha256 = "SHA256"
        public var description: String { return self.rawValue }
    }

    public enum ImageFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case json = "JSON"
        case jsonDetached = "JSONDetached"
        case jsonEmbedded = "JSONEmbedded"
        public var description: String { return self.rawValue }
    }

    public enum SigningProfileStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case canceled = "Canceled"
        case revoked = "Revoked"
        public var description: String { return self.rawValue }
    }

    public enum SigningStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case succeeded = "Succeeded"
        public var description: String { return self.rawValue }
    }

    public enum ValidityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case days = "DAYS"
        case months = "MONTHS"
        case years = "YEARS"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddProfilePermissionRequest: AWSEncodableShape {
        /// The AWS Signer action permitted as part of cross-account permissions.
        public let action: String
        /// The AWS principal receiving cross-account permissions. This may be an IAM role or another
        /// 			AWS account ID.
        public let principal: String
        /// The human-readable name of the signing profile.
        public let profileName: String
        /// The version of the signing profile.
        public let profileVersion: String?
        /// A unique identifier for the current profile revision.
        public let revisionId: String?
        /// A unique identifier for the cross-account permission statement.
        public let statementId: String

        public init(action: String, principal: String, profileName: String, profileVersion: String? = nil, revisionId: String? = nil, statementId: String) {
            self.action = action
            self.principal = principal
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.revisionId = revisionId
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encode(self.principal, forKey: .principal)
            request.encodePath(self.profileName, key: "profileName")
            try container.encodeIfPresent(self.profileVersion, forKey: .profileVersion)
            try container.encodeIfPresent(self.revisionId, forKey: .revisionId)
            try container.encode(self.statementId, forKey: .statementId)
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, max: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, min: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, pattern: "^[a-zA-Z0-9]{10}$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case principal = "principal"
            case profileVersion = "profileVersion"
            case revisionId = "revisionId"
            case statementId = "statementId"
        }
    }

    public struct AddProfilePermissionResponse: AWSDecodableShape {
        /// A unique identifier for the current profile revision.
        public let revisionId: String?

        public init(revisionId: String? = nil) {
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case revisionId = "revisionId"
        }
    }

    public struct CancelSigningProfileRequest: AWSEncodableShape {
        /// The name of the signing profile to be canceled.
        public let profileName: String

        public init(profileName: String) {
            self.profileName = profileName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profileName, key: "profileName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSigningJobRequest: AWSEncodableShape {
        /// The ID of the signing job on input.
        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSigningJobResponse: AWSDecodableShape {
        /// Date and time that the signing job was completed.
        public let completedAt: Date?
        /// Date and time that the signing job was created.
        public let createdAt: Date?
        /// The ID of the signing job on output.
        public let jobId: String?
        /// The IAM entity that initiated the signing job.
        public let jobInvoker: String?
        /// The AWS account ID of the job owner.
        public let jobOwner: String?
        /// A list of any overrides that were applied to the signing operation.
        public let overrides: SigningPlatformOverrides?
        /// A human-readable name for the signing platform associated with the signing job.
        public let platformDisplayName: String?
        /// The microcontroller platform to which your signed code image will be
        /// 			distributed.
        public let platformId: String?
        /// The name of the profile that initiated the signing operation.
        public let profileName: String?
        /// The version of the signing profile used to initiate the signing job.
        public let profileVersion: String?
        /// The IAM principal that requested the signing job.
        public let requestedBy: String?
        /// A revocation record if the signature generated by the signing job has been revoked.
        /// 			Contains a timestamp and the ID of the IAM entity that revoked the signature.
        public let revocationRecord: SigningJobRevocationRecord?
        /// Thr expiration timestamp for the signature generated by the signing job.
        public let signatureExpiresAt: Date?
        /// Name of the S3 bucket where the signed code image is saved by AWS Signer.
        public let signedObject: SignedObject?
        /// The Amazon Resource Name (ARN) of your code signing certificate.
        public let signingMaterial: SigningMaterial?
        /// Map of user-assigned key-value pairs used during signing. These values contain any
        /// 			information that you specified for use in your signing job.
        public let signingParameters: [String: String]?
        /// The object that contains the name of your S3 bucket or your raw code.
        public let source: Source?
        /// Status of the signing job.
        public let status: SigningStatus?
        /// String value that contains the status reason.
        public let statusReason: String?

        public init(completedAt: Date? = nil, createdAt: Date? = nil, jobId: String? = nil, jobInvoker: String? = nil, jobOwner: String? = nil, overrides: SigningPlatformOverrides? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, requestedBy: String? = nil, revocationRecord: SigningJobRevocationRecord? = nil, signatureExpiresAt: Date? = nil, signedObject: SignedObject? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, source: Source? = nil, status: SigningStatus? = nil, statusReason: String? = nil) {
            self.completedAt = completedAt
            self.createdAt = createdAt
            self.jobId = jobId
            self.jobInvoker = jobInvoker
            self.jobOwner = jobOwner
            self.overrides = overrides
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.requestedBy = requestedBy
            self.revocationRecord = revocationRecord
            self.signatureExpiresAt = signatureExpiresAt
            self.signedObject = signedObject
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.source = source
            self.status = status
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case completedAt = "completedAt"
            case createdAt = "createdAt"
            case jobId = "jobId"
            case jobInvoker = "jobInvoker"
            case jobOwner = "jobOwner"
            case overrides = "overrides"
            case platformDisplayName = "platformDisplayName"
            case platformId = "platformId"
            case profileName = "profileName"
            case profileVersion = "profileVersion"
            case requestedBy = "requestedBy"
            case revocationRecord = "revocationRecord"
            case signatureExpiresAt = "signatureExpiresAt"
            case signedObject = "signedObject"
            case signingMaterial = "signingMaterial"
            case signingParameters = "signingParameters"
            case source = "source"
            case status = "status"
            case statusReason = "statusReason"
        }
    }

    public struct Destination: AWSEncodableShape {
        /// The S3Destination object.
        public let s3: S3Destination?

        public init(s3: S3Destination? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct EncryptionAlgorithmOptions: AWSDecodableShape {
        /// The set of accepted encryption algorithms that are allowed in a code-signing job.
        public let allowedValues: [EncryptionAlgorithm]
        /// The default encryption algorithm that is used by a code-signing job.
        public let defaultValue: EncryptionAlgorithm

        public init(allowedValues: [EncryptionAlgorithm], defaultValue: EncryptionAlgorithm) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case defaultValue = "defaultValue"
        }
    }

    public struct GetRevocationStatusRequest: AWSEncodableShape {
        /// A list of composite signed hashes that identify certificates.
        /// 		       A certificate identifier consists of a subject certificate TBS hash (signed by the
        /// 			parent CA) combined with a parent CA TBS hash (signed by the parent CA’s CA). Root
        /// 			certificates are defined as their own CA.
        /// 		       The following example shows how to calculate a hash for this parameter using OpenSSL
        /// 			commands:
        ///
        /// 			       openssl asn1parse -in childCert.pem -strparse 4 -out childCert.tbs
        /// 			       openssl sha384  childCertTbsHash
        /// 			       openssl asn1parse -in parentCert.pem -strparse 4 -out parentCert.tbs
        /// 			       openssl sha384  parentCertTbsHash xxd -p
        /// 				childCertTbsHash > certificateHash.hex xxd -p parentCertTbsHash >>
        /// 				certificateHash.hex
        /// 			       cat certificateHash.hex | tr -d '\n'
        public let certificateHashes: [String]
        /// The ARN of a signing job.
        public let jobArn: String
        /// The ID of a signing platform.
        public let platformId: String
        /// The version of a signing profile.
        public let profileVersionArn: String
        /// The timestamp of the signature that validates the profile or job.
        public let signatureTimestamp: Date

        public init(certificateHashes: [String], jobArn: String, platformId: String, profileVersionArn: String, signatureTimestamp: Date) {
            self.certificateHashes = certificateHashes
            self.jobArn = jobArn
            self.platformId = platformId
            self.profileVersionArn = profileVersionArn
            self.signatureTimestamp = signatureTimestamp
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.certificateHashes, key: "certificateHashes")
            request.encodeQuery(self.jobArn, key: "jobArn")
            request.encodeQuery(self.platformId, key: "platformId")
            request.encodeQuery(self.profileVersionArn, key: "profileVersionArn")
            request.encodeQuery(self.signatureTimestamp, key: "signatureTimestamp")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobArn, name: "jobArn", parent: name, max: 2048)
            try self.validate(self.jobArn, name: "jobArn", parent: name, min: 20)
            try self.validate(self.profileVersionArn, name: "profileVersionArn", parent: name, max: 2048)
            try self.validate(self.profileVersionArn, name: "profileVersionArn", parent: name, min: 20)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRevocationStatusResponse: AWSDecodableShape {
        /// A list of revoked entities (including zero or more of the signing profile ARN, signing job
        /// 			ARN, and certificate hashes) supplied as input to the API.
        public let revokedEntities: [String]?

        public init(revokedEntities: [String]? = nil) {
            self.revokedEntities = revokedEntities
        }

        private enum CodingKeys: String, CodingKey {
            case revokedEntities = "revokedEntities"
        }
    }

    public struct GetSigningPlatformRequest: AWSEncodableShape {
        /// The ID of the target signing platform.
        public let platformId: String

        public init(platformId: String) {
            self.platformId = platformId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.platformId, key: "platformId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSigningPlatformResponse: AWSDecodableShape {
        /// The category type of the target signing platform.
        public let category: Category?
        /// The display name of the target signing platform.
        public let displayName: String?
        /// The maximum size (in MB) of the payload that can be signed by the target
        /// 			platform.
        public let maxSizeInMB: Int?
        /// A list of partner entities that use the target signing platform.
        public let partner: String?
        /// The ID of the target signing platform.
        public let platformId: String?
        /// A flag indicating whether signatures generated for the signing platform can be
        /// 			revoked.
        public let revocationSupported: Bool?
        /// A list of configurations applied to the target platform at signing.
        public let signingConfiguration: SigningConfiguration?
        /// The format of the target platform's signing image.
        public let signingImageFormat: SigningImageFormat?
        /// The validation template that is used by the target signing platform.
        public let target: String?

        public init(category: Category? = nil, displayName: String? = nil, maxSizeInMB: Int? = nil, partner: String? = nil, platformId: String? = nil, revocationSupported: Bool? = nil, signingConfiguration: SigningConfiguration? = nil, signingImageFormat: SigningImageFormat? = nil, target: String? = nil) {
            self.category = category
            self.displayName = displayName
            self.maxSizeInMB = maxSizeInMB
            self.partner = partner
            self.platformId = platformId
            self.revocationSupported = revocationSupported
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case displayName = "displayName"
            case maxSizeInMB = "maxSizeInMB"
            case partner = "partner"
            case platformId = "platformId"
            case revocationSupported = "revocationSupported"
            case signingConfiguration = "signingConfiguration"
            case signingImageFormat = "signingImageFormat"
            case target = "target"
        }
    }

    public struct GetSigningProfileRequest: AWSEncodableShape {
        /// The name of the target signing profile.
        public let profileName: String
        /// The AWS account ID of the profile owner.
        public let profileOwner: String?

        public init(profileName: String, profileOwner: String? = nil) {
            self.profileName = profileName
            self.profileOwner = profileOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profileName, key: "profileName")
            request.encodeQuery(self.profileOwner, key: "profileOwner")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, max: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, min: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSigningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public let arn: String?
        /// A list of overrides applied by the target signing profile for signing
        /// 			operations.
        public let overrides: SigningPlatformOverrides?
        /// A human-readable name for the signing platform associated with the signing
        /// 			profile.
        public let platformDisplayName: String?
        /// The ID of the platform that is used by the target signing profile.
        public let platformId: String?
        /// The name of the target signing profile.
        public let profileName: String?
        /// The current version of the signing profile.
        public let profileVersion: String?
        /// The signing profile ARN, including the profile version.
        public let profileVersionArn: String?
        public let revocationRecord: SigningProfileRevocationRecord?
        public let signatureValidityPeriod: SignatureValidityPeriod?
        /// The ARN of the certificate that the target profile uses for signing operations.
        public let signingMaterial: SigningMaterial?
        /// A map of key-value pairs for signing operations that is attached to the target signing
        /// 			profile.
        public let signingParameters: [String: String]?
        /// The status of the target signing profile.
        public let status: SigningProfileStatus?
        /// Reason for the status of the target signing profile.
        public let statusReason: String?
        /// A list of tags associated with the signing profile.
        public let tags: [String: String]?

        public init(arn: String? = nil, overrides: SigningPlatformOverrides? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, profileVersionArn: String? = nil, revocationRecord: SigningProfileRevocationRecord? = nil, signatureValidityPeriod: SignatureValidityPeriod? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, status: SigningProfileStatus? = nil, statusReason: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.overrides = overrides
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
            self.revocationRecord = revocationRecord
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case overrides = "overrides"
            case platformDisplayName = "platformDisplayName"
            case platformId = "platformId"
            case profileName = "profileName"
            case profileVersion = "profileVersion"
            case profileVersionArn = "profileVersionArn"
            case revocationRecord = "revocationRecord"
            case signatureValidityPeriod = "signatureValidityPeriod"
            case signingMaterial = "signingMaterial"
            case signingParameters = "signingParameters"
            case status = "status"
            case statusReason = "statusReason"
            case tags = "tags"
        }
    }

    public struct HashAlgorithmOptions: AWSDecodableShape {
        /// The set of accepted hash algorithms allowed in a code-signing job.
        public let allowedValues: [HashAlgorithm]
        /// The default hash algorithm that is used in a code-signing job.
        public let defaultValue: HashAlgorithm

        public init(allowedValues: [HashAlgorithm], defaultValue: HashAlgorithm) {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case defaultValue = "defaultValue"
        }
    }

    public struct ListProfilePermissionsRequest: AWSEncodableShape {
        /// String for specifying the next set of paginated results.
        public let nextToken: String?
        /// Name of the signing profile containing the cross-account permissions.
        public let profileName: String

        public init(nextToken: String? = nil, profileName: String) {
            self.nextToken = nextToken
            self.profileName = profileName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.profileName, key: "profileName")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfilePermissionsResponse: AWSDecodableShape {
        /// String for specifying the next set of paginated results.
        public let nextToken: String?
        /// List of permissions associated with the Signing Profile.
        public let permissions: [Permission]?
        /// Total size of the policy associated with the Signing Profile in bytes.
        public let policySizeBytes: Int?
        /// The identifier for the current revision of profile permissions.
        public let revisionId: String?

        public init(nextToken: String? = nil, permissions: [Permission]? = nil, policySizeBytes: Int? = nil, revisionId: String? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
            self.policySizeBytes = policySizeBytes
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case permissions = "permissions"
            case policySizeBytes = "policySizeBytes"
            case revisionId = "revisionId"
        }
    }

    public struct ListSigningJobsRequest: AWSEncodableShape {
        /// Filters results to return only signing jobs with revoked signatures.
        public let isRevoked: Bool?
        /// Filters results to return only signing jobs initiated by a specified IAM
        /// 			entity.
        public let jobInvoker: String?
        /// Specifies the maximum number of items to return in the response. Use this parameter
        /// 			when paginating results. If additional items exist beyond the number you specify, the
        /// 				nextToken element is set in the response. Use the
        /// 				nextToken value in a subsequent request to retrieve additional items.
        ///
        public let maxResults: Int?
        /// String for specifying the next set of paginated results to return. After you receive a
        /// 			response with truncated results, use this parameter in a subsequent request. Set it to
        /// 			the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// The ID of microcontroller platform that you specified for the distribution of your
        /// 			code image.
        public let platformId: String?
        /// The IAM principal that requested the signing job.
        public let requestedBy: String?
        /// Filters results to return only signing jobs with signatures expiring after a specified
        /// 			timestamp.
        public let signatureExpiresAfter: Date?
        /// Filters results to return only signing jobs with signatures expiring before a
        /// 			specified timestamp.
        public let signatureExpiresBefore: Date?
        /// A status value with which to filter your results.
        public let status: SigningStatus?

        public init(isRevoked: Bool? = nil, jobInvoker: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, platformId: String? = nil, requestedBy: String? = nil, signatureExpiresAfter: Date? = nil, signatureExpiresBefore: Date? = nil, status: SigningStatus? = nil) {
            self.isRevoked = isRevoked
            self.jobInvoker = jobInvoker
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.platformId = platformId
            self.requestedBy = requestedBy
            self.signatureExpiresAfter = signatureExpiresAfter
            self.signatureExpiresBefore = signatureExpiresBefore
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.isRevoked, key: "isRevoked")
            request.encodeQuery(self.jobInvoker, key: "jobInvoker")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.platformId, key: "platformId")
            request.encodeQuery(self.requestedBy, key: "requestedBy")
            request.encodeQuery(self.signatureExpiresAfter, key: "signatureExpiresAfter")
            request.encodeQuery(self.signatureExpiresBefore, key: "signatureExpiresBefore")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.jobInvoker, name: "jobInvoker", parent: name, max: 12)
            try self.validate(self.jobInvoker, name: "jobInvoker", parent: name, min: 12)
            try self.validate(self.jobInvoker, name: "jobInvoker", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSigningJobsResponse: AWSDecodableShape {
        /// A list of your signing jobs.
        public let jobs: [SigningJob]?
        /// String for specifying the next set of paginated results.
        public let nextToken: String?

        public init(jobs: [SigningJob]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "jobs"
            case nextToken = "nextToken"
        }
    }

    public struct ListSigningPlatformsRequest: AWSEncodableShape {
        /// The category type of a signing platform.
        public let category: String?
        /// The maximum number of results to be returned by this operation.
        public let maxResults: Int?
        /// Value for specifying the next set of paginated results to return. After you receive a
        /// 			response with truncated results, use this parameter in a subsequent request. Set it to
        /// 			the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// Any partner entities connected to a signing platform.
        public let partner: String?
        /// The validation template that is used by the target signing platform.
        public let target: String?

        public init(category: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, partner: String? = nil, target: String? = nil) {
            self.category = category
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.partner = partner
            self.target = target
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.category, key: "category")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.partner, key: "partner")
            request.encodeQuery(self.target, key: "target")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSigningPlatformsResponse: AWSDecodableShape {
        /// Value for specifying the next set of paginated results to return.
        public let nextToken: String?
        /// A list of all platforms that match the request parameters.
        public let platforms: [SigningPlatform]?

        public init(nextToken: String? = nil, platforms: [SigningPlatform]? = nil) {
            self.nextToken = nextToken
            self.platforms = platforms
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case platforms = "platforms"
        }
    }

    public struct ListSigningProfilesRequest: AWSEncodableShape {
        /// Designates whether to include profiles with the status of
        /// 			CANCELED.
        public let includeCanceled: Bool?
        /// The maximum number of profiles to be returned.
        public let maxResults: Int?
        /// Value for specifying the next set of paginated results to return. After you receive a
        /// 			response with truncated results, use this parameter in a subsequent request. Set it to
        /// 			the value of nextToken from the response that you just received.
        public let nextToken: String?
        /// Filters results to return only signing jobs initiated for a specified signing
        /// 			platform.
        public let platformId: String?
        /// Filters results to return only signing jobs with statuses in the specified
        /// 			list.
        public let statuses: [SigningProfileStatus]?

        public init(includeCanceled: Bool? = nil, maxResults: Int? = nil, nextToken: String? = nil, platformId: String? = nil, statuses: [SigningProfileStatus]? = nil) {
            self.includeCanceled = includeCanceled
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.platformId = platformId
            self.statuses = statuses
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeCanceled, key: "includeCanceled")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.platformId, key: "platformId")
            request.encodeQuery(self.statuses, key: "statuses")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSigningProfilesResponse: AWSDecodableShape {
        /// Value for specifying the next set of paginated results to return.
        public let nextToken: String?
        /// A list of profiles that are available in the AWS account. This includes profiles with
        /// 			the status of CANCELED if the includeCanceled parameter is set
        /// 			to true.
        public let profiles: [SigningProfile]?

        public init(nextToken: String? = nil, profiles: [SigningProfile]? = nil) {
            self.nextToken = nextToken
            self.profiles = profiles
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case profiles = "profiles"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the signing profile.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct Permission: AWSDecodableShape {
        /// An AWS Signer action permitted as part of cross-account permissions.
        public let action: String?
        /// The AWS principal that has been granted a cross-account permission.
        public let principal: String?
        /// The signing profile version that a permission applies to.
        public let profileVersion: String?
        /// A unique identifier for a cross-account permission statement.
        public let statementId: String?

        public init(action: String? = nil, principal: String? = nil, profileVersion: String? = nil, statementId: String? = nil) {
            self.action = action
            self.principal = principal
            self.profileVersion = profileVersion
            self.statementId = statementId
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case principal = "principal"
            case profileVersion = "profileVersion"
            case statementId = "statementId"
        }
    }

    public struct PutSigningProfileRequest: AWSEncodableShape {
        /// A subfield of platform. This specifies any different configuration
        /// 			options that you want to apply to the chosen platform (such as a different
        /// 				hash-algorithm or signing-algorithm).
        public let overrides: SigningPlatformOverrides?
        /// The ID of the signing platform to be created.
        public let platformId: String
        /// The name of the signing profile to be created.
        public let profileName: String
        /// The default validity period override for any signature generated using this signing
        /// 			profile. If unspecified, the default is 135 months.
        public let signatureValidityPeriod: SignatureValidityPeriod?
        /// The AWS Certificate Manager certificate that will be used to sign code with the new signing
        /// 			profile.
        public let signingMaterial: SigningMaterial?
        /// Map of key-value pairs for signing. These can include any information that you want to
        /// 			use during signing.
        public let signingParameters: [String: String]?
        /// Tags to be associated with the signing profile that is being created.
        public let tags: [String: String]?

        public init(overrides: SigningPlatformOverrides? = nil, platformId: String, profileName: String, signatureValidityPeriod: SignatureValidityPeriod? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, tags: [String: String]? = nil) {
            self.overrides = overrides
            self.platformId = platformId
            self.profileName = profileName
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.overrides, forKey: .overrides)
            try container.encode(self.platformId, forKey: .platformId)
            request.encodePath(self.profileName, key: "profileName")
            try container.encodeIfPresent(self.signatureValidityPeriod, forKey: .signatureValidityPeriod)
            try container.encodeIfPresent(self.signingMaterial, forKey: .signingMaterial)
            try container.encodeIfPresent(self.signingParameters, forKey: .signingParameters)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case overrides = "overrides"
            case platformId = "platformId"
            case signatureValidityPeriod = "signatureValidityPeriod"
            case signingMaterial = "signingMaterial"
            case signingParameters = "signingParameters"
            case tags = "tags"
        }
    }

    public struct PutSigningProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the signing profile created.
        public let arn: String?
        /// The version of the signing profile being created.
        public let profileVersion: String?
        /// The signing profile ARN, including the profile version.
        public let profileVersionArn: String?

        public init(arn: String? = nil, profileVersion: String? = nil, profileVersionArn: String? = nil) {
            self.arn = arn
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case profileVersion = "profileVersion"
            case profileVersionArn = "profileVersionArn"
        }
    }

    public struct RemoveProfilePermissionRequest: AWSEncodableShape {
        /// A human-readable name for the signing profile with permissions to be removed.
        public let profileName: String
        /// An identifier for the current revision of the signing profile permissions.
        public let revisionId: String
        /// A unique identifier for the cross-account permissions statement.
        public let statementId: String

        public init(profileName: String, revisionId: String, statementId: String) {
            self.profileName = profileName
            self.revisionId = revisionId
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.profileName, key: "profileName")
            request.encodeQuery(self.revisionId, key: "revisionId")
            request.encodePath(self.statementId, key: "statementId")
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct RemoveProfilePermissionResponse: AWSDecodableShape {
        /// An identifier for the current revision of the profile permissions.
        public let revisionId: String?

        public init(revisionId: String? = nil) {
            self.revisionId = revisionId
        }

        private enum CodingKeys: String, CodingKey {
            case revisionId = "revisionId"
        }
    }

    public struct RevokeSignatureRequest: AWSEncodableShape {
        /// ID of the signing job to be revoked.
        public let jobId: String
        /// AWS account ID of the job owner.
        public let jobOwner: String?
        /// The reason for revoking the signing job.
        public let reason: String

        public init(jobId: String, jobOwner: String? = nil, reason: String) {
            self.jobId = jobId
            self.jobOwner = jobOwner
            self.reason = reason
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.jobId, key: "jobId")
            try container.encodeIfPresent(self.jobOwner, forKey: .jobOwner)
            try container.encode(self.reason, forKey: .reason)
        }

        public func validate(name: String) throws {
            try self.validate(self.jobOwner, name: "jobOwner", parent: name, max: 12)
            try self.validate(self.jobOwner, name: "jobOwner", parent: name, min: 12)
            try self.validate(self.jobOwner, name: "jobOwner", parent: name, pattern: "^[0-9]{12}$")
            try self.validate(self.reason, name: "reason", parent: name, max: 500)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case jobOwner = "jobOwner"
            case reason = "reason"
        }
    }

    public struct RevokeSigningProfileRequest: AWSEncodableShape {
        /// A timestamp for when revocation of a Signing Profile should become effective.
        /// 			Signatures generated using the signing profile after this timestamp are not
        /// 			trusted.
        public let effectiveTime: Date
        /// The name of the signing profile to be revoked.
        public let profileName: String
        /// The version of the signing profile to be revoked.
        public let profileVersion: String
        /// The reason for revoking a signing profile.
        public let reason: String

        public init(effectiveTime: Date, profileName: String, profileVersion: String, reason: String) {
            self.effectiveTime = effectiveTime
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.reason = reason
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.effectiveTime, forKey: .effectiveTime)
            request.encodePath(self.profileName, key: "profileName")
            try container.encode(self.profileVersion, forKey: .profileVersion)
            try container.encode(self.reason, forKey: .reason)
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, max: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, min: 10)
            try self.validate(self.profileVersion, name: "profileVersion", parent: name, pattern: "^[a-zA-Z0-9]{10}$")
            try self.validate(self.reason, name: "reason", parent: name, max: 500)
            try self.validate(self.reason, name: "reason", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveTime = "effectiveTime"
            case profileVersion = "profileVersion"
            case reason = "reason"
        }
    }

    public struct S3Destination: AWSEncodableShape {
        /// Name of the S3 bucket.
        public let bucketName: String?
        /// An S3 prefix that you can use to limit responses to those that begin with the specified
        /// 			prefix.
        public let prefix: String?

        public init(bucketName: String? = nil, prefix: String? = nil) {
            self.bucketName = bucketName
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case prefix = "prefix"
        }
    }

    public struct S3SignedObject: AWSDecodableShape {
        /// Name of the S3 bucket.
        public let bucketName: String?
        /// Key name that uniquely identifies a signed code image in your bucket.
        public let key: String?

        public init(bucketName: String? = nil, key: String? = nil) {
            self.bucketName = bucketName
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case key = "key"
        }
    }

    public struct S3Source: AWSEncodableShape & AWSDecodableShape {
        /// Name of the S3 bucket.
        public let bucketName: String
        /// Key name of the bucket object that contains your unsigned code.
        public let key: String
        /// Version of your source image in your version enabled S3 bucket.
        public let version: String

        public init(bucketName: String, key: String, version: String) {
            self.bucketName = bucketName
            self.key = key
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "bucketName"
            case key = "key"
            case version = "version"
        }
    }

    public struct SignPayloadRequest: AWSEncodableShape {
        /// Specifies the object digest (hash) to sign.
        public let payload: AWSBase64Data
        /// Payload content type. The single valid type is
        /// 				application/vnd.cncf.notary.payload.v1+json.
        public let payloadFormat: String
        /// The name of the signing profile.
        public let profileName: String
        /// The AWS account ID of the profile owner.
        public let profileOwner: String?

        public init(payload: AWSBase64Data, payloadFormat: String, profileName: String, profileOwner: String? = nil) {
            self.payload = payload
            self.payloadFormat = payloadFormat
            self.profileName = profileName
            self.profileOwner = profileOwner
        }

        public func validate(name: String) throws {
            try self.validate(self.payload, name: "payload", parent: name, max: 4096)
            try self.validate(self.payload, name: "payload", parent: name, min: 1)
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, max: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, min: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case payloadFormat = "payloadFormat"
            case profileName = "profileName"
            case profileOwner = "profileOwner"
        }
    }

    public struct SignPayloadResponse: AWSDecodableShape {
        /// Unique identifier of the signing job.
        public let jobId: String?
        /// The AWS account ID of the job owner.
        public let jobOwner: String?
        /// Information including the signing profile ARN and the signing job ID.
        public let metadata: [String: String]?
        /// A cryptographic signature.
        public let signature: AWSBase64Data?

        public init(jobId: String? = nil, jobOwner: String? = nil, metadata: [String: String]? = nil, signature: AWSBase64Data? = nil) {
            self.jobId = jobId
            self.jobOwner = jobOwner
            self.metadata = metadata
            self.signature = signature
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case jobOwner = "jobOwner"
            case metadata = "metadata"
            case signature = "signature"
        }
    }

    public struct SignatureValidityPeriod: AWSEncodableShape & AWSDecodableShape {
        /// The time unit for signature validity.
        public let type: ValidityType?
        /// The numerical value of the time unit for signature validity.
        public let value: Int?

        public init(type: ValidityType? = nil, value: Int? = nil) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case value = "value"
        }
    }

    public struct SignedObject: AWSDecodableShape {
        /// The S3SignedObject.
        public let s3: S3SignedObject?

        public init(s3: S3SignedObject? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct SigningConfiguration: AWSDecodableShape {
        /// The encryption algorithm options that are available for a code-signing job.
        public let encryptionAlgorithmOptions: EncryptionAlgorithmOptions
        /// The hash algorithm options that are available for a code-signing job.
        public let hashAlgorithmOptions: HashAlgorithmOptions

        public init(encryptionAlgorithmOptions: EncryptionAlgorithmOptions, hashAlgorithmOptions: HashAlgorithmOptions) {
            self.encryptionAlgorithmOptions = encryptionAlgorithmOptions
            self.hashAlgorithmOptions = hashAlgorithmOptions
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAlgorithmOptions = "encryptionAlgorithmOptions"
            case hashAlgorithmOptions = "hashAlgorithmOptions"
        }
    }

    public struct SigningConfigurationOverrides: AWSEncodableShape & AWSDecodableShape {
        /// A specified override of the default encryption algorithm that is used in a code-signing
        /// 			job.
        public let encryptionAlgorithm: EncryptionAlgorithm?
        /// A specified override of the default hash algorithm that is used in a code-signing
        /// 			job.
        public let hashAlgorithm: HashAlgorithm?

        public init(encryptionAlgorithm: EncryptionAlgorithm? = nil, hashAlgorithm: HashAlgorithm? = nil) {
            self.encryptionAlgorithm = encryptionAlgorithm
            self.hashAlgorithm = hashAlgorithm
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionAlgorithm = "encryptionAlgorithm"
            case hashAlgorithm = "hashAlgorithm"
        }
    }

    public struct SigningImageFormat: AWSDecodableShape {
        /// The default format of a signing image.
        public let defaultFormat: ImageFormat
        /// The supported formats of a signing image.
        public let supportedFormats: [ImageFormat]

        public init(defaultFormat: ImageFormat, supportedFormats: [ImageFormat]) {
            self.defaultFormat = defaultFormat
            self.supportedFormats = supportedFormats
        }

        private enum CodingKeys: String, CodingKey {
            case defaultFormat = "defaultFormat"
            case supportedFormats = "supportedFormats"
        }
    }

    public struct SigningJob: AWSDecodableShape {
        /// The date and time that the signing job was created.
        public let createdAt: Date?
        /// Indicates whether the signing job is revoked.
        public let isRevoked: Bool?
        /// The ID of the signing job.
        public let jobId: String?
        /// The AWS account ID of the job invoker.
        public let jobInvoker: String?
        /// The AWS account ID of the job owner.
        public let jobOwner: String?
        /// The name of a signing platform.
        public let platformDisplayName: String?
        /// The unique identifier for a signing platform.
        public let platformId: String?
        /// The name of the signing profile that created a signing job.
        public let profileName: String?
        /// The version of the signing profile that created a signing job.
        public let profileVersion: String?
        /// The time when the signature of a signing job expires.
        public let signatureExpiresAt: Date?
        /// A SignedObject structure that contains information about a signing job's
        /// 			signed code image.
        public let signedObject: SignedObject?
        /// A SigningMaterial object that contains the Amazon Resource Name (ARN) of
        /// 			the certificate used for the signing job.
        public let signingMaterial: SigningMaterial?
        /// A Source that contains information about a signing job's code image
        /// 			source.
        public let source: Source?
        /// The status of the signing job.
        public let status: SigningStatus?

        public init(createdAt: Date? = nil, isRevoked: Bool? = nil, jobId: String? = nil, jobInvoker: String? = nil, jobOwner: String? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, signatureExpiresAt: Date? = nil, signedObject: SignedObject? = nil, signingMaterial: SigningMaterial? = nil, source: Source? = nil, status: SigningStatus? = nil) {
            self.createdAt = createdAt
            self.isRevoked = isRevoked
            self.jobId = jobId
            self.jobInvoker = jobInvoker
            self.jobOwner = jobOwner
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.signatureExpiresAt = signatureExpiresAt
            self.signedObject = signedObject
            self.signingMaterial = signingMaterial
            self.source = source
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case isRevoked = "isRevoked"
            case jobId = "jobId"
            case jobInvoker = "jobInvoker"
            case jobOwner = "jobOwner"
            case platformDisplayName = "platformDisplayName"
            case platformId = "platformId"
            case profileName = "profileName"
            case profileVersion = "profileVersion"
            case signatureExpiresAt = "signatureExpiresAt"
            case signedObject = "signedObject"
            case signingMaterial = "signingMaterial"
            case source = "source"
            case status = "status"
        }
    }

    public struct SigningJobRevocationRecord: AWSDecodableShape {
        /// A caller-supplied reason for revocation.
        public let reason: String?
        /// The time of revocation.
        public let revokedAt: Date?
        /// The identity of the revoker.
        public let revokedBy: String?

        public init(reason: String? = nil, revokedAt: Date? = nil, revokedBy: String? = nil) {
            self.reason = reason
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "reason"
            case revokedAt = "revokedAt"
            case revokedBy = "revokedBy"
        }
    }

    public struct SigningMaterial: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the certificates that is used to sign your
        /// 			code.
        public let certificateArn: String

        public init(certificateArn: String) {
            self.certificateArn = certificateArn
        }

        private enum CodingKeys: String, CodingKey {
            case certificateArn = "certificateArn"
        }
    }

    public struct SigningPlatform: AWSDecodableShape {
        /// The category of a signing platform.
        public let category: Category?
        /// The display name of a signing platform.
        public let displayName: String?
        /// The maximum size (in MB) of code that can be signed by a signing platform.
        public let maxSizeInMB: Int?
        /// Any partner entities linked to a signing platform.
        public let partner: String?
        /// The ID of a signing platform.
        public let platformId: String?
        /// Indicates whether revocation is supported for the platform.
        public let revocationSupported: Bool?
        /// The configuration of a signing platform. This includes the designated hash algorithm and
        /// 			encryption algorithm of a signing platform.
        public let signingConfiguration: SigningConfiguration?
        public let signingImageFormat: SigningImageFormat?
        /// The types of targets that can be signed by a signing platform.
        public let target: String?

        public init(category: Category? = nil, displayName: String? = nil, maxSizeInMB: Int? = nil, partner: String? = nil, platformId: String? = nil, revocationSupported: Bool? = nil, signingConfiguration: SigningConfiguration? = nil, signingImageFormat: SigningImageFormat? = nil, target: String? = nil) {
            self.category = category
            self.displayName = displayName
            self.maxSizeInMB = maxSizeInMB
            self.partner = partner
            self.platformId = platformId
            self.revocationSupported = revocationSupported
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case displayName = "displayName"
            case maxSizeInMB = "maxSizeInMB"
            case partner = "partner"
            case platformId = "platformId"
            case revocationSupported = "revocationSupported"
            case signingConfiguration = "signingConfiguration"
            case signingImageFormat = "signingImageFormat"
            case target = "target"
        }
    }

    public struct SigningPlatformOverrides: AWSEncodableShape & AWSDecodableShape {
        /// A signing configuration that overrides the default encryption or hash algorithm of a
        /// 			signing job.
        public let signingConfiguration: SigningConfigurationOverrides?
        /// A signed image is a JSON object. When overriding the default signing platform
        /// 			configuration, a customer can select either of two signing formats,
        /// 				JSONEmbedded or JSONDetached. (A third format value,
        /// 				JSON, is reserved for future use.) With JSONEmbedded, the
        /// 			signing image has the payload embedded in it. With JSONDetached, the
        /// 			payload is not be embedded in the signing image.
        public let signingImageFormat: ImageFormat?

        public init(signingConfiguration: SigningConfigurationOverrides? = nil, signingImageFormat: ImageFormat? = nil) {
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
        }

        private enum CodingKeys: String, CodingKey {
            case signingConfiguration = "signingConfiguration"
            case signingImageFormat = "signingImageFormat"
        }
    }

    public struct SigningProfile: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public let arn: String?
        /// The name of the signing platform.
        public let platformDisplayName: String?
        /// The ID of a platform that is available for use by a signing profile.
        public let platformId: String?
        /// The name of the signing profile.
        public let profileName: String?
        /// The version of a signing profile.
        public let profileVersion: String?
        /// The ARN of a signing profile, including the profile version.
        public let profileVersionArn: String?
        /// The validity period for a signing job created using this signing profile.
        public let signatureValidityPeriod: SignatureValidityPeriod?
        /// The ACM certificate that is available for use by a signing profile.
        public let signingMaterial: SigningMaterial?
        /// The parameters that are available for use by a Signer user.
        public let signingParameters: [String: String]?
        /// The status of a signing profile.
        public let status: SigningProfileStatus?
        /// A list of tags associated with the signing profile.
        public let tags: [String: String]?

        public init(arn: String? = nil, platformDisplayName: String? = nil, platformId: String? = nil, profileName: String? = nil, profileVersion: String? = nil, profileVersionArn: String? = nil, signatureValidityPeriod: SignatureValidityPeriod? = nil, signingMaterial: SigningMaterial? = nil, signingParameters: [String: String]? = nil, status: SigningProfileStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case platformDisplayName = "platformDisplayName"
            case platformId = "platformId"
            case profileName = "profileName"
            case profileVersion = "profileVersion"
            case profileVersionArn = "profileVersionArn"
            case signatureValidityPeriod = "signatureValidityPeriod"
            case signingMaterial = "signingMaterial"
            case signingParameters = "signingParameters"
            case status = "status"
            case tags = "tags"
        }
    }

    public struct SigningProfileRevocationRecord: AWSDecodableShape {
        /// The time when revocation becomes effective.
        public let revocationEffectiveFrom: Date?
        /// The time when the signing profile was revoked.
        public let revokedAt: Date?
        /// The identity of the revoker.
        public let revokedBy: String?

        public init(revocationEffectiveFrom: Date? = nil, revokedAt: Date? = nil, revokedBy: String? = nil) {
            self.revocationEffectiveFrom = revocationEffectiveFrom
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }

        private enum CodingKeys: String, CodingKey {
            case revocationEffectiveFrom = "revocationEffectiveFrom"
            case revokedAt = "revokedAt"
            case revokedBy = "revokedBy"
        }
    }

    public struct Source: AWSEncodableShape & AWSDecodableShape {
        /// The S3Source object.
        public let s3: S3Source?

        public init(s3: S3Source? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct StartSigningJobRequest: AWSEncodableShape {
        /// String that identifies the signing request. All calls after the first that use this
        /// 			token return the same response as the first call.
        public let clientRequestToken: String
        /// The S3 bucket in which to save your signed object. The destination contains the name
        /// 			of your bucket and an optional prefix.
        public let destination: Destination
        /// The name of the signing profile.
        public let profileName: String
        /// The AWS account ID of the signing profile owner.
        public let profileOwner: String?
        /// The S3 bucket that contains the object to sign or a BLOB that contains your raw
        /// 			code.
        public let source: Source

        public init(clientRequestToken: String = StartSigningJobRequest.idempotencyToken(), destination: Destination, profileName: String, profileOwner: String? = nil, source: Source) {
            self.clientRequestToken = clientRequestToken
            self.destination = destination
            self.profileName = profileName
            self.profileOwner = profileOwner
            self.source = source
        }

        public func validate(name: String) throws {
            try self.validate(self.profileName, name: "profileName", parent: name, max: 64)
            try self.validate(self.profileName, name: "profileName", parent: name, min: 2)
            try self.validate(self.profileName, name: "profileName", parent: name, pattern: "^[a-zA-Z0-9_]{2,}$")
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, max: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, min: 12)
            try self.validate(self.profileOwner, name: "profileOwner", parent: name, pattern: "^[0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case destination = "destination"
            case profileName = "profileName"
            case profileOwner = "profileOwner"
            case source = "source"
        }
    }

    public struct StartSigningJobResponse: AWSDecodableShape {
        /// The ID of your signing job.
        public let jobId: String?
        /// The AWS account ID of the signing job owner.
        public let jobOwner: String?

        public init(jobId: String? = nil, jobOwner: String? = nil) {
            self.jobId = jobId
            self.jobOwner = jobOwner
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "jobId"
            case jobOwner = "jobOwner"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public let resourceArn: String
        /// One or more tags to be associated with the signing profile.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public let resourceArn: String
        /// A list of tag keys to be removed from the signing profile.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }
}

// MARK: - Errors

/// Error enum for Signer
public struct SignerErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalServiceErrorException = "InternalServiceErrorException"
        case notFoundException = "NotFoundException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceLimitExceededException = "ServiceLimitExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyRequestsException = "TooManyRequestsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Signer
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request contains invalid parameters for the ARN or tags. This exception also
    /// 			occurs when you call a tagging API on a cancelled signing profile.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The resource encountered a conflicting state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal error occurred.
    public static var internalServiceErrorException: Self { .init(.internalServiceErrorException) }
    /// The signing profile was not found.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// A specified resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The client is making a request that exceeds service limits.
    public static var serviceLimitExceededException: Self { .init(.serviceLimitExceededException) }
    /// The request was denied due to request throttling.
    /// 		       Instead of this error, TooManyRequestsException should be used.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The allowed number of job-signing requests has been exceeded.
    /// 		       This error supersedes the error ThrottlingException.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// You signing certificate could not be validated.
    public static var validationException: Self { .init(.validationException) }
}

extension SignerErrorType: Equatable {
    public static func == (lhs: SignerErrorType, rhs: SignerErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension SignerErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
