//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension ChimeSDKMediaPipelines {
    // MARK: Enums

    public enum ArtifactsConcatenationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactsState: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum AudioArtifactsConcatenationState: String, CustomStringConvertible, Codable, _SotoSendable {
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum AudioChannelsOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case mono = "Mono"
        case stereo = "Stereo"
        public var description: String { return self.rawValue }
    }

    public enum AudioMuxType: String, CustomStringConvertible, Codable, _SotoSendable {
        case audioOnly = "AudioOnly"
        case audioWithActiveSpeakerVideo = "AudioWithActiveSpeakerVideo"
        case audioWithCompositedVideo = "AudioWithCompositedVideo"
        public var description: String { return self.rawValue }
    }

    public enum ConcatenationSinkType: String, CustomStringConvertible, Codable, _SotoSendable {
        case s3Bucket = "S3Bucket"
        public var description: String { return self.rawValue }
    }

    public enum ConcatenationSourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case mediaCapturePipeline = "MediaCapturePipeline"
        public var description: String { return self.rawValue }
    }

    public enum ContentMuxType: String, CustomStringConvertible, Codable, _SotoSendable {
        case contentOnly = "ContentOnly"
        public var description: String { return self.rawValue }
    }

    public enum ContentShareLayoutOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case horizontal = "Horizontal"
        case presenterOnly = "PresenterOnly"
        case vertical = "Vertical"
        public var description: String { return self.rawValue }
    }

    public enum LayoutOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case gridView = "GridView"
        public var description: String { return self.rawValue }
    }

    public enum LiveConnectorMuxType: String, CustomStringConvertible, Codable, _SotoSendable {
        case audioWithActiveSpeakerVideo = "AudioWithActiveSpeakerVideo"
        case audioWithCompositedVideo = "AudioWithCompositedVideo"
        public var description: String { return self.rawValue }
    }

    public enum LiveConnectorSinkType: String, CustomStringConvertible, Codable, _SotoSendable {
        case rtmp = "RTMP"
        public var description: String { return self.rawValue }
    }

    public enum LiveConnectorSourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case chimeSdkMeeting = "ChimeSdkMeeting"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineSinkType: String, CustomStringConvertible, Codable, _SotoSendable {
        case s3Bucket = "S3Bucket"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineSourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case chimeSdkMeeting = "ChimeSdkMeeting"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case initializing = "Initializing"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum PresenterPosition: String, CustomStringConvertible, Codable, _SotoSendable {
        case bottomLeft = "BottomLeft"
        case bottomRight = "BottomRight"
        case topLeft = "TopLeft"
        case topRight = "TopRight"
        public var description: String { return self.rawValue }
    }

    public enum ResolutionOption: String, CustomStringConvertible, Codable, _SotoSendable {
        case fhd = "FHD"
        case hd = "HD"
        public var description: String { return self.rawValue }
    }

    public enum VideoMuxType: String, CustomStringConvertible, Codable, _SotoSendable {
        case videoOnly = "VideoOnly"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ArtifactsConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the audio artifacts concatenation.
        public let audio: AudioConcatenationConfiguration
        /// The configuration for the composited video artifacts concatenation.
        public let compositedVideo: CompositedVideoConcatenationConfiguration
        /// The configuration for the content artifacts concatenation.
        public let content: ContentConcatenationConfiguration
        /// The configuration for the data channel artifacts concatenation.
        public let dataChannel: DataChannelConcatenationConfiguration
        /// The configuration for the meeting events artifacts concatenation.
        public let meetingEvents: MeetingEventsConcatenationConfiguration
        /// The configuration for the transcription messages artifacts concatenation.
        public let transcriptionMessages: TranscriptionMessagesConcatenationConfiguration
        /// The configuration for the video artifacts concatenation.
        public let video: VideoConcatenationConfiguration

        public init(audio: AudioConcatenationConfiguration, compositedVideo: CompositedVideoConcatenationConfiguration, content: ContentConcatenationConfiguration, dataChannel: DataChannelConcatenationConfiguration, meetingEvents: MeetingEventsConcatenationConfiguration, transcriptionMessages: TranscriptionMessagesConcatenationConfiguration, video: VideoConcatenationConfiguration) {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.dataChannel = dataChannel
            self.meetingEvents = meetingEvents
            self.transcriptionMessages = transcriptionMessages
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
            case compositedVideo = "CompositedVideo"
            case content = "Content"
            case dataChannel = "DataChannel"
            case meetingEvents = "MeetingEvents"
            case transcriptionMessages = "TranscriptionMessages"
            case video = "Video"
        }
    }

    public struct ArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the audio artifacts.
        public let audio: AudioArtifactsConfiguration
        /// Enables video compositing.
        public let compositedVideo: CompositedVideoArtifactsConfiguration?
        /// The configuration for the content artifacts.
        public let content: ContentArtifactsConfiguration
        /// The configuration for the video artifacts.
        public let video: VideoArtifactsConfiguration

        public init(audio: AudioArtifactsConfiguration, compositedVideo: CompositedVideoArtifactsConfiguration? = nil, content: ContentArtifactsConfiguration, video: VideoArtifactsConfiguration) {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
            case compositedVideo = "CompositedVideo"
            case content = "Content"
            case video = "Video"
        }
    }

    public struct AudioArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The MUX type of the audio artifact configuration object.
        public let muxType: AudioMuxType

        public init(muxType: AudioMuxType) {
            self.muxType = muxType
        }

        private enum CodingKeys: String, CodingKey {
            case muxType = "MuxType"
        }
    }

    public struct AudioConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables the name object, where name  is the name of the configuration object, such as AudioConcatenation.
        public let state: AudioArtifactsConcatenationState

        public init(state: AudioArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct ChimeSdkMeetingConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting concatenation.
        public let artifactsConfiguration: ArtifactsConcatenationConfiguration

        public init(artifactsConfiguration: ArtifactsConcatenationConfiguration) {
            self.artifactsConfiguration = artifactsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case artifactsConfiguration = "ArtifactsConfiguration"
        }
    }

    public struct ChimeSdkMeetingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public let artifactsConfiguration: ArtifactsConfiguration?
        /// The source configuration for a specified media pipline.
        public let sourceConfiguration: SourceConfiguration?

        public init(artifactsConfiguration: ArtifactsConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil) {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactsConfiguration = "ArtifactsConfiguration"
            case sourceConfiguration = "SourceConfiguration"
        }
    }

    public struct ChimeSdkMeetingLiveConnectorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration object's Chime SDK meeting ARN.
        public let arn: String
        /// The media pipeline's composited video.
        public let compositedVideo: CompositedVideoArtifactsConfiguration?
        /// The configuration object's multiplex type.
        public let muxType: LiveConnectorMuxType
        /// The source configuration settings of the media pipeline's configuration object.
        public let sourceConfiguration: SourceConfiguration?

        public init(arn: String, compositedVideo: CompositedVideoArtifactsConfiguration? = nil, muxType: LiveConnectorMuxType, sourceConfiguration: SourceConfiguration? = nil) {
            self.arn = arn
            self.compositedVideo = compositedVideo
            self.muxType = muxType
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1024)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case compositedVideo = "CompositedVideo"
            case muxType = "MuxType"
            case sourceConfiguration = "SourceConfiguration"
        }
    }

    public struct CompositedVideoArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The GridView configuration setting.
        public let gridViewConfiguration: GridViewConfiguration
        /// The layout setting, such as GridView in the configuration object.
        public let layout: LayoutOption?
        /// The video resolution setting in the configuration object. Default: HD at 1280 x 720. FHD resolution: 1920 x 1080.
        public let resolution: ResolutionOption?

        public init(gridViewConfiguration: GridViewConfiguration, layout: LayoutOption? = nil, resolution: ResolutionOption? = nil) {
            self.gridViewConfiguration = gridViewConfiguration
            self.layout = layout
            self.resolution = resolution
        }

        private enum CodingKeys: String, CodingKey {
            case gridViewConfiguration = "GridViewConfiguration"
            case layout = "Layout"
            case resolution = "Resolution"
        }
    }

    public struct CompositedVideoConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct ConcatenationSink: AWSEncodableShape & AWSDecodableShape {
        /// The configuration settings for an Amazon S3 bucket sink.
        public let s3BucketSinkConfiguration: S3BucketSinkConfiguration
        /// The type of data sink in the configuration object.
        public let type: ConcatenationSinkType

        public init(s3BucketSinkConfiguration: S3BucketSinkConfiguration, type: ConcatenationSinkType) {
            self.s3BucketSinkConfiguration = s3BucketSinkConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.s3BucketSinkConfiguration.validate(name: "\(name).s3BucketSinkConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketSinkConfiguration = "S3BucketSinkConfiguration"
            case type = "Type"
        }
    }

    public struct ConcatenationSource: AWSEncodableShape & AWSDecodableShape {
        /// The concatenation settings for the media pipeline in a configuration object.
        public let mediaCapturePipelineSourceConfiguration: MediaCapturePipelineSourceConfiguration
        /// The type of concatenation source in a configuration object.
        public let type: ConcatenationSourceType

        public init(mediaCapturePipelineSourceConfiguration: MediaCapturePipelineSourceConfiguration, type: ConcatenationSourceType) {
            self.mediaCapturePipelineSourceConfiguration = mediaCapturePipelineSourceConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.mediaCapturePipelineSourceConfiguration.validate(name: "\(name).mediaCapturePipelineSourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipelineSourceConfiguration = "MediaCapturePipelineSourceConfiguration"
            case type = "Type"
        }
    }

    public struct ContentArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The MUX type of the artifact configuration.
        public let muxType: ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        public let state: ArtifactsState

        public init(muxType: ContentMuxType? = nil, state: ArtifactsState) {
            self.muxType = muxType
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case muxType = "MuxType"
            case state = "State"
        }
    }

    public struct ContentConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct CreateMediaCapturePipelineRequest: AWSEncodableShape {
        /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
        public let chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration?
        /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.
        public let clientRequestToken: String?
        /// The ARN of the sink type.
        public let sinkArn: String
        /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
        public let sinkType: MediaPipelineSinkType
        /// ARN of the source from which the media artifacts are captured.
        public let sourceArn: String
        /// Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.
        public let sourceType: MediaPipelineSourceType
        /// The tag key-value pairs.
        public let tags: [Tag]?

        public init(chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration? = nil, clientRequestToken: String? = CreateMediaCapturePipelineRequest.idempotencyToken(), sinkArn: String, sinkType: MediaPipelineSinkType, sourceArn: String, sourceType: MediaPipelineSourceType, tags: [Tag]? = nil) {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.clientRequestToken = clientRequestToken
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.chimeSdkMeetingConfiguration?.validate(name: "\(name).chimeSdkMeetingConfiguration")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, max: 1024)
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, min: 1)
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 1024)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 1)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
            case clientRequestToken = "ClientRequestToken"
            case sinkArn = "SinkArn"
            case sinkType = "SinkType"
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
            case tags = "Tags"
        }
    }

    public struct CreateMediaCapturePipelineResponse: AWSDecodableShape {
        /// A media pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media pipeline object.
        public let mediaCapturePipeline: MediaCapturePipeline?

        public init(mediaCapturePipeline: MediaCapturePipeline? = nil) {
            self.mediaCapturePipeline = mediaCapturePipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipeline = "MediaCapturePipeline"
        }
    }

    public struct CreateMediaConcatenationPipelineRequest: AWSEncodableShape {
        /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media concatenation pipeline request.
        public let clientRequestToken: String?
        /// An object that specifies the data sinks for the media concatenation pipeline.
        public let sinks: [ConcatenationSink]
        /// An object that specifies the sources for the media concatenation pipeline.
        public let sources: [ConcatenationSource]
        /// The tags associated with the media concatenation pipeline.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaConcatenationPipelineRequest.idempotencyToken(), sinks: [ConcatenationSink], sources: [ConcatenationSource], tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.sinks = sinks
            self.sources = sources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.sinks.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.validate(self.sinks, name: "sinks", parent: name, max: 1)
            try self.validate(self.sinks, name: "sinks", parent: name, min: 1)
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case sinks = "Sinks"
            case sources = "Sources"
            case tags = "Tags"
        }
    }

    public struct CreateMediaConcatenationPipelineResponse: AWSDecodableShape {
        /// A media concatenation pipeline object, the ID, source type, MediaPipelineARN, and sink of a media concatenation pipeline object.
        public let mediaConcatenationPipeline: MediaConcatenationPipeline?

        public init(mediaConcatenationPipeline: MediaConcatenationPipeline? = nil) {
            self.mediaConcatenationPipeline = mediaConcatenationPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaConcatenationPipeline = "MediaConcatenationPipeline"
        }
    }

    public struct CreateMediaLiveConnectorPipelineRequest: AWSEncodableShape {
        /// The token assigned to the client making the request.
        public let clientRequestToken: String?
        /// The media pipeline's data sinks.
        public let sinks: [LiveConnectorSinkConfiguration]
        /// The media pipeline's data sources.
        public let sources: [LiveConnectorSourceConfiguration]
        /// The tags associated with the media pipeline.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaLiveConnectorPipelineRequest.idempotencyToken(), sinks: [LiveConnectorSinkConfiguration], sources: [LiveConnectorSourceConfiguration], tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.sinks = sinks
            self.sources = sources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.sinks.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.validate(self.sinks, name: "sinks", parent: name, max: 1)
            try self.validate(self.sinks, name: "sinks", parent: name, min: 1)
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case sinks = "Sinks"
            case sources = "Sources"
            case tags = "Tags"
        }
    }

    public struct CreateMediaLiveConnectorPipelineResponse: AWSDecodableShape {
        /// The new media pipeline.
        public let mediaLiveConnectorPipeline: MediaLiveConnectorPipeline?

        public init(mediaLiveConnectorPipeline: MediaLiveConnectorPipeline? = nil) {
            self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
        }
    }

    public struct DataChannelConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct DeleteMediaCapturePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mediaPipelineId", location: .uri("MediaPipelineId"))
        ]

        /// The ID of the media pipeline being deleted.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMediaPipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mediaPipelineId", location: .uri("MediaPipelineId"))
        ]

        /// The ID of the media pipeline to delete.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaCapturePipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mediaPipelineId", location: .uri("MediaPipelineId"))
        ]

        /// The ID of the pipeline that you want to get.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaCapturePipelineResponse: AWSDecodableShape {
        /// The media pipeline object.
        public let mediaCapturePipeline: MediaCapturePipeline?

        public init(mediaCapturePipeline: MediaCapturePipeline? = nil) {
            self.mediaCapturePipeline = mediaCapturePipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipeline = "MediaCapturePipeline"
        }
    }

    public struct GetMediaPipelineRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "mediaPipelineId", location: .uri("MediaPipelineId"))
        ]

        /// The ID of the pipeline that you want to get.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaPipelineResponse: AWSDecodableShape {
        /// The media pipeline object.
        public let mediaPipeline: MediaPipeline?

        public init(mediaPipeline: MediaPipeline? = nil) {
            self.mediaPipeline = mediaPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipeline = "MediaPipeline"
        }
    }

    public struct GridViewConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the layout of the video tiles when content sharing is enabled.
        public let contentShareLayout: ContentShareLayoutOption
        /// Defines the configuration options for a presenter only video tile.
        public let presenterOnlyConfiguration: PresenterOnlyConfiguration?

        public init(contentShareLayout: ContentShareLayoutOption, presenterOnlyConfiguration: PresenterOnlyConfiguration? = nil) {
            self.contentShareLayout = contentShareLayout
            self.presenterOnlyConfiguration = presenterOnlyConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case contentShareLayout = "ContentShareLayout"
            case presenterOnlyConfiguration = "PresenterOnlyConfiguration"
        }
    }

    public struct ListMediaCapturePipelinesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
        public let maxResults: Int?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMediaCapturePipelinesResponse: AWSDecodableShape {
        /// The media pipeline objects in the list.
        public let mediaCapturePipelines: [MediaCapturePipelineSummary]?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(mediaCapturePipelines: [MediaCapturePipelineSummary]? = nil, nextToken: String? = nil) {
            self.mediaCapturePipelines = mediaCapturePipelines
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipelines = "MediaCapturePipelines"
            case nextToken = "NextToken"
        }
    }

    public struct ListMediaPipelinesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("next-token"))
        ]

        /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
        public let maxResults: Int?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMediaPipelinesResponse: AWSDecodableShape {
        /// The media pipeline objects in the list.
        public let mediaPipelines: [MediaPipelineSummary]?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(mediaPipelines: [MediaPipelineSummary]? = nil, nextToken: String? = nil) {
            self.mediaPipelines = mediaPipelines
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipelines = "MediaPipelines"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceARN", location: .querystring("arn"))
        ]

        /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's region, resource ID, and pipeline ID.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the specified media pipeline.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LiveConnectorRTMPConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The audio channels set for the RTMP configuration
        public let audioChannels: AudioChannelsOption?
        /// The audio sample rate set for the RTMP configuration. Default: 48000.
        public let audioSampleRate: String?
        /// The URL of the RTMP configuration.
        public let url: String

        public init(audioChannels: AudioChannelsOption? = nil, audioSampleRate: String? = nil, url: String) {
            self.audioChannels = audioChannels
            self.audioSampleRate = audioSampleRate
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.audioSampleRate, name: "audioSampleRate", parent: name, pattern: "^44100|48000$")
            try self.validate(self.url, name: "url", parent: name, max: 1024)
            try self.validate(self.url, name: "url", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audioChannels = "AudioChannels"
            case audioSampleRate = "AudioSampleRate"
            case url = "Url"
        }
    }

    public struct LiveConnectorSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sink configuration's RTMP configuration setttings.
        public let rtmpConfiguration: LiveConnectorRTMPConfiguration
        /// The sink configuration's sink type.
        public let sinkType: LiveConnectorSinkType

        public init(rtmpConfiguration: LiveConnectorRTMPConfiguration, sinkType: LiveConnectorSinkType) {
            self.rtmpConfiguration = rtmpConfiguration
            self.sinkType = sinkType
        }

        public func validate(name: String) throws {
            try self.rtmpConfiguration.validate(name: "\(name).rtmpConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case rtmpConfiguration = "RTMPConfiguration"
            case sinkType = "SinkType"
        }
    }

    public struct LiveConnectorSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration settings of the connector pipeline.
        public let chimeSdkMeetingLiveConnectorConfiguration: ChimeSdkMeetingLiveConnectorConfiguration
        /// The source configuration's media source type.
        public let sourceType: LiveConnectorSourceType

        public init(chimeSdkMeetingLiveConnectorConfiguration: ChimeSdkMeetingLiveConnectorConfiguration, sourceType: LiveConnectorSourceType) {
            self.chimeSdkMeetingLiveConnectorConfiguration = chimeSdkMeetingLiveConnectorConfiguration
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.chimeSdkMeetingLiveConnectorConfiguration.validate(name: "\(name).chimeSdkMeetingLiveConnectorConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingLiveConnectorConfiguration = "ChimeSdkMeetingLiveConnectorConfiguration"
            case sourceType = "SourceType"
        }
    }

    public struct MediaCapturePipeline: AWSDecodableShape {
        /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
        public let chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration?
        /// The time at which the pipeline was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The ARN of the media capture pipeline
        public let mediaPipelineArn: String?
        /// The ID of a media pipeline.
        public let mediaPipelineId: String?
        /// ARN of the destination to which the media artifacts are saved.
        public let sinkArn: String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public let sinkType: MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts are saved.
        public let sourceArn: String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public let sourceType: MediaPipelineSourceType?
        /// The status of the media pipeline.
        public let status: MediaPipelineStatus?
        /// The time at which the pipeline was updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration? = nil, createdTimestamp: Date? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, sinkArn: String? = nil, sinkType: MediaPipelineSinkType? = nil, sourceArn: String? = nil, sourceType: MediaPipelineSourceType? = nil, status: MediaPipelineStatus? = nil, updatedTimestamp: Date? = nil) {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
            case createdTimestamp = "CreatedTimestamp"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case sinkArn = "SinkArn"
            case sinkType = "SinkType"
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
            case status = "Status"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaCapturePipelineSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The meeting configuration settings in a media capture pipeline configuration object.
        public let chimeSdkMeetingConfiguration: ChimeSdkMeetingConcatenationConfiguration
        /// The media pipeline ARN in the configuration object of a media capture pipeline.
        public let mediaPipelineArn: String

        public init(chimeSdkMeetingConfiguration: ChimeSdkMeetingConcatenationConfiguration, mediaPipelineArn: String) {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.mediaPipelineArn = mediaPipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineArn, name: "mediaPipelineArn", parent: name, max: 1024)
            try self.validate(self.mediaPipelineArn, name: "mediaPipelineArn", parent: name, min: 1)
            try self.validate(self.mediaPipelineArn, name: "mediaPipelineArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
            case mediaPipelineArn = "MediaPipelineArn"
        }
    }

    public struct MediaCapturePipelineSummary: AWSDecodableShape {
        /// The ARN of the media pipeline in the summary.
        public let mediaPipelineArn: String?
        /// The ID of the media pipeline in the summary.
        public let mediaPipelineId: String?

        public init(mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil) {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
        }
    }

    public struct MediaConcatenationPipeline: AWSDecodableShape {
        /// The time at which the concatenation pipeline was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The ARN of the media pipeline that you specify in the SourceConfiguration object.
        public let mediaPipelineArn: String?
        /// The ID of the media pipeline being concatenated.
        public let mediaPipelineId: String?
        /// The data sinks of the concatenation pipeline.
        public let sinks: [ConcatenationSink]?
        /// The data sources being concatnated.
        public let sources: [ConcatenationSource]?
        /// The status of the concatenation pipeline.
        public let status: MediaPipelineStatus?
        /// The time at which the concatenation pipeline was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, sinks: [ConcatenationSink]? = nil, sources: [ConcatenationSource]? = nil, status: MediaPipelineStatus? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case sinks = "Sinks"
            case sources = "Sources"
            case status = "Status"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaLiveConnectorPipeline: AWSDecodableShape {
        /// Thetime at which the connector pipeline was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The connector pipeline's ARN.
        public let mediaPipelineArn: String?
        /// The connector pipeline's ID.
        public let mediaPipelineId: String?
        /// The connector pipeline's data sinks.
        public let sinks: [LiveConnectorSinkConfiguration]?
        /// The connector pipeline's data sources.
        public let sources: [LiveConnectorSourceConfiguration]?
        /// The connector pipeline's status.
        public let status: MediaPipelineStatus?
        /// The time at which the connector pipeline was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, sinks: [LiveConnectorSinkConfiguration]? = nil, sources: [LiveConnectorSourceConfiguration]? = nil, status: MediaPipelineStatus? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case sinks = "Sinks"
            case sources = "Sources"
            case status = "Status"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaPipeline: AWSDecodableShape {
        /// A pipeline that enables users to capture audio and video.
        public let mediaCapturePipeline: MediaCapturePipeline?
        /// The media concatenation pipeline in a media pipeline.
        public let mediaConcatenationPipeline: MediaConcatenationPipeline?
        /// The connector pipeline of the media pipeline.
        public let mediaLiveConnectorPipeline: MediaLiveConnectorPipeline?

        public init(mediaCapturePipeline: MediaCapturePipeline? = nil, mediaConcatenationPipeline: MediaConcatenationPipeline? = nil, mediaLiveConnectorPipeline: MediaLiveConnectorPipeline? = nil) {
            self.mediaCapturePipeline = mediaCapturePipeline
            self.mediaConcatenationPipeline = mediaConcatenationPipeline
            self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipeline = "MediaCapturePipeline"
            case mediaConcatenationPipeline = "MediaConcatenationPipeline"
            case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
        }
    }

    public struct MediaPipelineSummary: AWSDecodableShape {
        /// The ARN of the media pipeline in the summary.
        public let mediaPipelineArn: String?
        /// The ID of the media pipeline in the summary.
        public let mediaPipelineId: String?

        public init(mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil) {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
        }
    }

    public struct MeetingEventsConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct PresenterOnlyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the position of the presenter video tile. Default: TopRight.
        public let presenterPosition: PresenterPosition?

        public init(presenterPosition: PresenterPosition? = nil) {
            self.presenterPosition = presenterPosition
        }

        private enum CodingKeys: String, CodingKey {
            case presenterPosition = "PresenterPosition"
        }
    }

    public struct S3BucketSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The destination URL of the S3 bucket.
        public let destination: String

        public init(destination: String) {
            self.destination = destination
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
        }
    }

    public struct SelectedVideoStreams: AWSEncodableShape & AWSDecodableShape {
        /// The attendee IDs of the streams selected for a media pipeline.
        public let attendeeIds: [String]?
        /// The external user IDs of the streams selected for a media pipeline.
        public let externalUserIds: [String]?

        public init(attendeeIds: [String]? = nil, externalUserIds: [String]? = nil) {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }

        public func validate(name: String) throws {
            try self.attendeeIds?.forEach {
                try validate($0, name: "attendeeIds[]", parent: name, max: 36)
                try validate($0, name: "attendeeIds[]", parent: name, min: 36)
                try validate($0, name: "attendeeIds[]", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
            }
            try self.validate(self.attendeeIds, name: "attendeeIds", parent: name, min: 1)
            try self.externalUserIds?.forEach {
                try validate($0, name: "externalUserIds[]", parent: name, max: 64)
                try validate($0, name: "externalUserIds[]", parent: name, min: 2)
            }
            try self.validate(self.externalUserIds, name: "externalUserIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attendeeIds = "AttendeeIds"
            case externalUserIds = "ExternalUserIds"
        }
    }

    public struct SourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The selected video streams for a specified media pipeline. The number of video streams can't exceed 25.
        public let selectedVideoStreams: SelectedVideoStreams?

        public init(selectedVideoStreams: SelectedVideoStreams? = nil) {
            self.selectedVideoStreams = selectedVideoStreams
        }

        public func validate(name: String) throws {
            try self.selectedVideoStreams?.validate(name: "\(name).selectedVideoStreams")
        }

        private enum CodingKeys: String, CodingKey {
            case selectedVideoStreams = "SelectedVideoStreams"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key half of a tag.
        public let key: String
        /// The value half of a tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's endpoint region, resource ID, and pipeline ID.
        public let resourceARN: String
        /// The tags associated with the specified media pipeline.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TranscriptionMessagesConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the pipeline that you want to untag.
        public let resourceARN: String
        /// The key/value pairs in the tag that you want to remove.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct VideoArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The MUX type of the video artifact configuration object.
        public let muxType: VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        public let state: ArtifactsState

        public init(muxType: VideoMuxType? = nil, state: ArtifactsState) {
            self.muxType = muxType
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case muxType = "MuxType"
            case state = "State"
        }
    }

    public struct VideoConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }
}

// MARK: - Errors

/// Error enum for ChimeSDKMediaPipelines
public struct ChimeSDKMediaPipelinesErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case forbiddenException = "ForbiddenException"
        case notFoundException = "NotFoundException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case serviceFailureException = "ServiceFailureException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttledClientException = "ThrottledClientException"
        case unauthorizedClientException = "UnauthorizedClientException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ChimeSDKMediaPipelines
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The input parameters don&#39;t match the service&#39;s restrictions.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The client is permanently forbidden from making the request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// One or more of the resources in the request does not exist in the system.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The request exceeds the resource limit.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// The service encountered an unexpected error.
    public static var serviceFailureException: Self { .init(.serviceFailureException) }
    /// The service is currently unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The client exceeded its request rate limit.
    public static var throttledClientException: Self { .init(.throttledClientException) }
    /// The client is not currently authorized to make the request.
    public static var unauthorizedClientException: Self { .init(.unauthorizedClientException) }
}

extension ChimeSDKMediaPipelinesErrorType: Equatable {
    public static func == (lhs: ChimeSDKMediaPipelinesErrorType, rhs: ChimeSDKMediaPipelinesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ChimeSDKMediaPipelinesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
