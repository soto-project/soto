//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ChimeSDKMediaPipelines {
    // MARK: Enums

    public enum ActiveSpeakerPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottomLeft = "BottomLeft"
        case bottomRight = "BottomRight"
        case topLeft = "TopLeft"
        case topRight = "TopRight"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactsConcatenationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactsState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum AudioArtifactsConcatenationState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum AudioChannelsOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mono = "Mono"
        case stereo = "Stereo"
        public var description: String { return self.rawValue }
    }

    public enum AudioMuxType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audioOnly = "AudioOnly"
        case audioWithActiveSpeakerVideo = "AudioWithActiveSpeakerVideo"
        case audioWithCompositedVideo = "AudioWithCompositedVideo"
        public var description: String { return self.rawValue }
    }

    public enum BorderColor: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case black = "Black"
        case blue = "Blue"
        case green = "Green"
        case red = "Red"
        case white = "White"
        case yellow = "Yellow"
        public var description: String { return self.rawValue }
    }

    public enum CallAnalyticsLanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deDe = "de-DE"
        case enAu = "en-AU"
        case enGb = "en-GB"
        case enUs = "en-US"
        case esUs = "es-US"
        case frCa = "fr-CA"
        case frFr = "fr-FR"
        case itIt = "it-IT"
        case ptBr = "pt-BR"
        public var description: String { return self.rawValue }
    }

    public enum CanvasOrientation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case landscape = "Landscape"
        case portrait = "Portrait"
        public var description: String { return self.rawValue }
    }

    public enum ConcatenationSinkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3Bucket = "S3Bucket"
        public var description: String { return self.rawValue }
    }

    public enum ConcatenationSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mediaCapturePipeline = "MediaCapturePipeline"
        public var description: String { return self.rawValue }
    }

    public enum ContentMuxType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentOnly = "ContentOnly"
        public var description: String { return self.rawValue }
    }

    public enum ContentRedactionOutput: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case redacted = "redacted"
        case redactedAndUnredacted = "redacted_and_unredacted"
        public var description: String { return self.rawValue }
    }

    public enum ContentShareLayoutOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case activeSpeakerOnly = "ActiveSpeakerOnly"
        case horizontal = "Horizontal"
        case presenterOnly = "PresenterOnly"
        case vertical = "Vertical"
        public var description: String { return self.rawValue }
    }

    public enum ContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pii = "PII"
        public var description: String { return self.rawValue }
    }

    public enum FragmentSelectorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case producerTimestamp = "ProducerTimestamp"
        case serverTimestamp = "ServerTimestamp"
        public var description: String { return self.rawValue }
    }

    public enum HighlightColor: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case black = "Black"
        case blue = "Blue"
        case green = "Green"
        case red = "Red"
        case white = "White"
        case yellow = "Yellow"
        public var description: String { return self.rawValue }
    }

    public enum HorizontalTilePosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottom = "Bottom"
        case top = "Top"
        public var description: String { return self.rawValue }
    }

    public enum KinesisVideoStreamPoolStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum LayoutOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case gridView = "GridView"
        public var description: String { return self.rawValue }
    }

    public enum LiveConnectorMuxType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case audioWithActiveSpeakerVideo = "AudioWithActiveSpeakerVideo"
        case audioWithCompositedVideo = "AudioWithCompositedVideo"
        public var description: String { return self.rawValue }
    }

    public enum LiveConnectorSinkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rtmp = "RTMP"
        public var description: String { return self.rawValue }
    }

    public enum LiveConnectorSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chimeSdkMeeting = "ChimeSdkMeeting"
        public var description: String { return self.rawValue }
    }

    public enum MediaEncoding: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pcm = "pcm"
        public var description: String { return self.rawValue }
    }

    public enum MediaInsightsPipelineConfigurationElementType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amazonTranscribeCallAnalyticsProcessor = "AmazonTranscribeCallAnalyticsProcessor"
        case amazonTranscribeProcessor = "AmazonTranscribeProcessor"
        case kinesisDataStreamSink = "KinesisDataStreamSink"
        case lambdaFunctionSink = "LambdaFunctionSink"
        case s3RecordingSink = "S3RecordingSink"
        case snsTopicSink = "SnsTopicSink"
        case sqsQueueSink = "SqsQueueSink"
        case voiceAnalyticsProcessor = "VoiceAnalyticsProcessor"
        case voiceEnhancementSink = "VoiceEnhancementSink"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineElementStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case initializing = "Initializing"
        case notStarted = "NotStarted"
        case notSupported = "NotSupported"
        case paused = "Paused"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineSinkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case s3Bucket = "S3Bucket"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chimeSdkMeeting = "ChimeSdkMeeting"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case initializing = "Initializing"
        case notStarted = "NotStarted"
        case paused = "Paused"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineStatusUpdate: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pause = "Pause"
        case resume = "Resume"
        public var description: String { return self.rawValue }
    }

    public enum MediaPipelineTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "Failed"
        case inProgress = "InProgress"
        case initializing = "Initializing"
        case notStarted = "NotStarted"
        case stopped = "Stopped"
        case stopping = "Stopping"
        public var description: String { return self.rawValue }
    }

    public enum MediaStreamPipelineSinkType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kinesisVideoStreamPool = "KinesisVideoStreamPool"
        public var description: String { return self.rawValue }
    }

    public enum MediaStreamType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case individualAudio = "IndividualAudio"
        case mixedAudio = "MixedAudio"
        public var description: String { return self.rawValue }
    }

    public enum PartialResultsStability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "high"
        case low = "low"
        case medium = "medium"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case customer = "CUSTOMER"
        public var description: String { return self.rawValue }
    }

    public enum PresenterPosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bottomLeft = "BottomLeft"
        case bottomRight = "BottomRight"
        case topLeft = "TopLeft"
        case topRight = "TopRight"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeAlertRuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case issueDetection = "IssueDetection"
        case keywordMatch = "KeywordMatch"
        case sentiment = "Sentiment"
        public var description: String { return self.rawValue }
    }

    public enum RecordingFileFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case opus = "Opus"
        case wav = "Wav"
        public var description: String { return self.rawValue }
    }

    public enum ResolutionOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fhd = "FHD"
        case hd = "HD"
        public var description: String { return self.rawValue }
    }

    public enum SentimentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case negative = "NEGATIVE"
        public var description: String { return self.rawValue }
    }

    public enum TileOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case joinSequence = "JoinSequence"
        case speakerSequence = "SpeakerSequence"
        public var description: String { return self.rawValue }
    }

    public enum VerticalTilePosition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case left = "Left"
        case right = "Right"
        public var description: String { return self.rawValue }
    }

    public enum VideoMuxType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case videoOnly = "VideoOnly"
        public var description: String { return self.rawValue }
    }

    public enum VocabularyFilterMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case mask = "mask"
        case remove = "remove"
        case tag = "tag"
        public var description: String { return self.rawValue }
    }

    public enum VoiceAnalyticsConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum VoiceAnalyticsLanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enUs = "en-US"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct ActiveSpeakerOnlyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The position of the ActiveSpeakerOnly video tile.
        public let activeSpeakerPosition: ActiveSpeakerPosition?

        public init(activeSpeakerPosition: ActiveSpeakerPosition? = nil) {
            self.activeSpeakerPosition = activeSpeakerPosition
        }

        private enum CodingKeys: String, CodingKey {
            case activeSpeakerPosition = "ActiveSpeakerPosition"
        }
    }

    public struct AmazonTranscribeCallAnalyticsProcessorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// By default, all CategoryEvents are sent to the insights target. If this parameter is specified, only included categories are sent to the insights target.
        public let callAnalyticsStreamCategories: [String]?
        /// Labels all personally identifiable information (PII) identified in your transcript. Content identification is performed at the segment level; PII specified in PiiEntityTypes is flagged upon complete transcription of an audio segment. You can’t set ContentIdentificationType and ContentRedactionType in the same request. If you do, your request returns a BadRequestException. For more information, see Redacting or identifying personally identifiable information  in the Amazon Transcribe Developer Guide.
        public let contentIdentificationType: ContentType?
        /// Redacts all personally identifiable information (PII) identified in your transcript. Content redaction is performed at the segment level; PII specified in PiiEntityTypes is redacted upon complete transcription of an audio segment. You can’t set ContentRedactionType and ContentIdentificationType in the same request. If you do, your request returns a BadRequestException. For more information, see Redacting or identifying personally identifiable information  in the Amazon Transcribe Developer Guide.
        public let contentRedactionType: ContentType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.  For more information, see Partial-result stabilization  in the Amazon Transcribe Developer Guide.
        public let enablePartialResultsStabilization: Bool?
        /// If true, UtteranceEvents with IsPartial: true are filtered out of the insights target.
        public let filterPartialResults: Bool?
        /// The language code in the configuration.
        public let languageCode: CallAnalyticsLanguageCode
        /// Specifies the name of the custom language model to use when processing a transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code specified in the transcription request. If the languages don't match, the custom language model isn't applied. Language mismatches don't generate errors or warnings. For more information, see Custom language models in the Amazon Transcribe Developer Guide.
        public let languageModelName: String?
        /// Specifies the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy. For more information, see Partial-result stabilization  in the Amazon Transcribe Developer Guide.
        public let partialResultsStability: PartialResultsStability?
        /// Specifies the types of personally identifiable information (PII) to redact from a transcript. You can include as many types as you'd like, or you can select ALL. To include PiiEntityTypes in your Call Analytics request, you must also include ContentIdentificationType or ContentRedactionType, but you can't include both.  Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV,  CREDIT_DEBIT_EXPIRY, CREDIT_DEBIT_NUMBER, EMAIL,  NAME, PHONE, PIN, SSN, or ALL. Length Constraints: Minimum length of 1. Maximum length of 300.
        public let piiEntityTypes: String?
        /// The settings for a post-call analysis task in an analytics configuration.
        public let postCallAnalyticsSettings: PostCallAnalyticsSettings?
        /// Specifies how to apply a vocabulary filter to a transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public let vocabularyFilterMethod: VocabularyFilterMethod?
        /// Specifies the name of the custom vocabulary filter to use when processing a transcription. Note that vocabulary filter names are case sensitive. If the language of the specified custom vocabulary filter doesn't match the language identified in your media, the vocabulary filter is not applied to your transcription. For more information, see Using vocabulary filtering with unwanted words  in the Amazon Transcribe Developer Guide. Length Constraints: Minimum length of 1. Maximum length of 200.
        public let vocabularyFilterName: String?
        /// Specifies the name of the custom vocabulary to use when processing a transcription. Note that vocabulary names are case sensitive. If the language of the specified custom vocabulary doesn't match the language identified in your media, the custom vocabulary is not applied to your transcription. For more information, see Custom vocabularies in the Amazon Transcribe Developer Guide. Length Constraints: Minimum length of 1. Maximum length of 200.
        public let vocabularyName: String?

        public init(callAnalyticsStreamCategories: [String]? = nil, contentIdentificationType: ContentType? = nil, contentRedactionType: ContentType? = nil, enablePartialResultsStabilization: Bool? = nil, filterPartialResults: Bool? = nil, languageCode: CallAnalyticsLanguageCode, languageModelName: String? = nil, partialResultsStability: PartialResultsStability? = nil, piiEntityTypes: String? = nil, postCallAnalyticsSettings: PostCallAnalyticsSettings? = nil, vocabularyFilterMethod: VocabularyFilterMethod? = nil, vocabularyFilterName: String? = nil, vocabularyName: String? = nil) {
            self.callAnalyticsStreamCategories = callAnalyticsStreamCategories
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.filterPartialResults = filterPartialResults
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.postCallAnalyticsSettings = postCallAnalyticsSettings
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }

        public func validate(name: String) throws {
            try self.callAnalyticsStreamCategories?.forEach {
                try validate($0, name: "callAnalyticsStreamCategories[]", parent: name, max: 200)
                try validate($0, name: "callAnalyticsStreamCategories[]", parent: name, min: 1)
                try validate($0, name: "callAnalyticsStreamCategories[]", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            }
            try self.validate(self.callAnalyticsStreamCategories, name: "callAnalyticsStreamCategories", parent: name, max: 20)
            try self.validate(self.callAnalyticsStreamCategories, name: "callAnalyticsStreamCategories", parent: name, min: 1)
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, max: 200)
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, min: 1)
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, max: 300)
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, min: 1)
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, pattern: "^[A-Z_, ]+$")
            try self.postCallAnalyticsSettings?.validate(name: "\(name).postCallAnalyticsSettings")
            try self.validate(self.vocabularyFilterName, name: "vocabularyFilterName", parent: name, max: 200)
            try self.validate(self.vocabularyFilterName, name: "vocabularyFilterName", parent: name, min: 1)
            try self.validate(self.vocabularyFilterName, name: "vocabularyFilterName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, max: 200)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, min: 1)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case callAnalyticsStreamCategories = "CallAnalyticsStreamCategories"
            case contentIdentificationType = "ContentIdentificationType"
            case contentRedactionType = "ContentRedactionType"
            case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
            case filterPartialResults = "FilterPartialResults"
            case languageCode = "LanguageCode"
            case languageModelName = "LanguageModelName"
            case partialResultsStability = "PartialResultsStability"
            case piiEntityTypes = "PiiEntityTypes"
            case postCallAnalyticsSettings = "PostCallAnalyticsSettings"
            case vocabularyFilterMethod = "VocabularyFilterMethod"
            case vocabularyFilterName = "VocabularyFilterName"
            case vocabularyName = "VocabularyName"
        }
    }

    public struct AmazonTranscribeProcessorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Labels all personally identifiable information (PII) identified in your transcript. Content identification is performed at the segment level; PII specified in PiiEntityTypes is flagged upon complete transcription of an audio segment. You can’t set ContentIdentificationType and ContentRedactionType in the same request. If you set both, your request returns a BadRequestException. For more information, see Redacting or identifying personally identifiable information  in the Amazon Transcribe Developer Guide.
        public let contentIdentificationType: ContentType?
        /// Redacts all personally identifiable information (PII) identified in your transcript. Content redaction is performed at the segment level; PII specified in PiiEntityTypes is redacted upon complete transcription of an audio segment. You can’t set ContentRedactionType and ContentIdentificationType in the same request. If you set both, your request returns a BadRequestException. For more information, see Redacting or identifying personally identifiable information  in the Amazon Transcribe Developer Guide.
        public let contentRedactionType: ContentType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy. For more information, see Partial-result stabilization  in the Amazon Transcribe Developer Guide.
        public let enablePartialResultsStabilization: Bool?
        /// If true, TranscriptEvents with IsPartial: true are filtered out of the insights target.
        public let filterPartialResults: Bool?
        /// Turns language identification on or off.
        public let identifyLanguage: Bool?
        /// The language code that represents the language spoken in your audio. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification. For a list of languages that real-time Call Analytics supports, see the Supported languages table  in the Amazon Transcribe Developer Guide.
        public let languageCode: CallAnalyticsLanguageCode?
        /// The name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code you specify in your transcription request. If the languages don't match, the custom language model isn't applied.  There are no errors or warnings associated with a language mismatch. For more information, see Custom language models in the Amazon Transcribe Developer Guide.
        public let languageModelName: String?
        /// The language options for the transcription, such as automatic language detection.
        public let languageOptions: String?
        /// The level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy. For more information, see Partial-result stabilization  in the Amazon Transcribe Developer Guide.
        public let partialResultsStability: PartialResultsStability?
        /// The types of personally identifiable information (PII) to redact from a transcript. You can include as many types as you'd like, or you can select ALL. To include PiiEntityTypes in your Call Analytics request, you must also include ContentIdentificationType or ContentRedactionType, but you can't include both. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV,  CREDIT_DEBIT_EXPIRY, CREDIT_DEBIT_NUMBER, EMAIL,  NAME, PHONE, PIN, SSN, or ALL. If you leave this parameter empty, the default behavior is equivalent to ALL.
        public let piiEntityTypes: String?
        /// The preferred language for the transcription.
        public let preferredLanguage: CallAnalyticsLanguageCode?
        /// Enables speaker partitioning (diarization) in your transcription output. Speaker partitioning labels the speech from individual speakers in your media file. For more information, see Partitioning speakers (diarization) in the Amazon Transcribe Developer Guide.
        public let showSpeakerLabel: Bool?
        /// The vocabulary filtering method used in your Call Analytics transcription.
        public let vocabularyFilterMethod: VocabularyFilterMethod?
        /// The name of the custom vocabulary filter that you specified in your Call Analytics request. Length Constraints: Minimum length of 1. Maximum length of 200.
        public let vocabularyFilterName: String?
        /// The names of the custom vocabulary filter or filters using during transcription.
        public let vocabularyFilterNames: String?
        /// The name of the custom vocabulary that you specified in your Call Analytics request. Length Constraints: Minimum length of 1. Maximum length of 200.
        public let vocabularyName: String?
        /// The names of the custom vocabulary or vocabularies used during transcription.
        public let vocabularyNames: String?

        public init(contentIdentificationType: ContentType? = nil, contentRedactionType: ContentType? = nil, enablePartialResultsStabilization: Bool? = nil, filterPartialResults: Bool? = nil, identifyLanguage: Bool? = nil, languageCode: CallAnalyticsLanguageCode? = nil, languageModelName: String? = nil, languageOptions: String? = nil, partialResultsStability: PartialResultsStability? = nil, piiEntityTypes: String? = nil, preferredLanguage: CallAnalyticsLanguageCode? = nil, showSpeakerLabel: Bool? = nil, vocabularyFilterMethod: VocabularyFilterMethod? = nil, vocabularyFilterName: String? = nil, vocabularyFilterNames: String? = nil, vocabularyName: String? = nil, vocabularyNames: String? = nil) {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.filterPartialResults = filterPartialResults
            self.identifyLanguage = identifyLanguage
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.showSpeakerLabel = showSpeakerLabel
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }

        public func validate(name: String) throws {
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, max: 200)
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, min: 1)
            try self.validate(self.languageModelName, name: "languageModelName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.languageOptions, name: "languageOptions", parent: name, max: 200)
            try self.validate(self.languageOptions, name: "languageOptions", parent: name, min: 1)
            try self.validate(self.languageOptions, name: "languageOptions", parent: name, pattern: "^[a-zA-Z-,]+$")
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, max: 300)
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, min: 1)
            try self.validate(self.piiEntityTypes, name: "piiEntityTypes", parent: name, pattern: "^[A-Z_, ]+$")
            try self.validate(self.vocabularyFilterName, name: "vocabularyFilterName", parent: name, max: 200)
            try self.validate(self.vocabularyFilterName, name: "vocabularyFilterName", parent: name, min: 1)
            try self.validate(self.vocabularyFilterName, name: "vocabularyFilterName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.vocabularyFilterNames, name: "vocabularyFilterNames", parent: name, max: 3000)
            try self.validate(self.vocabularyFilterNames, name: "vocabularyFilterNames", parent: name, min: 1)
            try self.validate(self.vocabularyFilterNames, name: "vocabularyFilterNames", parent: name, pattern: "^[a-zA-Z0-9,-._]+$")
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, max: 200)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, min: 1)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.vocabularyNames, name: "vocabularyNames", parent: name, max: 3000)
            try self.validate(self.vocabularyNames, name: "vocabularyNames", parent: name, min: 1)
            try self.validate(self.vocabularyNames, name: "vocabularyNames", parent: name, pattern: "^[a-zA-Z0-9,-._]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case contentIdentificationType = "ContentIdentificationType"
            case contentRedactionType = "ContentRedactionType"
            case enablePartialResultsStabilization = "EnablePartialResultsStabilization"
            case filterPartialResults = "FilterPartialResults"
            case identifyLanguage = "IdentifyLanguage"
            case languageCode = "LanguageCode"
            case languageModelName = "LanguageModelName"
            case languageOptions = "LanguageOptions"
            case partialResultsStability = "PartialResultsStability"
            case piiEntityTypes = "PiiEntityTypes"
            case preferredLanguage = "PreferredLanguage"
            case showSpeakerLabel = "ShowSpeakerLabel"
            case vocabularyFilterMethod = "VocabularyFilterMethod"
            case vocabularyFilterName = "VocabularyFilterName"
            case vocabularyFilterNames = "VocabularyFilterNames"
            case vocabularyName = "VocabularyName"
            case vocabularyNames = "VocabularyNames"
        }
    }

    public struct ArtifactsConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the audio artifacts concatenation.
        public let audio: AudioConcatenationConfiguration
        /// The configuration for the composited video artifacts concatenation.
        public let compositedVideo: CompositedVideoConcatenationConfiguration
        /// The configuration for the content artifacts concatenation.
        public let content: ContentConcatenationConfiguration
        /// The configuration for the data channel artifacts concatenation.
        public let dataChannel: DataChannelConcatenationConfiguration
        /// The configuration for the meeting events artifacts concatenation.
        public let meetingEvents: MeetingEventsConcatenationConfiguration
        /// The configuration for the transcription messages artifacts concatenation.
        public let transcriptionMessages: TranscriptionMessagesConcatenationConfiguration
        /// The configuration for the video artifacts concatenation.
        public let video: VideoConcatenationConfiguration

        public init(audio: AudioConcatenationConfiguration, compositedVideo: CompositedVideoConcatenationConfiguration, content: ContentConcatenationConfiguration, dataChannel: DataChannelConcatenationConfiguration, meetingEvents: MeetingEventsConcatenationConfiguration, transcriptionMessages: TranscriptionMessagesConcatenationConfiguration, video: VideoConcatenationConfiguration) {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.dataChannel = dataChannel
            self.meetingEvents = meetingEvents
            self.transcriptionMessages = transcriptionMessages
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
            case compositedVideo = "CompositedVideo"
            case content = "Content"
            case dataChannel = "DataChannel"
            case meetingEvents = "MeetingEvents"
            case transcriptionMessages = "TranscriptionMessages"
            case video = "Video"
        }
    }

    public struct ArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the audio artifacts.
        public let audio: AudioArtifactsConfiguration
        /// Enables video compositing.
        public let compositedVideo: CompositedVideoArtifactsConfiguration?
        /// The configuration for the content artifacts.
        public let content: ContentArtifactsConfiguration
        /// The configuration for the video artifacts.
        public let video: VideoArtifactsConfiguration

        public init(audio: AudioArtifactsConfiguration, compositedVideo: CompositedVideoArtifactsConfiguration? = nil, content: ContentArtifactsConfiguration, video: VideoArtifactsConfiguration) {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.video = video
        }

        public func validate(name: String) throws {
            try self.compositedVideo?.validate(name: "\(name).compositedVideo")
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
            case compositedVideo = "CompositedVideo"
            case content = "Content"
            case video = "Video"
        }
    }

    public struct AudioArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The MUX type of the audio artifact configuration object.
        public let muxType: AudioMuxType

        public init(muxType: AudioMuxType) {
            self.muxType = muxType
        }

        private enum CodingKeys: String, CodingKey {
            case muxType = "MuxType"
        }
    }

    public struct AudioConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: AudioArtifactsConcatenationState

        public init(state: AudioArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct ChannelDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The channel ID.
        public let channelId: Int
        /// Specifies whether the audio in a channel belongs to the AGENT or CUSTOMER.
        public let participantRole: ParticipantRole?

        public init(channelId: Int, participantRole: ParticipantRole? = nil) {
            self.channelId = channelId
            self.participantRole = participantRole
        }

        public func validate(name: String) throws {
            try self.validate(self.channelId, name: "channelId", parent: name, max: 1)
            try self.validate(self.channelId, name: "channelId", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case channelId = "ChannelId"
            case participantRole = "ParticipantRole"
        }
    }

    public struct ChimeSdkMeetingConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting concatenation.
        public let artifactsConfiguration: ArtifactsConcatenationConfiguration

        public init(artifactsConfiguration: ArtifactsConcatenationConfiguration) {
            self.artifactsConfiguration = artifactsConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case artifactsConfiguration = "ArtifactsConfiguration"
        }
    }

    public struct ChimeSdkMeetingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public let artifactsConfiguration: ArtifactsConfiguration?
        /// The source configuration for a specified media pipeline.
        public let sourceConfiguration: SourceConfiguration?

        public init(artifactsConfiguration: ArtifactsConfiguration? = nil, sourceConfiguration: SourceConfiguration? = nil) {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.artifactsConfiguration?.validate(name: "\(name).artifactsConfiguration")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case artifactsConfiguration = "ArtifactsConfiguration"
            case sourceConfiguration = "SourceConfiguration"
        }
    }

    public struct ChimeSdkMeetingLiveConnectorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration object's Chime SDK meeting ARN.
        public let arn: String
        /// The media pipeline's composited video.
        public let compositedVideo: CompositedVideoArtifactsConfiguration?
        /// The configuration object's multiplex type.
        public let muxType: LiveConnectorMuxType
        /// The source configuration settings of the media pipeline's configuration object.
        public let sourceConfiguration: SourceConfiguration?

        public init(arn: String, compositedVideo: CompositedVideoArtifactsConfiguration? = nil, muxType: LiveConnectorMuxType, sourceConfiguration: SourceConfiguration? = nil) {
            self.arn = arn
            self.compositedVideo = compositedVideo
            self.muxType = muxType
            self.sourceConfiguration = sourceConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1024)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.compositedVideo?.validate(name: "\(name).compositedVideo")
            try self.sourceConfiguration?.validate(name: "\(name).sourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case compositedVideo = "CompositedVideo"
            case muxType = "MuxType"
            case sourceConfiguration = "SourceConfiguration"
        }
    }

    public struct CompositedVideoArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The GridView configuration setting.
        public let gridViewConfiguration: GridViewConfiguration
        /// The layout setting, such as GridView in the configuration object.
        public let layout: LayoutOption?
        /// The video resolution setting in the configuration object. Default: HD at 1280 x 720. FHD resolution: 1920 x 1080.
        public let resolution: ResolutionOption?

        public init(gridViewConfiguration: GridViewConfiguration, layout: LayoutOption? = nil, resolution: ResolutionOption? = nil) {
            self.gridViewConfiguration = gridViewConfiguration
            self.layout = layout
            self.resolution = resolution
        }

        public func validate(name: String) throws {
            try self.gridViewConfiguration.validate(name: "\(name).gridViewConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case gridViewConfiguration = "GridViewConfiguration"
            case layout = "Layout"
            case resolution = "Resolution"
        }
    }

    public struct CompositedVideoConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct ConcatenationSink: AWSEncodableShape & AWSDecodableShape {
        /// The configuration settings for an Amazon S3 bucket sink.
        public let s3BucketSinkConfiguration: S3BucketSinkConfiguration
        /// The type of data sink in the configuration object.
        public let type: ConcatenationSinkType

        public init(s3BucketSinkConfiguration: S3BucketSinkConfiguration, type: ConcatenationSinkType) {
            self.s3BucketSinkConfiguration = s3BucketSinkConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.s3BucketSinkConfiguration.validate(name: "\(name).s3BucketSinkConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketSinkConfiguration = "S3BucketSinkConfiguration"
            case type = "Type"
        }
    }

    public struct ConcatenationSource: AWSEncodableShape & AWSDecodableShape {
        /// The concatenation settings for the media pipeline in a configuration object.
        public let mediaCapturePipelineSourceConfiguration: MediaCapturePipelineSourceConfiguration
        /// The type of concatenation source in a configuration object.
        public let type: ConcatenationSourceType

        public init(mediaCapturePipelineSourceConfiguration: MediaCapturePipelineSourceConfiguration, type: ConcatenationSourceType) {
            self.mediaCapturePipelineSourceConfiguration = mediaCapturePipelineSourceConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.mediaCapturePipelineSourceConfiguration.validate(name: "\(name).mediaCapturePipelineSourceConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipelineSourceConfiguration = "MediaCapturePipelineSourceConfiguration"
            case type = "Type"
        }
    }

    public struct ContentArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The MUX type of the artifact configuration.
        public let muxType: ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        public let state: ArtifactsState

        public init(muxType: ContentMuxType? = nil, state: ArtifactsState) {
            self.muxType = muxType
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case muxType = "MuxType"
            case state = "State"
        }
    }

    public struct ContentConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct CreateMediaCapturePipelineRequest: AWSEncodableShape {
        /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
        public let chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration?
        /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.
        public let clientRequestToken: String?
        /// The ARN of the sink type.
        public let sinkArn: String
        /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
        public let sinkType: MediaPipelineSinkType
        /// ARN of the source from which the media artifacts are captured.
        public let sourceArn: String
        /// Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.
        public let sourceType: MediaPipelineSourceType
        /// The tag key-value pairs.
        public let tags: [Tag]?

        public init(chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration? = nil, clientRequestToken: String? = CreateMediaCapturePipelineRequest.idempotencyToken(), sinkArn: String, sinkType: MediaPipelineSinkType, sourceArn: String, sourceType: MediaPipelineSourceType, tags: [Tag]? = nil) {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.clientRequestToken = clientRequestToken
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.chimeSdkMeetingConfiguration?.validate(name: "\(name).chimeSdkMeetingConfiguration")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, max: 1024)
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, min: 1)
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 1024)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 1)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
            case clientRequestToken = "ClientRequestToken"
            case sinkArn = "SinkArn"
            case sinkType = "SinkType"
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
            case tags = "Tags"
        }
    }

    public struct CreateMediaCapturePipelineResponse: AWSDecodableShape {
        /// A media pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media pipeline object.
        public let mediaCapturePipeline: MediaCapturePipeline?

        public init(mediaCapturePipeline: MediaCapturePipeline? = nil) {
            self.mediaCapturePipeline = mediaCapturePipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipeline = "MediaCapturePipeline"
        }
    }

    public struct CreateMediaConcatenationPipelineRequest: AWSEncodableShape {
        /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media concatenation pipeline request.
        public let clientRequestToken: String?
        /// An object that specifies the data sinks for the media concatenation pipeline.
        public let sinks: [ConcatenationSink]
        /// An object that specifies the sources for the media concatenation pipeline.
        public let sources: [ConcatenationSource]
        /// The tags associated with the media concatenation pipeline.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaConcatenationPipelineRequest.idempotencyToken(), sinks: [ConcatenationSink], sources: [ConcatenationSource], tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.sinks = sinks
            self.sources = sources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.sinks.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.validate(self.sinks, name: "sinks", parent: name, max: 1)
            try self.validate(self.sinks, name: "sinks", parent: name, min: 1)
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case sinks = "Sinks"
            case sources = "Sources"
            case tags = "Tags"
        }
    }

    public struct CreateMediaConcatenationPipelineResponse: AWSDecodableShape {
        /// A media concatenation pipeline object, the ID, source type, MediaPipelineARN, and sink of a media concatenation pipeline object.
        public let mediaConcatenationPipeline: MediaConcatenationPipeline?

        public init(mediaConcatenationPipeline: MediaConcatenationPipeline? = nil) {
            self.mediaConcatenationPipeline = mediaConcatenationPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaConcatenationPipeline = "MediaConcatenationPipeline"
        }
    }

    public struct CreateMediaInsightsPipelineConfigurationRequest: AWSEncodableShape {
        /// The unique identifier for the media insights pipeline configuration request.
        public let clientRequestToken: String?
        /// The elements in the request, such as a processor for Amazon Transcribe or a sink for a Kinesis Data Stream.
        public let elements: [MediaInsightsPipelineConfigurationElement]
        /// The name of the media insights pipeline configuration.
        public let mediaInsightsPipelineConfigurationName: String
        /// The configuration settings for the real-time alerts in a media insights pipeline configuration.
        public let realTimeAlertConfiguration: RealTimeAlertConfiguration?
        /// The ARN of the role used by the service to access Amazon Web Services resources, including Transcribe and Transcribe Call Analytics, on the  caller’s behalf.
        public let resourceAccessRoleArn: String
        /// The tags assigned to the media insights pipeline configuration.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaInsightsPipelineConfigurationRequest.idempotencyToken(), elements: [MediaInsightsPipelineConfigurationElement], mediaInsightsPipelineConfigurationName: String, realTimeAlertConfiguration: RealTimeAlertConfiguration? = nil, resourceAccessRoleArn: String, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.elements = elements
            self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
            self.realTimeAlertConfiguration = realTimeAlertConfiguration
            self.resourceAccessRoleArn = resourceAccessRoleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.mediaInsightsPipelineConfigurationName, name: "mediaInsightsPipelineConfigurationName", parent: name, max: 64)
            try self.validate(self.mediaInsightsPipelineConfigurationName, name: "mediaInsightsPipelineConfigurationName", parent: name, min: 2)
            try self.validate(self.mediaInsightsPipelineConfigurationName, name: "mediaInsightsPipelineConfigurationName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.realTimeAlertConfiguration?.validate(name: "\(name).realTimeAlertConfiguration")
            try self.validate(self.resourceAccessRoleArn, name: "resourceAccessRoleArn", parent: name, max: 1024)
            try self.validate(self.resourceAccessRoleArn, name: "resourceAccessRoleArn", parent: name, min: 1)
            try self.validate(self.resourceAccessRoleArn, name: "resourceAccessRoleArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case elements = "Elements"
            case mediaInsightsPipelineConfigurationName = "MediaInsightsPipelineConfigurationName"
            case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
            case resourceAccessRoleArn = "ResourceAccessRoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateMediaInsightsPipelineConfigurationResponse: AWSDecodableShape {
        /// The configuration settings for the media insights pipeline.
        public let mediaInsightsPipelineConfiguration: MediaInsightsPipelineConfiguration?

        public init(mediaInsightsPipelineConfiguration: MediaInsightsPipelineConfiguration? = nil) {
            self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case mediaInsightsPipelineConfiguration = "MediaInsightsPipelineConfiguration"
        }
    }

    public struct CreateMediaInsightsPipelineRequest: AWSEncodableShape {
        /// The unique identifier for the media insights pipeline request.
        public let clientRequestToken: String?
        /// The runtime configuration for the Kinesis video recording stream source.
        public let kinesisVideoStreamRecordingSourceRuntimeConfiguration: KinesisVideoStreamRecordingSourceRuntimeConfiguration?
        /// The runtime configuration for the Kinesis video stream source of the media insights pipeline.
        public let kinesisVideoStreamSourceRuntimeConfiguration: KinesisVideoStreamSourceRuntimeConfiguration?
        /// The ARN of the pipeline's configuration.
        public let mediaInsightsPipelineConfigurationArn: String
        /// The runtime metadata for the media insights pipeline. Consists of a key-value map of strings.
        public let mediaInsightsRuntimeMetadata: [String: String]?
        /// The runtime configuration for the S3 recording sink. If specified, the settings in this structure override any settings in S3RecordingSinkConfiguration.
        public let s3RecordingSinkRuntimeConfiguration: S3RecordingSinkRuntimeConfiguration?
        /// The tags assigned to the media insights pipeline.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaInsightsPipelineRequest.idempotencyToken(), kinesisVideoStreamRecordingSourceRuntimeConfiguration: KinesisVideoStreamRecordingSourceRuntimeConfiguration? = nil, kinesisVideoStreamSourceRuntimeConfiguration: KinesisVideoStreamSourceRuntimeConfiguration? = nil, mediaInsightsPipelineConfigurationArn: String, mediaInsightsRuntimeMetadata: [String: String]? = nil, s3RecordingSinkRuntimeConfiguration: S3RecordingSinkRuntimeConfiguration? = nil, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfiguration
            self.kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfiguration
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata
            self.s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.kinesisVideoStreamRecordingSourceRuntimeConfiguration?.validate(name: "\(name).kinesisVideoStreamRecordingSourceRuntimeConfiguration")
            try self.kinesisVideoStreamSourceRuntimeConfiguration?.validate(name: "\(name).kinesisVideoStreamSourceRuntimeConfiguration")
            try self.validate(self.mediaInsightsPipelineConfigurationArn, name: "mediaInsightsPipelineConfigurationArn", parent: name, max: 1024)
            try self.validate(self.mediaInsightsPipelineConfigurationArn, name: "mediaInsightsPipelineConfigurationArn", parent: name, min: 1)
            try self.validate(self.mediaInsightsPipelineConfigurationArn, name: "mediaInsightsPipelineConfigurationArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.mediaInsightsRuntimeMetadata?.forEach {
                try validate($0.key, name: "mediaInsightsRuntimeMetadata.key", parent: name, max: 1024)
                try validate($0.key, name: "mediaInsightsRuntimeMetadata.key", parent: name, pattern: "\\S")
                try validate($0.value, name: "mediaInsightsRuntimeMetadata[\"\($0.key)\"]", parent: name, max: 4096)
                try validate($0.value, name: "mediaInsightsRuntimeMetadata[\"\($0.key)\"]", parent: name, pattern: ".*")
            }
            try self.s3RecordingSinkRuntimeConfiguration?.validate(name: "\(name).s3RecordingSinkRuntimeConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case kinesisVideoStreamRecordingSourceRuntimeConfiguration = "KinesisVideoStreamRecordingSourceRuntimeConfiguration"
            case kinesisVideoStreamSourceRuntimeConfiguration = "KinesisVideoStreamSourceRuntimeConfiguration"
            case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
            case mediaInsightsRuntimeMetadata = "MediaInsightsRuntimeMetadata"
            case s3RecordingSinkRuntimeConfiguration = "S3RecordingSinkRuntimeConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateMediaInsightsPipelineResponse: AWSDecodableShape {
        /// The media insights pipeline object.
        public let mediaInsightsPipeline: MediaInsightsPipeline

        public init(mediaInsightsPipeline: MediaInsightsPipeline) {
            self.mediaInsightsPipeline = mediaInsightsPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaInsightsPipeline = "MediaInsightsPipeline"
        }
    }

    public struct CreateMediaLiveConnectorPipelineRequest: AWSEncodableShape {
        /// The token assigned to the client making the request.
        public let clientRequestToken: String?
        /// The media live connector pipeline's data sinks.
        public let sinks: [LiveConnectorSinkConfiguration]
        /// The media live connector pipeline's data sources.
        public let sources: [LiveConnectorSourceConfiguration]
        /// The tags associated with the media live connector pipeline.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaLiveConnectorPipelineRequest.idempotencyToken(), sinks: [LiveConnectorSinkConfiguration], sources: [LiveConnectorSourceConfiguration], tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.sinks = sinks
            self.sources = sources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.sinks.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.validate(self.sinks, name: "sinks", parent: name, max: 1)
            try self.validate(self.sinks, name: "sinks", parent: name, min: 1)
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, max: 1)
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case sinks = "Sinks"
            case sources = "Sources"
            case tags = "Tags"
        }
    }

    public struct CreateMediaLiveConnectorPipelineResponse: AWSDecodableShape {
        /// The new media live connector pipeline.
        public let mediaLiveConnectorPipeline: MediaLiveConnectorPipeline?

        public init(mediaLiveConnectorPipeline: MediaLiveConnectorPipeline? = nil) {
            self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
        }
    }

    public struct CreateMediaPipelineKinesisVideoStreamPoolRequest: AWSEncodableShape {
        /// The token assigned to the client making the request.
        public let clientRequestToken: String?
        /// The name of the video stream pool.
        public let poolName: String
        /// The configuration settings for the video stream.
        public let streamConfiguration: KinesisVideoStreamConfiguration
        /// The tags assigned to the video stream pool.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaPipelineKinesisVideoStreamPoolRequest.idempotencyToken(), poolName: String, streamConfiguration: KinesisVideoStreamConfiguration, tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.poolName = poolName
            self.streamConfiguration = streamConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.poolName, name: "poolName", parent: name, max: 128)
            try self.validate(self.poolName, name: "poolName", parent: name, min: 1)
            try self.validate(self.poolName, name: "poolName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.streamConfiguration.validate(name: "\(name).streamConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case poolName = "PoolName"
            case streamConfiguration = "StreamConfiguration"
            case tags = "Tags"
        }
    }

    public struct CreateMediaPipelineKinesisVideoStreamPoolResponse: AWSDecodableShape {
        /// The configuration for the Kinesis video stream pool.
        public let kinesisVideoStreamPoolConfiguration: KinesisVideoStreamPoolConfiguration?

        public init(kinesisVideoStreamPoolConfiguration: KinesisVideoStreamPoolConfiguration? = nil) {
            self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisVideoStreamPoolConfiguration = "KinesisVideoStreamPoolConfiguration"
        }
    }

    public struct CreateMediaStreamPipelineRequest: AWSEncodableShape {
        /// The token assigned to the client making the request.
        public let clientRequestToken: String?
        /// The data sink for the media pipeline.
        public let sinks: [MediaStreamSink]
        /// The data sources for the media pipeline.
        public let sources: [MediaStreamSource]
        /// The tags assigned to the media pipeline.
        public let tags: [Tag]?

        public init(clientRequestToken: String? = CreateMediaStreamPipelineRequest.idempotencyToken(), sinks: [MediaStreamSink], sources: [MediaStreamSource], tags: [Tag]? = nil) {
            self.clientRequestToken = clientRequestToken
            self.sinks = sinks
            self.sources = sources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.sinks.forEach {
                try $0.validate(name: "\(name).sinks[]")
            }
            try self.validate(self.sinks, name: "sinks", parent: name, max: 2)
            try self.validate(self.sinks, name: "sinks", parent: name, min: 1)
            try self.sources.forEach {
                try $0.validate(name: "\(name).sources[]")
            }
            try self.validate(self.sources, name: "sources", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case sinks = "Sinks"
            case sources = "Sources"
            case tags = "Tags"
        }
    }

    public struct CreateMediaStreamPipelineResponse: AWSDecodableShape {
        /// The requested media pipeline.
        public let mediaStreamPipeline: MediaStreamPipeline?

        public init(mediaStreamPipeline: MediaStreamPipeline? = nil) {
            self.mediaStreamPipeline = mediaStreamPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaStreamPipeline = "MediaStreamPipeline"
        }
    }

    public struct DataChannelConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct DeleteMediaCapturePipelineRequest: AWSEncodableShape {
        /// The ID of the media pipeline being deleted.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mediaPipelineId, key: "MediaPipelineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMediaInsightsPipelineConfigurationRequest: AWSEncodableShape {
        /// The unique identifier of the resource to be deleted. Valid values include the name and ARN of the media insights pipeline configuration.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMediaPipelineKinesisVideoStreamPoolRequest: AWSEncodableShape {
        /// The ID of the pool being deleted.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMediaPipelineRequest: AWSEncodableShape {
        /// The ID of the media pipeline to delete.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mediaPipelineId, key: "MediaPipelineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct FragmentSelector: AWSEncodableShape & AWSDecodableShape {
        /// The origin of the timestamps to use, Server or Producer. For more information, see  StartSelectorType in the Amazon Kinesis Video Streams Developer Guide.
        public let fragmentSelectorType: FragmentSelectorType
        /// The range of timestamps to return.
        public let timestampRange: TimestampRange

        public init(fragmentSelectorType: FragmentSelectorType, timestampRange: TimestampRange) {
            self.fragmentSelectorType = fragmentSelectorType
            self.timestampRange = timestampRange
        }

        private enum CodingKeys: String, CodingKey {
            case fragmentSelectorType = "FragmentSelectorType"
            case timestampRange = "TimestampRange"
        }
    }

    public struct GetMediaCapturePipelineRequest: AWSEncodableShape {
        /// The ID of the pipeline that you want to get.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mediaPipelineId, key: "MediaPipelineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaCapturePipelineResponse: AWSDecodableShape {
        /// The media pipeline object.
        public let mediaCapturePipeline: MediaCapturePipeline?

        public init(mediaCapturePipeline: MediaCapturePipeline? = nil) {
            self.mediaCapturePipeline = mediaCapturePipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipeline = "MediaCapturePipeline"
        }
    }

    public struct GetMediaInsightsPipelineConfigurationRequest: AWSEncodableShape {
        /// The unique identifier of the requested resource.  Valid values include the name and ARN of the media insights pipeline configuration.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaInsightsPipelineConfigurationResponse: AWSDecodableShape {
        /// The requested media insights pipeline configuration.
        public let mediaInsightsPipelineConfiguration: MediaInsightsPipelineConfiguration?

        public init(mediaInsightsPipelineConfiguration: MediaInsightsPipelineConfiguration? = nil) {
            self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case mediaInsightsPipelineConfiguration = "MediaInsightsPipelineConfiguration"
        }
    }

    public struct GetMediaPipelineKinesisVideoStreamPoolRequest: AWSEncodableShape {
        /// The ID of the video stream pool.
        public let identifier: String

        public init(identifier: String) {
            self.identifier = identifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaPipelineKinesisVideoStreamPoolResponse: AWSDecodableShape {
        /// The video stream pool configuration object.
        public let kinesisVideoStreamPoolConfiguration: KinesisVideoStreamPoolConfiguration?

        public init(kinesisVideoStreamPoolConfiguration: KinesisVideoStreamPoolConfiguration? = nil) {
            self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisVideoStreamPoolConfiguration = "KinesisVideoStreamPoolConfiguration"
        }
    }

    public struct GetMediaPipelineRequest: AWSEncodableShape {
        /// The ID of the pipeline that you want to get.
        public let mediaPipelineId: String

        public init(mediaPipelineId: String) {
            self.mediaPipelineId = mediaPipelineId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.mediaPipelineId, key: "MediaPipelineId")
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, max: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, min: 36)
            try self.validate(self.mediaPipelineId, name: "mediaPipelineId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaPipelineResponse: AWSDecodableShape {
        /// The media pipeline object.
        public let mediaPipeline: MediaPipeline?

        public init(mediaPipeline: MediaPipeline? = nil) {
            self.mediaPipeline = mediaPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipeline = "MediaPipeline"
        }
    }

    public struct GetSpeakerSearchTaskRequest: AWSEncodableShape {
        /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
        public let identifier: String
        /// The ID of the speaker search task.
        public let speakerSearchTaskId: String

        public init(identifier: String, speakerSearchTaskId: String) {
            self.identifier = identifier
            self.speakerSearchTaskId = speakerSearchTaskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodePath(self.speakerSearchTaskId, key: "SpeakerSearchTaskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.validate(self.speakerSearchTaskId, name: "speakerSearchTaskId", parent: name, max: 36)
            try self.validate(self.speakerSearchTaskId, name: "speakerSearchTaskId", parent: name, min: 36)
            try self.validate(self.speakerSearchTaskId, name: "speakerSearchTaskId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSpeakerSearchTaskResponse: AWSDecodableShape {
        /// The details of the speaker search task.
        public let speakerSearchTask: SpeakerSearchTask?

        public init(speakerSearchTask: SpeakerSearchTask? = nil) {
            self.speakerSearchTask = speakerSearchTask
        }

        private enum CodingKeys: String, CodingKey {
            case speakerSearchTask = "SpeakerSearchTask"
        }
    }

    public struct GetVoiceToneAnalysisTaskRequest: AWSEncodableShape {
        /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
        public let identifier: String
        /// The ID of the voice tone analysis task.
        public let voiceToneAnalysisTaskId: String

        public init(identifier: String, voiceToneAnalysisTaskId: String) {
            self.identifier = identifier
            self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodePath(self.voiceToneAnalysisTaskId, key: "VoiceToneAnalysisTaskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.validate(self.voiceToneAnalysisTaskId, name: "voiceToneAnalysisTaskId", parent: name, max: 36)
            try self.validate(self.voiceToneAnalysisTaskId, name: "voiceToneAnalysisTaskId", parent: name, min: 36)
            try self.validate(self.voiceToneAnalysisTaskId, name: "voiceToneAnalysisTaskId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVoiceToneAnalysisTaskResponse: AWSDecodableShape {
        /// The details of the voice tone analysis task.
        public let voiceToneAnalysisTask: VoiceToneAnalysisTask?

        public init(voiceToneAnalysisTask: VoiceToneAnalysisTask? = nil) {
            self.voiceToneAnalysisTask = voiceToneAnalysisTask
        }

        private enum CodingKeys: String, CodingKey {
            case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
        }
    }

    public struct GridViewConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration settings for an ActiveSpeakerOnly video tile.
        public let activeSpeakerOnlyConfiguration: ActiveSpeakerOnlyConfiguration?
        /// The orientation setting, horizontal or vertical.
        public let canvasOrientation: CanvasOrientation?
        /// Defines the layout of the video tiles when content sharing is enabled.
        public let contentShareLayout: ContentShareLayoutOption
        /// The configuration settings for a horizontal layout.
        public let horizontalLayoutConfiguration: HorizontalLayoutConfiguration?
        /// Defines the configuration options for a presenter only video tile.
        public let presenterOnlyConfiguration: PresenterOnlyConfiguration?
        /// The configuration settings for a vertical layout.
        public let verticalLayoutConfiguration: VerticalLayoutConfiguration?
        /// The attribute settings for the video tiles.
        public let videoAttribute: VideoAttribute?

        public init(activeSpeakerOnlyConfiguration: ActiveSpeakerOnlyConfiguration? = nil, canvasOrientation: CanvasOrientation? = nil, contentShareLayout: ContentShareLayoutOption, horizontalLayoutConfiguration: HorizontalLayoutConfiguration? = nil, presenterOnlyConfiguration: PresenterOnlyConfiguration? = nil, verticalLayoutConfiguration: VerticalLayoutConfiguration? = nil, videoAttribute: VideoAttribute? = nil) {
            self.activeSpeakerOnlyConfiguration = activeSpeakerOnlyConfiguration
            self.canvasOrientation = canvasOrientation
            self.contentShareLayout = contentShareLayout
            self.horizontalLayoutConfiguration = horizontalLayoutConfiguration
            self.presenterOnlyConfiguration = presenterOnlyConfiguration
            self.verticalLayoutConfiguration = verticalLayoutConfiguration
            self.videoAttribute = videoAttribute
        }

        public func validate(name: String) throws {
            try self.horizontalLayoutConfiguration?.validate(name: "\(name).horizontalLayoutConfiguration")
            try self.verticalLayoutConfiguration?.validate(name: "\(name).verticalLayoutConfiguration")
            try self.videoAttribute?.validate(name: "\(name).videoAttribute")
        }

        private enum CodingKeys: String, CodingKey {
            case activeSpeakerOnlyConfiguration = "ActiveSpeakerOnlyConfiguration"
            case canvasOrientation = "CanvasOrientation"
            case contentShareLayout = "ContentShareLayout"
            case horizontalLayoutConfiguration = "HorizontalLayoutConfiguration"
            case presenterOnlyConfiguration = "PresenterOnlyConfiguration"
            case verticalLayoutConfiguration = "VerticalLayoutConfiguration"
            case videoAttribute = "VideoAttribute"
        }
    }

    public struct HorizontalLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the aspect ratio of all video tiles.
        public let tileAspectRatio: String?
        /// The maximum number of video tiles to display.
        public let tileCount: Int?
        /// Sets the automatic ordering of the video tiles.
        public let tileOrder: TileOrder?
        /// Sets the position of horizontal tiles.
        public let tilePosition: HorizontalTilePosition?

        public init(tileAspectRatio: String? = nil, tileCount: Int? = nil, tileOrder: TileOrder? = nil, tilePosition: HorizontalTilePosition? = nil) {
            self.tileAspectRatio = tileAspectRatio
            self.tileCount = tileCount
            self.tileOrder = tileOrder
            self.tilePosition = tilePosition
        }

        public func validate(name: String) throws {
            try self.validate(self.tileAspectRatio, name: "tileAspectRatio", parent: name, pattern: "^\\d{1,2}\\/\\d{1,2}$")
            try self.validate(self.tileCount, name: "tileCount", parent: name, max: 10)
            try self.validate(self.tileCount, name: "tileCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tileAspectRatio = "TileAspectRatio"
            case tileCount = "TileCount"
            case tileOrder = "TileOrder"
            case tilePosition = "TilePosition"
        }
    }

    public struct IssueDetectionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the issue detection rule.
        public let ruleName: String

        public init(ruleName: String) {
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 64)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 2)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "RuleName"
        }
    }

    public struct KeywordMatchConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The keywords or phrases that you want to match.
        public let keywords: [String]
        /// Matches keywords or phrases on their presence or absence. If set to TRUE, the rule matches when all the specified keywords or phrases are absent. Default: FALSE.
        public let negate: Bool?
        /// The name of the keyword match rule.
        public let ruleName: String

        public init(keywords: [String], negate: Bool? = nil, ruleName: String) {
            self.keywords = keywords
            self.negate = negate
            self.ruleName = ruleName
        }

        public func validate(name: String) throws {
            try self.keywords.forEach {
                try validate($0, name: "keywords[]", parent: name, max: 100)
                try validate($0, name: "keywords[]", parent: name, min: 1)
                try validate($0, name: "keywords[]", parent: name, pattern: "^[\\s0-9a-zA-Z'-]+$")
            }
            try self.validate(self.keywords, name: "keywords", parent: name, max: 10)
            try self.validate(self.keywords, name: "keywords", parent: name, min: 1)
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 64)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 2)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case keywords = "Keywords"
            case negate = "Negate"
            case ruleName = "RuleName"
        }
    }

    public struct KinesisDataStreamSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the sink.
        public let insightsTarget: String?

        public init(insightsTarget: String? = nil) {
            self.insightsTarget = insightsTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, max: 1024)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, min: 1)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightsTarget = "InsightsTarget"
        }
    }

    public struct KinesisVideoStreamConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The amount of time that data is retained.
        public let dataRetentionInHours: Int?
        /// The Amazon Web Services Region of the video stream.
        public let region: String

        public init(dataRetentionInHours: Int? = nil, region: String) {
            self.dataRetentionInHours = dataRetentionInHours
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.dataRetentionInHours, name: "dataRetentionInHours", parent: name, min: 0)
            try self.validate(self.region, name: "region", parent: name, max: 32)
            try self.validate(self.region, name: "region", parent: name, min: 1)
            try self.validate(self.region, name: "region", parent: name, pattern: "^([a-z]+-){2,}\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataRetentionInHours = "DataRetentionInHours"
            case region = "Region"
        }
    }

    public struct KinesisVideoStreamConfigurationUpdate: AWSEncodableShape {
        /// The updated time that data is retained.
        public let dataRetentionInHours: Int?

        public init(dataRetentionInHours: Int? = nil) {
            self.dataRetentionInHours = dataRetentionInHours
        }

        public func validate(name: String) throws {
            try self.validate(self.dataRetentionInHours, name: "dataRetentionInHours", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataRetentionInHours = "DataRetentionInHours"
        }
    }

    public struct KinesisVideoStreamPoolConfiguration: AWSDecodableShape {
        /// The time at which the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The ARN of the video stream pool configuration.
        public let poolArn: String?
        /// The ID of the video stream pool in the configuration.
        public let poolId: String?
        /// The name of the video stream pool configuration.
        public let poolName: String?
        /// The size of the video stream pool in the configuration.
        public let poolSize: Int?
        /// The status of the video stream pool in the configuration.
        public let poolStatus: KinesisVideoStreamPoolStatus?
        /// The Kinesis video stream pool configuration object.
        public let streamConfiguration: KinesisVideoStreamConfiguration?
        /// The time at which the configuration was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, poolArn: String? = nil, poolId: String? = nil, poolName: String? = nil, poolSize: Int? = nil, poolStatus: KinesisVideoStreamPoolStatus? = nil, streamConfiguration: KinesisVideoStreamConfiguration? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.poolArn = poolArn
            self.poolId = poolId
            self.poolName = poolName
            self.poolSize = poolSize
            self.poolStatus = poolStatus
            self.streamConfiguration = streamConfiguration
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case poolName = "PoolName"
            case poolSize = "PoolSize"
            case poolStatus = "PoolStatus"
            case streamConfiguration = "StreamConfiguration"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct KinesisVideoStreamPoolSummary: AWSDecodableShape {
        /// The ARN of the video stream pool.
        public let poolArn: String?
        /// The ID of the video stream pool.
        public let poolId: String?
        /// The name of the video stream pool.
        public let poolName: String?

        public init(poolArn: String? = nil, poolId: String? = nil, poolName: String? = nil) {
            self.poolArn = poolArn
            self.poolId = poolId
            self.poolName = poolName
        }

        private enum CodingKeys: String, CodingKey {
            case poolArn = "PoolArn"
            case poolId = "PoolId"
            case poolName = "PoolName"
        }
    }

    public struct KinesisVideoStreamRecordingSourceRuntimeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Describes the timestamp range and timestamp origin of a range of fragments in the Kinesis video stream.
        public let fragmentSelector: FragmentSelector
        /// The stream or streams to be recorded.
        public let streams: [RecordingStreamConfiguration]

        public init(fragmentSelector: FragmentSelector, streams: [RecordingStreamConfiguration]) {
            self.fragmentSelector = fragmentSelector
            self.streams = streams
        }

        public func validate(name: String) throws {
            try self.streams.forEach {
                try $0.validate(name: "\(name).streams[]")
            }
            try self.validate(self.streams, name: "streams", parent: name, max: 2)
            try self.validate(self.streams, name: "streams", parent: name, min: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case fragmentSelector = "FragmentSelector"
            case streams = "Streams"
        }
    }

    public struct KinesisVideoStreamSourceRuntimeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the encoding of your input audio. Supported format: PCM (only signed 16-bit little-endian audio formats, which does not include WAV) For more information, see Media formats in the Amazon Transcribe Developer Guide.
        public let mediaEncoding: MediaEncoding
        /// The sample rate of the input audio (in hertz). Low-quality audio, such as telephone  audio, is typically around 8,000 Hz. High-quality audio typically ranges from 16,000 Hz to  48,000 Hz. Note that the sample rate you specify must match that of your audio. Valid Range: Minimum value of 8000. Maximum value of 48000.
        public let mediaSampleRate: Int
        /// The streams in the source runtime configuration of a Kinesis video stream.
        public let streams: [StreamConfiguration]

        public init(mediaEncoding: MediaEncoding, mediaSampleRate: Int, streams: [StreamConfiguration]) {
            self.mediaEncoding = mediaEncoding
            self.mediaSampleRate = mediaSampleRate
            self.streams = streams
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaSampleRate, name: "mediaSampleRate", parent: name, max: 48000)
            try self.validate(self.mediaSampleRate, name: "mediaSampleRate", parent: name, min: 8000)
            try self.streams.forEach {
                try $0.validate(name: "\(name).streams[]")
            }
            try self.validate(self.streams, name: "streams", parent: name, max: 2)
            try self.validate(self.streams, name: "streams", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case mediaEncoding = "MediaEncoding"
            case mediaSampleRate = "MediaSampleRate"
            case streams = "Streams"
        }
    }

    public struct KinesisVideoStreamSourceTaskConfiguration: AWSEncodableShape {
        /// The channel ID.
        public let channelId: Int
        /// The unique identifier of the fragment to begin processing.
        public let fragmentNumber: String?
        /// The ARN of the stream.
        public let streamArn: String

        public init(channelId: Int = 0, fragmentNumber: String? = nil, streamArn: String) {
            self.channelId = channelId
            self.fragmentNumber = fragmentNumber
            self.streamArn = streamArn
        }

        public func validate(name: String) throws {
            try self.validate(self.channelId, name: "channelId", parent: name, max: 1)
            try self.validate(self.channelId, name: "channelId", parent: name, min: 0)
            try self.validate(self.fragmentNumber, name: "fragmentNumber", parent: name, max: 128)
            try self.validate(self.fragmentNumber, name: "fragmentNumber", parent: name, min: 1)
            try self.validate(self.fragmentNumber, name: "fragmentNumber", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.streamArn, name: "streamArn", parent: name, max: 1024)
            try self.validate(self.streamArn, name: "streamArn", parent: name, min: 1)
            try self.validate(self.streamArn, name: "streamArn", parent: name, pattern: "^arn:[a-z\\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case channelId = "ChannelId"
            case fragmentNumber = "FragmentNumber"
            case streamArn = "StreamArn"
        }
    }

    public struct LambdaFunctionSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the sink.
        public let insightsTarget: String?

        public init(insightsTarget: String? = nil) {
            self.insightsTarget = insightsTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, max: 1024)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, min: 1)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightsTarget = "InsightsTarget"
        }
    }

    public struct ListMediaCapturePipelinesRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
        public let maxResults: Int?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMediaCapturePipelinesResponse: AWSDecodableShape {
        /// The media pipeline objects in the list.
        public let mediaCapturePipelines: [MediaCapturePipelineSummary]?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(mediaCapturePipelines: [MediaCapturePipelineSummary]? = nil, nextToken: String? = nil) {
            self.mediaCapturePipelines = mediaCapturePipelines
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipelines = "MediaCapturePipelines"
            case nextToken = "NextToken"
        }
    }

    public struct ListMediaInsightsPipelineConfigurationsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token used to return the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMediaInsightsPipelineConfigurationsResponse: AWSDecodableShape {
        /// The requested list of media insights pipeline configurations.
        public let mediaInsightsPipelineConfigurations: [MediaInsightsPipelineConfigurationSummary]?
        /// The token used to return the next page of results.
        public let nextToken: String?

        public init(mediaInsightsPipelineConfigurations: [MediaInsightsPipelineConfigurationSummary]? = nil, nextToken: String? = nil) {
            self.mediaInsightsPipelineConfigurations = mediaInsightsPipelineConfigurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mediaInsightsPipelineConfigurations = "MediaInsightsPipelineConfigurations"
            case nextToken = "NextToken"
        }
    }

    public struct ListMediaPipelineKinesisVideoStreamPoolsRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token used to return the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMediaPipelineKinesisVideoStreamPoolsResponse: AWSDecodableShape {
        /// The list of video stream pools.
        public let kinesisVideoStreamPools: [KinesisVideoStreamPoolSummary]?
        /// The token used to return the next page of results.
        public let nextToken: String?

        public init(kinesisVideoStreamPools: [KinesisVideoStreamPoolSummary]? = nil, nextToken: String? = nil) {
            self.kinesisVideoStreamPools = kinesisVideoStreamPools
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisVideoStreamPools = "KinesisVideoStreamPools"
            case nextToken = "NextToken"
        }
    }

    public struct ListMediaPipelinesRequest: AWSEncodableShape {
        /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
        public let maxResults: Int?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "max-results")
            request.encodeQuery(self.nextToken, key: "next-token")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: ".*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMediaPipelinesResponse: AWSDecodableShape {
        /// The media pipeline objects in the list.
        public let mediaPipelines: [MediaPipelineSummary]?
        /// The token used to retrieve the next page of results.
        public let nextToken: String?

        public init(mediaPipelines: [MediaPipelineSummary]? = nil, nextToken: String? = nil) {
            self.mediaPipelines = mediaPipelines
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipelines = "MediaPipelines"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's region, resource ID, and pipeline ID.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.resourceARN, key: "arn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags associated with the specified media pipeline.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LiveConnectorRTMPConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The audio channels set for the RTMP configuration
        public let audioChannels: AudioChannelsOption?
        /// The audio sample rate set for the RTMP configuration. Default: 48000.
        public let audioSampleRate: String?
        /// The URL of the RTMP configuration.
        public let url: String

        public init(audioChannels: AudioChannelsOption? = nil, audioSampleRate: String? = nil, url: String) {
            self.audioChannels = audioChannels
            self.audioSampleRate = audioSampleRate
            self.url = url
        }

        public func validate(name: String) throws {
            try self.validate(self.audioSampleRate, name: "audioSampleRate", parent: name, pattern: "^44100|48000$")
            try self.validate(self.url, name: "url", parent: name, max: 1024)
            try self.validate(self.url, name: "url", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case audioChannels = "AudioChannels"
            case audioSampleRate = "AudioSampleRate"
            case url = "Url"
        }
    }

    public struct LiveConnectorSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The sink configuration's RTMP configuration settings.
        public let rtmpConfiguration: LiveConnectorRTMPConfiguration
        /// The sink configuration's sink type.
        public let sinkType: LiveConnectorSinkType

        public init(rtmpConfiguration: LiveConnectorRTMPConfiguration, sinkType: LiveConnectorSinkType) {
            self.rtmpConfiguration = rtmpConfiguration
            self.sinkType = sinkType
        }

        public func validate(name: String) throws {
            try self.rtmpConfiguration.validate(name: "\(name).rtmpConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case rtmpConfiguration = "RTMPConfiguration"
            case sinkType = "SinkType"
        }
    }

    public struct LiveConnectorSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The configuration settings of the connector pipeline.
        public let chimeSdkMeetingLiveConnectorConfiguration: ChimeSdkMeetingLiveConnectorConfiguration
        /// The source configuration's media source type.
        public let sourceType: LiveConnectorSourceType

        public init(chimeSdkMeetingLiveConnectorConfiguration: ChimeSdkMeetingLiveConnectorConfiguration, sourceType: LiveConnectorSourceType) {
            self.chimeSdkMeetingLiveConnectorConfiguration = chimeSdkMeetingLiveConnectorConfiguration
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.chimeSdkMeetingLiveConnectorConfiguration.validate(name: "\(name).chimeSdkMeetingLiveConnectorConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingLiveConnectorConfiguration = "ChimeSdkMeetingLiveConnectorConfiguration"
            case sourceType = "SourceType"
        }
    }

    public struct MediaCapturePipeline: AWSDecodableShape {
        /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
        public let chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration?
        /// The time at which the pipeline was created, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The ARN of the media capture pipeline
        public let mediaPipelineArn: String?
        /// The ID of a media pipeline.
        public let mediaPipelineId: String?
        /// ARN of the destination to which the media artifacts are saved.
        public let sinkArn: String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public let sinkType: MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts are saved.
        public let sourceArn: String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public let sourceType: MediaPipelineSourceType?
        /// The status of the media pipeline.
        public let status: MediaPipelineStatus?
        /// The time at which the pipeline was updated, in ISO 8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(chimeSdkMeetingConfiguration: ChimeSdkMeetingConfiguration? = nil, createdTimestamp: Date? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, sinkArn: String? = nil, sinkType: MediaPipelineSinkType? = nil, sourceArn: String? = nil, sourceType: MediaPipelineSourceType? = nil, status: MediaPipelineStatus? = nil, updatedTimestamp: Date? = nil) {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
            case createdTimestamp = "CreatedTimestamp"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case sinkArn = "SinkArn"
            case sinkType = "SinkType"
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
            case status = "Status"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaCapturePipelineSourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The meeting configuration settings in a media capture pipeline configuration object.
        public let chimeSdkMeetingConfiguration: ChimeSdkMeetingConcatenationConfiguration
        /// The media pipeline ARN in the configuration object of a media capture pipeline.
        public let mediaPipelineArn: String

        public init(chimeSdkMeetingConfiguration: ChimeSdkMeetingConcatenationConfiguration, mediaPipelineArn: String) {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.mediaPipelineArn = mediaPipelineArn
        }

        public func validate(name: String) throws {
            try self.validate(self.mediaPipelineArn, name: "mediaPipelineArn", parent: name, max: 1024)
            try self.validate(self.mediaPipelineArn, name: "mediaPipelineArn", parent: name, min: 1)
            try self.validate(self.mediaPipelineArn, name: "mediaPipelineArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case chimeSdkMeetingConfiguration = "ChimeSdkMeetingConfiguration"
            case mediaPipelineArn = "MediaPipelineArn"
        }
    }

    public struct MediaCapturePipelineSummary: AWSDecodableShape {
        /// The ARN of the media pipeline in the summary.
        public let mediaPipelineArn: String?
        /// The ID of the media pipeline in the summary.
        public let mediaPipelineId: String?

        public init(mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil) {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
        }
    }

    public struct MediaConcatenationPipeline: AWSDecodableShape {
        /// The time at which the concatenation pipeline was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The ARN of the media pipeline that you specify in the SourceConfiguration object.
        public let mediaPipelineArn: String?
        /// The ID of the media pipeline being concatenated.
        public let mediaPipelineId: String?
        /// The data sinks of the concatenation pipeline.
        public let sinks: [ConcatenationSink]?
        /// The data sources being concatenated.
        public let sources: [ConcatenationSource]?
        /// The status of the concatenation pipeline.
        public let status: MediaPipelineStatus?
        /// The time at which the concatenation pipeline was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, sinks: [ConcatenationSink]? = nil, sources: [ConcatenationSource]? = nil, status: MediaPipelineStatus? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case sinks = "Sinks"
            case sources = "Sources"
            case status = "Status"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaInsightsPipeline: AWSDecodableShape {
        /// The time at which the media insights pipeline was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The statuses that the elements in a media insights pipeline can have during data processing.
        public let elementStatuses: [MediaInsightsPipelineElementStatus]?
        /// The runtime configuration settings for a Kinesis recording video stream in a media insights pipeline.
        public let kinesisVideoStreamRecordingSourceRuntimeConfiguration: KinesisVideoStreamRecordingSourceRuntimeConfiguration?
        /// The configuration settings for a Kinesis runtime video stream in a media insights pipeline.
        public let kinesisVideoStreamSourceRuntimeConfiguration: KinesisVideoStreamSourceRuntimeConfiguration?
        /// The ARN of a media insight pipeline's configuration settings.
        public let mediaInsightsPipelineConfigurationArn: String?
        /// The runtime metadata of a media insights pipeline.
        public let mediaInsightsRuntimeMetadata: [String: String]?
        /// The ARN of a media insights pipeline.
        public let mediaPipelineArn: String?
        /// The ID of a media insights pipeline.
        public let mediaPipelineId: String?
        /// The runtime configuration of the Amazon S3 bucket that stores recordings in a media insights pipeline.
        public let s3RecordingSinkRuntimeConfiguration: S3RecordingSinkRuntimeConfiguration?
        /// The status of a media insights pipeline.
        public let status: MediaPipelineStatus?

        public init(createdTimestamp: Date? = nil, elementStatuses: [MediaInsightsPipelineElementStatus]? = nil, kinesisVideoStreamRecordingSourceRuntimeConfiguration: KinesisVideoStreamRecordingSourceRuntimeConfiguration? = nil, kinesisVideoStreamSourceRuntimeConfiguration: KinesisVideoStreamSourceRuntimeConfiguration? = nil, mediaInsightsPipelineConfigurationArn: String? = nil, mediaInsightsRuntimeMetadata: [String: String]? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, s3RecordingSinkRuntimeConfiguration: S3RecordingSinkRuntimeConfiguration? = nil, status: MediaPipelineStatus? = nil) {
            self.createdTimestamp = createdTimestamp
            self.elementStatuses = elementStatuses
            self.kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfiguration
            self.kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfiguration
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfiguration
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case elementStatuses = "ElementStatuses"
            case kinesisVideoStreamRecordingSourceRuntimeConfiguration = "KinesisVideoStreamRecordingSourceRuntimeConfiguration"
            case kinesisVideoStreamSourceRuntimeConfiguration = "KinesisVideoStreamSourceRuntimeConfiguration"
            case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
            case mediaInsightsRuntimeMetadata = "MediaInsightsRuntimeMetadata"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case s3RecordingSinkRuntimeConfiguration = "S3RecordingSinkRuntimeConfiguration"
            case status = "Status"
        }
    }

    public struct MediaInsightsPipelineConfiguration: AWSDecodableShape {
        /// The time at which the configuration was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The elements in the configuration.
        public let elements: [MediaInsightsPipelineConfigurationElement]?
        /// The ARN of the configuration.
        public let mediaInsightsPipelineConfigurationArn: String?
        /// The ID of the configuration.
        public let mediaInsightsPipelineConfigurationId: String?
        /// The name of the configuration.
        public let mediaInsightsPipelineConfigurationName: String?
        /// Lists the rules that trigger a real-time alert.
        public let realTimeAlertConfiguration: RealTimeAlertConfiguration?
        /// The ARN of the role used by the service to access Amazon Web Services resources.
        public let resourceAccessRoleArn: String?
        /// The time at which the configuration was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, elements: [MediaInsightsPipelineConfigurationElement]? = nil, mediaInsightsPipelineConfigurationArn: String? = nil, mediaInsightsPipelineConfigurationId: String? = nil, mediaInsightsPipelineConfigurationName: String? = nil, realTimeAlertConfiguration: RealTimeAlertConfiguration? = nil, resourceAccessRoleArn: String? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.elements = elements
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationId
            self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
            self.realTimeAlertConfiguration = realTimeAlertConfiguration
            self.resourceAccessRoleArn = resourceAccessRoleArn
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case elements = "Elements"
            case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
            case mediaInsightsPipelineConfigurationId = "MediaInsightsPipelineConfigurationId"
            case mediaInsightsPipelineConfigurationName = "MediaInsightsPipelineConfigurationName"
            case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
            case resourceAccessRoleArn = "ResourceAccessRoleArn"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaInsightsPipelineConfigurationElement: AWSEncodableShape & AWSDecodableShape {
        /// The analytics configuration settings for transcribing audio in a media insights pipeline configuration element.
        public let amazonTranscribeCallAnalyticsProcessorConfiguration: AmazonTranscribeCallAnalyticsProcessorConfiguration?
        /// The transcription processor configuration settings in a media insights pipeline configuration element.
        public let amazonTranscribeProcessorConfiguration: AmazonTranscribeProcessorConfiguration?
        /// The configuration settings for the Kinesis Data Stream Sink in a media insights pipeline configuration element.
        public let kinesisDataStreamSinkConfiguration: KinesisDataStreamSinkConfiguration?
        /// The configuration settings for the Amazon Web Services Lambda sink in a media insights pipeline configuration element.
        public let lambdaFunctionSinkConfiguration: LambdaFunctionSinkConfiguration?
        /// The configuration settings for the Amazon S3 recording bucket in a media insights pipeline configuration element.
        public let s3RecordingSinkConfiguration: S3RecordingSinkConfiguration?
        /// The configuration settings for an SNS topic sink in a media insights pipeline configuration element.
        public let snsTopicSinkConfiguration: SnsTopicSinkConfiguration?
        /// The configuration settings for an SQS queue sink in a media insights pipeline configuration element.
        public let sqsQueueSinkConfiguration: SqsQueueSinkConfiguration?
        /// The element type.
        public let type: MediaInsightsPipelineConfigurationElementType
        /// The voice analytics configuration settings in a media insights pipeline configuration element.
        public let voiceAnalyticsProcessorConfiguration: VoiceAnalyticsProcessorConfiguration?
        /// The configuration settings for voice enhancement sink in a media insights pipeline configuration element.
        public let voiceEnhancementSinkConfiguration: VoiceEnhancementSinkConfiguration?

        public init(amazonTranscribeCallAnalyticsProcessorConfiguration: AmazonTranscribeCallAnalyticsProcessorConfiguration? = nil, amazonTranscribeProcessorConfiguration: AmazonTranscribeProcessorConfiguration? = nil, kinesisDataStreamSinkConfiguration: KinesisDataStreamSinkConfiguration? = nil, lambdaFunctionSinkConfiguration: LambdaFunctionSinkConfiguration? = nil, s3RecordingSinkConfiguration: S3RecordingSinkConfiguration? = nil, snsTopicSinkConfiguration: SnsTopicSinkConfiguration? = nil, sqsQueueSinkConfiguration: SqsQueueSinkConfiguration? = nil, type: MediaInsightsPipelineConfigurationElementType, voiceAnalyticsProcessorConfiguration: VoiceAnalyticsProcessorConfiguration? = nil, voiceEnhancementSinkConfiguration: VoiceEnhancementSinkConfiguration? = nil) {
            self.amazonTranscribeCallAnalyticsProcessorConfiguration = amazonTranscribeCallAnalyticsProcessorConfiguration
            self.amazonTranscribeProcessorConfiguration = amazonTranscribeProcessorConfiguration
            self.kinesisDataStreamSinkConfiguration = kinesisDataStreamSinkConfiguration
            self.lambdaFunctionSinkConfiguration = lambdaFunctionSinkConfiguration
            self.s3RecordingSinkConfiguration = s3RecordingSinkConfiguration
            self.snsTopicSinkConfiguration = snsTopicSinkConfiguration
            self.sqsQueueSinkConfiguration = sqsQueueSinkConfiguration
            self.type = type
            self.voiceAnalyticsProcessorConfiguration = voiceAnalyticsProcessorConfiguration
            self.voiceEnhancementSinkConfiguration = voiceEnhancementSinkConfiguration
        }

        public func validate(name: String) throws {
            try self.amazonTranscribeCallAnalyticsProcessorConfiguration?.validate(name: "\(name).amazonTranscribeCallAnalyticsProcessorConfiguration")
            try self.amazonTranscribeProcessorConfiguration?.validate(name: "\(name).amazonTranscribeProcessorConfiguration")
            try self.kinesisDataStreamSinkConfiguration?.validate(name: "\(name).kinesisDataStreamSinkConfiguration")
            try self.lambdaFunctionSinkConfiguration?.validate(name: "\(name).lambdaFunctionSinkConfiguration")
            try self.s3RecordingSinkConfiguration?.validate(name: "\(name).s3RecordingSinkConfiguration")
            try self.snsTopicSinkConfiguration?.validate(name: "\(name).snsTopicSinkConfiguration")
            try self.sqsQueueSinkConfiguration?.validate(name: "\(name).sqsQueueSinkConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case amazonTranscribeCallAnalyticsProcessorConfiguration = "AmazonTranscribeCallAnalyticsProcessorConfiguration"
            case amazonTranscribeProcessorConfiguration = "AmazonTranscribeProcessorConfiguration"
            case kinesisDataStreamSinkConfiguration = "KinesisDataStreamSinkConfiguration"
            case lambdaFunctionSinkConfiguration = "LambdaFunctionSinkConfiguration"
            case s3RecordingSinkConfiguration = "S3RecordingSinkConfiguration"
            case snsTopicSinkConfiguration = "SnsTopicSinkConfiguration"
            case sqsQueueSinkConfiguration = "SqsQueueSinkConfiguration"
            case type = "Type"
            case voiceAnalyticsProcessorConfiguration = "VoiceAnalyticsProcessorConfiguration"
            case voiceEnhancementSinkConfiguration = "VoiceEnhancementSinkConfiguration"
        }
    }

    public struct MediaInsightsPipelineConfigurationSummary: AWSDecodableShape {
        /// The ARN of the media insights pipeline configuration.
        public let mediaInsightsPipelineConfigurationArn: String?
        /// The ID of the media insights pipeline configuration.
        public let mediaInsightsPipelineConfigurationId: String?
        /// The name of the media insights pipeline configuration.
        public let mediaInsightsPipelineConfigurationName: String?

        public init(mediaInsightsPipelineConfigurationArn: String? = nil, mediaInsightsPipelineConfigurationId: String? = nil, mediaInsightsPipelineConfigurationName: String? = nil) {
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationId
            self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
        }

        private enum CodingKeys: String, CodingKey {
            case mediaInsightsPipelineConfigurationArn = "MediaInsightsPipelineConfigurationArn"
            case mediaInsightsPipelineConfigurationId = "MediaInsightsPipelineConfigurationId"
            case mediaInsightsPipelineConfigurationName = "MediaInsightsPipelineConfigurationName"
        }
    }

    public struct MediaInsightsPipelineElementStatus: AWSDecodableShape {
        /// The element's status.
        public let status: MediaPipelineElementStatus?
        /// The type of status.
        public let type: MediaInsightsPipelineConfigurationElementType?

        public init(status: MediaPipelineElementStatus? = nil, type: MediaInsightsPipelineConfigurationElementType? = nil) {
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
            case type = "Type"
        }
    }

    public struct MediaLiveConnectorPipeline: AWSDecodableShape {
        /// The time at which the connector pipeline was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The connector pipeline's ARN.
        public let mediaPipelineArn: String?
        /// The connector pipeline's ID.
        public let mediaPipelineId: String?
        /// The connector pipeline's data sinks.
        public let sinks: [LiveConnectorSinkConfiguration]?
        /// The connector pipeline's data sources.
        public let sources: [LiveConnectorSourceConfiguration]?
        /// The connector pipeline's status.
        public let status: MediaPipelineStatus?
        /// The time at which the connector pipeline was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, sinks: [LiveConnectorSinkConfiguration]? = nil, sources: [LiveConnectorSourceConfiguration]? = nil, status: MediaPipelineStatus? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case sinks = "Sinks"
            case sources = "Sources"
            case status = "Status"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaPipeline: AWSDecodableShape {
        /// A pipeline that enables users to capture audio and video.
        public let mediaCapturePipeline: MediaCapturePipeline?
        /// The media concatenation pipeline in a media pipeline.
        public let mediaConcatenationPipeline: MediaConcatenationPipeline?
        /// The media insights pipeline of a media pipeline.
        public let mediaInsightsPipeline: MediaInsightsPipeline?
        /// The connector pipeline of the media pipeline.
        public let mediaLiveConnectorPipeline: MediaLiveConnectorPipeline?
        /// Designates a media pipeline as a media stream pipeline.
        public let mediaStreamPipeline: MediaStreamPipeline?

        public init(mediaCapturePipeline: MediaCapturePipeline? = nil, mediaConcatenationPipeline: MediaConcatenationPipeline? = nil, mediaInsightsPipeline: MediaInsightsPipeline? = nil, mediaLiveConnectorPipeline: MediaLiveConnectorPipeline? = nil, mediaStreamPipeline: MediaStreamPipeline? = nil) {
            self.mediaCapturePipeline = mediaCapturePipeline
            self.mediaConcatenationPipeline = mediaConcatenationPipeline
            self.mediaInsightsPipeline = mediaInsightsPipeline
            self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
            self.mediaStreamPipeline = mediaStreamPipeline
        }

        private enum CodingKeys: String, CodingKey {
            case mediaCapturePipeline = "MediaCapturePipeline"
            case mediaConcatenationPipeline = "MediaConcatenationPipeline"
            case mediaInsightsPipeline = "MediaInsightsPipeline"
            case mediaLiveConnectorPipeline = "MediaLiveConnectorPipeline"
            case mediaStreamPipeline = "MediaStreamPipeline"
        }
    }

    public struct MediaPipelineSummary: AWSDecodableShape {
        /// The ARN of the media pipeline in the summary.
        public let mediaPipelineArn: String?
        /// The ID of the media pipeline in the summary.
        public let mediaPipelineId: String?

        public init(mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil) {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
        }
    }

    public struct MediaStreamPipeline: AWSDecodableShape {
        /// The time at which the media stream pipeline was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The ARN of the media stream pipeline.
        public let mediaPipelineArn: String?
        /// The ID of the media stream pipeline
        public let mediaPipelineId: String?
        /// The media stream pipeline's data sinks.
        public let sinks: [MediaStreamSink]?
        /// The media stream pipeline's data sources.
        public let sources: [MediaStreamSource]?
        /// The status of the media stream pipeline.
        public let status: MediaPipelineStatus?
        /// The time at which the media stream pipeline was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, mediaPipelineArn: String? = nil, mediaPipelineId: String? = nil, sinks: [MediaStreamSink]? = nil, sources: [MediaStreamSource]? = nil, status: MediaPipelineStatus? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case mediaPipelineArn = "MediaPipelineArn"
            case mediaPipelineId = "MediaPipelineId"
            case sinks = "Sinks"
            case sources = "Sources"
            case status = "Status"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct MediaStreamSink: AWSEncodableShape & AWSDecodableShape {
        /// The media stream sink's media stream type.
        public let mediaStreamType: MediaStreamType
        /// Specifies the number of streams that the sink can accept.
        public let reservedStreamCapacity: Int
        /// The ARN of the media stream sink.
        public let sinkArn: String
        /// The media stream sink's type.
        public let sinkType: MediaStreamPipelineSinkType

        public init(mediaStreamType: MediaStreamType, reservedStreamCapacity: Int, sinkArn: String, sinkType: MediaStreamPipelineSinkType) {
            self.mediaStreamType = mediaStreamType
            self.reservedStreamCapacity = reservedStreamCapacity
            self.sinkArn = sinkArn
            self.sinkType = sinkType
        }

        public func validate(name: String) throws {
            try self.validate(self.reservedStreamCapacity, name: "reservedStreamCapacity", parent: name, max: 10)
            try self.validate(self.reservedStreamCapacity, name: "reservedStreamCapacity", parent: name, min: 1)
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, max: 1024)
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, min: 1)
            try self.validate(self.sinkArn, name: "sinkArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case mediaStreamType = "MediaStreamType"
            case reservedStreamCapacity = "ReservedStreamCapacity"
            case sinkArn = "SinkArn"
            case sinkType = "SinkType"
        }
    }

    public struct MediaStreamSource: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the media stream source.
        public let sourceArn: String
        /// The type of media stream source.
        public let sourceType: MediaPipelineSourceType

        public init(sourceArn: String, sourceType: MediaPipelineSourceType) {
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, max: 1024)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, min: 1)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceArn = "SourceArn"
            case sourceType = "SourceType"
        }
    }

    public struct MeetingEventsConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct PostCallAnalyticsSettings: AWSEncodableShape & AWSDecodableShape {
        /// The content redaction output settings for a post-call analysis task.
        public let contentRedactionOutput: ContentRedactionOutput?
        /// The ARN of the role used by Amazon Web Services Transcribe to upload your post call analysis. For more information, see  Post-call analytics with real-time transcriptions in the Amazon Transcribe Developer Guide.
        public let dataAccessRoleArn: String
        /// The ID of the KMS (Key Management Service) key used to encrypt the output.
        public let outputEncryptionKMSKeyId: String?
        /// The URL of the Amazon S3 bucket that contains the post-call data.
        public let outputLocation: String

        public init(contentRedactionOutput: ContentRedactionOutput? = nil, dataAccessRoleArn: String, outputEncryptionKMSKeyId: String? = nil, outputLocation: String) {
            self.contentRedactionOutput = contentRedactionOutput
            self.dataAccessRoleArn = dataAccessRoleArn
            self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
            self.outputLocation = outputLocation
        }

        public func validate(name: String) throws {
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, max: 4096)
            try self.validate(self.dataAccessRoleArn, name: "dataAccessRoleArn", parent: name, pattern: ".*")
            try self.validate(self.outputEncryptionKMSKeyId, name: "outputEncryptionKMSKeyId", parent: name, max: 4096)
            try self.validate(self.outputEncryptionKMSKeyId, name: "outputEncryptionKMSKeyId", parent: name, pattern: ".*")
            try self.validate(self.outputLocation, name: "outputLocation", parent: name, max: 4096)
            try self.validate(self.outputLocation, name: "outputLocation", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case contentRedactionOutput = "ContentRedactionOutput"
            case dataAccessRoleArn = "DataAccessRoleArn"
            case outputEncryptionKMSKeyId = "OutputEncryptionKMSKeyId"
            case outputLocation = "OutputLocation"
        }
    }

    public struct PresenterOnlyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Defines the position of the presenter video tile. Default: TopRight.
        public let presenterPosition: PresenterPosition?

        public init(presenterPosition: PresenterPosition? = nil) {
            self.presenterPosition = presenterPosition
        }

        private enum CodingKeys: String, CodingKey {
            case presenterPosition = "PresenterPosition"
        }
    }

    public struct RealTimeAlertConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Turns off real-time alerts.
        public let disabled: Bool?
        /// The rules in the alert. Rules specify the words or phrases that you want to be notified about.
        public let rules: [RealTimeAlertRule]?

        public init(disabled: Bool? = nil, rules: [RealTimeAlertRule]? = nil) {
            self.disabled = disabled
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 3)
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case disabled = "Disabled"
            case rules = "Rules"
        }
    }

    public struct RealTimeAlertRule: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the issue detection settings for a real-time alert rule.
        public let issueDetectionConfiguration: IssueDetectionConfiguration?
        /// Specifies the settings for matching the keywords in a real-time alert rule.
        public let keywordMatchConfiguration: KeywordMatchConfiguration?
        /// Specifies the settings for predicting sentiment in a real-time alert rule.
        public let sentimentConfiguration: SentimentConfiguration?
        /// The type of alert rule.
        public let type: RealTimeAlertRuleType

        public init(issueDetectionConfiguration: IssueDetectionConfiguration? = nil, keywordMatchConfiguration: KeywordMatchConfiguration? = nil, sentimentConfiguration: SentimentConfiguration? = nil, type: RealTimeAlertRuleType) {
            self.issueDetectionConfiguration = issueDetectionConfiguration
            self.keywordMatchConfiguration = keywordMatchConfiguration
            self.sentimentConfiguration = sentimentConfiguration
            self.type = type
        }

        public func validate(name: String) throws {
            try self.issueDetectionConfiguration?.validate(name: "\(name).issueDetectionConfiguration")
            try self.keywordMatchConfiguration?.validate(name: "\(name).keywordMatchConfiguration")
            try self.sentimentConfiguration?.validate(name: "\(name).sentimentConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case issueDetectionConfiguration = "IssueDetectionConfiguration"
            case keywordMatchConfiguration = "KeywordMatchConfiguration"
            case sentimentConfiguration = "SentimentConfiguration"
            case type = "Type"
        }
    }

    public struct RecordingStreamConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the recording stream.
        public let streamArn: String?

        public init(streamArn: String? = nil) {
            self.streamArn = streamArn
        }

        public func validate(name: String) throws {
            try self.validate(self.streamArn, name: "streamArn", parent: name, max: 1024)
            try self.validate(self.streamArn, name: "streamArn", parent: name, min: 1)
            try self.validate(self.streamArn, name: "streamArn", parent: name, pattern: "^arn:[a-z\\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case streamArn = "StreamArn"
        }
    }

    public struct S3BucketSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The destination URL of the S3 bucket.
        public let destination: String

        public init(destination: String) {
            self.destination = destination
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
        }
    }

    public struct S3RecordingSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The default URI of the Amazon S3 bucket used as the recording sink.
        public let destination: String?
        /// The default file format for the media files sent to the Amazon S3 bucket.
        public let recordingFileFormat: RecordingFileFormat?

        public init(destination: String? = nil, recordingFileFormat: RecordingFileFormat? = nil) {
            self.destination = destination
            self.recordingFileFormat = recordingFileFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case recordingFileFormat = "RecordingFileFormat"
        }
    }

    public struct S3RecordingSinkRuntimeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The URI of the S3 bucket used as the sink.
        public let destination: String
        /// The file format for the media files sent to the Amazon S3 bucket.
        public let recordingFileFormat: RecordingFileFormat

        public init(destination: String, recordingFileFormat: RecordingFileFormat) {
            self.destination = destination
            self.recordingFileFormat = recordingFileFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.destination, name: "destination", parent: name, max: 1024)
            try self.validate(self.destination, name: "destination", parent: name, min: 1)
            try self.validate(self.destination, name: "destination", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case recordingFileFormat = "RecordingFileFormat"
        }
    }

    public struct SelectedVideoStreams: AWSEncodableShape & AWSDecodableShape {
        /// The attendee IDs of the streams selected for a media pipeline.
        public let attendeeIds: [String]?
        /// The external user IDs of the streams selected for a media pipeline.
        public let externalUserIds: [String]?

        public init(attendeeIds: [String]? = nil, externalUserIds: [String]? = nil) {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }

        public func validate(name: String) throws {
            try self.attendeeIds?.forEach {
                try validate($0, name: "attendeeIds[]", parent: name, max: 36)
                try validate($0, name: "attendeeIds[]", parent: name, min: 36)
                try validate($0, name: "attendeeIds[]", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
            }
            try self.validate(self.attendeeIds, name: "attendeeIds", parent: name, min: 1)
            try self.externalUserIds?.forEach {
                try validate($0, name: "externalUserIds[]", parent: name, max: 64)
                try validate($0, name: "externalUserIds[]", parent: name, min: 2)
            }
            try self.validate(self.externalUserIds, name: "externalUserIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attendeeIds = "AttendeeIds"
            case externalUserIds = "ExternalUserIds"
        }
    }

    public struct SentimentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the rule in the sentiment configuration.
        public let ruleName: String
        /// The type of sentiment, POSITIVE, NEGATIVE, or NEUTRAL.
        public let sentimentType: SentimentType
        /// Specifies the analysis interval.
        public let timePeriod: Int

        public init(ruleName: String, sentimentType: SentimentType, timePeriod: Int) {
            self.ruleName = ruleName
            self.sentimentType = sentimentType
            self.timePeriod = timePeriod
        }

        public func validate(name: String) throws {
            try self.validate(self.ruleName, name: "ruleName", parent: name, max: 64)
            try self.validate(self.ruleName, name: "ruleName", parent: name, min: 2)
            try self.validate(self.ruleName, name: "ruleName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.timePeriod, name: "timePeriod", parent: name, max: 1800)
            try self.validate(self.timePeriod, name: "timePeriod", parent: name, min: 60)
        }

        private enum CodingKeys: String, CodingKey {
            case ruleName = "RuleName"
            case sentimentType = "SentimentType"
            case timePeriod = "TimePeriod"
        }
    }

    public struct SnsTopicSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the SNS sink.
        public let insightsTarget: String?

        public init(insightsTarget: String? = nil) {
            self.insightsTarget = insightsTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, max: 1024)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, min: 1)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightsTarget = "InsightsTarget"
        }
    }

    public struct SourceConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The selected video streams for a specified media pipeline. The number of video streams can't exceed 25.
        public let selectedVideoStreams: SelectedVideoStreams?

        public init(selectedVideoStreams: SelectedVideoStreams? = nil) {
            self.selectedVideoStreams = selectedVideoStreams
        }

        public func validate(name: String) throws {
            try self.selectedVideoStreams?.validate(name: "\(name).selectedVideoStreams")
        }

        private enum CodingKeys: String, CodingKey {
            case selectedVideoStreams = "SelectedVideoStreams"
        }
    }

    public struct SpeakerSearchTask: AWSDecodableShape {
        /// The time at which a speaker search task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The speaker search task ID.
        public let speakerSearchTaskId: String?
        /// The status of the speaker search task.
        public let speakerSearchTaskStatus: MediaPipelineTaskStatus?
        /// The time at which a speaker search task was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?

        public init(createdTimestamp: Date? = nil, speakerSearchTaskId: String? = nil, speakerSearchTaskStatus: MediaPipelineTaskStatus? = nil, updatedTimestamp: Date? = nil) {
            self.createdTimestamp = createdTimestamp
            self.speakerSearchTaskId = speakerSearchTaskId
            self.speakerSearchTaskStatus = speakerSearchTaskStatus
            self.updatedTimestamp = updatedTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case speakerSearchTaskId = "SpeakerSearchTaskId"
            case speakerSearchTaskStatus = "SpeakerSearchTaskStatus"
            case updatedTimestamp = "UpdatedTimestamp"
        }
    }

    public struct SqsQueueSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the SQS sink.
        public let insightsTarget: String?

        public init(insightsTarget: String? = nil) {
            self.insightsTarget = insightsTarget
        }

        public func validate(name: String) throws {
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, max: 1024)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, min: 1)
            try self.validate(self.insightsTarget, name: "insightsTarget", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case insightsTarget = "InsightsTarget"
        }
    }

    public struct StartSpeakerSearchTaskRequest: AWSEncodableShape {
        /// The unique identifier for the client request. Use a different token for different speaker search tasks.
        public let clientRequestToken: String?
        /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
        public let identifier: String
        /// The task configuration for the Kinesis video stream source of the media insights pipeline.
        public let kinesisVideoStreamSourceTaskConfiguration: KinesisVideoStreamSourceTaskConfiguration?
        /// The ARN of the voice profile domain that will store the voice profile.
        public let voiceProfileDomainArn: String

        public init(clientRequestToken: String? = StartSpeakerSearchTaskRequest.idempotencyToken(), identifier: String, kinesisVideoStreamSourceTaskConfiguration: KinesisVideoStreamSourceTaskConfiguration? = nil, voiceProfileDomainArn: String) {
            self.clientRequestToken = clientRequestToken
            self.identifier = identifier
            self.kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfiguration
            self.voiceProfileDomainArn = voiceProfileDomainArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientRequestToken, forKey: .clientRequestToken)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.kinesisVideoStreamSourceTaskConfiguration, forKey: .kinesisVideoStreamSourceTaskConfiguration)
            try container.encode(self.voiceProfileDomainArn, forKey: .voiceProfileDomainArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.kinesisVideoStreamSourceTaskConfiguration?.validate(name: "\(name).kinesisVideoStreamSourceTaskConfiguration")
            try self.validate(self.voiceProfileDomainArn, name: "voiceProfileDomainArn", parent: name, max: 1024)
            try self.validate(self.voiceProfileDomainArn, name: "voiceProfileDomainArn", parent: name, min: 1)
            try self.validate(self.voiceProfileDomainArn, name: "voiceProfileDomainArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case kinesisVideoStreamSourceTaskConfiguration = "KinesisVideoStreamSourceTaskConfiguration"
            case voiceProfileDomainArn = "VoiceProfileDomainArn"
        }
    }

    public struct StartSpeakerSearchTaskResponse: AWSDecodableShape {
        /// The details of the speaker search task.
        public let speakerSearchTask: SpeakerSearchTask?

        public init(speakerSearchTask: SpeakerSearchTask? = nil) {
            self.speakerSearchTask = speakerSearchTask
        }

        private enum CodingKeys: String, CodingKey {
            case speakerSearchTask = "SpeakerSearchTask"
        }
    }

    public struct StartVoiceToneAnalysisTaskRequest: AWSEncodableShape {
        /// The unique identifier for the client request. Use a different token for different voice tone analysis tasks.
        public let clientRequestToken: String?
        /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
        public let identifier: String
        /// The task configuration for the Kinesis video stream source of the media insights pipeline.
        public let kinesisVideoStreamSourceTaskConfiguration: KinesisVideoStreamSourceTaskConfiguration?
        /// The language code.
        public let languageCode: VoiceAnalyticsLanguageCode

        public init(clientRequestToken: String? = StartVoiceToneAnalysisTaskRequest.idempotencyToken(), identifier: String, kinesisVideoStreamSourceTaskConfiguration: KinesisVideoStreamSourceTaskConfiguration? = nil, languageCode: VoiceAnalyticsLanguageCode) {
            self.clientRequestToken = clientRequestToken
            self.identifier = identifier
            self.kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfiguration
            self.languageCode = languageCode
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientRequestToken, forKey: .clientRequestToken)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.kinesisVideoStreamSourceTaskConfiguration, forKey: .kinesisVideoStreamSourceTaskConfiguration)
            try container.encode(self.languageCode, forKey: .languageCode)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 2)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, pattern: "^[-_a-zA-Z0-9]*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.kinesisVideoStreamSourceTaskConfiguration?.validate(name: "\(name).kinesisVideoStreamSourceTaskConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case kinesisVideoStreamSourceTaskConfiguration = "KinesisVideoStreamSourceTaskConfiguration"
            case languageCode = "LanguageCode"
        }
    }

    public struct StartVoiceToneAnalysisTaskResponse: AWSDecodableShape {
        /// The details of the voice tone analysis task.
        public let voiceToneAnalysisTask: VoiceToneAnalysisTask?

        public init(voiceToneAnalysisTask: VoiceToneAnalysisTask? = nil) {
            self.voiceToneAnalysisTask = voiceToneAnalysisTask
        }

        private enum CodingKeys: String, CodingKey {
            case voiceToneAnalysisTask = "VoiceToneAnalysisTask"
        }
    }

    public struct StopSpeakerSearchTaskRequest: AWSEncodableShape {
        /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
        public let identifier: String
        /// The speaker search task ID.
        public let speakerSearchTaskId: String

        public init(identifier: String, speakerSearchTaskId: String) {
            self.identifier = identifier
            self.speakerSearchTaskId = speakerSearchTaskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodePath(self.speakerSearchTaskId, key: "SpeakerSearchTaskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.validate(self.speakerSearchTaskId, name: "speakerSearchTaskId", parent: name, max: 36)
            try self.validate(self.speakerSearchTaskId, name: "speakerSearchTaskId", parent: name, min: 36)
            try self.validate(self.speakerSearchTaskId, name: "speakerSearchTaskId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopVoiceToneAnalysisTaskRequest: AWSEncodableShape {
        /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
        public let identifier: String
        /// The ID of the voice tone analysis task.
        public let voiceToneAnalysisTaskId: String

        public init(identifier: String, voiceToneAnalysisTaskId: String) {
            self.identifier = identifier
            self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            request.encodePath(self.voiceToneAnalysisTaskId, key: "VoiceToneAnalysisTaskId")
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.validate(self.voiceToneAnalysisTaskId, name: "voiceToneAnalysisTaskId", parent: name, max: 36)
            try self.validate(self.voiceToneAnalysisTaskId, name: "voiceToneAnalysisTaskId", parent: name, min: 36)
            try self.validate(self.voiceToneAnalysisTaskId, name: "voiceToneAnalysisTaskId", parent: name, pattern: "^[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StreamChannelDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The definitions of the channels in a streaming channel.
        public let channelDefinitions: [ChannelDefinition]?
        /// The number of channels in a streaming channel.
        public let numberOfChannels: Int

        public init(channelDefinitions: [ChannelDefinition]? = nil, numberOfChannels: Int) {
            self.channelDefinitions = channelDefinitions
            self.numberOfChannels = numberOfChannels
        }

        public func validate(name: String) throws {
            try self.channelDefinitions?.forEach {
                try $0.validate(name: "\(name).channelDefinitions[]")
            }
            try self.validate(self.channelDefinitions, name: "channelDefinitions", parent: name, max: 2)
            try self.validate(self.channelDefinitions, name: "channelDefinitions", parent: name, min: 1)
            try self.validate(self.numberOfChannels, name: "numberOfChannels", parent: name, max: 2)
            try self.validate(self.numberOfChannels, name: "numberOfChannels", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channelDefinitions = "ChannelDefinitions"
            case numberOfChannels = "NumberOfChannels"
        }
    }

    public struct StreamConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the fragment to begin processing.
        public let fragmentNumber: String?
        /// The ARN of the stream.
        public let streamArn: String
        /// The streaming channel definition in the stream configuration.
        public let streamChannelDefinition: StreamChannelDefinition

        public init(fragmentNumber: String? = nil, streamArn: String, streamChannelDefinition: StreamChannelDefinition) {
            self.fragmentNumber = fragmentNumber
            self.streamArn = streamArn
            self.streamChannelDefinition = streamChannelDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.fragmentNumber, name: "fragmentNumber", parent: name, max: 128)
            try self.validate(self.fragmentNumber, name: "fragmentNumber", parent: name, min: 1)
            try self.validate(self.fragmentNumber, name: "fragmentNumber", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.streamArn, name: "streamArn", parent: name, max: 1024)
            try self.validate(self.streamArn, name: "streamArn", parent: name, min: 1)
            try self.validate(self.streamArn, name: "streamArn", parent: name, pattern: "^arn:[a-z\\d-]+:kinesisvideo:[a-z0-9-]+:[0-9]+:[a-z]+/[a-zA-Z0-9_.-]+/[0-9]+$")
            try self.streamChannelDefinition.validate(name: "\(name).streamChannelDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case fragmentNumber = "FragmentNumber"
            case streamArn = "StreamArn"
            case streamChannelDefinition = "StreamChannelDefinition"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key half of a tag.
        public let key: String
        /// The value half of a tag.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's endpoint region, resource ID, and pipeline ID.
        public let resourceARN: String
        /// The tags associated with the specified media pipeline.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimestampRange: AWSEncodableShape & AWSDecodableShape {
        /// The ending timestamp for the specified range.
        public let endTimestamp: Date
        /// The starting timestamp for the specified range.
        public let startTimestamp: Date

        public init(endTimestamp: Date, startTimestamp: Date) {
            self.endTimestamp = endTimestamp
            self.startTimestamp = startTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case endTimestamp = "EndTimestamp"
            case startTimestamp = "StartTimestamp"
        }
    }

    public struct TranscriptionMessagesConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The ARN of the pipeline that you want to untag.
        public let resourceARN: String
        /// The key/value pairs in the tag that you want to remove.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceARN = "ResourceARN"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMediaInsightsPipelineConfigurationRequest: AWSEncodableShape {
        /// The elements in the request, such as a processor for Amazon Transcribe or a sink for a Kinesis Data Stream..
        public let elements: [MediaInsightsPipelineConfigurationElement]
        /// The unique identifier for the resource to be updated. Valid values include the name and ARN of the media insights pipeline configuration.
        public let identifier: String
        /// The configuration settings for real-time alerts for the media insights pipeline.
        public let realTimeAlertConfiguration: RealTimeAlertConfiguration?
        /// The ARN of the role used by the service to access Amazon Web Services resources.
        public let resourceAccessRoleArn: String

        public init(elements: [MediaInsightsPipelineConfigurationElement], identifier: String, realTimeAlertConfiguration: RealTimeAlertConfiguration? = nil, resourceAccessRoleArn: String) {
            self.elements = elements
            self.identifier = identifier
            self.realTimeAlertConfiguration = realTimeAlertConfiguration
            self.resourceAccessRoleArn = resourceAccessRoleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.elements, forKey: .elements)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.realTimeAlertConfiguration, forKey: .realTimeAlertConfiguration)
            try container.encode(self.resourceAccessRoleArn, forKey: .resourceAccessRoleArn)
        }

        public func validate(name: String) throws {
            try self.elements.forEach {
                try $0.validate(name: "\(name).elements[]")
            }
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.realTimeAlertConfiguration?.validate(name: "\(name).realTimeAlertConfiguration")
            try self.validate(self.resourceAccessRoleArn, name: "resourceAccessRoleArn", parent: name, max: 1024)
            try self.validate(self.resourceAccessRoleArn, name: "resourceAccessRoleArn", parent: name, min: 1)
            try self.validate(self.resourceAccessRoleArn, name: "resourceAccessRoleArn", parent: name, pattern: "^arn[\\/\\:\\-\\_\\.a-zA-Z0-9]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case elements = "Elements"
            case realTimeAlertConfiguration = "RealTimeAlertConfiguration"
            case resourceAccessRoleArn = "ResourceAccessRoleArn"
        }
    }

    public struct UpdateMediaInsightsPipelineConfigurationResponse: AWSDecodableShape {
        /// The updated configuration settings.
        public let mediaInsightsPipelineConfiguration: MediaInsightsPipelineConfiguration?

        public init(mediaInsightsPipelineConfiguration: MediaInsightsPipelineConfiguration? = nil) {
            self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case mediaInsightsPipelineConfiguration = "MediaInsightsPipelineConfiguration"
        }
    }

    public struct UpdateMediaInsightsPipelineStatusRequest: AWSEncodableShape {
        /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
        public let identifier: String
        /// The requested status of the media insights pipeline.
        public let updateStatus: MediaPipelineStatusUpdate

        public init(identifier: String, updateStatus: MediaPipelineStatusUpdate) {
            self.identifier = identifier
            self.updateStatus = updateStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encode(self.updateStatus, forKey: .updateStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case updateStatus = "UpdateStatus"
        }
    }

    public struct UpdateMediaPipelineKinesisVideoStreamPoolRequest: AWSEncodableShape {
        /// The ID of the video stream pool.
        public let identifier: String
        /// The configuration settings for the video stream.
        public let streamConfiguration: KinesisVideoStreamConfigurationUpdate?

        public init(identifier: String, streamConfiguration: KinesisVideoStreamConfigurationUpdate? = nil) {
            self.identifier = identifier
            self.streamConfiguration = streamConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.identifier, key: "Identifier")
            try container.encodeIfPresent(self.streamConfiguration, forKey: .streamConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "\\S")
            try self.streamConfiguration?.validate(name: "\(name).streamConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case streamConfiguration = "StreamConfiguration"
        }
    }

    public struct UpdateMediaPipelineKinesisVideoStreamPoolResponse: AWSDecodableShape {
        /// The video stream pool configuration object.
        public let kinesisVideoStreamPoolConfiguration: KinesisVideoStreamPoolConfiguration?

        public init(kinesisVideoStreamPoolConfiguration: KinesisVideoStreamPoolConfiguration? = nil) {
            self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case kinesisVideoStreamPoolConfiguration = "KinesisVideoStreamPoolConfiguration"
        }
    }

    public struct VerticalLayoutConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Sets the aspect ratio of the video tiles, such as 16:9.
        public let tileAspectRatio: String?
        /// The maximum number of tiles to display.
        public let tileCount: Int?
        /// Sets the automatic ordering of the video tiles.
        public let tileOrder: TileOrder?
        /// Sets the position of vertical tiles.
        public let tilePosition: VerticalTilePosition?

        public init(tileAspectRatio: String? = nil, tileCount: Int? = nil, tileOrder: TileOrder? = nil, tilePosition: VerticalTilePosition? = nil) {
            self.tileAspectRatio = tileAspectRatio
            self.tileCount = tileCount
            self.tileOrder = tileOrder
            self.tilePosition = tilePosition
        }

        public func validate(name: String) throws {
            try self.validate(self.tileAspectRatio, name: "tileAspectRatio", parent: name, pattern: "^\\d{1,2}\\/\\d{1,2}$")
            try self.validate(self.tileCount, name: "tileCount", parent: name, max: 10)
            try self.validate(self.tileCount, name: "tileCount", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tileAspectRatio = "TileAspectRatio"
            case tileCount = "TileCount"
            case tileOrder = "TileOrder"
            case tilePosition = "TilePosition"
        }
    }

    public struct VideoArtifactsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The MUX type of the video artifact configuration object.
        public let muxType: VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        public let state: ArtifactsState

        public init(muxType: VideoMuxType? = nil, state: ArtifactsState) {
            self.muxType = muxType
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case muxType = "MuxType"
            case state = "State"
        }
    }

    public struct VideoAttribute: AWSEncodableShape & AWSDecodableShape {
        /// Defines the border color of all video tiles.
        public let borderColor: BorderColor?
        /// Defines the border thickness for all video tiles.
        public let borderThickness: Int?
        /// Sets the corner radius of all video tiles.
        public let cornerRadius: Int?
        /// Defines the highlight color for the active video tile.
        public let highlightColor: HighlightColor?

        public init(borderColor: BorderColor? = nil, borderThickness: Int? = nil, cornerRadius: Int? = nil, highlightColor: HighlightColor? = nil) {
            self.borderColor = borderColor
            self.borderThickness = borderThickness
            self.cornerRadius = cornerRadius
            self.highlightColor = highlightColor
        }

        public func validate(name: String) throws {
            try self.validate(self.borderThickness, name: "borderThickness", parent: name, max: 20)
            try self.validate(self.borderThickness, name: "borderThickness", parent: name, min: 1)
            try self.validate(self.cornerRadius, name: "cornerRadius", parent: name, max: 20)
            try self.validate(self.cornerRadius, name: "cornerRadius", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case borderColor = "BorderColor"
            case borderThickness = "BorderThickness"
            case cornerRadius = "CornerRadius"
            case highlightColor = "HighlightColor"
        }
    }

    public struct VideoConcatenationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Enables or disables the configuration object.
        public let state: ArtifactsConcatenationState

        public init(state: ArtifactsConcatenationState) {
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
        }
    }

    public struct VoiceAnalyticsProcessorConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The status of the speaker search task.
        public let speakerSearchStatus: VoiceAnalyticsConfigurationStatus?
        /// The status of the voice tone analysis task.
        public let voiceToneAnalysisStatus: VoiceAnalyticsConfigurationStatus?

        public init(speakerSearchStatus: VoiceAnalyticsConfigurationStatus? = nil, voiceToneAnalysisStatus: VoiceAnalyticsConfigurationStatus? = nil) {
            self.speakerSearchStatus = speakerSearchStatus
            self.voiceToneAnalysisStatus = voiceToneAnalysisStatus
        }

        private enum CodingKeys: String, CodingKey {
            case speakerSearchStatus = "SpeakerSearchStatus"
            case voiceToneAnalysisStatus = "VoiceToneAnalysisStatus"
        }
    }

    public struct VoiceEnhancementSinkConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Disables the VoiceEnhancementSinkConfiguration element.
        public let disabled: Bool?

        public init(disabled: Bool? = nil) {
            self.disabled = disabled
        }

        private enum CodingKeys: String, CodingKey {
            case disabled = "Disabled"
        }
    }

    public struct VoiceToneAnalysisTask: AWSDecodableShape {
        /// The time at which a voice tone analysis task was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdTimestamp: Date?
        /// The time at which a voice tone analysis task was updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedTimestamp: Date?
        /// The ID of the voice tone analysis task.
        public let voiceToneAnalysisTaskId: String?
        /// The status of a voice tone analysis task.
        public let voiceToneAnalysisTaskStatus: MediaPipelineTaskStatus?

        public init(createdTimestamp: Date? = nil, updatedTimestamp: Date? = nil, voiceToneAnalysisTaskId: String? = nil, voiceToneAnalysisTaskStatus: MediaPipelineTaskStatus? = nil) {
            self.createdTimestamp = createdTimestamp
            self.updatedTimestamp = updatedTimestamp
            self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
            self.voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatus
        }

        private enum CodingKeys: String, CodingKey {
            case createdTimestamp = "CreatedTimestamp"
            case updatedTimestamp = "UpdatedTimestamp"
            case voiceToneAnalysisTaskId = "VoiceToneAnalysisTaskId"
            case voiceToneAnalysisTaskStatus = "VoiceToneAnalysisTaskStatus"
        }
    }
}

// MARK: - Errors

/// Error enum for ChimeSDKMediaPipelines
public struct ChimeSDKMediaPipelinesErrorType: AWSErrorType {
    enum Code: String {
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case forbiddenException = "ForbiddenException"
        case notFoundException = "NotFoundException"
        case resourceLimitExceededException = "ResourceLimitExceededException"
        case serviceFailureException = "ServiceFailureException"
        case serviceUnavailableException = "ServiceUnavailableException"
        case throttledClientException = "ThrottledClientException"
        case unauthorizedClientException = "UnauthorizedClientException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ChimeSDKMediaPipelines
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The input parameters don't match the service's restrictions.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The request could not be processed because of conflict in the current state of the resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The client is permanently forbidden from making the request.
    public static var forbiddenException: Self { .init(.forbiddenException) }
    /// One or more of the resources in the request does not exist in the system.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The request exceeds the resource limit.
    public static var resourceLimitExceededException: Self { .init(.resourceLimitExceededException) }
    /// The service encountered an unexpected error.
    public static var serviceFailureException: Self { .init(.serviceFailureException) }
    /// The service is currently unavailable.
    public static var serviceUnavailableException: Self { .init(.serviceUnavailableException) }
    /// The client exceeded its request rate limit.
    public static var throttledClientException: Self { .init(.throttledClientException) }
    /// The client is not currently authorized to make the request.
    public static var unauthorizedClientException: Self { .init(.unauthorizedClientException) }
}

extension ChimeSDKMediaPipelinesErrorType: Equatable {
    public static func == (lhs: ChimeSDKMediaPipelinesErrorType, rhs: ChimeSDKMediaPipelinesErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ChimeSDKMediaPipelinesErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
