//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension ServiceCatalog {
    // MARK: Enums

    public enum AccessLevelFilterKey: String, CustomStringConvertible, Codable {
        case account = "Account"
        case role = "Role"
        case user = "User"
        public var description: String { return self.rawValue }
    }

    public enum AccessStatus: String, CustomStringConvertible, Codable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        case underChange = "UNDER_CHANGE"
        public var description: String { return self.rawValue }
    }

    public enum ChangeAction: String, CustomStringConvertible, Codable {
        case add = "ADD"
        case modify = "MODIFY"
        case remove = "REMOVE"
        public var description: String { return self.rawValue }
    }

    public enum CopyOption: String, CustomStringConvertible, Codable {
        case copytags = "CopyTags"
        public var description: String { return self.rawValue }
    }

    public enum CopyProductStatus: String, CustomStringConvertible, Codable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum DescribePortfolioShareType: String, CustomStringConvertible, Codable {
        case account = "ACCOUNT"
        case organization = "ORGANIZATION"
        case organizationMemberAccount = "ORGANIZATION_MEMBER_ACCOUNT"
        case organizationalUnit = "ORGANIZATIONAL_UNIT"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationType: String, CustomStringConvertible, Codable {
        case dynamic = "DYNAMIC"
        case `static` = "STATIC"
        public var description: String { return self.rawValue }
    }

    public enum OrganizationNodeType: String, CustomStringConvertible, Codable {
        case account = "ACCOUNT"
        case organization = "ORGANIZATION"
        case organizationalUnit = "ORGANIZATIONAL_UNIT"
        public var description: String { return self.rawValue }
    }

    public enum PortfolioShareType: String, CustomStringConvertible, Codable {
        case awsOrganizations = "AWS_ORGANIZATIONS"
        case awsServicecatalog = "AWS_SERVICECATALOG"
        case imported = "IMPORTED"
        public var description: String { return self.rawValue }
    }

    public enum PrincipalType: String, CustomStringConvertible, Codable {
        case iam = "IAM"
        public var description: String { return self.rawValue }
    }

    public enum ProductSource: String, CustomStringConvertible, Codable {
        case account = "ACCOUNT"
        public var description: String { return self.rawValue }
    }

    public enum ProductType: String, CustomStringConvertible, Codable {
        case cloudFormationTemplate = "CLOUD_FORMATION_TEMPLATE"
        case marketplace = "MARKETPLACE"
        public var description: String { return self.rawValue }
    }

    public enum ProductViewFilterBy: String, CustomStringConvertible, Codable {
        case fulltextsearch = "FullTextSearch"
        case owner = "Owner"
        case producttype = "ProductType"
        case sourceproductid = "SourceProductId"
        public var description: String { return self.rawValue }
    }

    public enum ProductViewSortBy: String, CustomStringConvertible, Codable {
        case creationdate = "CreationDate"
        case title = "Title"
        case versioncount = "VersionCount"
        public var description: String { return self.rawValue }
    }

    public enum PropertyKey: String, CustomStringConvertible, Codable {
        case launchRole = "LAUNCH_ROLE"
        case owner = "OWNER"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedProductPlanStatus: String, CustomStringConvertible, Codable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case createSuccess = "CREATE_SUCCESS"
        case executeFailed = "EXECUTE_FAILED"
        case executeInProgress = "EXECUTE_IN_PROGRESS"
        case executeSuccess = "EXECUTE_SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedProductPlanType: String, CustomStringConvertible, Codable {
        case cloudformation = "CLOUDFORMATION"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedProductStatus: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case error = "ERROR"
        case planInProgress = "PLAN_IN_PROGRESS"
        case tainted = "TAINTED"
        case underChange = "UNDER_CHANGE"
        public var description: String { return self.rawValue }
    }

    public enum ProvisionedProductViewFilterBy: String, CustomStringConvertible, Codable {
        case searchquery = "SearchQuery"
        public var description: String { return self.rawValue }
    }

    public enum ProvisioningArtifactGuidance: String, CustomStringConvertible, Codable {
        case `default` = "DEFAULT"
        case deprecated = "DEPRECATED"
        public var description: String { return self.rawValue }
    }

    public enum ProvisioningArtifactPropertyName: String, CustomStringConvertible, Codable {
        case id = "Id"
        public var description: String { return self.rawValue }
    }

    public enum ProvisioningArtifactType: String, CustomStringConvertible, Codable {
        case cloudFormationTemplate = "CLOUD_FORMATION_TEMPLATE"
        case marketplaceAmi = "MARKETPLACE_AMI"
        case marketplaceCar = "MARKETPLACE_CAR"
        public var description: String { return self.rawValue }
    }

    public enum RecordStatus: String, CustomStringConvertible, Codable {
        case created = "CREATED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case inProgressInError = "IN_PROGRESS_IN_ERROR"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum Replacement: String, CustomStringConvertible, Codable {
        case conditional = "CONDITIONAL"
        case `false` = "FALSE"
        case `true` = "TRUE"
        public var description: String { return self.rawValue }
    }

    public enum RequiresRecreation: String, CustomStringConvertible, Codable {
        case always = "ALWAYS"
        case conditionally = "CONDITIONALLY"
        case never = "NEVER"
        public var description: String { return self.rawValue }
    }

    public enum ResourceAttribute: String, CustomStringConvertible, Codable {
        case creationpolicy = "CREATIONPOLICY"
        case deletionpolicy = "DELETIONPOLICY"
        case metadata = "METADATA"
        case properties = "PROPERTIES"
        case tags = "TAGS"
        case updatepolicy = "UPDATEPOLICY"
        public var description: String { return self.rawValue }
    }

    public enum ServiceActionAssociationErrorCode: String, CustomStringConvertible, Codable {
        case duplicateResource = "DUPLICATE_RESOURCE"
        case internalFailure = "INTERNAL_FAILURE"
        case limitExceeded = "LIMIT_EXCEEDED"
        case resourceNotFound = "RESOURCE_NOT_FOUND"
        case throttling = "THROTTLING"
        public var description: String { return self.rawValue }
    }

    public enum ServiceActionDefinitionKey: String, CustomStringConvertible, Codable {
        case assumerole = "AssumeRole"
        case name = "Name"
        case parameters = "Parameters"
        case version = "Version"
        public var description: String { return self.rawValue }
    }

    public enum ServiceActionDefinitionType: String, CustomStringConvertible, Codable {
        case ssmAutomation = "SSM_AUTOMATION"
        public var description: String { return self.rawValue }
    }

    public enum ShareStatus: String, CustomStringConvertible, Codable {
        case completed = "COMPLETED"
        case completedWithErrors = "COMPLETED_WITH_ERRORS"
        case error = "ERROR"
        case inProgress = "IN_PROGRESS"
        case notStarted = "NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum StackInstanceStatus: String, CustomStringConvertible, Codable {
        case current = "CURRENT"
        case inoperable = "INOPERABLE"
        case outdated = "OUTDATED"
        public var description: String { return self.rawValue }
    }

    public enum StackSetOperationType: String, CustomStringConvertible, Codable {
        case create = "CREATE"
        case delete = "DELETE"
        case update = "UPDATE"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptPortfolioShareInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let portfolioId: String
        /// The type of shared portfolios to accept. The default is to accept imported portfolios.    AWS_ORGANIZATIONS - Accept portfolios shared by the management account of your organization.    IMPORTED - Accept imported portfolios.    AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)   For example, aws servicecatalog accept-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
        public let portfolioShareType: PortfolioShareType?

        public init(acceptLanguage: String? = nil, portfolioId: String, portfolioShareType: PortfolioShareType? = nil) {
            self.acceptLanguage = acceptLanguage
            self.portfolioId = portfolioId
            self.portfolioShareType = portfolioShareType
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case portfolioId = "PortfolioId"
            case portfolioShareType = "PortfolioShareType"
        }
    }

    public struct AcceptPortfolioShareOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AccessLevelFilter: AWSEncodableShape {
        /// The access level.    Account - Filter results based on the account.    Role - Filter results based on the federated role of the specified user.    User - Filter results based on the specified user.
        public let key: AccessLevelFilterKey?
        /// The user to which the access level applies. The only supported value is Self.
        public let value: String?

        public init(key: AccessLevelFilterKey? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct AssociateBudgetWithResourceInput: AWSEncodableShape {
        /// The name of the budget you want to associate.
        public let budgetName: String
        ///  The resource identifier. Either a portfolio-id or a product-id.
        public let resourceId: String

        public init(budgetName: String, resourceId: String) {
            self.budgetName = budgetName
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.budgetName, name: "budgetName", parent: name, max: 100)
            try self.validate(self.budgetName, name: "budgetName", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 100)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case budgetName = "BudgetName"
            case resourceId = "ResourceId"
        }
    }

    public struct AssociateBudgetWithResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AssociatePrincipalWithPortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let portfolioId: String
        /// The ARN of the principal (IAM user, role, or group).
        public let principalARN: String
        /// The principal type. The supported value is IAM.
        public let principalType: PrincipalType

        public init(acceptLanguage: String? = nil, portfolioId: String, principalARN: String, principalType: PrincipalType) {
            self.acceptLanguage = acceptLanguage
            self.portfolioId = portfolioId
            self.principalARN = principalARN
            self.principalType = principalType
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.principalARN, name: "principalARN", parent: name, max: 1000)
            try self.validate(self.principalARN, name: "principalARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case portfolioId = "PortfolioId"
            case principalARN = "PrincipalARN"
            case principalType = "PrincipalType"
        }
    }

    public struct AssociatePrincipalWithPortfolioOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateProductWithPortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let portfolioId: String
        /// The product identifier.
        public let productId: String
        /// The identifier of the source portfolio.
        public let sourcePortfolioId: String?

        public init(acceptLanguage: String? = nil, portfolioId: String, productId: String, sourcePortfolioId: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.portfolioId = portfolioId
            self.productId = productId
            self.sourcePortfolioId = sourcePortfolioId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.sourcePortfolioId, name: "sourcePortfolioId", parent: name, max: 100)
            try self.validate(self.sourcePortfolioId, name: "sourcePortfolioId", parent: name, min: 1)
            try self.validate(self.sourcePortfolioId, name: "sourcePortfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case portfolioId = "PortfolioId"
            case productId = "ProductId"
            case sourcePortfolioId = "SourcePortfolioId"
        }
    }

    public struct AssociateProductWithPortfolioOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateServiceActionWithProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public let productId: String
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public let provisioningArtifactId: String
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public let serviceActionId: String

        public init(acceptLanguage: String? = nil, productId: String, provisioningArtifactId: String, serviceActionId: String) {
            self.acceptLanguage = acceptLanguage
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, max: 100)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, min: 1)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case serviceActionId = "ServiceActionId"
        }
    }

    public struct AssociateServiceActionWithProvisioningArtifactOutput: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateTagOptionWithResourceInput: AWSEncodableShape {
        /// The resource identifier.
        public let resourceId: String
        /// The TagOption identifier.
        public let tagOptionId: String

        public init(resourceId: String, tagOptionId: String) {
            self.resourceId = resourceId
            self.tagOptionId = tagOptionId
        }

        public func validate(name: String) throws {
            try self.validate(self.tagOptionId, name: "tagOptionId", parent: name, max: 100)
            try self.validate(self.tagOptionId, name: "tagOptionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case tagOptionId = "TagOptionId"
        }
    }

    public struct AssociateTagOptionWithResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct BatchAssociateServiceActionWithProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
        public let serviceActionAssociations: [ServiceActionAssociation]

        public init(acceptLanguage: String? = nil, serviceActionAssociations: [ServiceActionAssociation]) {
            self.acceptLanguage = acceptLanguage
            self.serviceActionAssociations = serviceActionAssociations
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.serviceActionAssociations.forEach {
                try $0.validate(name: "\(name).serviceActionAssociations[]")
            }
            try self.validate(self.serviceActionAssociations, name: "serviceActionAssociations", parent: name, max: 50)
            try self.validate(self.serviceActionAssociations, name: "serviceActionAssociations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case serviceActionAssociations = "ServiceActionAssociations"
        }
    }

    public struct BatchAssociateServiceActionWithProvisioningArtifactOutput: AWSDecodableShape {
        /// An object that contains a list of errors, along with information to help you identify the self-service action.
        public let failedServiceActionAssociations: [FailedServiceActionAssociation]?

        public init(failedServiceActionAssociations: [FailedServiceActionAssociation]? = nil) {
            self.failedServiceActionAssociations = failedServiceActionAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case failedServiceActionAssociations = "FailedServiceActionAssociations"
        }
    }

    public struct BatchDisassociateServiceActionFromProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
        public let serviceActionAssociations: [ServiceActionAssociation]

        public init(acceptLanguage: String? = nil, serviceActionAssociations: [ServiceActionAssociation]) {
            self.acceptLanguage = acceptLanguage
            self.serviceActionAssociations = serviceActionAssociations
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.serviceActionAssociations.forEach {
                try $0.validate(name: "\(name).serviceActionAssociations[]")
            }
            try self.validate(self.serviceActionAssociations, name: "serviceActionAssociations", parent: name, max: 50)
            try self.validate(self.serviceActionAssociations, name: "serviceActionAssociations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case serviceActionAssociations = "ServiceActionAssociations"
        }
    }

    public struct BatchDisassociateServiceActionFromProvisioningArtifactOutput: AWSDecodableShape {
        /// An object that contains a list of errors, along with information to help you identify the self-service action.
        public let failedServiceActionAssociations: [FailedServiceActionAssociation]?

        public init(failedServiceActionAssociations: [FailedServiceActionAssociation]? = nil) {
            self.failedServiceActionAssociations = failedServiceActionAssociations
        }

        private enum CodingKeys: String, CodingKey {
            case failedServiceActionAssociations = "FailedServiceActionAssociations"
        }
    }

    public struct BudgetDetail: AWSDecodableShape {
        /// Name of the associated budget.
        public let budgetName: String?

        public init(budgetName: String? = nil) {
            self.budgetName = budgetName
        }

        private enum CodingKeys: String, CodingKey {
            case budgetName = "BudgetName"
        }
    }

    public struct CloudWatchDashboard: AWSDecodableShape {
        /// The name of the CloudWatch dashboard.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct ConstraintDetail: AWSDecodableShape {
        /// The identifier of the constraint.
        public let constraintId: String?
        /// The description of the constraint.
        public let description: String?
        /// The owner of the constraint.
        public let owner: String?
        /// The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.
        public let portfolioId: String?
        /// The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.
        public let productId: String?
        /// The type of constraint.    LAUNCH     NOTIFICATION    STACKSET    TEMPLATE
        public let type: String?

        public init(constraintId: String? = nil, description: String? = nil, owner: String? = nil, portfolioId: String? = nil, productId: String? = nil, type: String? = nil) {
            self.constraintId = constraintId
            self.description = description
            self.owner = owner
            self.portfolioId = portfolioId
            self.productId = productId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case constraintId = "ConstraintId"
            case description = "Description"
            case owner = "Owner"
            case portfolioId = "PortfolioId"
            case productId = "ProductId"
            case type = "Type"
        }
    }

    public struct ConstraintSummary: AWSDecodableShape {
        /// The description of the constraint.
        public let description: String?
        /// The type of constraint.    LAUNCH     NOTIFICATION    STACKSET    TEMPLATE
        public let type: String?

        public init(description: String? = nil, type: String? = nil) {
            self.description = description
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case type = "Type"
        }
    }

    public struct CopyProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The copy options. If the value is CopyTags, the tags from the source product are copied to the target product.
        public let copyOptions: [CopyOption]?
        ///  A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The Amazon Resource Name (ARN) of the source product.
        public let sourceProductArn: String
        /// The identifiers of the provisioning artifacts (also known as versions) of the product to copy. By default, all provisioning artifacts are copied.
        public let sourceProvisioningArtifactIdentifiers: [[ProvisioningArtifactPropertyName: String]]?
        /// The identifier of the target product. By default, a new product is created.
        public let targetProductId: String?
        /// A name for the target product. The default is the name of the source product.
        public let targetProductName: String?

        public init(acceptLanguage: String? = nil, copyOptions: [CopyOption]? = nil, idempotencyToken: String = CopyProductInput.idempotencyToken(), sourceProductArn: String, sourceProvisioningArtifactIdentifiers: [[ProvisioningArtifactPropertyName: String]]? = nil, targetProductId: String? = nil, targetProductName: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.copyOptions = copyOptions
            self.idempotencyToken = idempotencyToken
            self.sourceProductArn = sourceProductArn
            self.sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers
            self.targetProductId = targetProductId
            self.targetProductName = targetProductName
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.sourceProductArn, name: "sourceProductArn", parent: name, max: 1224)
            try self.validate(self.sourceProductArn, name: "sourceProductArn", parent: name, min: 1)
            try self.validate(self.sourceProductArn, name: "sourceProductArn", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.targetProductId, name: "targetProductId", parent: name, max: 100)
            try self.validate(self.targetProductId, name: "targetProductId", parent: name, min: 1)
            try self.validate(self.targetProductId, name: "targetProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.targetProductName, name: "targetProductName", parent: name, max: 8191)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case copyOptions = "CopyOptions"
            case idempotencyToken = "IdempotencyToken"
            case sourceProductArn = "SourceProductArn"
            case sourceProvisioningArtifactIdentifiers = "SourceProvisioningArtifactIdentifiers"
            case targetProductId = "TargetProductId"
            case targetProductName = "TargetProductName"
        }
    }

    public struct CopyProductOutput: AWSDecodableShape {
        /// The token to use to track the progress of the operation.
        public let copyProductToken: String?

        public init(copyProductToken: String? = nil) {
            self.copyProductToken = copyProductToken
        }

        private enum CodingKeys: String, CodingKey {
            case copyProductToken = "CopyProductToken"
        }
    }

    public struct CreateConstraintInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The description of the constraint.
        public let description: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows:  LAUNCH  You are required to specify either the RoleArn or the LocalRoleName but can't use both. Specify the RoleArn property as follows:  {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"}  Specify the LocalRoleName property as follows:  {"LocalRoleName": "SCBasicLaunchRole"}  If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account.  The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.  You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one LAUNCH constraint on a product and portfolio.  NOTIFICATION  Specify the NotificationArns property as follows:  {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]}   RESOURCE_UPDATE  Specify the TagUpdatesOnProvisionedProduct property as follows:  {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}}  The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED.  STACKSET  Specify the Parameters property as follows:  {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}}  You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one STACKSET constraint on a product and portfolio. Products with a STACKSET constraint will launch an AWS CloudFormation stack set.  TEMPLATE  Specify the Rules property. For more information, see Template Constraint Rules.
        public let parameters: String
        /// The portfolio identifier.
        public let portfolioId: String
        /// The product identifier.
        public let productId: String
        /// The type of constraint.    LAUNCH     NOTIFICATION     RESOURCE_UPDATE     STACKSET     TEMPLATE
        public let type: String

        public init(acceptLanguage: String? = nil, description: String? = nil, idempotencyToken: String = CreateConstraintInput.idempotencyToken(), parameters: String, portfolioId: String, productId: String, type: String) {
            self.acceptLanguage = acceptLanguage
            self.description = description
            self.idempotencyToken = idempotencyToken
            self.parameters = parameters
            self.portfolioId = portfolioId
            self.productId = productId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 2000)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.type, name: "type", parent: name, max: 1024)
            try self.validate(self.type, name: "type", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case description = "Description"
            case idempotencyToken = "IdempotencyToken"
            case parameters = "Parameters"
            case portfolioId = "PortfolioId"
            case productId = "ProductId"
            case type = "Type"
        }
    }

    public struct CreateConstraintOutput: AWSDecodableShape {
        /// Information about the constraint.
        public let constraintDetail: ConstraintDetail?
        /// The constraint parameters.
        public let constraintParameters: String?
        /// The status of the current request.
        public let status: Status?

        public init(constraintDetail: ConstraintDetail? = nil, constraintParameters: String? = nil, status: Status? = nil) {
            self.constraintDetail = constraintDetail
            self.constraintParameters = constraintParameters
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case constraintDetail = "ConstraintDetail"
            case constraintParameters = "ConstraintParameters"
            case status = "Status"
        }
    }

    public struct CreatePortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The description of the portfolio.
        public let description: String?
        /// The name to use for display purposes.
        public let displayName: String
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The name of the portfolio provider.
        public let providerName: String
        /// One or more tags.
        public let tags: [Tag]?

        public init(acceptLanguage: String? = nil, description: String? = nil, displayName: String, idempotencyToken: String = CreatePortfolioInput.idempotencyToken(), providerName: String, tags: [Tag]? = nil) {
            self.acceptLanguage = acceptLanguage
            self.description = description
            self.displayName = displayName
            self.idempotencyToken = idempotencyToken
            self.providerName = providerName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 2000)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.providerName, name: "providerName", parent: name, max: 50)
            try self.validate(self.providerName, name: "providerName", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case description = "Description"
            case displayName = "DisplayName"
            case idempotencyToken = "IdempotencyToken"
            case providerName = "ProviderName"
            case tags = "Tags"
        }
    }

    public struct CreatePortfolioOutput: AWSDecodableShape {
        /// Information about the portfolio.
        public let portfolioDetail: PortfolioDetail?
        /// Information about the tags associated with the portfolio.
        public let tags: [Tag]?

        public init(portfolioDetail: PortfolioDetail? = nil, tags: [Tag]? = nil) {
            self.portfolioDetail = portfolioDetail
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case portfolioDetail = "PortfolioDetail"
            case tags = "Tags"
        }
    }

    public struct CreatePortfolioShareInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The AWS account ID. For example, 123456789012.
        public let accountId: String?
        /// The organization node to whom you are going to share. If OrganizationNode is passed in, PortfolioShare will be created for the node an ListOrganizationPortfolioAccessd its children (when applies), and a PortfolioShareToken will be returned in the output in order for the administrator to monitor the status of the PortfolioShare creation process.
        public let organizationNode: OrganizationNode?
        /// The portfolio identifier.
        public let portfolioId: String
        /// Enables or disables TagOptions  sharing when creating the portfolio share. If this flag is not provided, TagOptions sharing is disabled.
        public let shareTagOptions: Bool?

        public init(acceptLanguage: String? = nil, accountId: String? = nil, organizationNode: OrganizationNode? = nil, portfolioId: String, shareTagOptions: Bool? = nil) {
            self.acceptLanguage = acceptLanguage
            self.accountId = accountId
            self.organizationNode = organizationNode
            self.portfolioId = portfolioId
            self.shareTagOptions = shareTagOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.organizationNode?.validate(name: "\(name).organizationNode")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case accountId = "AccountId"
            case organizationNode = "OrganizationNode"
            case portfolioId = "PortfolioId"
            case shareTagOptions = "ShareTagOptions"
        }
    }

    public struct CreatePortfolioShareOutput: AWSDecodableShape {
        /// The portfolio shares a unique identifier that only returns if the portfolio is shared to an organization node.
        public let portfolioShareToken: String?

        public init(portfolioShareToken: String? = nil) {
            self.portfolioShareToken = portfolioShareToken
        }

        private enum CodingKeys: String, CodingKey {
            case portfolioShareToken = "PortfolioShareToken"
        }
    }

    public struct CreateProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The description of the product.
        public let description: String?
        /// The distributor of the product.
        public let distributor: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The name of the product.
        public let name: String
        /// The owner of the product.
        public let owner: String
        /// The type of product.
        public let productType: ProductType
        /// The configuration of the provisioning artifact.
        public let provisioningArtifactParameters: ProvisioningArtifactProperties
        /// The support information about the product.
        public let supportDescription: String?
        /// The contact email for product support.
        public let supportEmail: String?
        /// The contact URL for product support.  ^https?:\/\// / is the pattern used to validate SupportUrl.
        public let supportUrl: String?
        /// One or more tags.
        public let tags: [Tag]?

        public init(acceptLanguage: String? = nil, description: String? = nil, distributor: String? = nil, idempotencyToken: String = CreateProductInput.idempotencyToken(), name: String, owner: String, productType: ProductType, provisioningArtifactParameters: ProvisioningArtifactProperties, supportDescription: String? = nil, supportEmail: String? = nil, supportUrl: String? = nil, tags: [Tag]? = nil) {
            self.acceptLanguage = acceptLanguage
            self.description = description
            self.distributor = distributor
            self.idempotencyToken = idempotencyToken
            self.name = name
            self.owner = owner
            self.productType = productType
            self.provisioningArtifactParameters = provisioningArtifactParameters
            self.supportDescription = supportDescription
            self.supportEmail = supportEmail
            self.supportUrl = supportUrl
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 8191)
            try self.validate(self.distributor, name: "distributor", parent: name, max: 8191)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.name, name: "name", parent: name, max: 8191)
            try self.validate(self.owner, name: "owner", parent: name, max: 8191)
            try self.provisioningArtifactParameters.validate(name: "\(name).provisioningArtifactParameters")
            try self.validate(self.supportDescription, name: "supportDescription", parent: name, max: 8191)
            try self.validate(self.supportEmail, name: "supportEmail", parent: name, max: 254)
            try self.validate(self.supportUrl, name: "supportUrl", parent: name, max: 2083)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case description = "Description"
            case distributor = "Distributor"
            case idempotencyToken = "IdempotencyToken"
            case name = "Name"
            case owner = "Owner"
            case productType = "ProductType"
            case provisioningArtifactParameters = "ProvisioningArtifactParameters"
            case supportDescription = "SupportDescription"
            case supportEmail = "SupportEmail"
            case supportUrl = "SupportUrl"
            case tags = "Tags"
        }
    }

    public struct CreateProductOutput: AWSDecodableShape {
        /// Information about the product view.
        public let productViewDetail: ProductViewDetail?
        /// Information about the provisioning artifact.
        public let provisioningArtifactDetail: ProvisioningArtifactDetail?
        /// Information about the tags associated with the product.
        public let tags: [Tag]?

        public init(productViewDetail: ProductViewDetail? = nil, provisioningArtifactDetail: ProvisioningArtifactDetail? = nil, tags: [Tag]? = nil) {
            self.productViewDetail = productViewDetail
            self.provisioningArtifactDetail = provisioningArtifactDetail
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case productViewDetail = "ProductViewDetail"
            case provisioningArtifactDetail = "ProvisioningArtifactDetail"
            case tags = "Tags"
        }
    }

    public struct CreateProvisionedProductPlanInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
        public let notificationArns: [String]?
        /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use ListLaunchPaths.
        public let pathId: String?
        /// The name of the plan.
        public let planName: String
        /// The plan type.
        public let planType: ProvisionedProductPlanType
        /// The product identifier.
        public let productId: String
        /// A user-friendly name for the provisioned product. This value must be unique for the AWS account and cannot be updated after the product is provisioned.
        public let provisionedProductName: String
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String
        /// Parameters specified by the administrator that are required for provisioning the product.
        public let provisioningParameters: [UpdateProvisioningParameter]?
        /// One or more tags. If the plan is for an existing provisioned product, the product must have a RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
        public let tags: [Tag]?

        public init(acceptLanguage: String? = nil, idempotencyToken: String = CreateProvisionedProductPlanInput.idempotencyToken(), notificationArns: [String]? = nil, pathId: String? = nil, planName: String, planType: ProvisionedProductPlanType, productId: String, provisionedProductName: String, provisioningArtifactId: String, provisioningParameters: [UpdateProvisioningParameter]? = nil, tags: [Tag]? = nil) {
            self.acceptLanguage = acceptLanguage
            self.idempotencyToken = idempotencyToken
            self.notificationArns = notificationArns
            self.pathId = pathId
            self.planName = planName
            self.planType = planType
            self.productId = productId
            self.provisionedProductName = provisionedProductName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningParameters = provisioningParameters
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.notificationArns?.forEach {
                try validate($0, name: "notificationArns[]", parent: name, max: 1224)
                try validate($0, name: "notificationArns[]", parent: name, min: 1)
                try validate($0, name: "notificationArns[]", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            }
            try self.validate(self.notificationArns, name: "notificationArns", parent: name, max: 5)
            try self.validate(self.pathId, name: "pathId", parent: name, max: 100)
            try self.validate(self.pathId, name: "pathId", parent: name, min: 1)
            try self.validate(self.pathId, name: "pathId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, max: 128)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, min: 1)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9._-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.provisioningParameters?.forEach {
                try $0.validate(name: "\(name).provisioningParameters[]")
            }
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case idempotencyToken = "IdempotencyToken"
            case notificationArns = "NotificationArns"
            case pathId = "PathId"
            case planName = "PlanName"
            case planType = "PlanType"
            case productId = "ProductId"
            case provisionedProductName = "ProvisionedProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningParameters = "ProvisioningParameters"
            case tags = "Tags"
        }
    }

    public struct CreateProvisionedProductPlanOutput: AWSDecodableShape {
        /// The plan identifier.
        public let planId: String?
        /// The name of the plan.
        public let planName: String?
        /// The user-friendly name of the provisioned product.
        public let provisionedProductName: String?
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// The product identifier.
        public let provisionProductId: String?

        public init(planId: String? = nil, planName: String? = nil, provisionedProductName: String? = nil, provisioningArtifactId: String? = nil, provisionProductId: String? = nil) {
            self.planId = planId
            self.planName = planName
            self.provisionedProductName = provisionedProductName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisionProductId = provisionProductId
        }

        private enum CodingKeys: String, CodingKey {
            case planId = "PlanId"
            case planName = "PlanName"
            case provisionedProductName = "ProvisionedProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisionProductId = "ProvisionProductId"
        }
    }

    public struct CreateProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The configuration for the provisioning artifact.
        public let parameters: ProvisioningArtifactProperties
        /// The product identifier.
        public let productId: String

        public init(acceptLanguage: String? = nil, idempotencyToken: String = CreateProvisioningArtifactInput.idempotencyToken(), parameters: ProvisioningArtifactProperties, productId: String) {
            self.acceptLanguage = acceptLanguage
            self.idempotencyToken = idempotencyToken
            self.parameters = parameters
            self.productId = productId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.parameters.validate(name: "\(name).parameters")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case idempotencyToken = "IdempotencyToken"
            case parameters = "Parameters"
            case productId = "ProductId"
        }
    }

    public struct CreateProvisioningArtifactOutput: AWSDecodableShape {
        /// Specify the template source with one of the following options, but not both. Keys accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ]. The URL of the CloudFormation template in Amazon S3, in JSON format.   LoadTemplateFromURL  Use the URL of the CloudFormation template in Amazon S3 in JSON format.  ImportFromPhysicalId  Use the physical id of the resource that contains the template; currently supports CloudFormation stack ARN.
        public let info: [String: String]?
        /// Information about the provisioning artifact.
        public let provisioningArtifactDetail: ProvisioningArtifactDetail?
        /// The status of the current request.
        public let status: Status?

        public init(info: [String: String]? = nil, provisioningArtifactDetail: ProvisioningArtifactDetail? = nil, status: Status? = nil) {
            self.info = info
            self.provisioningArtifactDetail = provisioningArtifactDetail
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case info = "Info"
            case provisioningArtifactDetail = "ProvisioningArtifactDetail"
            case status = "Status"
        }
    }

    public struct CreateServiceActionInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The self-service action definition. Can be one of the following:  Name  The name of the AWS Systems Manager document (SSM document). For example, AWS-RestartEC2Instance. If you are using a shared SSM document, you must provide the ARN instead of the name.  Version  The AWS Systems Manager automation document version. For example, "Version": "1"   AssumeRole  The Amazon Resource Name (ARN) of the role that performs the self-service actions on your behalf. For example, "AssumeRole": "arn:aws:iam::12345678910:role/ActionRole". To reuse the provisioned product launch role, set to "AssumeRole": "LAUNCH_ROLE".  Parameters  The list of parameters in JSON format. For example: [{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}] or [{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}].
        public let definition: [ServiceActionDefinitionKey: String]
        /// The service action definition type. For example, SSM_AUTOMATION.
        public let definitionType: ServiceActionDefinitionType
        /// The self-service action description.
        public let description: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The self-service action name.
        public let name: String

        public init(acceptLanguage: String? = nil, definition: [ServiceActionDefinitionKey: String], definitionType: ServiceActionDefinitionType, description: String? = nil, idempotencyToken: String = CreateServiceActionInput.idempotencyToken(), name: String) {
            self.acceptLanguage = acceptLanguage
            self.definition = definition
            self.definitionType = definitionType
            self.description = description
            self.idempotencyToken = idempotencyToken
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.definition.forEach {
                try validate($0.value, name: "definition[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "definition[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case definition = "Definition"
            case definitionType = "DefinitionType"
            case description = "Description"
            case idempotencyToken = "IdempotencyToken"
            case name = "Name"
        }
    }

    public struct CreateServiceActionOutput: AWSDecodableShape {
        /// An object containing information about the self-service action.
        public let serviceActionDetail: ServiceActionDetail?

        public init(serviceActionDetail: ServiceActionDetail? = nil) {
            self.serviceActionDetail = serviceActionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case serviceActionDetail = "ServiceActionDetail"
        }
    }

    public struct CreateTagOptionInput: AWSEncodableShape {
        /// The TagOption key.
        public let key: String
        /// The TagOption value.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct CreateTagOptionOutput: AWSDecodableShape {
        /// Information about the TagOption.
        public let tagOptionDetail: TagOptionDetail?

        public init(tagOptionDetail: TagOptionDetail? = nil) {
            self.tagOptionDetail = tagOptionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case tagOptionDetail = "TagOptionDetail"
        }
    }

    public struct DeleteConstraintInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The identifier of the constraint.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DeleteConstraintOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DeletePortfolioOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePortfolioShareInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The AWS account ID.
        public let accountId: String?
        /// The organization node to whom you are going to stop sharing.
        public let organizationNode: OrganizationNode?
        /// The portfolio identifier.
        public let portfolioId: String

        public init(acceptLanguage: String? = nil, accountId: String? = nil, organizationNode: OrganizationNode? = nil, portfolioId: String) {
            self.acceptLanguage = acceptLanguage
            self.accountId = accountId
            self.organizationNode = organizationNode
            self.portfolioId = portfolioId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.organizationNode?.validate(name: "\(name).organizationNode")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case accountId = "AccountId"
            case organizationNode = "OrganizationNode"
            case portfolioId = "PortfolioId"
        }
    }

    public struct DeletePortfolioShareOutput: AWSDecodableShape {
        /// The portfolio share unique identifier. This will only be returned if delete is made to an organization node.
        public let portfolioShareToken: String?

        public init(portfolioShareToken: String? = nil) {
            self.portfolioShareToken = portfolioShareToken
        }

        private enum CodingKeys: String, CodingKey {
            case portfolioShareToken = "PortfolioShareToken"
        }
    }

    public struct DeleteProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DeleteProductOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProvisionedProductPlanInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// If set to true, AWS Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.
        public let ignoreErrors: Bool?
        /// The plan identifier.
        public let planId: String

        public init(acceptLanguage: String? = nil, ignoreErrors: Bool? = nil, planId: String) {
            self.acceptLanguage = acceptLanguage
            self.ignoreErrors = ignoreErrors
            self.planId = planId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.planId, name: "planId", parent: name, max: 100)
            try self.validate(self.planId, name: "planId", parent: name, min: 1)
            try self.validate(self.planId, name: "planId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case ignoreErrors = "IgnoreErrors"
            case planId = "PlanId"
        }
    }

    public struct DeleteProvisionedProductPlanOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier.
        public let productId: String
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String

        public init(acceptLanguage: String? = nil, productId: String, provisioningArtifactId: String) {
            self.acceptLanguage = acceptLanguage
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
        }
    }

    public struct DeleteProvisioningArtifactOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServiceActionInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DeleteServiceActionOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTagOptionInput: AWSEncodableShape {
        /// The TagOption identifier.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct DeleteTagOptionOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeConstraintInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The identifier of the constraint.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DescribeConstraintOutput: AWSDecodableShape {
        /// Information about the constraint.
        public let constraintDetail: ConstraintDetail?
        /// The constraint parameters.
        public let constraintParameters: String?
        /// The status of the current request.
        public let status: Status?

        public init(constraintDetail: ConstraintDetail? = nil, constraintParameters: String? = nil, status: Status? = nil) {
            self.constraintDetail = constraintDetail
            self.constraintParameters = constraintParameters
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case constraintDetail = "ConstraintDetail"
            case constraintParameters = "ConstraintParameters"
            case status = "Status"
        }
    }

    public struct DescribeCopyProductStatusInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The token for the copy product operation. This token is returned by CopyProduct.
        public let copyProductToken: String

        public init(acceptLanguage: String? = nil, copyProductToken: String) {
            self.acceptLanguage = acceptLanguage
            self.copyProductToken = copyProductToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.copyProductToken, name: "copyProductToken", parent: name, max: 100)
            try self.validate(self.copyProductToken, name: "copyProductToken", parent: name, min: 1)
            try self.validate(self.copyProductToken, name: "copyProductToken", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case copyProductToken = "CopyProductToken"
        }
    }

    public struct DescribeCopyProductStatusOutput: AWSDecodableShape {
        /// The status of the copy product operation.
        public let copyProductStatus: CopyProductStatus?
        /// The status message.
        public let statusDetail: String?
        /// The identifier of the copied product.
        public let targetProductId: String?

        public init(copyProductStatus: CopyProductStatus? = nil, statusDetail: String? = nil, targetProductId: String? = nil) {
            self.copyProductStatus = copyProductStatus
            self.statusDetail = statusDetail
            self.targetProductId = targetProductId
        }

        private enum CodingKeys: String, CodingKey {
            case copyProductStatus = "CopyProductStatus"
            case statusDetail = "StatusDetail"
            case targetProductId = "TargetProductId"
        }
    }

    public struct DescribePortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DescribePortfolioOutput: AWSDecodableShape {
        /// Information about the associated budgets.
        public let budgets: [BudgetDetail]?
        /// Information about the portfolio.
        public let portfolioDetail: PortfolioDetail?
        /// Information about the TagOptions associated with the portfolio.
        public let tagOptions: [TagOptionDetail]?
        /// Information about the tags associated with the portfolio.
        public let tags: [Tag]?

        public init(budgets: [BudgetDetail]? = nil, portfolioDetail: PortfolioDetail? = nil, tagOptions: [TagOptionDetail]? = nil, tags: [Tag]? = nil) {
            self.budgets = budgets
            self.portfolioDetail = portfolioDetail
            self.tagOptions = tagOptions
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case budgets = "Budgets"
            case portfolioDetail = "PortfolioDetail"
            case tagOptions = "TagOptions"
            case tags = "Tags"
        }
    }

    public struct DescribePortfolioShareStatusInput: AWSEncodableShape {
        /// The token for the portfolio share operation. This token is returned either by CreatePortfolioShare or by DeletePortfolioShare.
        public let portfolioShareToken: String

        public init(portfolioShareToken: String) {
            self.portfolioShareToken = portfolioShareToken
        }

        public func validate(name: String) throws {
            try self.validate(self.portfolioShareToken, name: "portfolioShareToken", parent: name, max: 100)
            try self.validate(self.portfolioShareToken, name: "portfolioShareToken", parent: name, min: 1)
            try self.validate(self.portfolioShareToken, name: "portfolioShareToken", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case portfolioShareToken = "PortfolioShareToken"
        }
    }

    public struct DescribePortfolioShareStatusOutput: AWSDecodableShape {
        /// Organization node identifier. It can be either account id, organizational unit id or organization id.
        public let organizationNodeValue: String?
        /// The portfolio identifier.
        public let portfolioId: String?
        /// The token for the portfolio share operation. For example, share-6v24abcdefghi.
        public let portfolioShareToken: String?
        /// Information about the portfolio share operation.
        public let shareDetails: ShareDetails?
        /// Status of the portfolio share operation.
        public let status: ShareStatus?

        public init(organizationNodeValue: String? = nil, portfolioId: String? = nil, portfolioShareToken: String? = nil, shareDetails: ShareDetails? = nil, status: ShareStatus? = nil) {
            self.organizationNodeValue = organizationNodeValue
            self.portfolioId = portfolioId
            self.portfolioShareToken = portfolioShareToken
            self.shareDetails = shareDetails
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case organizationNodeValue = "OrganizationNodeValue"
            case portfolioId = "PortfolioId"
            case portfolioShareToken = "PortfolioShareToken"
            case shareDetails = "ShareDetails"
            case status = "Status"
        }
    }

    public struct DescribePortfolioSharesInput: AWSEncodableShape {
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The unique identifier of the portfolio for which shares will be retrieved.
        public let portfolioId: String
        /// The type of portfolio share to summarize. This field acts as a filter on the type of portfolio share, which can be one of the following: 1. ACCOUNT - Represents an external account to account share. 2. ORGANIZATION - Represents a share to an organization. This share is available to every account in the organization. 3. ORGANIZATIONAL_UNIT - Represents a share to an organizational unit. 4. ORGANIZATION_MEMBER_ACCOUNT - Represents a share to an account in the organization.
        public let type: DescribePortfolioShareType

        public init(pageSize: Int? = nil, pageToken: String? = nil, portfolioId: String, type: DescribePortfolioShareType) {
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.portfolioId = portfolioId
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case portfolioId = "PortfolioId"
            case type = "Type"
        }
    }

    public struct DescribePortfolioSharesOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Summaries about each of the portfolio shares.
        public let portfolioShareDetails: [PortfolioShareDetail]?

        public init(nextPageToken: String? = nil, portfolioShareDetails: [PortfolioShareDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.portfolioShareDetails = portfolioShareDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case portfolioShareDetails = "PortfolioShareDetails"
        }
    }

    public struct DescribeProductAsAdminInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier.
        public let id: String?
        /// The product name.
        public let name: String?
        /// The unique identifier of the shared portfolio that the specified product is associated with. You can provide this parameter to retrieve the shared TagOptions associated with the product. If this parameter is provided and if TagOptions sharing is enabled in the portfolio share, the API returns both local and shared TagOptions associated with the product. Otherwise only local TagOptions will be returned.
        public let sourcePortfolioId: String?

        public init(acceptLanguage: String? = nil, id: String? = nil, name: String? = nil, sourcePortfolioId: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.id = id
            self.name = name
            self.sourcePortfolioId = sourcePortfolioId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.name, name: "name", parent: name, max: 8191)
            try self.validate(self.sourcePortfolioId, name: "sourcePortfolioId", parent: name, max: 100)
            try self.validate(self.sourcePortfolioId, name: "sourcePortfolioId", parent: name, min: 1)
            try self.validate(self.sourcePortfolioId, name: "sourcePortfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
            case name = "Name"
            case sourcePortfolioId = "SourcePortfolioId"
        }
    }

    public struct DescribeProductAsAdminOutput: AWSDecodableShape {
        /// Information about the associated budgets.
        public let budgets: [BudgetDetail]?
        /// Information about the product view.
        public let productViewDetail: ProductViewDetail?
        /// Information about the provisioning artifacts (also known as versions) for the specified product.
        public let provisioningArtifactSummaries: [ProvisioningArtifactSummary]?
        /// Information about the TagOptions associated with the product.
        public let tagOptions: [TagOptionDetail]?
        /// Information about the tags associated with the product.
        public let tags: [Tag]?

        public init(budgets: [BudgetDetail]? = nil, productViewDetail: ProductViewDetail? = nil, provisioningArtifactSummaries: [ProvisioningArtifactSummary]? = nil, tagOptions: [TagOptionDetail]? = nil, tags: [Tag]? = nil) {
            self.budgets = budgets
            self.productViewDetail = productViewDetail
            self.provisioningArtifactSummaries = provisioningArtifactSummaries
            self.tagOptions = tagOptions
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case budgets = "Budgets"
            case productViewDetail = "ProductViewDetail"
            case provisioningArtifactSummaries = "ProvisioningArtifactSummaries"
            case tagOptions = "TagOptions"
            case tags = "Tags"
        }
    }

    public struct DescribeProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier.
        public let id: String?
        /// The product name.
        public let name: String?

        public init(acceptLanguage: String? = nil, id: String? = nil, name: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.name, name: "name", parent: name, max: 8191)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct DescribeProductOutput: AWSDecodableShape {
        /// Information about the associated budgets.
        public let budgets: [BudgetDetail]?
        /// Information about the associated launch paths.
        public let launchPaths: [LaunchPath]?
        /// Summary information about the product view.
        public let productViewSummary: ProductViewSummary?
        /// Information about the provisioning artifacts for the specified product.
        public let provisioningArtifacts: [ProvisioningArtifact]?

        public init(budgets: [BudgetDetail]? = nil, launchPaths: [LaunchPath]? = nil, productViewSummary: ProductViewSummary? = nil, provisioningArtifacts: [ProvisioningArtifact]? = nil) {
            self.budgets = budgets
            self.launchPaths = launchPaths
            self.productViewSummary = productViewSummary
            self.provisioningArtifacts = provisioningArtifacts
        }

        private enum CodingKeys: String, CodingKey {
            case budgets = "Budgets"
            case launchPaths = "LaunchPaths"
            case productViewSummary = "ProductViewSummary"
            case provisioningArtifacts = "ProvisioningArtifacts"
        }
    }

    public struct DescribeProductViewInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product view identifier.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DescribeProductViewOutput: AWSDecodableShape {
        /// Summary information about the product.
        public let productViewSummary: ProductViewSummary?
        /// Information about the provisioning artifacts for the product.
        public let provisioningArtifacts: [ProvisioningArtifact]?

        public init(productViewSummary: ProductViewSummary? = nil, provisioningArtifacts: [ProvisioningArtifact]? = nil) {
            self.productViewSummary = productViewSummary
            self.provisioningArtifacts = provisioningArtifacts
        }

        private enum CodingKeys: String, CodingKey {
            case productViewSummary = "ProductViewSummary"
            case provisioningArtifacts = "ProvisioningArtifacts"
        }
    }

    public struct DescribeProvisionedProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The provisioned product identifier. You must provide the name or ID, but not both. If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
        public let id: String?
        /// The name of the provisioned product. You must provide the name or ID, but not both. If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
        public let name: String?

        public init(acceptLanguage: String? = nil, id: String? = nil, name: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9._-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct DescribeProvisionedProductOutput: AWSDecodableShape {
        /// Any CloudWatch dashboards that were created when provisioning the product.
        public let cloudWatchDashboards: [CloudWatchDashboard]?
        /// Information about the provisioned product.
        public let provisionedProductDetail: ProvisionedProductDetail?

        public init(cloudWatchDashboards: [CloudWatchDashboard]? = nil, provisionedProductDetail: ProvisionedProductDetail? = nil) {
            self.cloudWatchDashboards = cloudWatchDashboards
            self.provisionedProductDetail = provisionedProductDetail
        }

        private enum CodingKeys: String, CodingKey {
            case cloudWatchDashboards = "CloudWatchDashboards"
            case provisionedProductDetail = "ProvisionedProductDetail"
        }
    }

    public struct DescribeProvisionedProductPlanInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The plan identifier.
        public let planId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, planId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.planId = planId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.planId, name: "planId", parent: name, max: 100)
            try self.validate(self.planId, name: "planId", parent: name, min: 1)
            try self.validate(self.planId, name: "planId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case planId = "PlanId"
        }
    }

    public struct DescribeProvisionedProductPlanOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the plan.
        public let provisionedProductPlanDetails: ProvisionedProductPlanDetails?
        /// Information about the resource changes that will occur when the plan is executed.
        public let resourceChanges: [ResourceChange]?

        public init(nextPageToken: String? = nil, provisionedProductPlanDetails: ProvisionedProductPlanDetails? = nil, resourceChanges: [ResourceChange]? = nil) {
            self.nextPageToken = nextPageToken
            self.provisionedProductPlanDetails = provisionedProductPlanDetails
            self.resourceChanges = resourceChanges
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case provisionedProductPlanDetails = "ProvisionedProductPlanDetails"
            case resourceChanges = "ResourceChanges"
        }
    }

    public struct DescribeProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier.
        public let productId: String?
        /// The product name.
        public let productName: String?
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// The provisioning artifact name.
        public let provisioningArtifactName: String?
        /// Indicates whether a verbose level of detail is enabled.
        public let verbose: Bool?

        public init(acceptLanguage: String? = nil, productId: String? = nil, productName: String? = nil, provisioningArtifactId: String? = nil, provisioningArtifactName: String? = nil, verbose: Bool? = nil) {
            self.acceptLanguage = acceptLanguage
            self.productId = productId
            self.productName = productName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
            self.verbose = verbose
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productName, name: "productName", parent: name, max: 8191)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactName, name: "provisioningArtifactName", parent: name, max: 8192)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case productId = "ProductId"
            case productName = "ProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningArtifactName = "ProvisioningArtifactName"
            case verbose = "Verbose"
        }
    }

    public struct DescribeProvisioningArtifactOutput: AWSDecodableShape {
        /// The URL of the CloudFormation template in Amazon S3.
        public let info: [String: String]?
        /// Information about the provisioning artifact.
        public let provisioningArtifactDetail: ProvisioningArtifactDetail?
        /// The status of the current request.
        public let status: Status?

        public init(info: [String: String]? = nil, provisioningArtifactDetail: ProvisioningArtifactDetail? = nil, status: Status? = nil) {
            self.info = info
            self.provisioningArtifactDetail = provisioningArtifactDetail
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case info = "Info"
            case provisioningArtifactDetail = "ProvisioningArtifactDetail"
            case status = "Status"
        }
    }

    public struct DescribeProvisioningParametersInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use ListLaunchPaths. You must provide the name or ID, but not both.
        public let pathId: String?
        /// The name of the path. You must provide the name or ID, but not both.
        public let pathName: String?
        /// The product identifier. You must provide the product name or ID, but not both.
        public let productId: String?
        /// The name of the product. You must provide the name or ID, but not both.
        public let productName: String?
        /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
        public let provisioningArtifactId: String?
        /// The name of the provisioning artifact. You must provide the name or ID, but not both.
        public let provisioningArtifactName: String?

        public init(acceptLanguage: String? = nil, pathId: String? = nil, pathName: String? = nil, productId: String? = nil, productName: String? = nil, provisioningArtifactId: String? = nil, provisioningArtifactName: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.pathId = pathId
            self.pathName = pathName
            self.productId = productId
            self.productName = productName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pathId, name: "pathId", parent: name, max: 100)
            try self.validate(self.pathId, name: "pathId", parent: name, min: 1)
            try self.validate(self.pathId, name: "pathId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.pathName, name: "pathName", parent: name, max: 100)
            try self.validate(self.pathName, name: "pathName", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productName, name: "productName", parent: name, max: 8191)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactName, name: "provisioningArtifactName", parent: name, max: 8192)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pathId = "PathId"
            case pathName = "PathName"
            case productId = "ProductId"
            case productName = "ProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningArtifactName = "ProvisioningArtifactName"
        }
    }

    public struct DescribeProvisioningParametersOutput: AWSDecodableShape {
        /// Information about the constraints used to provision the product.
        public let constraintSummaries: [ConstraintSummary]?
        /// The output of the provisioning artifact.
        public let provisioningArtifactOutputs: [ProvisioningArtifactOutput]?
        /// Information about the parameters used to provision the product.
        public let provisioningArtifactParameters: [ProvisioningArtifactParameter]?
        /// An object that contains information about preferences, such as regions and accounts, for the provisioning artifact.
        public let provisioningArtifactPreferences: ProvisioningArtifactPreferences?
        /// Information about the TagOptions associated with the resource.
        public let tagOptions: [TagOptionSummary]?
        /// Any additional metadata specifically related to the provisioning of the product. For example, see the Version field of the CloudFormation template.
        public let usageInstructions: [UsageInstruction]?

        public init(constraintSummaries: [ConstraintSummary]? = nil, provisioningArtifactOutputs: [ProvisioningArtifactOutput]? = nil, provisioningArtifactParameters: [ProvisioningArtifactParameter]? = nil, provisioningArtifactPreferences: ProvisioningArtifactPreferences? = nil, tagOptions: [TagOptionSummary]? = nil, usageInstructions: [UsageInstruction]? = nil) {
            self.constraintSummaries = constraintSummaries
            self.provisioningArtifactOutputs = provisioningArtifactOutputs
            self.provisioningArtifactParameters = provisioningArtifactParameters
            self.provisioningArtifactPreferences = provisioningArtifactPreferences
            self.tagOptions = tagOptions
            self.usageInstructions = usageInstructions
        }

        private enum CodingKeys: String, CodingKey {
            case constraintSummaries = "ConstraintSummaries"
            case provisioningArtifactOutputs = "ProvisioningArtifactOutputs"
            case provisioningArtifactParameters = "ProvisioningArtifactParameters"
            case provisioningArtifactPreferences = "ProvisioningArtifactPreferences"
            case tagOptions = "TagOptions"
            case usageInstructions = "UsageInstructions"
        }
    }

    public struct DescribeRecordInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The record identifier of the provisioned product. This identifier is returned by the request operation.
        public let id: String
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?

        public init(acceptLanguage: String? = nil, id: String, pageSize: Int? = nil, pageToken: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.id = id
            self.pageSize = pageSize
            self.pageToken = pageToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
        }
    }

    public struct DescribeRecordOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the product.
        public let recordDetail: RecordDetail?
        /// Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
        public let recordOutputs: [RecordOutput]?

        public init(nextPageToken: String? = nil, recordDetail: RecordDetail? = nil, recordOutputs: [RecordOutput]? = nil) {
            self.nextPageToken = nextPageToken
            self.recordDetail = recordDetail
            self.recordOutputs = recordOutputs
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case recordDetail = "RecordDetail"
            case recordOutputs = "RecordOutputs"
        }
    }

    public struct DescribeServiceActionExecutionParametersInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The identifier of the provisioned product.
        public let provisionedProductId: String
        /// The self-service action identifier.
        public let serviceActionId: String

        public init(acceptLanguage: String? = nil, provisionedProductId: String, serviceActionId: String) {
            self.acceptLanguage = acceptLanguage
            self.provisionedProductId = provisionedProductId
            self.serviceActionId = serviceActionId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, min: 1)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, max: 100)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, min: 1)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case provisionedProductId = "ProvisionedProductId"
            case serviceActionId = "ServiceActionId"
        }
    }

    public struct DescribeServiceActionExecutionParametersOutput: AWSDecodableShape {
        /// The parameters of the self-service action.
        public let serviceActionParameters: [ExecutionParameter]?

        public init(serviceActionParameters: [ExecutionParameter]? = nil) {
            self.serviceActionParameters = serviceActionParameters
        }

        private enum CodingKeys: String, CodingKey {
            case serviceActionParameters = "ServiceActionParameters"
        }
    }

    public struct DescribeServiceActionInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The self-service action identifier.
        public let id: String

        public init(acceptLanguage: String? = nil, id: String) {
            self.acceptLanguage = acceptLanguage
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case id = "Id"
        }
    }

    public struct DescribeServiceActionOutput: AWSDecodableShape {
        /// Detailed information about the self-service action.
        public let serviceActionDetail: ServiceActionDetail?

        public init(serviceActionDetail: ServiceActionDetail? = nil) {
            self.serviceActionDetail = serviceActionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case serviceActionDetail = "ServiceActionDetail"
        }
    }

    public struct DescribeTagOptionInput: AWSEncodableShape {
        /// The TagOption identifier.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct DescribeTagOptionOutput: AWSDecodableShape {
        /// Information about the TagOption.
        public let tagOptionDetail: TagOptionDetail?

        public init(tagOptionDetail: TagOptionDetail? = nil) {
            self.tagOptionDetail = tagOptionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case tagOptionDetail = "TagOptionDetail"
        }
    }

    public struct DisableAWSOrganizationsAccessInput: AWSEncodableShape {
        public init() {}
    }

    public struct DisableAWSOrganizationsAccessOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateBudgetFromResourceInput: AWSEncodableShape {
        /// The name of the budget you want to disassociate.
        public let budgetName: String
        /// The resource identifier you want to disassociate from. Either a portfolio-id or a product-id.
        public let resourceId: String

        public init(budgetName: String, resourceId: String) {
            self.budgetName = budgetName
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.budgetName, name: "budgetName", parent: name, max: 100)
            try self.validate(self.budgetName, name: "budgetName", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 100)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case budgetName = "BudgetName"
            case resourceId = "ResourceId"
        }
    }

    public struct DisassociateBudgetFromResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociatePrincipalFromPortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let portfolioId: String
        /// The ARN of the principal (IAM user, role, or group).
        public let principalARN: String

        public init(acceptLanguage: String? = nil, portfolioId: String, principalARN: String) {
            self.acceptLanguage = acceptLanguage
            self.portfolioId = portfolioId
            self.principalARN = principalARN
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.principalARN, name: "principalARN", parent: name, max: 1000)
            try self.validate(self.principalARN, name: "principalARN", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case portfolioId = "PortfolioId"
            case principalARN = "PrincipalARN"
        }
    }

    public struct DisassociatePrincipalFromPortfolioOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateProductFromPortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let portfolioId: String
        /// The product identifier.
        public let productId: String

        public init(acceptLanguage: String? = nil, portfolioId: String, productId: String) {
            self.acceptLanguage = acceptLanguage
            self.portfolioId = portfolioId
            self.productId = productId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case portfolioId = "PortfolioId"
            case productId = "ProductId"
        }
    }

    public struct DisassociateProductFromPortfolioOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateServiceActionFromProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public let productId: String
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public let provisioningArtifactId: String
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public let serviceActionId: String

        public init(acceptLanguage: String? = nil, productId: String, provisioningArtifactId: String, serviceActionId: String) {
            self.acceptLanguage = acceptLanguage
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, max: 100)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, min: 1)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case serviceActionId = "ServiceActionId"
        }
    }

    public struct DisassociateServiceActionFromProvisioningArtifactOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateTagOptionFromResourceInput: AWSEncodableShape {
        /// The resource identifier.
        public let resourceId: String
        /// The TagOption identifier.
        public let tagOptionId: String

        public init(resourceId: String, tagOptionId: String) {
            self.resourceId = resourceId
            self.tagOptionId = tagOptionId
        }

        public func validate(name: String) throws {
            try self.validate(self.tagOptionId, name: "tagOptionId", parent: name, max: 100)
            try self.validate(self.tagOptionId, name: "tagOptionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceId = "ResourceId"
            case tagOptionId = "TagOptionId"
        }
    }

    public struct DisassociateTagOptionFromResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct EnableAWSOrganizationsAccessInput: AWSEncodableShape {
        public init() {}
    }

    public struct EnableAWSOrganizationsAccessOutput: AWSDecodableShape {
        public init() {}
    }

    public struct ExecuteProvisionedProductPlanInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The plan identifier.
        public let planId: String

        public init(acceptLanguage: String? = nil, idempotencyToken: String = ExecuteProvisionedProductPlanInput.idempotencyToken(), planId: String) {
            self.acceptLanguage = acceptLanguage
            self.idempotencyToken = idempotencyToken
            self.planId = planId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.planId, name: "planId", parent: name, max: 100)
            try self.validate(self.planId, name: "planId", parent: name, min: 1)
            try self.validate(self.planId, name: "planId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case idempotencyToken = "IdempotencyToken"
            case planId = "PlanId"
        }
    }

    public struct ExecuteProvisionedProductPlanOutput: AWSDecodableShape {
        /// Information about the result of provisioning the product.
        public let recordDetail: RecordDetail?

        public init(recordDetail: RecordDetail? = nil) {
            self.recordDetail = recordDetail
        }

        private enum CodingKeys: String, CodingKey {
            case recordDetail = "RecordDetail"
        }
    }

    public struct ExecuteProvisionedProductServiceActionInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// An idempotency token that uniquely identifies the execute request.
        public let executeToken: String
        /// A map of all self-service action parameters and their values. If a provided parameter is of a special type, such as TARGET, the provided value will override the default value generated by AWS Service Catalog. If the parameters field is not provided, no additional parameters are passed and default values will be used for any special parameters such as TARGET.
        public let parameters: [String: [String]]?
        /// The identifier of the provisioned product.
        public let provisionedProductId: String
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public let serviceActionId: String

        public init(acceptLanguage: String? = nil, executeToken: String = ExecuteProvisionedProductServiceActionInput.idempotencyToken(), parameters: [String: [String]]? = nil, provisionedProductId: String, serviceActionId: String) {
            self.acceptLanguage = acceptLanguage
            self.executeToken = executeToken
            self.parameters = parameters
            self.provisionedProductId = provisionedProductId
            self.serviceActionId = serviceActionId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.executeToken, name: "executeToken", parent: name, max: 128)
            try self.validate(self.executeToken, name: "executeToken", parent: name, min: 1)
            try self.validate(self.executeToken, name: "executeToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 50)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 25)
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, min: 1)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, max: 100)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, min: 1)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case executeToken = "ExecuteToken"
            case parameters = "Parameters"
            case provisionedProductId = "ProvisionedProductId"
            case serviceActionId = "ServiceActionId"
        }
    }

    public struct ExecuteProvisionedProductServiceActionOutput: AWSDecodableShape {
        /// An object containing detailed information about the result of provisioning the product.
        public let recordDetail: RecordDetail?

        public init(recordDetail: RecordDetail? = nil) {
            self.recordDetail = recordDetail
        }

        private enum CodingKeys: String, CodingKey {
            case recordDetail = "RecordDetail"
        }
    }

    public struct ExecutionParameter: AWSDecodableShape {
        /// The default values for the execution parameter.
        public let defaultValues: [String]?
        /// The name of the execution parameter.
        public let name: String?
        /// The execution parameter type.
        public let type: String?

        public init(defaultValues: [String]? = nil, name: String? = nil, type: String? = nil) {
            self.defaultValues = defaultValues
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValues = "DefaultValues"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct FailedServiceActionAssociation: AWSDecodableShape {
        /// The error code. Valid values are listed below.
        public let errorCode: ServiceActionAssociationErrorCode?
        /// A text description of the error.
        public let errorMessage: String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public let productId: String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public let provisioningArtifactId: String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public let serviceActionId: String?

        public init(errorCode: ServiceActionAssociationErrorCode? = nil, errorMessage: String? = nil, productId: String? = nil, provisioningArtifactId: String? = nil, serviceActionId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case serviceActionId = "ServiceActionId"
        }
    }

    public struct GetAWSOrganizationsAccessStatusInput: AWSEncodableShape {
        public init() {}
    }

    public struct GetAWSOrganizationsAccessStatusOutput: AWSDecodableShape {
        /// The status of the portfolio share feature.
        public let accessStatus: AccessStatus?

        public init(accessStatus: AccessStatus? = nil) {
            self.accessStatus = accessStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accessStatus = "AccessStatus"
        }
    }

    public struct GetProvisionedProductOutputsInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The list of keys that the API should return with their values. If none are provided, the API will return all outputs of the provisioned product.
        public let outputKeys: [String]?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The identifier of the provisioned product that you want the outputs from.
        public let provisionedProductId: String?
        /// The name of the provisioned product that you want the outputs from.
        public let provisionedProductName: String?

        public init(acceptLanguage: String? = nil, outputKeys: [String]? = nil, pageSize: Int? = nil, pageToken: String? = nil, provisionedProductId: String? = nil, provisionedProductName: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.outputKeys = outputKeys
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.provisionedProductId = provisionedProductId
            self.provisionedProductName = provisionedProductName
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.outputKeys, name: "outputKeys", parent: name, max: 60)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, min: 1)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, max: 128)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, min: 1)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9._-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case outputKeys = "OutputKeys"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case provisionedProductId = "ProvisionedProductId"
            case provisionedProductName = "ProvisionedProductName"
        }
    }

    public struct GetProvisionedProductOutputsOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
        public let outputs: [RecordOutput]?

        public init(nextPageToken: String? = nil, outputs: [RecordOutput]? = nil) {
            self.nextPageToken = nextPageToken
            self.outputs = outputs
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case outputs = "Outputs"
        }
    }

    public struct ImportAsProvisionedProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String
        /// The unique identifier of the resource to be imported. It only currently supports CloudFormation stack IDs.
        public let physicalId: String
        /// The product identifier.
        public let productId: String
        /// The user-friendly name of the provisioned product. The value must be unique for the AWS account. The name cannot be updated after the product is provisioned.
        public let provisionedProductName: String
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String

        public init(acceptLanguage: String? = nil, idempotencyToken: String = ImportAsProvisionedProductInput.idempotencyToken(), physicalId: String, productId: String, provisionedProductName: String, provisioningArtifactId: String) {
            self.acceptLanguage = acceptLanguage
            self.idempotencyToken = idempotencyToken
            self.physicalId = physicalId
            self.productId = productId
            self.provisionedProductName = provisionedProductName
            self.provisioningArtifactId = provisioningArtifactId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, max: 128)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, min: 1)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9._-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case idempotencyToken = "IdempotencyToken"
            case physicalId = "PhysicalId"
            case productId = "ProductId"
            case provisionedProductName = "ProvisionedProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
        }
    }

    public struct ImportAsProvisionedProductOutput: AWSDecodableShape {
        public let recordDetail: RecordDetail?

        public init(recordDetail: RecordDetail? = nil) {
            self.recordDetail = recordDetail
        }

        private enum CodingKeys: String, CodingKey {
            case recordDetail = "RecordDetail"
        }
    }

    public struct LaunchPath: AWSDecodableShape {
        /// The identifier of the launch path.
        public let id: String?
        /// The name of the launch path.
        public let name: String?

        public init(id: String? = nil, name: String? = nil) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
        }
    }

    public struct LaunchPathSummary: AWSDecodableShape {
        /// The constraints on the portfolio-product relationship.
        public let constraintSummaries: [ConstraintSummary]?
        /// The identifier of the product path.
        public let id: String?
        /// The name of the portfolio to which the user was assigned.
        public let name: String?
        /// The tags associated with this product path.
        public let tags: [Tag]?

        public init(constraintSummaries: [ConstraintSummary]? = nil, id: String? = nil, name: String? = nil, tags: [Tag]? = nil) {
            self.constraintSummaries = constraintSummaries
            self.id = id
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case constraintSummaries = "ConstraintSummaries"
            case id = "Id"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct ListAcceptedPortfolioSharesInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The type of shared portfolios to list. The default is to list imported portfolios.    AWS_ORGANIZATIONS - List portfolios shared by the management account of your organization    AWS_SERVICECATALOG - List default portfolios    IMPORTED - List imported portfolios
        public let portfolioShareType: PortfolioShareType?

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, portfolioShareType: PortfolioShareType? = nil) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.portfolioShareType = portfolioShareType
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case portfolioShareType = "PortfolioShareType"
        }
    }

    public struct ListAcceptedPortfolioSharesOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the portfolios.
        public let portfolioDetails: [PortfolioDetail]?

        public init(nextPageToken: String? = nil, portfolioDetails: [PortfolioDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.portfolioDetails = portfolioDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case portfolioDetails = "PortfolioDetails"
        }
    }

    public struct ListBudgetsForResourceInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The resource identifier.
        public let resourceId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, resourceId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.resourceId = resourceId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.resourceId, name: "resourceId", parent: name, max: 100)
            try self.validate(self.resourceId, name: "resourceId", parent: name, min: 1)
            try self.validate(self.resourceId, name: "resourceId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case resourceId = "ResourceId"
        }
    }

    public struct ListBudgetsForResourceOutput: AWSDecodableShape {
        /// Information about the associated budgets.
        public let budgets: [BudgetDetail]?
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?

        public init(budgets: [BudgetDetail]? = nil, nextPageToken: String? = nil) {
            self.budgets = budgets
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case budgets = "Budgets"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct ListConstraintsForPortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The portfolio identifier.
        public let portfolioId: String
        /// The product identifier.
        public let productId: String?

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, portfolioId: String, productId: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.portfolioId = portfolioId
            self.productId = productId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case portfolioId = "PortfolioId"
            case productId = "ProductId"
        }
    }

    public struct ListConstraintsForPortfolioOutput: AWSDecodableShape {
        /// Information about the constraints.
        public let constraintDetails: [ConstraintDetail]?
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?

        public init(constraintDetails: [ConstraintDetail]? = nil, nextPageToken: String? = nil) {
            self.constraintDetails = constraintDetails
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case constraintDetails = "ConstraintDetails"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct ListLaunchPathsInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The product identifier.
        public let productId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, productId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.productId = productId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case productId = "ProductId"
        }
    }

    public struct ListLaunchPathsOutput: AWSDecodableShape {
        /// Information about the launch path.
        public let launchPathSummaries: [LaunchPathSummary]?
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?

        public init(launchPathSummaries: [LaunchPathSummary]? = nil, nextPageToken: String? = nil) {
            self.launchPathSummaries = launchPathSummaries
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case launchPathSummaries = "LaunchPathSummaries"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct ListOrganizationPortfolioAccessInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The organization node type that will be returned in the output.    ORGANIZATION - Organization that has access to the portfolio.     ORGANIZATIONAL_UNIT - Organizational unit that has access to the portfolio within your organization.    ACCOUNT - Account that has access to the portfolio within your organization.
        public let organizationNodeType: OrganizationNodeType
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The portfolio identifier. For example, port-2abcdext3y5fk.
        public let portfolioId: String

        public init(acceptLanguage: String? = nil, organizationNodeType: OrganizationNodeType, pageSize: Int? = nil, pageToken: String? = nil, portfolioId: String) {
            self.acceptLanguage = acceptLanguage
            self.organizationNodeType = organizationNodeType
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.portfolioId = portfolioId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case organizationNodeType = "OrganizationNodeType"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case portfolioId = "PortfolioId"
        }
    }

    public struct ListOrganizationPortfolioAccessOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Displays information about the organization nodes.
        public let organizationNodes: [OrganizationNode]?

        public init(nextPageToken: String? = nil, organizationNodes: [OrganizationNode]? = nil) {
            self.nextPageToken = nextPageToken
            self.organizationNodes = organizationNodes
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case organizationNodes = "OrganizationNodes"
        }
    }

    public struct ListPortfolioAccessInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The ID of an organization node the portfolio is shared with. All children of this node with an inherited portfolio share will be returned.
        public let organizationParentId: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The portfolio identifier.
        public let portfolioId: String

        public init(acceptLanguage: String? = nil, organizationParentId: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, portfolioId: String) {
            self.acceptLanguage = acceptLanguage
            self.organizationParentId = organizationParentId
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.portfolioId = portfolioId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.organizationParentId, name: "organizationParentId", parent: name, max: 100)
            try self.validate(self.organizationParentId, name: "organizationParentId", parent: name, min: 1)
            try self.validate(self.organizationParentId, name: "organizationParentId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case organizationParentId = "OrganizationParentId"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case portfolioId = "PortfolioId"
        }
    }

    public struct ListPortfolioAccessOutput: AWSDecodableShape {
        /// Information about the AWS accounts with access to the portfolio.
        public let accountIds: [String]?
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?

        public init(accountIds: [String]? = nil, nextPageToken: String? = nil) {
            self.accountIds = accountIds
            self.nextPageToken = nextPageToken
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case nextPageToken = "NextPageToken"
        }
    }

    public struct ListPortfoliosForProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The product identifier.
        public let productId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, productId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.productId = productId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case productId = "ProductId"
        }
    }

    public struct ListPortfoliosForProductOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the portfolios.
        public let portfolioDetails: [PortfolioDetail]?

        public init(nextPageToken: String? = nil, portfolioDetails: [PortfolioDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.portfolioDetails = portfolioDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case portfolioDetails = "PortfolioDetails"
        }
    }

    public struct ListPortfoliosInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
        }
    }

    public struct ListPortfoliosOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the portfolios.
        public let portfolioDetails: [PortfolioDetail]?

        public init(nextPageToken: String? = nil, portfolioDetails: [PortfolioDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.portfolioDetails = portfolioDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case portfolioDetails = "PortfolioDetails"
        }
    }

    public struct ListPrincipalsForPortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The portfolio identifier.
        public let portfolioId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, portfolioId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.portfolioId = portfolioId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case portfolioId = "PortfolioId"
        }
    }

    public struct ListPrincipalsForPortfolioOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// The IAM principals (users or roles) associated with the portfolio.
        public let principals: [Principal]?

        public init(nextPageToken: String? = nil, principals: [Principal]? = nil) {
            self.nextPageToken = nextPageToken
            self.principals = principals
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case principals = "Principals"
        }
    }

    public struct ListProvisionedProductPlansInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The access level to use to obtain results. The default is User.
        public let accessLevelFilter: AccessLevelFilter?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The product identifier.
        public let provisionProductId: String?

        public init(acceptLanguage: String? = nil, accessLevelFilter: AccessLevelFilter? = nil, pageSize: Int? = nil, pageToken: String? = nil, provisionProductId: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.accessLevelFilter = accessLevelFilter
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.provisionProductId = provisionProductId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.provisionProductId, name: "provisionProductId", parent: name, max: 100)
            try self.validate(self.provisionProductId, name: "provisionProductId", parent: name, min: 1)
            try self.validate(self.provisionProductId, name: "provisionProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case accessLevelFilter = "AccessLevelFilter"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case provisionProductId = "ProvisionProductId"
        }
    }

    public struct ListProvisionedProductPlansOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the plans.
        public let provisionedProductPlans: [ProvisionedProductPlanSummary]?

        public init(nextPageToken: String? = nil, provisionedProductPlans: [ProvisionedProductPlanSummary]? = nil) {
            self.nextPageToken = nextPageToken
            self.provisionedProductPlans = provisionedProductPlans
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case provisionedProductPlans = "ProvisionedProductPlans"
        }
    }

    public struct ListProvisioningArtifactsForServiceActionInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public let serviceActionId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, serviceActionId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.serviceActionId = serviceActionId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, max: 100)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, min: 1)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case serviceActionId = "ServiceActionId"
        }
    }

    public struct ListProvisioningArtifactsForServiceActionOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// An array of objects with information about product views and provisioning artifacts.
        public let provisioningArtifactViews: [ProvisioningArtifactView]?

        public init(nextPageToken: String? = nil, provisioningArtifactViews: [ProvisioningArtifactView]? = nil) {
            self.nextPageToken = nextPageToken
            self.provisioningArtifactViews = provisioningArtifactViews
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case provisioningArtifactViews = "ProvisioningArtifactViews"
        }
    }

    public struct ListProvisioningArtifactsInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The product identifier.
        public let productId: String

        public init(acceptLanguage: String? = nil, productId: String) {
            self.acceptLanguage = acceptLanguage
            self.productId = productId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case productId = "ProductId"
        }
    }

    public struct ListProvisioningArtifactsOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the provisioning artifacts.
        public let provisioningArtifactDetails: [ProvisioningArtifactDetail]?

        public init(nextPageToken: String? = nil, provisioningArtifactDetails: [ProvisioningArtifactDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.provisioningArtifactDetails = provisioningArtifactDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case provisioningArtifactDetails = "ProvisioningArtifactDetails"
        }
    }

    public struct ListRecordHistoryInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The access level to use to obtain results. The default is User.
        public let accessLevelFilter: AccessLevelFilter?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The search filter to scope the results.
        public let searchFilter: ListRecordHistorySearchFilter?

        public init(acceptLanguage: String? = nil, accessLevelFilter: AccessLevelFilter? = nil, pageSize: Int? = nil, pageToken: String? = nil, searchFilter: ListRecordHistorySearchFilter? = nil) {
            self.acceptLanguage = acceptLanguage
            self.accessLevelFilter = accessLevelFilter
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case accessLevelFilter = "AccessLevelFilter"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case searchFilter = "SearchFilter"
        }
    }

    public struct ListRecordHistoryOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// The records, in reverse chronological order.
        public let recordDetails: [RecordDetail]?

        public init(nextPageToken: String? = nil, recordDetails: [RecordDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.recordDetails = recordDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case recordDetails = "RecordDetails"
        }
    }

    public struct ListRecordHistorySearchFilter: AWSEncodableShape {
        /// The filter key.    product - Filter results based on the specified product identifier.    provisionedproduct - Filter results based on the provisioned product identifier.
        public let key: String?
        /// The filter value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ListResourcesForTagOptionInput: AWSEncodableShape {
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The resource type.    Portfolio     Product
        public let resourceType: String?
        /// The TagOption identifier.
        public let tagOptionId: String

        public init(pageSize: Int? = nil, pageToken: String? = nil, resourceType: String? = nil, tagOptionId: String) {
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.resourceType = resourceType
            self.tagOptionId = tagOptionId
        }

        public func validate(name: String) throws {
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.tagOptionId, name: "tagOptionId", parent: name, max: 100)
            try self.validate(self.tagOptionId, name: "tagOptionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case resourceType = "ResourceType"
            case tagOptionId = "TagOptionId"
        }
    }

    public struct ListResourcesForTagOptionOutput: AWSDecodableShape {
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// Information about the resources.
        public let resourceDetails: [ResourceDetail]?

        public init(pageToken: String? = nil, resourceDetails: [ResourceDetail]? = nil) {
            self.pageToken = pageToken
            self.resourceDetails = resourceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case pageToken = "PageToken"
            case resourceDetails = "ResourceDetails"
        }
    }

    public struct ListServiceActionsForProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public let productId: String
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public let provisioningArtifactId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, productId: String, provisioningArtifactId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
        }
    }

    public struct ListServiceActionsForProvisioningArtifactOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// An object containing information about the self-service actions associated with the provisioning artifact.
        public let serviceActionSummaries: [ServiceActionSummary]?

        public init(nextPageToken: String? = nil, serviceActionSummaries: [ServiceActionSummary]? = nil) {
            self.nextPageToken = nextPageToken
            self.serviceActionSummaries = serviceActionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case serviceActionSummaries = "ServiceActionSummaries"
        }
    }

    public struct ListServiceActionsInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
        }
    }

    public struct ListServiceActionsOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// An object containing information about the service actions associated with the provisioning artifact.
        public let serviceActionSummaries: [ServiceActionSummary]?

        public init(nextPageToken: String? = nil, serviceActionSummaries: [ServiceActionSummary]? = nil) {
            self.nextPageToken = nextPageToken
            self.serviceActionSummaries = serviceActionSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case serviceActionSummaries = "ServiceActionSummaries"
        }
    }

    public struct ListStackInstancesForProvisionedProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The identifier of the provisioned product.
        public let provisionedProductId: String

        public init(acceptLanguage: String? = nil, pageSize: Int? = nil, pageToken: String? = nil, provisionedProductId: String) {
            self.acceptLanguage = acceptLanguage
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.provisionedProductId = provisionedProductId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, min: 1)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case provisionedProductId = "ProvisionedProductId"
        }
    }

    public struct ListStackInstancesForProvisionedProductOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// List of stack instances.
        public let stackInstances: [StackInstance]?

        public init(nextPageToken: String? = nil, stackInstances: [StackInstance]? = nil) {
            self.nextPageToken = nextPageToken
            self.stackInstances = stackInstances
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case stackInstances = "StackInstances"
        }
    }

    public struct ListTagOptionsFilters: AWSEncodableShape {
        /// The active state.
        public let active: Bool?
        /// The TagOption key.
        public let key: String?
        /// The TagOption value.
        public let value: String?

        public init(active: Bool? = nil, key: String? = nil, value: String? = nil) {
            self.active = active
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "Active"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ListTagOptionsInput: AWSEncodableShape {
        /// The search filters. If no search filters are specified, the output includes all TagOptions.
        public let filters: ListTagOptionsFilters?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?

        public init(filters: ListTagOptionsFilters? = nil, pageSize: Int? = nil, pageToken: String? = nil) {
            self.filters = filters
            self.pageSize = pageSize
            self.pageToken = pageToken
        }

        public func validate(name: String) throws {
            try self.filters?.validate(name: "\(name).filters")
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
        }
    }

    public struct ListTagOptionsOutput: AWSDecodableShape {
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// Information about the TagOptions.
        public let tagOptionDetails: [TagOptionDetail]?

        public init(pageToken: String? = nil, tagOptionDetails: [TagOptionDetail]? = nil) {
            self.pageToken = pageToken
            self.tagOptionDetails = tagOptionDetails
        }

        private enum CodingKeys: String, CodingKey {
            case pageToken = "PageToken"
            case tagOptionDetails = "TagOptionDetails"
        }
    }

    public struct OrganizationNode: AWSEncodableShape & AWSDecodableShape {
        /// The organization node type.
        public let type: OrganizationNodeType?
        /// The identifier of the organization node.
        public let value: String?

        public init(type: OrganizationNodeType? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "(^[0-9]{12}$)|(^arn:aws:organizations::\\d{12}:organization\\/o-[a-z0-9]{10,32})|(^o-[a-z0-9]{10,32}$)|(^arn:aws:organizations::\\d{12}:ou\\/o-[a-z0-9]{10,32}\\/ou-[0-9a-z]{4,32}-[0-9a-z]{8,32}$)|(^ou-[0-9a-z]{4,32}-[a-z0-9]{8,32}$)")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct ParameterConstraints: AWSDecodableShape {
        /// A regular expression that represents the patterns that allow for String types. The pattern must match the entire parameter value provided.
        public let allowedPattern: String?
        /// The values that the administrator has allowed for the parameter.
        public let allowedValues: [String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value:  Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+  By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message:  Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.
        public let constraintDescription: String?
        /// An integer value that determines the largest number of characters you want to allow for String types.
        public let maxLength: String?
        /// A numeric value that determines the largest numeric value you want to allow for Number types.
        public let maxValue: String?
        /// An integer value that determines the smallest number of characters you want to allow for String types.
        public let minLength: String?
        /// A numeric value that determines the smallest numeric value you want to allow for Number types.
        public let minValue: String?

        public init(allowedPattern: String? = nil, allowedValues: [String]? = nil, constraintDescription: String? = nil, maxLength: String? = nil, maxValue: String? = nil, minLength: String? = nil, minValue: String? = nil) {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
        }

        private enum CodingKeys: String, CodingKey {
            case allowedPattern = "AllowedPattern"
            case allowedValues = "AllowedValues"
            case constraintDescription = "ConstraintDescription"
            case maxLength = "MaxLength"
            case maxValue = "MaxValue"
            case minLength = "MinLength"
            case minValue = "MinValue"
        }
    }

    public struct PortfolioDetail: AWSDecodableShape {
        /// The ARN assigned to the portfolio.
        public let arn: String?
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The description of the portfolio.
        public let description: String?
        /// The name to use for display purposes.
        public let displayName: String?
        /// The portfolio identifier.
        public let id: String?
        /// The name of the portfolio provider.
        public let providerName: String?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, displayName: String? = nil, id: String? = nil, providerName: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.id = id
            self.providerName = providerName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
            case createdTime = "CreatedTime"
            case description = "Description"
            case displayName = "DisplayName"
            case id = "Id"
            case providerName = "ProviderName"
        }
    }

    public struct PortfolioShareDetail: AWSDecodableShape {
        /// Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.
        public let accepted: Bool?
        /// The identifier of the recipient entity that received the portfolio share. The recipient entities can be one of the following:  1. An external account. 2. An organziation member account. 3. An organzational unit (OU). 4. The organization itself. (This shares with every account in the organization).
        public let principalId: String?
        /// Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.
        public let shareTagOptions: Bool?
        /// The type of the portfolio share.
        public let type: DescribePortfolioShareType?

        public init(accepted: Bool? = nil, principalId: String? = nil, shareTagOptions: Bool? = nil, type: DescribePortfolioShareType? = nil) {
            self.accepted = accepted
            self.principalId = principalId
            self.shareTagOptions = shareTagOptions
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case accepted = "Accepted"
            case principalId = "PrincipalId"
            case shareTagOptions = "ShareTagOptions"
            case type = "Type"
        }
    }

    public struct Principal: AWSDecodableShape {
        /// The ARN of the principal (IAM user, role, or group).
        public let principalARN: String?
        /// The principal type. The supported value is IAM.
        public let principalType: PrincipalType?

        public init(principalARN: String? = nil, principalType: PrincipalType? = nil) {
            self.principalARN = principalARN
            self.principalType = principalType
        }

        private enum CodingKeys: String, CodingKey {
            case principalARN = "PrincipalARN"
            case principalType = "PrincipalType"
        }
    }

    public struct ProductViewAggregationValue: AWSDecodableShape {
        /// An approximate count of the products that match the value.
        public let approximateCount: Int?
        /// The value of the product view aggregation.
        public let value: String?

        public init(approximateCount: Int? = nil, value: String? = nil) {
            self.approximateCount = approximateCount
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case approximateCount = "ApproximateCount"
            case value = "Value"
        }
    }

    public struct ProductViewDetail: AWSDecodableShape {
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The ARN of the product.
        public let productARN: String?
        /// Summary information about the product view.
        public let productViewSummary: ProductViewSummary?
        /// The status of the product.    AVAILABLE - The product is ready for use.    CREATING - Product creation has started; the product is not ready for use.    FAILED - An action failed.
        public let status: Status?

        public init(createdTime: Date? = nil, productARN: String? = nil, productViewSummary: ProductViewSummary? = nil, status: Status? = nil) {
            self.createdTime = createdTime
            self.productARN = productARN
            self.productViewSummary = productViewSummary
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case productARN = "ProductARN"
            case productViewSummary = "ProductViewSummary"
            case status = "Status"
        }
    }

    public struct ProductViewSummary: AWSDecodableShape {
        /// The distributor of the product. Contact the product administrator for the significance of this value.
        public let distributor: String?
        /// Indicates whether the product has a default path. If the product does not have a default path, call ListLaunchPaths to disambiguate between paths. Otherwise, ListLaunchPaths is not required, and the output of ProductViewSummary can be used directly with DescribeProvisioningParameters.
        public let hasDefaultPath: Bool?
        /// The product view identifier.
        public let id: String?
        /// The name of the product.
        public let name: String?
        /// The owner of the product. Contact the product administrator for the significance of this value.
        public let owner: String?
        /// The product identifier.
        public let productId: String?
        /// Short description of the product.
        public let shortDescription: String?
        /// The description of the support for this Product.
        public let supportDescription: String?
        /// The email contact information to obtain support for this Product.
        public let supportEmail: String?
        /// The URL information to obtain support for this Product.
        public let supportUrl: String?
        /// The product type. Contact the product administrator for the significance of this value. If this value is MARKETPLACE, the product was created by AWS Marketplace.
        public let type: ProductType?

        public init(distributor: String? = nil, hasDefaultPath: Bool? = nil, id: String? = nil, name: String? = nil, owner: String? = nil, productId: String? = nil, shortDescription: String? = nil, supportDescription: String? = nil, supportEmail: String? = nil, supportUrl: String? = nil, type: ProductType? = nil) {
            self.distributor = distributor
            self.hasDefaultPath = hasDefaultPath
            self.id = id
            self.name = name
            self.owner = owner
            self.productId = productId
            self.shortDescription = shortDescription
            self.supportDescription = supportDescription
            self.supportEmail = supportEmail
            self.supportUrl = supportUrl
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case distributor = "Distributor"
            case hasDefaultPath = "HasDefaultPath"
            case id = "Id"
            case name = "Name"
            case owner = "Owner"
            case productId = "ProductId"
            case shortDescription = "ShortDescription"
            case supportDescription = "SupportDescription"
            case supportEmail = "SupportEmail"
            case supportUrl = "SupportUrl"
            case type = "Type"
        }
    }

    public struct ProvisionProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
        public let notificationArns: [String]?
        /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use ListLaunchPaths. You must provide the name or ID, but not both.
        public let pathId: String?
        /// The name of the path. You must provide the name or ID, but not both.
        public let pathName: String?
        /// The product identifier. You must provide the name or ID, but not both.
        public let productId: String?
        /// The name of the product. You must provide the name or ID, but not both.
        public let productName: String?
        /// A user-friendly name for the provisioned product. This value must be unique for the AWS account and cannot be updated after the product is provisioned.
        public let provisionedProductName: String
        /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
        public let provisioningArtifactId: String?
        /// The name of the provisioning artifact. You must provide the name or ID, but not both.
        public let provisioningArtifactName: String?
        /// Parameters specified by the administrator that are required for provisioning the product.
        public let provisioningParameters: [ProvisioningParameter]?
        /// An object that contains information about the provisioning preferences for a stack set.
        public let provisioningPreferences: ProvisioningPreferences?
        /// An idempotency token that uniquely identifies the provisioning request.
        public let provisionToken: String
        /// One or more tags.
        public let tags: [Tag]?

        public init(acceptLanguage: String? = nil, notificationArns: [String]? = nil, pathId: String? = nil, pathName: String? = nil, productId: String? = nil, productName: String? = nil, provisionedProductName: String, provisioningArtifactId: String? = nil, provisioningArtifactName: String? = nil, provisioningParameters: [ProvisioningParameter]? = nil, provisioningPreferences: ProvisioningPreferences? = nil, provisionToken: String = ProvisionProductInput.idempotencyToken(), tags: [Tag]? = nil) {
            self.acceptLanguage = acceptLanguage
            self.notificationArns = notificationArns
            self.pathId = pathId
            self.pathName = pathName
            self.productId = productId
            self.productName = productName
            self.provisionedProductName = provisionedProductName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
            self.provisioningParameters = provisioningParameters
            self.provisioningPreferences = provisioningPreferences
            self.provisionToken = provisionToken
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.notificationArns?.forEach {
                try validate($0, name: "notificationArns[]", parent: name, max: 1224)
                try validate($0, name: "notificationArns[]", parent: name, min: 1)
                try validate($0, name: "notificationArns[]", parent: name, pattern: "arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            }
            try self.validate(self.notificationArns, name: "notificationArns", parent: name, max: 5)
            try self.validate(self.pathId, name: "pathId", parent: name, max: 100)
            try self.validate(self.pathId, name: "pathId", parent: name, min: 1)
            try self.validate(self.pathId, name: "pathId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.pathName, name: "pathName", parent: name, max: 100)
            try self.validate(self.pathName, name: "pathName", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productName, name: "productName", parent: name, max: 8191)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, max: 128)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, min: 1)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9._-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactName, name: "provisioningArtifactName", parent: name, max: 8192)
            try self.provisioningParameters?.forEach {
                try $0.validate(name: "\(name).provisioningParameters[]")
            }
            try self.provisioningPreferences?.validate(name: "\(name).provisioningPreferences")
            try self.validate(self.provisionToken, name: "provisionToken", parent: name, max: 128)
            try self.validate(self.provisionToken, name: "provisionToken", parent: name, min: 1)
            try self.validate(self.provisionToken, name: "provisionToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case notificationArns = "NotificationArns"
            case pathId = "PathId"
            case pathName = "PathName"
            case productId = "ProductId"
            case productName = "ProductName"
            case provisionedProductName = "ProvisionedProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningArtifactName = "ProvisioningArtifactName"
            case provisioningParameters = "ProvisioningParameters"
            case provisioningPreferences = "ProvisioningPreferences"
            case provisionToken = "ProvisionToken"
            case tags = "Tags"
        }
    }

    public struct ProvisionProductOutput: AWSDecodableShape {
        /// Information about the result of provisioning the product.
        public let recordDetail: RecordDetail?

        public init(recordDetail: RecordDetail? = nil) {
            self.recordDetail = recordDetail
        }

        private enum CodingKeys: String, CodingKey {
            case recordDetail = "RecordDetail"
        }
    }

    public struct ProvisionedProductAttribute: AWSDecodableShape {
        /// The ARN of the provisioned product.
        public let arn: String?
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The identifier of the provisioned product.
        public let id: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String?
        /// The record identifier of the last request performed on this provisioned product of the following types:    ProvisionedProduct     UpdateProvisionedProduct     ExecuteProvisionedProductPlan     TerminateProvisionedProduct
        public let lastProvisioningRecordId: String?
        /// The record identifier of the last request performed on this provisioned product.
        public let lastRecordId: String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:    ProvisionedProduct     UpdateProvisionedProduct     ExecuteProvisionedProductPlan     TerminateProvisionedProduct
        public let lastSuccessfulProvisioningRecordId: String?
        /// The user-friendly name of the provisioned product.
        public let name: String?
        /// The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.
        public let physicalId: String?
        /// The product identifier.
        public let productId: String?
        /// The name of the product.
        public let productName: String?
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// The name of the provisioning artifact.
        public let provisioningArtifactName: String?
        /// The current status of the provisioned product.    AVAILABLE - Stable state, ready to perform any operation. The most recent operation succeeded and completed.    UNDER_CHANGE - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.    TAINTED - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.    ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.    PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        public let status: ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public let statusMessage: String?
        /// One or more tags.
        public let tags: [Tag]?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public let type: String?
        /// The Amazon Resource Name (ARN) of the IAM user.
        public let userArn: String?
        /// The ARN of the IAM user in the session. This ARN might contain a session ID.
        public let userArnSession: String?

        public init(arn: String? = nil, createdTime: Date? = nil, id: String? = nil, idempotencyToken: String? = nil, lastProvisioningRecordId: String? = nil, lastRecordId: String? = nil, lastSuccessfulProvisioningRecordId: String? = nil, name: String? = nil, physicalId: String? = nil, productId: String? = nil, productName: String? = nil, provisioningArtifactId: String? = nil, provisioningArtifactName: String? = nil, status: ProvisionedProductStatus? = nil, statusMessage: String? = nil, tags: [Tag]? = nil, type: String? = nil, userArn: String? = nil, userArnSession: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.name = name
            self.physicalId = physicalId
            self.productId = productId
            self.productName = productName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.type = type
            self.userArn = userArn
            self.userArnSession = userArnSession
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case id = "Id"
            case idempotencyToken = "IdempotencyToken"
            case lastProvisioningRecordId = "LastProvisioningRecordId"
            case lastRecordId = "LastRecordId"
            case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
            case name = "Name"
            case physicalId = "PhysicalId"
            case productId = "ProductId"
            case productName = "ProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningArtifactName = "ProvisioningArtifactName"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case tags = "Tags"
            case type = "Type"
            case userArn = "UserArn"
            case userArnSession = "UserArnSession"
        }
    }

    public struct ProvisionedProductDetail: AWSDecodableShape {
        /// The ARN of the provisioned product.
        public let arn: String?
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The identifier of the provisioned product.
        public let id: String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public let idempotencyToken: String?
        /// The record identifier of the last request performed on this provisioned product of the following types:    ProvisionedProduct     UpdateProvisionedProduct     ExecuteProvisionedProductPlan     TerminateProvisionedProduct
        public let lastProvisioningRecordId: String?
        /// The record identifier of the last request performed on this provisioned product.
        public let lastRecordId: String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:    ProvisionedProduct     UpdateProvisionedProduct     ExecuteProvisionedProductPlan     TerminateProvisionedProduct
        public let lastSuccessfulProvisioningRecordId: String?
        /// The ARN of the launch role associated with the provisioned product.
        public let launchRoleArn: String?
        /// The user-friendly name of the provisioned product.
        public let name: String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public let productId: String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public let provisioningArtifactId: String?
        /// The current status of the provisioned product.    AVAILABLE - Stable state, ready to perform any operation. The most recent operation succeeded and completed.    UNDER_CHANGE - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.    TAINTED - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.    ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.    PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        public let status: ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public let statusMessage: String?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public let type: String?

        public init(arn: String? = nil, createdTime: Date? = nil, id: String? = nil, idempotencyToken: String? = nil, lastProvisioningRecordId: String? = nil, lastRecordId: String? = nil, lastSuccessfulProvisioningRecordId: String? = nil, launchRoleArn: String? = nil, name: String? = nil, productId: String? = nil, provisioningArtifactId: String? = nil, status: ProvisionedProductStatus? = nil, statusMessage: String? = nil, type: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.launchRoleArn = launchRoleArn
            self.name = name
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case id = "Id"
            case idempotencyToken = "IdempotencyToken"
            case lastProvisioningRecordId = "LastProvisioningRecordId"
            case lastRecordId = "LastRecordId"
            case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
            case launchRoleArn = "LaunchRoleArn"
            case name = "Name"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case type = "Type"
        }
    }

    public struct ProvisionedProductPlanDetails: AWSDecodableShape {
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
        public let notificationArns: [String]?
        /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use ListLaunchPaths.
        public let pathId: String?
        /// The plan identifier.
        public let planId: String?
        /// The name of the plan.
        public let planName: String?
        /// The plan type.
        public let planType: ProvisionedProductPlanType?
        /// The product identifier.
        public let productId: String?
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// Parameters specified by the administrator that are required for provisioning the product.
        public let provisioningParameters: [UpdateProvisioningParameter]?
        /// The product identifier.
        public let provisionProductId: String?
        /// The user-friendly name of the provisioned product.
        public let provisionProductName: String?
        /// The status.
        public let status: ProvisionedProductPlanStatus?
        /// The status message.
        public let statusMessage: String?
        /// One or more tags.
        public let tags: [Tag]?
        /// The time when the plan was last updated.
        public let updatedTime: Date?

        public init(createdTime: Date? = nil, notificationArns: [String]? = nil, pathId: String? = nil, planId: String? = nil, planName: String? = nil, planType: ProvisionedProductPlanType? = nil, productId: String? = nil, provisioningArtifactId: String? = nil, provisioningParameters: [UpdateProvisioningParameter]? = nil, provisionProductId: String? = nil, provisionProductName: String? = nil, status: ProvisionedProductPlanStatus? = nil, statusMessage: String? = nil, tags: [Tag]? = nil, updatedTime: Date? = nil) {
            self.createdTime = createdTime
            self.notificationArns = notificationArns
            self.pathId = pathId
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningParameters = provisioningParameters
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case notificationArns = "NotificationArns"
            case pathId = "PathId"
            case planId = "PlanId"
            case planName = "PlanName"
            case planType = "PlanType"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningParameters = "ProvisioningParameters"
            case provisionProductId = "ProvisionProductId"
            case provisionProductName = "ProvisionProductName"
            case status = "Status"
            case statusMessage = "StatusMessage"
            case tags = "Tags"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct ProvisionedProductPlanSummary: AWSDecodableShape {
        /// The plan identifier.
        public let planId: String?
        /// The name of the plan.
        public let planName: String?
        /// The plan type.
        public let planType: ProvisionedProductPlanType?
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// The product identifier.
        public let provisionProductId: String?
        /// The user-friendly name of the provisioned product.
        public let provisionProductName: String?

        public init(planId: String? = nil, planName: String? = nil, planType: ProvisionedProductPlanType? = nil, provisioningArtifactId: String? = nil, provisionProductId: String? = nil, provisionProductName: String? = nil) {
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.provisioningArtifactId = provisioningArtifactId
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
        }

        private enum CodingKeys: String, CodingKey {
            case planId = "PlanId"
            case planName = "PlanName"
            case planType = "PlanType"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisionProductId = "ProvisionProductId"
            case provisionProductName = "ProvisionProductName"
        }
    }

    public struct ProvisioningArtifact: AWSDecodableShape {
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The description of the provisioning artifact.
        public let description: String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public let guidance: ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public let id: String?
        /// The name of the provisioning artifact.
        public let name: String?

        public init(createdTime: Date? = nil, description: String? = nil, guidance: ProvisioningArtifactGuidance? = nil, id: String? = nil, name: String? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case guidance = "Guidance"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ProvisioningArtifactDetail: AWSDecodableShape {
        /// Indicates whether the product version is active.
        public let active: Bool?
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The description of the provisioning artifact.
        public let description: String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public let guidance: ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public let id: String?
        /// The name of the provisioning artifact.
        public let name: String?
        /// The type of provisioning artifact.    CLOUD_FORMATION_TEMPLATE - AWS CloudFormation template    MARKETPLACE_AMI - AWS Marketplace AMI    MARKETPLACE_CAR - AWS Marketplace Clusters and AWS Resources
        public let type: ProvisioningArtifactType?

        public init(active: Bool? = nil, createdTime: Date? = nil, description: String? = nil, guidance: ProvisioningArtifactGuidance? = nil, id: String? = nil, name: String? = nil, type: ProvisioningArtifactType? = nil) {
            self.active = active
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case active = "Active"
            case createdTime = "CreatedTime"
            case description = "Description"
            case guidance = "Guidance"
            case id = "Id"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct ProvisioningArtifactOutput: AWSDecodableShape {
        /// Description of the provisioning artifact output key.
        public let description: String?
        /// The provisioning artifact output key.
        public let key: String?

        public init(description: String? = nil, key: String? = nil) {
            self.description = description
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case key = "Key"
        }
    }

    public struct ProvisioningArtifactParameter: AWSDecodableShape {
        /// The default value.
        public let defaultValue: String?
        /// The description of the parameter.
        public let description: String?
        /// If this value is true, the value for this parameter is obfuscated from view when the parameter is retrieved. This parameter is used to hide sensitive information.
        public let isNoEcho: Bool?
        /// Constraints that the administrator has put on a parameter.
        public let parameterConstraints: ParameterConstraints?
        /// The parameter key.
        public let parameterKey: String?
        /// The parameter type.
        public let parameterType: String?

        public init(defaultValue: String? = nil, description: String? = nil, isNoEcho: Bool? = nil, parameterConstraints: ParameterConstraints? = nil, parameterKey: String? = nil, parameterType: String? = nil) {
            self.defaultValue = defaultValue
            self.description = description
            self.isNoEcho = isNoEcho
            self.parameterConstraints = parameterConstraints
            self.parameterKey = parameterKey
            self.parameterType = parameterType
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case description = "Description"
            case isNoEcho = "IsNoEcho"
            case parameterConstraints = "ParameterConstraints"
            case parameterKey = "ParameterKey"
            case parameterType = "ParameterType"
        }
    }

    public struct ProvisioningArtifactPreferences: AWSDecodableShape {
        /// One or more AWS accounts where stack instances are deployed from the stack set. These accounts can be scoped in ProvisioningPreferences$StackSetAccounts and UpdateProvisioningPreferences$StackSetAccounts. Applicable only to a CFN_STACKSET provisioned product type.
        public let stackSetAccounts: [String]?
        /// One or more AWS Regions where stack instances are deployed from the stack set. These regions can be scoped in ProvisioningPreferences$StackSetRegions and UpdateProvisioningPreferences$StackSetRegions. Applicable only to a CFN_STACKSET provisioned product type.
        public let stackSetRegions: [String]?

        public init(stackSetAccounts: [String]? = nil, stackSetRegions: [String]? = nil) {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetRegions = stackSetRegions
        }

        private enum CodingKeys: String, CodingKey {
            case stackSetAccounts = "StackSetAccounts"
            case stackSetRegions = "StackSetRegions"
        }
    }

    public struct ProvisioningArtifactProperties: AWSEncodableShape {
        /// The description of the provisioning artifact, including how it differs from the previous provisioning artifact.
        public let description: String?
        /// If set to true, AWS Service Catalog stops validating the specified provisioning artifact even if it is invalid.
        public let disableTemplateValidation: Bool?
        /// Specify the template source with one of the following options, but not both. Keys accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ] The URL of the CloudFormation template in Amazon S3. Specify the URL in JSON format as follows:  "LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."   ImportFromPhysicalId: The physical id of the resource that contains the template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON format as follows: ImportFromPhysicalId: “arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]
        public let info: [String: String]
        /// The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.
        public let name: String?
        /// The type of provisioning artifact.    CLOUD_FORMATION_TEMPLATE - AWS CloudFormation template    MARKETPLACE_AMI - AWS Marketplace AMI    MARKETPLACE_CAR - AWS Marketplace Clusters and AWS Resources
        public let type: ProvisioningArtifactType?

        public init(description: String? = nil, disableTemplateValidation: Bool? = nil, info: [String: String], name: String? = nil, type: ProvisioningArtifactType? = nil) {
            self.description = description
            self.disableTemplateValidation = disableTemplateValidation
            self.info = info
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 8192)
            try self.validate(self.name, name: "name", parent: name, max: 8192)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case disableTemplateValidation = "DisableTemplateValidation"
            case info = "Info"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct ProvisioningArtifactSummary: AWSDecodableShape {
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The description of the provisioning artifact.
        public let description: String?
        /// The identifier of the provisioning artifact.
        public let id: String?
        /// The name of the provisioning artifact.
        public let name: String?
        /// The metadata for the provisioning artifact. This is used with AWS Marketplace products.
        public let provisioningArtifactMetadata: [String: String]?

        public init(createdTime: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil, provisioningArtifactMetadata: [String: String]? = nil) {
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
            self.provisioningArtifactMetadata = provisioningArtifactMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case provisioningArtifactMetadata = "ProvisioningArtifactMetadata"
        }
    }

    public struct ProvisioningArtifactView: AWSDecodableShape {
        /// Summary information about a product view.
        public let productViewSummary: ProductViewSummary?
        /// Information about a provisioning artifact. A provisioning artifact is also known as a product version.
        public let provisioningArtifact: ProvisioningArtifact?

        public init(productViewSummary: ProductViewSummary? = nil, provisioningArtifact: ProvisioningArtifact? = nil) {
            self.productViewSummary = productViewSummary
            self.provisioningArtifact = provisioningArtifact
        }

        private enum CodingKeys: String, CodingKey {
            case productViewSummary = "ProductViewSummary"
            case provisioningArtifact = "ProvisioningArtifact"
        }
    }

    public struct ProvisioningParameter: AWSEncodableShape {
        /// The parameter key.
        public let key: String?
        /// The parameter value.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ProvisioningPreferences: AWSEncodableShape {
        /// One or more AWS accounts where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified accounts should be within the list of accounts from the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all acounts from the STACKSET constraint.
        public let stackSetAccounts: [String]?
        /// The number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both. The default value is 0 if no value is specified.
        public let stackSetFailureToleranceCount: Int?
        /// The percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public let stackSetFailureTolerancePercentage: Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public let stackSetMaxConcurrencyCount: Int?
        /// The maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public let stackSetMaxConcurrencyPercentage: Int?
        /// One or more AWS Regions where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified regions should be within the list of regions from the STACKSET constraint. To get the list of regions in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all regions from the STACKSET constraint.
        public let stackSetRegions: [String]?

        public init(stackSetAccounts: [String]? = nil, stackSetFailureToleranceCount: Int? = nil, stackSetFailureTolerancePercentage: Int? = nil, stackSetMaxConcurrencyCount: Int? = nil, stackSetMaxConcurrencyPercentage: Int? = nil, stackSetRegions: [String]? = nil) {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetRegions = stackSetRegions
        }

        public func validate(name: String) throws {
            try self.stackSetAccounts?.forEach {
                try validate($0, name: "stackSetAccounts[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.stackSetFailureToleranceCount, name: "stackSetFailureToleranceCount", parent: name, min: 0)
            try self.validate(self.stackSetFailureTolerancePercentage, name: "stackSetFailureTolerancePercentage", parent: name, max: 100)
            try self.validate(self.stackSetFailureTolerancePercentage, name: "stackSetFailureTolerancePercentage", parent: name, min: 0)
            try self.validate(self.stackSetMaxConcurrencyCount, name: "stackSetMaxConcurrencyCount", parent: name, min: 1)
            try self.validate(self.stackSetMaxConcurrencyPercentage, name: "stackSetMaxConcurrencyPercentage", parent: name, max: 100)
            try self.validate(self.stackSetMaxConcurrencyPercentage, name: "stackSetMaxConcurrencyPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stackSetAccounts = "StackSetAccounts"
            case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
            case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
            case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
            case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
            case stackSetRegions = "StackSetRegions"
        }
    }

    public struct RecordDetail: AWSDecodableShape {
        /// The UTC time stamp of the creation time.
        public let createdTime: Date?
        /// The ARN of the launch role associated with the provisioned product.
        public let launchRoleArn: String?
        /// The path identifier.
        public let pathId: String?
        /// The product identifier.
        public let productId: String?
        /// The identifier of the provisioned product.
        public let provisionedProductId: String?
        /// The user-friendly name of the provisioned product.
        public let provisionedProductName: String?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public let provisionedProductType: String?
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// The errors that occurred.
        public let recordErrors: [RecordError]?
        /// The identifier of the record.
        public let recordId: String?
        /// One or more tags.
        public let recordTags: [RecordTag]?
        /// The record type.    PROVISION_PRODUCT     UPDATE_PROVISIONED_PRODUCT     TERMINATE_PROVISIONED_PRODUCT
        public let recordType: String?
        /// The status of the provisioned product.    CREATED - The request was created but the operation has not started.    IN_PROGRESS - The requested operation is in progress.    IN_PROGRESS_IN_ERROR - The provisioned product is under change but the requested operation failed and some remediation is occurring. For example, a rollback.    SUCCEEDED - The requested operation has successfully completed.    FAILED - The requested operation has unsuccessfully completed. Investigate using the error messages returned.
        public let status: RecordStatus?
        /// The time when the record was last updated.
        public let updatedTime: Date?

        public init(createdTime: Date? = nil, launchRoleArn: String? = nil, pathId: String? = nil, productId: String? = nil, provisionedProductId: String? = nil, provisionedProductName: String? = nil, provisionedProductType: String? = nil, provisioningArtifactId: String? = nil, recordErrors: [RecordError]? = nil, recordId: String? = nil, recordTags: [RecordTag]? = nil, recordType: String? = nil, status: RecordStatus? = nil, updatedTime: Date? = nil) {
            self.createdTime = createdTime
            self.launchRoleArn = launchRoleArn
            self.pathId = pathId
            self.productId = productId
            self.provisionedProductId = provisionedProductId
            self.provisionedProductName = provisionedProductName
            self.provisionedProductType = provisionedProductType
            self.provisioningArtifactId = provisioningArtifactId
            self.recordErrors = recordErrors
            self.recordId = recordId
            self.recordTags = recordTags
            self.recordType = recordType
            self.status = status
            self.updatedTime = updatedTime
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case launchRoleArn = "LaunchRoleArn"
            case pathId = "PathId"
            case productId = "ProductId"
            case provisionedProductId = "ProvisionedProductId"
            case provisionedProductName = "ProvisionedProductName"
            case provisionedProductType = "ProvisionedProductType"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case recordErrors = "RecordErrors"
            case recordId = "RecordId"
            case recordTags = "RecordTags"
            case recordType = "RecordType"
            case status = "Status"
            case updatedTime = "UpdatedTime"
        }
    }

    public struct RecordError: AWSDecodableShape {
        /// The numeric value of the error.
        public let code: String?
        /// The description of the error.
        public let description: String?

        public init(code: String? = nil, description: String? = nil) {
            self.code = code
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case description = "Description"
        }
    }

    public struct RecordOutput: AWSDecodableShape {
        /// The description of the output.
        public let description: String?
        /// The output key.
        public let outputKey: String?
        /// The output value.
        public let outputValue: String?

        public init(description: String? = nil, outputKey: String? = nil, outputValue: String? = nil) {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case outputKey = "OutputKey"
            case outputValue = "OutputValue"
        }
    }

    public struct RecordTag: AWSDecodableShape {
        /// The key for this tag.
        public let key: String?
        /// The value for this tag.
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct RejectPortfolioShareInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The portfolio identifier.
        public let portfolioId: String
        /// The type of shared portfolios to reject. The default is to reject imported portfolios.    AWS_ORGANIZATIONS - Reject portfolios shared by the management account of your organization.    IMPORTED - Reject imported portfolios.    AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)   For example, aws servicecatalog reject-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
        public let portfolioShareType: PortfolioShareType?

        public init(acceptLanguage: String? = nil, portfolioId: String, portfolioShareType: PortfolioShareType? = nil) {
            self.acceptLanguage = acceptLanguage
            self.portfolioId = portfolioId
            self.portfolioShareType = portfolioShareType
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case portfolioId = "PortfolioId"
            case portfolioShareType = "PortfolioShareType"
        }
    }

    public struct RejectPortfolioShareOutput: AWSDecodableShape {
        public init() {}
    }

    public struct ResourceChange: AWSDecodableShape {
        /// The change action.
        public let action: ChangeAction?
        /// Information about the resource changes.
        public let details: [ResourceChangeDetail]?
        /// The ID of the resource, as defined in the CloudFormation template.
        public let logicalResourceId: String?
        /// The ID of the resource, if it was already created.
        public let physicalResourceId: String?
        /// If the change type is Modify, indicates whether the existing resource is deleted and replaced with a new one.
        public let replacement: Replacement?
        /// The type of resource.
        public let resourceType: String?
        /// The change scope.
        public let scope: [ResourceAttribute]?

        public init(action: ChangeAction? = nil, details: [ResourceChangeDetail]? = nil, logicalResourceId: String? = nil, physicalResourceId: String? = nil, replacement: Replacement? = nil, resourceType: String? = nil, scope: [ResourceAttribute]? = nil) {
            self.action = action
            self.details = details
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.replacement = replacement
            self.resourceType = resourceType
            self.scope = scope
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case details = "Details"
            case logicalResourceId = "LogicalResourceId"
            case physicalResourceId = "PhysicalResourceId"
            case replacement = "Replacement"
            case resourceType = "ResourceType"
            case scope = "Scope"
        }
    }

    public struct ResourceChangeDetail: AWSDecodableShape {
        /// The ID of the entity that caused the change.
        public let causingEntity: String?
        /// For static evaluations, the value of the resource attribute will change and the new value is known. For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.
        public let evaluation: EvaluationType?
        /// Information about the resource attribute to be modified.
        public let target: ResourceTargetDefinition?

        public init(causingEntity: String? = nil, evaluation: EvaluationType? = nil, target: ResourceTargetDefinition? = nil) {
            self.causingEntity = causingEntity
            self.evaluation = evaluation
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case causingEntity = "CausingEntity"
            case evaluation = "Evaluation"
            case target = "Target"
        }
    }

    public struct ResourceDetail: AWSDecodableShape {
        /// The ARN of the resource.
        public let arn: String?
        /// The creation time of the resource.
        public let createdTime: Date?
        /// The description of the resource.
        public let description: String?
        /// The identifier of the resource.
        public let id: String?
        /// The name of the resource.
        public let name: String?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "ARN"
            case createdTime = "CreatedTime"
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ResourceTargetDefinition: AWSDecodableShape {
        /// The attribute to be changed.
        public let attribute: ResourceAttribute?
        /// If the attribute is Properties, the value is the name of the property. Otherwise, the value is null.
        public let name: String?
        /// If the attribute is Properties, indicates whether a change to this property causes the resource to be re-created.
        public let requiresRecreation: RequiresRecreation?

        public init(attribute: ResourceAttribute? = nil, name: String? = nil, requiresRecreation: RequiresRecreation? = nil) {
            self.attribute = attribute
            self.name = name
            self.requiresRecreation = requiresRecreation
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
            case name = "Name"
            case requiresRecreation = "RequiresRecreation"
        }
    }

    public struct ScanProvisionedProductsInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The access level to use to obtain results. The default is User.
        public let accessLevelFilter: AccessLevelFilter?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?

        public init(acceptLanguage: String? = nil, accessLevelFilter: AccessLevelFilter? = nil, pageSize: Int? = nil, pageToken: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.accessLevelFilter = accessLevelFilter
            self.pageSize = pageSize
            self.pageToken = pageToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case accessLevelFilter = "AccessLevelFilter"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
        }
    }

    public struct ScanProvisionedProductsOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the provisioned products.
        public let provisionedProducts: [ProvisionedProductDetail]?

        public init(nextPageToken: String? = nil, provisionedProducts: [ProvisionedProductDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.provisionedProducts = provisionedProducts
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case provisionedProducts = "ProvisionedProducts"
        }
    }

    public struct SearchProductsAsAdminInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The search filters. If no search filters are specified, the output includes all products to which the administrator has access.
        public let filters: [ProductViewFilterBy: [String]]?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The portfolio identifier.
        public let portfolioId: String?
        /// Access level of the source of the product.
        public let productSource: ProductSource?
        /// The sort field. If no value is specified, the results are not sorted.
        public let sortBy: ProductViewSortBy?
        /// The sort order. If no value is specified, the results are not sorted.
        public let sortOrder: SortOrder?

        public init(acceptLanguage: String? = nil, filters: [ProductViewFilterBy: [String]]? = nil, pageSize: Int? = nil, pageToken: String? = nil, portfolioId: String? = nil, productSource: ProductSource? = nil, sortBy: ProductViewSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.acceptLanguage = acceptLanguage
            self.filters = filters
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.portfolioId = portfolioId
            self.productSource = productSource
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 20)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case filters = "Filters"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case portfolioId = "PortfolioId"
            case productSource = "ProductSource"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct SearchProductsAsAdminOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the product views.
        public let productViewDetails: [ProductViewDetail]?

        public init(nextPageToken: String? = nil, productViewDetails: [ProductViewDetail]? = nil) {
            self.nextPageToken = nextPageToken
            self.productViewDetails = productViewDetails
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case productViewDetails = "ProductViewDetails"
        }
    }

    public struct SearchProductsInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The search filters. If no search filters are specified, the output includes all products to which the caller has access.
        public let filters: [ProductViewFilterBy: [String]]?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The sort field. If no value is specified, the results are not sorted.
        public let sortBy: ProductViewSortBy?
        /// The sort order. If no value is specified, the results are not sorted.
        public let sortOrder: SortOrder?

        public init(acceptLanguage: String? = nil, filters: [ProductViewFilterBy: [String]]? = nil, pageSize: Int? = nil, pageToken: String? = nil, sortBy: ProductViewSortBy? = nil, sortOrder: SortOrder? = nil) {
            self.acceptLanguage = acceptLanguage
            self.filters = filters
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case filters = "Filters"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct SearchProductsOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// The product view aggregations.
        public let productViewAggregations: [String: [ProductViewAggregationValue]]?
        /// Information about the product views.
        public let productViewSummaries: [ProductViewSummary]?

        public init(nextPageToken: String? = nil, productViewAggregations: [String: [ProductViewAggregationValue]]? = nil, productViewSummaries: [ProductViewSummary]? = nil) {
            self.nextPageToken = nextPageToken
            self.productViewAggregations = productViewAggregations
            self.productViewSummaries = productViewSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case productViewAggregations = "ProductViewAggregations"
            case productViewSummaries = "ProductViewSummaries"
        }
    }

    public struct SearchProvisionedProductsInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The access level to use to obtain results. The default is User.
        public let accessLevelFilter: AccessLevelFilter?
        /// The search filters. When the key is SearchQuery, the searchable fields are arn, createdTime, id, lastRecordId, idempotencyToken, name, physicalId, productId, provisioningArtifact, type, status, tags, userArn, userArnSession, lastProvisioningRecordId, lastSuccessfulProvisioningRecordId, productName, and provisioningArtifactName. Example: "SearchQuery":["status:AVAILABLE"]
        public let filters: [ProvisionedProductViewFilterBy: [String]]?
        /// The maximum number of items to return with this call.
        public let pageSize: Int?
        /// The page token for the next set of results. To retrieve the first set of results, use null.
        public let pageToken: String?
        /// The sort field. If no value is specified, the results are not sorted. The valid values are arn, id, name, and lastRecordId.
        public let sortBy: String?
        /// The sort order. If no value is specified, the results are not sorted.
        public let sortOrder: SortOrder?

        public init(acceptLanguage: String? = nil, accessLevelFilter: AccessLevelFilter? = nil, filters: [ProvisionedProductViewFilterBy: [String]]? = nil, pageSize: Int? = nil, pageToken: String? = nil, sortBy: String? = nil, sortOrder: SortOrder? = nil) {
            self.acceptLanguage = acceptLanguage
            self.accessLevelFilter = accessLevelFilter
            self.filters = filters
            self.pageSize = pageSize
            self.pageToken = pageToken
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, max: 100)
            try self.validate(self.pageSize, name: "pageSize", parent: name, min: 0)
            try self.validate(self.pageToken, name: "pageToken", parent: name, max: 2024)
            try self.validate(self.pageToken, name: "pageToken", parent: name, pattern: "[\\u0009\\u000a\\u000d\\u0020-\\uD7FF\\uE000-\\uFFFD]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case accessLevelFilter = "AccessLevelFilter"
            case filters = "Filters"
            case pageSize = "PageSize"
            case pageToken = "PageToken"
            case sortBy = "SortBy"
            case sortOrder = "SortOrder"
        }
    }

    public struct SearchProvisionedProductsOutput: AWSDecodableShape {
        /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
        public let nextPageToken: String?
        /// Information about the provisioned products.
        public let provisionedProducts: [ProvisionedProductAttribute]?
        /// The number of provisioned products found.
        public let totalResultsCount: Int?

        public init(nextPageToken: String? = nil, provisionedProducts: [ProvisionedProductAttribute]? = nil, totalResultsCount: Int? = nil) {
            self.nextPageToken = nextPageToken
            self.provisionedProducts = provisionedProducts
            self.totalResultsCount = totalResultsCount
        }

        private enum CodingKeys: String, CodingKey {
            case nextPageToken = "NextPageToken"
            case provisionedProducts = "ProvisionedProducts"
            case totalResultsCount = "TotalResultsCount"
        }
    }

    public struct ServiceActionAssociation: AWSEncodableShape {
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public let productId: String
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public let provisioningArtifactId: String
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public let serviceActionId: String

        public init(productId: String, provisioningArtifactId: String, serviceActionId: String) {
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }

        public func validate(name: String) throws {
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, max: 100)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, min: 1)
            try self.validate(self.serviceActionId, name: "serviceActionId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case serviceActionId = "ServiceActionId"
        }
    }

    public struct ServiceActionDetail: AWSDecodableShape {
        /// A map that defines the self-service action.
        public let definition: [ServiceActionDefinitionKey: String]?
        /// Summary information about the self-service action.
        public let serviceActionSummary: ServiceActionSummary?

        public init(definition: [ServiceActionDefinitionKey: String]? = nil, serviceActionSummary: ServiceActionSummary? = nil) {
            self.definition = definition
            self.serviceActionSummary = serviceActionSummary
        }

        private enum CodingKeys: String, CodingKey {
            case definition = "Definition"
            case serviceActionSummary = "ServiceActionSummary"
        }
    }

    public struct ServiceActionSummary: AWSDecodableShape {
        /// The self-service action definition type. For example, SSM_AUTOMATION.
        public let definitionType: ServiceActionDefinitionType?
        /// The self-service action description.
        public let description: String?
        /// The self-service action identifier.
        public let id: String?
        /// The self-service action name.
        public let name: String?

        public init(definitionType: ServiceActionDefinitionType? = nil, description: String? = nil, id: String? = nil, name: String? = nil) {
            self.definitionType = definitionType
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case definitionType = "DefinitionType"
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ShareDetails: AWSDecodableShape {
        /// List of errors.
        public let shareErrors: [ShareError]?
        /// List of accounts for whom the operation succeeded.
        public let successfulShares: [String]?

        public init(shareErrors: [ShareError]? = nil, successfulShares: [String]? = nil) {
            self.shareErrors = shareErrors
            self.successfulShares = successfulShares
        }

        private enum CodingKeys: String, CodingKey {
            case shareErrors = "ShareErrors"
            case successfulShares = "SuccessfulShares"
        }
    }

    public struct ShareError: AWSDecodableShape {
        /// List of accounts impacted by the error.
        public let accounts: [String]?
        /// Error type that happened when processing the operation.
        public let error: String?
        /// Information about the error.
        public let message: String?

        public init(accounts: [String]? = nil, error: String? = nil, message: String? = nil) {
            self.accounts = accounts
            self.error = error
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "Accounts"
            case error = "Error"
            case message = "Message"
        }
    }

    public struct StackInstance: AWSDecodableShape {
        /// The name of the AWS account that the stack instance is associated with.
        public let account: String?
        /// The name of the AWS region that the stack instance is associated with.
        public let region: String?
        /// The status of the stack instance, in terms of its synchronization with its associated stack set.     INOPERABLE: A DeleteStackInstances operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further UpdateStackSet operations. You might need to perform a DeleteStackInstances operation, with RetainStacks set to true, to delete the stack instance, and then delete the stack manually.     OUTDATED: The stack isn't currently up to date with the stack set because either the associated stack failed during a CreateStackSet or UpdateStackSet operation, or the stack was part of a CreateStackSet or UpdateStackSet operation that failed or was stopped before the stack was created or updated.    CURRENT: The stack is currently up to date with the stack set.
        public let stackInstanceStatus: StackInstanceStatus?

        public init(account: String? = nil, region: String? = nil, stackInstanceStatus: StackInstanceStatus? = nil) {
            self.account = account
            self.region = region
            self.stackInstanceStatus = stackInstanceStatus
        }

        private enum CodingKeys: String, CodingKey {
            case account = "Account"
            case region = "Region"
            case stackInstanceStatus = "StackInstanceStatus"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The tag key.
        public let key: String
        /// The value for this key.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagOptionDetail: AWSDecodableShape {
        /// The TagOption active state.
        public let active: Bool?
        /// The TagOption identifier.
        public let id: String?
        /// The TagOption key.
        public let key: String?
        /// The AWS account Id of the owner account that created the TagOption.
        public let owner: String?
        /// The TagOption value.
        public let value: String?

        public init(active: Bool? = nil, id: String? = nil, key: String? = nil, owner: String? = nil, value: String? = nil) {
            self.active = active
            self.id = id
            self.key = key
            self.owner = owner
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case active = "Active"
            case id = "Id"
            case key = "Key"
            case owner = "Owner"
            case value = "Value"
        }
    }

    public struct TagOptionSummary: AWSDecodableShape {
        /// The TagOption key.
        public let key: String?
        /// The TagOption value.
        public let values: [String]?

        public init(key: String? = nil, values: [String]? = nil) {
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case values = "Values"
        }
    }

    public struct TerminateProvisionedProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// If set to true, AWS Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.
        public let ignoreErrors: Bool?
        /// The identifier of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
        public let provisionedProductId: String?
        /// The name of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
        public let provisionedProductName: String?
        /// When this boolean parameter is set to true, the TerminateProvisionedProduct API deletes the Service Catalog provisioned product. However, it does not remove the CloudFormation stack, stack set, or the underlying resources of the deleted provisioned product. The default value is false.
        public let retainPhysicalResources: Bool?
        /// An idempotency token that uniquely identifies the termination request. This token is only valid during the termination process. After the provisioned product is terminated, subsequent requests to terminate the same provisioned product always return ResourceNotFound.
        public let terminateToken: String

        public init(acceptLanguage: String? = nil, ignoreErrors: Bool? = nil, provisionedProductId: String? = nil, provisionedProductName: String? = nil, retainPhysicalResources: Bool? = nil, terminateToken: String = TerminateProvisionedProductInput.idempotencyToken()) {
            self.acceptLanguage = acceptLanguage
            self.ignoreErrors = ignoreErrors
            self.provisionedProductId = provisionedProductId
            self.provisionedProductName = provisionedProductName
            self.retainPhysicalResources = retainPhysicalResources
            self.terminateToken = terminateToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, min: 1)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, max: 1224)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, min: 1)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9._-]{0,127}|arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.terminateToken, name: "terminateToken", parent: name, max: 128)
            try self.validate(self.terminateToken, name: "terminateToken", parent: name, min: 1)
            try self.validate(self.terminateToken, name: "terminateToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case ignoreErrors = "IgnoreErrors"
            case provisionedProductId = "ProvisionedProductId"
            case provisionedProductName = "ProvisionedProductName"
            case retainPhysicalResources = "RetainPhysicalResources"
            case terminateToken = "TerminateToken"
        }
    }

    public struct TerminateProvisionedProductOutput: AWSDecodableShape {
        /// Information about the result of this request.
        public let recordDetail: RecordDetail?

        public init(recordDetail: RecordDetail? = nil) {
            self.recordDetail = recordDetail
        }

        private enum CodingKeys: String, CodingKey {
            case recordDetail = "RecordDetail"
        }
    }

    public struct UpdateConstraintInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The updated description of the constraint.
        public let description: String?
        /// The identifier of the constraint.
        public let id: String
        /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows:  LAUNCH  You are required to specify either the RoleArn or the LocalRoleName but can't use both. Specify the RoleArn property as follows:  {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"}  Specify the LocalRoleName property as follows:  {"LocalRoleName": "SCBasicLaunchRole"}  If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account.  The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.  You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one LAUNCH constraint on a product and portfolio.  NOTIFICATION  Specify the NotificationArns property as follows:  {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]}   RESOURCE_UPDATE  Specify the TagUpdatesOnProvisionedProduct property as follows:  {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}}  The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED.  STACKSET  Specify the Parameters property as follows:  {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}}  You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one STACKSET constraint on a product and portfolio. Products with a STACKSET constraint will launch an AWS CloudFormation stack set.  TEMPLATE  Specify the Rules property. For more information, see Template Constraint Rules.
        public let parameters: String?

        public init(acceptLanguage: String? = nil, description: String? = nil, id: String, parameters: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.description = description
            self.id = id
            self.parameters = parameters
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 2000)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case description = "Description"
            case id = "Id"
            case parameters = "Parameters"
        }
    }

    public struct UpdateConstraintOutput: AWSDecodableShape {
        /// Information about the constraint.
        public let constraintDetail: ConstraintDetail?
        /// The constraint parameters.
        public let constraintParameters: String?
        /// The status of the current request.
        public let status: Status?

        public init(constraintDetail: ConstraintDetail? = nil, constraintParameters: String? = nil, status: Status? = nil) {
            self.constraintDetail = constraintDetail
            self.constraintParameters = constraintParameters
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case constraintDetail = "ConstraintDetail"
            case constraintParameters = "ConstraintParameters"
            case status = "Status"
        }
    }

    public struct UpdatePortfolioInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The tags to add.
        public let addTags: [Tag]?
        /// The updated description of the portfolio.
        public let description: String?
        /// The name to use for display purposes.
        public let displayName: String?
        /// The portfolio identifier.
        public let id: String
        /// The updated name of the portfolio provider.
        public let providerName: String?
        /// The tags to remove.
        public let removeTags: [String]?

        public init(acceptLanguage: String? = nil, addTags: [Tag]? = nil, description: String? = nil, displayName: String? = nil, id: String, providerName: String? = nil, removeTags: [String]? = nil) {
            self.acceptLanguage = acceptLanguage
            self.addTags = addTags
            self.description = description
            self.displayName = displayName
            self.id = id
            self.providerName = providerName
            self.removeTags = removeTags
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.addTags?.forEach {
                try $0.validate(name: "\(name).addTags[]")
            }
            try self.validate(self.addTags, name: "addTags", parent: name, max: 20)
            try self.validate(self.description, name: "description", parent: name, max: 2000)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.providerName, name: "providerName", parent: name, max: 50)
            try self.validate(self.providerName, name: "providerName", parent: name, min: 1)
            try self.removeTags?.forEach {
                try validate($0, name: "removeTags[]", parent: name, max: 128)
                try validate($0, name: "removeTags[]", parent: name, min: 1)
                try validate($0, name: "removeTags[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case addTags = "AddTags"
            case description = "Description"
            case displayName = "DisplayName"
            case id = "Id"
            case providerName = "ProviderName"
            case removeTags = "RemoveTags"
        }
    }

    public struct UpdatePortfolioOutput: AWSDecodableShape {
        /// Information about the portfolio.
        public let portfolioDetail: PortfolioDetail?
        /// Information about the tags associated with the portfolio.
        public let tags: [Tag]?

        public init(portfolioDetail: PortfolioDetail? = nil, tags: [Tag]? = nil) {
            self.portfolioDetail = portfolioDetail
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case portfolioDetail = "PortfolioDetail"
            case tags = "Tags"
        }
    }

    public struct UpdatePortfolioShareInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The AWS Account Id of the recipient account. This field is required when updating an external account to account type share.
        public let accountId: String?
        public let organizationNode: OrganizationNode?
        /// The unique identifier of the portfolio for which the share will be updated.
        public let portfolioId: String
        /// A flag to enable or disable TagOptions sharing for the portfolio share. If this field is not provided, the current state of TagOptions sharing on the portfolio share will not be modified.
        public let shareTagOptions: Bool?

        public init(acceptLanguage: String? = nil, accountId: String? = nil, organizationNode: OrganizationNode? = nil, portfolioId: String, shareTagOptions: Bool? = nil) {
            self.acceptLanguage = acceptLanguage
            self.accountId = accountId
            self.organizationNode = organizationNode
            self.portfolioId = portfolioId
            self.shareTagOptions = shareTagOptions
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^[0-9]{12}$")
            try self.organizationNode?.validate(name: "\(name).organizationNode")
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, max: 100)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, min: 1)
            try self.validate(self.portfolioId, name: "portfolioId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case accountId = "AccountId"
            case organizationNode = "OrganizationNode"
            case portfolioId = "PortfolioId"
            case shareTagOptions = "ShareTagOptions"
        }
    }

    public struct UpdatePortfolioShareOutput: AWSDecodableShape {
        /// The token that tracks the status of the UpdatePortfolioShare operation for external account to account or organizational type sharing.
        public let portfolioShareToken: String?
        /// The status of UpdatePortfolioShare operation. You can also obtain the operation status using DescribePortfolioShareStatus API.
        public let status: ShareStatus?

        public init(portfolioShareToken: String? = nil, status: ShareStatus? = nil) {
            self.portfolioShareToken = portfolioShareToken
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case portfolioShareToken = "PortfolioShareToken"
            case status = "Status"
        }
    }

    public struct UpdateProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The tags to add to the product.
        public let addTags: [Tag]?
        /// The updated description of the product.
        public let description: String?
        /// The updated distributor of the product.
        public let distributor: String?
        /// The product identifier.
        public let id: String
        /// The updated product name.
        public let name: String?
        /// The updated owner of the product.
        public let owner: String?
        /// The tags to remove from the product.
        public let removeTags: [String]?
        /// The updated support description for the product.
        public let supportDescription: String?
        /// The updated support email for the product.
        public let supportEmail: String?
        /// The updated support URL for the product.
        public let supportUrl: String?

        public init(acceptLanguage: String? = nil, addTags: [Tag]? = nil, description: String? = nil, distributor: String? = nil, id: String, name: String? = nil, owner: String? = nil, removeTags: [String]? = nil, supportDescription: String? = nil, supportEmail: String? = nil, supportUrl: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.addTags = addTags
            self.description = description
            self.distributor = distributor
            self.id = id
            self.name = name
            self.owner = owner
            self.removeTags = removeTags
            self.supportDescription = supportDescription
            self.supportEmail = supportEmail
            self.supportUrl = supportUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.addTags?.forEach {
                try $0.validate(name: "\(name).addTags[]")
            }
            try self.validate(self.addTags, name: "addTags", parent: name, max: 20)
            try self.validate(self.description, name: "description", parent: name, max: 8191)
            try self.validate(self.distributor, name: "distributor", parent: name, max: 8191)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.name, name: "name", parent: name, max: 8191)
            try self.validate(self.owner, name: "owner", parent: name, max: 8191)
            try self.removeTags?.forEach {
                try validate($0, name: "removeTags[]", parent: name, max: 128)
                try validate($0, name: "removeTags[]", parent: name, min: 1)
                try validate($0, name: "removeTags[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.supportDescription, name: "supportDescription", parent: name, max: 8191)
            try self.validate(self.supportEmail, name: "supportEmail", parent: name, max: 254)
            try self.validate(self.supportUrl, name: "supportUrl", parent: name, max: 2083)
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case addTags = "AddTags"
            case description = "Description"
            case distributor = "Distributor"
            case id = "Id"
            case name = "Name"
            case owner = "Owner"
            case removeTags = "RemoveTags"
            case supportDescription = "SupportDescription"
            case supportEmail = "SupportEmail"
            case supportUrl = "SupportUrl"
        }
    }

    public struct UpdateProductOutput: AWSDecodableShape {
        /// Information about the product view.
        public let productViewDetail: ProductViewDetail?
        /// Information about the tags associated with the product.
        public let tags: [Tag]?

        public init(productViewDetail: ProductViewDetail? = nil, tags: [Tag]? = nil) {
            self.productViewDetail = productViewDetail
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case productViewDetail = "ProductViewDetail"
            case tags = "Tags"
        }
    }

    public struct UpdateProvisionedProductInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The path identifier. This value is optional if the product has a default path, and required if the product has more than one path. You must provide the name or ID, but not both.
        public let pathId: String?
        /// The name of the path. You must provide the name or ID, but not both.
        public let pathName: String?
        /// The identifier of the product. You must provide the name or ID, but not both.
        public let productId: String?
        /// The name of the product. You must provide the name or ID, but not both.
        public let productName: String?
        /// The identifier of the provisioned product. You must provide the name or ID, but not both.
        public let provisionedProductId: String?
        /// The name of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
        public let provisionedProductName: String?
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String?
        /// The name of the provisioning artifact. You must provide the name or ID, but not both.
        public let provisioningArtifactName: String?
        /// The new parameters.
        public let provisioningParameters: [UpdateProvisioningParameter]?
        /// An object that contains information about the provisioning preferences for a stack set.
        public let provisioningPreferences: UpdateProvisioningPreferences?
        /// One or more tags. Requires the product to have RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
        public let tags: [Tag]?
        /// The idempotency token that uniquely identifies the provisioning update request.
        public let updateToken: String

        public init(acceptLanguage: String? = nil, pathId: String? = nil, pathName: String? = nil, productId: String? = nil, productName: String? = nil, provisionedProductId: String? = nil, provisionedProductName: String? = nil, provisioningArtifactId: String? = nil, provisioningArtifactName: String? = nil, provisioningParameters: [UpdateProvisioningParameter]? = nil, provisioningPreferences: UpdateProvisioningPreferences? = nil, tags: [Tag]? = nil, updateToken: String = UpdateProvisionedProductInput.idempotencyToken()) {
            self.acceptLanguage = acceptLanguage
            self.pathId = pathId
            self.pathName = pathName
            self.productId = productId
            self.productName = productName
            self.provisionedProductId = provisionedProductId
            self.provisionedProductName = provisionedProductName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
            self.provisioningParameters = provisioningParameters
            self.provisioningPreferences = provisioningPreferences
            self.tags = tags
            self.updateToken = updateToken
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.pathId, name: "pathId", parent: name, max: 100)
            try self.validate(self.pathId, name: "pathId", parent: name, min: 1)
            try self.validate(self.pathId, name: "pathId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.pathName, name: "pathName", parent: name, max: 100)
            try self.validate(self.pathName, name: "pathName", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.productName, name: "productName", parent: name, max: 8191)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, min: 1)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, max: 1224)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, min: 1)
            try self.validate(self.provisionedProductName, name: "provisionedProductName", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9._-]{0,127}|arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactName, name: "provisioningArtifactName", parent: name, max: 8192)
            try self.provisioningParameters?.forEach {
                try $0.validate(name: "\(name).provisioningParameters[]")
            }
            try self.provisioningPreferences?.validate(name: "\(name).provisioningPreferences")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.updateToken, name: "updateToken", parent: name, max: 128)
            try self.validate(self.updateToken, name: "updateToken", parent: name, min: 1)
            try self.validate(self.updateToken, name: "updateToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case pathId = "PathId"
            case pathName = "PathName"
            case productId = "ProductId"
            case productName = "ProductName"
            case provisionedProductId = "ProvisionedProductId"
            case provisionedProductName = "ProvisionedProductName"
            case provisioningArtifactId = "ProvisioningArtifactId"
            case provisioningArtifactName = "ProvisioningArtifactName"
            case provisioningParameters = "ProvisioningParameters"
            case provisioningPreferences = "ProvisioningPreferences"
            case tags = "Tags"
            case updateToken = "UpdateToken"
        }
    }

    public struct UpdateProvisionedProductOutput: AWSDecodableShape {
        /// Information about the result of the request.
        public let recordDetail: RecordDetail?

        public init(recordDetail: RecordDetail? = nil) {
            self.recordDetail = recordDetail
        }

        private enum CodingKeys: String, CodingKey {
            case recordDetail = "RecordDetail"
        }
    }

    public struct UpdateProvisionedProductPropertiesInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// The idempotency token that uniquely identifies the provisioning product update request.
        public let idempotencyToken: String
        /// The identifier of the provisioned product.
        public let provisionedProductId: String
        /// A map that contains the provisioned product properties to be updated. The LAUNCH_ROLE key accepts role ARNs. This key allows an administrator to call UpdateProvisionedProductProperties to update the launch role that is associated with a provisioned product. This role is used when an end user calls a provisioning operation such as UpdateProvisionedProduct, TerminateProvisionedProduct, or ExecuteProvisionedProductServiceAction. Only a role ARN is valid. A user ARN is invalid.  The OWNER key accepts user ARNs and role ARNs. The owner is the user that has permission to see, update, terminate, and execute service actions in the provisioned product. The administrator can change the owner of a provisioned product to another IAM user within the same account. Both end user owners and administrators can see ownership history of the provisioned product using the ListRecordHistory API. The new owner can describe all past records for the provisioned product using the DescribeRecord API. The previous owner can no longer use DescribeRecord, but can still see the product's history from when he was an owner using ListRecordHistory. If a provisioned product ownership is assigned to an end user, they can see and perform any action through the API or Service Catalog console such as update, terminate, and execute service actions. If an end user provisions a product and the owner is updated to someone else, they will no longer be able to see or perform any actions through API or the Service Catalog console on that provisioned product.
        public let provisionedProductProperties: [PropertyKey: String]

        public init(acceptLanguage: String? = nil, idempotencyToken: String = UpdateProvisionedProductPropertiesInput.idempotencyToken(), provisionedProductId: String, provisionedProductProperties: [PropertyKey: String]) {
            self.acceptLanguage = acceptLanguage
            self.idempotencyToken = idempotencyToken
            self.provisionedProductId = provisionedProductId
            self.provisionedProductProperties = provisionedProductProperties
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, max: 128)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, min: 1)
            try self.validate(self.idempotencyToken, name: "idempotencyToken", parent: name, pattern: "[a-zA-Z0-9][a-zA-Z0-9_-]*")
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, max: 100)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, min: 1)
            try self.validate(self.provisionedProductId, name: "provisionedProductId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.provisionedProductProperties.forEach {
                try validate($0.value, name: "provisionedProductProperties[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "provisionedProductProperties[\"\($0.key)\"]", parent: name, min: 0)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case idempotencyToken = "IdempotencyToken"
            case provisionedProductId = "ProvisionedProductId"
            case provisionedProductProperties = "ProvisionedProductProperties"
        }
    }

    public struct UpdateProvisionedProductPropertiesOutput: AWSDecodableShape {
        /// The provisioned product identifier.
        public let provisionedProductId: String?
        /// A map that contains the properties updated.
        public let provisionedProductProperties: [PropertyKey: String]?
        /// The identifier of the record.
        public let recordId: String?
        /// The status of the request.
        public let status: RecordStatus?

        public init(provisionedProductId: String? = nil, provisionedProductProperties: [PropertyKey: String]? = nil, recordId: String? = nil, status: RecordStatus? = nil) {
            self.provisionedProductId = provisionedProductId
            self.provisionedProductProperties = provisionedProductProperties
            self.recordId = recordId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case provisionedProductId = "ProvisionedProductId"
            case provisionedProductProperties = "ProvisionedProductProperties"
            case recordId = "RecordId"
            case status = "Status"
        }
    }

    public struct UpdateProvisioningArtifactInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// Indicates whether the product version is active. Inactive provisioning artifacts are invisible to end users. End users cannot launch or update a provisioned product from an inactive provisioning artifact.
        public let active: Bool?
        /// The updated description of the provisioning artifact.
        public let description: String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use. The DEFAULT value indicates that the product version is active. The administrator can set the guidance to DEPRECATED to inform users that the product version is deprecated. Users are able to make updates to a provisioned product of a deprecated version but cannot launch new provisioned products using a deprecated version.
        public let guidance: ProvisioningArtifactGuidance?
        /// The updated name of the provisioning artifact.
        public let name: String?
        /// The product identifier.
        public let productId: String
        /// The identifier of the provisioning artifact.
        public let provisioningArtifactId: String

        public init(acceptLanguage: String? = nil, active: Bool? = nil, description: String? = nil, guidance: ProvisioningArtifactGuidance? = nil, name: String? = nil, productId: String, provisioningArtifactId: String) {
            self.acceptLanguage = acceptLanguage
            self.active = active
            self.description = description
            self.guidance = guidance
            self.name = name
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 8192)
            try self.validate(self.name, name: "name", parent: name, max: 8192)
            try self.validate(self.productId, name: "productId", parent: name, max: 100)
            try self.validate(self.productId, name: "productId", parent: name, min: 1)
            try self.validate(self.productId, name: "productId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, max: 100)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, min: 1)
            try self.validate(self.provisioningArtifactId, name: "provisioningArtifactId", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case active = "Active"
            case description = "Description"
            case guidance = "Guidance"
            case name = "Name"
            case productId = "ProductId"
            case provisioningArtifactId = "ProvisioningArtifactId"
        }
    }

    public struct UpdateProvisioningArtifactOutput: AWSDecodableShape {
        /// The URL of the CloudFormation template in Amazon S3.
        public let info: [String: String]?
        /// Information about the provisioning artifact.
        public let provisioningArtifactDetail: ProvisioningArtifactDetail?
        /// The status of the current request.
        public let status: Status?

        public init(info: [String: String]? = nil, provisioningArtifactDetail: ProvisioningArtifactDetail? = nil, status: Status? = nil) {
            self.info = info
            self.provisioningArtifactDetail = provisioningArtifactDetail
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case info = "Info"
            case provisioningArtifactDetail = "ProvisioningArtifactDetail"
            case status = "Status"
        }
    }

    public struct UpdateProvisioningParameter: AWSEncodableShape & AWSDecodableShape {
        /// The parameter key.
        public let key: String?
        /// If set to true, Value is ignored and the previous parameter value is kept.
        public let usePreviousValue: Bool?
        /// The parameter value.
        public let value: String?

        public init(key: String? = nil, usePreviousValue: Bool? = nil, value: String? = nil) {
            self.key = key
            self.usePreviousValue = usePreviousValue
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1000)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case usePreviousValue = "UsePreviousValue"
            case value = "Value"
        }
    }

    public struct UpdateProvisioningPreferences: AWSEncodableShape {
        /// One or more AWS accounts that will have access to the provisioned product. Applicable only to a CFN_STACKSET provisioned product type. The AWS accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all accounts from the STACKSET constraint.
        public let stackSetAccounts: [String]?
        /// The number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both. The default value is 0 if no value is specified.
        public let stackSetFailureToleranceCount: Int?
        /// The percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public let stackSetFailureTolerancePercentage: Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public let stackSetMaxConcurrencyCount: Int?
        /// The maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public let stackSetMaxConcurrencyPercentage: Int?
        /// Determines what action AWS Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is UPDATE if nothing is specified. Applicable only to a CFN_STACKSET provisioned product type.  CREATE  Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored.  UPDATE  Updates the stack set represented by the provisioned product and also its stack instances.  DELETE  Deletes a stack instance in the stack set represented by the provisioned product.
        public let stackSetOperationType: StackSetOperationType?
        /// One or more AWS Regions where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified regions should be within the list of regions from the STACKSET constraint. To get the list of regions in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all regions from the STACKSET constraint.
        public let stackSetRegions: [String]?

        public init(stackSetAccounts: [String]? = nil, stackSetFailureToleranceCount: Int? = nil, stackSetFailureTolerancePercentage: Int? = nil, stackSetMaxConcurrencyCount: Int? = nil, stackSetMaxConcurrencyPercentage: Int? = nil, stackSetOperationType: StackSetOperationType? = nil, stackSetRegions: [String]? = nil) {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetOperationType = stackSetOperationType
            self.stackSetRegions = stackSetRegions
        }

        public func validate(name: String) throws {
            try self.stackSetAccounts?.forEach {
                try validate($0, name: "stackSetAccounts[]", parent: name, pattern: "^[0-9]{12}$")
            }
            try self.validate(self.stackSetFailureToleranceCount, name: "stackSetFailureToleranceCount", parent: name, min: 0)
            try self.validate(self.stackSetFailureTolerancePercentage, name: "stackSetFailureTolerancePercentage", parent: name, max: 100)
            try self.validate(self.stackSetFailureTolerancePercentage, name: "stackSetFailureTolerancePercentage", parent: name, min: 0)
            try self.validate(self.stackSetMaxConcurrencyCount, name: "stackSetMaxConcurrencyCount", parent: name, min: 1)
            try self.validate(self.stackSetMaxConcurrencyPercentage, name: "stackSetMaxConcurrencyPercentage", parent: name, max: 100)
            try self.validate(self.stackSetMaxConcurrencyPercentage, name: "stackSetMaxConcurrencyPercentage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stackSetAccounts = "StackSetAccounts"
            case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
            case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
            case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
            case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
            case stackSetOperationType = "StackSetOperationType"
            case stackSetRegions = "StackSetRegions"
        }
    }

    public struct UpdateServiceActionInput: AWSEncodableShape {
        /// The language code.    en - English (default)    jp - Japanese    zh - Chinese
        public let acceptLanguage: String?
        /// A map that defines the self-service action.
        public let definition: [ServiceActionDefinitionKey: String]?
        /// The self-service action description.
        public let description: String?
        /// The self-service action identifier.
        public let id: String
        /// The self-service action name.
        public let name: String?

        public init(acceptLanguage: String? = nil, definition: [ServiceActionDefinitionKey: String]? = nil, description: String? = nil, id: String, name: String? = nil) {
            self.acceptLanguage = acceptLanguage
            self.definition = definition
            self.description = description
            self.id = id
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.acceptLanguage, name: "acceptLanguage", parent: name, max: 100)
            try self.definition?.forEach {
                try validate($0.value, name: "definition[\"\($0.key)\"]", parent: name, max: 1024)
                try validate($0.value, name: "definition[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^[a-zA-Z0-9_\\-]*")
            try self.validate(self.name, name: "name", parent: name, max: 256)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_\\-.]*")
        }

        private enum CodingKeys: String, CodingKey {
            case acceptLanguage = "AcceptLanguage"
            case definition = "Definition"
            case description = "Description"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct UpdateServiceActionOutput: AWSDecodableShape {
        /// Detailed information about the self-service action.
        public let serviceActionDetail: ServiceActionDetail?

        public init(serviceActionDetail: ServiceActionDetail? = nil) {
            self.serviceActionDetail = serviceActionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case serviceActionDetail = "ServiceActionDetail"
        }
    }

    public struct UpdateTagOptionInput: AWSEncodableShape {
        /// The updated active state.
        public let active: Bool?
        /// The TagOption identifier.
        public let id: String
        /// The updated value.
        public let value: String?

        public init(active: Bool? = nil, id: String, value: String? = nil) {
            self.active = active
            self.id = id
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 100)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case active = "Active"
            case id = "Id"
            case value = "Value"
        }
    }

    public struct UpdateTagOptionOutput: AWSDecodableShape {
        /// Information about the TagOption.
        public let tagOptionDetail: TagOptionDetail?

        public init(tagOptionDetail: TagOptionDetail? = nil) {
            self.tagOptionDetail = tagOptionDetail
        }

        private enum CodingKeys: String, CodingKey {
            case tagOptionDetail = "TagOptionDetail"
        }
    }

    public struct UsageInstruction: AWSDecodableShape {
        /// The usage instruction type for the value.
        public let type: String?
        /// The usage instruction value for this type.
        public let value: String?

        public init(type: String? = nil, value: String? = nil) {
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }
}
