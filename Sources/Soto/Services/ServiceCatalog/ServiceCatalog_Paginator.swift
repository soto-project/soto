//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2020 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/soto/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension ServiceCatalog {
    ///  Lists all portfolios for which sharing was accepted by this account.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listAcceptedPortfolioSharesPaginator<Result>(
        _ input: ListAcceptedPortfolioSharesInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListAcceptedPortfolioSharesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listAcceptedPortfolioShares,
            tokenKey: \ListAcceptedPortfolioSharesOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listAcceptedPortfolioSharesPaginator(
        _ input: ListAcceptedPortfolioSharesInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListAcceptedPortfolioSharesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listAcceptedPortfolioShares,
            tokenKey: \ListAcceptedPortfolioSharesOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all the budgets associated to the specified resource.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listBudgetsForResourcePaginator<Result>(
        _ input: ListBudgetsForResourceInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListBudgetsForResourceOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listBudgetsForResource,
            tokenKey: \ListBudgetsForResourceOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listBudgetsForResourcePaginator(
        _ input: ListBudgetsForResourceInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListBudgetsForResourceOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listBudgetsForResource,
            tokenKey: \ListBudgetsForResourceOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the constraints for the specified portfolio and product.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listConstraintsForPortfolioPaginator<Result>(
        _ input: ListConstraintsForPortfolioInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListConstraintsForPortfolioOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listConstraintsForPortfolio,
            tokenKey: \ListConstraintsForPortfolioOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listConstraintsForPortfolioPaginator(
        _ input: ListConstraintsForPortfolioInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListConstraintsForPortfolioOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listConstraintsForPortfolio,
            tokenKey: \ListConstraintsForPortfolioOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the paths to the specified product. A path is how the user has access to a specified product, and is necessary when provisioning a product. A path also determines the constraints put on the product.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listLaunchPathsPaginator<Result>(
        _ input: ListLaunchPathsInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListLaunchPathsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listLaunchPaths,
            tokenKey: \ListLaunchPathsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listLaunchPathsPaginator(
        _ input: ListLaunchPathsInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListLaunchPathsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listLaunchPaths,
            tokenKey: \ListLaunchPathsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the organization nodes that have access to the specified portfolio. This API can only be called by the master account in the organization or by a delegated admin. If a delegated admin is de-registered, they can no longer perform this operation.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listOrganizationPortfolioAccessPaginator<Result>(
        _ input: ListOrganizationPortfolioAccessInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListOrganizationPortfolioAccessOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listOrganizationPortfolioAccess,
            tokenKey: \ListOrganizationPortfolioAccessOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listOrganizationPortfolioAccessPaginator(
        _ input: ListOrganizationPortfolioAccessInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListOrganizationPortfolioAccessOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listOrganizationPortfolioAccess,
            tokenKey: \ListOrganizationPortfolioAccessOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the account IDs that have access to the specified portfolio. A delegated admin can list the accounts that have access to the shared portfolio. Note that if a delegated admin is de-registered, they can no longer perform this operation.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPortfolioAccessPaginator<Result>(
        _ input: ListPortfolioAccessInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListPortfolioAccessOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPortfolioAccess,
            tokenKey: \ListPortfolioAccessOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPortfolioAccessPaginator(
        _ input: ListPortfolioAccessInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListPortfolioAccessOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPortfolioAccess,
            tokenKey: \ListPortfolioAccessOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all portfolios in the catalog.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPortfoliosPaginator<Result>(
        _ input: ListPortfoliosInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListPortfoliosOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPortfolios,
            tokenKey: \ListPortfoliosOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPortfoliosPaginator(
        _ input: ListPortfoliosInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListPortfoliosOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPortfolios,
            tokenKey: \ListPortfoliosOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all portfolios that the specified product is associated with.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPortfoliosForProductPaginator<Result>(
        _ input: ListPortfoliosForProductInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListPortfoliosForProductOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPortfoliosForProduct,
            tokenKey: \ListPortfoliosForProductOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPortfoliosForProductPaginator(
        _ input: ListPortfoliosForProductInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListPortfoliosForProductOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPortfoliosForProduct,
            tokenKey: \ListPortfoliosForProductOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all principal ARNs associated with the specified portfolio.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listPrincipalsForPortfolioPaginator<Result>(
        _ input: ListPrincipalsForPortfolioInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListPrincipalsForPortfolioOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listPrincipalsForPortfolio,
            tokenKey: \ListPrincipalsForPortfolioOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listPrincipalsForPortfolioPaginator(
        _ input: ListPrincipalsForPortfolioInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListPrincipalsForPortfolioOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listPrincipalsForPortfolio,
            tokenKey: \ListPrincipalsForPortfolioOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all provisioning artifacts (also known as versions) for the specified self-service action.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProvisioningArtifactsForServiceActionPaginator<Result>(
        _ input: ListProvisioningArtifactsForServiceActionInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListProvisioningArtifactsForServiceActionOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listProvisioningArtifactsForServiceAction,
            tokenKey: \ListProvisioningArtifactsForServiceActionOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProvisioningArtifactsForServiceActionPaginator(
        _ input: ListProvisioningArtifactsForServiceActionInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListProvisioningArtifactsForServiceActionOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listProvisioningArtifactsForServiceAction,
            tokenKey: \ListProvisioningArtifactsForServiceActionOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the resources associated with the specified TagOption.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listResourcesForTagOptionPaginator<Result>(
        _ input: ListResourcesForTagOptionInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListResourcesForTagOptionOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listResourcesForTagOption,
            tokenKey: \ListResourcesForTagOptionOutput.pageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listResourcesForTagOptionPaginator(
        _ input: ListResourcesForTagOptionInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListResourcesForTagOptionOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listResourcesForTagOption,
            tokenKey: \ListResourcesForTagOptionOutput.pageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists all self-service actions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listServiceActionsPaginator<Result>(
        _ input: ListServiceActionsInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListServiceActionsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listServiceActions,
            tokenKey: \ListServiceActionsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listServiceActionsPaginator(
        _ input: ListServiceActionsInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListServiceActionsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listServiceActions,
            tokenKey: \ListServiceActionsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Returns a paginated list of self-service actions associated with the specified Product ID and Provisioning Artifact ID.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listServiceActionsForProvisioningArtifactPaginator<Result>(
        _ input: ListServiceActionsForProvisioningArtifactInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListServiceActionsForProvisioningArtifactOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listServiceActionsForProvisioningArtifact,
            tokenKey: \ListServiceActionsForProvisioningArtifactOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listServiceActionsForProvisioningArtifactPaginator(
        _ input: ListServiceActionsForProvisioningArtifactInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListServiceActionsForProvisioningArtifactOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listServiceActionsForProvisioningArtifact,
            tokenKey: \ListServiceActionsForProvisioningArtifactOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Lists the specified TagOptions or all TagOptions.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listTagOptionsPaginator<Result>(
        _ input: ListTagOptionsInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, ListTagOptionsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: listTagOptions,
            tokenKey: \ListTagOptionsOutput.pageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listTagOptionsPaginator(
        _ input: ListTagOptionsInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (ListTagOptionsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: listTagOptions,
            tokenKey: \ListTagOptionsOutput.pageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the products to which the caller has access.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchProductsPaginator<Result>(
        _ input: SearchProductsInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, SearchProductsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchProducts,
            tokenKey: \SearchProductsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchProductsPaginator(
        _ input: SearchProductsInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (SearchProductsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchProducts,
            tokenKey: \SearchProductsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the products for the specified portfolio or all products.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchProductsAsAdminPaginator<Result>(
        _ input: SearchProductsAsAdminInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, SearchProductsAsAdminOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchProductsAsAdmin,
            tokenKey: \SearchProductsAsAdminOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchProductsAsAdminPaginator(
        _ input: SearchProductsAsAdminInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (SearchProductsAsAdminOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchProductsAsAdmin,
            tokenKey: \SearchProductsAsAdminOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the provisioned products that meet the specified criteria.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func searchProvisionedProductsPaginator<Result>(
        _ input: SearchProvisionedProductsInput,
        _ initialValue: Result,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (Result, SearchProvisionedProductsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: searchProvisionedProducts,
            tokenKey: \SearchProvisionedProductsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - eventLoop: EventLoop to run this process on
    ///   - logger: Logger used flot logging
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func searchProvisionedProductsPaginator(
        _ input: SearchProvisionedProductsInput,
        on eventLoop: EventLoop? = nil,
        logger: Logger = AWSClient.loggingDisabled,
        onPage: @escaping (SearchProvisionedProductsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: searchProvisionedProducts,
            tokenKey: \SearchProvisionedProductsOutput.nextPageToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension ServiceCatalog.ListAcceptedPortfolioSharesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListAcceptedPortfolioSharesInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioShareType: self.portfolioShareType
        )
    }
}

extension ServiceCatalog.ListBudgetsForResourceInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListBudgetsForResourceInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            resourceId: self.resourceId
        )
    }
}

extension ServiceCatalog.ListConstraintsForPortfolioInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListConstraintsForPortfolioInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            productId: self.productId
        )
    }
}

extension ServiceCatalog.ListLaunchPathsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListLaunchPathsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId
        )
    }
}

extension ServiceCatalog.ListOrganizationPortfolioAccessInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListOrganizationPortfolioAccessInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            organizationNodeType: self.organizationNodeType,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )
    }
}

extension ServiceCatalog.ListPortfolioAccessInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPortfolioAccessInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            organizationParentId: self.organizationParentId,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )
    }
}

extension ServiceCatalog.ListPortfoliosInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPortfoliosInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token
        )
    }
}

extension ServiceCatalog.ListPortfoliosForProductInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPortfoliosForProductInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId
        )
    }
}

extension ServiceCatalog.ListPrincipalsForPortfolioInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListPrincipalsForPortfolioInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId
        )
    }
}

extension ServiceCatalog.ListProvisioningArtifactsForServiceActionInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListProvisioningArtifactsForServiceActionInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            serviceActionId: self.serviceActionId
        )
    }
}

extension ServiceCatalog.ListResourcesForTagOptionInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListResourcesForTagOptionInput {
        return .init(
            pageSize: self.pageSize,
            pageToken: token,
            resourceType: self.resourceType,
            tagOptionId: self.tagOptionId
        )
    }
}

extension ServiceCatalog.ListServiceActionsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListServiceActionsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token
        )
    }
}

extension ServiceCatalog.ListServiceActionsForProvisioningArtifactInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListServiceActionsForProvisioningArtifactInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            pageSize: self.pageSize,
            pageToken: token,
            productId: self.productId,
            provisioningArtifactId: self.provisioningArtifactId
        )
    }
}

extension ServiceCatalog.ListTagOptionsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.ListTagOptionsInput {
        return .init(
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token
        )
    }
}

extension ServiceCatalog.SearchProductsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.SearchProductsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension ServiceCatalog.SearchProductsAsAdminInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.SearchProductsAsAdminInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            portfolioId: self.portfolioId,
            productSource: self.productSource,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}

extension ServiceCatalog.SearchProvisionedProductsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> ServiceCatalog.SearchProvisionedProductsInput {
        return .init(
            acceptLanguage: self.acceptLanguage,
            accessLevelFilter: self.accessLevelFilter,
            filters: self.filters,
            pageSize: self.pageSize,
            pageToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )
    }
}
