//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Outposts {
    // MARK: Enums

    public enum AWSServiceName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case ec2 = "EC2"
        case elasticache = "ELASTICACHE"
        case elb = "ELB"
        case rds = "RDS"
        case route53 = "ROUTE53"
        public var description: String { return self.rawValue }
    }

    public enum AddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case operatingAddress = "OPERATING_ADDRESS"
        case shippingAddress = "SHIPPING_ADDRESS"
        public var description: String { return self.rawValue }
    }

    public enum AssetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case isolated = "ISOLATED"
        case retiring = "RETIRING"
        public var description: String { return self.rawValue }
    }

    public enum AssetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case compute = "COMPUTE"
        public var description: String { return self.rawValue }
    }

    public enum CapacityTaskFailureType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blockingInstancesNotEvacuated = "BLOCKING_INSTANCES_NOT_EVACUATED"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case resourceNotFound = "RESOURCE_NOT_FOUND"
        case unexpectedAssetState = "UNEXPECTED_ASSET_STATE"
        case unsupportedCapacityConfiguration = "UNSUPPORTED_CAPACITY_CONFIGURATION"
        public var description: String { return self.rawValue }
    }

    public enum CapacityTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancellationInProgress = "CANCELLATION_IN_PROGRESS"
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case requested = "REQUESTED"
        case waitingForEvacuation = "WAITING_FOR_EVACUATION"
        public var description: String { return self.rawValue }
    }

    public enum CatalogItemClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rack = "RACK"
        case server = "SERVER"
        public var description: String { return self.rawValue }
    }

    public enum CatalogItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case discontinued = "DISCONTINUED"
        public var description: String { return self.rawValue }
    }

    public enum ComputeAssetState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case isolated = "ISOLATED"
        case retiring = "RETIRING"
        public var description: String { return self.rawValue }
    }

    public enum FiberOpticCableType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case multiMode = "MULTI_MODE"
        case singleMode = "SINGLE_MODE"
        public var description: String { return self.rawValue }
    }

    public enum LineItemStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case building = "BUILDING"
        case cancelled = "CANCELLED"
        case delivered = "DELIVERED"
        case error = "ERROR"
        case installed = "INSTALLED"
        case installing = "INSTALLING"
        case preparing = "PREPARING"
        case replaced = "REPLACED"
        case shipped = "SHIPPED"
        public var description: String { return self.rawValue }
    }

    public enum MaximumSupportedWeightLbs: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case max1400Lbs = "MAX_1400_LBS"
        case max1600Lbs = "MAX_1600_LBS"
        case max1800Lbs = "MAX_1800_LBS"
        case max2000Lbs = "MAX_2000_LBS"
        case noLimit = "NO_LIMIT"
        public var description: String { return self.rawValue }
    }

    public enum OpticalStandard: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case optic1000BaseLx = "OPTIC_1000BASE_LX"
        case optic1000BaseSx = "OPTIC_1000BASE_SX"
        case optic100GPsm4Msa = "OPTIC_100G_PSM4_MSA"
        case optic100GbaseCwdm4 = "OPTIC_100GBASE_CWDM4"
        case optic100GbaseLr4 = "OPTIC_100GBASE_LR4"
        case optic100GbaseSr4 = "OPTIC_100GBASE_SR4"
        case optic10GbaseIr = "OPTIC_10GBASE_IR"
        case optic10GbaseLr = "OPTIC_10GBASE_LR"
        case optic10GbaseSr = "OPTIC_10GBASE_SR"
        case optic40GbaseEsr = "OPTIC_40GBASE_ESR"
        case optic40GbaseIr4Lr4L = "OPTIC_40GBASE_IR4_LR4L"
        case optic40GbaseLr4 = "OPTIC_40GBASE_LR4"
        case optic40GbaseSr = "OPTIC_40GBASE_SR"
        public var description: String { return self.rawValue }
    }

    public enum OrderStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case completed = "COMPLETED"
        case delivered = "DELIVERED"
        case error = "ERROR"
        case fulfilled = "FULFILLED"
        case inProgress = "IN_PROGRESS"
        case installing = "INSTALLING"
        case pending = "PENDING"
        case preparing = "PREPARING"
        case processing = "PROCESSING"
        case received = "RECEIVED"
        public var description: String { return self.rawValue }
    }

    public enum OrderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case outpost = "OUTPOST"
        case replacement = "REPLACEMENT"
        public var description: String { return self.rawValue }
    }

    public enum PaymentOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allUpfront = "ALL_UPFRONT"
        case noUpfront = "NO_UPFRONT"
        case partialUpfront = "PARTIAL_UPFRONT"
        public var description: String { return self.rawValue }
    }

    public enum PaymentTerm: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fiveYears = "FIVE_YEARS"
        case oneYear = "ONE_YEAR"
        case threeYears = "THREE_YEARS"
        public var description: String { return self.rawValue }
    }

    public enum PowerConnector: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ah530p7w = "AH530P7W"
        case ah532p6w = "AH532P6W"
        case cs8365c = "CS8365C"
        case iec309 = "IEC309"
        case l630P = "L6_30P"
        public var description: String { return self.rawValue }
    }

    public enum PowerDrawKva: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case power10Kva = "POWER_10_KVA"
        case power15Kva = "POWER_15_KVA"
        case power30Kva = "POWER_30_KVA"
        case power5Kva = "POWER_5_KVA"
        public var description: String { return self.rawValue }
    }

    public enum PowerFeedDrop: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aboveRack = "ABOVE_RACK"
        case belowRack = "BELOW_RACK"
        public var description: String { return self.rawValue }
    }

    public enum PowerPhase: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case singlePhase = "SINGLE_PHASE"
        case threePhase = "THREE_PHASE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case order = "ORDER"
        case outpost = "OUTPOST"
        public var description: String { return self.rawValue }
    }

    public enum ShipmentCarrier: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dbs = "DBS"
        case dhl = "DHL"
        case expeditors = "EXPEDITORS"
        case fedex = "FEDEX"
        case ups = "UPS"
        public var description: String { return self.rawValue }
    }

    public enum SupportedHardwareType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case rack = "RACK"
        case server = "SERVER"
        public var description: String { return self.rawValue }
    }

    public enum SupportedStorageEnum: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ebs = "EBS"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum TaskActionOnBlockingInstances: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failTask = "FAIL_TASK"
        case waitForEvacuation = "WAIT_FOR_EVACUATION"
        public var description: String { return self.rawValue }
    }

    public enum UplinkCount: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case uplinkCount1 = "UPLINK_COUNT_1"
        case uplinkCount12 = "UPLINK_COUNT_12"
        case uplinkCount16 = "UPLINK_COUNT_16"
        case uplinkCount2 = "UPLINK_COUNT_2"
        case uplinkCount3 = "UPLINK_COUNT_3"
        case uplinkCount4 = "UPLINK_COUNT_4"
        case uplinkCount5 = "UPLINK_COUNT_5"
        case uplinkCount6 = "UPLINK_COUNT_6"
        case uplinkCount7 = "UPLINK_COUNT_7"
        case uplinkCount8 = "UPLINK_COUNT_8"
        public var description: String { return self.rawValue }
    }

    public enum UplinkGbps: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case uplink100G = "UPLINK_100G"
        case uplink10G = "UPLINK_10G"
        case uplink1G = "UPLINK_1G"
        case uplink40G = "UPLINK_40G"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Address: AWSEncodableShape & AWSDecodableShape {
        /// The first line of the address.
        public let addressLine1: String
        /// The second line of the address.
        public let addressLine2: String?
        /// The third line of the address.
        public let addressLine3: String?
        /// The city for the address.
        public let city: String
        /// The name of the contact.
        public let contactName: String?
        /// The phone number of the contact.
        public let contactPhoneNumber: String?
        /// The ISO-3166 two-letter country code for the address.
        public let countryCode: String
        /// The district or county for the address.
        public let districtOrCounty: String?
        /// The municipality for the address.
        public let municipality: String?
        /// The postal code for the address.
        public let postalCode: String
        /// The state for the address.
        public let stateOrRegion: String

        @inlinable
        public init(addressLine1: String, addressLine2: String? = nil, addressLine3: String? = nil, city: String, contactName: String? = nil, contactPhoneNumber: String? = nil, countryCode: String, districtOrCounty: String? = nil, municipality: String? = nil, postalCode: String, stateOrRegion: String) {
            self.addressLine1 = addressLine1
            self.addressLine2 = addressLine2
            self.addressLine3 = addressLine3
            self.city = city
            self.contactName = contactName
            self.contactPhoneNumber = contactPhoneNumber
            self.countryCode = countryCode
            self.districtOrCounty = districtOrCounty
            self.municipality = municipality
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.addressLine1, name: "addressLine1", parent: name, max: 180)
            try self.validate(self.addressLine1, name: "addressLine1", parent: name, min: 1)
            try self.validate(self.addressLine1, name: "addressLine1", parent: name, pattern: "^\\S[\\S ]*$")
            try self.validate(self.addressLine2, name: "addressLine2", parent: name, max: 60)
            try self.validate(self.addressLine2, name: "addressLine2", parent: name, pattern: "^\\S[\\S ]*$")
            try self.validate(self.addressLine3, name: "addressLine3", parent: name, max: 60)
            try self.validate(self.addressLine3, name: "addressLine3", parent: name, pattern: "^\\S[\\S ]*$")
            try self.validate(self.city, name: "city", parent: name, max: 50)
            try self.validate(self.city, name: "city", parent: name, min: 1)
            try self.validate(self.city, name: "city", parent: name, pattern: "^\\S[\\S ]*$")
            try self.validate(self.contactName, name: "contactName", parent: name, max: 255)
            try self.validate(self.contactName, name: "contactName", parent: name, min: 1)
            try self.validate(self.contactName, name: "contactName", parent: name, pattern: "^\\S[\\S ]*$")
            try self.validate(self.contactPhoneNumber, name: "contactPhoneNumber", parent: name, max: 20)
            try self.validate(self.contactPhoneNumber, name: "contactPhoneNumber", parent: name, min: 1)
            try self.validate(self.contactPhoneNumber, name: "contactPhoneNumber", parent: name, pattern: "^[\\S ]+$")
            try self.validate(self.countryCode, name: "countryCode", parent: name, max: 2)
            try self.validate(self.countryCode, name: "countryCode", parent: name, min: 2)
            try self.validate(self.countryCode, name: "countryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.districtOrCounty, name: "districtOrCounty", parent: name, max: 60)
            try self.validate(self.districtOrCounty, name: "districtOrCounty", parent: name, min: 1)
            try self.validate(self.districtOrCounty, name: "districtOrCounty", parent: name, pattern: "^\\S[\\S ]*$")
            try self.validate(self.municipality, name: "municipality", parent: name, max: 180)
            try self.validate(self.municipality, name: "municipality", parent: name, pattern: "^\\S[\\S ]*$")
            try self.validate(self.postalCode, name: "postalCode", parent: name, max: 20)
            try self.validate(self.postalCode, name: "postalCode", parent: name, min: 1)
            try self.validate(self.postalCode, name: "postalCode", parent: name, pattern: "^[a-zA-Z0-9 -]+$")
            try self.validate(self.stateOrRegion, name: "stateOrRegion", parent: name, max: 50)
            try self.validate(self.stateOrRegion, name: "stateOrRegion", parent: name, min: 1)
            try self.validate(self.stateOrRegion, name: "stateOrRegion", parent: name, pattern: "^\\S[\\S ]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case addressLine1 = "AddressLine1"
            case addressLine2 = "AddressLine2"
            case addressLine3 = "AddressLine3"
            case city = "City"
            case contactName = "ContactName"
            case contactPhoneNumber = "ContactPhoneNumber"
            case countryCode = "CountryCode"
            case districtOrCounty = "DistrictOrCounty"
            case municipality = "Municipality"
            case postalCode = "PostalCode"
            case stateOrRegion = "StateOrRegion"
        }
    }

    public struct AssetInfo: AWSDecodableShape {
        ///  The ID of the asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        ///  The position of an asset in a rack.
        public let assetLocation: AssetLocation?
        ///  The type of the asset.
        public let assetType: AssetType?
        ///  Information about compute hardware assets.
        public let computeAttributes: ComputeAttributes?
        ///  The rack ID of the asset.
        public let rackId: String?

        @inlinable
        public init(assetId: String? = nil, assetLocation: AssetLocation? = nil, assetType: AssetType? = nil, computeAttributes: ComputeAttributes? = nil, rackId: String? = nil) {
            self.assetId = assetId
            self.assetLocation = assetLocation
            self.assetType = assetType
            self.computeAttributes = computeAttributes
            self.rackId = rackId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case assetLocation = "AssetLocation"
            case assetType = "AssetType"
            case computeAttributes = "ComputeAttributes"
            case rackId = "RackId"
        }
    }

    public struct AssetInstance: AWSDecodableShape {
        public let accountId: String?
        /// The ID of the asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        /// The Amazon Web Services service name of the instance.
        public let awsServiceName: AWSServiceName?
        /// The ID of the instance.
        public let instanceId: String?
        /// The type of instance.
        public let instanceType: String?

        @inlinable
        public init(accountId: String? = nil, assetId: String? = nil, awsServiceName: AWSServiceName? = nil, instanceId: String? = nil, instanceType: String? = nil) {
            self.accountId = accountId
            self.assetId = assetId
            self.awsServiceName = awsServiceName
            self.instanceId = instanceId
            self.instanceType = instanceType
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case assetId = "AssetId"
            case awsServiceName = "AwsServiceName"
            case instanceId = "InstanceId"
            case instanceType = "InstanceType"
        }
    }

    public struct AssetInstanceTypeCapacity: AWSDecodableShape {
        /// The number of each instance type.
        public let count: Int
        /// The type of instance.
        public let instanceType: String

        @inlinable
        public init(count: Int, instanceType: String) {
            self.count = count
            self.instanceType = instanceType
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case instanceType = "InstanceType"
        }
    }

    public struct AssetLocation: AWSDecodableShape {
        ///  The position of an asset in a rack measured in rack units.
        public let rackElevation: Float?

        @inlinable
        public init(rackElevation: Float? = nil) {
            self.rackElevation = rackElevation
        }

        private enum CodingKeys: String, CodingKey {
            case rackElevation = "RackElevation"
        }
    }

    public struct BlockingInstance: AWSDecodableShape {
        public let accountId: String?
        /// The Amazon Web Services service name that owns the specified blocking instance.
        public let awsServiceName: AWSServiceName?
        /// The ID of the blocking instance.
        public let instanceId: String?

        @inlinable
        public init(accountId: String? = nil, awsServiceName: AWSServiceName? = nil, instanceId: String? = nil) {
            self.accountId = accountId
            self.awsServiceName = awsServiceName
            self.instanceId = instanceId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case awsServiceName = "AwsServiceName"
            case instanceId = "InstanceId"
        }
    }

    public struct CancelCapacityTaskInput: AWSEncodableShape {
        /// ID of the capacity task that you want to cancel.
        public let capacityTaskId: String
        /// ID or ARN of the Outpost associated with the capacity task that you want to cancel.
        public let outpostIdentifier: String

        @inlinable
        public init(capacityTaskId: String, outpostIdentifier: String) {
            self.capacityTaskId = capacityTaskId
            self.outpostIdentifier = outpostIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capacityTaskId, key: "CapacityTaskId")
            request.encodePath(self.outpostIdentifier, key: "OutpostIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, max: 21)
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, min: 21)
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, pattern: "^cap-[a-f0-9]{17}$")
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelCapacityTaskOutput: AWSDecodableShape {
        public init() {}
    }

    public struct CancelOrderInput: AWSEncodableShape {
        ///  The ID of the order.
        public let orderId: String

        @inlinable
        public init(orderId: String) {
            self.orderId = orderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.orderId, key: "OrderId")
        }

        public func validate(name: String) throws {
            try self.validate(self.orderId, name: "orderId", parent: name, max: 20)
            try self.validate(self.orderId, name: "orderId", parent: name, min: 1)
            try self.validate(self.orderId, name: "orderId", parent: name, pattern: "^oo-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelOrderOutput: AWSDecodableShape {
        public init() {}
    }

    public struct CapacityTaskFailure: AWSDecodableShape {
        /// The reason that the specified capacity task failed.
        public let reason: String
        /// The type of failure.
        public let type: CapacityTaskFailureType?

        @inlinable
        public init(reason: String, type: CapacityTaskFailureType? = nil) {
            self.reason = reason
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case reason = "Reason"
            case type = "Type"
        }
    }

    public struct CapacityTaskSummary: AWSDecodableShape {
        /// The ID of the asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        /// The ID of the specified capacity task.
        public let capacityTaskId: String?
        /// The status of the capacity task.
        public let capacityTaskStatus: CapacityTaskStatus?
        /// The date that the specified capacity task successfully ran.
        public let completionDate: Date?
        /// The date that the specified capacity task was created.
        public let creationDate: Date?
        /// The date that the specified capacity was last modified.
        public let lastModifiedDate: Date?
        /// The ID of the Amazon Web Services Outposts order of the host associated with the capacity task.
        public let orderId: String?
        /// The ID of the Outpost associated with the specified capacity task.
        public let outpostId: String?

        @inlinable
        public init(assetId: String? = nil, capacityTaskId: String? = nil, capacityTaskStatus: CapacityTaskStatus? = nil, completionDate: Date? = nil, creationDate: Date? = nil, lastModifiedDate: Date? = nil, orderId: String? = nil, outpostId: String? = nil) {
            self.assetId = assetId
            self.capacityTaskId = capacityTaskId
            self.capacityTaskStatus = capacityTaskStatus
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.lastModifiedDate = lastModifiedDate
            self.orderId = orderId
            self.outpostId = outpostId
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case capacityTaskId = "CapacityTaskId"
            case capacityTaskStatus = "CapacityTaskStatus"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case lastModifiedDate = "LastModifiedDate"
            case orderId = "OrderId"
            case outpostId = "OutpostId"
        }
    }

    public struct CatalogItem: AWSDecodableShape {
        ///  The ID of the catalog item.
        public let catalogItemId: String?
        ///  Information about the EC2 capacity of an item.
        public let ec2Capacities: [EC2Capacity]?
        ///  The status of a catalog item.
        public let itemStatus: CatalogItemStatus?
        ///  Information about the power draw of an item.
        public let powerKva: Float?
        ///  The supported storage options for the catalog item.
        public let supportedStorage: [SupportedStorageEnum]?
        ///  The uplink speed this catalog item requires for the connection to the Region.
        public let supportedUplinkGbps: [Int]?
        ///  The weight of the item in pounds.
        public let weightLbs: Int?

        @inlinable
        public init(catalogItemId: String? = nil, ec2Capacities: [EC2Capacity]? = nil, itemStatus: CatalogItemStatus? = nil, powerKva: Float? = nil, supportedStorage: [SupportedStorageEnum]? = nil, supportedUplinkGbps: [Int]? = nil, weightLbs: Int? = nil) {
            self.catalogItemId = catalogItemId
            self.ec2Capacities = ec2Capacities
            self.itemStatus = itemStatus
            self.powerKva = powerKva
            self.supportedStorage = supportedStorage
            self.supportedUplinkGbps = supportedUplinkGbps
            self.weightLbs = weightLbs
        }

        private enum CodingKeys: String, CodingKey {
            case catalogItemId = "CatalogItemId"
            case ec2Capacities = "EC2Capacities"
            case itemStatus = "ItemStatus"
            case powerKva = "PowerKva"
            case supportedStorage = "SupportedStorage"
            case supportedUplinkGbps = "SupportedUplinkGbps"
            case weightLbs = "WeightLbs"
        }
    }

    public struct ComputeAttributes: AWSDecodableShape {
        ///  The host ID of the Dedicated Host on the asset.
        public let hostId: String?
        /// A list of the names of instance families that are currently associated with a given asset.
        public let instanceFamilies: [String]?
        /// The instance type capacities configured for this asset. This can be changed through a capacity task.
        public let instanceTypeCapacities: [AssetInstanceTypeCapacity]?
        /// The maximum number of vCPUs possible for the specified asset.
        public let maxVcpus: Int?
        /// The state.   ACTIVE - The asset is available and can provide capacity for new compute resources.   ISOLATED - The asset is undergoing maintenance and can't provide capacity for new compute resources. Existing compute resources on the asset are not affected.   RETIRING - The underlying hardware for the asset is degraded. Capacity for new compute resources is reduced. Amazon Web Services sends notifications for resources that must be stopped before the asset can be replaced.
        public let state: ComputeAssetState?

        @inlinable
        public init(hostId: String? = nil, instanceFamilies: [String]? = nil, instanceTypeCapacities: [AssetInstanceTypeCapacity]? = nil, maxVcpus: Int? = nil, state: ComputeAssetState? = nil) {
            self.hostId = hostId
            self.instanceFamilies = instanceFamilies
            self.instanceTypeCapacities = instanceTypeCapacities
            self.maxVcpus = maxVcpus
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case hostId = "HostId"
            case instanceFamilies = "InstanceFamilies"
            case instanceTypeCapacities = "InstanceTypeCapacities"
            case maxVcpus = "MaxVcpus"
            case state = "State"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String?
        /// The ID of the resource causing the conflict.
        public let resourceId: String?
        /// The type of the resource causing the conflict.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ConnectionDetails: AWSDecodableShape {
        ///  The allowed IP addresses.
        public let allowedIps: [String]?
        ///  The public key of the client.
        public let clientPublicKey: String?
        ///  The client tunnel address.
        public let clientTunnelAddress: String?
        ///  The endpoint for the server.
        public let serverEndpoint: String?
        ///  The public key of the server.
        public let serverPublicKey: String?
        ///  The server tunnel address.
        public let serverTunnelAddress: String?

        @inlinable
        public init(allowedIps: [String]? = nil, clientPublicKey: String? = nil, clientTunnelAddress: String? = nil, serverEndpoint: String? = nil, serverPublicKey: String? = nil, serverTunnelAddress: String? = nil) {
            self.allowedIps = allowedIps
            self.clientPublicKey = clientPublicKey
            self.clientTunnelAddress = clientTunnelAddress
            self.serverEndpoint = serverEndpoint
            self.serverPublicKey = serverPublicKey
            self.serverTunnelAddress = serverTunnelAddress
        }

        private enum CodingKeys: String, CodingKey {
            case allowedIps = "AllowedIps"
            case clientPublicKey = "ClientPublicKey"
            case clientTunnelAddress = "ClientTunnelAddress"
            case serverEndpoint = "ServerEndpoint"
            case serverPublicKey = "ServerPublicKey"
            case serverTunnelAddress = "ServerTunnelAddress"
        }
    }

    public struct CreateOrderInput: AWSEncodableShape {
        /// The line items that make up the order.
        public let lineItems: [LineItemRequest]
        ///  The ID or the Amazon Resource Name (ARN) of the Outpost.
        public let outpostIdentifier: String
        /// The payment option.
        public let paymentOption: PaymentOption
        /// The payment terms.
        public let paymentTerm: PaymentTerm?

        @inlinable
        public init(lineItems: [LineItemRequest], outpostIdentifier: String, paymentOption: PaymentOption, paymentTerm: PaymentTerm? = nil) {
            self.lineItems = lineItems
            self.outpostIdentifier = outpostIdentifier
            self.paymentOption = paymentOption
            self.paymentTerm = paymentTerm
        }

        public func validate(name: String) throws {
            try self.lineItems.forEach {
                try $0.validate(name: "\(name).lineItems[]")
            }
            try self.validate(self.lineItems, name: "lineItems", parent: name, max: 20)
            try self.validate(self.lineItems, name: "lineItems", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case lineItems = "LineItems"
            case outpostIdentifier = "OutpostIdentifier"
            case paymentOption = "PaymentOption"
            case paymentTerm = "PaymentTerm"
        }
    }

    public struct CreateOrderOutput: AWSDecodableShape {
        /// Information about this order.
        public let order: Order?

        @inlinable
        public init(order: Order? = nil) {
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case order = "Order"
        }
    }

    public struct CreateOutpostInput: AWSEncodableShape {
        public let availabilityZone: String?
        public let availabilityZoneId: String?
        public let description: String?
        public let name: String
        ///  The ID or the Amazon Resource Name (ARN) of the site.
        public let siteId: String
        ///  The type of hardware for this Outpost.
        public let supportedHardwareType: SupportedHardwareType?
        /// The tags to apply to the Outpost.
        public let tags: [String: String]?

        @inlinable
        public init(availabilityZone: String? = nil, availabilityZoneId: String? = nil, description: String? = nil, name: String, siteId: String, supportedHardwareType: SupportedHardwareType? = nil, tags: [String: String]? = nil) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.description = description
            self.name = name
            self.siteId = siteId
            self.supportedHardwareType = supportedHardwareType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, max: 1000)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, min: 1)
            try self.validate(self.availabilityZone, name: "availabilityZone", parent: name, pattern: "^([a-zA-Z]+-){1,3}([a-zA-Z]+)?(\\d+[a-zA-Z]?)?$")
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, max: 255)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, min: 1)
            try self.validate(self.availabilityZoneId, name: "availabilityZoneId", parent: name, pattern: "^[a-zA-Z]+\\d-[a-zA-Z]+\\d$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S ]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S ]+$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 255)
            try self.validate(self.siteId, name: "siteId", parent: name, min: 1)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:site/)?(os-[a-f0-9]{17})$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\S \\n]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case availabilityZoneId = "AvailabilityZoneId"
            case description = "Description"
            case name = "Name"
            case siteId = "SiteId"
            case supportedHardwareType = "SupportedHardwareType"
            case tags = "Tags"
        }
    }

    public struct CreateOutpostOutput: AWSDecodableShape {
        public let outpost: Outpost?

        @inlinable
        public init(outpost: Outpost? = nil) {
            self.outpost = outpost
        }

        private enum CodingKeys: String, CodingKey {
            case outpost = "Outpost"
        }
    }

    public struct CreateSiteInput: AWSEncodableShape {
        public let description: String?
        public let name: String
        /// Additional information that you provide about site access requirements, electrician scheduling, personal protective equipment, or regulation of equipment materials that could affect your installation process.
        public let notes: String?
        ///  The location to install and power on the hardware. This address might be different from the shipping address.
        public let operatingAddress: Address?
        ///  Information about the physical and logistical details for the rack at this site. For more information about hardware requirements for racks, see Network  readiness checklist in the Amazon Web Services Outposts User Guide.
        public let rackPhysicalProperties: RackPhysicalProperties?
        ///  The location to ship the hardware. This address might be different from the operating address.
        public let shippingAddress: Address?
        ///  The tags to apply to a site.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, name: String, notes: String? = nil, operatingAddress: Address? = nil, rackPhysicalProperties: RackPhysicalProperties? = nil, shippingAddress: Address? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.notes = notes
            self.operatingAddress = operatingAddress
            self.rackPhysicalProperties = rackPhysicalProperties
            self.shippingAddress = shippingAddress
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1001)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S ]+$")
            try self.validate(self.notes, name: "notes", parent: name, max: 2000)
            try self.validate(self.notes, name: "notes", parent: name, min: 1)
            try self.validate(self.notes, name: "notes", parent: name, pattern: "^[\\S \\n]+$")
            try self.operatingAddress?.validate(name: "\(name).operatingAddress")
            try self.shippingAddress?.validate(name: "\(name).shippingAddress")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\S \\n]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case notes = "Notes"
            case operatingAddress = "OperatingAddress"
            case rackPhysicalProperties = "RackPhysicalProperties"
            case shippingAddress = "ShippingAddress"
            case tags = "Tags"
        }
    }

    public struct CreateSiteOutput: AWSDecodableShape {
        public let site: Site?

        @inlinable
        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct DeleteOutpostInput: AWSEncodableShape {
        ///  The ID or ARN of the Outpost.
        public let outpostId: String

        @inlinable
        public init(outpostId: String) {
            self.outpostId = outpostId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.outpostId, key: "OutpostId")
        }

        public func validate(name: String) throws {
            try self.validate(self.outpostId, name: "outpostId", parent: name, max: 180)
            try self.validate(self.outpostId, name: "outpostId", parent: name, min: 1)
            try self.validate(self.outpostId, name: "outpostId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteOutpostOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteSiteInput: AWSEncodableShape {
        ///  The ID or the Amazon Resource Name (ARN) of the site.
        public let siteId: String

        @inlinable
        public init(siteId: String) {
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.siteId, name: "siteId", parent: name, max: 255)
            try self.validate(self.siteId, name: "siteId", parent: name, min: 1)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:site/)?(os-[a-f0-9]{17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSiteOutput: AWSDecodableShape {
        public init() {}
    }

    public struct EC2Capacity: AWSDecodableShape {
        ///  The family of the EC2 capacity.
        public let family: String?
        ///  The maximum size of the EC2 capacity.
        public let maxSize: String?
        ///  The quantity of the EC2 capacity.
        public let quantity: String?

        @inlinable
        public init(family: String? = nil, maxSize: String? = nil, quantity: String? = nil) {
            self.family = family
            self.maxSize = maxSize
            self.quantity = quantity
        }

        private enum CodingKeys: String, CodingKey {
            case family = "Family"
            case maxSize = "MaxSize"
            case quantity = "Quantity"
        }
    }

    public struct GetCapacityTaskInput: AWSEncodableShape {
        /// ID of the capacity task.
        public let capacityTaskId: String
        /// ID or ARN of the Outpost associated with the specified capacity task.
        public let outpostIdentifier: String

        @inlinable
        public init(capacityTaskId: String, outpostIdentifier: String) {
            self.capacityTaskId = capacityTaskId
            self.outpostIdentifier = outpostIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capacityTaskId, key: "CapacityTaskId")
            request.encodePath(self.outpostIdentifier, key: "OutpostIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, max: 21)
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, min: 21)
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, pattern: "^cap-[a-f0-9]{17}$")
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCapacityTaskOutput: AWSDecodableShape {
        /// The ID of the Outpost asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        /// ID of the capacity task.
        public let capacityTaskId: String?
        /// Status of the capacity task. A capacity task can have one of the following statuses:    REQUESTED - The capacity task was created and is awaiting the next step by Amazon Web Services Outposts.    IN_PROGRESS - The capacity task is running and cannot be cancelled.    FAILED - The capacity task could not be completed.    COMPLETED - The capacity task has completed successfully.    WAITING_FOR_EVACUATION - The capacity task requires capacity to run. You must stop the recommended EC2 running instances to free up capacity for the task to run.    CANCELLATION_IN_PROGRESS - The capacity task has been cancelled and is in the process of cleaning up resources.    CANCELLED - The capacity task is cancelled.
        public let capacityTaskStatus: CapacityTaskStatus?
        /// The date the capacity task ran successfully.
        public let completionDate: Date?
        /// The date the capacity task was created.
        public let creationDate: Date?
        /// Performs a dry run to determine if you are above or below instance capacity.
        public let dryRun: Bool?
        /// Reason why the capacity task failed.
        public let failed: CapacityTaskFailure?
        /// Instances that the user specified they cannot stop in order to free up the capacity needed to run the capacity task.
        public let instancesToExclude: InstancesToExclude?
        /// The date the capacity task was last modified.
        public let lastModifiedDate: Date?
        /// ID of the Amazon Web Services Outposts order associated with the specified capacity task.
        public let orderId: String?
        /// ID of the Outpost associated with the specified capacity task.
        public let outpostId: String?
        /// List of instance pools requested in the capacity task.
        public let requestedInstancePools: [InstanceTypeCapacity]?
        /// User-specified option in case an instance is blocking the capacity task from running. Shows one of the following options:    WAIT_FOR_EVACUATION - Checks every 10 minutes over 48 hours to determine if instances have stopped and capacity is available to complete the task.    FAIL_TASK - The capacity task fails.
        public let taskActionOnBlockingInstances: TaskActionOnBlockingInstances?

        @inlinable
        public init(assetId: String? = nil, capacityTaskId: String? = nil, capacityTaskStatus: CapacityTaskStatus? = nil, completionDate: Date? = nil, creationDate: Date? = nil, dryRun: Bool? = nil, failed: CapacityTaskFailure? = nil, instancesToExclude: InstancesToExclude? = nil, lastModifiedDate: Date? = nil, orderId: String? = nil, outpostId: String? = nil, requestedInstancePools: [InstanceTypeCapacity]? = nil, taskActionOnBlockingInstances: TaskActionOnBlockingInstances? = nil) {
            self.assetId = assetId
            self.capacityTaskId = capacityTaskId
            self.capacityTaskStatus = capacityTaskStatus
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.dryRun = dryRun
            self.failed = failed
            self.instancesToExclude = instancesToExclude
            self.lastModifiedDate = lastModifiedDate
            self.orderId = orderId
            self.outpostId = outpostId
            self.requestedInstancePools = requestedInstancePools
            self.taskActionOnBlockingInstances = taskActionOnBlockingInstances
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case capacityTaskId = "CapacityTaskId"
            case capacityTaskStatus = "CapacityTaskStatus"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case dryRun = "DryRun"
            case failed = "Failed"
            case instancesToExclude = "InstancesToExclude"
            case lastModifiedDate = "LastModifiedDate"
            case orderId = "OrderId"
            case outpostId = "OutpostId"
            case requestedInstancePools = "RequestedInstancePools"
            case taskActionOnBlockingInstances = "TaskActionOnBlockingInstances"
        }
    }

    public struct GetCatalogItemInput: AWSEncodableShape {
        /// The ID of the catalog item.
        public let catalogItemId: String

        @inlinable
        public init(catalogItemId: String) {
            self.catalogItemId = catalogItemId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.catalogItemId, key: "CatalogItemId")
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogItemId, name: "catalogItemId", parent: name, max: 10)
            try self.validate(self.catalogItemId, name: "catalogItemId", parent: name, min: 1)
            try self.validate(self.catalogItemId, name: "catalogItemId", parent: name, pattern: "^OR-[A-Z0-9]{7}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCatalogItemOutput: AWSDecodableShape {
        /// Information about this catalog item.
        public let catalogItem: CatalogItem?

        @inlinable
        public init(catalogItem: CatalogItem? = nil) {
            self.catalogItem = catalogItem
        }

        private enum CodingKeys: String, CodingKey {
            case catalogItem = "CatalogItem"
        }
    }

    public struct GetConnectionRequest: AWSEncodableShape {
        ///  The ID of the connection.
        public let connectionId: String

        @inlinable
        public init(connectionId: String) {
            self.connectionId = connectionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.connectionId, key: "ConnectionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.connectionId, name: "connectionId", parent: name, max: 1024)
            try self.validate(self.connectionId, name: "connectionId", parent: name, min: 1)
            try self.validate(self.connectionId, name: "connectionId", parent: name, pattern: "^[a-zA-Z0-9+/=]{1,1024}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConnectionResponse: AWSDecodableShape {
        ///  Information about the connection.
        public let connectionDetails: ConnectionDetails?
        ///  The ID of the connection.
        public let connectionId: String?

        @inlinable
        public init(connectionDetails: ConnectionDetails? = nil, connectionId: String? = nil) {
            self.connectionDetails = connectionDetails
            self.connectionId = connectionId
        }

        private enum CodingKeys: String, CodingKey {
            case connectionDetails = "ConnectionDetails"
            case connectionId = "ConnectionId"
        }
    }

    public struct GetOrderInput: AWSEncodableShape {
        /// The ID of the order.
        public let orderId: String

        @inlinable
        public init(orderId: String) {
            self.orderId = orderId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.orderId, key: "OrderId")
        }

        public func validate(name: String) throws {
            try self.validate(self.orderId, name: "orderId", parent: name, max: 20)
            try self.validate(self.orderId, name: "orderId", parent: name, min: 1)
            try self.validate(self.orderId, name: "orderId", parent: name, pattern: "^oo-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOrderOutput: AWSDecodableShape {
        public let order: Order?

        @inlinable
        public init(order: Order? = nil) {
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case order = "Order"
        }
    }

    public struct GetOutpostInput: AWSEncodableShape {
        ///  The ID or ARN of the Outpost.
        public let outpostId: String

        @inlinable
        public init(outpostId: String) {
            self.outpostId = outpostId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.outpostId, key: "OutpostId")
        }

        public func validate(name: String) throws {
            try self.validate(self.outpostId, name: "outpostId", parent: name, max: 180)
            try self.validate(self.outpostId, name: "outpostId", parent: name, min: 1)
            try self.validate(self.outpostId, name: "outpostId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOutpostInstanceTypesInput: AWSEncodableShape {
        public let maxResults: Int?
        public let nextToken: String?
        ///  The ID or ARN of the Outpost.
        public let outpostId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, outpostId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outpostId = outpostId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.outpostId, key: "OutpostId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.validate(self.outpostId, name: "outpostId", parent: name, max: 180)
            try self.validate(self.outpostId, name: "outpostId", parent: name, min: 1)
            try self.validate(self.outpostId, name: "outpostId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOutpostInstanceTypesOutput: AWSDecodableShape {
        public let instanceTypes: [InstanceTypeItem]?
        public let nextToken: String?
        public let outpostArn: String?
        ///  The ID of the Outpost.
        public let outpostId: String?

        @inlinable
        public init(instanceTypes: [InstanceTypeItem]? = nil, nextToken: String? = nil, outpostArn: String? = nil, outpostId: String? = nil) {
            self.instanceTypes = instanceTypes
            self.nextToken = nextToken
            self.outpostArn = outpostArn
            self.outpostId = outpostId
        }

        private enum CodingKeys: String, CodingKey {
            case instanceTypes = "InstanceTypes"
            case nextToken = "NextToken"
            case outpostArn = "OutpostArn"
            case outpostId = "OutpostId"
        }
    }

    public struct GetOutpostOutput: AWSDecodableShape {
        public let outpost: Outpost?

        @inlinable
        public init(outpost: Outpost? = nil) {
            self.outpost = outpost
        }

        private enum CodingKeys: String, CodingKey {
            case outpost = "Outpost"
        }
    }

    public struct GetOutpostSupportedInstanceTypesInput: AWSEncodableShape {
        /// The ID of the Outpost asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        public let maxResults: Int?
        public let nextToken: String?
        /// The ID for the Amazon Web Services Outposts order.
        public let orderId: String?
        /// The ID or ARN of the Outpost.
        public let outpostIdentifier: String

        @inlinable
        public init(assetId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderId: String? = nil, outpostIdentifier: String) {
            self.assetId = assetId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderId = orderId
            self.outpostIdentifier = outpostIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.assetId, key: "AssetId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.orderId, key: "OrderId")
            request.encodePath(self.outpostIdentifier, key: "OutpostIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 10)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 10)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^\\d{10}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.validate(self.orderId, name: "orderId", parent: name, max: 20)
            try self.validate(self.orderId, name: "orderId", parent: name, min: 1)
            try self.validate(self.orderId, name: "orderId", parent: name, pattern: "^oo-[a-f0-9]{17}$")
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetOutpostSupportedInstanceTypesOutput: AWSDecodableShape {
        public let instanceTypes: [InstanceTypeItem]?
        public let nextToken: String?

        @inlinable
        public init(instanceTypes: [InstanceTypeItem]? = nil, nextToken: String? = nil) {
            self.instanceTypes = instanceTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceTypes = "InstanceTypes"
            case nextToken = "NextToken"
        }
    }

    public struct GetSiteAddressInput: AWSEncodableShape {
        /// The type of the address you request.
        public let addressType: AddressType
        ///  The ID or the Amazon Resource Name (ARN) of the site.
        public let siteId: String

        @inlinable
        public init(addressType: AddressType, siteId: String) {
            self.addressType = addressType
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.addressType, key: "AddressType")
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.siteId, name: "siteId", parent: name, max: 255)
            try self.validate(self.siteId, name: "siteId", parent: name, min: 1)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:site/)?(os-[a-f0-9]{17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSiteAddressOutput: AWSDecodableShape {
        ///  Information about the address.
        public let address: Address?
        /// The type of the address you receive.
        public let addressType: AddressType?
        public let siteId: String?

        @inlinable
        public init(address: Address? = nil, addressType: AddressType? = nil, siteId: String? = nil) {
            self.address = address
            self.addressType = addressType
            self.siteId = siteId
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case addressType = "AddressType"
            case siteId = "SiteId"
        }
    }

    public struct GetSiteInput: AWSEncodableShape {
        ///  The ID or the Amazon Resource Name (ARN) of the site.
        public let siteId: String

        @inlinable
        public init(siteId: String) {
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.siteId, name: "siteId", parent: name, max: 255)
            try self.validate(self.siteId, name: "siteId", parent: name, min: 1)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:site/)?(os-[a-f0-9]{17})$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSiteOutput: AWSDecodableShape {
        public let site: Site?

        @inlinable
        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct InstanceTypeCapacity: AWSEncodableShape & AWSDecodableShape {
        /// The number of instances for the specified instance type.
        public let count: Int
        /// The instance type of the hosts.
        public let instanceType: String

        @inlinable
        public init(count: Int, instanceType: String) {
            self.count = count
            self.instanceType = instanceType
        }

        public func validate(name: String) throws {
            try self.validate(self.count, name: "count", parent: name, max: 9999)
            try self.validate(self.count, name: "count", parent: name, min: 0)
            try self.validate(self.instanceType, name: "instanceType", parent: name, max: 64)
            try self.validate(self.instanceType, name: "instanceType", parent: name, min: 1)
            try self.validate(self.instanceType, name: "instanceType", parent: name, pattern: "^[a-z0-9\\-]+\\.[a-z0-9\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case count = "Count"
            case instanceType = "InstanceType"
        }
    }

    public struct InstanceTypeItem: AWSDecodableShape {
        public let instanceType: String?
        /// The number of default VCPUs in an instance type.
        public let vcpUs: Int?

        @inlinable
        public init(instanceType: String? = nil, vcpUs: Int? = nil) {
            self.instanceType = instanceType
            self.vcpUs = vcpUs
        }

        private enum CodingKeys: String, CodingKey {
            case instanceType = "InstanceType"
            case vcpUs = "VCPUs"
        }
    }

    public struct InstancesToExclude: AWSEncodableShape & AWSDecodableShape {
        /// IDs of the accounts that own each instance that must not be stopped.
        public let accountIds: [String]?
        /// List of user-specified instances that must not be stopped.
        public let instances: [String]?
        /// Names of the services that own each instance that must not be stopped in order to free up the capacity needed to run the capacity task.
        public let services: [AWSServiceName]?

        @inlinable
        public init(accountIds: [String]? = nil, instances: [String]? = nil, services: [AWSServiceName]? = nil) {
            self.accountIds = accountIds
            self.instances = instances
            self.services = services
        }

        public func validate(name: String) throws {
            try self.accountIds?.forEach {
                try validate($0, name: "accountIds[]", parent: name, max: 12)
                try validate($0, name: "accountIds[]", parent: name, min: 12)
                try validate($0, name: "accountIds[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.instances?.forEach {
                try validate($0, name: "instances[]", parent: name, max: 32)
                try validate($0, name: "instances[]", parent: name, min: 11)
                try validate($0, name: "instances[]", parent: name, pattern: "^i-[0-9a-z]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds = "AccountIds"
            case instances = "Instances"
            case services = "Services"
        }
    }

    public struct LineItem: AWSDecodableShape {
        ///  Information about assets.
        public let assetInformationList: [LineItemAssetInformation]?
        ///  The ID of the catalog item.
        public let catalogItemId: String?
        /// The ID of the line item.
        public let lineItemId: String?
        /// The ID of the previous line item.
        public let previousLineItemId: String?
        /// The ID of the previous order.
        public let previousOrderId: String?
        /// The quantity of the line item.
        public let quantity: Int?
        ///  Information about a line item shipment.
        public let shipmentInformation: ShipmentInformation?
        /// The status of the line item.
        public let status: LineItemStatus?

        @inlinable
        public init(assetInformationList: [LineItemAssetInformation]? = nil, catalogItemId: String? = nil, lineItemId: String? = nil, previousLineItemId: String? = nil, previousOrderId: String? = nil, quantity: Int? = nil, shipmentInformation: ShipmentInformation? = nil, status: LineItemStatus? = nil) {
            self.assetInformationList = assetInformationList
            self.catalogItemId = catalogItemId
            self.lineItemId = lineItemId
            self.previousLineItemId = previousLineItemId
            self.previousOrderId = previousOrderId
            self.quantity = quantity
            self.shipmentInformation = shipmentInformation
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case assetInformationList = "AssetInformationList"
            case catalogItemId = "CatalogItemId"
            case lineItemId = "LineItemId"
            case previousLineItemId = "PreviousLineItemId"
            case previousOrderId = "PreviousOrderId"
            case quantity = "Quantity"
            case shipmentInformation = "ShipmentInformation"
            case status = "Status"
        }
    }

    public struct LineItemAssetInformation: AWSDecodableShape {
        ///  The ID of the asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        ///  The MAC addresses of the asset.
        public let macAddressList: [String]?

        @inlinable
        public init(assetId: String? = nil, macAddressList: [String]? = nil) {
            self.assetId = assetId
            self.macAddressList = macAddressList
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case macAddressList = "MacAddressList"
        }
    }

    public struct LineItemRequest: AWSEncodableShape {
        /// The ID of the catalog item.
        public let catalogItemId: String?
        /// The quantity of a line item request.
        public let quantity: Int?

        @inlinable
        public init(catalogItemId: String? = nil, quantity: Int? = nil) {
            self.catalogItemId = catalogItemId
            self.quantity = quantity
        }

        public func validate(name: String) throws {
            try self.validate(self.catalogItemId, name: "catalogItemId", parent: name, max: 10)
            try self.validate(self.catalogItemId, name: "catalogItemId", parent: name, min: 1)
            try self.validate(self.catalogItemId, name: "catalogItemId", parent: name, pattern: "^OR-[A-Z0-9]{7}$")
            try self.validate(self.quantity, name: "quantity", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case catalogItemId = "CatalogItemId"
            case quantity = "Quantity"
        }
    }

    public struct ListAssetInstancesInput: AWSEncodableShape {
        /// Filters the results by account ID.
        public let accountIdFilter: [String]?
        /// Filters the results by asset ID.
        public let assetIdFilter: [String]?
        /// Filters the results by Amazon Web Services service.
        public let awsServiceFilter: [AWSServiceName]?
        /// Filters the results by instance ID.
        public let instanceTypeFilter: [String]?
        public let maxResults: Int?
        public let nextToken: String?
        /// The ID of the Outpost.
        public let outpostIdentifier: String

        @inlinable
        public init(accountIdFilter: [String]? = nil, assetIdFilter: [String]? = nil, awsServiceFilter: [AWSServiceName]? = nil, instanceTypeFilter: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, outpostIdentifier: String) {
            self.accountIdFilter = accountIdFilter
            self.assetIdFilter = assetIdFilter
            self.awsServiceFilter = awsServiceFilter
            self.instanceTypeFilter = instanceTypeFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outpostIdentifier = outpostIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.accountIdFilter, key: "AccountIdFilter")
            request.encodeQuery(self.assetIdFilter, key: "AssetIdFilter")
            request.encodeQuery(self.awsServiceFilter, key: "AwsServiceFilter")
            request.encodeQuery(self.instanceTypeFilter, key: "InstanceTypeFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.outpostIdentifier, key: "OutpostIdentifier")
        }

        public func validate(name: String) throws {
            try self.accountIdFilter?.forEach {
                try validate($0, name: "accountIdFilter[]", parent: name, max: 12)
                try validate($0, name: "accountIdFilter[]", parent: name, min: 12)
                try validate($0, name: "accountIdFilter[]", parent: name, pattern: "^\\d{12}$")
            }
            try self.assetIdFilter?.forEach {
                try validate($0, name: "assetIdFilter[]", parent: name, max: 100)
                try validate($0, name: "assetIdFilter[]", parent: name, min: 1)
                try validate($0, name: "assetIdFilter[]", parent: name, pattern: "^(\\w+)$")
            }
            try self.instanceTypeFilter?.forEach {
                try validate($0, name: "instanceTypeFilter[]", parent: name, max: 30)
                try validate($0, name: "instanceTypeFilter[]", parent: name, min: 3)
                try validate($0, name: "instanceTypeFilter[]", parent: name, pattern: "^[a-z0-9\\-\\.]+$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetInstancesOutput: AWSDecodableShape {
        /// List of instances owned by all accounts on the Outpost. Does not include Amazon EBS or Amazon S3 instances.
        public let assetInstances: [AssetInstance]?
        public let nextToken: String?

        @inlinable
        public init(assetInstances: [AssetInstance]? = nil, nextToken: String? = nil) {
            self.assetInstances = assetInstances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assetInstances = "AssetInstances"
            case nextToken = "NextToken"
        }
    }

    public struct ListAssetsInput: AWSEncodableShape {
        /// Filters the results by the host ID of a Dedicated Host.
        public let hostIdFilter: [String]?
        public let maxResults: Int?
        public let nextToken: String?
        ///  The ID or the Amazon Resource Name (ARN) of the Outpost.
        public let outpostIdentifier: String
        /// Filters the results by state.
        public let statusFilter: [AssetState]?

        @inlinable
        public init(hostIdFilter: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil, outpostIdentifier: String, statusFilter: [AssetState]? = nil) {
            self.hostIdFilter = hostIdFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outpostIdentifier = outpostIdentifier
            self.statusFilter = statusFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.hostIdFilter, key: "HostIdFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.outpostIdentifier, key: "OutpostIdentifier")
            request.encodeQuery(self.statusFilter, key: "StatusFilter")
        }

        public func validate(name: String) throws {
            try self.hostIdFilter?.forEach {
                try validate($0, name: "hostIdFilter[]", parent: name, max: 50)
                try validate($0, name: "hostIdFilter[]", parent: name, min: 1)
                try validate($0, name: "hostIdFilter[]", parent: name, pattern: "^[A-Za-z0-9-]*$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
            try self.validate(self.statusFilter, name: "statusFilter", parent: name, max: 3)
            try self.validate(self.statusFilter, name: "statusFilter", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssetsOutput: AWSDecodableShape {
        /// Information about the hardware assets.
        public let assets: [AssetInfo]?
        public let nextToken: String?

        @inlinable
        public init(assets: [AssetInfo]? = nil, nextToken: String? = nil) {
            self.assets = assets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case assets = "Assets"
            case nextToken = "NextToken"
        }
    }

    public struct ListBlockingInstancesForCapacityTaskInput: AWSEncodableShape {
        /// The ID of the capacity task.
        public let capacityTaskId: String
        public let maxResults: Int?
        public let nextToken: String?
        /// The ID or ARN of the Outpost associated with the specified capacity task.
        public let outpostIdentifier: String

        @inlinable
        public init(capacityTaskId: String, maxResults: Int? = nil, nextToken: String? = nil, outpostIdentifier: String) {
            self.capacityTaskId = capacityTaskId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outpostIdentifier = outpostIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.capacityTaskId, key: "CapacityTaskId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.outpostIdentifier, key: "OutpostIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, max: 21)
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, min: 21)
            try self.validate(self.capacityTaskId, name: "capacityTaskId", parent: name, pattern: "^cap-[a-f0-9]{17}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBlockingInstancesForCapacityTaskOutput: AWSDecodableShape {
        /// A list of all running Amazon EC2 instances on the Outpost. Stopping one or more of these instances can free up the capacity needed to run the capacity task.
        public let blockingInstances: [BlockingInstance]?
        public let nextToken: String?

        @inlinable
        public init(blockingInstances: [BlockingInstance]? = nil, nextToken: String? = nil) {
            self.blockingInstances = blockingInstances
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case blockingInstances = "BlockingInstances"
            case nextToken = "NextToken"
        }
    }

    public struct ListCapacityTasksInput: AWSEncodableShape {
        /// A list of statuses. For example, REQUESTED or WAITING_FOR_EVACUATION.
        public let capacityTaskStatusFilter: [CapacityTaskStatus]?
        public let maxResults: Int?
        public let nextToken: String?
        /// Filters the results by an Outpost ID or an Outpost ARN.
        public let outpostIdentifierFilter: String?

        @inlinable
        public init(capacityTaskStatusFilter: [CapacityTaskStatus]? = nil, maxResults: Int? = nil, nextToken: String? = nil, outpostIdentifierFilter: String? = nil) {
            self.capacityTaskStatusFilter = capacityTaskStatusFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outpostIdentifierFilter = outpostIdentifierFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.capacityTaskStatusFilter, key: "CapacityTaskStatusFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.outpostIdentifierFilter, key: "OutpostIdentifierFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.validate(self.outpostIdentifierFilter, name: "outpostIdentifierFilter", parent: name, max: 180)
            try self.validate(self.outpostIdentifierFilter, name: "outpostIdentifierFilter", parent: name, min: 1)
            try self.validate(self.outpostIdentifierFilter, name: "outpostIdentifierFilter", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCapacityTasksOutput: AWSDecodableShape {
        /// Lists all the capacity tasks.
        public let capacityTasks: [CapacityTaskSummary]?
        public let nextToken: String?

        @inlinable
        public init(capacityTasks: [CapacityTaskSummary]? = nil, nextToken: String? = nil) {
            self.capacityTasks = capacityTasks
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case capacityTasks = "CapacityTasks"
            case nextToken = "NextToken"
        }
    }

    public struct ListCatalogItemsInput: AWSEncodableShape {
        /// Filters the results by EC2 family (for example, M5).
        public let ec2FamilyFilter: [String]?
        /// Filters the results by item class.
        public let itemClassFilter: [CatalogItemClass]?
        public let maxResults: Int?
        public let nextToken: String?
        /// Filters the results by storage option.
        public let supportedStorageFilter: [SupportedStorageEnum]?

        @inlinable
        public init(ec2FamilyFilter: [String]? = nil, itemClassFilter: [CatalogItemClass]? = nil, maxResults: Int? = nil, nextToken: String? = nil, supportedStorageFilter: [SupportedStorageEnum]? = nil) {
            self.ec2FamilyFilter = ec2FamilyFilter
            self.itemClassFilter = itemClassFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.supportedStorageFilter = supportedStorageFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.ec2FamilyFilter, key: "EC2FamilyFilter")
            request.encodeQuery(self.itemClassFilter, key: "ItemClassFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.supportedStorageFilter, key: "SupportedStorageFilter")
        }

        public func validate(name: String) throws {
            try self.ec2FamilyFilter?.forEach {
                try validate($0, name: "ec2FamilyFilter[]", parent: name, max: 10)
                try validate($0, name: "ec2FamilyFilter[]", parent: name, min: 1)
                try validate($0, name: "ec2FamilyFilter[]", parent: name, pattern: "^[a-z0-9]+$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCatalogItemsOutput: AWSDecodableShape {
        /// Information about the catalog items.
        public let catalogItems: [CatalogItem]?
        public let nextToken: String?

        @inlinable
        public init(catalogItems: [CatalogItem]? = nil, nextToken: String? = nil) {
            self.catalogItems = catalogItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case catalogItems = "CatalogItems"
            case nextToken = "NextToken"
        }
    }

    public struct ListOrdersInput: AWSEncodableShape {
        public let maxResults: Int?
        public let nextToken: String?
        ///  The ID or the Amazon Resource Name (ARN) of the Outpost.
        public let outpostIdentifierFilter: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, outpostIdentifierFilter: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outpostIdentifierFilter = outpostIdentifierFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.outpostIdentifierFilter, key: "OutpostIdentifierFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.validate(self.outpostIdentifierFilter, name: "outpostIdentifierFilter", parent: name, max: 180)
            try self.validate(self.outpostIdentifierFilter, name: "outpostIdentifierFilter", parent: name, min: 1)
            try self.validate(self.outpostIdentifierFilter, name: "outpostIdentifierFilter", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrdersOutput: AWSDecodableShape {
        public let nextToken: String?
        ///  Information about the orders.
        public let orders: [OrderSummary]?

        @inlinable
        public init(nextToken: String? = nil, orders: [OrderSummary]? = nil) {
            self.nextToken = nextToken
            self.orders = orders
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case orders = "Orders"
        }
    }

    public struct ListOutpostsInput: AWSEncodableShape {
        /// Filters the results by Availability Zone (for example, us-east-1a).
        public let availabilityZoneFilter: [String]?
        /// Filters the results by AZ ID (for example, use1-az1).
        public let availabilityZoneIdFilter: [String]?
        /// Filters the results by the lifecycle status.
        public let lifeCycleStatusFilter: [String]?
        public let maxResults: Int?
        public let nextToken: String?

        @inlinable
        public init(availabilityZoneFilter: [String]? = nil, availabilityZoneIdFilter: [String]? = nil, lifeCycleStatusFilter: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.availabilityZoneFilter = availabilityZoneFilter
            self.availabilityZoneIdFilter = availabilityZoneIdFilter
            self.lifeCycleStatusFilter = lifeCycleStatusFilter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.availabilityZoneFilter, key: "AvailabilityZoneFilter")
            request.encodeQuery(self.availabilityZoneIdFilter, key: "AvailabilityZoneIdFilter")
            request.encodeQuery(self.lifeCycleStatusFilter, key: "LifeCycleStatusFilter")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.availabilityZoneFilter?.forEach {
                try validate($0, name: "availabilityZoneFilter[]", parent: name, max: 1000)
                try validate($0, name: "availabilityZoneFilter[]", parent: name, min: 1)
                try validate($0, name: "availabilityZoneFilter[]", parent: name, pattern: "^([a-zA-Z]+-){1,3}([a-zA-Z]+)?(\\d+[a-zA-Z]?)?$")
            }
            try self.validate(self.availabilityZoneFilter, name: "availabilityZoneFilter", parent: name, max: 5)
            try self.validate(self.availabilityZoneFilter, name: "availabilityZoneFilter", parent: name, min: 1)
            try self.availabilityZoneIdFilter?.forEach {
                try validate($0, name: "availabilityZoneIdFilter[]", parent: name, max: 255)
                try validate($0, name: "availabilityZoneIdFilter[]", parent: name, min: 1)
                try validate($0, name: "availabilityZoneIdFilter[]", parent: name, pattern: "^[a-zA-Z]+\\d-[a-zA-Z]+\\d$")
            }
            try self.validate(self.availabilityZoneIdFilter, name: "availabilityZoneIdFilter", parent: name, max: 5)
            try self.validate(self.availabilityZoneIdFilter, name: "availabilityZoneIdFilter", parent: name, min: 1)
            try self.lifeCycleStatusFilter?.forEach {
                try validate($0, name: "lifeCycleStatusFilter[]", parent: name, max: 20)
                try validate($0, name: "lifeCycleStatusFilter[]", parent: name, min: 1)
                try validate($0, name: "lifeCycleStatusFilter[]", parent: name, pattern: "^[ A-Za-z]+$")
            }
            try self.validate(self.lifeCycleStatusFilter, name: "lifeCycleStatusFilter", parent: name, max: 5)
            try self.validate(self.lifeCycleStatusFilter, name: "lifeCycleStatusFilter", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOutpostsOutput: AWSDecodableShape {
        public let nextToken: String?
        public let outposts: [Outpost]?

        @inlinable
        public init(nextToken: String? = nil, outposts: [Outpost]? = nil) {
            self.nextToken = nextToken
            self.outposts = outposts
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case outposts = "Outposts"
        }
    }

    public struct ListSitesInput: AWSEncodableShape {
        public let maxResults: Int?
        public let nextToken: String?
        /// Filters the results by city.
        public let operatingAddressCityFilter: [String]?
        /// Filters the results by country code.
        public let operatingAddressCountryCodeFilter: [String]?
        /// Filters the results by state or region.
        public let operatingAddressStateOrRegionFilter: [String]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, operatingAddressCityFilter: [String]? = nil, operatingAddressCountryCodeFilter: [String]? = nil, operatingAddressStateOrRegionFilter: [String]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.operatingAddressCityFilter = operatingAddressCityFilter
            self.operatingAddressCountryCodeFilter = operatingAddressCountryCodeFilter
            self.operatingAddressStateOrRegionFilter = operatingAddressStateOrRegionFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.operatingAddressCityFilter, key: "OperatingAddressCityFilter")
            request.encodeQuery(self.operatingAddressCountryCodeFilter, key: "OperatingAddressCountryCodeFilter")
            request.encodeQuery(self.operatingAddressStateOrRegionFilter, key: "OperatingAddressStateOrRegionFilter")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^(\\d+)##(\\S+)$")
            try self.operatingAddressCityFilter?.forEach {
                try validate($0, name: "operatingAddressCityFilter[]", parent: name, max: 50)
                try validate($0, name: "operatingAddressCityFilter[]", parent: name, min: 1)
                try validate($0, name: "operatingAddressCityFilter[]", parent: name, pattern: "^\\S[\\S ]*$")
            }
            try self.operatingAddressCountryCodeFilter?.forEach {
                try validate($0, name: "operatingAddressCountryCodeFilter[]", parent: name, max: 2)
                try validate($0, name: "operatingAddressCountryCodeFilter[]", parent: name, min: 2)
                try validate($0, name: "operatingAddressCountryCodeFilter[]", parent: name, pattern: "^[A-Z]{2}$")
            }
            try self.operatingAddressStateOrRegionFilter?.forEach {
                try validate($0, name: "operatingAddressStateOrRegionFilter[]", parent: name, max: 50)
                try validate($0, name: "operatingAddressStateOrRegionFilter[]", parent: name, min: 1)
                try validate($0, name: "operatingAddressStateOrRegionFilter[]", parent: name, pattern: "^\\S[\\S ]*$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSitesOutput: AWSDecodableShape {
        public let nextToken: String?
        public let sites: [Site]?

        @inlinable
        public init(nextToken: String? = nil, sites: [Site]? = nil) {
            self.nextToken = nextToken
            self.sites = sites
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case sites = "Sites"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:([a-z\\d-]+)/)[a-z]{2,8}-[a-f0-9]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The resource tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Order: AWSDecodableShape {
        /// The line items for the order
        public let lineItems: [LineItem]?
        /// The fulfillment date of the order.
        public let orderFulfilledDate: Date?
        /// The ID of the order.
        public let orderId: String?
        /// The submission date for the order.
        public let orderSubmissionDate: Date?
        /// The type of order.
        public let orderType: OrderType?
        ///  The ID of the Outpost in the order.
        public let outpostId: String?
        /// The payment option for the order.
        public let paymentOption: PaymentOption?
        /// The payment term.
        public let paymentTerm: PaymentTerm?
        /// The status of the order.    PREPARING - Order is received and being prepared.    IN_PROGRESS - Order is either being built or shipped. To get more details, see the line item status.    DELIVERED - Order was delivered to the Outpost site.    COMPLETED - Order is complete.    CANCELLED - Order is cancelled.    ERROR - Customer should contact support.    The following status are deprecated: RECEIVED, PENDING, PROCESSING, INSTALLING, and FULFILLED.
        public let status: OrderStatus?

        @inlinable
        public init(lineItems: [LineItem]? = nil, orderFulfilledDate: Date? = nil, orderId: String? = nil, orderSubmissionDate: Date? = nil, orderType: OrderType? = nil, outpostId: String? = nil, paymentOption: PaymentOption? = nil, paymentTerm: PaymentTerm? = nil, status: OrderStatus? = nil) {
            self.lineItems = lineItems
            self.orderFulfilledDate = orderFulfilledDate
            self.orderId = orderId
            self.orderSubmissionDate = orderSubmissionDate
            self.orderType = orderType
            self.outpostId = outpostId
            self.paymentOption = paymentOption
            self.paymentTerm = paymentTerm
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case lineItems = "LineItems"
            case orderFulfilledDate = "OrderFulfilledDate"
            case orderId = "OrderId"
            case orderSubmissionDate = "OrderSubmissionDate"
            case orderType = "OrderType"
            case outpostId = "OutpostId"
            case paymentOption = "PaymentOption"
            case paymentTerm = "PaymentTerm"
            case status = "Status"
        }
    }

    public struct OrderSummary: AWSDecodableShape {
        ///  The status of all line items in the order.
        public let lineItemCountsByStatus: [LineItemStatus: Int]?
        ///  The fulfilment date for the order.
        public let orderFulfilledDate: Date?
        ///  The ID of the order.
        public let orderId: String?
        ///  The submission date for the order.
        public let orderSubmissionDate: Date?
        /// The type of order.
        public let orderType: OrderType?
        ///  The ID of the Outpost.
        public let outpostId: String?
        /// The status of the order.    PREPARING - Order is received and is being prepared.    IN_PROGRESS - Order is either being built, shipped, or installed. For more information, see the LineItem status.    COMPLETED - Order is complete.    CANCELLED - Order is cancelled.    ERROR - Customer should contact support.    The following statuses are deprecated: RECEIVED, PENDING, PROCESSING, INSTALLING, and FULFILLED.
        public let status: OrderStatus?

        @inlinable
        public init(lineItemCountsByStatus: [LineItemStatus: Int]? = nil, orderFulfilledDate: Date? = nil, orderId: String? = nil, orderSubmissionDate: Date? = nil, orderType: OrderType? = nil, outpostId: String? = nil, status: OrderStatus? = nil) {
            self.lineItemCountsByStatus = lineItemCountsByStatus
            self.orderFulfilledDate = orderFulfilledDate
            self.orderId = orderId
            self.orderSubmissionDate = orderSubmissionDate
            self.orderType = orderType
            self.outpostId = outpostId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case lineItemCountsByStatus = "LineItemCountsByStatus"
            case orderFulfilledDate = "OrderFulfilledDate"
            case orderId = "OrderId"
            case orderSubmissionDate = "OrderSubmissionDate"
            case orderType = "OrderType"
            case outpostId = "OutpostId"
            case status = "Status"
        }
    }

    public struct Outpost: AWSDecodableShape {
        public let availabilityZone: String?
        public let availabilityZoneId: String?
        public let description: String?
        public let lifeCycleStatus: String?
        public let name: String?
        public let outpostArn: String?
        ///  The ID of the Outpost.
        public let outpostId: String?
        public let ownerId: String?
        public let siteArn: String?
        public let siteId: String?
        ///  The hardware type.
        public let supportedHardwareType: SupportedHardwareType?
        /// The Outpost tags.
        public let tags: [String: String]?

        @inlinable
        public init(availabilityZone: String? = nil, availabilityZoneId: String? = nil, description: String? = nil, lifeCycleStatus: String? = nil, name: String? = nil, outpostArn: String? = nil, outpostId: String? = nil, ownerId: String? = nil, siteArn: String? = nil, siteId: String? = nil, supportedHardwareType: SupportedHardwareType? = nil, tags: [String: String]? = nil) {
            self.availabilityZone = availabilityZone
            self.availabilityZoneId = availabilityZoneId
            self.description = description
            self.lifeCycleStatus = lifeCycleStatus
            self.name = name
            self.outpostArn = outpostArn
            self.outpostId = outpostId
            self.ownerId = ownerId
            self.siteArn = siteArn
            self.siteId = siteId
            self.supportedHardwareType = supportedHardwareType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "AvailabilityZone"
            case availabilityZoneId = "AvailabilityZoneId"
            case description = "Description"
            case lifeCycleStatus = "LifeCycleStatus"
            case name = "Name"
            case outpostArn = "OutpostArn"
            case outpostId = "OutpostId"
            case ownerId = "OwnerId"
            case siteArn = "SiteArn"
            case siteId = "SiteId"
            case supportedHardwareType = "SupportedHardwareType"
            case tags = "Tags"
        }
    }

    public struct RackPhysicalProperties: AWSEncodableShape & AWSDecodableShape {
        /// The type of fiber used to attach the Outpost to the network.
        public let fiberOpticCableType: FiberOpticCableType?
        /// The maximum rack weight that this site can support. NO_LIMIT is over 2000 lbs (907 kg).
        public let maximumSupportedWeightLbs: MaximumSupportedWeightLbs?
        /// The type of optical standard used to attach the Outpost to the network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see Network  in the Amazon Web Services Outposts User Guide.
        public let opticalStandard: OpticalStandard?
        /// The power connector for the hardware.
        public let powerConnector: PowerConnector?
        /// The power draw available at the hardware placement position for the rack.
        public let powerDrawKva: PowerDrawKva?
        /// The position of the power feed.
        public let powerFeedDrop: PowerFeedDrop?
        /// The power option that you can provide for hardware.
        public let powerPhase: PowerPhase?
        /// The number of uplinks each Outpost network device.
        public let uplinkCount: UplinkCount?
        /// The uplink speed the rack supports for the connection to the Region.
        public let uplinkGbps: UplinkGbps?

        @inlinable
        public init(fiberOpticCableType: FiberOpticCableType? = nil, maximumSupportedWeightLbs: MaximumSupportedWeightLbs? = nil, opticalStandard: OpticalStandard? = nil, powerConnector: PowerConnector? = nil, powerDrawKva: PowerDrawKva? = nil, powerFeedDrop: PowerFeedDrop? = nil, powerPhase: PowerPhase? = nil, uplinkCount: UplinkCount? = nil, uplinkGbps: UplinkGbps? = nil) {
            self.fiberOpticCableType = fiberOpticCableType
            self.maximumSupportedWeightLbs = maximumSupportedWeightLbs
            self.opticalStandard = opticalStandard
            self.powerConnector = powerConnector
            self.powerDrawKva = powerDrawKva
            self.powerFeedDrop = powerFeedDrop
            self.powerPhase = powerPhase
            self.uplinkCount = uplinkCount
            self.uplinkGbps = uplinkGbps
        }

        private enum CodingKeys: String, CodingKey {
            case fiberOpticCableType = "FiberOpticCableType"
            case maximumSupportedWeightLbs = "MaximumSupportedWeightLbs"
            case opticalStandard = "OpticalStandard"
            case powerConnector = "PowerConnector"
            case powerDrawKva = "PowerDrawKva"
            case powerFeedDrop = "PowerFeedDrop"
            case powerPhase = "PowerPhase"
            case uplinkCount = "UplinkCount"
            case uplinkGbps = "UplinkGbps"
        }
    }

    public struct ShipmentInformation: AWSDecodableShape {
        ///  The carrier of the shipment.
        public let shipmentCarrier: ShipmentCarrier?
        ///  The tracking number of the shipment.
        public let shipmentTrackingNumber: String?

        @inlinable
        public init(shipmentCarrier: ShipmentCarrier? = nil, shipmentTrackingNumber: String? = nil) {
            self.shipmentCarrier = shipmentCarrier
            self.shipmentTrackingNumber = shipmentTrackingNumber
        }

        private enum CodingKeys: String, CodingKey {
            case shipmentCarrier = "ShipmentCarrier"
            case shipmentTrackingNumber = "ShipmentTrackingNumber"
        }
    }

    public struct Site: AWSDecodableShape {
        public let accountId: String?
        public let description: String?
        public let name: String?
        ///  Notes about a site.
        public let notes: String?
        ///  City where the hardware is installed and powered on.
        public let operatingAddressCity: String?
        ///  The ISO-3166 two-letter country code where the hardware is installed and powered on.
        public let operatingAddressCountryCode: String?
        ///  State or region where the hardware is installed and powered on.
        public let operatingAddressStateOrRegion: String?
        ///  Information about the physical and logistical details for a rack at the site.
        public let rackPhysicalProperties: RackPhysicalProperties?
        public let siteArn: String?
        public let siteId: String?
        /// The site tags.
        public let tags: [String: String]?

        @inlinable
        public init(accountId: String? = nil, description: String? = nil, name: String? = nil, notes: String? = nil, operatingAddressCity: String? = nil, operatingAddressCountryCode: String? = nil, operatingAddressStateOrRegion: String? = nil, rackPhysicalProperties: RackPhysicalProperties? = nil, siteArn: String? = nil, siteId: String? = nil, tags: [String: String]? = nil) {
            self.accountId = accountId
            self.description = description
            self.name = name
            self.notes = notes
            self.operatingAddressCity = operatingAddressCity
            self.operatingAddressCountryCode = operatingAddressCountryCode
            self.operatingAddressStateOrRegion = operatingAddressStateOrRegion
            self.rackPhysicalProperties = rackPhysicalProperties
            self.siteArn = siteArn
            self.siteId = siteId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case description = "Description"
            case name = "Name"
            case notes = "Notes"
            case operatingAddressCity = "OperatingAddressCity"
            case operatingAddressCountryCode = "OperatingAddressCountryCode"
            case operatingAddressStateOrRegion = "OperatingAddressStateOrRegion"
            case rackPhysicalProperties = "RackPhysicalProperties"
            case siteArn = "SiteArn"
            case siteId = "SiteId"
            case tags = "Tags"
        }
    }

    public struct StartCapacityTaskInput: AWSEncodableShape {
        /// The ID of the Outpost asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        /// You can request a dry run to determine if the instance type and instance size changes is above or below available instance capacity. Requesting a dry run does not make any changes to your plan.
        public let dryRun: Bool?
        /// The instance pools specified in the capacity task.
        public let instancePools: [InstanceTypeCapacity]
        /// List of user-specified running instances that must not be stopped in order to free up the capacity needed to run the capacity task.
        public let instancesToExclude: InstancesToExclude?
        /// The ID of the Amazon Web Services Outposts order associated with the specified capacity task.
        public let orderId: String?
        /// The ID or ARN of the Outposts associated with the specified capacity task.
        public let outpostIdentifier: String
        /// Specify one of the following options in case an instance is blocking the capacity task from running.    WAIT_FOR_EVACUATION - Checks every 10 minutes over 48 hours to determine if instances have stopped and capacity is available to complete the task.    FAIL_TASK - The capacity task fails.
        public let taskActionOnBlockingInstances: TaskActionOnBlockingInstances?

        @inlinable
        public init(assetId: String? = nil, dryRun: Bool? = nil, instancePools: [InstanceTypeCapacity], instancesToExclude: InstancesToExclude? = nil, orderId: String? = nil, outpostIdentifier: String, taskActionOnBlockingInstances: TaskActionOnBlockingInstances? = nil) {
            self.assetId = assetId
            self.dryRun = dryRun
            self.instancePools = instancePools
            self.instancesToExclude = instancesToExclude
            self.orderId = orderId
            self.outpostIdentifier = outpostIdentifier
            self.taskActionOnBlockingInstances = taskActionOnBlockingInstances
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.assetId, forKey: .assetId)
            try container.encodeIfPresent(self.dryRun, forKey: .dryRun)
            try container.encode(self.instancePools, forKey: .instancePools)
            try container.encodeIfPresent(self.instancesToExclude, forKey: .instancesToExclude)
            try container.encodeIfPresent(self.orderId, forKey: .orderId)
            request.encodePath(self.outpostIdentifier, key: "OutpostIdentifier")
            try container.encodeIfPresent(self.taskActionOnBlockingInstances, forKey: .taskActionOnBlockingInstances)
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 10)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 10)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^\\d{10}$")
            try self.instancePools.forEach {
                try $0.validate(name: "\(name).instancePools[]")
            }
            try self.instancesToExclude?.validate(name: "\(name).instancesToExclude")
            try self.validate(self.orderId, name: "orderId", parent: name, max: 20)
            try self.validate(self.orderId, name: "orderId", parent: name, min: 1)
            try self.validate(self.orderId, name: "orderId", parent: name, pattern: "^oo-[a-f0-9]{17}$")
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, max: 180)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, min: 1)
            try self.validate(self.outpostIdentifier, name: "outpostIdentifier", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case dryRun = "DryRun"
            case instancePools = "InstancePools"
            case instancesToExclude = "InstancesToExclude"
            case orderId = "OrderId"
            case taskActionOnBlockingInstances = "TaskActionOnBlockingInstances"
        }
    }

    public struct StartCapacityTaskOutput: AWSDecodableShape {
        /// The ID of the asset. An Outpost asset can be a single server within an Outposts rack or an Outposts server configuration.
        public let assetId: String?
        /// ID of the capacity task that you want to start.
        public let capacityTaskId: String?
        /// Status of the specified capacity task.
        public let capacityTaskStatus: CapacityTaskStatus?
        /// Date that the specified capacity task ran successfully.
        public let completionDate: Date?
        /// Date that the specified capacity task was created.
        public let creationDate: Date?
        /// Results of the dry run showing if the specified capacity task is above or below the available instance capacity.
        public let dryRun: Bool?
        /// Reason that the specified capacity task failed.
        public let failed: CapacityTaskFailure?
        /// User-specified instances that must not be stopped in order to free up the capacity needed to run the capacity task.
        public let instancesToExclude: InstancesToExclude?
        /// Date that the specified capacity task was last modified.
        public let lastModifiedDate: Date?
        /// ID of the Amazon Web Services Outposts order of the host associated with the capacity task.
        public let orderId: String?
        /// ID of the Outpost associated with the capacity task.
        public let outpostId: String?
        /// List of the instance pools requested in the specified capacity task.
        public let requestedInstancePools: [InstanceTypeCapacity]?
        /// User-specified option in case an instance is blocking the capacity task from running.    WAIT_FOR_EVACUATION - Checks every 10 minutes over 48 hours to determine if instances have stopped and capacity is available to complete the task.    FAIL_TASK - The capacity task fails.
        public let taskActionOnBlockingInstances: TaskActionOnBlockingInstances?

        @inlinable
        public init(assetId: String? = nil, capacityTaskId: String? = nil, capacityTaskStatus: CapacityTaskStatus? = nil, completionDate: Date? = nil, creationDate: Date? = nil, dryRun: Bool? = nil, failed: CapacityTaskFailure? = nil, instancesToExclude: InstancesToExclude? = nil, lastModifiedDate: Date? = nil, orderId: String? = nil, outpostId: String? = nil, requestedInstancePools: [InstanceTypeCapacity]? = nil, taskActionOnBlockingInstances: TaskActionOnBlockingInstances? = nil) {
            self.assetId = assetId
            self.capacityTaskId = capacityTaskId
            self.capacityTaskStatus = capacityTaskStatus
            self.completionDate = completionDate
            self.creationDate = creationDate
            self.dryRun = dryRun
            self.failed = failed
            self.instancesToExclude = instancesToExclude
            self.lastModifiedDate = lastModifiedDate
            self.orderId = orderId
            self.outpostId = outpostId
            self.requestedInstancePools = requestedInstancePools
            self.taskActionOnBlockingInstances = taskActionOnBlockingInstances
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case capacityTaskId = "CapacityTaskId"
            case capacityTaskStatus = "CapacityTaskStatus"
            case completionDate = "CompletionDate"
            case creationDate = "CreationDate"
            case dryRun = "DryRun"
            case failed = "Failed"
            case instancesToExclude = "InstancesToExclude"
            case lastModifiedDate = "LastModifiedDate"
            case orderId = "OrderId"
            case outpostId = "OutpostId"
            case requestedInstancePools = "RequestedInstancePools"
            case taskActionOnBlockingInstances = "TaskActionOnBlockingInstances"
        }
    }

    public struct StartConnectionRequest: AWSEncodableShape {
        ///  The ID of the Outpost server.
        public let assetId: String
        ///  The public key of the client.
        public let clientPublicKey: String
        ///  The serial number of the dongle.
        public let deviceSerialNumber: String?
        ///  The device index of the network interface on the Outpost server.
        public let networkInterfaceDeviceIndex: Int

        @inlinable
        public init(assetId: String, clientPublicKey: String, deviceSerialNumber: String? = nil, networkInterfaceDeviceIndex: Int = 0) {
            self.assetId = assetId
            self.clientPublicKey = clientPublicKey
            self.deviceSerialNumber = deviceSerialNumber
            self.networkInterfaceDeviceIndex = networkInterfaceDeviceIndex
        }

        public func validate(name: String) throws {
            try self.validate(self.assetId, name: "assetId", parent: name, max: 100)
            try self.validate(self.assetId, name: "assetId", parent: name, min: 1)
            try self.validate(self.assetId, name: "assetId", parent: name, pattern: "^(\\w+)$")
            try self.validate(self.clientPublicKey, name: "clientPublicKey", parent: name, max: 44)
            try self.validate(self.clientPublicKey, name: "clientPublicKey", parent: name, min: 44)
            try self.validate(self.clientPublicKey, name: "clientPublicKey", parent: name, pattern: "^[a-zA-Z0-9/+]{43}=$")
            try self.validate(self.deviceSerialNumber, name: "deviceSerialNumber", parent: name, max: 100)
            try self.validate(self.deviceSerialNumber, name: "deviceSerialNumber", parent: name, min: 1)
            try self.validate(self.deviceSerialNumber, name: "deviceSerialNumber", parent: name, pattern: "^(\\w+)$")
            try self.validate(self.networkInterfaceDeviceIndex, name: "networkInterfaceDeviceIndex", parent: name, max: 1)
            try self.validate(self.networkInterfaceDeviceIndex, name: "networkInterfaceDeviceIndex", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case assetId = "AssetId"
            case clientPublicKey = "ClientPublicKey"
            case deviceSerialNumber = "DeviceSerialNumber"
            case networkInterfaceDeviceIndex = "NetworkInterfaceDeviceIndex"
        }
    }

    public struct StartConnectionResponse: AWSDecodableShape {
        ///  The ID of the connection.
        public let connectionId: String?
        ///  The underlay IP address.
        public let underlayIpAddress: String?

        @inlinable
        public init(connectionId: String? = nil, underlayIpAddress: String? = nil) {
            self.connectionId = connectionId
            self.underlayIpAddress = underlayIpAddress
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "ConnectionId"
            case underlayIpAddress = "UnderlayIpAddress"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:([a-z\\d-]+)/)[a-z]{2,8}-[a-f0-9]{17}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\S \\n]+$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:([a-z\\d-]+)/)[a-z]{2,8}-[a-f0-9]{17}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateOutpostInput: AWSEncodableShape {
        public let description: String?
        public let name: String?
        ///  The ID or ARN of the Outpost.
        public let outpostId: String
        ///  The type of hardware for this Outpost.
        public let supportedHardwareType: SupportedHardwareType?

        @inlinable
        public init(description: String? = nil, name: String? = nil, outpostId: String, supportedHardwareType: SupportedHardwareType? = nil) {
            self.description = description
            self.name = name
            self.outpostId = outpostId
            self.supportedHardwareType = supportedHardwareType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.outpostId, key: "OutpostId")
            try container.encodeIfPresent(self.supportedHardwareType, forKey: .supportedHardwareType)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S ]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S ]+$")
            try self.validate(self.outpostId, name: "outpostId", parent: name, max: 180)
            try self.validate(self.outpostId, name: "outpostId", parent: name, min: 1)
            try self.validate(self.outpostId, name: "outpostId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:outpost/)?op-[a-f0-9]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case supportedHardwareType = "SupportedHardwareType"
        }
    }

    public struct UpdateOutpostOutput: AWSDecodableShape {
        public let outpost: Outpost?

        @inlinable
        public init(outpost: Outpost? = nil) {
            self.outpost = outpost
        }

        private enum CodingKeys: String, CodingKey {
            case outpost = "Outpost"
        }
    }

    public struct UpdateSiteAddressInput: AWSEncodableShape {
        ///  The address for the site.
        public let address: Address
        ///  The type of the address.
        public let addressType: AddressType
        ///  The ID or the Amazon Resource Name (ARN) of the site.
        public let siteId: String

        @inlinable
        public init(address: Address, addressType: AddressType, siteId: String) {
            self.address = address
            self.addressType = addressType
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.address, forKey: .address)
            try container.encode(self.addressType, forKey: .addressType)
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.address.validate(name: "\(name).address")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 255)
            try self.validate(self.siteId, name: "siteId", parent: name, min: 1)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:site/)?(os-[a-f0-9]{17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case addressType = "AddressType"
        }
    }

    public struct UpdateSiteAddressOutput: AWSDecodableShape {
        ///  Information about an address.
        public let address: Address?
        ///  The type of the address.
        public let addressType: AddressType?

        @inlinable
        public init(address: Address? = nil, addressType: AddressType? = nil) {
            self.address = address
            self.addressType = addressType
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case addressType = "AddressType"
        }
    }

    public struct UpdateSiteInput: AWSEncodableShape {
        public let description: String?
        public let name: String?
        /// Notes about a site.
        public let notes: String?
        ///  The ID or the Amazon Resource Name (ARN) of the site.
        public let siteId: String

        @inlinable
        public init(description: String? = nil, name: String? = nil, notes: String? = nil, siteId: String) {
            self.description = description
            self.name = name
            self.notes = notes
            self.siteId = siteId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.notes, forKey: .notes)
            request.encodePath(self.siteId, key: "SiteId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1001)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\S ]+$")
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\S ]+$")
            try self.validate(self.notes, name: "notes", parent: name, max: 2000)
            try self.validate(self.notes, name: "notes", parent: name, min: 1)
            try self.validate(self.notes, name: "notes", parent: name, pattern: "^[\\S \\n]+$")
            try self.validate(self.siteId, name: "siteId", parent: name, max: 255)
            try self.validate(self.siteId, name: "siteId", parent: name, min: 1)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:site/)?(os-[a-f0-9]{17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case notes = "Notes"
        }
    }

    public struct UpdateSiteOutput: AWSDecodableShape {
        public let site: Site?

        @inlinable
        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }

    public struct UpdateSiteRackPhysicalPropertiesInput: AWSEncodableShape {
        /// The type of fiber that you will use to attach the Outpost to your network.
        public let fiberOpticCableType: FiberOpticCableType?
        /// The maximum rack weight that this site can support. NO_LIMIT is over 2000lbs.
        public let maximumSupportedWeightLbs: MaximumSupportedWeightLbs?
        /// The type of optical standard that you will use to attach the Outpost to your network. This field is dependent on uplink speed, fiber type, and distance to the upstream device. For more information about networking requirements for racks, see Network  in the Amazon Web Services Outposts User Guide.     OPTIC_10GBASE_SR: 10GBASE-SR    OPTIC_10GBASE_IR: 10GBASE-IR    OPTIC_10GBASE_LR: 10GBASE-LR    OPTIC_40GBASE_SR: 40GBASE-SR    OPTIC_40GBASE_ESR: 40GBASE-ESR    OPTIC_40GBASE_IR4_LR4L: 40GBASE-IR (LR4L)    OPTIC_40GBASE_LR4: 40GBASE-LR4    OPTIC_100GBASE_SR4: 100GBASE-SR4    OPTIC_100GBASE_CWDM4: 100GBASE-CWDM4    OPTIC_100GBASE_LR4: 100GBASE-LR4    OPTIC_100G_PSM4_MSA: 100G PSM4 MSA    OPTIC_1000BASE_LX: 1000Base-LX    OPTIC_1000BASE_SX : 1000Base-SX
        public let opticalStandard: OpticalStandard?
        /// The power connector that Amazon Web Services should plan to provide for connections to the hardware. Note the correlation between PowerPhase and PowerConnector.    Single-phase AC feed    L6-30P  (common in US); 30A; single phase    IEC309 (blue)  P+N+E, 6hr; 32 A; single phase     Three-phase AC feed    AH530P7W (red)  3P+N+E, 7hr; 30A; three phase    AH532P6W (red)  3P+N+E, 6hr; 32A; three phase    CS8365C  (common in US); 3P+E, 50A; three phase
        public let powerConnector: PowerConnector?
        /// The power draw, in kVA, available at the hardware placement position for the rack.
        public let powerDrawKva: PowerDrawKva?
        /// Indicates whether the power feed comes above or below the rack.
        public let powerFeedDrop: PowerFeedDrop?
        /// The power option that you can provide for hardware.    Single-phase AC feed: 200 V to 277 V, 50 Hz or 60 Hz   Three-phase AC feed: 346 V to 480 V, 50 Hz or 60 Hz
        public let powerPhase: PowerPhase?
        ///  The ID or the Amazon Resource Name (ARN) of the site.
        public let siteId: String
        /// Racks come with two Outpost network devices. Depending on the supported uplink speed at the site, the Outpost network devices provide a variable number of uplinks. Specify the number of uplinks for each Outpost network device that you intend to use to connect the rack to your network. Note the correlation between UplinkGbps and UplinkCount.    1Gbps - Uplinks available: 1, 2, 4, 6, 8   10Gbps - Uplinks available: 1, 2, 4, 8, 12, 16   40 and 100 Gbps- Uplinks available: 1, 2, 4
        public let uplinkCount: UplinkCount?
        /// The uplink speed the rack should support for the connection to the Region.
        public let uplinkGbps: UplinkGbps?

        @inlinable
        public init(fiberOpticCableType: FiberOpticCableType? = nil, maximumSupportedWeightLbs: MaximumSupportedWeightLbs? = nil, opticalStandard: OpticalStandard? = nil, powerConnector: PowerConnector? = nil, powerDrawKva: PowerDrawKva? = nil, powerFeedDrop: PowerFeedDrop? = nil, powerPhase: PowerPhase? = nil, siteId: String, uplinkCount: UplinkCount? = nil, uplinkGbps: UplinkGbps? = nil) {
            self.fiberOpticCableType = fiberOpticCableType
            self.maximumSupportedWeightLbs = maximumSupportedWeightLbs
            self.opticalStandard = opticalStandard
            self.powerConnector = powerConnector
            self.powerDrawKva = powerDrawKva
            self.powerFeedDrop = powerFeedDrop
            self.powerPhase = powerPhase
            self.siteId = siteId
            self.uplinkCount = uplinkCount
            self.uplinkGbps = uplinkGbps
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.fiberOpticCableType, forKey: .fiberOpticCableType)
            try container.encodeIfPresent(self.maximumSupportedWeightLbs, forKey: .maximumSupportedWeightLbs)
            try container.encodeIfPresent(self.opticalStandard, forKey: .opticalStandard)
            try container.encodeIfPresent(self.powerConnector, forKey: .powerConnector)
            try container.encodeIfPresent(self.powerDrawKva, forKey: .powerDrawKva)
            try container.encodeIfPresent(self.powerFeedDrop, forKey: .powerFeedDrop)
            try container.encodeIfPresent(self.powerPhase, forKey: .powerPhase)
            request.encodePath(self.siteId, key: "SiteId")
            try container.encodeIfPresent(self.uplinkCount, forKey: .uplinkCount)
            try container.encodeIfPresent(self.uplinkGbps, forKey: .uplinkGbps)
        }

        public func validate(name: String) throws {
            try self.validate(self.siteId, name: "siteId", parent: name, max: 255)
            try self.validate(self.siteId, name: "siteId", parent: name, min: 1)
            try self.validate(self.siteId, name: "siteId", parent: name, pattern: "^(arn:aws([a-z-]+)?:outposts:[a-z\\d-]+:\\d{12}:site/)?(os-[a-f0-9]{17})$")
        }

        private enum CodingKeys: String, CodingKey {
            case fiberOpticCableType = "FiberOpticCableType"
            case maximumSupportedWeightLbs = "MaximumSupportedWeightLbs"
            case opticalStandard = "OpticalStandard"
            case powerConnector = "PowerConnector"
            case powerDrawKva = "PowerDrawKva"
            case powerFeedDrop = "PowerFeedDrop"
            case powerPhase = "PowerPhase"
            case uplinkCount = "UplinkCount"
            case uplinkGbps = "UplinkGbps"
        }
    }

    public struct UpdateSiteRackPhysicalPropertiesOutput: AWSDecodableShape {
        public let site: Site?

        @inlinable
        public init(site: Site? = nil) {
            self.site = site
        }

        private enum CodingKeys: String, CodingKey {
            case site = "Site"
        }
    }
}

// MARK: - Errors

/// Error enum for Outposts
public struct OutpostsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case notFoundException = "NotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Outposts
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have permission to perform this operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting this resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal error has occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified request is not valid.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// You have exceeded a service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// A parameter is not valid.
    public static var validationException: Self { .init(.validationException) }
}

extension OutpostsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": Outposts.ConflictException.self
    ]
}

extension OutpostsErrorType: Equatable {
    public static func == (lhs: OutpostsErrorType, rhs: OutpostsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension OutpostsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
