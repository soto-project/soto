//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ApiGatewayV2 {
    // MARK: Enums

    public enum AuthorizationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIam = "AWS_IAM"
        case custom = "CUSTOM"
        case jwt = "JWT"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum AuthorizerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jwt = "JWT"
        case request = "REQUEST"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internet = "INTERNET"
        case vpcLink = "VPC_LINK"
        public var description: String { return self.rawValue }
    }

    public enum ContentHandlingStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case convertToBinary = "CONVERT_TO_BINARY"
        case convertToText = "CONVERT_TO_TEXT"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deployed = "DEPLOYED"
        case failed = "FAILED"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum DomainNameStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case pendingCertificateReimport = "PENDING_CERTIFICATE_REIMPORT"
        case pendingOwnershipVerification = "PENDING_OWNERSHIP_VERIFICATION"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum EndpointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case edge = "EDGE"
        case regional = "REGIONAL"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case awsProxy = "AWS_PROXY"
        case http = "HTTP"
        case httpProxy = "HTTP_PROXY"
        case mock = "MOCK"
        public var description: String { return self.rawValue }
    }

    public enum IpAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dualstack = "dualstack"
        case ipv4 = "ipv4"
        public var description: String { return self.rawValue }
    }

    public enum LoggingLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case error = "ERROR"
        case info = "INFO"
        case off = "OFF"
        public var description: String { return self.rawValue }
    }

    public enum PassthroughBehavior: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case never = "NEVER"
        case whenNoMatch = "WHEN_NO_MATCH"
        case whenNoTemplates = "WHEN_NO_TEMPLATES"
        public var description: String { return self.rawValue }
    }

    public enum ProtocolType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case http = "HTTP"
        case websocket = "WEBSOCKET"
        public var description: String { return self.rawValue }
    }

    public enum SecurityPolicy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case tls10 = "TLS_1_0"
        case tls12 = "TLS_1_2"
        public var description: String { return self.rawValue }
    }

    public enum VpcLinkStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case failed = "FAILED"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum VpcLinkVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccessLogSettings: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the CloudWatch Logs log group to receive access logs.
        public let destinationArn: String?
        /// A single line format of the access logs of data, as specified by selected $context variables. The format must include at least $context.requestId.
        public let format: String?

        @inlinable
        public init(destinationArn: String? = nil, format: String? = nil) {
            self.destinationArn = destinationArn
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "destinationArn"
            case format = "format"
        }
    }

    public struct Api: AWSDecodableShape {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public let apiGatewayManaged: Bool?
        /// The API ID.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public let corsConfiguration: Cors?
        /// The timestamp when the API was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public let importInfo: [String]?
        /// The IP address types that can invoke the API.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// The API protocol.
        public let protocolType: ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// A collection of tags associated with the API.
        public let tags: [String: String]?
        /// A version identifier for the API.
        public let version: String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public let warnings: [String]?

        @inlinable
        public init(apiEndpoint: String? = nil, apiGatewayManaged: Bool? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, createdDate: Date? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, importInfo: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocolType: ProtocolType? = nil, routeSelectionExpression: String? = nil, tags: [String: String]? = nil, version: String? = nil, warnings: [String]? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "apiEndpoint"
            case apiGatewayManaged = "apiGatewayManaged"
            case apiId = "apiId"
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case createdDate = "createdDate"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case importInfo = "importInfo"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case protocolType = "protocolType"
            case routeSelectionExpression = "routeSelectionExpression"
            case tags = "tags"
            case version = "version"
            case warnings = "warnings"
        }
    }

    public struct ApiMapping: AWSDecodableShape {
        /// The API identifier.
        public let apiId: String?
        /// The API mapping identifier.
        public let apiMappingId: String?
        /// The API mapping key.
        public let apiMappingKey: String?
        /// The API stage.
        public let stage: String?

        @inlinable
        public init(apiId: String? = nil, apiMappingId: String? = nil, apiMappingKey: String? = nil, stage: String? = nil) {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case apiMappingId = "apiMappingId"
            case apiMappingKey = "apiMappingKey"
            case stage = "stage"
        }
    }

    public struct Authorizer: AWSDecodableShape {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public let authorizerCredentialsArn: String?
        /// The authorizer identifier.
        public let authorizerId: String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see Working with AWS Lambda authorizers for HTTP APIs.
        public let authorizerPayloadFormatVersion: String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public let authorizerResultTtlInSeconds: Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public let authorizerType: AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public let authorizerUri: String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see Working with AWS Lambda authorizers for HTTP APIs
        public let enableSimpleResponses: Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see Working with AWS Lambda authorizers for HTTP APIs. For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public let identitySource: [String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public let identityValidationExpression: String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public let jwtConfiguration: JWTConfiguration?
        /// The name of the authorizer.
        public let name: String?

        @inlinable
        public init(authorizerCredentialsArn: String? = nil, authorizerId: String? = nil, authorizerPayloadFormatVersion: String? = nil, authorizerResultTtlInSeconds: Int? = nil, authorizerType: AuthorizerType? = nil, authorizerUri: String? = nil, enableSimpleResponses: Bool? = nil, identitySource: [String]? = nil, identityValidationExpression: String? = nil, jwtConfiguration: JWTConfiguration? = nil, name: String? = nil) {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerCredentialsArn = "authorizerCredentialsArn"
            case authorizerId = "authorizerId"
            case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
            case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
            case authorizerType = "authorizerType"
            case authorizerUri = "authorizerUri"
            case enableSimpleResponses = "enableSimpleResponses"
            case identitySource = "identitySource"
            case identityValidationExpression = "identityValidationExpression"
            case jwtConfiguration = "jwtConfiguration"
            case name = "name"
        }
    }

    public struct Cors: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether credentials are included in the CORS request. Supported only for HTTP APIs.
        public let allowCredentials: Bool?
        /// Represents a collection of allowed headers. Supported only for HTTP APIs.
        public let allowHeaders: [String]?
        /// Represents a collection of allowed HTTP methods. Supported only for HTTP APIs.
        public let allowMethods: [String]?
        /// Represents a collection of allowed origins. Supported only for HTTP APIs.
        public let allowOrigins: [String]?
        /// Represents a collection of exposed headers. Supported only for HTTP APIs.
        public let exposeHeaders: [String]?
        /// The number of seconds that the browser should cache preflight request results. Supported only for HTTP APIs.
        public let maxAge: Int?

        @inlinable
        public init(allowCredentials: Bool? = nil, allowHeaders: [String]? = nil, allowMethods: [String]? = nil, allowOrigins: [String]? = nil, exposeHeaders: [String]? = nil, maxAge: Int? = nil) {
            self.allowCredentials = allowCredentials
            self.allowHeaders = allowHeaders
            self.allowMethods = allowMethods
            self.allowOrigins = allowOrigins
            self.exposeHeaders = exposeHeaders
            self.maxAge = maxAge
        }

        public func validate(name: String) throws {
            try self.validate(self.maxAge, name: "maxAge", parent: name, max: 86400)
            try self.validate(self.maxAge, name: "maxAge", parent: name, min: -1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowCredentials = "allowCredentials"
            case allowHeaders = "allowHeaders"
            case allowMethods = "allowMethods"
            case allowOrigins = "allowOrigins"
            case exposeHeaders = "exposeHeaders"
            case maxAge = "maxAge"
        }
    }

    public struct CreateApiMappingRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String?
        /// The API mapping key.
        public let apiMappingKey: String?
        /// The domain name.
        public let domainName: String
        /// The API stage.
        public let stage: String?

        @inlinable
        public init(apiId: String? = nil, apiMappingKey: String? = nil, domainName: String, stage: String? = nil) {
            self.apiId = apiId
            self.apiMappingKey = apiMappingKey
            self.domainName = domainName
            self.stage = stage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.apiId, forKey: .apiId)
            try container.encodeIfPresent(self.apiMappingKey, forKey: .apiMappingKey)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.stage, forKey: .stage)
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case apiMappingKey = "apiMappingKey"
            case stage = "stage"
        }
    }

    public struct CreateApiMappingResponse: AWSDecodableShape {
        /// The API identifier.
        public let apiId: String?
        /// The API mapping identifier.
        public let apiMappingId: String?
        /// The API mapping key.
        public let apiMappingKey: String?
        /// The API stage.
        public let stage: String?

        @inlinable
        public init(apiId: String? = nil, apiMappingId: String? = nil, apiMappingKey: String? = nil, stage: String? = nil) {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case apiMappingId = "apiMappingId"
            case apiMappingKey = "apiMappingKey"
            case stage = "stage"
        }
    }

    public struct CreateApiRequest: AWSEncodableShape {
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs. See Configuring CORS for more information.
        public let corsConfiguration: Cors?
        /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null. Currently, this property is not used for HTTP integrations. Supported only for HTTP APIs.
        public let credentialsArn: String?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The IP address types that can invoke the API.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// The API protocol.
        public let protocolType: ProtocolType?
        /// This property is part of quick create. If you don't specify a routeKey, a default route of $default is created. The $default route acts as a catch-all for any request made to your API, for a particular stage. The $default route key can't be modified. You can add routes after creating the API, and you can update the route keys of additional routes. Supported only for HTTP APIs.
        public let routeKey: String?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public let tags: [String: String]?
        /// This property is part of quick create. Quick create produces an API with an integration, a default catch-all route, and a default stage which is configured to automatically deploy changes. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. Supported only for HTTP APIs.
        public let target: String?
        /// A version identifier for the API.
        public let version: String?

        @inlinable
        public init(apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, credentialsArn: String? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocolType: ProtocolType? = nil, routeKey: String? = nil, routeSelectionExpression: String? = nil, tags: [String: String]? = nil, target: String? = nil, version: String? = nil) {
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.credentialsArn = credentialsArn
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeKey = routeKey
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.target = target
            self.version = version
        }

        public func validate(name: String) throws {
            try self.corsConfiguration?.validate(name: "\(name).corsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case protocolType = "protocolType"
            case routeKey = "routeKey"
            case routeSelectionExpression = "routeSelectionExpression"
            case tags = "tags"
            case target = "target"
            case version = "version"
        }
    }

    public struct CreateApiResponse: AWSDecodableShape {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public let apiGatewayManaged: Bool?
        /// The API ID.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public let corsConfiguration: Cors?
        /// The timestamp when the API was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public let importInfo: [String]?
        /// The IP address types that can invoke the API.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// The API protocol.
        public let protocolType: ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// A collection of tags associated with the API.
        public let tags: [String: String]?
        /// A version identifier for the API.
        public let version: String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public let warnings: [String]?

        @inlinable
        public init(apiEndpoint: String? = nil, apiGatewayManaged: Bool? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, createdDate: Date? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, importInfo: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocolType: ProtocolType? = nil, routeSelectionExpression: String? = nil, tags: [String: String]? = nil, version: String? = nil, warnings: [String]? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "apiEndpoint"
            case apiGatewayManaged = "apiGatewayManaged"
            case apiId = "apiId"
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case createdDate = "createdDate"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case importInfo = "importInfo"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case protocolType = "protocolType"
            case routeSelectionExpression = "routeSelectionExpression"
            case tags = "tags"
            case version = "version"
            case warnings = "warnings"
        }
    }

    public struct CreateAuthorizerRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public let authorizerCredentialsArn: String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see Working with AWS Lambda authorizers for HTTP APIs.
        public let authorizerPayloadFormatVersion: String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public let authorizerResultTtlInSeconds: Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public let authorizerType: AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public let authorizerUri: String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see Working with AWS Lambda authorizers for HTTP APIs
        public let enableSimpleResponses: Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see Working with AWS Lambda authorizers for HTTP APIs. For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public let identitySource: [String]?
        /// This parameter is not used.
        public let identityValidationExpression: String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public let jwtConfiguration: JWTConfiguration?
        /// The name of the authorizer.
        public let name: String?

        @inlinable
        public init(apiId: String, authorizerCredentialsArn: String? = nil, authorizerPayloadFormatVersion: String? = nil, authorizerResultTtlInSeconds: Int? = nil, authorizerType: AuthorizerType? = nil, authorizerUri: String? = nil, enableSimpleResponses: Bool? = nil, identitySource: [String]? = nil, identityValidationExpression: String? = nil, jwtConfiguration: JWTConfiguration? = nil, name: String? = nil) {
            self.apiId = apiId
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
            try container.encodeIfPresent(self.authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
            try container.encodeIfPresent(self.authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
            try container.encodeIfPresent(self.authorizerType, forKey: .authorizerType)
            try container.encodeIfPresent(self.authorizerUri, forKey: .authorizerUri)
            try container.encodeIfPresent(self.enableSimpleResponses, forKey: .enableSimpleResponses)
            try container.encodeIfPresent(self.identitySource, forKey: .identitySource)
            try container.encodeIfPresent(self.identityValidationExpression, forKey: .identityValidationExpression)
            try container.encodeIfPresent(self.jwtConfiguration, forKey: .jwtConfiguration)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizerResultTtlInSeconds, name: "authorizerResultTtlInSeconds", parent: name, max: 3600)
            try self.validate(self.authorizerResultTtlInSeconds, name: "authorizerResultTtlInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerCredentialsArn = "authorizerCredentialsArn"
            case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
            case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
            case authorizerType = "authorizerType"
            case authorizerUri = "authorizerUri"
            case enableSimpleResponses = "enableSimpleResponses"
            case identitySource = "identitySource"
            case identityValidationExpression = "identityValidationExpression"
            case jwtConfiguration = "jwtConfiguration"
            case name = "name"
        }
    }

    public struct CreateAuthorizerResponse: AWSDecodableShape {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public let authorizerCredentialsArn: String?
        /// The authorizer identifier.
        public let authorizerId: String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see Working with AWS Lambda authorizers for HTTP APIs.
        public let authorizerPayloadFormatVersion: String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public let authorizerResultTtlInSeconds: Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public let authorizerType: AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public let authorizerUri: String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see Working with AWS Lambda authorizers for HTTP APIs
        public let enableSimpleResponses: Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see Working with AWS Lambda authorizers for HTTP APIs. For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public let identitySource: [String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public let identityValidationExpression: String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public let jwtConfiguration: JWTConfiguration?
        /// The name of the authorizer.
        public let name: String?

        @inlinable
        public init(authorizerCredentialsArn: String? = nil, authorizerId: String? = nil, authorizerPayloadFormatVersion: String? = nil, authorizerResultTtlInSeconds: Int? = nil, authorizerType: AuthorizerType? = nil, authorizerUri: String? = nil, enableSimpleResponses: Bool? = nil, identitySource: [String]? = nil, identityValidationExpression: String? = nil, jwtConfiguration: JWTConfiguration? = nil, name: String? = nil) {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerCredentialsArn = "authorizerCredentialsArn"
            case authorizerId = "authorizerId"
            case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
            case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
            case authorizerType = "authorizerType"
            case authorizerUri = "authorizerUri"
            case enableSimpleResponses = "enableSimpleResponses"
            case identitySource = "identitySource"
            case identityValidationExpression = "identityValidationExpression"
            case jwtConfiguration = "jwtConfiguration"
            case name = "name"
        }
    }

    public struct CreateDeploymentRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The description for the deployment resource.
        public let description: String?
        /// The name of the Stage resource for the Deployment resource to create.
        public let stageName: String?

        @inlinable
        public init(apiId: String, description: String? = nil, stageName: String? = nil) {
            self.apiId = apiId
            self.description = description
            self.stageName = stageName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.stageName, forKey: .stageName)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case stageName = "stageName"
        }
    }

    public struct CreateDeploymentResponse: AWSDecodableShape {
        /// Specifies whether a deployment was automatically released.
        public let autoDeployed: Bool?
        /// The date and time when the Deployment resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The identifier for the deployment.
        public let deploymentId: String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public let deploymentStatus: DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public let deploymentStatusMessage: String?
        /// The description for the deployment.
        public let description: String?

        @inlinable
        public init(autoDeployed: Bool? = nil, createdDate: Date? = nil, deploymentId: String? = nil, deploymentStatus: DeploymentStatus? = nil, deploymentStatusMessage: String? = nil, description: String? = nil) {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case autoDeployed = "autoDeployed"
            case createdDate = "createdDate"
            case deploymentId = "deploymentId"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case description = "description"
        }
    }

    public struct CreateDomainNameRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String?
        /// The domain name configurations.
        public let domainNameConfigurations: [DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public let mutualTlsAuthentication: MutualTlsAuthenticationInput?
        /// The collection of tags associated with a domain name.
        public let tags: [String: String]?

        @inlinable
        public init(domainName: String? = nil, domainNameConfigurations: [DomainNameConfiguration]? = nil, mutualTlsAuthentication: MutualTlsAuthenticationInput? = nil, tags: [String: String]? = nil) {
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case domainNameConfigurations = "domainNameConfigurations"
            case mutualTlsAuthentication = "mutualTlsAuthentication"
            case tags = "tags"
        }
    }

    public struct CreateDomainNameResponse: AWSDecodableShape {
        /// The API mapping selection expression.
        public let apiMappingSelectionExpression: String?
        /// The name of the DomainName resource.
        public let domainName: String?
        /// The domain name configurations.
        public let domainNameConfigurations: [DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public let mutualTlsAuthentication: MutualTlsAuthentication?
        /// The collection of tags associated with a domain name.
        public let tags: [String: String]?

        @inlinable
        public init(apiMappingSelectionExpression: String? = nil, domainName: String? = nil, domainNameConfigurations: [DomainNameConfiguration]? = nil, mutualTlsAuthentication: MutualTlsAuthentication? = nil, tags: [String: String]? = nil) {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case apiMappingSelectionExpression = "apiMappingSelectionExpression"
            case domainName = "domainName"
            case domainNameConfigurations = "domainNameConfigurations"
            case mutualTlsAuthentication = "mutualTlsAuthentication"
            case tags = "tags"
        }
    }

    public struct CreateIntegrationRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public let connectionId: String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public let connectionType: ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public let credentialsArn: String?
        /// The description of the integration.
        public let description: String?
        /// Specifies the integration's HTTP method type.
        public let integrationMethod: String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see Integration subtype reference.
        public let integrationSubtype: String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public let integrationType: IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see DiscoverInstances. For private integrations, all resources must be owned by the same AWS account.
        public let integrationUri: String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public let passthroughBehavior: PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see Working with AWS Lambda proxy integrations for HTTP APIs.
        public let payloadFormatVersion: String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where  {location} is querystring, path, or header; and  {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Working with AWS service integrations for HTTP APIs. For HTTP API integrations without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt; where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let requestParameters: [String: String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public let requestTemplates: [String: String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let responseParameters: [String: [String: String]]?
        /// The template selection expression for the integration.
        public let templateSelectionExpression: String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public let timeoutInMillis: Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public let tlsConfig: TlsConfigInput?

        @inlinable
        public init(apiId: String, connectionId: String? = nil, connectionType: ConnectionType? = nil, contentHandlingStrategy: ContentHandlingStrategy? = nil, credentialsArn: String? = nil, description: String? = nil, integrationMethod: String? = nil, integrationSubtype: String? = nil, integrationType: IntegrationType? = nil, integrationUri: String? = nil, passthroughBehavior: PassthroughBehavior? = nil, payloadFormatVersion: String? = nil, requestParameters: [String: String]? = nil, requestTemplates: [String: String]? = nil, responseParameters: [String: [String: String]]? = nil, templateSelectionExpression: String? = nil, timeoutInMillis: Int? = nil, tlsConfig: TlsConfigInput? = nil) {
            self.apiId = apiId
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationMethod = integrationMethod
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.connectionId, forKey: .connectionId)
            try container.encodeIfPresent(self.connectionType, forKey: .connectionType)
            try container.encodeIfPresent(self.contentHandlingStrategy, forKey: .contentHandlingStrategy)
            try container.encodeIfPresent(self.credentialsArn, forKey: .credentialsArn)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.integrationMethod, forKey: .integrationMethod)
            try container.encodeIfPresent(self.integrationSubtype, forKey: .integrationSubtype)
            try container.encodeIfPresent(self.integrationType, forKey: .integrationType)
            try container.encodeIfPresent(self.integrationUri, forKey: .integrationUri)
            try container.encodeIfPresent(self.passthroughBehavior, forKey: .passthroughBehavior)
            try container.encodeIfPresent(self.payloadFormatVersion, forKey: .payloadFormatVersion)
            try container.encodeIfPresent(self.requestParameters, forKey: .requestParameters)
            try container.encodeIfPresent(self.requestTemplates, forKey: .requestTemplates)
            try container.encodeIfPresent(self.responseParameters, forKey: .responseParameters)
            try container.encodeIfPresent(self.templateSelectionExpression, forKey: .templateSelectionExpression)
            try container.encodeIfPresent(self.timeoutInMillis, forKey: .timeoutInMillis)
            try container.encodeIfPresent(self.tlsConfig, forKey: .tlsConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.timeoutInMillis, name: "timeoutInMillis", parent: name, max: 30000)
            try self.validate(self.timeoutInMillis, name: "timeoutInMillis", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case connectionType = "connectionType"
            case contentHandlingStrategy = "contentHandlingStrategy"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case integrationMethod = "integrationMethod"
            case integrationSubtype = "integrationSubtype"
            case integrationType = "integrationType"
            case integrationUri = "integrationUri"
            case passthroughBehavior = "passthroughBehavior"
            case payloadFormatVersion = "payloadFormatVersion"
            case requestParameters = "requestParameters"
            case requestTemplates = "requestTemplates"
            case responseParameters = "responseParameters"
            case templateSelectionExpression = "templateSelectionExpression"
            case timeoutInMillis = "timeoutInMillis"
            case tlsConfig = "tlsConfig"
        }
    }

    public struct CreateIntegrationResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// The integration ID.
        public let integrationId: String
        /// The integration response key.
        public let integrationResponseKey: String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where {name} is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where {name} is a valid and unique response header name and {JSON-expression} is a valid JSON expression without the $ prefix.
        public let responseParameters: [String: String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public let responseTemplates: [String: String]?
        /// The template selection expression for the integration response. Supported only for WebSocket APIs.
        public let templateSelectionExpression: String?

        @inlinable
        public init(apiId: String, contentHandlingStrategy: ContentHandlingStrategy? = nil, integrationId: String, integrationResponseKey: String? = nil, responseParameters: [String: String]? = nil, responseTemplates: [String: String]? = nil, templateSelectionExpression: String? = nil) {
            self.apiId = apiId
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationId = integrationId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.contentHandlingStrategy, forKey: .contentHandlingStrategy)
            request.encodePath(self.integrationId, key: "IntegrationId")
            try container.encodeIfPresent(self.integrationResponseKey, forKey: .integrationResponseKey)
            try container.encodeIfPresent(self.responseParameters, forKey: .responseParameters)
            try container.encodeIfPresent(self.responseTemplates, forKey: .responseTemplates)
            try container.encodeIfPresent(self.templateSelectionExpression, forKey: .templateSelectionExpression)
        }

        private enum CodingKeys: String, CodingKey {
            case contentHandlingStrategy = "contentHandlingStrategy"
            case integrationResponseKey = "integrationResponseKey"
            case responseParameters = "responseParameters"
            case responseTemplates = "responseTemplates"
            case templateSelectionExpression = "templateSelectionExpression"
        }
    }

    public struct CreateIntegrationResponseResponse: AWSDecodableShape {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// The integration response ID.
        public let integrationResponseId: String?
        /// The integration response key.
        public let integrationResponseKey: String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public let responseParameters: [String: String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public let responseTemplates: [String: String]?
        /// The template selection expressions for the integration response.
        public let templateSelectionExpression: String?

        @inlinable
        public init(contentHandlingStrategy: ContentHandlingStrategy? = nil, integrationResponseId: String? = nil, integrationResponseKey: String? = nil, responseParameters: [String: String]? = nil, responseTemplates: [String: String]? = nil, templateSelectionExpression: String? = nil) {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }

        private enum CodingKeys: String, CodingKey {
            case contentHandlingStrategy = "contentHandlingStrategy"
            case integrationResponseId = "integrationResponseId"
            case integrationResponseKey = "integrationResponseKey"
            case responseParameters = "responseParameters"
            case responseTemplates = "responseTemplates"
            case templateSelectionExpression = "templateSelectionExpression"
        }
    }

    public struct CreateIntegrationResult: AWSDecodableShape {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public let apiGatewayManaged: Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public let connectionId: String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public let connectionType: ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public let credentialsArn: String?
        /// Represents the description of an integration.
        public let description: String?
        /// Represents the identifier of an integration.
        public let integrationId: String?
        /// Specifies the integration's HTTP method type.
        public let integrationMethod: String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See Integration Response Selection Expressions.
        public let integrationResponseSelectionExpression: String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see Integration subtype reference.
        public let integrationSubtype: String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public let integrationType: IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see DiscoverInstances. For private integrations, all resources must be owned by the same AWS account.
        public let integrationUri: String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public let passthroughBehavior: PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see Working with AWS Lambda proxy integrations for HTTP APIs.
        public let payloadFormatVersion: String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where  {location} is querystring, path, or header; and  {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Working with AWS service integrations for HTTP APIs. For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let requestParameters: [String: String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public let requestTemplates: [String: String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let responseParameters: [String: [String: String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public let templateSelectionExpression: String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public let timeoutInMillis: Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public let tlsConfig: TlsConfig?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, connectionId: String? = nil, connectionType: ConnectionType? = nil, contentHandlingStrategy: ContentHandlingStrategy? = nil, credentialsArn: String? = nil, description: String? = nil, integrationId: String? = nil, integrationMethod: String? = nil, integrationResponseSelectionExpression: String? = nil, integrationSubtype: String? = nil, integrationType: IntegrationType? = nil, integrationUri: String? = nil, passthroughBehavior: PassthroughBehavior? = nil, payloadFormatVersion: String? = nil, requestParameters: [String: String]? = nil, requestTemplates: [String: String]? = nil, responseParameters: [String: [String: String]]? = nil, templateSelectionExpression: String? = nil, timeoutInMillis: Int? = nil, tlsConfig: TlsConfig? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case connectionId = "connectionId"
            case connectionType = "connectionType"
            case contentHandlingStrategy = "contentHandlingStrategy"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case integrationId = "integrationId"
            case integrationMethod = "integrationMethod"
            case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
            case integrationSubtype = "integrationSubtype"
            case integrationType = "integrationType"
            case integrationUri = "integrationUri"
            case passthroughBehavior = "passthroughBehavior"
            case payloadFormatVersion = "payloadFormatVersion"
            case requestParameters = "requestParameters"
            case requestTemplates = "requestTemplates"
            case responseParameters = "responseParameters"
            case templateSelectionExpression = "templateSelectionExpression"
            case timeoutInMillis = "timeoutInMillis"
            case tlsConfig = "tlsConfig"
        }
    }

    public struct CreateModelRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The content-type for the model, for example, "application/json".
        public let contentType: String?
        /// The description of the model.
        public let description: String?
        /// The name of the model. Must be alphanumeric.
        public let name: String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public let schema: String?

        @inlinable
        public init(apiId: String, contentType: String? = nil, description: String? = nil, name: String? = nil, schema: String? = nil) {
            self.apiId = apiId
            self.contentType = contentType
            self.description = description
            self.name = name
            self.schema = schema
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.schema, forKey: .schema)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case description = "description"
            case name = "name"
            case schema = "schema"
        }
    }

    public struct CreateModelResponse: AWSDecodableShape {
        /// The content-type for the model, for example, "application/json".
        public let contentType: String?
        /// The description of the model.
        public let description: String?
        /// The model identifier.
        public let modelId: String?
        /// The name of the model. Must be alphanumeric.
        public let name: String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public let schema: String?

        @inlinable
        public init(contentType: String? = nil, description: String? = nil, modelId: String? = nil, name: String? = nil, schema: String? = nil) {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case description = "description"
            case modelId = "modelId"
            case name = "name"
            case schema = "schema"
        }
    }

    public struct CreateRouteRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
        public let apiKeyRequired: Bool?
        /// The authorization scopes supported by this route.
        public let authorizationScopes: [String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public let authorizationType: AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public let authorizerId: String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The operation name for the route.
        public let operationName: String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public let requestModels: [String: String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public let requestParameters: [String: ParameterConstraints]?
        /// The route key for the route.
        public let routeKey: String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public let routeResponseSelectionExpression: String?
        /// The target for the route.
        public let target: String?

        @inlinable
        public init(apiId: String, apiKeyRequired: Bool? = nil, authorizationScopes: [String]? = nil, authorizationType: AuthorizationType? = nil, authorizerId: String? = nil, modelSelectionExpression: String? = nil, operationName: String? = nil, requestModels: [String: String]? = nil, requestParameters: [String: ParameterConstraints]? = nil, routeKey: String? = nil, routeResponseSelectionExpression: String? = nil, target: String? = nil) {
            self.apiId = apiId
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.apiKeyRequired, forKey: .apiKeyRequired)
            try container.encodeIfPresent(self.authorizationScopes, forKey: .authorizationScopes)
            try container.encodeIfPresent(self.authorizationType, forKey: .authorizationType)
            try container.encodeIfPresent(self.authorizerId, forKey: .authorizerId)
            try container.encodeIfPresent(self.modelSelectionExpression, forKey: .modelSelectionExpression)
            try container.encodeIfPresent(self.operationName, forKey: .operationName)
            try container.encodeIfPresent(self.requestModels, forKey: .requestModels)
            try container.encodeIfPresent(self.requestParameters, forKey: .requestParameters)
            try container.encodeIfPresent(self.routeKey, forKey: .routeKey)
            try container.encodeIfPresent(self.routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
            try container.encodeIfPresent(self.target, forKey: .target)
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeyRequired = "apiKeyRequired"
            case authorizationScopes = "authorizationScopes"
            case authorizationType = "authorizationType"
            case authorizerId = "authorizerId"
            case modelSelectionExpression = "modelSelectionExpression"
            case operationName = "operationName"
            case requestModels = "requestModels"
            case requestParameters = "requestParameters"
            case routeKey = "routeKey"
            case routeResponseSelectionExpression = "routeResponseSelectionExpression"
            case target = "target"
        }
    }

    public struct CreateRouteResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The model selection expression for the route response. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The response models for the route response.
        public let responseModels: [String: String]?
        /// The route response parameters.
        public let responseParameters: [String: ParameterConstraints]?
        /// The route ID.
        public let routeId: String
        /// The route response key.
        public let routeResponseKey: String?

        @inlinable
        public init(apiId: String, modelSelectionExpression: String? = nil, responseModels: [String: String]? = nil, responseParameters: [String: ParameterConstraints]? = nil, routeId: String, routeResponseKey: String? = nil) {
            self.apiId = apiId
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeId = routeId
            self.routeResponseKey = routeResponseKey
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.modelSelectionExpression, forKey: .modelSelectionExpression)
            try container.encodeIfPresent(self.responseModels, forKey: .responseModels)
            try container.encodeIfPresent(self.responseParameters, forKey: .responseParameters)
            request.encodePath(self.routeId, key: "RouteId")
            try container.encodeIfPresent(self.routeResponseKey, forKey: .routeResponseKey)
        }

        private enum CodingKeys: String, CodingKey {
            case modelSelectionExpression = "modelSelectionExpression"
            case responseModels = "responseModels"
            case responseParameters = "responseParameters"
            case routeResponseKey = "routeResponseKey"
        }
    }

    public struct CreateRouteResponseResponse: AWSDecodableShape {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// Represents the response models of a route response.
        public let responseModels: [String: String]?
        /// Represents the response parameters of a route response.
        public let responseParameters: [String: ParameterConstraints]?
        /// Represents the identifier of a route response.
        public let routeResponseId: String?
        /// Represents the route response key of a route response.
        public let routeResponseKey: String?

        @inlinable
        public init(modelSelectionExpression: String? = nil, responseModels: [String: String]? = nil, responseParameters: [String: ParameterConstraints]? = nil, routeResponseId: String? = nil, routeResponseKey: String? = nil) {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }

        private enum CodingKeys: String, CodingKey {
            case modelSelectionExpression = "modelSelectionExpression"
            case responseModels = "responseModels"
            case responseParameters = "responseParameters"
            case routeResponseId = "routeResponseId"
            case routeResponseKey = "routeResponseKey"
        }
    }

    public struct CreateRouteResult: AWSDecodableShape {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public let apiGatewayManaged: Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public let apiKeyRequired: Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public let authorizationScopes: [String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public let authorizationType: AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public let authorizerId: String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The operation name for the route.
        public let operationName: String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public let requestModels: [String: String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public let requestParameters: [String: ParameterConstraints]?
        /// The route ID.
        public let routeId: String?
        /// The route key for the route.
        public let routeKey: String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public let routeResponseSelectionExpression: String?
        /// The target for the route.
        public let target: String?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, apiKeyRequired: Bool? = nil, authorizationScopes: [String]? = nil, authorizationType: AuthorizationType? = nil, authorizerId: String? = nil, modelSelectionExpression: String? = nil, operationName: String? = nil, requestModels: [String: String]? = nil, requestParameters: [String: ParameterConstraints]? = nil, routeId: String? = nil, routeKey: String? = nil, routeResponseSelectionExpression: String? = nil, target: String? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case apiKeyRequired = "apiKeyRequired"
            case authorizationScopes = "authorizationScopes"
            case authorizationType = "authorizationType"
            case authorizerId = "authorizerId"
            case modelSelectionExpression = "modelSelectionExpression"
            case operationName = "operationName"
            case requestModels = "requestModels"
            case requestParameters = "requestParameters"
            case routeId = "routeId"
            case routeKey = "routeKey"
            case routeResponseSelectionExpression = "routeResponseSelectionExpression"
            case target = "target"
        }
    }

    public struct CreateStageRequest: AWSEncodableShape {
        /// Settings for logging access in this stage.
        public let accessLogSettings: AccessLogSettings?
        /// The API identifier.
        public let apiId: String
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public let clientCertificateId: String?
        /// The default route settings for the stage.
        public let defaultRouteSettings: RouteSettings?
        /// The deployment identifier of the API stage.
        public let deploymentId: String?
        /// The description for the API stage.
        public let description: String?
        /// Route settings for the stage, by routeKey.
        public let routeSettings: [String: RouteSettings]?
        /// The name of the stage.
        public let stageName: String?
        /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.
        public let stageVariables: [String: String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public let tags: [String: String]?

        @inlinable
        public init(accessLogSettings: AccessLogSettings? = nil, apiId: String, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, defaultRouteSettings: RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, routeSettings: [String: RouteSettings]? = nil, stageName: String? = nil, stageVariables: [String: String]? = nil, tags: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiId = apiId
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accessLogSettings, forKey: .accessLogSettings)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.autoDeploy, forKey: .autoDeploy)
            try container.encodeIfPresent(self.clientCertificateId, forKey: .clientCertificateId)
            try container.encodeIfPresent(self.defaultRouteSettings, forKey: .defaultRouteSettings)
            try container.encodeIfPresent(self.deploymentId, forKey: .deploymentId)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routeSettings, forKey: .routeSettings)
            try container.encodeIfPresent(self.stageName, forKey: .stageName)
            try container.encodeIfPresent(self.stageVariables, forKey: .stageVariables)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "accessLogSettings"
            case autoDeploy = "autoDeploy"
            case clientCertificateId = "clientCertificateId"
            case defaultRouteSettings = "defaultRouteSettings"
            case deploymentId = "deploymentId"
            case description = "description"
            case routeSettings = "routeSettings"
            case stageName = "stageName"
            case stageVariables = "stageVariables"
            case tags = "tags"
        }
    }

    public struct CreateStageResponse: AWSDecodableShape {
        /// Settings for logging access in this stage.
        public let accessLogSettings: AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public let apiGatewayManaged: Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public let clientCertificateId: String?
        /// The timestamp when the stage was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// Default route settings for the stage.
        public let defaultRouteSettings: RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public let deploymentId: String?
        /// The description of the stage.
        public let description: String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public let lastDeploymentStatusMessage: String?
        /// The timestamp when the stage was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedDate: Date?
        /// Route settings for the stage, by routeKey.
        public let routeSettings: [String: RouteSettings]?
        /// The name of the stage.
        public let stageName: String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.
        public let stageVariables: [String: String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public let tags: [String: String]?

        @inlinable
        public init(accessLogSettings: AccessLogSettings? = nil, apiGatewayManaged: Bool? = nil, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, createdDate: Date? = nil, defaultRouteSettings: RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, lastDeploymentStatusMessage: String? = nil, lastUpdatedDate: Date? = nil, routeSettings: [String: RouteSettings]? = nil, stageName: String? = nil, stageVariables: [String: String]? = nil, tags: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "accessLogSettings"
            case apiGatewayManaged = "apiGatewayManaged"
            case autoDeploy = "autoDeploy"
            case clientCertificateId = "clientCertificateId"
            case createdDate = "createdDate"
            case defaultRouteSettings = "defaultRouteSettings"
            case deploymentId = "deploymentId"
            case description = "description"
            case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
            case lastUpdatedDate = "lastUpdatedDate"
            case routeSettings = "routeSettings"
            case stageName = "stageName"
            case stageVariables = "stageVariables"
            case tags = "tags"
        }
    }

    public struct CreateVpcLinkRequest: AWSEncodableShape {
        /// The name of the VPC link.
        public let name: String?
        /// A list of security group IDs for the VPC link.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs to include in the VPC link.
        public let subnetIds: [String]?
        /// A list of tags.
        public let tags: [String: String]?

        @inlinable
        public init(name: String? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil) {
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
        }
    }

    public struct CreateVpcLinkResponse: AWSDecodableShape {
        /// The timestamp when the VPC link was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The name of the VPC link.
        public let name: String?
        /// A list of security group IDs for the VPC link.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs to include in the VPC link.
        public let subnetIds: [String]?
        /// Tags for the VPC link.
        public let tags: [String: String]?
        /// The ID of the VPC link.
        public let vpcLinkId: String?
        /// The status of the VPC link.
        public let vpcLinkStatus: VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public let vpcLinkStatusMessage: String?
        /// The version of the VPC link.
        public let vpcLinkVersion: VpcLinkVersion?

        @inlinable
        public init(createdDate: Date? = nil, name: String? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, vpcLinkId: String? = nil, vpcLinkStatus: VpcLinkStatus? = nil, vpcLinkStatusMessage: String? = nil, vpcLinkVersion: VpcLinkVersion? = nil) {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcLinkId = "vpcLinkId"
            case vpcLinkStatus = "vpcLinkStatus"
            case vpcLinkStatusMessage = "vpcLinkStatusMessage"
            case vpcLinkVersion = "vpcLinkVersion"
        }
    }

    public struct DeleteAccessLogSettingsRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        public let stageName: String

        @inlinable
        public init(apiId: String, stageName: String) {
            self.apiId = apiId
            self.stageName = stageName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.stageName, key: "StageName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApiMappingRequest: AWSEncodableShape {
        /// The API mapping identifier.
        public let apiMappingId: String
        /// The domain name.
        public let domainName: String

        @inlinable
        public init(apiMappingId: String, domainName: String) {
            self.apiMappingId = apiMappingId
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiMappingId, key: "ApiMappingId")
            request.encodePath(self.domainName, key: "DomainName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApiRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String

        @inlinable
        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAuthorizerRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The authorizer identifier.
        public let authorizerId: String

        @inlinable
        public init(apiId: String, authorizerId: String) {
            self.apiId = apiId
            self.authorizerId = authorizerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.authorizerId, key: "AuthorizerId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCorsConfigurationRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String

        @inlinable
        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDeploymentRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The deployment ID.
        public let deploymentId: String

        @inlinable
        public init(apiId: String, deploymentId: String) {
            self.apiId = apiId
            self.deploymentId = deploymentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.deploymentId, key: "DeploymentId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainNameRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIntegrationRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The integration ID.
        public let integrationId: String

        @inlinable
        public init(apiId: String, integrationId: String) {
            self.apiId = apiId
            self.integrationId = integrationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.integrationId, key: "IntegrationId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIntegrationResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The integration ID.
        public let integrationId: String
        /// The integration response ID.
        public let integrationResponseId: String

        @inlinable
        public init(apiId: String, integrationId: String, integrationResponseId: String) {
            self.apiId = apiId
            self.integrationId = integrationId
            self.integrationResponseId = integrationResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.integrationId, key: "IntegrationId")
            request.encodePath(self.integrationResponseId, key: "IntegrationResponseId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteModelRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The model ID.
        public let modelId: String

        @inlinable
        public init(apiId: String, modelId: String) {
            self.apiId = apiId
            self.modelId = modelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.modelId, key: "ModelId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The route ID.
        public let routeId: String

        @inlinable
        public init(apiId: String, routeId: String) {
            self.apiId = apiId
            self.routeId = routeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.routeId, key: "RouteId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteRequestParameterRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The route request parameter key.
        public let requestParameterKey: String
        /// The route ID.
        public let routeId: String

        @inlinable
        public init(apiId: String, requestParameterKey: String, routeId: String) {
            self.apiId = apiId
            self.requestParameterKey = requestParameterKey
            self.routeId = routeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.requestParameterKey, key: "RequestParameterKey")
            request.encodePath(self.routeId, key: "RouteId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The route ID.
        public let routeId: String
        /// The route response ID.
        public let routeResponseId: String

        @inlinable
        public init(apiId: String, routeId: String, routeResponseId: String) {
            self.apiId = apiId
            self.routeId = routeId
            self.routeResponseId = routeResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.routeId, key: "RouteId")
            request.encodePath(self.routeResponseId, key: "RouteResponseId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRouteSettingsRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The route key.
        public let routeKey: String
        /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        public let stageName: String

        @inlinable
        public init(apiId: String, routeKey: String, stageName: String) {
            self.apiId = apiId
            self.routeKey = routeKey
            self.stageName = stageName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.routeKey, key: "RouteKey")
            request.encodePath(self.stageName, key: "StageName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStageRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        public let stageName: String

        @inlinable
        public init(apiId: String, stageName: String) {
            self.apiId = apiId
            self.stageName = stageName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.stageName, key: "StageName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVpcLinkRequest: AWSEncodableShape {
        /// The ID of the VPC link.
        public let vpcLinkId: String

        @inlinable
        public init(vpcLinkId: String) {
            self.vpcLinkId = vpcLinkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vpcLinkId, key: "VpcLinkId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVpcLinkResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Deployment: AWSDecodableShape {
        /// Specifies whether a deployment was automatically released.
        public let autoDeployed: Bool?
        /// The date and time when the Deployment resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The identifier for the deployment.
        public let deploymentId: String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public let deploymentStatus: DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public let deploymentStatusMessage: String?
        /// The description for the deployment.
        public let description: String?

        @inlinable
        public init(autoDeployed: Bool? = nil, createdDate: Date? = nil, deploymentId: String? = nil, deploymentStatus: DeploymentStatus? = nil, deploymentStatusMessage: String? = nil, description: String? = nil) {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case autoDeployed = "autoDeployed"
            case createdDate = "createdDate"
            case deploymentId = "deploymentId"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case description = "description"
        }
    }

    public struct DomainName: AWSDecodableShape {
        /// The API mapping selection expression.
        public let apiMappingSelectionExpression: String?
        /// The name of the DomainName resource.
        public let domainName: String?
        /// The domain name configurations.
        public let domainNameConfigurations: [DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public let mutualTlsAuthentication: MutualTlsAuthentication?
        /// The collection of tags associated with a domain name.
        public let tags: [String: String]?

        @inlinable
        public init(apiMappingSelectionExpression: String? = nil, domainName: String? = nil, domainNameConfigurations: [DomainNameConfiguration]? = nil, mutualTlsAuthentication: MutualTlsAuthentication? = nil, tags: [String: String]? = nil) {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case apiMappingSelectionExpression = "apiMappingSelectionExpression"
            case domainName = "domainName"
            case domainNameConfigurations = "domainNameConfigurations"
            case mutualTlsAuthentication = "mutualTlsAuthentication"
            case tags = "tags"
        }
    }

    public struct DomainNameConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A domain name for the API.
        public let apiGatewayDomainName: String?
        /// An AWS-managed certificate that will be used by the edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
        public let certificateArn: String?
        /// The user-friendly name of the certificate that will be used by the edge-optimized endpoint for this domain name.
        public let certificateName: String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var certificateUploadDate: Date?
        /// The status of the domain name migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public let domainNameStatus: DomainNameStatus?
        /// An optional text message containing detailed information about status of the domain name migration.
        public let domainNameStatusMessage: String?
        /// The endpoint type.
        public let endpointType: EndpointType?
        /// The Amazon Route 53 Hosted Zone ID of the endpoint.
        public let hostedZoneId: String?
        /// The IP address types that can invoke the domain name. Use ipv4 to allow only IPv4 addresses to invoke your domain name, or use dualstack to allow both IPv4 and IPv6 addresses to invoke your domain name.
        public let ipAddressType: IpAddressType?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn
        public let ownershipVerificationCertificateArn: String?
        /// The Transport Layer Security (TLS) version of the security policy for this domain name. The valid values are TLS_1_0 and TLS_1_2.
        public let securityPolicy: SecurityPolicy?

        @inlinable
        public init(apiGatewayDomainName: String? = nil, certificateArn: String? = nil, certificateName: String? = nil, certificateUploadDate: Date? = nil, domainNameStatus: DomainNameStatus? = nil, domainNameStatusMessage: String? = nil, endpointType: EndpointType? = nil, hostedZoneId: String? = nil, ipAddressType: IpAddressType? = nil, ownershipVerificationCertificateArn: String? = nil, securityPolicy: SecurityPolicy? = nil) {
            self.apiGatewayDomainName = apiGatewayDomainName
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointType = endpointType
            self.hostedZoneId = hostedZoneId
            self.ipAddressType = ipAddressType
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.securityPolicy = securityPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayDomainName = "apiGatewayDomainName"
            case certificateArn = "certificateArn"
            case certificateName = "certificateName"
            case certificateUploadDate = "certificateUploadDate"
            case domainNameStatus = "domainNameStatus"
            case domainNameStatusMessage = "domainNameStatusMessage"
            case endpointType = "endpointType"
            case hostedZoneId = "hostedZoneId"
            case ipAddressType = "ipAddressType"
            case ownershipVerificationCertificateArn = "ownershipVerificationCertificateArn"
            case securityPolicy = "securityPolicy"
        }
    }

    public struct ExportApiRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The version of the API Gateway export algorithm. API Gateway uses the latest version by default. Currently, the only supported version is 1.0.
        public let exportVersion: String?
        /// Specifies whether to include API Gateway extensions in the exported API definition. API Gateway extensions are included by default.
        public let includeExtensions: Bool?
        /// The output type of the exported definition file. Valid values are JSON and YAML.
        public let outputType: String?
        /// The version of the API specification to use. OAS30, for OpenAPI 3.0, is the only supported value.
        public let specification: String
        /// The name of the API stage to export. If you don't specify this property, a representation of the latest API configuration is exported.
        public let stageName: String?

        @inlinable
        public init(apiId: String, exportVersion: String? = nil, includeExtensions: Bool? = nil, outputType: String? = nil, specification: String, stageName: String? = nil) {
            self.apiId = apiId
            self.exportVersion = exportVersion
            self.includeExtensions = includeExtensions
            self.outputType = outputType
            self.specification = specification
            self.stageName = stageName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.exportVersion, key: "exportVersion")
            request.encodeQuery(self.includeExtensions, key: "includeExtensions")
            request.encodeQuery(self.outputType, key: "outputType")
            request.encodePath(self.specification, key: "Specification")
            request.encodeQuery(self.stageName, key: "stageName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportApiResponse: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        public let body: AWSHTTPBody

        @inlinable
        public init(body: AWSHTTPBody) {
            self.body = body
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.body = try container.decode(AWSHTTPBody.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApiMappingRequest: AWSEncodableShape {
        /// The API mapping identifier.
        public let apiMappingId: String
        /// The domain name.
        public let domainName: String

        @inlinable
        public init(apiMappingId: String, domainName: String) {
            self.apiMappingId = apiMappingId
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiMappingId, key: "ApiMappingId")
            request.encodePath(self.domainName, key: "DomainName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApiMappingResponse: AWSDecodableShape {
        /// The API identifier.
        public let apiId: String?
        /// The API mapping identifier.
        public let apiMappingId: String?
        /// The API mapping key.
        public let apiMappingKey: String?
        /// The API stage.
        public let stage: String?

        @inlinable
        public init(apiId: String? = nil, apiMappingId: String? = nil, apiMappingKey: String? = nil, stage: String? = nil) {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case apiMappingId = "apiMappingId"
            case apiMappingKey = "apiMappingKey"
            case stage = "stage"
        }
    }

    public struct GetApiMappingsRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(domainName: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApiMappingsResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [ApiMapping]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [ApiMapping]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetApiRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String

        @inlinable
        public init(apiId: String) {
            self.apiId = apiId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApiResponse: AWSDecodableShape {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public let apiGatewayManaged: Bool?
        /// The API ID.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public let corsConfiguration: Cors?
        /// The timestamp when the API was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public let importInfo: [String]?
        /// The IP address types that can invoke the API.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// The API protocol.
        public let protocolType: ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// A collection of tags associated with the API.
        public let tags: [String: String]?
        /// A version identifier for the API.
        public let version: String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public let warnings: [String]?

        @inlinable
        public init(apiEndpoint: String? = nil, apiGatewayManaged: Bool? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, createdDate: Date? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, importInfo: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocolType: ProtocolType? = nil, routeSelectionExpression: String? = nil, tags: [String: String]? = nil, version: String? = nil, warnings: [String]? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "apiEndpoint"
            case apiGatewayManaged = "apiGatewayManaged"
            case apiId = "apiId"
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case createdDate = "createdDate"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case importInfo = "importInfo"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case protocolType = "protocolType"
            case routeSelectionExpression = "routeSelectionExpression"
            case tags = "tags"
            case version = "version"
            case warnings = "warnings"
        }
    }

    public struct GetApisRequest: AWSEncodableShape {
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApisResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Api]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [Api]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetAuthorizerRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The authorizer identifier.
        public let authorizerId: String

        @inlinable
        public init(apiId: String, authorizerId: String) {
            self.apiId = apiId
            self.authorizerId = authorizerId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.authorizerId, key: "AuthorizerId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAuthorizerResponse: AWSDecodableShape {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public let authorizerCredentialsArn: String?
        /// The authorizer identifier.
        public let authorizerId: String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see Working with AWS Lambda authorizers for HTTP APIs.
        public let authorizerPayloadFormatVersion: String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public let authorizerResultTtlInSeconds: Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public let authorizerType: AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public let authorizerUri: String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see Working with AWS Lambda authorizers for HTTP APIs
        public let enableSimpleResponses: Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see Working with AWS Lambda authorizers for HTTP APIs. For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public let identitySource: [String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public let identityValidationExpression: String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public let jwtConfiguration: JWTConfiguration?
        /// The name of the authorizer.
        public let name: String?

        @inlinable
        public init(authorizerCredentialsArn: String? = nil, authorizerId: String? = nil, authorizerPayloadFormatVersion: String? = nil, authorizerResultTtlInSeconds: Int? = nil, authorizerType: AuthorizerType? = nil, authorizerUri: String? = nil, enableSimpleResponses: Bool? = nil, identitySource: [String]? = nil, identityValidationExpression: String? = nil, jwtConfiguration: JWTConfiguration? = nil, name: String? = nil) {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerCredentialsArn = "authorizerCredentialsArn"
            case authorizerId = "authorizerId"
            case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
            case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
            case authorizerType = "authorizerType"
            case authorizerUri = "authorizerUri"
            case enableSimpleResponses = "enableSimpleResponses"
            case identitySource = "identitySource"
            case identityValidationExpression = "identityValidationExpression"
            case jwtConfiguration = "jwtConfiguration"
            case name = "name"
        }
    }

    public struct GetAuthorizersRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(apiId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAuthorizersResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Authorizer]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [Authorizer]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetDeploymentRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The deployment ID.
        public let deploymentId: String

        @inlinable
        public init(apiId: String, deploymentId: String) {
            self.apiId = apiId
            self.deploymentId = deploymentId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.deploymentId, key: "DeploymentId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeploymentResponse: AWSDecodableShape {
        /// Specifies whether a deployment was automatically released.
        public let autoDeployed: Bool?
        /// The date and time when the Deployment resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The identifier for the deployment.
        public let deploymentId: String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public let deploymentStatus: DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public let deploymentStatusMessage: String?
        /// The description for the deployment.
        public let description: String?

        @inlinable
        public init(autoDeployed: Bool? = nil, createdDate: Date? = nil, deploymentId: String? = nil, deploymentStatus: DeploymentStatus? = nil, deploymentStatusMessage: String? = nil, description: String? = nil) {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case autoDeployed = "autoDeployed"
            case createdDate = "createdDate"
            case deploymentId = "deploymentId"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case description = "description"
        }
    }

    public struct GetDeploymentsRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(apiId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDeploymentsResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Deployment]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [Deployment]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetDomainNameRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String

        @inlinable
        public init(domainName: String) {
            self.domainName = domainName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainNameResponse: AWSDecodableShape {
        /// The API mapping selection expression.
        public let apiMappingSelectionExpression: String?
        /// The name of the DomainName resource.
        public let domainName: String?
        /// The domain name configurations.
        public let domainNameConfigurations: [DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public let mutualTlsAuthentication: MutualTlsAuthentication?
        /// The collection of tags associated with a domain name.
        public let tags: [String: String]?

        @inlinable
        public init(apiMappingSelectionExpression: String? = nil, domainName: String? = nil, domainNameConfigurations: [DomainNameConfiguration]? = nil, mutualTlsAuthentication: MutualTlsAuthentication? = nil, tags: [String: String]? = nil) {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case apiMappingSelectionExpression = "apiMappingSelectionExpression"
            case domainName = "domainName"
            case domainNameConfigurations = "domainNameConfigurations"
            case mutualTlsAuthentication = "mutualTlsAuthentication"
            case tags = "tags"
        }
    }

    public struct GetDomainNamesRequest: AWSEncodableShape {
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainNamesResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [DomainName]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [DomainName]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetIntegrationRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The integration ID.
        public let integrationId: String

        @inlinable
        public init(apiId: String, integrationId: String) {
            self.apiId = apiId
            self.integrationId = integrationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.integrationId, key: "IntegrationId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIntegrationResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The integration ID.
        public let integrationId: String
        /// The integration response ID.
        public let integrationResponseId: String

        @inlinable
        public init(apiId: String, integrationId: String, integrationResponseId: String) {
            self.apiId = apiId
            self.integrationId = integrationId
            self.integrationResponseId = integrationResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.integrationId, key: "IntegrationId")
            request.encodePath(self.integrationResponseId, key: "IntegrationResponseId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIntegrationResponseResponse: AWSDecodableShape {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// The integration response ID.
        public let integrationResponseId: String?
        /// The integration response key.
        public let integrationResponseKey: String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public let responseParameters: [String: String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public let responseTemplates: [String: String]?
        /// The template selection expressions for the integration response.
        public let templateSelectionExpression: String?

        @inlinable
        public init(contentHandlingStrategy: ContentHandlingStrategy? = nil, integrationResponseId: String? = nil, integrationResponseKey: String? = nil, responseParameters: [String: String]? = nil, responseTemplates: [String: String]? = nil, templateSelectionExpression: String? = nil) {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }

        private enum CodingKeys: String, CodingKey {
            case contentHandlingStrategy = "contentHandlingStrategy"
            case integrationResponseId = "integrationResponseId"
            case integrationResponseKey = "integrationResponseKey"
            case responseParameters = "responseParameters"
            case responseTemplates = "responseTemplates"
            case templateSelectionExpression = "templateSelectionExpression"
        }
    }

    public struct GetIntegrationResponsesRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The integration ID.
        public let integrationId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(apiId: String, integrationId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.integrationId = integrationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.integrationId, key: "IntegrationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIntegrationResponsesResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [IntegrationResponse]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [IntegrationResponse]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetIntegrationResult: AWSDecodableShape {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public let apiGatewayManaged: Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public let connectionId: String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public let connectionType: ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public let credentialsArn: String?
        /// Represents the description of an integration.
        public let description: String?
        /// Represents the identifier of an integration.
        public let integrationId: String?
        /// Specifies the integration's HTTP method type.
        public let integrationMethod: String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See Integration Response Selection Expressions.
        public let integrationResponseSelectionExpression: String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see Integration subtype reference.
        public let integrationSubtype: String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public let integrationType: IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see DiscoverInstances. For private integrations, all resources must be owned by the same AWS account.
        public let integrationUri: String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public let passthroughBehavior: PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see Working with AWS Lambda proxy integrations for HTTP APIs.
        public let payloadFormatVersion: String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where  {location} is querystring, path, or header; and  {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Working with AWS service integrations for HTTP APIs. For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let requestParameters: [String: String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public let requestTemplates: [String: String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let responseParameters: [String: [String: String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public let templateSelectionExpression: String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public let timeoutInMillis: Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public let tlsConfig: TlsConfig?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, connectionId: String? = nil, connectionType: ConnectionType? = nil, contentHandlingStrategy: ContentHandlingStrategy? = nil, credentialsArn: String? = nil, description: String? = nil, integrationId: String? = nil, integrationMethod: String? = nil, integrationResponseSelectionExpression: String? = nil, integrationSubtype: String? = nil, integrationType: IntegrationType? = nil, integrationUri: String? = nil, passthroughBehavior: PassthroughBehavior? = nil, payloadFormatVersion: String? = nil, requestParameters: [String: String]? = nil, requestTemplates: [String: String]? = nil, responseParameters: [String: [String: String]]? = nil, templateSelectionExpression: String? = nil, timeoutInMillis: Int? = nil, tlsConfig: TlsConfig? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case connectionId = "connectionId"
            case connectionType = "connectionType"
            case contentHandlingStrategy = "contentHandlingStrategy"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case integrationId = "integrationId"
            case integrationMethod = "integrationMethod"
            case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
            case integrationSubtype = "integrationSubtype"
            case integrationType = "integrationType"
            case integrationUri = "integrationUri"
            case passthroughBehavior = "passthroughBehavior"
            case payloadFormatVersion = "payloadFormatVersion"
            case requestParameters = "requestParameters"
            case requestTemplates = "requestTemplates"
            case responseParameters = "responseParameters"
            case templateSelectionExpression = "templateSelectionExpression"
            case timeoutInMillis = "timeoutInMillis"
            case tlsConfig = "tlsConfig"
        }
    }

    public struct GetIntegrationsRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(apiId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIntegrationsResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Integration]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [Integration]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetModelRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The model ID.
        public let modelId: String

        @inlinable
        public init(apiId: String, modelId: String) {
            self.apiId = apiId
            self.modelId = modelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.modelId, key: "ModelId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelResponse: AWSDecodableShape {
        /// The content-type for the model, for example, "application/json".
        public let contentType: String?
        /// The description of the model.
        public let description: String?
        /// The model identifier.
        public let modelId: String?
        /// The name of the model. Must be alphanumeric.
        public let name: String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public let schema: String?

        @inlinable
        public init(contentType: String? = nil, description: String? = nil, modelId: String? = nil, name: String? = nil, schema: String? = nil) {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case description = "description"
            case modelId = "modelId"
            case name = "name"
            case schema = "schema"
        }
    }

    public struct GetModelTemplateRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The model ID.
        public let modelId: String

        @inlinable
        public init(apiId: String, modelId: String) {
            self.apiId = apiId
            self.modelId = modelId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.modelId, key: "ModelId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelTemplateResponse: AWSDecodableShape {
        /// The template value.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct GetModelsRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(apiId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetModelsResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Model]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [Model]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetRouteRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The route ID.
        public let routeId: String

        @inlinable
        public init(apiId: String, routeId: String) {
            self.apiId = apiId
            self.routeId = routeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.routeId, key: "RouteId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRouteResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The route ID.
        public let routeId: String
        /// The route response ID.
        public let routeResponseId: String

        @inlinable
        public init(apiId: String, routeId: String, routeResponseId: String) {
            self.apiId = apiId
            self.routeId = routeId
            self.routeResponseId = routeResponseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.routeId, key: "RouteId")
            request.encodePath(self.routeResponseId, key: "RouteResponseId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRouteResponseResponse: AWSDecodableShape {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// Represents the response models of a route response.
        public let responseModels: [String: String]?
        /// Represents the response parameters of a route response.
        public let responseParameters: [String: ParameterConstraints]?
        /// Represents the identifier of a route response.
        public let routeResponseId: String?
        /// Represents the route response key of a route response.
        public let routeResponseKey: String?

        @inlinable
        public init(modelSelectionExpression: String? = nil, responseModels: [String: String]? = nil, responseParameters: [String: ParameterConstraints]? = nil, routeResponseId: String? = nil, routeResponseKey: String? = nil) {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }

        private enum CodingKeys: String, CodingKey {
            case modelSelectionExpression = "modelSelectionExpression"
            case responseModels = "responseModels"
            case responseParameters = "responseParameters"
            case routeResponseId = "routeResponseId"
            case routeResponseKey = "routeResponseKey"
        }
    }

    public struct GetRouteResponsesRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?
        /// The route ID.
        public let routeId: String

        @inlinable
        public init(apiId: String, maxResults: String? = nil, nextToken: String? = nil, routeId: String) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.routeId = routeId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.routeId, key: "RouteId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRouteResponsesResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [RouteResponse]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [RouteResponse]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetRouteResult: AWSDecodableShape {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public let apiGatewayManaged: Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public let apiKeyRequired: Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public let authorizationScopes: [String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public let authorizationType: AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public let authorizerId: String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The operation name for the route.
        public let operationName: String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public let requestModels: [String: String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public let requestParameters: [String: ParameterConstraints]?
        /// The route ID.
        public let routeId: String?
        /// The route key for the route.
        public let routeKey: String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public let routeResponseSelectionExpression: String?
        /// The target for the route.
        public let target: String?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, apiKeyRequired: Bool? = nil, authorizationScopes: [String]? = nil, authorizationType: AuthorizationType? = nil, authorizerId: String? = nil, modelSelectionExpression: String? = nil, operationName: String? = nil, requestModels: [String: String]? = nil, requestParameters: [String: ParameterConstraints]? = nil, routeId: String? = nil, routeKey: String? = nil, routeResponseSelectionExpression: String? = nil, target: String? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case apiKeyRequired = "apiKeyRequired"
            case authorizationScopes = "authorizationScopes"
            case authorizationType = "authorizationType"
            case authorizerId = "authorizerId"
            case modelSelectionExpression = "modelSelectionExpression"
            case operationName = "operationName"
            case requestModels = "requestModels"
            case requestParameters = "requestParameters"
            case routeId = "routeId"
            case routeKey = "routeKey"
            case routeResponseSelectionExpression = "routeResponseSelectionExpression"
            case target = "target"
        }
    }

    public struct GetRoutesRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(apiId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRoutesResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Route]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [Route]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetStageRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The stage name. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        public let stageName: String

        @inlinable
        public init(apiId: String, stageName: String) {
            self.apiId = apiId
            self.stageName = stageName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.stageName, key: "StageName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStageResponse: AWSDecodableShape {
        /// Settings for logging access in this stage.
        public let accessLogSettings: AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public let apiGatewayManaged: Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public let clientCertificateId: String?
        /// The timestamp when the stage was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// Default route settings for the stage.
        public let defaultRouteSettings: RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public let deploymentId: String?
        /// The description of the stage.
        public let description: String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public let lastDeploymentStatusMessage: String?
        /// The timestamp when the stage was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedDate: Date?
        /// Route settings for the stage, by routeKey.
        public let routeSettings: [String: RouteSettings]?
        /// The name of the stage.
        public let stageName: String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.
        public let stageVariables: [String: String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public let tags: [String: String]?

        @inlinable
        public init(accessLogSettings: AccessLogSettings? = nil, apiGatewayManaged: Bool? = nil, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, createdDate: Date? = nil, defaultRouteSettings: RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, lastDeploymentStatusMessage: String? = nil, lastUpdatedDate: Date? = nil, routeSettings: [String: RouteSettings]? = nil, stageName: String? = nil, stageVariables: [String: String]? = nil, tags: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "accessLogSettings"
            case apiGatewayManaged = "apiGatewayManaged"
            case autoDeploy = "autoDeploy"
            case clientCertificateId = "clientCertificateId"
            case createdDate = "createdDate"
            case defaultRouteSettings = "defaultRouteSettings"
            case deploymentId = "deploymentId"
            case description = "description"
            case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
            case lastUpdatedDate = "lastUpdatedDate"
            case routeSettings = "routeSettings"
            case stageName = "stageName"
            case stageVariables = "stageVariables"
            case tags = "tags"
        }
    }

    public struct GetStagesRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(apiId: String, maxResults: String? = nil, nextToken: String? = nil) {
            self.apiId = apiId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStagesResponse: AWSDecodableShape {
        /// The elements from this collection.
        public let items: [Stage]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [Stage]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct GetTagsRequest: AWSEncodableShape {
        /// The resource ARN for the tag.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTagsResponse: AWSDecodableShape {
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct GetVpcLinkRequest: AWSEncodableShape {
        /// The ID of the VPC link.
        public let vpcLinkId: String

        @inlinable
        public init(vpcLinkId: String) {
            self.vpcLinkId = vpcLinkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.vpcLinkId, key: "VpcLinkId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVpcLinkResponse: AWSDecodableShape {
        /// The timestamp when the VPC link was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The name of the VPC link.
        public let name: String?
        /// A list of security group IDs for the VPC link.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs to include in the VPC link.
        public let subnetIds: [String]?
        /// Tags for the VPC link.
        public let tags: [String: String]?
        /// The ID of the VPC link.
        public let vpcLinkId: String?
        /// The status of the VPC link.
        public let vpcLinkStatus: VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public let vpcLinkStatusMessage: String?
        /// The version of the VPC link.
        public let vpcLinkVersion: VpcLinkVersion?

        @inlinable
        public init(createdDate: Date? = nil, name: String? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, vpcLinkId: String? = nil, vpcLinkStatus: VpcLinkStatus? = nil, vpcLinkStatusMessage: String? = nil, vpcLinkVersion: VpcLinkVersion? = nil) {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcLinkId = "vpcLinkId"
            case vpcLinkStatus = "vpcLinkStatus"
            case vpcLinkStatusMessage = "vpcLinkStatusMessage"
            case vpcLinkVersion = "vpcLinkVersion"
        }
    }

    public struct GetVpcLinksRequest: AWSEncodableShape {
        /// The maximum number of elements to be returned for this resource.
        public let maxResults: String?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(maxResults: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetVpcLinksResponse: AWSDecodableShape {
        /// A collection of VPC links.
        public let items: [VpcLink]?
        /// The next page of elements from this collection. Not valid for the last element of the collection.
        public let nextToken: String?

        @inlinable
        public init(items: [VpcLink]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ImportApiRequest: AWSEncodableShape {
        /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see Set the OpenAPI basePath Property. Supported only for HTTP APIs.
        public let basepath: String?
        /// The OpenAPI definition. Supported only for HTTP APIs.
        public let body: String?
        /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
        public let failOnWarnings: Bool?

        @inlinable
        public init(basepath: String? = nil, body: String? = nil, failOnWarnings: Bool? = nil) {
            self.basepath = basepath
            self.body = body
            self.failOnWarnings = failOnWarnings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.basepath, key: "basepath")
            try container.encodeIfPresent(self.body, forKey: .body)
            request.encodeQuery(self.failOnWarnings, key: "failOnWarnings")
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
        }
    }

    public struct ImportApiResponse: AWSDecodableShape {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public let apiGatewayManaged: Bool?
        /// The API ID.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public let corsConfiguration: Cors?
        /// The timestamp when the API was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public let importInfo: [String]?
        /// The IP address types that can invoke the API.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// The API protocol.
        public let protocolType: ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// A collection of tags associated with the API.
        public let tags: [String: String]?
        /// A version identifier for the API.
        public let version: String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public let warnings: [String]?

        @inlinable
        public init(apiEndpoint: String? = nil, apiGatewayManaged: Bool? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, createdDate: Date? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, importInfo: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocolType: ProtocolType? = nil, routeSelectionExpression: String? = nil, tags: [String: String]? = nil, version: String? = nil, warnings: [String]? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "apiEndpoint"
            case apiGatewayManaged = "apiGatewayManaged"
            case apiId = "apiId"
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case createdDate = "createdDate"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case importInfo = "importInfo"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case protocolType = "protocolType"
            case routeSelectionExpression = "routeSelectionExpression"
            case tags = "tags"
            case version = "version"
            case warnings = "warnings"
        }
    }

    public struct Integration: AWSDecodableShape {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public let apiGatewayManaged: Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public let connectionId: String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public let connectionType: ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public let credentialsArn: String?
        /// Represents the description of an integration.
        public let description: String?
        /// Represents the identifier of an integration.
        public let integrationId: String?
        /// Specifies the integration's HTTP method type.
        public let integrationMethod: String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See Integration Response Selection Expressions.
        public let integrationResponseSelectionExpression: String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see Integration subtype reference.
        public let integrationSubtype: String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public let integrationType: IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see DiscoverInstances. For private integrations, all resources must be owned by the same AWS account.
        public let integrationUri: String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public let passthroughBehavior: PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see Working with AWS Lambda proxy integrations for HTTP APIs.
        public let payloadFormatVersion: String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where  {location} is querystring, path, or header; and  {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Working with AWS service integrations for HTTP APIs. For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let requestParameters: [String: String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public let requestTemplates: [String: String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let responseParameters: [String: [String: String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public let templateSelectionExpression: String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public let timeoutInMillis: Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public let tlsConfig: TlsConfig?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, connectionId: String? = nil, connectionType: ConnectionType? = nil, contentHandlingStrategy: ContentHandlingStrategy? = nil, credentialsArn: String? = nil, description: String? = nil, integrationId: String? = nil, integrationMethod: String? = nil, integrationResponseSelectionExpression: String? = nil, integrationSubtype: String? = nil, integrationType: IntegrationType? = nil, integrationUri: String? = nil, passthroughBehavior: PassthroughBehavior? = nil, payloadFormatVersion: String? = nil, requestParameters: [String: String]? = nil, requestTemplates: [String: String]? = nil, responseParameters: [String: [String: String]]? = nil, templateSelectionExpression: String? = nil, timeoutInMillis: Int? = nil, tlsConfig: TlsConfig? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case connectionId = "connectionId"
            case connectionType = "connectionType"
            case contentHandlingStrategy = "contentHandlingStrategy"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case integrationId = "integrationId"
            case integrationMethod = "integrationMethod"
            case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
            case integrationSubtype = "integrationSubtype"
            case integrationType = "integrationType"
            case integrationUri = "integrationUri"
            case passthroughBehavior = "passthroughBehavior"
            case payloadFormatVersion = "payloadFormatVersion"
            case requestParameters = "requestParameters"
            case requestTemplates = "requestTemplates"
            case responseParameters = "responseParameters"
            case templateSelectionExpression = "templateSelectionExpression"
            case timeoutInMillis = "timeoutInMillis"
            case tlsConfig = "tlsConfig"
        }
    }

    public struct IntegrationResponse: AWSDecodableShape {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// The integration response ID.
        public let integrationResponseId: String?
        /// The integration response key.
        public let integrationResponseKey: String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public let responseParameters: [String: String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public let responseTemplates: [String: String]?
        /// The template selection expressions for the integration response.
        public let templateSelectionExpression: String?

        @inlinable
        public init(contentHandlingStrategy: ContentHandlingStrategy? = nil, integrationResponseId: String? = nil, integrationResponseKey: String? = nil, responseParameters: [String: String]? = nil, responseTemplates: [String: String]? = nil, templateSelectionExpression: String? = nil) {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }

        private enum CodingKeys: String, CodingKey {
            case contentHandlingStrategy = "contentHandlingStrategy"
            case integrationResponseId = "integrationResponseId"
            case integrationResponseKey = "integrationResponseKey"
            case responseParameters = "responseParameters"
            case responseTemplates = "responseTemplates"
            case templateSelectionExpression = "templateSelectionExpression"
        }
    }

    public struct JWTConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of the intended recipients of the JWT. A valid JWT must provide an aud that matches at least one entry in this list. See RFC 7519. Supported only for HTTP APIs.
        public let audience: [String]?
        /// The base domain of the identity provider that issues JSON Web Tokens. For example, an Amazon Cognito user pool has the following format: https://cognito-idp.{region}.amazonaws.com/{userPoolId} . Required for the JWT authorizer type. Supported only for HTTP APIs.
        public let issuer: String?

        @inlinable
        public init(audience: [String]? = nil, issuer: String? = nil) {
            self.audience = audience
            self.issuer = issuer
        }

        private enum CodingKeys: String, CodingKey {
            case audience = "audience"
            case issuer = "issuer"
        }
    }

    public struct Model: AWSDecodableShape {
        /// The content-type for the model, for example, "application/json".
        public let contentType: String?
        /// The description of the model.
        public let description: String?
        /// The model identifier.
        public let modelId: String?
        /// The name of the model. Must be alphanumeric.
        public let name: String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public let schema: String?

        @inlinable
        public init(contentType: String? = nil, description: String? = nil, modelId: String? = nil, name: String? = nil, schema: String? = nil) {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case description = "description"
            case modelId = "modelId"
            case name = "name"
            case schema = "schema"
        }
    }

    public struct MutualTlsAuthentication: AWSDecodableShape {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public let truststoreUri: String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public let truststoreVersion: String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public let truststoreWarnings: [String]?

        @inlinable
        public init(truststoreUri: String? = nil, truststoreVersion: String? = nil, truststoreWarnings: [String]? = nil) {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }

        private enum CodingKeys: String, CodingKey {
            case truststoreUri = "truststoreUri"
            case truststoreVersion = "truststoreVersion"
            case truststoreWarnings = "truststoreWarnings"
        }
    }

    public struct MutualTlsAuthenticationInput: AWSEncodableShape {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public let truststoreUri: String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public let truststoreVersion: String?

        @inlinable
        public init(truststoreUri: String? = nil, truststoreVersion: String? = nil) {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }

        private enum CodingKeys: String, CodingKey {
            case truststoreUri = "truststoreUri"
            case truststoreVersion = "truststoreVersion"
        }
    }

    public struct NotFoundException: AWSErrorShape {
        /// Describes the error encountered.
        public let message: String?
        /// The resource type.
        public let resourceType: String?

        @inlinable
        public init(message: String? = nil, resourceType: String? = nil) {
            self.message = message
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceType = "resourceType"
        }
    }

    public struct ParameterConstraints: AWSEncodableShape & AWSDecodableShape {
        /// Whether or not the parameter is required.
        public let required: Bool?

        @inlinable
        public init(required: Bool? = nil) {
            self.required = required
        }

        private enum CodingKeys: String, CodingKey {
            case required = "required"
        }
    }

    public struct ReimportApiRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// Specifies how to interpret the base path of the API during import. Valid values are ignore, prepend, and split. The default value is ignore. To learn more, see Set the OpenAPI basePath Property. Supported only for HTTP APIs.
        public let basepath: String?
        /// The OpenAPI definition. Supported only for HTTP APIs.
        public let body: String?
        /// Specifies whether to rollback the API creation when a warning is encountered. By default, API creation continues if a warning is encountered.
        public let failOnWarnings: Bool?

        @inlinable
        public init(apiId: String, basepath: String? = nil, body: String? = nil, failOnWarnings: Bool? = nil) {
            self.apiId = apiId
            self.basepath = basepath
            self.body = body
            self.failOnWarnings = failOnWarnings
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodeQuery(self.basepath, key: "basepath")
            try container.encodeIfPresent(self.body, forKey: .body)
            request.encodeQuery(self.failOnWarnings, key: "failOnWarnings")
        }

        private enum CodingKeys: String, CodingKey {
            case body = "body"
        }
    }

    public struct ReimportApiResponse: AWSDecodableShape {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public let apiGatewayManaged: Bool?
        /// The API ID.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public let corsConfiguration: Cors?
        /// The timestamp when the API was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public let importInfo: [String]?
        /// The IP address types that can invoke the API.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// The API protocol.
        public let protocolType: ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// A collection of tags associated with the API.
        public let tags: [String: String]?
        /// A version identifier for the API.
        public let version: String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public let warnings: [String]?

        @inlinable
        public init(apiEndpoint: String? = nil, apiGatewayManaged: Bool? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, createdDate: Date? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, importInfo: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocolType: ProtocolType? = nil, routeSelectionExpression: String? = nil, tags: [String: String]? = nil, version: String? = nil, warnings: [String]? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "apiEndpoint"
            case apiGatewayManaged = "apiGatewayManaged"
            case apiId = "apiId"
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case createdDate = "createdDate"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case importInfo = "importInfo"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case protocolType = "protocolType"
            case routeSelectionExpression = "routeSelectionExpression"
            case tags = "tags"
            case version = "version"
            case warnings = "warnings"
        }
    }

    public struct ResetAuthorizersCacheRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
        public let stageName: String

        @inlinable
        public init(apiId: String, stageName: String) {
            self.apiId = apiId
            self.stageName = stageName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.stageName, key: "StageName")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct Route: AWSDecodableShape {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public let apiGatewayManaged: Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public let apiKeyRequired: Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public let authorizationScopes: [String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public let authorizationType: AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public let authorizerId: String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The operation name for the route.
        public let operationName: String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public let requestModels: [String: String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public let requestParameters: [String: ParameterConstraints]?
        /// The route ID.
        public let routeId: String?
        /// The route key for the route.
        public let routeKey: String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public let routeResponseSelectionExpression: String?
        /// The target for the route.
        public let target: String?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, apiKeyRequired: Bool? = nil, authorizationScopes: [String]? = nil, authorizationType: AuthorizationType? = nil, authorizerId: String? = nil, modelSelectionExpression: String? = nil, operationName: String? = nil, requestModels: [String: String]? = nil, requestParameters: [String: ParameterConstraints]? = nil, routeId: String? = nil, routeKey: String? = nil, routeResponseSelectionExpression: String? = nil, target: String? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case apiKeyRequired = "apiKeyRequired"
            case authorizationScopes = "authorizationScopes"
            case authorizationType = "authorizationType"
            case authorizerId = "authorizerId"
            case modelSelectionExpression = "modelSelectionExpression"
            case operationName = "operationName"
            case requestModels = "requestModels"
            case requestParameters = "requestParameters"
            case routeId = "routeId"
            case routeKey = "routeKey"
            case routeResponseSelectionExpression = "routeResponseSelectionExpression"
            case target = "target"
        }
    }

    public struct RouteResponse: AWSDecodableShape {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// Represents the response models of a route response.
        public let responseModels: [String: String]?
        /// Represents the response parameters of a route response.
        public let responseParameters: [String: ParameterConstraints]?
        /// Represents the identifier of a route response.
        public let routeResponseId: String?
        /// Represents the route response key of a route response.
        public let routeResponseKey: String?

        @inlinable
        public init(modelSelectionExpression: String? = nil, responseModels: [String: String]? = nil, responseParameters: [String: ParameterConstraints]? = nil, routeResponseId: String? = nil, routeResponseKey: String? = nil) {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }

        private enum CodingKeys: String, CodingKey {
            case modelSelectionExpression = "modelSelectionExpression"
            case responseModels = "responseModels"
            case responseParameters = "responseParameters"
            case routeResponseId = "routeResponseId"
            case routeResponseKey = "routeResponseKey"
        }
    }

    public struct RouteSettings: AWSEncodableShape & AWSDecodableShape {
        /// Specifies whether (true) or not (false) data trace logging is enabled for this route. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public let dataTraceEnabled: Bool?
        /// Specifies whether detailed metrics are enabled.
        public let detailedMetricsEnabled: Bool?
        /// Specifies the logging level for this route: INFO, ERROR, or OFF. This property affects the log entries pushed to Amazon CloudWatch Logs. Supported only for WebSocket APIs.
        public let loggingLevel: LoggingLevel?
        /// Specifies the throttling burst limit.
        public let throttlingBurstLimit: Int?
        /// Specifies the throttling rate limit.
        public let throttlingRateLimit: Double?

        @inlinable
        public init(dataTraceEnabled: Bool? = nil, detailedMetricsEnabled: Bool? = nil, loggingLevel: LoggingLevel? = nil, throttlingBurstLimit: Int? = nil, throttlingRateLimit: Double? = nil) {
            self.dataTraceEnabled = dataTraceEnabled
            self.detailedMetricsEnabled = detailedMetricsEnabled
            self.loggingLevel = loggingLevel
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
        }

        private enum CodingKeys: String, CodingKey {
            case dataTraceEnabled = "dataTraceEnabled"
            case detailedMetricsEnabled = "detailedMetricsEnabled"
            case loggingLevel = "loggingLevel"
            case throttlingBurstLimit = "throttlingBurstLimit"
            case throttlingRateLimit = "throttlingRateLimit"
        }
    }

    public struct Stage: AWSDecodableShape {
        /// Settings for logging access in this stage.
        public let accessLogSettings: AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public let apiGatewayManaged: Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public let clientCertificateId: String?
        /// The timestamp when the stage was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// Default route settings for the stage.
        public let defaultRouteSettings: RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public let deploymentId: String?
        /// The description of the stage.
        public let description: String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public let lastDeploymentStatusMessage: String?
        /// The timestamp when the stage was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedDate: Date?
        /// Route settings for the stage, by routeKey.
        public let routeSettings: [String: RouteSettings]?
        /// The name of the stage.
        public let stageName: String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.
        public let stageVariables: [String: String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public let tags: [String: String]?

        @inlinable
        public init(accessLogSettings: AccessLogSettings? = nil, apiGatewayManaged: Bool? = nil, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, createdDate: Date? = nil, defaultRouteSettings: RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, lastDeploymentStatusMessage: String? = nil, lastUpdatedDate: Date? = nil, routeSettings: [String: RouteSettings]? = nil, stageName: String? = nil, stageVariables: [String: String]? = nil, tags: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "accessLogSettings"
            case apiGatewayManaged = "apiGatewayManaged"
            case autoDeploy = "autoDeploy"
            case clientCertificateId = "clientCertificateId"
            case createdDate = "createdDate"
            case defaultRouteSettings = "defaultRouteSettings"
            case deploymentId = "deploymentId"
            case description = "description"
            case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
            case lastUpdatedDate = "lastUpdatedDate"
            case routeSettings = "routeSettings"
            case stageName = "stageName"
            case stageVariables = "stageVariables"
            case tags = "tags"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The resource ARN for the tag.
        public let resourceArn: String
        /// The collection of tags. Each tag element is associated with a given resource.
        public let tags: [String: String]?

        @inlinable
        public init(resourceArn: String, tags: [String: String]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TlsConfig: AWSDecodableShape {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public let serverNameToVerify: String?

        @inlinable
        public init(serverNameToVerify: String? = nil) {
            self.serverNameToVerify = serverNameToVerify
        }

        private enum CodingKeys: String, CodingKey {
            case serverNameToVerify = "serverNameToVerify"
        }
    }

    public struct TlsConfigInput: AWSEncodableShape {
        /// If you specify a server name, API Gateway uses it to verify the hostname on the integration's certificate. The server name is also included in the TLS handshake to support Server Name Indication (SNI) or virtual hosting.
        public let serverNameToVerify: String?

        @inlinable
        public init(serverNameToVerify: String? = nil) {
            self.serverNameToVerify = serverNameToVerify
        }

        private enum CodingKeys: String, CodingKey {
            case serverNameToVerify = "serverNameToVerify"
        }
    }

    public struct TooManyRequestsException: AWSErrorShape {
        /// The limit type.
        public let limitType: String?
        /// Describes the error encountered.
        public let message: String?

        @inlinable
        public init(limitType: String? = nil, message: String? = nil) {
            self.limitType = limitType
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case limitType = "limitType"
            case message = "message"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The resource ARN for the tag.
        public let resourceArn: String
        /// The Tag keys to delete
        public let tagKeys: [String]?

        @inlinable
        public init(resourceArn: String, tagKeys: [String]? = nil) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateApiMappingRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String?
        /// The API mapping identifier.
        public let apiMappingId: String
        /// The API mapping key.
        public let apiMappingKey: String?
        /// The domain name.
        public let domainName: String
        /// The API stage.
        public let stage: String?

        @inlinable
        public init(apiId: String? = nil, apiMappingId: String, apiMappingKey: String? = nil, domainName: String, stage: String? = nil) {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.domainName = domainName
            self.stage = stage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.apiId, forKey: .apiId)
            request.encodePath(self.apiMappingId, key: "ApiMappingId")
            try container.encodeIfPresent(self.apiMappingKey, forKey: .apiMappingKey)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.stage, forKey: .stage)
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case apiMappingKey = "apiMappingKey"
            case stage = "stage"
        }
    }

    public struct UpdateApiMappingResponse: AWSDecodableShape {
        /// The API identifier.
        public let apiId: String?
        /// The API mapping identifier.
        public let apiMappingId: String?
        /// The API mapping key.
        public let apiMappingKey: String?
        /// The API stage.
        public let stage: String?

        @inlinable
        public init(apiId: String? = nil, apiMappingId: String? = nil, apiMappingKey: String? = nil, stage: String? = nil) {
            self.apiId = apiId
            self.apiMappingId = apiMappingId
            self.apiMappingKey = apiMappingKey
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case apiId = "apiId"
            case apiMappingId = "apiMappingId"
            case apiMappingKey = "apiMappingKey"
            case stage = "stage"
        }
    }

    public struct UpdateApiRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public let corsConfiguration: Cors?
        /// This property is part of quick create. It specifies the credentials required for the integration, if any. For a Lambda integration, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, don't specify this parameter. Currently, this property is not used for HTTP integrations. If provided, this value replaces the credentials associated with the quick create integration. Supported only for HTTP APIs.
        public let credentialsArn: String?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The IP address types that can invoke your API or domain name.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// This property is part of quick create. If not specified, the route created using quick create is kept. Otherwise, this value replaces the route key of the quick create route. Additional routes may still be added after the API is updated. Supported only for HTTP APIs.
        public let routeKey: String?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// This property is part of quick create. For HTTP integrations, specify a fully qualified URL. For Lambda integrations, specify a function ARN. The type of the integration will be HTTP_PROXY or AWS_PROXY, respectively. The value provided updates the integration URI and integration type. You can update a quick-created target, but you can't remove it from an API. Supported only for HTTP APIs.
        public let target: String?
        /// A version identifier for the API.
        public let version: String?

        @inlinable
        public init(apiId: String, apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, credentialsArn: String? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, routeKey: String? = nil, routeSelectionExpression: String? = nil, target: String? = nil, version: String? = nil) {
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.credentialsArn = credentialsArn
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.ipAddressType = ipAddressType
            self.name = name
            self.routeKey = routeKey
            self.routeSelectionExpression = routeSelectionExpression
            self.target = target
            self.version = version
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.apiKeySelectionExpression, forKey: .apiKeySelectionExpression)
            try container.encodeIfPresent(self.corsConfiguration, forKey: .corsConfiguration)
            try container.encodeIfPresent(self.credentialsArn, forKey: .credentialsArn)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
            try container.encodeIfPresent(self.disableSchemaValidation, forKey: .disableSchemaValidation)
            try container.encodeIfPresent(self.ipAddressType, forKey: .ipAddressType)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.routeKey, forKey: .routeKey)
            try container.encodeIfPresent(self.routeSelectionExpression, forKey: .routeSelectionExpression)
            try container.encodeIfPresent(self.target, forKey: .target)
            try container.encodeIfPresent(self.version, forKey: .version)
        }

        public func validate(name: String) throws {
            try self.corsConfiguration?.validate(name: "\(name).corsConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case routeKey = "routeKey"
            case routeSelectionExpression = "routeSelectionExpression"
            case target = "target"
            case version = "version"
        }
    }

    public struct UpdateApiResponse: AWSDecodableShape {
        /// The URI of the API, of the form {api-id}.execute-api.{region}.amazonaws.com. The stage name is typically appended to this URI to form a complete path to a deployed API stage.
        public let apiEndpoint: String?
        /// Specifies whether an API is managed by API Gateway. You can't update or delete a managed API by using API Gateway. A managed API can be deleted only through the tooling or service that created it.
        public let apiGatewayManaged: Bool?
        /// The API ID.
        public let apiId: String?
        /// An API key selection expression. Supported only for WebSocket APIs. See API Key Selection Expressions.
        public let apiKeySelectionExpression: String?
        /// A CORS configuration. Supported only for HTTP APIs.
        public let corsConfiguration: Cors?
        /// The timestamp when the API was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The description of the API.
        public let description: String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public let disableExecuteApiEndpoint: Bool?
        /// Avoid validating models when creating a deployment. Supported only for WebSocket APIs.
        public let disableSchemaValidation: Bool?
        /// The validation information during API import. This may include particular properties of your OpenAPI definition which are ignored during import. Supported only for HTTP APIs.
        public let importInfo: [String]?
        /// The IP address types that can invoke the API.
        public let ipAddressType: IpAddressType?
        /// The name of the API.
        public let name: String?
        /// The API protocol.
        public let protocolType: ProtocolType?
        /// The route selection expression for the API. For HTTP APIs, the routeSelectionExpression must be ${request.method} ${request.path}. If not provided, this will be the default for HTTP APIs. This property is required for WebSocket APIs.
        public let routeSelectionExpression: String?
        /// A collection of tags associated with the API.
        public let tags: [String: String]?
        /// A version identifier for the API.
        public let version: String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public let warnings: [String]?

        @inlinable
        public init(apiEndpoint: String? = nil, apiGatewayManaged: Bool? = nil, apiId: String? = nil, apiKeySelectionExpression: String? = nil, corsConfiguration: Cors? = nil, createdDate: Date? = nil, description: String? = nil, disableExecuteApiEndpoint: Bool? = nil, disableSchemaValidation: Bool? = nil, importInfo: [String]? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, protocolType: ProtocolType? = nil, routeSelectionExpression: String? = nil, tags: [String: String]? = nil, version: String? = nil, warnings: [String]? = nil) {
            self.apiEndpoint = apiEndpoint
            self.apiGatewayManaged = apiGatewayManaged
            self.apiId = apiId
            self.apiKeySelectionExpression = apiKeySelectionExpression
            self.corsConfiguration = corsConfiguration
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.disableSchemaValidation = disableSchemaValidation
            self.importInfo = importInfo
            self.ipAddressType = ipAddressType
            self.name = name
            self.protocolType = protocolType
            self.routeSelectionExpression = routeSelectionExpression
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }

        private enum CodingKeys: String, CodingKey {
            case apiEndpoint = "apiEndpoint"
            case apiGatewayManaged = "apiGatewayManaged"
            case apiId = "apiId"
            case apiKeySelectionExpression = "apiKeySelectionExpression"
            case corsConfiguration = "corsConfiguration"
            case createdDate = "createdDate"
            case description = "description"
            case disableExecuteApiEndpoint = "disableExecuteApiEndpoint"
            case disableSchemaValidation = "disableSchemaValidation"
            case importInfo = "importInfo"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case protocolType = "protocolType"
            case routeSelectionExpression = "routeSelectionExpression"
            case tags = "tags"
            case version = "version"
            case warnings = "warnings"
        }
    }

    public struct UpdateAuthorizerRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter.
        public let authorizerCredentialsArn: String?
        /// The authorizer identifier.
        public let authorizerId: String
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see Working with AWS Lambda authorizers for HTTP APIs.
        public let authorizerPayloadFormatVersion: String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public let authorizerResultTtlInSeconds: Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public let authorizerType: AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public let authorizerUri: String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. By default, a Lambda authorizer must return an IAM policy. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see Working with AWS Lambda authorizers for HTTP APIs
        public let enableSimpleResponses: Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see Working with AWS Lambda authorizers for HTTP APIs. For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public let identitySource: [String]?
        /// This parameter is not used.
        public let identityValidationExpression: String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public let jwtConfiguration: JWTConfiguration?
        /// The name of the authorizer.
        public let name: String?

        @inlinable
        public init(apiId: String, authorizerCredentialsArn: String? = nil, authorizerId: String, authorizerPayloadFormatVersion: String? = nil, authorizerResultTtlInSeconds: Int? = nil, authorizerType: AuthorizerType? = nil, authorizerUri: String? = nil, enableSimpleResponses: Bool? = nil, identitySource: [String]? = nil, identityValidationExpression: String? = nil, jwtConfiguration: JWTConfiguration? = nil, name: String? = nil) {
            self.apiId = apiId
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.authorizerCredentialsArn, forKey: .authorizerCredentialsArn)
            request.encodePath(self.authorizerId, key: "AuthorizerId")
            try container.encodeIfPresent(self.authorizerPayloadFormatVersion, forKey: .authorizerPayloadFormatVersion)
            try container.encodeIfPresent(self.authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
            try container.encodeIfPresent(self.authorizerType, forKey: .authorizerType)
            try container.encodeIfPresent(self.authorizerUri, forKey: .authorizerUri)
            try container.encodeIfPresent(self.enableSimpleResponses, forKey: .enableSimpleResponses)
            try container.encodeIfPresent(self.identitySource, forKey: .identitySource)
            try container.encodeIfPresent(self.identityValidationExpression, forKey: .identityValidationExpression)
            try container.encodeIfPresent(self.jwtConfiguration, forKey: .jwtConfiguration)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizerResultTtlInSeconds, name: "authorizerResultTtlInSeconds", parent: name, max: 3600)
            try self.validate(self.authorizerResultTtlInSeconds, name: "authorizerResultTtlInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerCredentialsArn = "authorizerCredentialsArn"
            case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
            case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
            case authorizerType = "authorizerType"
            case authorizerUri = "authorizerUri"
            case enableSimpleResponses = "enableSimpleResponses"
            case identitySource = "identitySource"
            case identityValidationExpression = "identityValidationExpression"
            case jwtConfiguration = "jwtConfiguration"
            case name = "name"
        }
    }

    public struct UpdateAuthorizerResponse: AWSDecodableShape {
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, don't specify this parameter. Supported only for REQUEST authorizers.
        public let authorizerCredentialsArn: String?
        /// The authorizer identifier.
        public let authorizerId: String?
        /// Specifies the format of the payload sent to an HTTP API Lambda authorizer. Required for HTTP API Lambda authorizers. Supported values are 1.0 and 2.0. To learn more, see Working with AWS Lambda authorizers for HTTP APIs.
        public let authorizerPayloadFormatVersion: String?
        /// The time to live (TTL) for cached authorizer results, in seconds. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway caches authorizer responses. The maximum value is 3600, or 1 hour. Supported only for HTTP API Lambda authorizers.
        public let authorizerResultTtlInSeconds: Int?
        /// The authorizer type. Specify REQUEST for a Lambda function using incoming request parameters. Specify JWT to use JSON Web Tokens (supported only for HTTP APIs).
        public let authorizerType: AuthorizerType?
        /// The authorizer's Uniform Resource Identifier (URI). For REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form: arn:aws:apigateway:{region}:lambda:path/{service_api} , where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations. Supported only for REQUEST authorizers.
        public let authorizerUri: String?
        /// Specifies whether a Lambda authorizer returns a response in a simple format. If enabled, the Lambda authorizer can return a boolean value instead of an IAM policy. Supported only for HTTP APIs. To learn more, see Working with AWS Lambda authorizers for HTTP APIs
        public let enableSimpleResponses: Bool?
        /// The identity source for which authorization is requested. For a REQUEST authorizer, this is optional. The value is a set of one or more mapping expressions of the specified request parameters. The identity source can be headers, query string parameters, stage variables, and context parameters. For example, if an Auth header and a Name query string parameter are defined as identity sources, this value is route.request.header.Auth, route.request.querystring.Name for WebSocket APIs. For HTTP APIs, use selection expressions prefixed with $, for example, $request.header.Auth, $request.querystring.Name. These parameters are used to perform runtime validation for Lambda-based authorizers by verifying all of the identity-related request parameters are present in the request, not null, and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function. Otherwise, it returns a 401 Unauthorized response without calling the Lambda function. For HTTP APIs, identity sources are also used as the cache key when caching is enabled. To learn more, see Working with AWS Lambda authorizers for HTTP APIs. For JWT, a single entry that specifies where to extract the JSON Web Token (JWT) from inbound requests. Currently only header-based and query parameter-based selections are supported, for example $request.header.Authorization.
        public let identitySource: [String]?
        /// The validation expression does not apply to the REQUEST authorizer.
        public let identityValidationExpression: String?
        /// Represents the configuration of a JWT authorizer. Required for the JWT authorizer type. Supported only for HTTP APIs.
        public let jwtConfiguration: JWTConfiguration?
        /// The name of the authorizer.
        public let name: String?

        @inlinable
        public init(authorizerCredentialsArn: String? = nil, authorizerId: String? = nil, authorizerPayloadFormatVersion: String? = nil, authorizerResultTtlInSeconds: Int? = nil, authorizerType: AuthorizerType? = nil, authorizerUri: String? = nil, enableSimpleResponses: Bool? = nil, identitySource: [String]? = nil, identityValidationExpression: String? = nil, jwtConfiguration: JWTConfiguration? = nil, name: String? = nil) {
            self.authorizerCredentialsArn = authorizerCredentialsArn
            self.authorizerId = authorizerId
            self.authorizerPayloadFormatVersion = authorizerPayloadFormatVersion
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerType = authorizerType
            self.authorizerUri = authorizerUri
            self.enableSimpleResponses = enableSimpleResponses
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.jwtConfiguration = jwtConfiguration
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case authorizerCredentialsArn = "authorizerCredentialsArn"
            case authorizerId = "authorizerId"
            case authorizerPayloadFormatVersion = "authorizerPayloadFormatVersion"
            case authorizerResultTtlInSeconds = "authorizerResultTtlInSeconds"
            case authorizerType = "authorizerType"
            case authorizerUri = "authorizerUri"
            case enableSimpleResponses = "enableSimpleResponses"
            case identitySource = "identitySource"
            case identityValidationExpression = "identityValidationExpression"
            case jwtConfiguration = "jwtConfiguration"
            case name = "name"
        }
    }

    public struct UpdateDeploymentRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The deployment ID.
        public let deploymentId: String
        /// The description for the deployment resource.
        public let description: String?

        @inlinable
        public init(apiId: String, deploymentId: String, description: String? = nil) {
            self.apiId = apiId
            self.deploymentId = deploymentId
            self.description = description
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            request.encodePath(self.deploymentId, key: "DeploymentId")
            try container.encodeIfPresent(self.description, forKey: .description)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateDeploymentResponse: AWSDecodableShape {
        /// Specifies whether a deployment was automatically released.
        public let autoDeployed: Bool?
        /// The date and time when the Deployment resource was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The identifier for the deployment.
        public let deploymentId: String?
        /// The status of the deployment: PENDING, FAILED, or SUCCEEDED.
        public let deploymentStatus: DeploymentStatus?
        /// May contain additional feedback on the status of an API deployment.
        public let deploymentStatusMessage: String?
        /// The description for the deployment.
        public let description: String?

        @inlinable
        public init(autoDeployed: Bool? = nil, createdDate: Date? = nil, deploymentId: String? = nil, deploymentStatus: DeploymentStatus? = nil, deploymentStatusMessage: String? = nil, description: String? = nil) {
            self.autoDeployed = autoDeployed
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentStatusMessage = deploymentStatusMessage
            self.description = description
        }

        private enum CodingKeys: String, CodingKey {
            case autoDeployed = "autoDeployed"
            case createdDate = "createdDate"
            case deploymentId = "deploymentId"
            case deploymentStatus = "deploymentStatus"
            case deploymentStatusMessage = "deploymentStatusMessage"
            case description = "description"
        }
    }

    public struct UpdateDomainNameRequest: AWSEncodableShape {
        /// The domain name.
        public let domainName: String
        /// The domain name configurations.
        public let domainNameConfigurations: [DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public let mutualTlsAuthentication: MutualTlsAuthenticationInput?

        @inlinable
        public init(domainName: String, domainNameConfigurations: [DomainNameConfiguration]? = nil, mutualTlsAuthentication: MutualTlsAuthenticationInput? = nil) {
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.domainName, key: "DomainName")
            try container.encodeIfPresent(self.domainNameConfigurations, forKey: .domainNameConfigurations)
            try container.encodeIfPresent(self.mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }

        private enum CodingKeys: String, CodingKey {
            case domainNameConfigurations = "domainNameConfigurations"
            case mutualTlsAuthentication = "mutualTlsAuthentication"
        }
    }

    public struct UpdateDomainNameResponse: AWSDecodableShape {
        /// The API mapping selection expression.
        public let apiMappingSelectionExpression: String?
        /// The name of the DomainName resource.
        public let domainName: String?
        /// The domain name configurations.
        public let domainNameConfigurations: [DomainNameConfiguration]?
        /// The mutual TLS authentication configuration for a custom domain name.
        public let mutualTlsAuthentication: MutualTlsAuthentication?
        /// The collection of tags associated with a domain name.
        public let tags: [String: String]?

        @inlinable
        public init(apiMappingSelectionExpression: String? = nil, domainName: String? = nil, domainNameConfigurations: [DomainNameConfiguration]? = nil, mutualTlsAuthentication: MutualTlsAuthentication? = nil, tags: [String: String]? = nil) {
            self.apiMappingSelectionExpression = apiMappingSelectionExpression
            self.domainName = domainName
            self.domainNameConfigurations = domainNameConfigurations
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case apiMappingSelectionExpression = "apiMappingSelectionExpression"
            case domainName = "domainName"
            case domainNameConfigurations = "domainNameConfigurations"
            case mutualTlsAuthentication = "mutualTlsAuthentication"
            case tags = "tags"
        }
    }

    public struct UpdateIntegrationRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public let connectionId: String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public let connectionType: ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public let credentialsArn: String?
        /// The description of the integration
        public let description: String?
        /// The integration ID.
        public let integrationId: String
        /// Specifies the integration's HTTP method type.
        public let integrationMethod: String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see Integration subtype reference.
        public let integrationSubtype: String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. For HTTP API private integrations, use an HTTP_PROXY integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public let integrationType: IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see DiscoverInstances. For private integrations, all resources must be owned by the same AWS account.
        public let integrationUri: String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public let passthroughBehavior: PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see Working with AWS Lambda proxy integrations for HTTP APIs.
        public let payloadFormatVersion: String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where  {location} is querystring, path, or header; and  {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Working with AWS service integrations for HTTP APIs. For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to the backend. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt; where action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let requestParameters: [String: String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public let requestTemplates: [String: String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let responseParameters: [String: [String: String]]?
        /// The template selection expression for the integration.
        public let templateSelectionExpression: String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public let timeoutInMillis: Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public let tlsConfig: TlsConfigInput?

        @inlinable
        public init(apiId: String, connectionId: String? = nil, connectionType: ConnectionType? = nil, contentHandlingStrategy: ContentHandlingStrategy? = nil, credentialsArn: String? = nil, description: String? = nil, integrationId: String, integrationMethod: String? = nil, integrationSubtype: String? = nil, integrationType: IntegrationType? = nil, integrationUri: String? = nil, passthroughBehavior: PassthroughBehavior? = nil, payloadFormatVersion: String? = nil, requestParameters: [String: String]? = nil, requestTemplates: [String: String]? = nil, responseParameters: [String: [String: String]]? = nil, templateSelectionExpression: String? = nil, timeoutInMillis: Int? = nil, tlsConfig: TlsConfigInput? = nil) {
            self.apiId = apiId
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.connectionId, forKey: .connectionId)
            try container.encodeIfPresent(self.connectionType, forKey: .connectionType)
            try container.encodeIfPresent(self.contentHandlingStrategy, forKey: .contentHandlingStrategy)
            try container.encodeIfPresent(self.credentialsArn, forKey: .credentialsArn)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.integrationId, key: "IntegrationId")
            try container.encodeIfPresent(self.integrationMethod, forKey: .integrationMethod)
            try container.encodeIfPresent(self.integrationSubtype, forKey: .integrationSubtype)
            try container.encodeIfPresent(self.integrationType, forKey: .integrationType)
            try container.encodeIfPresent(self.integrationUri, forKey: .integrationUri)
            try container.encodeIfPresent(self.passthroughBehavior, forKey: .passthroughBehavior)
            try container.encodeIfPresent(self.payloadFormatVersion, forKey: .payloadFormatVersion)
            try container.encodeIfPresent(self.requestParameters, forKey: .requestParameters)
            try container.encodeIfPresent(self.requestTemplates, forKey: .requestTemplates)
            try container.encodeIfPresent(self.responseParameters, forKey: .responseParameters)
            try container.encodeIfPresent(self.templateSelectionExpression, forKey: .templateSelectionExpression)
            try container.encodeIfPresent(self.timeoutInMillis, forKey: .timeoutInMillis)
            try container.encodeIfPresent(self.tlsConfig, forKey: .tlsConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.timeoutInMillis, name: "timeoutInMillis", parent: name, max: 30000)
            try self.validate(self.timeoutInMillis, name: "timeoutInMillis", parent: name, min: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case connectionId = "connectionId"
            case connectionType = "connectionType"
            case contentHandlingStrategy = "contentHandlingStrategy"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case integrationMethod = "integrationMethod"
            case integrationSubtype = "integrationSubtype"
            case integrationType = "integrationType"
            case integrationUri = "integrationUri"
            case passthroughBehavior = "passthroughBehavior"
            case payloadFormatVersion = "payloadFormatVersion"
            case requestParameters = "requestParameters"
            case requestTemplates = "requestTemplates"
            case responseParameters = "responseParameters"
            case templateSelectionExpression = "templateSelectionExpression"
            case timeoutInMillis = "timeoutInMillis"
            case tlsConfig = "tlsConfig"
        }
    }

    public struct UpdateIntegrationResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// The integration ID.
        public let integrationId: String
        /// The integration response ID.
        public let integrationResponseId: String
        /// The integration response key.
        public let integrationResponseKey: String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name} , where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression} , where  {name} is a valid and unique response header name and  {JSON-expression} is a valid JSON expression without the $ prefix.
        public let responseParameters: [String: String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public let responseTemplates: [String: String]?
        /// The template selection expression for the integration response. Supported only for WebSocket APIs.
        public let templateSelectionExpression: String?

        @inlinable
        public init(apiId: String, contentHandlingStrategy: ContentHandlingStrategy? = nil, integrationId: String, integrationResponseId: String, integrationResponseKey: String? = nil, responseParameters: [String: String]? = nil, responseTemplates: [String: String]? = nil, templateSelectionExpression: String? = nil) {
            self.apiId = apiId
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationId = integrationId
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.contentHandlingStrategy, forKey: .contentHandlingStrategy)
            request.encodePath(self.integrationId, key: "IntegrationId")
            request.encodePath(self.integrationResponseId, key: "IntegrationResponseId")
            try container.encodeIfPresent(self.integrationResponseKey, forKey: .integrationResponseKey)
            try container.encodeIfPresent(self.responseParameters, forKey: .responseParameters)
            try container.encodeIfPresent(self.responseTemplates, forKey: .responseTemplates)
            try container.encodeIfPresent(self.templateSelectionExpression, forKey: .templateSelectionExpression)
        }

        private enum CodingKeys: String, CodingKey {
            case contentHandlingStrategy = "contentHandlingStrategy"
            case integrationResponseKey = "integrationResponseKey"
            case responseParameters = "responseParameters"
            case responseTemplates = "responseTemplates"
            case templateSelectionExpression = "templateSelectionExpression"
        }
    }

    public struct UpdateIntegrationResponseResponse: AWSDecodableShape {
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// The integration response ID.
        public let integrationResponseId: String?
        /// The integration response key.
        public let integrationResponseKey: String?
        /// A key-value map specifying response parameters that are passed to the method response from the backend. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public let responseParameters: [String: String]?
        /// The collection of response templates for the integration response as a string-to-string map of key-value pairs. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public let responseTemplates: [String: String]?
        /// The template selection expressions for the integration response.
        public let templateSelectionExpression: String?

        @inlinable
        public init(contentHandlingStrategy: ContentHandlingStrategy? = nil, integrationResponseId: String? = nil, integrationResponseKey: String? = nil, responseParameters: [String: String]? = nil, responseTemplates: [String: String]? = nil, templateSelectionExpression: String? = nil) {
            self.contentHandlingStrategy = contentHandlingStrategy
            self.integrationResponseId = integrationResponseId
            self.integrationResponseKey = integrationResponseKey
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.templateSelectionExpression = templateSelectionExpression
        }

        private enum CodingKeys: String, CodingKey {
            case contentHandlingStrategy = "contentHandlingStrategy"
            case integrationResponseId = "integrationResponseId"
            case integrationResponseKey = "integrationResponseKey"
            case responseParameters = "responseParameters"
            case responseTemplates = "responseTemplates"
            case templateSelectionExpression = "templateSelectionExpression"
        }
    }

    public struct UpdateIntegrationResult: AWSDecodableShape {
        /// Specifies whether an integration is managed by API Gateway. If you created an API using using quick create, the resulting integration is managed by API Gateway. You can update a managed integration, but you can't delete it.
        public let apiGatewayManaged: Bool?
        /// The ID of the VPC link for a private integration. Supported only for HTTP APIs.
        public let connectionId: String?
        /// The type of the network connection to the integration endpoint. Specify INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and resources in a VPC. The default value is INTERNET.
        public let connectionType: ConnectionType?
        /// Supported only for WebSocket APIs. Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors: CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob. CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string. If this property is not defined, the response payload will be passed through from the integration response to the route response or method response without modification.
        public let contentHandlingStrategy: ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::*:user/*. To use resource-based permissions on supported AWS services, specify null.
        public let credentialsArn: String?
        /// Represents the description of an integration.
        public let description: String?
        /// Represents the identifier of an integration.
        public let integrationId: String?
        /// Specifies the integration's HTTP method type.
        public let integrationMethod: String?
        /// The integration response selection expression for the integration. Supported only for WebSocket APIs. See Integration Response Selection Expressions.
        public let integrationResponseSelectionExpression: String?
        /// Supported only for HTTP API AWS_PROXY integrations. Specifies the AWS service action to invoke. To learn more, see Integration subtype reference.
        public let integrationSubtype: String?
        /// The integration type of an integration. One of the following: AWS: for integrating the route or method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration. Supported only for WebSocket APIs. AWS_PROXY: for integrating the route or method request with a Lambda function or other AWS service action. This integration is also referred to as a Lambda proxy integration. HTTP: for integrating the route or method request with an HTTP endpoint. This integration is also referred to as the HTTP custom integration. Supported only for WebSocket APIs. HTTP_PROXY: for integrating the route or method request with an HTTP endpoint, with the client request passed through as-is. This is also referred to as HTTP proxy integration. MOCK: for integrating the route or method request with API Gateway as a "loopback" endpoint without invoking any backend. Supported only for WebSocket APIs.
        public let integrationType: IntegrationType?
        /// For a Lambda integration, specify the URI of a Lambda function. For an HTTP integration, specify a fully-qualified URL. For an HTTP API private integration, specify the ARN of an Application Load Balancer listener, Network Load Balancer listener, or AWS Cloud Map service. If you specify the ARN of an AWS Cloud Map service, API Gateway uses DiscoverInstances to identify resources. You can use query parameters to target specific resources. To learn more, see DiscoverInstances. For private integrations, all resources must be owned by the same AWS account.
        public let integrationUri: String?
        /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER. Supported only for WebSocket APIs. WHEN_NO_MATCH passes the request body for unmapped content types through to the integration backend without transformation. NEVER rejects unmapped content types with an HTTP 415 Unsupported Media Type response. WHEN_NO_TEMPLATES allows pass-through when the integration has no content types mapped to templates. However, if there is at least one content type defined, unmapped content types will be rejected with the same HTTP 415 Unsupported Media Type response.
        public let passthroughBehavior: PassthroughBehavior?
        /// Specifies the format of the payload sent to an integration. Required for HTTP APIs. Supported values for Lambda proxy integrations are 1.0 and 2.0. For all other integrations, 1.0 is the only supported value. To learn more, see Working with AWS Lambda proxy integrations for HTTP APIs.
        public let payloadFormatVersion: String?
        /// For WebSocket APIs, a key-value map specifying request parameters that are passed from the method request to the backend. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the backend. The method request parameter value must match the pattern of method.request.{location}.{name} , where  {location} is querystring, path, or header; and  {name} must be a valid and unique method request parameter name. For HTTP API integrations with a specified integrationSubtype, request parameters are a key-value map specifying parameters that are passed to AWS_PROXY integrations. You can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Working with AWS service integrations for HTTP APIs. For HTTP API integrations, without a specified integrationSubtype request parameters are a key-value map specifying how to transform HTTP requests before sending them to backend integrations. The key should follow the pattern &lt;action&gt;:&lt;header|querystring|path&gt;.&lt;location&gt;. The action can be append, overwrite or remove. For values, you can provide static values, or map request data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let requestParameters: [String: String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value. Supported only for WebSocket APIs.
        public let requestTemplates: [String: String]?
        /// Supported only for HTTP APIs. You use response parameters to transform the HTTP response from a backend integration before returning the response to clients. Specify a key-value map from a selection key to response parameters. The selection key must be a valid HTTP status code within the range of 200-599. Response parameters are a key-value map. The key must match pattern &lt;action&gt;:&lt;header&gt;.&lt;location&gt; or overwrite.statuscode. The action can be append, overwrite or remove. The value can be a static value, or map to response data, stage variables, or context variables that are evaluated at runtime. To learn more, see Transforming API requests and responses.
        public let responseParameters: [String: [String: String]]?
        /// The template selection expression for the integration. Supported only for WebSocket APIs.
        public let templateSelectionExpression: String?
        /// Custom timeout between 50 and 29,000 milliseconds for WebSocket APIs and between 50 and 30,000 milliseconds for HTTP APIs. The default timeout is 29 seconds for WebSocket APIs and 30 seconds for HTTP APIs.
        public let timeoutInMillis: Int?
        /// The TLS configuration for a private integration. If you specify a TLS configuration, private integration traffic uses the HTTPS protocol. Supported only for HTTP APIs.
        public let tlsConfig: TlsConfig?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, connectionId: String? = nil, connectionType: ConnectionType? = nil, contentHandlingStrategy: ContentHandlingStrategy? = nil, credentialsArn: String? = nil, description: String? = nil, integrationId: String? = nil, integrationMethod: String? = nil, integrationResponseSelectionExpression: String? = nil, integrationSubtype: String? = nil, integrationType: IntegrationType? = nil, integrationUri: String? = nil, passthroughBehavior: PassthroughBehavior? = nil, payloadFormatVersion: String? = nil, requestParameters: [String: String]? = nil, requestTemplates: [String: String]? = nil, responseParameters: [String: [String: String]]? = nil, templateSelectionExpression: String? = nil, timeoutInMillis: Int? = nil, tlsConfig: TlsConfig? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandlingStrategy = contentHandlingStrategy
            self.credentialsArn = credentialsArn
            self.description = description
            self.integrationId = integrationId
            self.integrationMethod = integrationMethod
            self.integrationResponseSelectionExpression = integrationResponseSelectionExpression
            self.integrationSubtype = integrationSubtype
            self.integrationType = integrationType
            self.integrationUri = integrationUri
            self.passthroughBehavior = passthroughBehavior
            self.payloadFormatVersion = payloadFormatVersion
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.responseParameters = responseParameters
            self.templateSelectionExpression = templateSelectionExpression
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case connectionId = "connectionId"
            case connectionType = "connectionType"
            case contentHandlingStrategy = "contentHandlingStrategy"
            case credentialsArn = "credentialsArn"
            case description = "description"
            case integrationId = "integrationId"
            case integrationMethod = "integrationMethod"
            case integrationResponseSelectionExpression = "integrationResponseSelectionExpression"
            case integrationSubtype = "integrationSubtype"
            case integrationType = "integrationType"
            case integrationUri = "integrationUri"
            case passthroughBehavior = "passthroughBehavior"
            case payloadFormatVersion = "payloadFormatVersion"
            case requestParameters = "requestParameters"
            case requestTemplates = "requestTemplates"
            case responseParameters = "responseParameters"
            case templateSelectionExpression = "templateSelectionExpression"
            case timeoutInMillis = "timeoutInMillis"
            case tlsConfig = "tlsConfig"
        }
    }

    public struct UpdateModelRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The content-type for the model, for example, "application/json".
        public let contentType: String?
        /// The description of the model.
        public let description: String?
        /// The model ID.
        public let modelId: String
        /// The name of the model.
        public let name: String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public let schema: String?

        @inlinable
        public init(apiId: String, contentType: String? = nil, description: String? = nil, modelId: String, name: String? = nil, schema: String? = nil) {
            self.apiId = apiId
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.contentType, forKey: .contentType)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.modelId, key: "ModelId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.schema, forKey: .schema)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case description = "description"
            case name = "name"
            case schema = "schema"
        }
    }

    public struct UpdateModelResponse: AWSDecodableShape {
        /// The content-type for the model, for example, "application/json".
        public let contentType: String?
        /// The description of the model.
        public let description: String?
        /// The model identifier.
        public let modelId: String?
        /// The name of the model. Must be alphanumeric.
        public let name: String?
        /// The schema for the model. For application/json models, this should be JSON schema draft 4 model.
        public let schema: String?

        @inlinable
        public init(contentType: String? = nil, description: String? = nil, modelId: String? = nil, name: String? = nil, schema: String? = nil) {
            self.contentType = contentType
            self.description = description
            self.modelId = modelId
            self.name = name
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "contentType"
            case description = "description"
            case modelId = "modelId"
            case name = "name"
            case schema = "schema"
        }
    }

    public struct UpdateRouteRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// Specifies whether an API key is required for the route. Supported only for WebSocket APIs.
        public let apiKeyRequired: Bool?
        /// The authorization scopes supported by this route.
        public let authorizationScopes: [String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public let authorizationType: AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public let authorizerId: String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The operation name for the route.
        public let operationName: String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public let requestModels: [String: String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public let requestParameters: [String: ParameterConstraints]?
        /// The route ID.
        public let routeId: String
        /// The route key for the route.
        public let routeKey: String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public let routeResponseSelectionExpression: String?
        /// The target for the route.
        public let target: String?

        @inlinable
        public init(apiId: String, apiKeyRequired: Bool? = nil, authorizationScopes: [String]? = nil, authorizationType: AuthorizationType? = nil, authorizerId: String? = nil, modelSelectionExpression: String? = nil, operationName: String? = nil, requestModels: [String: String]? = nil, requestParameters: [String: ParameterConstraints]? = nil, routeId: String, routeKey: String? = nil, routeResponseSelectionExpression: String? = nil, target: String? = nil) {
            self.apiId = apiId
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.apiKeyRequired, forKey: .apiKeyRequired)
            try container.encodeIfPresent(self.authorizationScopes, forKey: .authorizationScopes)
            try container.encodeIfPresent(self.authorizationType, forKey: .authorizationType)
            try container.encodeIfPresent(self.authorizerId, forKey: .authorizerId)
            try container.encodeIfPresent(self.modelSelectionExpression, forKey: .modelSelectionExpression)
            try container.encodeIfPresent(self.operationName, forKey: .operationName)
            try container.encodeIfPresent(self.requestModels, forKey: .requestModels)
            try container.encodeIfPresent(self.requestParameters, forKey: .requestParameters)
            request.encodePath(self.routeId, key: "RouteId")
            try container.encodeIfPresent(self.routeKey, forKey: .routeKey)
            try container.encodeIfPresent(self.routeResponseSelectionExpression, forKey: .routeResponseSelectionExpression)
            try container.encodeIfPresent(self.target, forKey: .target)
        }

        private enum CodingKeys: String, CodingKey {
            case apiKeyRequired = "apiKeyRequired"
            case authorizationScopes = "authorizationScopes"
            case authorizationType = "authorizationType"
            case authorizerId = "authorizerId"
            case modelSelectionExpression = "modelSelectionExpression"
            case operationName = "operationName"
            case requestModels = "requestModels"
            case requestParameters = "requestParameters"
            case routeKey = "routeKey"
            case routeResponseSelectionExpression = "routeResponseSelectionExpression"
            case target = "target"
        }
    }

    public struct UpdateRouteResponseRequest: AWSEncodableShape {
        /// The API identifier.
        public let apiId: String
        /// The model selection expression for the route response. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The response models for the route response.
        public let responseModels: [String: String]?
        /// The route response parameters.
        public let responseParameters: [String: ParameterConstraints]?
        /// The route ID.
        public let routeId: String
        /// The route response ID.
        public let routeResponseId: String
        /// The route response key.
        public let routeResponseKey: String?

        @inlinable
        public init(apiId: String, modelSelectionExpression: String? = nil, responseModels: [String: String]? = nil, responseParameters: [String: ParameterConstraints]? = nil, routeId: String, routeResponseId: String, routeResponseKey: String? = nil) {
            self.apiId = apiId
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeId = routeId
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.modelSelectionExpression, forKey: .modelSelectionExpression)
            try container.encodeIfPresent(self.responseModels, forKey: .responseModels)
            try container.encodeIfPresent(self.responseParameters, forKey: .responseParameters)
            request.encodePath(self.routeId, key: "RouteId")
            request.encodePath(self.routeResponseId, key: "RouteResponseId")
            try container.encodeIfPresent(self.routeResponseKey, forKey: .routeResponseKey)
        }

        private enum CodingKeys: String, CodingKey {
            case modelSelectionExpression = "modelSelectionExpression"
            case responseModels = "responseModels"
            case responseParameters = "responseParameters"
            case routeResponseKey = "routeResponseKey"
        }
    }

    public struct UpdateRouteResponseResponse: AWSDecodableShape {
        /// Represents the model selection expression of a route response. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// Represents the response models of a route response.
        public let responseModels: [String: String]?
        /// Represents the response parameters of a route response.
        public let responseParameters: [String: ParameterConstraints]?
        /// Represents the identifier of a route response.
        public let routeResponseId: String?
        /// Represents the route response key of a route response.
        public let routeResponseKey: String?

        @inlinable
        public init(modelSelectionExpression: String? = nil, responseModels: [String: String]? = nil, responseParameters: [String: ParameterConstraints]? = nil, routeResponseId: String? = nil, routeResponseKey: String? = nil) {
            self.modelSelectionExpression = modelSelectionExpression
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.routeResponseId = routeResponseId
            self.routeResponseKey = routeResponseKey
        }

        private enum CodingKeys: String, CodingKey {
            case modelSelectionExpression = "modelSelectionExpression"
            case responseModels = "responseModels"
            case responseParameters = "responseParameters"
            case routeResponseId = "routeResponseId"
            case routeResponseKey = "routeResponseKey"
        }
    }

    public struct UpdateRouteResult: AWSDecodableShape {
        /// Specifies whether a route is managed by API Gateway. If you created an API using quick create, the $default route is managed by API Gateway. You can't modify the $default route key.
        public let apiGatewayManaged: Bool?
        /// Specifies whether an API key is required for this route. Supported only for WebSocket APIs.
        public let apiKeyRequired: Bool?
        /// A list of authorization scopes configured on a route. The scopes are used with a JWT authorizer to authorize the method invocation. The authorization works by matching the route scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any route scope matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the route scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public let authorizationScopes: [String]?
        /// The authorization type for the route. For WebSocket APIs, valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer For HTTP APIs, valid values are NONE for open access, JWT for using JSON Web Tokens, AWS_IAM for using AWS IAM permissions, and CUSTOM for using a Lambda authorizer.
        public let authorizationType: AuthorizationType?
        /// The identifier of the Authorizer resource to be associated with this route. The authorizer identifier is generated by API Gateway when you created the authorizer.
        public let authorizerId: String?
        /// The model selection expression for the route. Supported only for WebSocket APIs.
        public let modelSelectionExpression: String?
        /// The operation name for the route.
        public let operationName: String?
        /// The request models for the route. Supported only for WebSocket APIs.
        public let requestModels: [String: String]?
        /// The request parameters for the route. Supported only for WebSocket APIs.
        public let requestParameters: [String: ParameterConstraints]?
        /// The route ID.
        public let routeId: String?
        /// The route key for the route.
        public let routeKey: String?
        /// The route response selection expression for the route. Supported only for WebSocket APIs.
        public let routeResponseSelectionExpression: String?
        /// The target for the route.
        public let target: String?

        @inlinable
        public init(apiGatewayManaged: Bool? = nil, apiKeyRequired: Bool? = nil, authorizationScopes: [String]? = nil, authorizationType: AuthorizationType? = nil, authorizerId: String? = nil, modelSelectionExpression: String? = nil, operationName: String? = nil, requestModels: [String: String]? = nil, requestParameters: [String: ParameterConstraints]? = nil, routeId: String? = nil, routeKey: String? = nil, routeResponseSelectionExpression: String? = nil, target: String? = nil) {
            self.apiGatewayManaged = apiGatewayManaged
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.modelSelectionExpression = modelSelectionExpression
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.routeId = routeId
            self.routeKey = routeKey
            self.routeResponseSelectionExpression = routeResponseSelectionExpression
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case apiGatewayManaged = "apiGatewayManaged"
            case apiKeyRequired = "apiKeyRequired"
            case authorizationScopes = "authorizationScopes"
            case authorizationType = "authorizationType"
            case authorizerId = "authorizerId"
            case modelSelectionExpression = "modelSelectionExpression"
            case operationName = "operationName"
            case requestModels = "requestModels"
            case requestParameters = "requestParameters"
            case routeId = "routeId"
            case routeKey = "routeKey"
            case routeResponseSelectionExpression = "routeResponseSelectionExpression"
            case target = "target"
        }
    }

    public struct UpdateStageRequest: AWSEncodableShape {
        /// Settings for logging access in this stage.
        public let accessLogSettings: AccessLogSettings?
        /// The API identifier.
        public let apiId: String
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a Stage.
        public let clientCertificateId: String?
        /// The default route settings for the stage.
        public let defaultRouteSettings: RouteSettings?
        /// The deployment identifier for the API stage. Can't be updated if autoDeploy is enabled.
        public let deploymentId: String?
        /// The description for the API stage.
        public let description: String?
        /// Route settings for the stage.
        public let routeSettings: [String: RouteSettings]?
        /// The stage name. Stage names can contain only alphanumeric characters, hyphens, and underscores, or be $default. Maximum length is 128 characters.
        public let stageName: String
        /// A map that defines the stage variables for a Stage. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.
        public let stageVariables: [String: String]?

        @inlinable
        public init(accessLogSettings: AccessLogSettings? = nil, apiId: String, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, defaultRouteSettings: RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, routeSettings: [String: RouteSettings]? = nil, stageName: String, stageVariables: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiId = apiId
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.accessLogSettings, forKey: .accessLogSettings)
            request.encodePath(self.apiId, key: "ApiId")
            try container.encodeIfPresent(self.autoDeploy, forKey: .autoDeploy)
            try container.encodeIfPresent(self.clientCertificateId, forKey: .clientCertificateId)
            try container.encodeIfPresent(self.defaultRouteSettings, forKey: .defaultRouteSettings)
            try container.encodeIfPresent(self.deploymentId, forKey: .deploymentId)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.routeSettings, forKey: .routeSettings)
            request.encodePath(self.stageName, key: "StageName")
            try container.encodeIfPresent(self.stageVariables, forKey: .stageVariables)
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "accessLogSettings"
            case autoDeploy = "autoDeploy"
            case clientCertificateId = "clientCertificateId"
            case defaultRouteSettings = "defaultRouteSettings"
            case deploymentId = "deploymentId"
            case description = "description"
            case routeSettings = "routeSettings"
            case stageVariables = "stageVariables"
        }
    }

    public struct UpdateStageResponse: AWSDecodableShape {
        /// Settings for logging access in this stage.
        public let accessLogSettings: AccessLogSettings?
        /// Specifies whether a stage is managed by API Gateway. If you created an API using quick create, the $default stage is managed by API Gateway. You can't modify the $default stage.
        public let apiGatewayManaged: Bool?
        /// Specifies whether updates to an API automatically trigger a new deployment. The default value is false.
        public let autoDeploy: Bool?
        /// The identifier of a client certificate for a Stage. Supported only for WebSocket APIs.
        public let clientCertificateId: String?
        /// The timestamp when the stage was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// Default route settings for the stage.
        public let defaultRouteSettings: RouteSettings?
        /// The identifier of the Deployment that the Stage is associated with. Can't be updated if autoDeploy is enabled.
        public let deploymentId: String?
        /// The description of the stage.
        public let description: String?
        /// Describes the status of the last deployment of a stage. Supported only for stages with autoDeploy enabled.
        public let lastDeploymentStatusMessage: String?
        /// The timestamp when the stage was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedDate: Date?
        /// Route settings for the stage, by routeKey.
        public let routeSettings: [String: RouteSettings]?
        /// The name of the stage.
        public let stageName: String?
        /// A map that defines the stage variables for a stage resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&amp;=,]+.
        public let stageVariables: [String: String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public let tags: [String: String]?

        @inlinable
        public init(accessLogSettings: AccessLogSettings? = nil, apiGatewayManaged: Bool? = nil, autoDeploy: Bool? = nil, clientCertificateId: String? = nil, createdDate: Date? = nil, defaultRouteSettings: RouteSettings? = nil, deploymentId: String? = nil, description: String? = nil, lastDeploymentStatusMessage: String? = nil, lastUpdatedDate: Date? = nil, routeSettings: [String: RouteSettings]? = nil, stageName: String? = nil, stageVariables: [String: String]? = nil, tags: [String: String]? = nil) {
            self.accessLogSettings = accessLogSettings
            self.apiGatewayManaged = apiGatewayManaged
            self.autoDeploy = autoDeploy
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.defaultRouteSettings = defaultRouteSettings
            self.deploymentId = deploymentId
            self.description = description
            self.lastDeploymentStatusMessage = lastDeploymentStatusMessage
            self.lastUpdatedDate = lastUpdatedDate
            self.routeSettings = routeSettings
            self.stageName = stageName
            self.stageVariables = stageVariables
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case accessLogSettings = "accessLogSettings"
            case apiGatewayManaged = "apiGatewayManaged"
            case autoDeploy = "autoDeploy"
            case clientCertificateId = "clientCertificateId"
            case createdDate = "createdDate"
            case defaultRouteSettings = "defaultRouteSettings"
            case deploymentId = "deploymentId"
            case description = "description"
            case lastDeploymentStatusMessage = "lastDeploymentStatusMessage"
            case lastUpdatedDate = "lastUpdatedDate"
            case routeSettings = "routeSettings"
            case stageName = "stageName"
            case stageVariables = "stageVariables"
            case tags = "tags"
        }
    }

    public struct UpdateVpcLinkRequest: AWSEncodableShape {
        /// The name of the VPC link.
        public let name: String?
        /// The ID of the VPC link.
        public let vpcLinkId: String

        @inlinable
        public init(name: String? = nil, vpcLinkId: String) {
            self.name = name
            self.vpcLinkId = vpcLinkId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.vpcLinkId, key: "VpcLinkId")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct UpdateVpcLinkResponse: AWSDecodableShape {
        /// The timestamp when the VPC link was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The name of the VPC link.
        public let name: String?
        /// A list of security group IDs for the VPC link.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs to include in the VPC link.
        public let subnetIds: [String]?
        /// Tags for the VPC link.
        public let tags: [String: String]?
        /// The ID of the VPC link.
        public let vpcLinkId: String?
        /// The status of the VPC link.
        public let vpcLinkStatus: VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public let vpcLinkStatusMessage: String?
        /// The version of the VPC link.
        public let vpcLinkVersion: VpcLinkVersion?

        @inlinable
        public init(createdDate: Date? = nil, name: String? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, vpcLinkId: String? = nil, vpcLinkStatus: VpcLinkStatus? = nil, vpcLinkStatusMessage: String? = nil, vpcLinkVersion: VpcLinkVersion? = nil) {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcLinkId = "vpcLinkId"
            case vpcLinkStatus = "vpcLinkStatus"
            case vpcLinkStatusMessage = "vpcLinkStatusMessage"
            case vpcLinkVersion = "vpcLinkVersion"
        }
    }

    public struct VpcLink: AWSDecodableShape {
        /// The timestamp when the VPC link was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdDate: Date?
        /// The name of the VPC link.
        public let name: String?
        /// A list of security group IDs for the VPC link.
        public let securityGroupIds: [String]?
        /// A list of subnet IDs to include in the VPC link.
        public let subnetIds: [String]?
        /// Tags for the VPC link.
        public let tags: [String: String]?
        /// The ID of the VPC link.
        public let vpcLinkId: String?
        /// The status of the VPC link.
        public let vpcLinkStatus: VpcLinkStatus?
        /// A message summarizing the cause of the status of the VPC link.
        public let vpcLinkStatusMessage: String?
        /// The version of the VPC link.
        public let vpcLinkVersion: VpcLinkVersion?

        @inlinable
        public init(createdDate: Date? = nil, name: String? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, tags: [String: String]? = nil, vpcLinkId: String? = nil, vpcLinkStatus: VpcLinkStatus? = nil, vpcLinkStatusMessage: String? = nil, vpcLinkVersion: VpcLinkVersion? = nil) {
            self.createdDate = createdDate
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcLinkId = vpcLinkId
            self.vpcLinkStatus = vpcLinkStatus
            self.vpcLinkStatusMessage = vpcLinkStatusMessage
            self.vpcLinkVersion = vpcLinkVersion
        }

        private enum CodingKeys: String, CodingKey {
            case createdDate = "createdDate"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcLinkId = "vpcLinkId"
            case vpcLinkStatus = "vpcLinkStatus"
            case vpcLinkStatusMessage = "vpcLinkStatusMessage"
            case vpcLinkVersion = "vpcLinkVersion"
        }
    }
}

// MARK: - Errors

/// Error enum for ApiGatewayV2
public struct ApiGatewayV2ErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case notFoundException = "NotFoundException"
        case tooManyRequestsException = "TooManyRequestsException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ApiGatewayV2
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request. See the accompanying error message for details.
    public static var conflictException: Self { .init(.conflictException) }
    /// The resource specified in the request was not found. See the message field for more information.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// A limit has been exceeded. See the accompanying error message for details.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
}

extension ApiGatewayV2ErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "NotFoundException": ApiGatewayV2.NotFoundException.self,
        "TooManyRequestsException": ApiGatewayV2.TooManyRequestsException.self
    ]
}

extension ApiGatewayV2ErrorType: Equatable {
    public static func == (lhs: ApiGatewayV2ErrorType, rhs: ApiGatewayV2ErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ApiGatewayV2ErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
