//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension InternetMonitor {
    // MARK: Enums

    public enum HealthEventImpactType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case availability = "AVAILABILITY"
        case localAvailability = "LOCAL_AVAILABILITY"
        case localPerformance = "LOCAL_PERFORMANCE"
        case performance = "PERFORMANCE"
        public var description: String { return self.rawValue }
    }

    public enum HealthEventStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum LocalHealthEventsConfigStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum LogDeliveryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MonitorConfigState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case error = "ERROR"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum MonitorProcessingStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case collectingData = "COLLECTING_DATA"
        case faultAccessCloudwatch = "FAULT_ACCESS_CLOUDWATCH"
        case faultService = "FAULT_SERVICE"
        case inactive = "INACTIVE"
        case insufficientData = "INSUFFICIENT_DATA"
        case ok = "OK"
        public var description: String { return self.rawValue }
    }

    public enum Operator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum QueryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case queued = "QUEUED"
        case running = "RUNNING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum QueryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case measurements = "MEASUREMENTS"
        case topLocations = "TOP_LOCATIONS"
        case topLocationDetails = "TOP_LOCATION_DETAILS"
        public var description: String { return self.rawValue }
    }

    public enum TriangulationEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aws = "AWS"
        case internet = "Internet"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AvailabilityMeasurement: AWSDecodableShape {
        /// Experience scores, or health scores are calculated for different geographic and network provider combinations (that is, different granularities) and
        /// 			also summed into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor
        /// 			provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and
        /// 			availability scores, and when it creates and resolves health events. For more information, see How Amazon Web Services calculates performance and
        /// 				availability scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let experienceScore: Double?
        /// The percentage of impact caused by a health event for client location traffic globally. For information about how Internet Monitor calculates impact, see Inside Internet Monitor in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User
        /// 			Guide.
        public let percentOfClientLocationImpacted: Double?
        /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the
        /// 			percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this
        /// 			client location to the Amazon Web Services location using this client network. For information about how Internet Monitor calculates impact, see How Internet Monitor works in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User
        /// 			Guide.
        public let percentOfTotalTrafficImpacted: Double?

        public init(experienceScore: Double? = nil, percentOfClientLocationImpacted: Double? = nil, percentOfTotalTrafficImpacted: Double? = nil) {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
        }

        private enum CodingKeys: String, CodingKey {
            case experienceScore = "ExperienceScore"
            case percentOfClientLocationImpacted = "PercentOfClientLocationImpacted"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
        }
    }

    public struct CreateMonitorInput: AWSEncodableShape {
        /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for
        /// 			other API requests.
        public let clientToken: String?
        /// Defines the threshold percentages and other configuration information for when Amazon CloudWatch Internet Monitor creates a health event. Internet Monitor creates a
        /// 			health event when an internet issue that affects your application end users has a health score percentage that is at or below a
        /// 			specific threshold, and, sometimes, when other criteria are met. If you don't set a health event threshold, the default value is 95%. For more information, see
        /// 			Change health event thresholds in the Internet Monitor section of the CloudWatch User Guide.
        public let healthEventsConfig: HealthEventsConfig?
        /// Publish internet measurements for Internet Monitor to an Amazon S3 bucket in addition to CloudWatch Logs.
        public let internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery?
        /// The maximum number of city-networks to monitor for your resources. A city-network is the location (city) where clients access your
        /// 			application resources from and the ASN or network provider, such as an internet service provider (ISP), that clients access the resources
        /// 			through. Setting this limit can help control billing costs. To learn more, see Choosing a city-network maximum value
        /// 		 in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let maxCityNetworksToMonitor: Int?
        /// The name of the monitor.
        public let monitorName: String
        /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). Resources can be VPCs, NLBs,
        /// 			Amazon CloudFront distributions, or Amazon WorkSpaces directories. You can add a combination of VPCs and CloudFront distributions, or you can add WorkSpaces directories, or you can add NLBs. You can't add
        /// 			NLBs or WorkSpaces directories together with any other resources.  If you add only Amazon VPC resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has
        /// 			internet connectivity.
        public let resources: [String]?
        /// The tags for a monitor. You can add a maximum of 50 tags in Internet Monitor.
        public let tags: [String: String]?
        /// The percentage of the internet-facing traffic for your application that you want to monitor with this monitor. If you set a city-networks
        /// 			maximum, that limit overrides the traffic percentage that you set. To learn more, see Choosing an application traffic percentage to monitor
        /// 		 in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let trafficPercentageToMonitor: Int?

        public init(clientToken: String? = CreateMonitorInput.idempotencyToken(), healthEventsConfig: HealthEventsConfig? = nil, internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery? = nil, maxCityNetworksToMonitor: Int? = nil, monitorName: String, resources: [String]? = nil, tags: [String: String]? = nil, trafficPercentageToMonitor: Int? = nil) {
            self.clientToken = clientToken
            self.healthEventsConfig = healthEventsConfig
            self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
            self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
            self.monitorName = monitorName
            self.resources = resources
            self.tags = tags
            self.trafficPercentageToMonitor = trafficPercentageToMonitor
        }

        public func validate(name: String) throws {
            try self.healthEventsConfig?.validate(name: "\(name).healthEventsConfig")
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, max: 500000)
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.resources?.forEach {
                try validate($0, name: "resources[]", parent: name, max: 2048)
                try validate($0, name: "resources[]", parent: name, min: 20)
                try validate($0, name: "resources[]", parent: name, pattern: "^arn:.*")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, max: 100)
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case healthEventsConfig = "HealthEventsConfig"
            case internetMeasurementsLogDelivery = "InternetMeasurementsLogDelivery"
            case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
            case monitorName = "MonitorName"
            case resources = "Resources"
            case tags = "Tags"
            case trafficPercentageToMonitor = "TrafficPercentageToMonitor"
        }
    }

    public struct CreateMonitorOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor.
        public let arn: String
        /// The status of a monitor.
        public let status: MonitorConfigState

        public init(arn: String, status: MonitorConfigState) {
            self.arn = arn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case status = "Status"
        }
    }

    public struct DeleteMonitorInput: AWSEncodableShape {
        /// The name of the monitor to delete.
        public let monitorName: String

        public init(monitorName: String) {
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "MonitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMonitorOutput: AWSDecodableShape {
        public init() {}
    }

    public struct FilterParameter: AWSEncodableShape {
        /// A data field that you want to filter, to further scope your application's Internet Monitor data in a repository that you
        /// 			created by running a query. A field might be city, for example. The field must be one of the fields
        /// 			that was returned by the specific query that you used to create the repository.
        public let field: String?
        /// The operator to use with the filter field and a value, such as not_equals.
        public let `operator`: Operator?
        /// One or more values to be used, together with the specified operator, to filter data for a query.
        /// 			For example, you could specify an array of values such as ["Seattle", "Redmond"]. Values in the array are separated by
        /// 			commas.
        public let values: [String]?

        public init(field: String? = nil, operator: Operator? = nil, values: [String]? = nil) {
            self.field = field
            self.`operator` = `operator`
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case field = "Field"
            case `operator` = "Operator"
            case values = "Values"
        }
    }

    public struct GetHealthEventInput: AWSEncodableShape {
        /// The internally-generated identifier of a health event. Because EventID contains the forward slash (“/”) character, you must
        /// 			URL-encode the EventID field in the request URL.
        public let eventId: String
        /// TBD
        public let linkedAccountId: String?
        /// The name of the monitor.
        public let monitorName: String

        public init(eventId: String, linkedAccountId: String? = nil, monitorName: String) {
            self.eventId = eventId
            self.linkedAccountId = linkedAccountId
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventId, key: "EventId")
            request.encodeQuery(self.linkedAccountId, key: "LinkedAccountId")
            request.encodePath(self.monitorName, key: "MonitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 255)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[a-zA-Z0-9/_.-]+$")
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, max: 12)
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, min: 12)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetHealthEventOutput: AWSDecodableShape {
        /// The time when a health event was created.
        public let createdAt: Date?
        /// The time when a health event was resolved. If the health event is still active, the end time is not set.
        public let endedAt: Date?
        /// The Amazon Resource Name (ARN) of the event.
        public let eventArn: String
        /// The internally-generated identifier of a health event.
        public let eventId: String
        /// The threshold percentage for a health score that determines, along with other configuration information,
        /// 			when Internet Monitor creates a health event when there's an internet issue that affects your application end users.
        public let healthScoreThreshold: Double?
        /// The locations affected by a health event.
        public let impactedLocations: [ImpactedLocation]
        /// The type of impairment of a specific health event.
        public let impactType: HealthEventImpactType
        /// The time when a health event was last updated or recalculated.
        public let lastUpdatedAt: Date
        /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the
        /// 			percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this
        /// 			client location to the Amazon Web Services location using this client network.
        public let percentOfTotalTrafficImpacted: Double?
        /// The time when a health event started.
        public let startedAt: Date
        /// The status of a health event.
        public let status: HealthEventStatus

        public init(createdAt: Date? = nil, endedAt: Date? = nil, eventArn: String, eventId: String, healthScoreThreshold: Double? = nil, impactedLocations: [ImpactedLocation], impactType: HealthEventImpactType, lastUpdatedAt: Date, percentOfTotalTrafficImpacted: Double? = nil, startedAt: Date, status: HealthEventStatus) {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.eventArn = eventArn
            self.eventId = eventId
            self.healthScoreThreshold = healthScoreThreshold
            self.impactedLocations = impactedLocations
            self.impactType = impactType
            self.lastUpdatedAt = lastUpdatedAt
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case endedAt = "EndedAt"
            case eventArn = "EventArn"
            case eventId = "EventId"
            case healthScoreThreshold = "HealthScoreThreshold"
            case impactedLocations = "ImpactedLocations"
            case impactType = "ImpactType"
            case lastUpdatedAt = "LastUpdatedAt"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct GetMonitorInput: AWSEncodableShape {
        /// TBD
        public let linkedAccountId: String?
        /// The name of the monitor.
        public let monitorName: String

        public init(linkedAccountId: String? = nil, monitorName: String) {
            self.linkedAccountId = linkedAccountId
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.linkedAccountId, key: "LinkedAccountId")
            request.encodePath(self.monitorName, key: "MonitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, max: 12)
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, min: 12)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMonitorOutput: AWSDecodableShape {
        /// The time when the monitor was created.
        public let createdAt: Date
        /// The list of health event threshold configurations. The threshold percentage for a health score determines, along with other configuration
        /// 			information, when Internet Monitor creates a health event when there's an internet issue that affects your application end users. For more information, see
        /// 			Change health event thresholds in the Internet Monitor section of the CloudWatch User Guide.
        public let healthEventsConfig: HealthEventsConfig?
        /// Publish internet measurements for Internet Monitor to another location, such as an Amazon S3 bucket. The measurements are also published to Amazon CloudWatch Logs.
        public let internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery?
        /// The maximum number of city-networks to monitor for your resources. A city-network is the location (city) where clients access your
        /// 			application resources from and the ASN or network provider, such as an internet service provider (ISP), that clients access the resources
        /// 			through. This limit can help control billing costs. To learn more, see Choosing a city-network maximum value
        /// 		 in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let maxCityNetworksToMonitor: Int?
        /// The last time that the monitor was modified.
        public let modifiedAt: Date
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The health of the data processing for the monitor.
        public let processingStatus: MonitorProcessingStatusCode?
        /// Additional information about the health of the data processing for the monitor.
        public let processingStatusInfo: String?
        /// The resources monitored by the monitor. Resources are listed by their Amazon Resource Names (ARNs).
        public let resources: [String]
        /// The status of the monitor.
        public let status: MonitorConfigState
        /// The tags that have been added to monitor.
        public let tags: [String: String]?
        /// The percentage of the internet-facing traffic for your application to monitor with this monitor. If you set a city-networks
        /// 			maximum, that limit overrides the traffic percentage that you set. To learn more, see Choosing an application traffic percentage to monitor
        /// 		 in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let trafficPercentageToMonitor: Int?

        public init(createdAt: Date, healthEventsConfig: HealthEventsConfig? = nil, internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery? = nil, maxCityNetworksToMonitor: Int? = nil, modifiedAt: Date, monitorArn: String, monitorName: String, processingStatus: MonitorProcessingStatusCode? = nil, processingStatusInfo: String? = nil, resources: [String], status: MonitorConfigState, tags: [String: String]? = nil, trafficPercentageToMonitor: Int? = nil) {
            self.createdAt = createdAt
            self.healthEventsConfig = healthEventsConfig
            self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
            self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
            self.modifiedAt = modifiedAt
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.processingStatus = processingStatus
            self.processingStatusInfo = processingStatusInfo
            self.resources = resources
            self.status = status
            self.tags = tags
            self.trafficPercentageToMonitor = trafficPercentageToMonitor
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case healthEventsConfig = "HealthEventsConfig"
            case internetMeasurementsLogDelivery = "InternetMeasurementsLogDelivery"
            case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
            case modifiedAt = "ModifiedAt"
            case monitorArn = "MonitorArn"
            case monitorName = "MonitorName"
            case processingStatus = "ProcessingStatus"
            case processingStatusInfo = "ProcessingStatusInfo"
            case resources = "Resources"
            case status = "Status"
            case tags = "Tags"
            case trafficPercentageToMonitor = "TrafficPercentageToMonitor"
        }
    }

    public struct GetQueryResultsInput: AWSEncodableShape {
        /// The number of query results that you want to return with this call.
        public let maxResults: Int?
        /// The name of the monitor to return data for.
        public let monitorName: String
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The ID of the query that you want to return data results for. A QueryId is an
        /// 			internally-generated identifier for a specific query.
        public let queryId: String

        public init(maxResults: Int? = nil, monitorName: String, nextToken: String? = nil, queryId: String) {
            self.maxResults = maxResults
            self.monitorName = monitorName
            self.nextToken = nextToken
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodePath(self.monitorName, key: "MonitorName")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodePath(self.queryId, key: "QueryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryResultsOutput: AWSDecodableShape {
        /// The data results that the query returns. Data is returned in arrays, aligned with the Fields
        /// 		for the query, which creates a repository of Amazon CloudWatch Internet Monitor information for your application. Then, you can filter
        /// 		the information in the repository by using FilterParameters that you define.
        public let data: [[String]]
        /// The fields that the query returns data for. Fields are name-data type pairs, such as
        /// 			availability_score-float.
        public let fields: [QueryField]
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(data: [[String]], fields: [QueryField], nextToken: String? = nil) {
            self.data = data
            self.fields = fields
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case data = "Data"
            case fields = "Fields"
            case nextToken = "NextToken"
        }
    }

    public struct GetQueryStatusInput: AWSEncodableShape {
        /// The name of the monitor.
        public let monitorName: String
        /// The ID of the query that you want to return the status for. A QueryId is an internally-generated
        /// 			dentifier for a specific query.
        public let queryId: String

        public init(monitorName: String, queryId: String) {
            self.monitorName = monitorName
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "MonitorName")
            request.encodePath(self.queryId, key: "QueryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetQueryStatusOutput: AWSDecodableShape {
        /// The current status for a query.
        public let status: QueryStatus

        public init(status: QueryStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct HealthEvent: AWSDecodableShape {
        /// When the health event was created.
        public let createdAt: Date?
        /// The time when a health event ended. If the health event is still active, then the end time is not set.
        public let endedAt: Date?
        /// The Amazon Resource Name (ARN) of the event.
        public let eventArn: String
        /// The internally-generated identifier of a specific network traffic impairment health event.
        public let eventId: String
        /// The value of the threshold percentage for performance or availability that was configured when Amazon CloudWatch Internet Monitor created the health event.
        public let healthScoreThreshold: Double?
        /// The locations impacted by the health event.
        public let impactedLocations: [ImpactedLocation]
        /// The type of impairment for a health event.
        public let impactType: HealthEventImpactType
        /// When the health event was last updated.
        public let lastUpdatedAt: Date
        /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the
        /// 			percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this
        /// 			client location to the Amazon Web Services location using this client network.
        public let percentOfTotalTrafficImpacted: Double?
        /// When a health event started.
        public let startedAt: Date
        /// Health event list member.
        public let status: HealthEventStatus

        public init(createdAt: Date? = nil, endedAt: Date? = nil, eventArn: String, eventId: String, healthScoreThreshold: Double? = nil, impactedLocations: [ImpactedLocation], impactType: HealthEventImpactType, lastUpdatedAt: Date, percentOfTotalTrafficImpacted: Double? = nil, startedAt: Date, status: HealthEventStatus) {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.eventArn = eventArn
            self.eventId = eventId
            self.healthScoreThreshold = healthScoreThreshold
            self.impactedLocations = impactedLocations
            self.impactType = impactType
            self.lastUpdatedAt = lastUpdatedAt
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case endedAt = "EndedAt"
            case eventArn = "EventArn"
            case eventId = "EventId"
            case healthScoreThreshold = "HealthScoreThreshold"
            case impactedLocations = "ImpactedLocations"
            case impactType = "ImpactType"
            case lastUpdatedAt = "LastUpdatedAt"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct HealthEventsConfig: AWSEncodableShape & AWSDecodableShape {
        /// The configuration that determines the threshold and other conditions for when Internet Monitor creates a health event for a local availability issue.
        public let availabilityLocalHealthEventsConfig: LocalHealthEventsConfig?
        /// The health event threshold percentage set for availability scores.
        public let availabilityScoreThreshold: Double?
        /// The configuration that determines the threshold and other conditions for when Internet Monitor creates a health event for a local performance issue.
        public let performanceLocalHealthEventsConfig: LocalHealthEventsConfig?
        /// The health event threshold percentage set for performance scores.
        public let performanceScoreThreshold: Double?

        public init(availabilityLocalHealthEventsConfig: LocalHealthEventsConfig? = nil, availabilityScoreThreshold: Double? = nil, performanceLocalHealthEventsConfig: LocalHealthEventsConfig? = nil, performanceScoreThreshold: Double? = nil) {
            self.availabilityLocalHealthEventsConfig = availabilityLocalHealthEventsConfig
            self.availabilityScoreThreshold = availabilityScoreThreshold
            self.performanceLocalHealthEventsConfig = performanceLocalHealthEventsConfig
            self.performanceScoreThreshold = performanceScoreThreshold
        }

        public func validate(name: String) throws {
            try self.availabilityLocalHealthEventsConfig?.validate(name: "\(name).availabilityLocalHealthEventsConfig")
            try self.validate(self.availabilityScoreThreshold, name: "availabilityScoreThreshold", parent: name, max: 100.0)
            try self.validate(self.availabilityScoreThreshold, name: "availabilityScoreThreshold", parent: name, min: 0.0)
            try self.performanceLocalHealthEventsConfig?.validate(name: "\(name).performanceLocalHealthEventsConfig")
            try self.validate(self.performanceScoreThreshold, name: "performanceScoreThreshold", parent: name, max: 100.0)
            try self.validate(self.performanceScoreThreshold, name: "performanceScoreThreshold", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityLocalHealthEventsConfig = "AvailabilityLocalHealthEventsConfig"
            case availabilityScoreThreshold = "AvailabilityScoreThreshold"
            case performanceLocalHealthEventsConfig = "PerformanceLocalHealthEventsConfig"
            case performanceScoreThreshold = "PerformanceScoreThreshold"
        }
    }

    public struct ImpactedLocation: AWSDecodableShape {
        /// The name of the network at an impacted location.
        public let asName: String
        /// The Autonomous System Number (ASN) of the network at an impacted location.
        public let asNumber: Int64
        /// The cause of the impairment. There are two types of network impairments: Amazon Web Services network issues 	or internet issues. Internet issues are typically a problem with a network provider, like an internet service provider (ISP).
        public let causedBy: NetworkImpairment?
        /// The name of the city where the health event is located.
        public let city: String?
        /// The name of the country where the health event is located.
        public let country: String
        /// The country code where the health event is located. The ISO 3166-2 codes for the 		country is provided, when available.
        public let countryCode: String?
        /// The calculated health at a specific location.
        public let internetHealth: InternetHealth?
        /// The IPv4 prefixes at the client location that was impacted by the health event.
        public let ipv4Prefixes: [String]?
        /// The latitude where the health event is located.
        public let latitude: Double?
        /// The longitude where the health event is located.
        public let longitude: Double?
        /// The metro area where the health event is located. Metro indicates a metropolitan region in the United States, such as the region around New York City. 		In non-US countries, this is a second-level subdivision. For example, in the United Kingdom, it could be 		a county, a London borough, a unitary authority, council area, and so on.
        public let metro: String?
        /// The service location where the health event is located.
        public let serviceLocation: String?
        /// The status of the health event at an impacted location.
        public let status: HealthEventStatus
        /// The subdivision location where the health event is located. The subdivision usually maps to
        /// 				states in most countries (including the United States). For United Kingdom, it maps to a country (England,
        /// 				Scotland, Wales) or province (Northern Ireland).
        public let subdivision: String?
        /// The subdivision code where the health event is located. The ISO 3166-2 codes for
        /// 			country subdivisions is provided, when available.
        public let subdivisionCode: String?

        public init(asName: String, asNumber: Int64, causedBy: NetworkImpairment? = nil, city: String? = nil, country: String, countryCode: String? = nil, internetHealth: InternetHealth? = nil, ipv4Prefixes: [String]? = nil, latitude: Double? = nil, longitude: Double? = nil, metro: String? = nil, serviceLocation: String? = nil, status: HealthEventStatus, subdivision: String? = nil, subdivisionCode: String? = nil) {
            self.asName = asName
            self.asNumber = asNumber
            self.causedBy = causedBy
            self.city = city
            self.country = country
            self.countryCode = countryCode
            self.internetHealth = internetHealth
            self.ipv4Prefixes = ipv4Prefixes
            self.latitude = latitude
            self.longitude = longitude
            self.metro = metro
            self.serviceLocation = serviceLocation
            self.status = status
            self.subdivision = subdivision
            self.subdivisionCode = subdivisionCode
        }

        private enum CodingKeys: String, CodingKey {
            case asName = "ASName"
            case asNumber = "ASNumber"
            case causedBy = "CausedBy"
            case city = "City"
            case country = "Country"
            case countryCode = "CountryCode"
            case internetHealth = "InternetHealth"
            case ipv4Prefixes = "Ipv4Prefixes"
            case latitude = "Latitude"
            case longitude = "Longitude"
            case metro = "Metro"
            case serviceLocation = "ServiceLocation"
            case status = "Status"
            case subdivision = "Subdivision"
            case subdivisionCode = "SubdivisionCode"
        }
    }

    public struct InternetHealth: AWSDecodableShape {
        /// Availability in Internet Monitor represents the estimated percentage of traffic that is not seeing an availability drop. For example, an availability score of 99%
        /// 			for an end user and service location pair is equivalent to 1% of the traffic experiencing an availability drop for that pair. For more information, see How Internet Monitor calculates performance and availability
        /// 			scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let availability: AvailabilityMeasurement?
        /// Performance in Internet Monitor represents the estimated percentage of traffic that is not seeing a performance drop. For example, a performance score of 99% for
        /// 			an end user and service location pair is equivalent to 1% of the traffic experiencing a performance drop for that pair. For more information, see How Internet Monitor calculates performance and availability
        /// 			scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let performance: PerformanceMeasurement?

        public init(availability: AvailabilityMeasurement? = nil, performance: PerformanceMeasurement? = nil) {
            self.availability = availability
            self.performance = performance
        }

        private enum CodingKeys: String, CodingKey {
            case availability = "Availability"
            case performance = "Performance"
        }
    }

    public struct InternetMeasurementsLogDelivery: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information for publishing Internet Monitor internet measurements to Amazon S3. The configuration includes the bucket name and (optionally) prefix
        /// 			for the S3 bucket to store the measurements, and the delivery status. The delivery status is ENABLED or DISABLED, depending on
        /// 			whether you choose to deliver internet measurements to S3 logs.
        public let s3Config: S3Config?

        public init(s3Config: S3Config? = nil) {
            self.s3Config = s3Config
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct ListHealthEventsInput: AWSEncodableShape {
        /// The time when a health event ended. If the health event is still ongoing, then the end time is not set.
        public let endTime: Date?
        /// The status of a health event.
        public let eventStatus: HealthEventStatus?
        /// TBD
        public let linkedAccountId: String?
        /// The number of health event objects that you want to return with this call.
        public let maxResults: Int?
        /// The name of the monitor.
        public let monitorName: String
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The time when a health event started.
        public let startTime: Date?

        public init(endTime: Date? = nil, eventStatus: HealthEventStatus? = nil, linkedAccountId: String? = nil, maxResults: Int? = nil, monitorName: String, nextToken: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.linkedAccountId = linkedAccountId
            self.maxResults = maxResults
            self.monitorName = monitorName
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "EndTime")
            request.encodeQuery(self.eventStatus, key: "EventStatus")
            request.encodeQuery(self.linkedAccountId, key: "LinkedAccountId")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodePath(self.monitorName, key: "MonitorName")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.startTime, key: "StartTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, max: 12)
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, min: 12)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHealthEventsOutput: AWSDecodableShape {
        /// A list of health events.
        public let healthEvents: [HealthEvent]
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(healthEvents: [HealthEvent], nextToken: String? = nil) {
            self.healthEvents = healthEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case healthEvents = "HealthEvents"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitorsInput: AWSEncodableShape {
        /// TBD
        public let includeLinkedAccounts: Bool?
        /// The number of monitor objects that you want to return with this call.
        public let maxResults: Int?
        /// The status of a monitor. This includes the status of the data processing for the monitor and the status of the monitor itself. For information about the statuses for a monitor, see
        /// 				Monitor.
        public let monitorStatus: String?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(includeLinkedAccounts: Bool? = nil, maxResults: Int? = nil, monitorStatus: String? = nil, nextToken: String? = nil) {
            self.includeLinkedAccounts = includeLinkedAccounts
            self.maxResults = maxResults
            self.monitorStatus = monitorStatus
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.includeLinkedAccounts, key: "IncludeLinkedAccounts")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.monitorStatus, key: "MonitorStatus")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMonitorsOutput: AWSDecodableShape {
        /// A list of monitors.
        public let monitors: [Monitor]
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(monitors: [Monitor], nextToken: String? = nil) {
            self.monitors = monitors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitors = "Monitors"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// Tags for a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LocalHealthEventsConfig: AWSEncodableShape & AWSDecodableShape {
        /// The health event threshold percentage set for a local health score.
        public let healthScoreThreshold: Double?
        /// The minimum percentage of overall traffic for an application that must be impacted by an issue before Internet Monitor creates an event when a
        /// 			threshold is crossed for a local health score. If you don't set a minimum traffic impact threshold, the default value is 0.1%.
        public let minTrafficImpact: Double?
        /// The status of whether Internet Monitor creates a health event based on a threshold percentage set for a local health score. The status can be ENABLED
        /// 		or DISABLED.
        public let status: LocalHealthEventsConfigStatus?

        public init(healthScoreThreshold: Double? = nil, minTrafficImpact: Double? = nil, status: LocalHealthEventsConfigStatus? = nil) {
            self.healthScoreThreshold = healthScoreThreshold
            self.minTrafficImpact = minTrafficImpact
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.healthScoreThreshold, name: "healthScoreThreshold", parent: name, max: 100.0)
            try self.validate(self.healthScoreThreshold, name: "healthScoreThreshold", parent: name, min: 0.0)
            try self.validate(self.minTrafficImpact, name: "minTrafficImpact", parent: name, max: 100.0)
            try self.validate(self.minTrafficImpact, name: "minTrafficImpact", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case healthScoreThreshold = "HealthScoreThreshold"
            case minTrafficImpact = "MinTrafficImpact"
            case status = "Status"
        }
    }

    public struct Monitor: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The health of data processing for the monitor.
        public let processingStatus: MonitorProcessingStatusCode?
        /// The status of a monitor.
        public let status: MonitorConfigState

        public init(monitorArn: String, monitorName: String, processingStatus: MonitorProcessingStatusCode? = nil, status: MonitorConfigState) {
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.processingStatus = processingStatus
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
            case monitorName = "MonitorName"
            case processingStatus = "ProcessingStatus"
            case status = "Status"
        }
    }

    public struct Network: AWSDecodableShape {
        /// The internet provider name or network name.
        public let asName: String
        /// The Autonomous System Number (ASN) of the internet provider or network.
        public let asNumber: Int64

        public init(asName: String, asNumber: Int64) {
            self.asName = asName
            self.asNumber = asNumber
        }

        private enum CodingKeys: String, CodingKey {
            case asName = "ASName"
            case asNumber = "ASNumber"
        }
    }

    public struct NetworkImpairment: AWSDecodableShape {
        /// The combination of the Autonomous System Number (ASN) of the network and the name of the network.
        public let asPath: [Network]
        /// Type of network impairment.
        public let networkEventType: TriangulationEventType
        /// The networks that could be impacted by a network impairment event.
        public let networks: [Network]

        public init(asPath: [Network], networkEventType: TriangulationEventType, networks: [Network]) {
            self.asPath = asPath
            self.networkEventType = networkEventType
            self.networks = networks
        }

        private enum CodingKeys: String, CodingKey {
            case asPath = "AsPath"
            case networkEventType = "NetworkEventType"
            case networks = "Networks"
        }
    }

    public struct PerformanceMeasurement: AWSDecodableShape {
        /// Experience scores, or health scores, are calculated for different geographic and network provider combinations (that is, different granularities) and
        /// 			also totaled into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor
        /// 			provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and
        /// 			availability scores, and when it creates and resolves health events. For more information, see How Amazon Web Services calculates performance and
        /// 				availability scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let experienceScore: Double?
        /// How much performance impact was caused by a health event at a client location. For performance, this is the percentage of how much latency increased
        /// 			during the event compared to typical performance for traffic, from this client location to an Amazon Web Services location, using a specific client network.  For more information, see When Amazon Web Services creates and resolves health
        /// 			events in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let percentOfClientLocationImpacted: Double?
        /// The impact on total traffic that a health event has, in increased latency or reduced availability. This is the
        /// 			percentage of how much latency has increased or availability has decreased during the event, compared to what is typical for traffic from this
        /// 			client location to the Amazon Web Services location using this client network. For more information, see When Amazon Web Services creates and resolves health
        /// 			events in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let percentOfTotalTrafficImpacted: Double?
        /// This is the percentage of how much round-trip time increased during the event compared to typical round-trip time for your application for traffic.  For more information, see When Amazon Web Services creates and resolves health
        /// 			events in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let roundTripTime: RoundTripTime?

        public init(experienceScore: Double? = nil, percentOfClientLocationImpacted: Double? = nil, percentOfTotalTrafficImpacted: Double? = nil, roundTripTime: RoundTripTime? = nil) {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.roundTripTime = roundTripTime
        }

        private enum CodingKeys: String, CodingKey {
            case experienceScore = "ExperienceScore"
            case percentOfClientLocationImpacted = "PercentOfClientLocationImpacted"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
            case roundTripTime = "RoundTripTime"
        }
    }

    public struct QueryField: AWSDecodableShape {
        /// The name of a field to query your application's Amazon CloudWatch Internet Monitor data for, such as availability_score.
        public let name: String?
        /// The data type for a query field, which must correspond to the field you're defining for QueryField. For example, if the query
        /// 			field name is availability_score, the data type is float.
        public let type: String?

        public init(name: String? = nil, type: String? = nil) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case type = "Type"
        }
    }

    public struct RoundTripTime: AWSDecodableShape {
        /// RTT at the 50th percentile (p50).
        public let p50: Double?
        /// RTT at the 90th percentile (p90).
        public let p90: Double?
        /// RTT at the 95th percentile (p95).
        public let p95: Double?

        public init(p50: Double? = nil, p90: Double? = nil, p95: Double? = nil) {
            self.p50 = p50
            self.p90 = p90
            self.p95 = p95
        }

        private enum CodingKeys: String, CodingKey {
            case p50 = "P50"
            case p90 = "P90"
            case p95 = "P95"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket name.
        public let bucketName: String?
        /// The Amazon S3 bucket prefix.
        public let bucketPrefix: String?
        /// The status of publishing Internet Monitor internet measurements to an Amazon S3 bucket.
        public let logDeliveryStatus: LogDeliveryStatus?

        public init(bucketName: String? = nil, bucketPrefix: String? = nil, logDeliveryStatus: LogDeliveryStatus? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.logDeliveryStatus = logDeliveryStatus
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case bucketPrefix = "BucketPrefix"
            case logDeliveryStatus = "LogDeliveryStatus"
        }
    }

    public struct StartQueryInput: AWSEncodableShape {
        /// The timestamp that is the end of the period that you want to retrieve data for with your query.
        public let endTime: Date
        /// The FilterParameters field that you use with Amazon CloudWatch Internet Monitor queries is a string the defines
        /// 			how you want a query to be filtered. The filter parameters that you can specify depend on the query type, since
        /// 			each query type returns a different set of Internet Monitor data. For more information about specifying filter parameters, see
        /// 			Using the Amazon CloudWatch Internet Monitor query interface
        /// 			in the Amazon CloudWatch Internet Monitor User Guide.
        public let filterParameters: [FilterParameter]?
        /// TBD
        public let linkedAccountId: String?
        /// The name of the monitor to query.
        public let monitorName: String
        /// The type of query to run. The following are the three types of queries that you can run using the Internet Monitor query interface:    MEASUREMENTS: Provides availability score, performance score, total traffic,
        /// 				and round-trip times, at 5 minute intervals.    TOP_LOCATIONS: Provides availability score, performance score, total traffic,
        /// 				and time to first byte (TTFB) information, for the top location and ASN combinations that you're monitoring, by traffic volume.    TOP_LOCATION_DETAILS: Provides TTFB for Amazon CloudFront, your
        /// 				current configuration, and the best performing EC2 configuration, at 1 hour intervals.   For lists of the fields returned with each query type and more information about how each type of query is
        /// 			performed, see
        /// 				Using the Amazon CloudWatch Internet Monitor query interface in the Amazon CloudWatch Internet Monitor User Guide.
        public let queryType: QueryType
        /// The timestamp that is the beginning of the period that you want to retrieve data for with your query.
        public let startTime: Date

        public init(endTime: Date, filterParameters: [FilterParameter]? = nil, linkedAccountId: String? = nil, monitorName: String, queryType: QueryType, startTime: Date) {
            self.endTime = endTime
            self.filterParameters = filterParameters
            self.linkedAccountId = linkedAccountId
            self.monitorName = monitorName
            self.queryType = queryType
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.endTime, forKey: .endTime)
            try container.encodeIfPresent(self.filterParameters, forKey: .filterParameters)
            try container.encodeIfPresent(self.linkedAccountId, forKey: .linkedAccountId)
            request.encodePath(self.monitorName, key: "MonitorName")
            try container.encode(self.queryType, forKey: .queryType)
            try container.encode(self.startTime, forKey: .startTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, max: 12)
            try self.validate(self.linkedAccountId, name: "linkedAccountId", parent: name, min: 12)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filterParameters = "FilterParameters"
            case linkedAccountId = "LinkedAccountId"
            case queryType = "QueryType"
            case startTime = "StartTime"
        }
    }

    public struct StartQueryOutput: AWSDecodableShape {
        /// The internally-generated identifier of a specific query.
        public let queryId: String

        public init(queryId: String) {
            self.queryId = queryId
        }

        private enum CodingKeys: String, CodingKey {
            case queryId = "QueryId"
        }
    }

    public struct StopQueryInput: AWSEncodableShape {
        /// The name of the monitor.
        public let monitorName: String
        /// The ID of the query that you want to stop. A QueryId is an internally-generated identifier for a specific query.
        public let queryId: String

        public init(monitorName: String, queryId: String) {
            self.monitorName = monitorName
            self.queryId = queryId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "MonitorName")
            request.encodePath(self.queryId, key: "QueryId")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopQueryOutput: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a tag that you add to a resource. Tags are supported only for monitors in Amazon CloudWatch Internet Monitor.
        public let resourceArn: String
        /// Tags that you add to a resource. You can add a maximum of 50 tags in Internet Monitor.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a tag you remove a resource from.
        public let resourceArn: String
        /// Tag keys that you remove from a resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMonitorInput: AWSEncodableShape {
        /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. You should not reuse the same client
        /// 			token for other API requests.
        public let clientToken: String?
        /// The list of health score thresholds. A threshold percentage for health scores, along with other configuration information,
        /// 			determines when Internet Monitor creates a health event when there's an internet issue that affects your application end users. For more information, see
        /// 			Change health event thresholds in the Internet Monitor section of the CloudWatch User Guide.
        public let healthEventsConfig: HealthEventsConfig?
        /// Publish internet measurements for Internet Monitor to another location, such as an Amazon S3 bucket. The measurements are also published to Amazon CloudWatch Logs.
        public let internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery?
        /// The maximum number of city-networks to monitor for your application. A city-network is the location (city) where clients access your
        /// 			application resources from and the ASN or network provider, such as an internet service provider (ISP), that clients access the resources
        /// 			through. Setting this limit can help control billing costs.
        public let maxCityNetworksToMonitor: Int?
        /// The name of the monitor.
        public let monitorName: String
        /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). Resources can be VPCs, NLBs,
        /// 			Amazon CloudFront distributions, or Amazon WorkSpaces directories. You can add a combination of VPCs and CloudFront distributions, or you can add WorkSpaces directories, or you can add NLBs. You can't add
        /// 			NLBs or WorkSpaces directories together with any other resources.  If you add only Amazon Virtual Private Clouds resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has internet
        /// 			connectivity.
        public let resourcesToAdd: [String]?
        /// The resources to remove from a monitor, which you provide as a set of Amazon Resource Names (ARNs).
        public let resourcesToRemove: [String]?
        /// The status for a monitor. The accepted values for Status with the UpdateMonitor API call are the following: ACTIVE and
        /// 			INACTIVE. The following values are not accepted: PENDING, and ERROR.
        public let status: MonitorConfigState?
        /// The percentage of the internet-facing traffic for your application that you want to monitor with this monitor. If you set a city-networks
        /// 			maximum, that limit overrides the traffic percentage that you set. To learn more, see Choosing an application traffic percentage to monitor
        /// 		 in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let trafficPercentageToMonitor: Int?

        public init(clientToken: String? = UpdateMonitorInput.idempotencyToken(), healthEventsConfig: HealthEventsConfig? = nil, internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery? = nil, maxCityNetworksToMonitor: Int? = nil, monitorName: String, resourcesToAdd: [String]? = nil, resourcesToRemove: [String]? = nil, status: MonitorConfigState? = nil, trafficPercentageToMonitor: Int? = nil) {
            self.clientToken = clientToken
            self.healthEventsConfig = healthEventsConfig
            self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
            self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
            self.monitorName = monitorName
            self.resourcesToAdd = resourcesToAdd
            self.resourcesToRemove = resourcesToRemove
            self.status = status
            self.trafficPercentageToMonitor = trafficPercentageToMonitor
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.healthEventsConfig, forKey: .healthEventsConfig)
            try container.encodeIfPresent(self.internetMeasurementsLogDelivery, forKey: .internetMeasurementsLogDelivery)
            try container.encodeIfPresent(self.maxCityNetworksToMonitor, forKey: .maxCityNetworksToMonitor)
            request.encodePath(self.monitorName, key: "MonitorName")
            try container.encodeIfPresent(self.resourcesToAdd, forKey: .resourcesToAdd)
            try container.encodeIfPresent(self.resourcesToRemove, forKey: .resourcesToRemove)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.trafficPercentageToMonitor, forKey: .trafficPercentageToMonitor)
        }

        public func validate(name: String) throws {
            try self.healthEventsConfig?.validate(name: "\(name).healthEventsConfig")
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, max: 500000)
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.resourcesToAdd?.forEach {
                try validate($0, name: "resourcesToAdd[]", parent: name, max: 2048)
                try validate($0, name: "resourcesToAdd[]", parent: name, min: 20)
                try validate($0, name: "resourcesToAdd[]", parent: name, pattern: "^arn:.*")
            }
            try self.resourcesToRemove?.forEach {
                try validate($0, name: "resourcesToRemove[]", parent: name, max: 2048)
                try validate($0, name: "resourcesToRemove[]", parent: name, min: 20)
                try validate($0, name: "resourcesToRemove[]", parent: name, pattern: "^arn:.*")
            }
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, max: 100)
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case healthEventsConfig = "HealthEventsConfig"
            case internetMeasurementsLogDelivery = "InternetMeasurementsLogDelivery"
            case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
            case resourcesToAdd = "ResourcesToAdd"
            case resourcesToRemove = "ResourcesToRemove"
            case status = "Status"
            case trafficPercentageToMonitor = "TrafficPercentageToMonitor"
        }
    }

    public struct UpdateMonitorOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The status of a monitor.
        public let status: MonitorConfigState

        public init(monitorArn: String, status: MonitorConfigState) {
            self.monitorArn = monitorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
            case status = "Status"
        }
    }
}

// MARK: - Errors

/// Error enum for InternetMonitor
public struct InternetMonitorErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalServerErrorException = "InternalServerErrorException"
        case internalServerException = "InternalServerException"
        case limitExceededException = "LimitExceededException"
        case notFoundException = "NotFoundException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case tooManyRequestsException = "TooManyRequestsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize InternetMonitor
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient permission to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A bad request was received.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The requested resource is in use.
    public static var conflictException: Self { .init(.conflictException) }
    /// There was an internal server error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// An internal error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request exceeded a service quota.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The request specifies something that doesn't exist.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The request specifies a resource that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// There were too many requests.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// Invalid request.
    public static var validationException: Self { .init(.validationException) }
}

extension InternetMonitorErrorType: Equatable {
    public static func == (lhs: InternetMonitorErrorType, rhs: InternetMonitorErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension InternetMonitorErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
