//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if compiler(>=5.7) && os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
import SotoCore

extension InternetMonitor {
    // MARK: Enums

    public enum HealthEventImpactType: String, CustomStringConvertible, Codable, Sendable {
        case availability = "AVAILABILITY"
        case performance = "PERFORMANCE"
        public var description: String { return self.rawValue }
    }

    public enum HealthEventStatus: String, CustomStringConvertible, Codable, Sendable {
        case active = "ACTIVE"
        case resolved = "RESOLVED"
        public var description: String { return self.rawValue }
    }

    public enum LogDeliveryStatus: String, CustomStringConvertible, Codable, Sendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MonitorConfigState: String, CustomStringConvertible, Codable, Sendable {
        case active = "ACTIVE"
        case error = "ERROR"
        case inactive = "INACTIVE"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum MonitorProcessingStatusCode: String, CustomStringConvertible, Codable, Sendable {
        case collectingData = "COLLECTING_DATA"
        case faultAccessCloudwatch = "FAULT_ACCESS_CLOUDWATCH"
        case faultService = "FAULT_SERVICE"
        case inactive = "INACTIVE"
        case insufficientData = "INSUFFICIENT_DATA"
        case ok = "OK"
        public var description: String { return self.rawValue }
    }

    public enum TriangulationEventType: String, CustomStringConvertible, Codable, Sendable {
        case aws = "AWS"
        case internet = "Internet"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AvailabilityMeasurement: AWSDecodableShape {
        /// Experience scores, or health scores are calculated for different geographic and network provider combinations (that is, different granularities) and
        /// 			also summed into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor
        /// 			provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and
        /// 			availability scores, and when it creates and resolves health events. For more information, see How Amazon Web Services calculates performance and
        /// 				availability scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let experienceScore: Double?
        /// The percentage of impact caused by a health event for client location traffic globally. For information about how Internet Monitor calculates impact, see Inside Internet Monitor in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User
        /// 			Guide.
        public let percentOfClientLocationImpacted: Double?
        /// The percentage of impact caused by a health event for total traffic globally. For information about how Internet Monitor calculates impact, see Inside Internet Monitor in the Amazon CloudWatch Internet Monitor section of the Amazon CloudWatch User
        /// 			Guide.
        public let percentOfTotalTrafficImpacted: Double?

        public init(experienceScore: Double? = nil, percentOfClientLocationImpacted: Double? = nil, percentOfTotalTrafficImpacted: Double? = nil) {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
        }

        private enum CodingKeys: String, CodingKey {
            case experienceScore = "ExperienceScore"
            case percentOfClientLocationImpacted = "PercentOfClientLocationImpacted"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
        }
    }

    public struct CreateMonitorInput: AWSEncodableShape {
        /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. Don't reuse the same client token for
        /// 			other API requests.
        public let clientToken: String?
        /// Publish internet measurements for Internet Monitor to an Amazon S3 bucket in addition to CloudWatch Logs.
        public let internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery?
        /// The maximum number of city-networks to monitor for your resources. A city-network is the location (city) where clients access your application resources from and
        /// 			the network or ASN, such as an internet service provider (ISP), that clients access the resources through. This limit helps control billing costs. To learn more, see Choosing a city-network maximum value
        /// 		 in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let maxCityNetworksToMonitor: Int?
        /// The name of the monitor.
        public let monitorName: String
        /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). You can add a combination of Amazon Virtual Private Clouds (VPCs) and Amazon CloudFront distributions, or you can add Amazon WorkSpaces directories. You can't add all three types of
        /// 			resources.  If you add only VPC resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has internet connectivity.
        public let resources: [String]?
        /// The tags for a monitor. You can add a maximum of 50 tags in Internet Monitor.
        public let tags: [String: String]?
        /// The percentage of the internet-facing traffic for your application that you want to monitor with this monitor.
        public let trafficPercentageToMonitor: Int?

        public init(clientToken: String? = CreateMonitorInput.idempotencyToken(), internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery? = nil, maxCityNetworksToMonitor: Int? = nil, monitorName: String, resources: [String]? = nil, tags: [String: String]? = nil, trafficPercentageToMonitor: Int? = nil) {
            self.clientToken = clientToken
            self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
            self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
            self.monitorName = monitorName
            self.resources = resources
            self.tags = tags
            self.trafficPercentageToMonitor = trafficPercentageToMonitor
        }

        public func validate(name: String) throws {
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, max: 500000)
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.resources?.forEach {
                try validate($0, name: "resources[]", parent: name, max: 2048)
                try validate($0, name: "resources[]", parent: name, min: 20)
                try validate($0, name: "resources[]", parent: name, pattern: "^arn:.*")
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, max: 100)
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case internetMeasurementsLogDelivery = "InternetMeasurementsLogDelivery"
            case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
            case monitorName = "MonitorName"
            case resources = "Resources"
            case tags = "Tags"
            case trafficPercentageToMonitor = "TrafficPercentageToMonitor"
        }
    }

    public struct CreateMonitorOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor.
        public let arn: String
        /// The status of a monitor.
        public let status: MonitorConfigState

        public init(arn: String, status: MonitorConfigState) {
            self.arn = arn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case status = "Status"
        }
    }

    public struct DeleteMonitorInput: AWSEncodableShape {
        /// The name of the monitor to delete.
        public let monitorName: String

        public init(monitorName: String) {
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "MonitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMonitorOutput: AWSDecodableShape {
        public init() {}
    }

    public struct GetHealthEventInput: AWSEncodableShape {
        /// The internally generated identifier of a health event. Because EventID contains the forward slash (“/”) character, you must
        /// 			URL-encode the EventID field in the request URL.
        public let eventId: String
        /// The name of the monitor.
        public let monitorName: String

        public init(eventId: String, monitorName: String) {
            self.eventId = eventId
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.eventId, key: "EventId")
            request.encodePath(self.monitorName, key: "MonitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.eventId, name: "eventId", parent: name, max: 255)
            try self.validate(self.eventId, name: "eventId", parent: name, min: 1)
            try self.validate(self.eventId, name: "eventId", parent: name, pattern: "^[a-zA-Z0-9/_.-]+$")
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetHealthEventOutput: AWSDecodableShape {
        /// The time when a health event was created.
        public let createdAt: Date?
        /// The time when a health event was resolved. If the health event is still active, the end time is not set.
        public let endedAt: Date?
        /// The Amazon Resource Name (ARN) of the event.
        public let eventArn: String
        /// The internally generated identifier of a health event.
        public let eventId: String
        /// The locations affected by a health event.
        public let impactedLocations: [ImpactedLocation]
        /// The type of impairment of a specific health event.
        public let impactType: HealthEventImpactType
        /// The time when a health event was last updated or recalculated.
        public let lastUpdatedAt: Date
        /// The impact on total traffic that a health event has.
        public let percentOfTotalTrafficImpacted: Double?
        /// The time when a health event started.
        public let startedAt: Date
        /// The status of a health event.
        public let status: HealthEventStatus

        public init(createdAt: Date? = nil, endedAt: Date? = nil, eventArn: String, eventId: String, impactedLocations: [ImpactedLocation], impactType: HealthEventImpactType, lastUpdatedAt: Date, percentOfTotalTrafficImpacted: Double? = nil, startedAt: Date, status: HealthEventStatus) {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.eventArn = eventArn
            self.eventId = eventId
            self.impactedLocations = impactedLocations
            self.impactType = impactType
            self.lastUpdatedAt = lastUpdatedAt
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case endedAt = "EndedAt"
            case eventArn = "EventArn"
            case eventId = "EventId"
            case impactedLocations = "ImpactedLocations"
            case impactType = "ImpactType"
            case lastUpdatedAt = "LastUpdatedAt"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct GetMonitorInput: AWSEncodableShape {
        /// The name of the monitor.
        public let monitorName: String

        public init(monitorName: String) {
            self.monitorName = monitorName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.monitorName, key: "MonitorName")
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMonitorOutput: AWSDecodableShape {
        /// The time when the monitor was created.
        public let createdAt: Date
        /// Publish internet measurements for Internet Monitor to another location, such as an Amazon S3 bucket. The measurements are also published to Amazon CloudWatch Logs.
        public let internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery?
        /// The maximum number of city-networks to monitor for your resources. A city-network is the location (city) where clients access your application resources from and
        /// 			the network or ASN, such as an internet service provider (ISP), that clients access the resources through. This limit helps control billing costs. To learn more, see Choosing a city-network maximum value
        /// 		 in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let maxCityNetworksToMonitor: Int?
        /// The last time that the monitor was modified.
        public let modifiedAt: Date
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The health of the data processing for the monitor.
        public let processingStatus: MonitorProcessingStatusCode?
        /// Additional information about the health of the data processing for the monitor.
        public let processingStatusInfo: String?
        /// The resources that have been added for the monitor. Resources are listed by their Amazon Resource Names (ARNs).
        public let resources: [String]
        /// The status of the monitor.
        public let status: MonitorConfigState
        /// The tags that have been added to monitor.
        public let tags: [String: String]?
        /// The percentage of the internet-facing traffic for your application that you want to monitor with this monitor.
        public let trafficPercentageToMonitor: Int?

        public init(createdAt: Date, internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery? = nil, maxCityNetworksToMonitor: Int? = nil, modifiedAt: Date, monitorArn: String, monitorName: String, processingStatus: MonitorProcessingStatusCode? = nil, processingStatusInfo: String? = nil, resources: [String], status: MonitorConfigState, tags: [String: String]? = nil, trafficPercentageToMonitor: Int? = nil) {
            self.createdAt = createdAt
            self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
            self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
            self.modifiedAt = modifiedAt
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.processingStatus = processingStatus
            self.processingStatusInfo = processingStatusInfo
            self.resources = resources
            self.status = status
            self.tags = tags
            self.trafficPercentageToMonitor = trafficPercentageToMonitor
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case internetMeasurementsLogDelivery = "InternetMeasurementsLogDelivery"
            case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
            case modifiedAt = "ModifiedAt"
            case monitorArn = "MonitorArn"
            case monitorName = "MonitorName"
            case processingStatus = "ProcessingStatus"
            case processingStatusInfo = "ProcessingStatusInfo"
            case resources = "Resources"
            case status = "Status"
            case tags = "Tags"
            case trafficPercentageToMonitor = "TrafficPercentageToMonitor"
        }
    }

    public struct HealthEvent: AWSDecodableShape {
        /// When the health event was created.
        public let createdAt: Date?
        /// The time when a health event ended. If the health event is still active, then the end time is not set.
        public let endedAt: Date?
        /// The Amazon Resource Name (ARN) of the event.
        public let eventArn: String
        /// The internally generated identifier of a specific network traffic impairment health event.
        public let eventId: String
        /// The locations impacted by the health event.
        public let impactedLocations: [ImpactedLocation]
        /// The type of impairment for a health event.
        public let impactType: HealthEventImpactType
        /// When the health event was last updated.
        public let lastUpdatedAt: Date
        /// The impact on global traffic monitored by this monitor for this health event.
        public let percentOfTotalTrafficImpacted: Double?
        /// When a health event started.
        public let startedAt: Date
        /// Health event list member.
        public let status: HealthEventStatus

        public init(createdAt: Date? = nil, endedAt: Date? = nil, eventArn: String, eventId: String, impactedLocations: [ImpactedLocation], impactType: HealthEventImpactType, lastUpdatedAt: Date, percentOfTotalTrafficImpacted: Double? = nil, startedAt: Date, status: HealthEventStatus) {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.eventArn = eventArn
            self.eventId = eventId
            self.impactedLocations = impactedLocations
            self.impactType = impactType
            self.lastUpdatedAt = lastUpdatedAt
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.startedAt = startedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case endedAt = "EndedAt"
            case eventArn = "EventArn"
            case eventId = "EventId"
            case impactedLocations = "ImpactedLocations"
            case impactType = "ImpactType"
            case lastUpdatedAt = "LastUpdatedAt"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
            case startedAt = "StartedAt"
            case status = "Status"
        }
    }

    public struct ImpactedLocation: AWSDecodableShape {
        /// The name of the network at an impacted location.
        public let asName: String
        /// The Autonomous System Number (ASN) of the network at an impacted location.
        public let asNumber: Int64
        /// The cause of the impairment. There are two types of network impairments: Amazon Web Services network issues 	or internet issues. Internet issues are typically a problem with a network provider, like an internet service provider (ISP).
        public let causedBy: NetworkImpairment?
        /// The name of the city where the health event is located.
        public let city: String?
        /// The name of the country where the health event is located.
        public let country: String
        /// The country code where the health event is located. The ISO 3166-2 codes for the 		country is provided, when available.
        public let countryCode: String?
        /// The calculated health at a specific location.
        public let internetHealth: InternetHealth?
        /// The latitude where the health event is located.
        public let latitude: Double?
        /// The longitude where the health event is located.
        public let longitude: Double?
        /// The metro area where the health event is located. Metro indicates a metropolitan region in the United States, such as the region around New York City. 		In non-US countries, this is a second-level subdivision. For example, in the United Kingdom, it could be 		a county, a London borough, a unitary authority, council area, and so on.
        public let metro: String?
        /// The service location where the health event is located.
        public let serviceLocation: String?
        /// The status of the health event at an impacted location.
        public let status: HealthEventStatus
        /// The subdivision location where the health event is located. The subdivision usually maps to
        /// 				states in most countries (including the United States). For United Kingdom, it maps to a country (England,
        /// 				Scotland, Wales) or province (Northern Ireland).
        public let subdivision: String?
        /// The subdivision code where the health event is located. The ISO 3166-2 codes for
        /// 			country subdivisions is provided, when available.
        public let subdivisionCode: String?

        public init(asName: String, asNumber: Int64, causedBy: NetworkImpairment? = nil, city: String? = nil, country: String, countryCode: String? = nil, internetHealth: InternetHealth? = nil, latitude: Double? = nil, longitude: Double? = nil, metro: String? = nil, serviceLocation: String? = nil, status: HealthEventStatus, subdivision: String? = nil, subdivisionCode: String? = nil) {
            self.asName = asName
            self.asNumber = asNumber
            self.causedBy = causedBy
            self.city = city
            self.country = country
            self.countryCode = countryCode
            self.internetHealth = internetHealth
            self.latitude = latitude
            self.longitude = longitude
            self.metro = metro
            self.serviceLocation = serviceLocation
            self.status = status
            self.subdivision = subdivision
            self.subdivisionCode = subdivisionCode
        }

        private enum CodingKeys: String, CodingKey {
            case asName = "ASName"
            case asNumber = "ASNumber"
            case causedBy = "CausedBy"
            case city = "City"
            case country = "Country"
            case countryCode = "CountryCode"
            case internetHealth = "InternetHealth"
            case latitude = "Latitude"
            case longitude = "Longitude"
            case metro = "Metro"
            case serviceLocation = "ServiceLocation"
            case status = "Status"
            case subdivision = "Subdivision"
            case subdivisionCode = "SubdivisionCode"
        }
    }

    public struct InternetHealth: AWSDecodableShape {
        /// Availability in Internet Monitor represents the estimated percentage of traffic that is not seeing an availability drop. For example, an availability score of 99%
        /// 			for an end user and service location pair is equivalent to 1% of the traffic experiencing an availability drop for that pair. For more information, see How Internet Monitor calculates performance and availability
        /// 			scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let availability: AvailabilityMeasurement?
        /// Performance in Internet Monitor represents the estimated percentage of traffic that is not seeing a performance drop. For example, a performance score of 99% for
        /// 			an end user and service location pair is equivalent to 1% of the traffic experiencing a performance drop for that pair. For more information, see How Internet Monitor calculates performance and availability
        /// 			scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let performance: PerformanceMeasurement?

        public init(availability: AvailabilityMeasurement? = nil, performance: PerformanceMeasurement? = nil) {
            self.availability = availability
            self.performance = performance
        }

        private enum CodingKeys: String, CodingKey {
            case availability = "Availability"
            case performance = "Performance"
        }
    }

    public struct InternetMeasurementsLogDelivery: AWSEncodableShape & AWSDecodableShape {
        /// The configuration information for publishing Internet Monitor internet measurements to Amazon S3. The configuration includes the bucket name and (optionally) prefix
        /// 			for the S3 bucket to store the measurements, and the delivery status. The delivery status is ENABLED or DISABLED, depending on
        /// 			whether you choose to deliver internet measurements to S3 logs.
        public let s3Config: S3Config?

        public init(s3Config: S3Config? = nil) {
            self.s3Config = s3Config
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct ListHealthEventsInput: AWSEncodableShape {
        /// The time when a health event ended. If the health event is still ongoing, then the end time is not set.
        public let endTime: Date?
        /// The status of a health event.
        public let eventStatus: HealthEventStatus?
        /// The number of health event objects that you want to return with this call.
        public let maxResults: Int?
        /// The name of the monitor.
        public let monitorName: String
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?
        /// The time when a health event started.
        public let startTime: Date?

        public init(endTime: Date? = nil, eventStatus: HealthEventStatus? = nil, maxResults: Int? = nil, monitorName: String, nextToken: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.eventStatus = eventStatus
            self.maxResults = maxResults
            self.monitorName = monitorName
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.endTime, key: "EndTime")
            request.encodeQuery(self.eventStatus, key: "EventStatus")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodePath(self.monitorName, key: "MonitorName")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.startTime, key: "StartTime")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHealthEventsOutput: AWSDecodableShape {
        /// A list of health events.
        public let healthEvents: [HealthEvent]
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(healthEvents: [HealthEvent], nextToken: String? = nil) {
            self.healthEvents = healthEvents
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case healthEvents = "HealthEvents"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitorsInput: AWSEncodableShape {
        /// The number of monitor objects that you want to return with this call.
        public let maxResults: Int?
        /// The status of a monitor. This includes the status of the data processing for the monitor and the status of the monitor itself. For information about the statuses for a monitor, see
        /// 				Monitor.
        public let monitorStatus: String?
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, monitorStatus: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.monitorStatus = monitorStatus
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.monitorStatus, key: "MonitorStatus")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMonitorsOutput: AWSDecodableShape {
        /// A list of monitors.
        public let monitors: [Monitor]
        /// The token for the next set of results. You receive this token from a previous call.
        public let nextToken: String?

        public init(monitors: [Monitor], nextToken: String? = nil) {
            self.monitors = monitors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitors = "Monitors"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// Tags for a resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Monitor: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The name of the monitor.
        public let monitorName: String
        /// The health of data processing for the monitor.
        public let processingStatus: MonitorProcessingStatusCode?
        /// The status of a monitor.
        public let status: MonitorConfigState

        public init(monitorArn: String, monitorName: String, processingStatus: MonitorProcessingStatusCode? = nil, status: MonitorConfigState) {
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.processingStatus = processingStatus
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
            case monitorName = "MonitorName"
            case processingStatus = "ProcessingStatus"
            case status = "Status"
        }
    }

    public struct Network: AWSDecodableShape {
        /// The internet provider name or network name.
        public let asName: String
        /// The Autonomous System Number (ASN) of the internet provider or network.
        public let asNumber: Int64

        public init(asName: String, asNumber: Int64) {
            self.asName = asName
            self.asNumber = asNumber
        }

        private enum CodingKeys: String, CodingKey {
            case asName = "ASName"
            case asNumber = "ASNumber"
        }
    }

    public struct NetworkImpairment: AWSDecodableShape {
        /// The combination of the Autonomous System Number (ASN) of the network and the name of the network.
        public let asPath: [Network]
        /// Type of network impairment.
        public let networkEventType: TriangulationEventType
        /// The networks that could be impacted by a network impairment event.
        public let networks: [Network]

        public init(asPath: [Network], networkEventType: TriangulationEventType, networks: [Network]) {
            self.asPath = asPath
            self.networkEventType = networkEventType
            self.networks = networks
        }

        private enum CodingKeys: String, CodingKey {
            case asPath = "AsPath"
            case networkEventType = "NetworkEventType"
            case networks = "Networks"
        }
    }

    public struct PerformanceMeasurement: AWSDecodableShape {
        /// Experience scores, or health scores, are calculated for different geographic and network provider combinations (that is, different granularities) and
        /// 			also totaled into global scores. If you view performance or availability scores without filtering for any specific geography or service provider, Amazon CloudWatch Internet Monitor
        /// 			provides global health scores. The Amazon CloudWatch Internet Monitor chapter in the CloudWatch User Guide includes detailed information about how Internet Monitor calculates health scores, including performance and
        /// 			availability scores, and when it creates and resolves health events. For more information, see How Amazon Web Services calculates performance and
        /// 				availability scores in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let experienceScore: Double?
        /// How much performance impact was caused by a health event at a client location. For performance, this is the percentage of how much latency increased
        /// 			during the event compared to typical performance for traffic, from this client location to an Amazon Web Services location, using a specific client network.  For more information, see When Amazon Web Services creates and resolves health
        /// 			events in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let percentOfClientLocationImpacted: Double?
        /// How much performance impact was caused by a health event for total traffic globally. For performance, this is the percentage of how much latency
        /// 			increased during the event compared to typical performance for your application traffic globally.  For more information, see When Amazon Web Services creates and resolves health
        /// 			events in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let percentOfTotalTrafficImpacted: Double?
        /// This is the percentage of how much round-trip time increased during the event compared to typical round-trip time for your application for traffic.  For more information, see When Amazon Web Services creates and resolves health
        /// 			events in the Amazon CloudWatch Internet Monitor section of the CloudWatch User Guide.
        public let roundTripTime: RoundTripTime?

        public init(experienceScore: Double? = nil, percentOfClientLocationImpacted: Double? = nil, percentOfTotalTrafficImpacted: Double? = nil, roundTripTime: RoundTripTime? = nil) {
            self.experienceScore = experienceScore
            self.percentOfClientLocationImpacted = percentOfClientLocationImpacted
            self.percentOfTotalTrafficImpacted = percentOfTotalTrafficImpacted
            self.roundTripTime = roundTripTime
        }

        private enum CodingKeys: String, CodingKey {
            case experienceScore = "ExperienceScore"
            case percentOfClientLocationImpacted = "PercentOfClientLocationImpacted"
            case percentOfTotalTrafficImpacted = "PercentOfTotalTrafficImpacted"
            case roundTripTime = "RoundTripTime"
        }
    }

    public struct RoundTripTime: AWSDecodableShape {
        /// RTT at the 50th percentile (p50).
        public let p50: Double?
        /// RTT at the 90th percentile (p90).
        public let p90: Double?
        /// RTT at the 95th percentile (p95).
        public let p95: Double?

        public init(p50: Double? = nil, p90: Double? = nil, p95: Double? = nil) {
            self.p50 = p50
            self.p90 = p90
            self.p95 = p95
        }

        private enum CodingKeys: String, CodingKey {
            case p50 = "P50"
            case p90 = "P90"
            case p95 = "P95"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon S3 bucket name.
        public let bucketName: String?
        /// The Amazon S3 bucket prefix.
        public let bucketPrefix: String?
        /// The status of publishing Internet Monitor internet measurements to an Amazon S3 bucket.
        public let logDeliveryStatus: LogDeliveryStatus?

        public init(bucketName: String? = nil, bucketPrefix: String? = nil, logDeliveryStatus: LogDeliveryStatus? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.logDeliveryStatus = logDeliveryStatus
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case bucketPrefix = "BucketPrefix"
            case logDeliveryStatus = "LogDeliveryStatus"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a tag that you add to a resource. Tags are supported only for monitors in Amazon CloudWatch Internet Monitor.
        public let resourceArn: String
        /// Tags that you add to a resource. You can add a maximum of 50 tags in Internet Monitor.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) for a tag you remove a resource from.
        public let resourceArn: String
        /// Tag keys that you remove from a resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 512)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:.*")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMonitorInput: AWSEncodableShape {
        /// A unique, case-sensitive string of up to 64 ASCII characters that you specify to make an idempotent API request. You should not reuse the same client
        /// 			token for other API requests.
        public let clientToken: String?
        /// Publish internet measurements for Internet Monitor to another location, such as an Amazon S3 bucket. The measurements are also published to Amazon CloudWatch Logs.
        public let internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery?
        /// The maximum number of city-networks to monitor for your resources. A city-network is the location (city) where clients access your application resources from
        /// 			and the network or ASN,
        /// 			such as an internet service provider, that clients access the resources through.
        public let maxCityNetworksToMonitor: Int?
        /// The name of the monitor.
        public let monitorName: String
        /// The resources to include in a monitor, which you provide as a set of Amazon Resource Names (ARNs). You can add a combination of Amazon Virtual Private Clouds (VPCs) and Amazon CloudFront distributions, or you can add Amazon WorkSpaces directories. You can't add all three types of
        /// 			resources.  If you add only VPC resources, at least one VPC must have an Internet Gateway attached to it, to make sure that it has internet
        /// 			connectivity.
        public let resourcesToAdd: [String]?
        /// The resources to remove from a monitor, which you provide as a set of Amazon Resource Names (ARNs).
        public let resourcesToRemove: [String]?
        /// The status for a monitor. The accepted values for Status with the UpdateMonitor API call are the following: ACTIVE and
        /// 			INACTIVE. The following values are not accepted: PENDING, and ERROR.
        public let status: MonitorConfigState?
        /// The percentage of the internet-facing traffic for your application that you want to monitor with this monitor.
        public let trafficPercentageToMonitor: Int?

        public init(clientToken: String? = UpdateMonitorInput.idempotencyToken(), internetMeasurementsLogDelivery: InternetMeasurementsLogDelivery? = nil, maxCityNetworksToMonitor: Int? = nil, monitorName: String, resourcesToAdd: [String]? = nil, resourcesToRemove: [String]? = nil, status: MonitorConfigState? = nil, trafficPercentageToMonitor: Int? = nil) {
            self.clientToken = clientToken
            self.internetMeasurementsLogDelivery = internetMeasurementsLogDelivery
            self.maxCityNetworksToMonitor = maxCityNetworksToMonitor
            self.monitorName = monitorName
            self.resourcesToAdd = resourcesToAdd
            self.resourcesToRemove = resourcesToRemove
            self.status = status
            self.trafficPercentageToMonitor = trafficPercentageToMonitor
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.internetMeasurementsLogDelivery, forKey: .internetMeasurementsLogDelivery)
            try container.encodeIfPresent(self.maxCityNetworksToMonitor, forKey: .maxCityNetworksToMonitor)
            request.encodePath(self.monitorName, key: "MonitorName")
            try container.encodeIfPresent(self.resourcesToAdd, forKey: .resourcesToAdd)
            try container.encodeIfPresent(self.resourcesToRemove, forKey: .resourcesToRemove)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.trafficPercentageToMonitor, forKey: .trafficPercentageToMonitor)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, max: 500000)
            try self.validate(self.maxCityNetworksToMonitor, name: "maxCityNetworksToMonitor", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 255)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z0-9_.-]+$")
            try self.resourcesToAdd?.forEach {
                try validate($0, name: "resourcesToAdd[]", parent: name, max: 2048)
                try validate($0, name: "resourcesToAdd[]", parent: name, min: 20)
                try validate($0, name: "resourcesToAdd[]", parent: name, pattern: "^arn:.*")
            }
            try self.resourcesToRemove?.forEach {
                try validate($0, name: "resourcesToRemove[]", parent: name, max: 2048)
                try validate($0, name: "resourcesToRemove[]", parent: name, min: 20)
                try validate($0, name: "resourcesToRemove[]", parent: name, pattern: "^arn:.*")
            }
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, max: 100)
            try self.validate(self.trafficPercentageToMonitor, name: "trafficPercentageToMonitor", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case internetMeasurementsLogDelivery = "InternetMeasurementsLogDelivery"
            case maxCityNetworksToMonitor = "MaxCityNetworksToMonitor"
            case resourcesToAdd = "ResourcesToAdd"
            case resourcesToRemove = "ResourcesToRemove"
            case status = "Status"
            case trafficPercentageToMonitor = "TrafficPercentageToMonitor"
        }
    }

    public struct UpdateMonitorOutput: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor.
        public let monitorArn: String
        /// The status of a monitor.
        public let status: MonitorConfigState

        public init(monitorArn: String, status: MonitorConfigState) {
            self.monitorArn = monitorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
            case status = "Status"
        }
    }
}

// MARK: - Errors

/// Error enum for InternetMonitor
public struct InternetMonitorErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case badRequestException = "BadRequestException"
        case conflictException = "ConflictException"
        case internalServerErrorException = "InternalServerErrorException"
        case internalServerException = "InternalServerException"
        case limitExceededException = "LimitExceededException"
        case notFoundException = "NotFoundException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case tooManyRequestsException = "TooManyRequestsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize InternetMonitor
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You don't have sufficient permission to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// A bad request was received.
    public static var badRequestException: Self { .init(.badRequestException) }
    /// The requested resource is in use.
    public static var conflictException: Self { .init(.conflictException) }
    /// There was an internal server error.
    public static var internalServerErrorException: Self { .init(.internalServerErrorException) }
    /// An internal error occurred.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request exceeded a service quota.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The request specifies something that doesn't exist.
    public static var notFoundException: Self { .init(.notFoundException) }
    /// The request specifies a resource that doesn't exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// There were too many requests.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// Invalid request.
    public static var validationException: Self { .init(.validationException) }
}

extension InternetMonitorErrorType: Equatable {
    public static func == (lhs: InternetMonitorErrorType, rhs: InternetMonitorErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension InternetMonitorErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
