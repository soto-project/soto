//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS InternetMonitor service.
///
/// Amazon CloudWatch Internet Monitor provides visibility into how internet issues impact the performance and availability
/// 			between your applications hosted on Amazon Web Services and your end users. It can reduce the time it takes for you to diagnose
/// 			internet issues from days to minutes. Internet Monitor uses the connectivity data that Amazon Web Services captures from its global
/// 			networking footprint to calculate a baseline of performance and availability for internet traffic. This
/// 			is the same data that Amazon Web Services uses to monitor internet uptime and availability. With those measurements
/// 			as a baseline, Internet Monitor raises awareness for you when there are significant problems for your
/// 			end users in the different geographic locations where your application runs. Internet Monitor publishes internet measurements to CloudWatch Logs and CloudWatch Metrics,
/// 			to easily support using CloudWatch tools with health information for geographies and networks specific to your application.
/// 			Internet Monitor sends health events to Amazon EventBridge so that you can set up notifications. If an issue is caused by the Amazon Web Services network,
/// 			you also automatically receive an Amazon Web Services Health Dashboard notification with the steps that Amazon Web Services is taking to mitigate the problem. To use Internet Monitor, you create a monitor and associate your application's resources
/// 			with it - VPCs, NLBs, CloudFront distributions, or WorkSpaces directories - so Internet Monitor can determine
/// 			where your application's internet traffic is. Internet Monitor then provides internet measurements from Amazon Web Services that are specific to
/// 			the locations and ASNs (typically, internet service providers or ISPs) that communicate with your application. For more information, see Using Amazon CloudWatch Internet Monitor in the Amazon CloudWatch User Guide.
public struct InternetMonitor: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the InternetMonitor client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "internetmonitor",
            serviceProtocol: .restjson,
            apiVersion: "2021-06-03",
            endpoint: endpoint,
            serviceEndpoints: [
                "af-south-1": "internetmonitor.af-south-1.api.aws",
                "ap-east-1": "internetmonitor.ap-east-1.api.aws",
                "ap-northeast-1": "internetmonitor.ap-northeast-1.api.aws",
                "ap-northeast-2": "internetmonitor.ap-northeast-2.api.aws",
                "ap-northeast-3": "internetmonitor.ap-northeast-3.api.aws",
                "ap-south-1": "internetmonitor.ap-south-1.api.aws",
                "ap-south-2": "internetmonitor.ap-south-2.api.aws",
                "ap-southeast-1": "internetmonitor.ap-southeast-1.api.aws",
                "ap-southeast-2": "internetmonitor.ap-southeast-2.api.aws",
                "ap-southeast-3": "internetmonitor.ap-southeast-3.api.aws",
                "ap-southeast-4": "internetmonitor.ap-southeast-4.api.aws",
                "ca-central-1": "internetmonitor.ca-central-1.api.aws",
                "cn-north-1": "internetmonitor.cn-north-1.api.amazonwebservices.com.cn",
                "cn-northwest-1": "internetmonitor.cn-northwest-1.api.amazonwebservices.com.cn",
                "eu-central-1": "internetmonitor.eu-central-1.api.aws",
                "eu-central-2": "internetmonitor.eu-central-2.api.aws",
                "eu-north-1": "internetmonitor.eu-north-1.api.aws",
                "eu-south-1": "internetmonitor.eu-south-1.api.aws",
                "eu-south-2": "internetmonitor.eu-south-2.api.aws",
                "eu-west-1": "internetmonitor.eu-west-1.api.aws",
                "eu-west-2": "internetmonitor.eu-west-2.api.aws",
                "eu-west-3": "internetmonitor.eu-west-3.api.aws",
                "il-central-1": "internetmonitor.il-central-1.api.aws",
                "me-central-1": "internetmonitor.me-central-1.api.aws",
                "me-south-1": "internetmonitor.me-south-1.api.aws",
                "sa-east-1": "internetmonitor.sa-east-1.api.aws",
                "us-east-1": "internetmonitor.us-east-1.api.aws",
                "us-east-2": "internetmonitor.us-east-2.api.aws",
                "us-gov-east-1": "internetmonitor.us-gov-east-1.api.aws",
                "us-gov-west-1": "internetmonitor.us-gov-west-1.api.aws",
                "us-west-1": "internetmonitor.us-west-1.api.aws",
                "us-west-2": "internetmonitor.us-west-2.api.aws"
            ],
            variantEndpoints: [
                [.fips]: .init(endpoints: [
                    "af-south-1": "internetmonitor-fips.af-south-1.api.aws",
                    "ap-east-1": "internetmonitor-fips.ap-east-1.api.aws",
                    "ap-northeast-1": "internetmonitor-fips.ap-northeast-1.api.aws",
                    "ap-northeast-2": "internetmonitor-fips.ap-northeast-2.api.aws",
                    "ap-northeast-3": "internetmonitor-fips.ap-northeast-3.api.aws",
                    "ap-south-1": "internetmonitor-fips.ap-south-1.api.aws",
                    "ap-south-2": "internetmonitor-fips.ap-south-2.api.aws",
                    "ap-southeast-1": "internetmonitor-fips.ap-southeast-1.api.aws",
                    "ap-southeast-2": "internetmonitor-fips.ap-southeast-2.api.aws",
                    "ap-southeast-3": "internetmonitor-fips.ap-southeast-3.api.aws",
                    "ap-southeast-4": "internetmonitor-fips.ap-southeast-4.api.aws",
                    "ca-central-1": "internetmonitor-fips.ca-central-1.amazonaws.com",
                    "cn-north-1": "internetmonitor-fips.cn-north-1.api.amazonwebservices.com.cn",
                    "cn-northwest-1": "internetmonitor-fips.cn-northwest-1.api.amazonwebservices.com.cn",
                    "eu-central-1": "internetmonitor-fips.eu-central-1.api.aws",
                    "eu-central-2": "internetmonitor-fips.eu-central-2.api.aws",
                    "eu-north-1": "internetmonitor-fips.eu-north-1.api.aws",
                    "eu-south-1": "internetmonitor-fips.eu-south-1.api.aws",
                    "eu-south-2": "internetmonitor-fips.eu-south-2.api.aws",
                    "eu-west-1": "internetmonitor-fips.eu-west-1.api.aws",
                    "eu-west-2": "internetmonitor-fips.eu-west-2.api.aws",
                    "eu-west-3": "internetmonitor-fips.eu-west-3.api.aws",
                    "il-central-1": "internetmonitor-fips.il-central-1.api.aws",
                    "me-central-1": "internetmonitor-fips.me-central-1.api.aws",
                    "me-south-1": "internetmonitor-fips.me-south-1.api.aws",
                    "sa-east-1": "internetmonitor-fips.sa-east-1.api.aws",
                    "us-east-1": "internetmonitor-fips.us-east-1.amazonaws.com",
                    "us-east-2": "internetmonitor-fips.us-east-2.amazonaws.com",
                    "us-gov-east-1": "internetmonitor-fips.us-gov-east-1.api.aws",
                    "us-gov-west-1": "internetmonitor-fips.us-gov-west-1.api.aws",
                    "us-west-1": "internetmonitor-fips.us-west-1.amazonaws.com",
                    "us-west-2": "internetmonitor-fips.us-west-2.amazonaws.com"
                ])
            ],
            errorType: InternetMonitorErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Creates a monitor in Amazon CloudWatch Internet Monitor. A monitor is built based on information from the application resources that you add: VPCs,
    /// 			Network Load Balancers (NLBs), Amazon CloudFront distributions, and Amazon WorkSpaces directories. Internet Monitor then publishes internet measurements from Amazon Web Services
    /// 			that are specific to the city-networks. That is, the locations and ASNs (typically internet service providers or ISPs),
    /// 			where clients access your application. For more information, see Using Amazon CloudWatch Internet Monitor in the Amazon CloudWatch User
    /// 					Guide. When you create a monitor, you choose the percentage of traffic that you want to monitor. You can also set a maximum limit for the
    /// 			number of city-networks where client traffic is monitored, that caps the total traffic that Internet Monitor monitors. A city-network
    /// 			maximum is the limit of city-networks, but you only pay for the number of city-networks that are actually monitored. You can update your monitor
    /// 			at any time to change the percentage of traffic to monitor or the city-networks maximum. For more information, see Choosing a city-network maximum value in the Amazon CloudWatch User Guide.
    public func createMonitor(_ input: CreateMonitorInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateMonitorOutput> {
        return self.client.execute(operation: "CreateMonitor", path: "/v20210603/Monitors", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a monitor in Amazon CloudWatch Internet Monitor.
    public func deleteMonitor(_ input: DeleteMonitorInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteMonitorOutput> {
        return self.client.execute(operation: "DeleteMonitor", path: "/v20210603/Monitors/{MonitorName}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information the Amazon CloudWatch Internet Monitor has created and stored about a health event for a specified monitor. This information includes the impacted locations,
    /// 			and all the information related to the event, by location. The information returned includes the impact on performance, availability, and round-trip time, information about the network providers (ASNs),
    /// 			the event type, and so on. Information rolled up at the global traffic level is also returned, including the impact type and total traffic impact.
    public func getHealthEvent(_ input: GetHealthEventInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetHealthEventOutput> {
        return self.client.execute(operation: "GetHealthEvent", path: "/v20210603/Monitors/{MonitorName}/HealthEvents/{EventId}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Gets information about a monitor in Amazon CloudWatch Internet Monitor based on a monitor name. The information returned includes the Amazon Resource Name (ARN), create time,
    /// 			modified time, resources included in the monitor, and status information.
    public func getMonitor(_ input: GetMonitorInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetMonitorOutput> {
        return self.client.execute(operation: "GetMonitor", path: "/v20210603/Monitors/{MonitorName}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all health events for a monitor in Amazon CloudWatch Internet Monitor. Returns information for health events including the event start and end time and
    /// 			the status.  Health events that have start times during the time frame that is requested are not included in the list of health events.
    public func listHealthEvents(_ input: ListHealthEventsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListHealthEventsOutput> {
        return self.client.execute(operation: "ListHealthEvents", path: "/v20210603/Monitors/{MonitorName}/HealthEvents", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all of your monitors for Amazon CloudWatch Internet Monitor and their statuses, along with the Amazon Resource Name (ARN) and name of each monitor.
    public func listMonitors(_ input: ListMonitorsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMonitorsOutput> {
        return self.client.execute(operation: "ListMonitors", path: "/v20210603/Monitors", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the tags for a resource. Tags are supported only for monitors in Amazon CloudWatch Internet Monitor.
    public func listTagsForResource(_ input: ListTagsForResourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListTagsForResourceOutput> {
        return self.client.execute(operation: "ListTagsForResource", path: "/tags/{ResourceArn}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Adds a tag to a resource. Tags are supported only for monitors in Amazon CloudWatch Internet Monitor. You can add a maximum of 50 tags in Internet Monitor. A minimum of one tag is required for this call. It returns an error if you use the TagResource request with 0 tags.
    public func tagResource(_ input: TagResourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<TagResourceOutput> {
        return self.client.execute(operation: "TagResource", path: "/tags/{ResourceArn}", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes a tag from a resource.
    public func untagResource(_ input: UntagResourceInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UntagResourceOutput> {
        return self.client.execute(operation: "UntagResource", path: "/tags/{ResourceArn}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a monitor. You can update a monitor to change the percentage of traffic to monitor or the maximum number of city-networks
    /// 			(locations and ASNs), to add or remove resources, or to change the status of the monitor. Note that you can't change the name of a monitor. The city-network maximum that you choose is the limit, but you only pay for the number of city-networks that are actually monitored.
    /// 			For more information, see Choosing a city-network maximum value in the Amazon CloudWatch User Guide.
    public func updateMonitor(_ input: UpdateMonitorInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateMonitorOutput> {
        return self.client.execute(operation: "UpdateMonitor", path: "/v20210603/Monitors/{MonitorName}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension InternetMonitor {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: InternetMonitor, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension InternetMonitor {
    /// Lists all health events for a monitor in Amazon CloudWatch Internet Monitor. Returns information for health events including the event start and end time and
    /// 			the status.  Health events that have start times during the time frame that is requested are not included in the list of health events.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listHealthEventsPaginator<Result>(
        _ input: ListHealthEventsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListHealthEventsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listHealthEvents,
            inputKey: \ListHealthEventsInput.nextToken,
            outputKey: \ListHealthEventsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listHealthEventsPaginator(
        _ input: ListHealthEventsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListHealthEventsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listHealthEvents,
            inputKey: \ListHealthEventsInput.nextToken,
            outputKey: \ListHealthEventsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Lists all of your monitors for Amazon CloudWatch Internet Monitor and their statuses, along with the Amazon Resource Name (ARN) and name of each monitor.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listMonitorsPaginator<Result>(
        _ input: ListMonitorsInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListMonitorsOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listMonitors,
            inputKey: \ListMonitorsInput.nextToken,
            outputKey: \ListMonitorsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listMonitorsPaginator(
        _ input: ListMonitorsInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListMonitorsOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listMonitors,
            inputKey: \ListMonitorsInput.nextToken,
            outputKey: \ListMonitorsOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension InternetMonitor.ListHealthEventsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> InternetMonitor.ListHealthEventsInput {
        return .init(
            endTime: self.endTime,
            eventStatus: self.eventStatus,
            maxResults: self.maxResults,
            monitorName: self.monitorName,
            nextToken: token,
            startTime: self.startTime
        )
    }
}

extension InternetMonitor.ListMonitorsInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> InternetMonitor.ListMonitorsInput {
        return .init(
            maxResults: self.maxResults,
            monitorStatus: self.monitorStatus,
            nextToken: token
        )
    }
}
