//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

@_exported import SotoCore

/// Service object for interacting with AWS CleanRooms service.
///
///  AWS Clean Rooms is in preview release and is subject to change.  Welcome to the AWS Clean Rooms API Reference. AWS Clean Rooms is an AWS service that helps multiple parties to join their data together in a secure collaboration workspace. In the collaboration, members who can query and receive results can get insights into the combined data without either party getting access to the other party's raw data. To learn more about AWS Clean Rooms concepts, procedures, and best practices, see the AWS Clean Rooms User Guide.
public struct CleanRooms: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the CleanRooms client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            service: "cleanrooms",
            serviceProtocol: .restjson,
            apiVersion: "2022-02-17",
            endpoint: endpoint,
            errorType: CleanRoomsErrorType.self,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }

    // MARK: API Calls

    /// Retrieves multiple schemas by their identifiers.
    public func batchGetSchema(_ input: BatchGetSchemaInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<BatchGetSchemaOutput> {
        return self.client.execute(operation: "BatchGetSchema", path: "/collaborations/{collaborationIdentifier}/batch-schema", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new collaboration.
    public func createCollaboration(_ input: CreateCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateCollaborationOutput> {
        return self.client.execute(operation: "CreateCollaboration", path: "/collaborations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new configured table resource.
    public func createConfiguredTable(_ input: CreateConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredTableOutput> {
        return self.client.execute(operation: "CreateConfiguredTable", path: "/configuredTables", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a new analysis rule for a configured table. Currently, only one analysis rule can be created for a given configured table.
    public func createConfiguredTableAnalysisRule(_ input: CreateConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "CreateConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a configured table association. A configured table association links a configured table with a collaboration.
    public func createConfiguredTableAssociation(_ input: CreateConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "CreateConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a membership for a specific collaboration identifier and joins the collaboration.
    public func createMembership(_ input: CreateMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<CreateMembershipOutput> {
        return self.client.execute(operation: "CreateMembership", path: "/memberships", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a collaboration. It can only be called by the collaboration owner.
    public func deleteCollaboration(_ input: DeleteCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteCollaborationOutput> {
        return self.client.execute(operation: "DeleteCollaboration", path: "/collaborations/{collaborationIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a configured table.
    public func deleteConfiguredTable(_ input: DeleteConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConfiguredTableOutput> {
        return self.client.execute(operation: "DeleteConfiguredTable", path: "/configuredTables/{configuredTableIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a configured table analysis rule.
    public func deleteConfiguredTableAnalysisRule(_ input: DeleteConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "DeleteConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule/{analysisRuleType}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a configured table association.
    public func deleteConfiguredTableAssociation(_ input: DeleteConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "DeleteConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations/{configuredTableAssociationIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Removes the specified member from a collaboration. The removed member is placed in the Removed status and can't interact with the collaboration. The removed member's data is inaccessible to active members of the collaboration.
    public func deleteMember(_ input: DeleteMemberInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteMemberOutput> {
        return self.client.execute(operation: "DeleteMember", path: "/collaborations/{collaborationIdentifier}/member/{accountId}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Deletes a specified membership. All resources under a membership must be deleted.
    public func deleteMembership(_ input: DeleteMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<DeleteMembershipOutput> {
        return self.client.execute(operation: "DeleteMembership", path: "/memberships/{membershipIdentifier}", httpMethod: .DELETE, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns metadata about a collaboration.
    public func getCollaboration(_ input: GetCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetCollaborationOutput> {
        return self.client.execute(operation: "GetCollaboration", path: "/collaborations/{collaborationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a configured table.
    public func getConfiguredTable(_ input: GetConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredTableOutput> {
        return self.client.execute(operation: "GetConfiguredTable", path: "/configuredTables/{configuredTableIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a configured table analysis rule.
    public func getConfiguredTableAnalysisRule(_ input: GetConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "GetConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule/{analysisRuleType}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a configured table association.
    public func getConfiguredTableAssociation(_ input: GetConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "GetConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations/{configuredTableAssociationIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a specified membership for an identifier.
    public func getMembership(_ input: GetMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetMembershipOutput> {
        return self.client.execute(operation: "GetMembership", path: "/memberships/{membershipIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Returns query processing metadata.
    public func getProtectedQuery(_ input: GetProtectedQueryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetProtectedQueryOutput> {
        return self.client.execute(operation: "GetProtectedQuery", path: "/memberships/{membershipIdentifier}/protectedQueries/{protectedQueryIdentifier}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves the schema for a relation within a collaboration.
    public func getSchema(_ input: GetSchemaInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSchemaOutput> {
        return self.client.execute(operation: "GetSchema", path: "/collaborations/{collaborationIdentifier}/schemas/{name}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Retrieves a schema analysis rule.
    public func getSchemaAnalysisRule(_ input: GetSchemaAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<GetSchemaAnalysisRuleOutput> {
        return self.client.execute(operation: "GetSchemaAnalysisRule", path: "/collaborations/{collaborationIdentifier}/schemas/{name}/analysisRule/{type}", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists collaborations the caller owns, is active in, or has been invited to.
    public func listCollaborations(_ input: ListCollaborationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListCollaborationsOutput> {
        return self.client.execute(operation: "ListCollaborations", path: "/collaborations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists configured table associations for a membership.
    public func listConfiguredTableAssociations(_ input: ListConfiguredTableAssociationsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConfiguredTableAssociationsOutput> {
        return self.client.execute(operation: "ListConfiguredTableAssociations", path: "/memberships/{membershipIdentifier}/configuredTableAssociations", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists configured tables.
    public func listConfiguredTables(_ input: ListConfiguredTablesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListConfiguredTablesOutput> {
        return self.client.execute(operation: "ListConfiguredTables", path: "/configuredTables", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all members within a collaboration.
    public func listMembers(_ input: ListMembersInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMembersOutput> {
        return self.client.execute(operation: "ListMembers", path: "/collaborations/{collaborationIdentifier}/members", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists all memberships resources within the caller's account.
    public func listMemberships(_ input: ListMembershipsInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListMembershipsOutput> {
        return self.client.execute(operation: "ListMemberships", path: "/memberships", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists protected queries, sorted by the most recent query.
    public func listProtectedQueries(_ input: ListProtectedQueriesInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListProtectedQueriesOutput> {
        return self.client.execute(operation: "ListProtectedQueries", path: "/memberships/{membershipIdentifier}/protectedQueries", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Lists the schemas for relations within a collaboration.
    public func listSchemas(_ input: ListSchemasInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<ListSchemasOutput> {
        return self.client.execute(operation: "ListSchemas", path: "/collaborations/{collaborationIdentifier}/schemas", httpMethod: .GET, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Creates a protected query that is started by AWS Clean Rooms.
    public func startProtectedQuery(_ input: StartProtectedQueryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<StartProtectedQueryOutput> {
        return self.client.execute(operation: "StartProtectedQuery", path: "/memberships/{membershipIdentifier}/protectedQueries", httpMethod: .POST, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates collaboration metadata and can only be called by the collaboration owner.
    public func updateCollaboration(_ input: UpdateCollaborationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateCollaborationOutput> {
        return self.client.execute(operation: "UpdateCollaboration", path: "/collaborations/{collaborationIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a configured table.
    public func updateConfiguredTable(_ input: UpdateConfiguredTableInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredTableOutput> {
        return self.client.execute(operation: "UpdateConfiguredTable", path: "/configuredTables/{configuredTableIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a configured table analysis rule.
    public func updateConfiguredTableAnalysisRule(_ input: UpdateConfiguredTableAnalysisRuleInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredTableAnalysisRuleOutput> {
        return self.client.execute(operation: "UpdateConfiguredTableAnalysisRule", path: "/configuredTables/{configuredTableIdentifier}/analysisRule/{analysisRuleType}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a configured table association.
    public func updateConfiguredTableAssociation(_ input: UpdateConfiguredTableAssociationInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateConfiguredTableAssociationOutput> {
        return self.client.execute(operation: "UpdateConfiguredTableAssociation", path: "/memberships/{membershipIdentifier}/configuredTableAssociations/{configuredTableAssociationIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates a membership.
    public func updateMembership(_ input: UpdateMembershipInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateMembershipOutput> {
        return self.client.execute(operation: "UpdateMembership", path: "/memberships/{membershipIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }

    /// Updates the processing of a currently running query.
    public func updateProtectedQuery(_ input: UpdateProtectedQueryInput, logger: Logger = AWSClient.loggingDisabled, on eventLoop: EventLoop? = nil) -> EventLoopFuture<UpdateProtectedQueryOutput> {
        return self.client.execute(operation: "UpdateProtectedQuery", path: "/memberships/{membershipIdentifier}/protectedQueries/{protectedQueryIdentifier}", httpMethod: .PATCH, serviceConfig: self.config, input: input, logger: logger, on: eventLoop)
    }
}

extension CleanRooms {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are no public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: CleanRooms, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

extension CleanRooms {
    /// Lists protected queries, sorted by the most recent query.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func listProtectedQueriesPaginator<Result>(
        _ input: ListProtectedQueriesInput,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ListProtectedQueriesOutput, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return self.client.paginate(
            input: input,
            initialValue: initialValue,
            command: self.listProtectedQueries,
            inputKey: \ListProtectedQueriesInput.nextToken,
            outputKey: \ListProtectedQueriesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used flot logging
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func listProtectedQueriesPaginator(
        _ input: ListProtectedQueriesInput,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ListProtectedQueriesOutput, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return self.client.paginate(
            input: input,
            command: self.listProtectedQueries,
            inputKey: \ListProtectedQueriesInput.nextToken,
            outputKey: \ListProtectedQueriesOutput.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension CleanRooms.ListProtectedQueriesInput: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> CleanRooms.ListProtectedQueriesInput {
        return .init(
            maxResults: self.maxResults,
            membershipIdentifier: self.membershipIdentifier,
            nextToken: token,
            status: self.status
        )
    }
}
