//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if compiler(>=5.7) && os(Linux)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
import SotoCore

extension CleanRooms {
    // MARK: Enums

    public enum AggregateFunctionName: String, CustomStringConvertible, Codable, Sendable {
        case avg = "AVG"
        case count = "COUNT"
        case countDistinct = "COUNT_DISTINCT"
        case sum = "SUM"
        case sumDistinct = "SUM_DISTINCT"
        public var description: String { return self.rawValue }
    }

    public enum AggregationType: String, CustomStringConvertible, Codable, Sendable {
        case countDistinct = "COUNT_DISTINCT"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisMethod: String, CustomStringConvertible, Codable, Sendable {
        case directQuery = "DIRECT_QUERY"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisRuleType: String, CustomStringConvertible, Codable, Sendable {
        case aggregation = "AGGREGATION"
        case list = "LIST"
        public var description: String { return self.rawValue }
    }

    public enum CollaborationQueryLogStatus: String, CustomStringConvertible, Codable, Sendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ConfiguredTableAnalysisRuleType: String, CustomStringConvertible, Codable, Sendable {
        case aggregation = "AGGREGATION"
        case list = "LIST"
        public var description: String { return self.rawValue }
    }

    public enum FilterableMemberStatus: String, CustomStringConvertible, Codable, Sendable {
        case active = "ACTIVE"
        case invited = "INVITED"
        public var description: String { return self.rawValue }
    }

    public enum JoinRequiredOption: String, CustomStringConvertible, Codable, Sendable {
        case queryRunner = "QUERY_RUNNER"
        public var description: String { return self.rawValue }
    }

    public enum MemberAbility: String, CustomStringConvertible, Codable, Sendable {
        case canQuery = "CAN_QUERY"
        case canReceiveResults = "CAN_RECEIVE_RESULTS"
        public var description: String { return self.rawValue }
    }

    public enum MemberStatus: String, CustomStringConvertible, Codable, Sendable {
        case active = "ACTIVE"
        case invited = "INVITED"
        case left = "LEFT"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum MembershipQueryLogStatus: String, CustomStringConvertible, Codable, Sendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MembershipStatus: String, CustomStringConvertible, Codable, Sendable {
        case active = "ACTIVE"
        case collaborationDeleted = "COLLABORATION_DELETED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedQueryStatus: String, CustomStringConvertible, Codable, Sendable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case failed = "FAILED"
        case started = "STARTED"
        case submitted = "SUBMITTED"
        case success = "SUCCESS"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedQueryType: String, CustomStringConvertible, Codable, Sendable {
        case sql = "SQL"
        public var description: String { return self.rawValue }
    }

    public enum ResultFormat: String, CustomStringConvertible, Codable, Sendable {
        case csv = "CSV"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum ScalarFunctions: String, CustomStringConvertible, Codable, Sendable {
        case abs = "ABS"
        case cast = "CAST"
        case ceiling = "CEILING"
        case coalesce = "COALESCE"
        case floor = "FLOOR"
        case ln = "LN"
        case log = "LOG"
        case lower = "LOWER"
        case round = "ROUND"
        case rtrim = "RTRIM"
        case sqrt = "SQRT"
        case trunc = "TRUNC"
        case upper = "UPPER"
        public var description: String { return self.rawValue }
    }

    public enum SchemaType: String, CustomStringConvertible, Codable, Sendable {
        case table = "TABLE"
        public var description: String { return self.rawValue }
    }

    public enum TargetProtectedQueryStatus: String, CustomStringConvertible, Codable, Sendable {
        case cancelled = "CANCELLED"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisRulePolicyV1: AWSDecodableShape, Sendable {
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(AnalysisRuleAggregation)
        /// Analysis rule type that enables only list queries on a configured table.
        case list(AnalysisRuleList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(AnalysisRuleAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .list:
                let value = try container.decode(AnalysisRuleList.self, forKey: .list)
                self = .list(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case list = "list"
        }
    }

    public enum ConfiguredTableAnalysisRulePolicyV1: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(AnalysisRuleAggregation)
        /// Analysis rule type that enables only list queries on a configured table.
        case list(AnalysisRuleList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(AnalysisRuleAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .list:
                let value = try container.decode(AnalysisRuleList.self, forKey: .list)
                self = .list(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .aggregation(let value):
                try container.encode(value, forKey: .aggregation)
            case .list(let value):
                try container.encode(value, forKey: .list)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .aggregation(let value):
                try value.validate(name: "\(name).aggregation")
            case .list(let value):
                try value.validate(name: "\(name).list")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case list = "list"
        }
    }

    // MARK: Shapes

    public struct AggregateColumn: AWSEncodableShape & AWSDecodableShape {
        /// Column names in configured table of aggregate columns.
        public let columnNames: [String]
        /// Aggregation function that can be applied to aggregate column in query.
        public let function: AggregateFunctionName

        public init(columnNames: [String], function: AggregateFunctionName) {
            self.columnNames = columnNames
            self.function = function
        }

        public func validate(name: String) throws {
            try self.columnNames.forEach {
                try validate($0, name: "columnNames[]", parent: name, max: 127)
                try validate($0, name: "columnNames[]", parent: name, min: 1)
                try validate($0, name: "columnNames[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "columnNames"
            case function = "function"
        }
    }

    public struct AggregationConstraint: AWSEncodableShape & AWSDecodableShape {
        /// Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.
        public let columnName: String
        /// The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.
        public let minimum: Int
        /// The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.
        public let type: AggregationType

        public init(columnName: String, minimum: Int, type: AggregationType) {
            self.columnName = columnName
            self.minimum = minimum
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 127)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case minimum = "minimum"
            case type = "type"
        }
    }

    public struct AnalysisRule: AWSDecodableShape {
        /// The unique ID for the associated collaboration.
        public let collaborationId: String
        /// The time the analysis rule was created.
        public let createTime: Date
        /// The name for the analysis rule.
        public let name: String
        /// A policy that describes the associated data usage limitations.
        public let policy: AnalysisRulePolicy
        /// The type of analysis rule. Valid values are `AGGREGATION` and `LIST`.
        public let type: AnalysisRuleType
        /// The time the analysis rule was last updated.
        public let updateTime: Date

        public init(collaborationId: String, createTime: Date, name: String, policy: AnalysisRulePolicy, type: AnalysisRuleType, updateTime: Date) {
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.name = name
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case name = "name"
            case policy = "policy"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct AnalysisRuleAggregation: AWSEncodableShape & AWSDecodableShape {
        /// The columns that query runners are allowed to use in aggregation queries.
        public let aggregateColumns: [AggregateColumn]
        /// The columns that query runners are allowed to select, group by, or filter by.
        public let dimensionColumns: [String]
        /// Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.
        public let joinColumns: [String]
        /// Control that requires member who runs query to do a join with their configured table and/or other configured table in query
        public let joinRequired: JoinRequiredOption?
        /// Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.
        public let outputConstraints: [AggregationConstraint]
        /// Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.
        public let scalarFunctions: [ScalarFunctions]

        public init(aggregateColumns: [AggregateColumn], dimensionColumns: [String], joinColumns: [String], joinRequired: JoinRequiredOption? = nil, outputConstraints: [AggregationConstraint], scalarFunctions: [ScalarFunctions]) {
            self.aggregateColumns = aggregateColumns
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.joinRequired = joinRequired
            self.outputConstraints = outputConstraints
            self.scalarFunctions = scalarFunctions
        }

        public func validate(name: String) throws {
            try self.aggregateColumns.forEach {
                try $0.validate(name: "\(name).aggregateColumns[]")
            }
            try self.dimensionColumns.forEach {
                try validate($0, name: "dimensionColumns[]", parent: name, max: 127)
                try validate($0, name: "dimensionColumns[]", parent: name, min: 1)
                try validate($0, name: "dimensionColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.joinColumns.forEach {
                try validate($0, name: "joinColumns[]", parent: name, max: 127)
                try validate($0, name: "joinColumns[]", parent: name, min: 1)
                try validate($0, name: "joinColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.outputConstraints.forEach {
                try $0.validate(name: "\(name).outputConstraints[]")
            }
            try self.validate(self.outputConstraints, name: "outputConstraints", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateColumns = "aggregateColumns"
            case dimensionColumns = "dimensionColumns"
            case joinColumns = "joinColumns"
            case joinRequired = "joinRequired"
            case outputConstraints = "outputConstraints"
            case scalarFunctions = "scalarFunctions"
        }
    }

    public struct AnalysisRuleList: AWSEncodableShape & AWSDecodableShape {
        /// Columns that can be used to join a configured table with the table of the member who can query and another members' configured tables.
        public let joinColumns: [String]
        /// Columns that can be listed in the output.
        public let listColumns: [String]

        public init(joinColumns: [String], listColumns: [String]) {
            self.joinColumns = joinColumns
            self.listColumns = listColumns
        }

        public func validate(name: String) throws {
            try self.joinColumns.forEach {
                try validate($0, name: "joinColumns[]", parent: name, max: 127)
                try validate($0, name: "joinColumns[]", parent: name, min: 1)
                try validate($0, name: "joinColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.listColumns.forEach {
                try validate($0, name: "listColumns[]", parent: name, max: 127)
                try validate($0, name: "listColumns[]", parent: name, min: 1)
                try validate($0, name: "listColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case joinColumns = "joinColumns"
            case listColumns = "listColumns"
        }
    }

    public struct BatchGetSchemaError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// An error message for the error.
        public let message: String
        /// An error name for the error.
        public let name: String

        public init(code: String, message: String, name: String) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
        }
    }

    public struct BatchGetSchemaInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schemas belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String
        /// The names for the schema objects to retrieve.&gt;
        public let names: [String]

        public init(collaborationIdentifier: String, names: [String]) {
            self.collaborationIdentifier = collaborationIdentifier
            self.names = names
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encode(self.names, forKey: .names)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.names.forEach {
                try validate($0, name: "names[]", parent: name, max: 128)
                try validate($0, name: "names[]", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 25)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case names = "names"
        }
    }

    public struct BatchGetSchemaOutput: AWSDecodableShape {
        /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
        public let errors: [BatchGetSchemaError]
        /// The retrieved list of schemas.
        public let schemas: [Schema]

        public init(errors: [BatchGetSchemaError], schemas: [Schema]) {
            self.errors = errors
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case schemas = "schemas"
        }
    }

    public struct Collaboration: AWSDecodableShape {
        /// The unique ARN for the collaboration.
        public let arn: String
        /// The time when the collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        public let creatorAccountId: String
        /// A display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The settings for client-side encryption for cryptographic computing.
        public let dataEncryptionMetadata: DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public let description: String?
        /// The unique ID for the collaboration.
        public let id: String
        /// The unique ARN for your membership within the collaboration.
        public let membershipArn: String?
        /// The unique ID for your membership within the collaboration.
        public let membershipId: String?
        /// The status of a member in a collaboration.
        public let memberStatus: MemberStatus
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        public let queryLogStatus: CollaborationQueryLogStatus
        /// The time the collaboration metadata was last updated.
        public let updateTime: Date

        public init(arn: String, createTime: Date, creatorAccountId: String, creatorDisplayName: String, dataEncryptionMetadata: DataEncryptionMetadata? = nil, description: String? = nil, id: String, membershipArn: String? = nil, membershipId: String? = nil, memberStatus: MemberStatus, name: String, queryLogStatus: CollaborationQueryLogStatus, updateTime: Date) {
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.memberStatus = memberStatus
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case creatorDisplayName = "creatorDisplayName"
            case dataEncryptionMetadata = "dataEncryptionMetadata"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case memberStatus = "memberStatus"
            case name = "name"
            case queryLogStatus = "queryLogStatus"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationSummary: AWSDecodableShape {
        /// The ARN of the collaboration.
        public let arn: String
        /// The time when the collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.
        public let creatorAccountId: String
        /// The display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The identifier for the collaboration.
        public let id: String
        /// The ARN of a member in a collaboration.
        public let membershipArn: String?
        /// The identifier of a member in a collaboration.
        public let membershipId: String?
        /// The status of a member in a collaboration.
        public let memberStatus: MemberStatus
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String
        /// The time the collaboration metadata was last updated.
        public let updateTime: Date

        public init(arn: String, createTime: Date, creatorAccountId: String, creatorDisplayName: String, id: String, membershipArn: String? = nil, membershipId: String? = nil, memberStatus: MemberStatus, name: String, updateTime: Date) {
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.memberStatus = memberStatus
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case creatorDisplayName = "creatorDisplayName"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case memberStatus = "memberStatus"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct Column: AWSDecodableShape {
        /// The name of the column.
        public let name: String
        /// The type of the column.
        public let type: String

        public init(name: String, type: String) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct ConfiguredTable: AWSDecodableShape {
        /// The columns within the underlying AWS Glue table that can be utilized within collaborations.
        public let allowedColumns: [String]
        /// The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod
        /// The types of analysis rules associated with this configured table. Valid values are `AGGREGATION` and `LIST`. Currently, only one analysis rule may be associated with a configured table.
        public let analysisRuleTypes: [ConfiguredTableAnalysisRuleType]
        /// The unique ARN for the configured table.
        public let arn: String
        /// The time the configured table was created.
        public let createTime: Date
        /// A description for the configured table.
        public let description: String?
        /// The unique ID for the configured table.
        public let id: String
        /// A name for the configured table.
        public let name: String
        /// The AWS Glue table that this configured table represents.
        public let tableReference: TableReference
        /// The time the configured table was last updated
        public let updateTime: Date

        public init(allowedColumns: [String], analysisMethod: AnalysisMethod, analysisRuleTypes: [ConfiguredTableAnalysisRuleType], arn: String, createTime: Date, description: String? = nil, id: String, name: String, tableReference: TableReference, updateTime: Date) {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.name = name
            self.tableReference = tableReference
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case allowedColumns = "allowedColumns"
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case tableReference = "tableReference"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAnalysisRule: AWSDecodableShape {
        /// The unique ARN for the configured table.
        public let configuredTableArn: String
        /// The unique ID for the configured table.
        public let configuredTableId: String
        /// The time the configured table analysis rule was created.
        public let createTime: Date
        /// The policy that controls SQL query rules.
        public let policy: ConfiguredTableAnalysisRulePolicy
        /// The type of configured table analysis rule. Valid values are `AGGREGATION` and `LIST`.
        public let type: ConfiguredTableAnalysisRuleType
        /// The time the configured table analysis rule was last updated.
        public let updateTime: Date

        public init(configuredTableArn: String, configuredTableId: String, createTime: Date, policy: ConfiguredTableAnalysisRulePolicy, type: ConfiguredTableAnalysisRuleType, updateTime: Date) {
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableArn = "configuredTableArn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case policy = "policy"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAssociation: AWSDecodableShape {
        /// The unique ARN for the configured table association.
        public let arn: String
        /// The unique ARN for the configured table that the association refers to.
        public let configuredTableArn: String
        /// The unique ID for the configured table that the association refers to.
        public let configuredTableId: String
        /// The time the configured table association was created.
        public let createTime: Date
        /// A description of the configured table association.
        public let description: String?
        /// The unique ID for the configured table association.
        public let id: String
        /// The unique ARN for the membership this configured table association belongs to.
        public let membershipArn: String
        /// The unique ID for the membership this configured table association belongs to.
        public let membershipId: String
        /// The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.
        public let name: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String
        /// The time the configured table association was last updated.
        public let updateTime: Date

        public init(arn: String, configuredTableArn: String, configuredTableId: String, createTime: Date, description: String? = nil, id: String, membershipArn: String, membershipId: String, name: String, roleArn: String, updateTime: Date) {
            self.arn = arn
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.roleArn = roleArn
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case configuredTableArn = "configuredTableArn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case roleArn = "roleArn"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAssociationSummary: AWSDecodableShape {
        /// The unique ARN for the configured table association.
        public let arn: String
        /// The unique configured table ID that this configured table association refers to.
        public let configuredTableId: String
        /// The time the configured table association was created.
        public let createTime: Date
        /// The unique ID for the configured table association.
        public let id: String
        /// The unique ARN for the membership that the configured table association belongs to.
        public let membershipArn: String
        /// The unique ID for the membership that the configured table association belongs to.
        public let membershipId: String
        /// The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.
        public let name: String
        /// The time the configured table association was last updated.
        public let updateTime: Date

        public init(arn: String, configuredTableId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableSummary: AWSDecodableShape {
        /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod
        /// The types of analysis rules associated with this configured table.
        public let analysisRuleTypes: [ConfiguredTableAnalysisRuleType]
        /// The unique ARN of the configured table.
        public let arn: String
        /// The time the configured table was created.
        public let createTime: Date
        /// The unique ID of the configured table.
        public let id: String
        /// The name of the configured table.
        public let name: String
        /// The time the configured table was last updated.
        public let updateTime: Date

        public init(analysisMethod: AnalysisMethod, analysisRuleTypes: [ConfiguredTableAnalysisRuleType], arn: String, createTime: Date, id: String, name: String, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case createTime = "createTime"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CreateCollaborationInput: AWSEncodableShape {
        /// The display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The abilities granted to the collaboration creator.
        public let creatorMemberAbilities: [MemberAbility]
        /// The settings for client-side encryption with Cryptographic Computing for Clean Rooms.
        public let dataEncryptionMetadata: DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public let description: String
        /// A list of initial members, not including the creator. This list is immutable.
        public let members: [MemberSpecification]
        /// The display name for a collaboration.
        public let name: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        public let queryLogStatus: CollaborationQueryLogStatus
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(creatorDisplayName: String, creatorMemberAbilities: [MemberAbility], dataEncryptionMetadata: DataEncryptionMetadata? = nil, description: String, members: [MemberSpecification], name: String, queryLogStatus: CollaborationQueryLogStatus, tags: [String: String]? = nil) {
            self.creatorDisplayName = creatorDisplayName
            self.creatorMemberAbilities = creatorMemberAbilities
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.members = members
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, max: 100)
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, min: 1)
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.members.forEach {
                try $0.validate(name: "\(name).members[]")
            }
            try self.validate(self.members, name: "members", parent: name, max: 9)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case creatorDisplayName = "creatorDisplayName"
            case creatorMemberAbilities = "creatorMemberAbilities"
            case dataEncryptionMetadata = "dataEncryptionMetadata"
            case description = "description"
            case members = "members"
            case name = "name"
            case queryLogStatus = "queryLogStatus"
            case tags = "tags"
        }
    }

    public struct CreateCollaborationOutput: AWSDecodableShape {
        /// The entire created collaboration object.
        public let collaboration: Collaboration

        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct CreateConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The entire created configured table analysis rule object.
        public let analysisRulePolicy: ConfiguredTableAnalysisRulePolicy
        /// The type of analysis rule. Valid values are AGGREGATION and LIST.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The identifier for the configured table to create the analysis rule for. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRulePolicy: ConfiguredTableAnalysisRulePolicy, analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            try container.encode(self.analysisRuleType, forKey: .analysisRuleType)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
            case analysisRuleType = "analysisRuleType"
        }
    }

    public struct CreateConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire created analysis rule.
        public let analysisRule: ConfiguredTableAnalysisRule

        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct CreateConfiguredTableAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured table to be associated to. Currently accepts a configured table ID.
        public let configuredTableIdentifier: String
        /// A description for the configured table association.
        public let description: String?
        /// A unique identifier for one of your memberships for a collaboration. The configured table is associated to the collaboration that this membership belongs to. Currently accepts a membership ID.
        public let membershipIdentifier: String
        /// The name of the configured table association. This name is used to query the underlying configured table.
        public let name: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(configuredTableIdentifier: String, description: String? = nil, membershipIdentifier: String, name: String, roleArn: String, tags: [String: String]? = nil) {
            self.configuredTableIdentifier = configuredTableIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configuredTableIdentifier, forKey: .configuredTableIdentifier)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=,./@-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableIdentifier = "configuredTableIdentifier"
            case description = "description"
            case name = "name"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire configured table association object.
        public let configuredTableAssociation: ConfiguredTableAssociation

        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct CreateConfiguredTableInput: AWSEncodableShape {
        /// The columns of the underlying table that can be used by collaborations or analysis rules.
        public let allowedColumns: [String]
        /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod
        /// A description for the configured table.
        public let description: String?
        /// The name of the configured table.
        public let name: String
        /// A reference to the AWS Glue table being configured.
        public let tableReference: TableReference
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(allowedColumns: [String], analysisMethod: AnalysisMethod, description: String? = nil, name: String, tableReference: TableReference, tags: [String: String]? = nil) {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.description = description
            self.name = name
            self.tableReference = tableReference
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allowedColumns.forEach {
                try validate($0, name: "allowedColumns[]", parent: name, max: 128)
                try validate($0, name: "allowedColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.validate(self.allowedColumns, name: "allowedColumns", parent: name, max: 100)
            try self.validate(self.allowedColumns, name: "allowedColumns", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tableReference.validate(name: "\(name).tableReference")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedColumns = "allowedColumns"
            case analysisMethod = "analysisMethod"
            case description = "description"
            case name = "name"
            case tableReference = "tableReference"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredTableOutput: AWSDecodableShape {
        /// The created configured table.
        public let configuredTable: ConfiguredTable

        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct CreateMembershipInput: AWSEncodableShape {
        /// The unique ID for the associated collaboration.
        public let collaborationIdentifier: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        public let queryLogStatus: MembershipQueryLogStatus
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(collaborationIdentifier: String, queryLogStatus: MembershipQueryLogStatus, tags: [String: String]? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.queryLogStatus = queryLogStatus
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationIdentifier = "collaborationIdentifier"
            case queryLogStatus = "queryLogStatus"
            case tags = "tags"
        }
    }

    public struct CreateMembershipOutput: AWSDecodableShape {
        /// The membership that was created.
        public let membership: Membership

        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct DataEncryptionMetadata: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether encrypted tables can contain cleartext data (true) or are to cryptographically process every column (false).
        public let allowCleartext: Bool
        /// Indicates whether Fingerprint columns can contain duplicate entries (true) or are to contain only non-repeated values (false).
        public let allowDuplicates: Bool
        /// Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (true) or can only be joined on Fingerprint columns of the same name (false).
        public let allowJoinsOnColumnsWithDifferentNames: Bool
        /// Indicates whether NULL values are to be copied as NULL to encrypted tables (true) or cryptographically processed (false).
        public let preserveNulls: Bool

        public init(allowCleartext: Bool, allowDuplicates: Bool, allowJoinsOnColumnsWithDifferentNames: Bool, preserveNulls: Bool) {
            self.allowCleartext = allowCleartext
            self.allowDuplicates = allowDuplicates
            self.allowJoinsOnColumnsWithDifferentNames = allowJoinsOnColumnsWithDifferentNames
            self.preserveNulls = preserveNulls
        }

        private enum CodingKeys: String, CodingKey {
            case allowCleartext = "allowCleartext"
            case allowDuplicates = "allowDuplicates"
            case allowJoinsOnColumnsWithDifferentNames = "allowJoinsOnColumnsWithDifferentNames"
            case preserveNulls = "preserveNulls"
        }
    }

    public struct DeleteCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String

        public init(collaborationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCollaborationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule type to be deleted. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique ID for the configured table association to be deleted. Currently accepts the configured table ID.
        public let configuredTableAssociationIdentifier: String
        /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        public init(configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableAssociationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableInput: AWSEncodableShape {
        /// The unique ID for the configured table to delete.
        public let configuredTableIdentifier: String

        public init(configuredTableIdentifier: String) {
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMemberInput: AWSEncodableShape {
        /// The account ID of the member to remove.
        public let accountId: String
        /// The unique identifier for the associated collaboration.
        public let collaborationIdentifier: String

        public init(accountId: String, collaborationIdentifier: String) {
            self.accountId = accountId
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemberOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMembershipInput: AWSEncodableShape {
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        public init(membershipIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMembershipOutput: AWSDecodableShape {
        public init() {}
    }

    public struct GetCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String

        public init(collaborationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationOutput: AWSDecodableShape {
        /// The entire collaboration for this identifier.
        public let collaboration: Collaboration

        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct GetConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule to be retrieved. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table to retrieve. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire analysis rule output.
        public let analysisRule: ConfiguredTableAnalysisRule

        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct GetConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique ID for the configured table association to retrieve. Currently accepts the configured table ID.
        public let configuredTableAssociationIdentifier: String
        /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        public init(configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire configured table association object.
        public let configuredTableAssociation: ConfiguredTableAssociation

        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct GetConfiguredTableInput: AWSEncodableShape {
        /// The unique ID for the configured table to retrieve.
        public let configuredTableIdentifier: String

        public init(configuredTableIdentifier: String) {
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableOutput: AWSDecodableShape {
        /// The retrieved configured table.
        public let configuredTable: ConfiguredTable

        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct GetMembershipInput: AWSEncodableShape {
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        public init(membershipIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMembershipOutput: AWSDecodableShape {
        /// The membership retrieved for the provided identifier.
        public let membership: Membership

        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct GetProtectedQueryInput: AWSEncodableShape {
        /// The identifier for a membership in a protected query instance.
        public let membershipIdentifier: String
        /// The identifier for a protected query instance.
        public let protectedQueryIdentifier: String

        public init(membershipIdentifier: String, protectedQueryIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedQueryIdentifier = protectedQueryIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedQueryIdentifier, key: "protectedQueryIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, max: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, min: 1)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProtectedQueryOutput: AWSDecodableShape {
        /// The query processing metadata.
        public let protectedQuery: ProtectedQuery

        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct GetSchemaAnalysisRuleInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The name of the schema to retrieve the analysis rule for.
        public let name: String
        /// The type of the schema analysis rule to retrieve. Schema analysis rules are uniquely identified by a combination of the collaboration, the schema name, and their type.
        public let type: AnalysisRuleType

        public init(collaborationIdentifier: String, name: String, type: AnalysisRuleType) {
            self.collaborationIdentifier = collaborationIdentifier
            self.name = name
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.name, key: "name")
            request.encodePath(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaAnalysisRuleOutput: AWSDecodableShape {
        /// A specification about how data from the configured table can be used.
        public let analysisRule: AnalysisRule

        public init(analysisRule: AnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct GetSchemaInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The name of the relation to retrieve the schema for.
        public let name: String

        public init(collaborationIdentifier: String, name: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaOutput: AWSDecodableShape {
        /// The entire schema object.
        public let schema: Schema

        public init(schema: Schema) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct GlueTableReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database the AWS Glue table belongs to.
        public let databaseName: String
        /// The name of the AWS Glue table.
        public let tableName: String

        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 128)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case tableName = "tableName"
        }
    }

    public struct ListCollaborationsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The caller's status in a collaboration.
        public let memberStatus: FilterableMemberStatus?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, memberStatus: FilterableMemberStatus? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.memberStatus = memberStatus
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.memberStatus, key: "memberStatus")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationsOutput: AWSDecodableShape {
        /// The list of collaborations.
        public let collaborationList: [CollaborationSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationList: [CollaborationSummary], nextToken: String? = nil) {
            self.collaborationList = collaborationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationList = "collaborationList"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredTableAssociationsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// A unique identifier for the membership to list configured table associations for. Currently accepts the membership ID.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredTableAssociationsOutput: AWSDecodableShape {
        /// The retrieved list of configured table associations.
        public let configuredTableAssociationSummaries: [ConfiguredTableAssociationSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(configuredTableAssociationSummaries: [ConfiguredTableAssociationSummary], nextToken: String? = nil) {
            self.configuredTableAssociationSummaries = configuredTableAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociationSummaries = "configuredTableAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredTablesInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredTablesOutput: AWSDecodableShape {
        /// The configured tables listed by the request.
        public let configuredTableSummaries: [ConfiguredTableSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(configuredTableSummaries: [ConfiguredTableSummary], nextToken: String? = nil) {
            self.configuredTableSummaries = configuredTableSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableSummaries = "configuredTableSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembersInput: AWSEncodableShape {
        /// The identifier of the collaboration in which the members are listed.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersOutput: AWSDecodableShape {
        /// The list of members returned by the ListMembers operation.
        public let memberSummaries: [MemberSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(memberSummaries: [MemberSummary], nextToken: String? = nil) {
            self.memberSummaries = memberSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memberSummaries = "memberSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembershipsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// A filter which will return only memberships in the specified status.
        public let status: MembershipStatus?

        public init(maxResults: Int? = nil, nextToken: String? = nil, status: MembershipStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembershipsOutput: AWSDecodableShape {
        /// The list of memberships returned from the ListMemberships operation.
        public let membershipSummaries: [MembershipSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(membershipSummaries: [MembershipSummary], nextToken: String? = nil) {
            self.membershipSummaries = membershipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case membershipSummaries = "membershipSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListProtectedQueriesInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service can return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The identifier for the membership in the collaboration.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// A filter on the status of the protected query.
        public let status: ProtectedQueryStatus?

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil, status: ProtectedQueryStatus? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProtectedQueriesOutput: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// A list of protected queries.
        public let protectedQueries: [ProtectedQuerySummary]

        public init(nextToken: String? = nil, protectedQueries: [ProtectedQuerySummary]) {
            self.nextToken = nextToken
            self.protectedQueries = protectedQueries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case protectedQueries = "protectedQueries"
        }
    }

    public struct ListSchemasInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// If present, filter schemas by schema type. The only valid schema type is currently `TABLE`.
        public let schemaType: SchemaType?

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, schemaType: SchemaType? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.schemaType = schemaType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.schemaType, key: "schemaType")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemasOutput: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// The retrieved list of schemas.
        public let schemaSummaries: [SchemaSummary]

        public init(nextToken: String? = nil, schemaSummaries: [SchemaSummary]) {
            self.nextToken = nextToken
            self.schemaSummaries = schemaSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemaSummaries = "schemaSummaries"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// A map of objects specifying each key name and value.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MemberSpecification: AWSEncodableShape {
        /// The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.
        public let accountId: String
        /// The member's display name.
        public let displayName: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]

        public init(accountId: String, displayName: String, memberAbilities: [MemberAbility]) {
            self.accountId = accountId
            self.displayName = displayName
            self.memberAbilities = memberAbilities
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case displayName = "displayName"
            case memberAbilities = "memberAbilities"
        }
    }

    public struct MemberSummary: AWSDecodableShape {
        /// The abilities granted to the collaboration member.
        public let abilities: [MemberAbility]
        /// The identifier used to reference members of the collaboration. Currently only supports AWS Account ID.
        public let accountId: String
        /// The time when the member was created.
        public let createTime: Date
        /// The member's display name.
        public let displayName: String
        /// The unique ARN for the member's associated membership, if present.
        public let membershipArn: String?
        /// The unique ID for the member's associated membership, if present.
        public let membershipId: String?
        /// The status of the member. Valid values are `INVITED`, `ACTIVE`, `LEFT`, and `REMOVED`.
        public let status: MemberStatus
        /// The time the member metadata was last updated.
        public let updateTime: Date

        public init(abilities: [MemberAbility], accountId: String, createTime: Date, displayName: String, membershipArn: String? = nil, membershipId: String? = nil, status: MemberStatus, updateTime: Date) {
            self.abilities = abilities
            self.accountId = accountId
            self.createTime = createTime
            self.displayName = displayName
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case abilities = "abilities"
            case accountId = "accountId"
            case createTime = "createTime"
            case displayName = "displayName"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct Membership: AWSDecodableShape {
        /// The unique ARN for the membership.
        public let arn: String
        /// The unique ARN for the membership's associated collaboration.
        public let collaborationArn: String
        /// The identifier used to reference members of the collaboration. Currently only supports AWS account ID.
        public let collaborationCreatorAccountId: String
        /// The display name of the collaboration creator.
        public let collaborationCreatorDisplayName: String
        /// The unique ID for the membership's collaboration.
        public let collaborationId: String
        /// The name of the membership's collaboration.
        public let collaborationName: String
        /// The time when the membership was created.
        public let createTime: Date
        /// The unique ID of the membership.
        public let id: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        public let queryLogStatus: MembershipQueryLogStatus
        /// The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.
        public let status: MembershipStatus
        /// The time the membership metadata was last updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationCreatorAccountId: String, collaborationCreatorDisplayName: String, collaborationId: String, collaborationName: String, createTime: Date, id: String, memberAbilities: [MemberAbility], queryLogStatus: MembershipQueryLogStatus, status: MembershipStatus, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.id = id
            self.memberAbilities = memberAbilities
            self.queryLogStatus = queryLogStatus
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationCreatorAccountId = "collaborationCreatorAccountId"
            case collaborationCreatorDisplayName = "collaborationCreatorDisplayName"
            case collaborationId = "collaborationId"
            case collaborationName = "collaborationName"
            case createTime = "createTime"
            case id = "id"
            case memberAbilities = "memberAbilities"
            case queryLogStatus = "queryLogStatus"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct MembershipSummary: AWSDecodableShape {
        /// The unique ARN for the membership.
        public let arn: String
        /// The unique ARN for the membership's associated collaboration.
        public let collaborationArn: String
        /// The identifier of the AWS principal that created the collaboration. Currently only supports AWS account ID.
        public let collaborationCreatorAccountId: String
        /// The display name of the collaboration creator.
        public let collaborationCreatorDisplayName: String
        /// The unique ID for the membership's collaboration.
        public let collaborationId: String
        /// The name for the membership's collaboration.
        public let collaborationName: String
        /// The time when the membership was created.
        public let createTime: Date
        /// The unique ID for the membership's collaboration.
        public let id: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// The status of the membership. Valid values are `ACTIVE`, `REMOVED`, and `COLLABORATION_DELETED`.
        public let status: MembershipStatus
        /// The time the membership metadata was last updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationCreatorAccountId: String, collaborationCreatorDisplayName: String, collaborationId: String, collaborationName: String, createTime: Date, id: String, memberAbilities: [MemberAbility], status: MembershipStatus, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.id = id
            self.memberAbilities = memberAbilities
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationCreatorAccountId = "collaborationCreatorAccountId"
            case collaborationCreatorDisplayName = "collaborationCreatorDisplayName"
            case collaborationId = "collaborationId"
            case collaborationName = "collaborationName"
            case createTime = "createTime"
            case id = "id"
            case memberAbilities = "memberAbilities"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct ProtectedQuery: AWSDecodableShape {
        /// The time at which the protected query was created.
        public let createTime: Date
        /// An error thrown by the protected query.
        public let error: ProtectedQueryError?
        /// The identifier for a protected query instance.
        public let id: String
        /// The ARN of the membership.
        public let membershipArn: String
        /// The identifier for the membership.
        public let membershipId: String
        /// The result of the protected query.
        public let result: ProtectedQueryResult?
        /// Contains any details needed to write the query results.
        public let resultConfiguration: ProtectedQueryResultConfiguration
        /// The protected query SQL parameters.
        public let sqlParameters: ProtectedQuerySQLParameters
        /// Statistics about protected query execution.
        public let statistics: ProtectedQueryStatistics?
        /// The status of the query.
        public let status: ProtectedQueryStatus

        public init(createTime: Date, error: ProtectedQueryError? = nil, id: String, membershipArn: String, membershipId: String, result: ProtectedQueryResult? = nil, resultConfiguration: ProtectedQueryResultConfiguration, sqlParameters: ProtectedQuerySQLParameters, statistics: ProtectedQueryStatistics? = nil, status: ProtectedQueryStatus) {
            self.createTime = createTime
            self.error = error
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.result = result
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.statistics = statistics
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case error = "error"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case result = "result"
            case resultConfiguration = "resultConfiguration"
            case sqlParameters = "sqlParameters"
            case statistics = "statistics"
            case status = "status"
        }
    }

    public struct ProtectedQueryError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// A description of why the query failed.
        public let message: String

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ProtectedQueryResult: AWSDecodableShape {
        /// The output of the protected query.
        public let output: ProtectedQueryOutput

        public init(output: ProtectedQueryOutput) {
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
        }
    }

    public struct ProtectedQueryResultConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for protected query results.
        public let outputConfiguration: ProtectedQueryOutputConfiguration

        public init(outputConfiguration: ProtectedQueryOutputConfiguration) {
            self.outputConfiguration = outputConfiguration
        }

        public func validate(name: String) throws {
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
        }
    }

    public struct ProtectedQueryS3Output: AWSDecodableShape {
        /// The S3 location of the result.
        public let location: String

        public init(location: String) {
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
        }
    }

    public struct ProtectedQueryS3OutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket to unload the protected query results.
        public let bucket: String
        /// The S3 prefix to unload the protected query results.
        public let keyPrefix: String?
        /// Intended file format of the result.
        public let resultFormat: ResultFormat

        public init(bucket: String, keyPrefix: String? = nil, resultFormat: ResultFormat) {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.resultFormat = resultFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, pattern: "^[\\w!.*/-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case keyPrefix = "keyPrefix"
            case resultFormat = "resultFormat"
        }
    }

    public struct ProtectedQuerySQLParameters: AWSEncodableShape & AWSDecodableShape {
        /// The query string to be submitted.
        public let queryString: String

        public init(queryString: String) {
            self.queryString = queryString
        }

        private enum CodingKeys: String, CodingKey {
            case queryString = "queryString"
        }
    }

    public struct ProtectedQueryStatistics: AWSDecodableShape {
        /// The duration of the Protected Query, from creation until query completion.
        public let totalDurationInMillis: Int64?

        public init(totalDurationInMillis: Int64? = nil) {
            self.totalDurationInMillis = totalDurationInMillis
        }

        private enum CodingKeys: String, CodingKey {
            case totalDurationInMillis = "totalDurationInMillis"
        }
    }

    public struct ProtectedQuerySummary: AWSDecodableShape {
        /// The time the protected query was created.
        public let createTime: Date
        /// The unique ID of the protected query.
        public let id: String
        /// The unique ARN for the membership that initiated the protected query.
        public let membershipArn: String
        /// The unique ID for the membership that initiated the protected query.
        public let membershipId: String
        /// The status of the protected query. Value values are `SUBMITTED`, `STARTED`, `CANCELLED`, `CANCELLING`, `FAILED`, `SUCCESS`, `TIMED_OUT`.
        public let status: ProtectedQueryStatus

        public init(createTime: Date, id: String, membershipArn: String, membershipId: String, status: ProtectedQueryStatus) {
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case status = "status"
        }
    }

    public struct Schema: AWSDecodableShape {
        /// The analysis method for the schema. The only valid value is currently DIRECT_QUERY.
        public let analysisMethod: AnalysisMethod?
        /// The analysis rule types associated with the schema. Valued values are LIST and AGGREGATION. Currently, only one entry is present.
        public let analysisRuleTypes: [AnalysisRuleType]
        /// The unique ARN for the collaboration that the schema belongs to.
        public let collaborationArn: String
        /// The unique ID for the collaboration that the schema belongs to.
        public let collaborationId: String
        /// The columns for the relation this schema represents.
        public let columns: [Column]
        /// The time the schema was created.
        public let createTime: Date
        /// The unique account ID for the AWS account that owns the schema.
        public let creatorAccountId: String
        /// A description for the schema.
        public let description: String
        /// A name for the schema. The schema relation is referred to by this name when queried by a protected query.
        public let name: String
        /// The partition keys for the dataset underlying this schema.
        public let partitionKeys: [Column]
        /// The type of schema. The only valid value is currently `TABLE`.
        public let type: SchemaType
        /// The time the schema was last updated.
        public let updateTime: Date

        public init(analysisMethod: AnalysisMethod? = nil, analysisRuleTypes: [AnalysisRuleType], collaborationArn: String, collaborationId: String, columns: [Column], createTime: Date, creatorAccountId: String, description: String, name: String, partitionKeys: [Column], type: SchemaType, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.columns = columns
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.name = name
            self.partitionKeys = partitionKeys
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case columns = "columns"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case name = "name"
            case partitionKeys = "partitionKeys"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct SchemaSummary: AWSDecodableShape {
        /// The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod?
        /// The types of analysis rules that are associated with this schema object.
        public let analysisRuleTypes: [AnalysisRuleType]
        /// The unique ARN for the collaboration that the schema belongs to.
        public let collaborationArn: String
        /// The unique ID for the collaboration that the schema belongs to.
        public let collaborationId: String
        /// The time the schema object was created.
        public let createTime: Date
        /// The unique account ID for the AWS account that owns the schema.
        public let creatorAccountId: String
        /// The name for the schema object.
        public let name: String
        /// The type of schema object. The only valid schema type is currently `TABLE`.
        public let type: SchemaType
        /// The time the schema object was last updated.
        public let updateTime: Date

        public init(analysisMethod: AnalysisMethod? = nil, analysisRuleTypes: [AnalysisRuleType], collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, name: String, type: SchemaType, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.name = name
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case name = "name"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct StartProtectedQueryInput: AWSEncodableShape {
        /// A unique identifier for the membership to run this query against. Currently accepts a membership ID.
        public let membershipIdentifier: String
        /// The details needed to write the query results.
        public let resultConfiguration: ProtectedQueryResultConfiguration
        /// The protected SQL query parameters.
        public let sqlParameters: ProtectedQuerySQLParameters
        /// The type of the protected query to be started.
        public let type: ProtectedQueryType

        public init(membershipIdentifier: String, resultConfiguration: ProtectedQueryResultConfiguration, sqlParameters: ProtectedQuerySQLParameters, type: ProtectedQueryType) {
            self.membershipIdentifier = membershipIdentifier
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.resultConfiguration, forKey: .resultConfiguration)
            try container.encode(self.sqlParameters, forKey: .sqlParameters)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.resultConfiguration.validate(name: "\(name).resultConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case resultConfiguration = "resultConfiguration"
            case sqlParameters = "sqlParameters"
            case type = "type"
        }
    }

    public struct StartProtectedQueryOutput: AWSDecodableShape {
        /// The protected query.
        public let protectedQuery: ProtectedQuery

        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to tag.
        public let resourceArn: String
        /// A map of objects specifying each key name and value.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:).{1,128}$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
        public let resourceArn: String
        /// A list of key names of tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:).{1,128}$")
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String
        /// A description of the collaboration.
        public let description: String?
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String?

        public init(collaborationIdentifier: String, description: String? = nil, name: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateCollaborationOutput: AWSDecodableShape {
        /// The entire collaboration that has been updated.
        public let collaboration: Collaboration

        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct UpdateConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The new analysis rule policy for the configured table analysis rule.
        public let analysisRulePolicy: ConfiguredTableAnalysisRulePolicy
        /// The analysis rule type to be updated. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRulePolicy: ConfiguredTableAnalysisRulePolicy, analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
        }
    }

    public struct UpdateConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire updated analysis rule.
        public let analysisRule: ConfiguredTableAnalysisRule

        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct UpdateConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique identifier for the configured table association to update. Currently accepts the configured table association ID.
        public let configuredTableAssociationIdentifier: String
        /// A new description for the configured table association.
        public let description: String?
        /// The unique ID for the membership that the configured table association belongs to.
        public let membershipIdentifier: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String?

        public init(configuredTableAssociationIdentifier: String, description: String? = nil, membershipIdentifier: String, roleArn: String? = nil) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=,./@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire updated configured table association.
        public let configuredTableAssociation: ConfiguredTableAssociation

        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct UpdateConfiguredTableInput: AWSEncodableShape {
        /// The identifier for the configured table to update. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String
        /// A new description for the configured table.
        public let description: String?
        /// A new name for the configured table.
        public let name: String?

        public init(configuredTableIdentifier: String, description: String? = nil, name: String? = nil) {
            self.configuredTableIdentifier = configuredTableIdentifier
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateConfiguredTableOutput: AWSDecodableShape {
        /// The updated configured table.
        public let configuredTable: ConfiguredTable

        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct UpdateMembershipInput: AWSEncodableShape {
        /// The unique identifier of the membership.
        public let membershipIdentifier: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        public let queryLogStatus: MembershipQueryLogStatus?

        public init(membershipIdentifier: String, queryLogStatus: MembershipQueryLogStatus? = nil) {
            self.membershipIdentifier = membershipIdentifier
            self.queryLogStatus = queryLogStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.queryLogStatus, forKey: .queryLogStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case queryLogStatus = "queryLogStatus"
        }
    }

    public struct UpdateMembershipOutput: AWSDecodableShape {
        public let membership: Membership

        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct UpdateProtectedQueryInput: AWSEncodableShape {
        /// The identifier for a member of a protected query instance.
        public let membershipIdentifier: String
        /// The identifier for a protected query instance.
        public let protectedQueryIdentifier: String
        /// The target status of a query. Used to update the execution status of a currently running query.
        public let targetStatus: TargetProtectedQueryStatus

        public init(membershipIdentifier: String, protectedQueryIdentifier: String, targetStatus: TargetProtectedQueryStatus) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedQueryIdentifier = protectedQueryIdentifier
            self.targetStatus = targetStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedQueryIdentifier, key: "protectedQueryIdentifier")
            try container.encode(self.targetStatus, forKey: .targetStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, max: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, min: 1)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, pattern: "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}")
        }

        private enum CodingKeys: String, CodingKey {
            case targetStatus = "targetStatus"
        }
    }

    public struct UpdateProtectedQueryOutput: AWSDecodableShape {
        /// The protected query output.
        public let protectedQuery: ProtectedQuery

        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct AnalysisRulePolicy: AWSDecodableShape {
        /// Controls on the query specifications that can be run on configured table..
        public let v1: AnalysisRulePolicyV1?

        public init(v1: AnalysisRulePolicyV1? = nil) {
            self.v1 = v1
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct ConfiguredTableAnalysisRulePolicy: AWSEncodableShape & AWSDecodableShape {
        /// Controls on the query specifications that can be run on a configured table.
        public let v1: ConfiguredTableAnalysisRulePolicyV1?

        public init(v1: ConfiguredTableAnalysisRulePolicyV1? = nil) {
            self.v1 = v1
        }

        public func validate(name: String) throws {
            try self.v1?.validate(name: "\(name).v1")
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct ProtectedQueryOutput: AWSDecodableShape {
        /// If present, the output for a protected query with an `S3` output type.
        public let s3: ProtectedQueryS3Output?

        public init(s3: ProtectedQueryS3Output? = nil) {
            self.s3 = s3
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct ProtectedQueryOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Required configuration for a protected query with an `S3` output type.
        public let s3: ProtectedQueryS3OutputConfiguration?

        public init(s3: ProtectedQueryS3OutputConfiguration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct TableReference: AWSEncodableShape & AWSDecodableShape {
        /// If present, a reference to the AWS Glue table referred to by this table reference.
        public let glue: GlueTableReference?

        public init(glue: GlueTableReference? = nil) {
            self.glue = glue
        }

        public func validate(name: String) throws {
            try self.glue?.validate(name: "\(name).glue")
        }

        private enum CodingKeys: String, CodingKey {
            case glue = "glue"
        }
    }
}

// MARK: - Errors

/// Error enum for CleanRooms
public struct CleanRoomsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CleanRooms
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Caller does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request denied because service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the specified constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension CleanRoomsErrorType: Equatable {
    public static func == (lhs: CleanRoomsErrorType, rhs: CleanRoomsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CleanRoomsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
