//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CleanRooms {
    // MARK: Enums

    public enum AggregateFunctionName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "AVG"
        case count = "COUNT"
        case countDistinct = "COUNT_DISTINCT"
        case sum = "SUM"
        case sumDistinct = "SUM_DISTINCT"
        public var description: String { return self.rawValue }
    }

    public enum AggregationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case countDistinct = "COUNT_DISTINCT"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sql = "SQL"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directQuery = "DIRECT_QUERY"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisRuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aggregation = "AGGREGATION"
        case custom = "CUSTOM"
        case list = "LIST"
        public var description: String { return self.rawValue }
    }

    public enum CollaborationQueryLogStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ConfiguredTableAnalysisRuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aggregation = "AGGREGATION"
        case custom = "CUSTOM"
        case list = "LIST"
        public var description: String { return self.rawValue }
    }

    public enum DifferentialPrivacyAggregationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "AVG"
        case count = "COUNT"
        case countDistinct = "COUNT_DISTINCT"
        case stddev = "STDDEV"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum FilterableMemberStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case invited = "INVITED"
        public var description: String { return self.rawValue }
    }

    public enum JoinOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum JoinRequiredOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queryRunner = "QUERY_RUNNER"
        public var description: String { return self.rawValue }
    }

    public enum MemberAbility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canQuery = "CAN_QUERY"
        case canReceiveResults = "CAN_RECEIVE_RESULTS"
        public var description: String { return self.rawValue }
    }

    public enum MemberStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case invited = "INVITED"
        case left = "LEFT"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum MembershipQueryLogStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MembershipStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case collaborationDeleted = "COLLABORATION_DELETED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum ParameterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case boolean = "BOOLEAN"
        case char = "CHAR"
        case date = "DATE"
        case decimal = "DECIMAL"
        case doublePrecision = "DOUBLE_PRECISION"
        case integer = "INTEGER"
        case real = "REAL"
        case smallint = "SMALLINT"
        case time = "TIME"
        case timestamp = "TIMESTAMP"
        case timestamptz = "TIMESTAMPTZ"
        case timetz = "TIMETZ"
        case varbyte = "VARBYTE"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum PrivacyBudgetTemplateAutoRefresh: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case calendarMonth = "CALENDAR_MONTH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum PrivacyBudgetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case differentialPrivacy = "DIFFERENTIAL_PRIVACY"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedQueryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case failed = "FAILED"
        case started = "STARTED"
        case submitted = "SUBMITTED"
        case success = "SUCCESS"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedQueryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sql = "SQL"
        public var description: String { return self.rawValue }
    }

    public enum ResultFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum ScalarFunctions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case abs = "ABS"
        case cast = "CAST"
        case ceiling = "CEILING"
        case coalesce = "COALESCE"
        case convert = "CONVERT"
        case currentDate = "CURRENT_DATE"
        case dateadd = "DATEADD"
        case extract = "EXTRACT"
        case floor = "FLOOR"
        case getdate = "GETDATE"
        case ln = "LN"
        case log = "LOG"
        case lower = "LOWER"
        case round = "ROUND"
        case rtrim = "RTRIM"
        case sqrt = "SQRT"
        case substring = "SUBSTRING"
        case toChar = "TO_CHAR"
        case toDate = "TO_DATE"
        case toNumber = "TO_NUMBER"
        case toTimestamp = "TO_TIMESTAMP"
        case trim = "TRIM"
        case trunc = "TRUNC"
        case upper = "UPPER"
        public var description: String { return self.rawValue }
    }

    public enum SchemaConfiguration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case differentialPrivacy = "DIFFERENTIAL_PRIVACY"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notReady = "NOT_READY"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatusReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analysisProvidersNotConfigured = "ANALYSIS_PROVIDERS_NOT_CONFIGURED"
        case analysisRuleMissing = "ANALYSIS_RULE_MISSING"
        case analysisTemplatesNotConfigured = "ANALYSIS_TEMPLATES_NOT_CONFIGURED"
        case differentialPrivacyPolicyNotConfigured = "DIFFERENTIAL_PRIVACY_POLICY_NOT_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum SchemaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case table = "TABLE"
        public var description: String { return self.rawValue }
    }

    public enum TargetProtectedQueryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisRulePolicyV1: AWSDecodableShape, Sendable {
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(AnalysisRuleAggregation)
        /// Analysis rule type that enables custom SQL queries on a configured table.
        case custom(AnalysisRuleCustom)
        /// Analysis rule type that enables only list queries on a configured table.
        case list(AnalysisRuleList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(AnalysisRuleAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .custom:
                let value = try container.decode(AnalysisRuleCustom.self, forKey: .custom)
                self = .custom(value)
            case .list:
                let value = try container.decode(AnalysisRuleList.self, forKey: .list)
                self = .list(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case custom = "custom"
            case list = "list"
        }
    }

    public enum ConfiguredTableAnalysisRulePolicyV1: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(AnalysisRuleAggregation)
        case custom(AnalysisRuleCustom)
        /// Analysis rule type that enables only list queries on a configured table.
        case list(AnalysisRuleList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(AnalysisRuleAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .custom:
                let value = try container.decode(AnalysisRuleCustom.self, forKey: .custom)
                self = .custom(value)
            case .list:
                let value = try container.decode(AnalysisRuleList.self, forKey: .list)
                self = .list(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .aggregation(let value):
                try container.encode(value, forKey: .aggregation)
            case .custom(let value):
                try container.encode(value, forKey: .custom)
            case .list(let value):
                try container.encode(value, forKey: .list)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .aggregation(let value):
                try value.validate(name: "\(name).aggregation")
            case .custom(let value):
                try value.validate(name: "\(name).custom")
            case .list(let value):
                try value.validate(name: "\(name).list")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case custom = "custom"
            case list = "list"
        }
    }

    public enum ProtectedQueryOutput: AWSDecodableShape, Sendable {
        /// The list of member Amazon Web Services account(s) that received the results of the query.
        case memberList([ProtectedQuerySingleMemberOutput])
        /// If present, the output for a protected query with an `S3` output type.
        case s3(ProtectedQueryS3Output)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .memberList:
                let value = try container.decode([ProtectedQuerySingleMemberOutput].self, forKey: .memberList)
                self = .memberList(value)
            case .s3:
                let value = try container.decode(ProtectedQueryS3Output.self, forKey: .s3)
                self = .s3(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case memberList = "memberList"
            case s3 = "s3"
        }
    }

    // MARK: Shapes

    public struct AggregateColumn: AWSEncodableShape & AWSDecodableShape {
        /// Column names in configured table of aggregate columns.
        public let columnNames: [String]
        /// Aggregation function that can be applied to aggregate column in query.
        public let function: AggregateFunctionName

        public init(columnNames: [String], function: AggregateFunctionName) {
            self.columnNames = columnNames
            self.function = function
        }

        public func validate(name: String) throws {
            try self.columnNames.forEach {
                try validate($0, name: "columnNames[]", parent: name, max: 127)
                try validate($0, name: "columnNames[]", parent: name, min: 1)
                try validate($0, name: "columnNames[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "columnNames"
            case function = "function"
        }
    }

    public struct AggregationConstraint: AWSEncodableShape & AWSDecodableShape {
        /// Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.
        public let columnName: String
        /// The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.
        public let minimum: Int
        /// The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.
        public let type: AggregationType

        public init(columnName: String, minimum: Int, type: AggregationType) {
            self.columnName = columnName
            self.minimum = minimum
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 127)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case minimum = "minimum"
            case type = "type"
        }
    }

    public struct AnalysisParameter: AWSEncodableShape & AWSDecodableShape {
        /// Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        public let defaultValue: String?
        /// The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        public let name: String
        /// The type of parameter.
        public let type: ParameterType

        public init(defaultValue: String? = nil, name: String, type: ParameterType) {
            self.defaultValue = defaultValue
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 250)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case name = "name"
            case type = "type"
        }
    }

    public struct AnalysisRule: AWSDecodableShape {
        /// The unique ID for the associated collaboration.
        public let collaborationId: String
        /// The time the analysis rule was created.
        public let createTime: Date
        /// The name for the analysis rule.
        public let name: String
        /// A policy that describes the associated data usage limitations.
        public let policy: AnalysisRulePolicy
        /// The type of analysis rule.
        public let type: AnalysisRuleType
        /// The time the analysis rule was last updated.
        public let updateTime: Date

        public init(collaborationId: String, createTime: Date, name: String, policy: AnalysisRulePolicy, type: AnalysisRuleType, updateTime: Date) {
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.name = name
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case name = "name"
            case policy = "policy"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct AnalysisRuleAggregation: AWSEncodableShape & AWSDecodableShape {
        /// The columns that query runners are allowed to use in aggregation queries.
        public let aggregateColumns: [AggregateColumn]
        /// Which logical operators (if any) are to be used in an INNER JOIN match condition. Default is AND.
        public let allowedJoinOperators: [JoinOperator]?
        /// The columns that query runners are allowed to select, group by, or filter by.
        public let dimensionColumns: [String]
        /// Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.
        public let joinColumns: [String]
        /// Control that requires member who runs query to do a join with their configured table and/or other configured table in query.
        public let joinRequired: JoinRequiredOption?
        /// Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.
        public let outputConstraints: [AggregationConstraint]
        /// Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.
        public let scalarFunctions: [ScalarFunctions]

        public init(aggregateColumns: [AggregateColumn], allowedJoinOperators: [JoinOperator]? = nil, dimensionColumns: [String], joinColumns: [String], joinRequired: JoinRequiredOption? = nil, outputConstraints: [AggregationConstraint], scalarFunctions: [ScalarFunctions]) {
            self.aggregateColumns = aggregateColumns
            self.allowedJoinOperators = allowedJoinOperators
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.joinRequired = joinRequired
            self.outputConstraints = outputConstraints
            self.scalarFunctions = scalarFunctions
        }

        public func validate(name: String) throws {
            try self.aggregateColumns.forEach {
                try $0.validate(name: "\(name).aggregateColumns[]")
            }
            try self.validate(self.allowedJoinOperators, name: "allowedJoinOperators", parent: name, max: 2)
            try self.dimensionColumns.forEach {
                try validate($0, name: "dimensionColumns[]", parent: name, max: 127)
                try validate($0, name: "dimensionColumns[]", parent: name, min: 1)
                try validate($0, name: "dimensionColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.joinColumns.forEach {
                try validate($0, name: "joinColumns[]", parent: name, max: 127)
                try validate($0, name: "joinColumns[]", parent: name, min: 1)
                try validate($0, name: "joinColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.outputConstraints.forEach {
                try $0.validate(name: "\(name).outputConstraints[]")
            }
            try self.validate(self.outputConstraints, name: "outputConstraints", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateColumns = "aggregateColumns"
            case allowedJoinOperators = "allowedJoinOperators"
            case dimensionColumns = "dimensionColumns"
            case joinColumns = "joinColumns"
            case joinRequired = "joinRequired"
            case outputConstraints = "outputConstraints"
            case scalarFunctions = "scalarFunctions"
        }
    }

    public struct AnalysisRuleCustom: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of the analysis templates that are allowed by the custom analysis rule.
        public let allowedAnalyses: [String]
        /// The IDs of the Amazon Web Services accounts that are allowed to query by the custom analysis rule. Required when allowedAnalyses is ANY_QUERY.
        public let allowedAnalysisProviders: [String]?
        /// The differential privacy configuration.
        public let differentialPrivacy: DifferentialPrivacyConfiguration?

        public init(allowedAnalyses: [String], allowedAnalysisProviders: [String]? = nil, differentialPrivacy: DifferentialPrivacyConfiguration? = nil) {
            self.allowedAnalyses = allowedAnalyses
            self.allowedAnalysisProviders = allowedAnalysisProviders
            self.differentialPrivacy = differentialPrivacy
        }

        public func validate(name: String) throws {
            try self.allowedAnalyses.forEach {
                try validate($0, name: "allowedAnalyses[]", parent: name, max: 200)
                try validate($0, name: "allowedAnalyses[]", parent: name, pattern: "^(ANY_QUERY|arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+)$")
            }
            try self.allowedAnalysisProviders?.forEach {
                try validate($0, name: "allowedAnalysisProviders[]", parent: name, max: 12)
                try validate($0, name: "allowedAnalysisProviders[]", parent: name, min: 12)
                try validate($0, name: "allowedAnalysisProviders[]", parent: name, pattern: "^\\d+$")
            }
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAnalyses = "allowedAnalyses"
            case allowedAnalysisProviders = "allowedAnalysisProviders"
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct AnalysisRuleList: AWSEncodableShape & AWSDecodableShape {
        /// The logical operators (if any) that are to be used in an INNER JOIN match condition. Default is AND.
        public let allowedJoinOperators: [JoinOperator]?
        /// Columns that can be used to join a configured table with the table of the member who can query and other members' configured tables.
        public let joinColumns: [String]
        /// Columns that can be listed in the output.
        public let listColumns: [String]

        public init(allowedJoinOperators: [JoinOperator]? = nil, joinColumns: [String], listColumns: [String]) {
            self.allowedJoinOperators = allowedJoinOperators
            self.joinColumns = joinColumns
            self.listColumns = listColumns
        }

        public func validate(name: String) throws {
            try self.validate(self.allowedJoinOperators, name: "allowedJoinOperators", parent: name, max: 2)
            try self.joinColumns.forEach {
                try validate($0, name: "joinColumns[]", parent: name, max: 127)
                try validate($0, name: "joinColumns[]", parent: name, min: 1)
                try validate($0, name: "joinColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.listColumns.forEach {
                try validate($0, name: "listColumns[]", parent: name, max: 127)
                try validate($0, name: "listColumns[]", parent: name, min: 1)
                try validate($0, name: "listColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowedJoinOperators = "allowedJoinOperators"
            case joinColumns = "joinColumns"
            case listColumns = "listColumns"
        }
    }

    public struct AnalysisSchema: AWSDecodableShape {
        /// The tables referenced in the analysis schema.
        public let referencedTables: [String]?

        public init(referencedTables: [String]? = nil) {
            self.referencedTables = referencedTables
        }

        private enum CodingKeys: String, CodingKey {
            case referencedTables = "referencedTables"
        }
    }

    public struct AnalysisTemplate: AWSDecodableShape {
        /// The parameters of the analysis template.
        public let analysisParameters: [AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis template’s associated collaboration.
        public let collaborationArn: String
        /// The unique ID for the associated collaboration of the analysis template.
        public let collaborationId: String
        /// The time that the analysis template was created.
        public let createTime: Date
        /// The description of the analysis template.
        public let description: String?
        /// The format of the analysis template.
        public let format: AnalysisFormat
        /// The identifier for the analysis template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        public let membershipArn: String
        /// The identifier of a member who created the analysis template.
        public let membershipId: String
        /// The name of the analysis template.
        public let name: String
        /// The entire schema object.
        public let schema: AnalysisSchema
        /// The source of the analysis template.
        public let source: AnalysisSource
        /// The time that the analysis template was last updated.
        public let updateTime: Date

        public init(analysisParameters: [AnalysisParameter]? = nil, arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, format: AnalysisFormat, id: String, membershipArn: String, membershipId: String, name: String, schema: AnalysisSchema, source: AnalysisSource, updateTime: Date) {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.format = format
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.schema = schema
            self.source = source
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisParameters = "analysisParameters"
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case format = "format"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case schema = "schema"
            case source = "source"
            case updateTime = "updateTime"
        }
    }

    public struct AnalysisTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis template summary’s associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the analysis template summary belongs to. Currently accepts collaboration ID.
        public let collaborationId: String
        /// The time that the analysis template summary was created.
        public let createTime: Date
        /// The description of the analysis template.
        public let description: String?
        /// The identifier of the analysis template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// The name of the analysis template.
        public let name: String
        /// The time that the analysis template summary was last updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, id: String, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct BatchGetCollaborationAnalysisTemplateError: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// An error code for the error.
        public let code: String
        /// A description of why the call failed.
        public let message: String

        public init(arn: String, code: String, message: String) {
            self.arn = arn
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case code = "code"
            case message = "message"
        }
    }

    public struct BatchGetCollaborationAnalysisTemplateInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public let analysisTemplateArns: [String]
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String

        public init(analysisTemplateArns: [String], collaborationIdentifier: String) {
            self.analysisTemplateArns = analysisTemplateArns
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisTemplateArns, forKey: .analysisTemplateArns)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisTemplateArns.forEach {
                try validate($0, name: "analysisTemplateArns[]", parent: name, max: 200)
                try validate($0, name: "analysisTemplateArns[]", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+$")
            }
            try self.validate(self.analysisTemplateArns, name: "analysisTemplateArns", parent: name, max: 10)
            try self.validate(self.analysisTemplateArns, name: "analysisTemplateArns", parent: name, min: 1)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplateArns = "analysisTemplateArns"
        }
    }

    public struct BatchGetCollaborationAnalysisTemplateOutput: AWSDecodableShape {
        /// The retrieved list of analysis templates within a collaboration.
        public let collaborationAnalysisTemplates: [CollaborationAnalysisTemplate]
        /// Error reasons for collaboration analysis templates that could not be retrieved. One error is returned for every collaboration analysis template that could not be retrieved.
        public let errors: [BatchGetCollaborationAnalysisTemplateError]

        public init(collaborationAnalysisTemplates: [CollaborationAnalysisTemplate], errors: [BatchGetCollaborationAnalysisTemplateError]) {
            self.collaborationAnalysisTemplates = collaborationAnalysisTemplates
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationAnalysisTemplates = "collaborationAnalysisTemplates"
            case errors = "errors"
        }
    }

    public struct BatchGetSchemaAnalysisRuleError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// A description of why the call failed.
        public let message: String
        /// An error name for the error.
        public let name: String
        /// The analysis rule type.
        public let type: AnalysisRuleType

        public init(code: String, message: String, name: String, type: AnalysisRuleType) {
            self.code = code
            self.message = message
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
            case type = "type"
        }
    }

    public struct BatchGetSchemaAnalysisRuleInput: AWSEncodableShape {
        /// The unique identifier of the collaboration that contains the schema analysis rule.
        public let collaborationIdentifier: String
        /// The information that's necessary to retrieve a schema analysis rule.
        public let schemaAnalysisRuleRequests: [SchemaAnalysisRuleRequest]

        public init(collaborationIdentifier: String, schemaAnalysisRuleRequests: [SchemaAnalysisRuleRequest]) {
            self.collaborationIdentifier = collaborationIdentifier
            self.schemaAnalysisRuleRequests = schemaAnalysisRuleRequests
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encode(self.schemaAnalysisRuleRequests, forKey: .schemaAnalysisRuleRequests)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.schemaAnalysisRuleRequests.forEach {
                try $0.validate(name: "\(name).schemaAnalysisRuleRequests[]")
            }
            try self.validate(self.schemaAnalysisRuleRequests, name: "schemaAnalysisRuleRequests", parent: name, max: 25)
            try self.validate(self.schemaAnalysisRuleRequests, name: "schemaAnalysisRuleRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case schemaAnalysisRuleRequests = "schemaAnalysisRuleRequests"
        }
    }

    public struct BatchGetSchemaAnalysisRuleOutput: AWSDecodableShape {
        /// The retrieved list of analysis rules.
        public let analysisRules: [AnalysisRule]
        /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
        public let errors: [BatchGetSchemaAnalysisRuleError]

        public init(analysisRules: [AnalysisRule], errors: [BatchGetSchemaAnalysisRuleError]) {
            self.analysisRules = analysisRules
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRules = "analysisRules"
            case errors = "errors"
        }
    }

    public struct BatchGetSchemaError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// An error message for the error.
        public let message: String
        /// An error name for the error.
        public let name: String

        public init(code: String, message: String, name: String) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
        }
    }

    public struct BatchGetSchemaInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schemas belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String
        /// The names for the schema objects to retrieve.
        public let names: [String]

        public init(collaborationIdentifier: String, names: [String]) {
            self.collaborationIdentifier = collaborationIdentifier
            self.names = names
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encode(self.names, forKey: .names)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.names.forEach {
                try validate($0, name: "names[]", parent: name, max: 128)
                try validate($0, name: "names[]", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 25)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case names = "names"
        }
    }

    public struct BatchGetSchemaOutput: AWSDecodableShape {
        /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
        public let errors: [BatchGetSchemaError]
        /// The retrieved list of schemas.
        public let schemas: [Schema]

        public init(errors: [BatchGetSchemaError], schemas: [Schema]) {
            self.errors = errors
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case schemas = "schemas"
        }
    }

    public struct Collaboration: AWSDecodableShape {
        /// The unique ARN for the collaboration.
        public let arn: String
        /// The time when the collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// A display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The settings for client-side encryption for cryptographic computing.
        public let dataEncryptionMetadata: DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public let description: String?
        /// The unique ID for the collaboration.
        public let id: String
        /// The unique ARN for your membership within the collaboration.
        public let membershipArn: String?
        /// The unique ID for your membership within the collaboration.
        public let membershipId: String?
        /// The status of a member in a collaboration.
        public let memberStatus: MemberStatus
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        public let queryLogStatus: CollaborationQueryLogStatus
        /// The time the collaboration metadata was last updated.
        public let updateTime: Date

        public init(arn: String, createTime: Date, creatorAccountId: String, creatorDisplayName: String, dataEncryptionMetadata: DataEncryptionMetadata? = nil, description: String? = nil, id: String, membershipArn: String? = nil, membershipId: String? = nil, memberStatus: MemberStatus, name: String, queryLogStatus: CollaborationQueryLogStatus, updateTime: Date) {
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.memberStatus = memberStatus
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case creatorDisplayName = "creatorDisplayName"
            case dataEncryptionMetadata = "dataEncryptionMetadata"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case memberStatus = "memberStatus"
            case name = "name"
            case queryLogStatus = "queryLogStatus"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationAnalysisTemplate: AWSDecodableShape {
        /// The analysis parameters that have been specified in the analysis template.
        public let analysisParameters: [AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis template’s associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationId: String
        /// The time that the analysis template within a collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The description of the analysis template.
        public let description: String?
        /// The format of the analysis template in the collaboration.
        public let format: AnalysisFormat
        /// The identifier of the analysis template.
        public let id: String
        /// The name of the analysis template.
        public let name: String
        /// The entire schema object.
        public let schema: AnalysisSchema
        /// The source of the analysis template within a collaboration.
        public let source: AnalysisSource
        /// The time that the analysis template in the collaboration was last updated.
        public let updateTime: Date

        public init(analysisParameters: [AnalysisParameter]? = nil, arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, format: AnalysisFormat, id: String, name: String, schema: AnalysisSchema, source: AnalysisSource, updateTime: Date) {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.format = format
            self.id = id
            self.name = name
            self.schema = schema
            self.source = source
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisParameters = "analysisParameters"
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case format = "format"
            case id = "id"
            case name = "name"
            case schema = "schema"
            case source = "source"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationAnalysisTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis template’s associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationId: String
        /// The time that the summary of the analysis template in a collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The description of the analysis template.
        public let description: String?
        /// The identifier of the analysis template.
        public let id: String
        /// The name of the analysis template.
        public let name: String
        /// The time that the summary of the analysis template in the collaboration was last updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationConfiguredAudienceModelAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The unique ARN for the configured audience model's associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        public let collaborationId: String
        /// The Amazon Resource Name (ARN) of the configure audience model.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Only supports AWS account ID.
        public let creatorAccountId: String
        /// The description of the configured audience model association.
        public let description: String?
        /// The identifier of the configured audience model association.
        public let id: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, configuredAudienceModelArn: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationConfiguredAudienceModelAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The unique ARN for the configured audience model's associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        public let collaborationId: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Only supports AWS account ID.
        public let creatorAccountId: String
        /// The description of the configured audience model association.
        public let description: String?
        /// The identifier of the configured audience model association.
        public let id: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationPrivacyBudgetSummary: AWSDecodableShape {
        /// The includes epsilon provided and utility in terms of aggregations.
        public let budget: PrivacyBudget
        /// The ARN of the collaboration that includes this privacy budget.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that includes this privacy budget.
        public let collaborationId: String
        /// The time at which the privacy budget was created.
        public let createTime: Date
        /// The unique identifier of the account that created this privacy budget.
        public let creatorAccountId: String
        /// The unique identifier of the collaboration privacy budget.
        public let id: String
        /// The ARN of the collaboration privacy budget template.
        public let privacyBudgetTemplateArn: String
        /// The unique identifier of the collaboration privacy budget template.
        public let privacyBudgetTemplateId: String
        /// The type of privacy budget template.
        public let type: PrivacyBudgetType
        /// The most recent time at which the privacy budget was updated.
        public let updateTime: Date

        public init(budget: PrivacyBudget, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, id: String, privacyBudgetTemplateArn: String, privacyBudgetTemplateId: String, type: PrivacyBudgetType, updateTime: Date) {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case budget = "budget"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case id = "id"
            case privacyBudgetTemplateArn = "privacyBudgetTemplateArn"
            case privacyBudgetTemplateId = "privacyBudgetTemplateId"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationPrivacyBudgetTemplate: AWSDecodableShape {
        /// The ARN of the collaboration privacy budget template.
        public let arn: String
        /// How often the privacy budget refreshes.  If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        public let autoRefresh: PrivacyBudgetTemplateAutoRefresh
        /// The ARN of the collaboration that includes this collaboration privacy budget template.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that includes this collaboration privacy budget template.
        public let collaborationId: String
        /// The time at which the collaboration privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the account that created this collaboration privacy budget template.
        public let creatorAccountId: String
        /// The unique identifier of the collaboration privacy budget template.
        public let id: String
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateParametersOutput
        /// The type of privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the collaboration privacy budget template was updated.
        public let updateTime: Date

        public init(arn: String, autoRefresh: PrivacyBudgetTemplateAutoRefresh, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, id: String, parameters: PrivacyBudgetTemplateParametersOutput, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case autoRefresh = "autoRefresh"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case id = "id"
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationPrivacyBudgetTemplateSummary: AWSDecodableShape {
        /// The ARN of the collaboration privacy budget template.
        public let arn: String
        /// The ARN of the collaboration that contains this collaboration privacy budget template.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this collaboration privacy budget template.
        public let collaborationId: String
        /// The time at which the collaboration privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the account that created this collaboration privacy budget template.
        public let creatorAccountId: String
        /// The unique identifier of the collaboration privacy budget template.
        public let id: String
        /// The type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the collaboration privacy budget template was updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, id: String, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case id = "id"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationSummary: AWSDecodableShape {
        /// The ARN of the collaboration.
        public let arn: String
        /// The time when the collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The identifier for the collaboration.
        public let id: String
        /// The ARN of a member in a collaboration.
        public let membershipArn: String?
        /// The identifier of a member in a collaboration.
        public let membershipId: String?
        /// The status of a member in a collaboration.
        public let memberStatus: MemberStatus
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String
        /// The time the collaboration metadata was last updated.
        public let updateTime: Date

        public init(arn: String, createTime: Date, creatorAccountId: String, creatorDisplayName: String, id: String, membershipArn: String? = nil, membershipId: String? = nil, memberStatus: MemberStatus, name: String, updateTime: Date) {
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.memberStatus = memberStatus
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case creatorDisplayName = "creatorDisplayName"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case memberStatus = "memberStatus"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct Column: AWSDecodableShape {
        /// The name of the column.
        public let name: String
        /// The type of the column.
        public let type: String

        public init(name: String, type: String) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct ConfiguredAudienceModelAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains this configured audience model association.
        public let collaborationArn: String
        /// A unique identifier of the collaboration that contains this configured audience model association.
        public let collaborationId: String
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The description of the configured audience model association.
        public let description: String?
        /// A unique identifier of the configured audience model association.
        public let id: String
        /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration.
        public let manageResourcePolicies: Bool
        /// The Amazon Resource Name (ARN) of the membership that contains this configured audience model association.
        public let membershipArn: String
        /// A unique identifier for the membership that contains this configured audience model association.
        public let membershipId: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, id: String, manageResourcePolicies: Bool, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.manageResourcePolicies = manageResourcePolicies
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case manageResourcePolicies = "manageResourcePolicies"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredAudienceModelAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains the configured audience model association.
        public let collaborationArn: String
        /// A unique identifier of the collaboration that configured audience model is associated with.
        public let collaborationId: String
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The description of the configured audience model association.
        public let description: String?
        /// A unique identifier of the configured audience model association.
        public let id: String
        /// The Amazon Resource Name (ARN) of the membership that contains the configured audience model association.
        public let membershipArn: String
        /// A unique identifier of the membership that contains the configured audience model association.
        public let membershipId: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, id: String, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTable: AWSDecodableShape {
        /// The columns within the underlying Glue table that can be utilized within collaborations.
        public let allowedColumns: [String]
        /// The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod
        /// The types of analysis rules associated with this configured table. Currently, only one analysis rule may be associated with a configured table.
        public let analysisRuleTypes: [ConfiguredTableAnalysisRuleType]
        /// The unique ARN for the configured table.
        public let arn: String
        /// The time the configured table was created.
        public let createTime: Date
        /// A description for the configured table.
        public let description: String?
        /// The unique ID for the configured table.
        public let id: String
        /// A name for the configured table.
        public let name: String
        /// The Glue table that this configured table represents.
        public let tableReference: TableReference
        /// The time the configured table was last updated
        public let updateTime: Date

        public init(allowedColumns: [String], analysisMethod: AnalysisMethod, analysisRuleTypes: [ConfiguredTableAnalysisRuleType], arn: String, createTime: Date, description: String? = nil, id: String, name: String, tableReference: TableReference, updateTime: Date) {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.name = name
            self.tableReference = tableReference
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case allowedColumns = "allowedColumns"
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case tableReference = "tableReference"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAnalysisRule: AWSDecodableShape {
        /// The unique ARN for the configured table.
        public let configuredTableArn: String
        /// The unique ID for the configured table.
        public let configuredTableId: String
        /// The time the configured table analysis rule was created.
        public let createTime: Date
        /// The policy that controls SQL query rules.
        public let policy: ConfiguredTableAnalysisRulePolicy
        /// The type of configured table analysis rule.
        public let type: ConfiguredTableAnalysisRuleType
        /// The time the configured table analysis rule was last updated.
        public let updateTime: Date

        public init(configuredTableArn: String, configuredTableId: String, createTime: Date, policy: ConfiguredTableAnalysisRulePolicy, type: ConfiguredTableAnalysisRuleType, updateTime: Date) {
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableArn = "configuredTableArn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case policy = "policy"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAssociation: AWSDecodableShape {
        /// The unique ARN for the configured table association.
        public let arn: String
        /// The unique ARN for the configured table that the association refers to.
        public let configuredTableArn: String
        /// The unique ID for the configured table that the association refers to.
        public let configuredTableId: String
        /// The time the configured table association was created.
        public let createTime: Date
        /// A description of the configured table association.
        public let description: String?
        /// The unique ID for the configured table association.
        public let id: String
        /// The unique ARN for the membership this configured table association belongs to.
        public let membershipArn: String
        /// The unique ID for the membership this configured table association belongs to.
        public let membershipId: String
        /// The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.
        public let name: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String
        /// The time the configured table association was last updated.
        public let updateTime: Date

        public init(arn: String, configuredTableArn: String, configuredTableId: String, createTime: Date, description: String? = nil, id: String, membershipArn: String, membershipId: String, name: String, roleArn: String, updateTime: Date) {
            self.arn = arn
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.roleArn = roleArn
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case configuredTableArn = "configuredTableArn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case roleArn = "roleArn"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAssociationSummary: AWSDecodableShape {
        /// The unique ARN for the configured table association.
        public let arn: String
        /// The unique configured table ID that this configured table association refers to.
        public let configuredTableId: String
        /// The time the configured table association was created.
        public let createTime: Date
        /// The unique ID for the configured table association.
        public let id: String
        /// The unique ARN for the membership that the configured table association belongs to.
        public let membershipArn: String
        /// The unique ID for the membership that the configured table association belongs to.
        public let membershipId: String
        /// The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.
        public let name: String
        /// The time the configured table association was last updated.
        public let updateTime: Date

        public init(arn: String, configuredTableId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableSummary: AWSDecodableShape {
        /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod
        /// The types of analysis rules associated with this configured table.
        public let analysisRuleTypes: [ConfiguredTableAnalysisRuleType]
        /// The unique ARN of the configured table.
        public let arn: String
        /// The time the configured table was created.
        public let createTime: Date
        /// The unique ID of the configured table.
        public let id: String
        /// The name of the configured table.
        public let name: String
        /// The time the configured table was last updated.
        public let updateTime: Date

        public init(analysisMethod: AnalysisMethod, analysisRuleTypes: [ConfiguredTableAnalysisRuleType], arn: String, createTime: Date, id: String, name: String, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case createTime = "createTime"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CreateAnalysisTemplateInput: AWSEncodableShape {
        /// The parameters of the analysis template.
        public let analysisParameters: [AnalysisParameter]?
        /// The description of the analysis template.
        public let description: String?
        /// The format of the analysis template.
        public let format: AnalysisFormat
        /// The identifier for a membership resource.
        public let membershipIdentifier: String
        /// The name of the analysis template.
        public let name: String
        /// The information in the analysis template. Currently supports text, the query text for the analysis template.
        public let source: AnalysisSource
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(analysisParameters: [AnalysisParameter]? = nil, description: String? = nil, format: AnalysisFormat, membershipIdentifier: String, name: String, source: AnalysisSource, tags: [String: String]? = nil) {
            self.analysisParameters = analysisParameters
            self.description = description
            self.format = format
            self.membershipIdentifier = membershipIdentifier
            self.name = name
            self.source = source
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.analysisParameters, forKey: .analysisParameters)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.format, forKey: .format)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.source, forKey: .source)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.analysisParameters?.forEach {
                try $0.validate(name: "\(name).analysisParameters[]")
            }
            try self.validate(self.analysisParameters, name: "analysisParameters", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisParameters = "analysisParameters"
            case description = "description"
            case format = "format"
            case name = "name"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct CreateAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template.
        public let analysisTemplate: AnalysisTemplate

        public init(analysisTemplate: AnalysisTemplate) {
            self.analysisTemplate = analysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplate = "analysisTemplate"
        }
    }

    public struct CreateCollaborationInput: AWSEncodableShape {
        /// The display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The abilities granted to the collaboration creator.
        public let creatorMemberAbilities: [MemberAbility]
        /// The collaboration creator's payment responsibilities set by the collaboration creator.  If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer.
        public let creatorPaymentConfiguration: PaymentConfiguration?
        /// The settings for client-side encryption with Cryptographic Computing for Clean Rooms.
        public let dataEncryptionMetadata: DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public let description: String
        /// A list of initial members, not including the creator. This list is immutable.
        public let members: [MemberSpecification]
        /// The display name for a collaboration.
        public let name: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        public let queryLogStatus: CollaborationQueryLogStatus
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(creatorDisplayName: String, creatorMemberAbilities: [MemberAbility], creatorPaymentConfiguration: PaymentConfiguration? = nil, dataEncryptionMetadata: DataEncryptionMetadata? = nil, description: String, members: [MemberSpecification], name: String, queryLogStatus: CollaborationQueryLogStatus, tags: [String: String]? = nil) {
            self.creatorDisplayName = creatorDisplayName
            self.creatorMemberAbilities = creatorMemberAbilities
            self.creatorPaymentConfiguration = creatorPaymentConfiguration
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.members = members
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, max: 100)
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, min: 1)
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.members.forEach {
                try $0.validate(name: "\(name).members[]")
            }
            try self.validate(self.members, name: "members", parent: name, max: 9)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case creatorDisplayName = "creatorDisplayName"
            case creatorMemberAbilities = "creatorMemberAbilities"
            case creatorPaymentConfiguration = "creatorPaymentConfiguration"
            case dataEncryptionMetadata = "dataEncryptionMetadata"
            case description = "description"
            case members = "members"
            case name = "name"
            case queryLogStatus = "queryLogStatus"
            case tags = "tags"
        }
    }

    public struct CreateCollaborationOutput: AWSDecodableShape {
        /// The entire created collaboration object.
        public let collaboration: Collaboration

        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct CreateConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured audience model that you want to associate.
        public let configuredAudienceModelArn: String
        /// The name of the configured audience model association.
        public let configuredAudienceModelAssociationName: String
        /// A description of the configured audience model association.
        public let description: String?
        /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration. Setting this to TRUE requires you to have permissions to create, update, and delete the resource policy for the cleanrooms-ml resource when you call the DeleteConfiguredAudienceModelAssociation resource. In addition, if you are the collaboration creator and specify TRUE, you must have the same permissions when you call the DeleteMember and DeleteCollaboration APIs.
        public let manageResourcePolicies: Bool
        /// A unique identifier for one of your memberships for a collaboration. The configured audience model is associated to the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(configuredAudienceModelArn: String, configuredAudienceModelAssociationName: String, description: String? = nil, manageResourcePolicies: Bool, membershipIdentifier: String, tags: [String: String]? = nil) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.configuredAudienceModelAssociationName = configuredAudienceModelAssociationName
            self.description = description
            self.manageResourcePolicies = manageResourcePolicies
            self.membershipIdentifier = membershipIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
            try container.encode(self.configuredAudienceModelAssociationName, forKey: .configuredAudienceModelAssociationName)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.manageResourcePolicies, forKey: .manageResourcePolicies)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
            try self.validate(self.configuredAudienceModelAssociationName, name: "configuredAudienceModelAssociationName", parent: name, max: 100)
            try self.validate(self.configuredAudienceModelAssociationName, name: "configuredAudienceModelAssociationName", parent: name, min: 1)
            try self.validate(self.configuredAudienceModelAssociationName, name: "configuredAudienceModelAssociationName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case configuredAudienceModelAssociationName = "configuredAudienceModelAssociationName"
            case description = "description"
            case manageResourcePolicies = "manageResourcePolicies"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// Information about the configured audience model association.
        public let configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation

        public init(configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation) {
            self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociation = "configuredAudienceModelAssociation"
        }
    }

    public struct CreateConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The entire created configured table analysis rule object.
        public let analysisRulePolicy: ConfiguredTableAnalysisRulePolicy
        /// The type of analysis rule.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The identifier for the configured table to create the analysis rule for. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRulePolicy: ConfiguredTableAnalysisRulePolicy, analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            try container.encode(self.analysisRuleType, forKey: .analysisRuleType)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
            case analysisRuleType = "analysisRuleType"
        }
    }

    public struct CreateConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire created analysis rule.
        public let analysisRule: ConfiguredTableAnalysisRule

        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct CreateConfiguredTableAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured table to be associated to. Currently accepts a configured table ID.
        public let configuredTableIdentifier: String
        /// A description for the configured table association.
        public let description: String?
        /// A unique identifier for one of your memberships for a collaboration. The configured table is associated to the collaboration that this membership belongs to. Currently accepts a membership ID.
        public let membershipIdentifier: String
        /// The name of the configured table association. This name is used to query the underlying configured table.
        public let name: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(configuredTableIdentifier: String, description: String? = nil, membershipIdentifier: String, name: String, roleArn: String, tags: [String: String]? = nil) {
            self.configuredTableIdentifier = configuredTableIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configuredTableIdentifier, forKey: .configuredTableIdentifier)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableIdentifier = "configuredTableIdentifier"
            case description = "description"
            case name = "name"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire configured table association object.
        public let configuredTableAssociation: ConfiguredTableAssociation

        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct CreateConfiguredTableInput: AWSEncodableShape {
        /// The columns of the underlying table that can be used by collaborations or analysis rules.
        public let allowedColumns: [String]
        /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod
        /// A description for the configured table.
        public let description: String?
        /// The name of the configured table.
        public let name: String
        /// A reference to the Glue table being configured.
        public let tableReference: TableReference
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(allowedColumns: [String], analysisMethod: AnalysisMethod, description: String? = nil, name: String, tableReference: TableReference, tags: [String: String]? = nil) {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.description = description
            self.name = name
            self.tableReference = tableReference
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allowedColumns.forEach {
                try validate($0, name: "allowedColumns[]", parent: name, max: 128)
                try validate($0, name: "allowedColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.validate(self.allowedColumns, name: "allowedColumns", parent: name, max: 225)
            try self.validate(self.allowedColumns, name: "allowedColumns", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tableReference.validate(name: "\(name).tableReference")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedColumns = "allowedColumns"
            case analysisMethod = "analysisMethod"
            case description = "description"
            case name = "name"
            case tableReference = "tableReference"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredTableOutput: AWSDecodableShape {
        /// The created configured table.
        public let configuredTable: ConfiguredTable

        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct CreateMembershipInput: AWSEncodableShape {
        /// The unique ID for the associated collaboration.
        public let collaborationIdentifier: String
        /// The default protected query result configuration as specified by the member who can receive results.
        public let defaultResultConfiguration: MembershipProtectedQueryResultConfiguration?
        /// The payment responsibilities accepted by the collaboration member. Not required if the collaboration member has the member ability to run queries.  Required if the collaboration member doesn't have the member ability to run queries but is configured as a payer by the collaboration creator.
        public let paymentConfiguration: MembershipPaymentConfiguration?
        /// An indicator as to whether query logging has been enabled or disabled for the membership.
        public let queryLogStatus: MembershipQueryLogStatus
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(collaborationIdentifier: String, defaultResultConfiguration: MembershipProtectedQueryResultConfiguration? = nil, paymentConfiguration: MembershipPaymentConfiguration? = nil, queryLogStatus: MembershipQueryLogStatus, tags: [String: String]? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.defaultResultConfiguration = defaultResultConfiguration
            self.paymentConfiguration = paymentConfiguration
            self.queryLogStatus = queryLogStatus
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.defaultResultConfiguration?.validate(name: "\(name).defaultResultConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationIdentifier = "collaborationIdentifier"
            case defaultResultConfiguration = "defaultResultConfiguration"
            case paymentConfiguration = "paymentConfiguration"
            case queryLogStatus = "queryLogStatus"
            case tags = "tags"
        }
    }

    public struct CreateMembershipOutput: AWSDecodableShape {
        /// The membership that was created.
        public let membership: Membership

        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct CreatePrivacyBudgetTemplateInput: AWSEncodableShape {
        /// How often the privacy budget refreshes.  If you plan to regularly bring new data into the collaboration, you can use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        public let autoRefresh: PrivacyBudgetTemplateAutoRefresh
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// Specifies your parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateParametersInput
        /// Specifies the type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        public init(autoRefresh: PrivacyBudgetTemplateAutoRefresh, membershipIdentifier: String, parameters: PrivacyBudgetTemplateParametersInput, privacyBudgetType: PrivacyBudgetType, tags: [String: String]? = nil) {
            self.autoRefresh = autoRefresh
            self.membershipIdentifier = membershipIdentifier
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.autoRefresh, forKey: .autoRefresh)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.parameters, forKey: .parameters)
            try container.encode(self.privacyBudgetType, forKey: .privacyBudgetType)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.parameters.validate(name: "\(name).parameters")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case autoRefresh = "autoRefresh"
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
            case tags = "tags"
        }
    }

    public struct CreatePrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// A summary of the elements in the privacy budget template.
        public let privacyBudgetTemplate: PrivacyBudgetTemplate

        public init(privacyBudgetTemplate: PrivacyBudgetTemplate) {
            self.privacyBudgetTemplate = privacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case privacyBudgetTemplate = "privacyBudgetTemplate"
        }
    }

    public struct DataEncryptionMetadata: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether encrypted tables can contain cleartext data (TRUE) or are to cryptographically process every column (FALSE).
        public let allowCleartext: Bool
        /// Indicates whether Fingerprint columns can contain duplicate entries (TRUE) or are to contain only non-repeated values (FALSE).
        public let allowDuplicates: Bool
        /// Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (TRUE) or can only be joined on Fingerprint columns of the same name (FALSE).
        public let allowJoinsOnColumnsWithDifferentNames: Bool
        /// Indicates whether NULL values are to be copied as NULL to encrypted tables (TRUE) or cryptographically processed (FALSE).
        public let preserveNulls: Bool

        public init(allowCleartext: Bool, allowDuplicates: Bool, allowJoinsOnColumnsWithDifferentNames: Bool, preserveNulls: Bool) {
            self.allowCleartext = allowCleartext
            self.allowDuplicates = allowDuplicates
            self.allowJoinsOnColumnsWithDifferentNames = allowJoinsOnColumnsWithDifferentNames
            self.preserveNulls = preserveNulls
        }

        private enum CodingKeys: String, CodingKey {
            case allowCleartext = "allowCleartext"
            case allowDuplicates = "allowDuplicates"
            case allowJoinsOnColumnsWithDifferentNames = "allowJoinsOnColumnsWithDifferentNames"
            case preserveNulls = "preserveNulls"
        }
    }

    public struct DeleteAnalysisTemplateInput: AWSEncodableShape {
        /// The identifier for the analysis template resource.
        public let analysisTemplateIdentifier: String
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        public init(analysisTemplateIdentifier: String, membershipIdentifier: String) {
            self.analysisTemplateIdentifier = analysisTemplateIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateIdentifier, key: "analysisTemplateIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnalysisTemplateOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String

        public init(collaborationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCollaborationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier of the configured audience model association that you want to delete.
        public let configuredAudienceModelAssociationIdentifier: String
        /// A unique identifier of the membership that contains the audience model association that you want to delete.
        public let membershipIdentifier: String

        public init(configuredAudienceModelAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule type to be deleted. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique ID for the configured table association to be deleted. Currently accepts the configured table ID.
        public let configuredTableAssociationIdentifier: String
        /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        public init(configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableAssociationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableInput: AWSEncodableShape {
        /// The unique ID for the configured table to delete.
        public let configuredTableIdentifier: String

        public init(configuredTableIdentifier: String) {
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMemberInput: AWSEncodableShape {
        /// The account ID of the member to remove.
        public let accountId: String
        /// The unique identifier for the associated collaboration.
        public let collaborationIdentifier: String

        public init(accountId: String, collaborationIdentifier: String) {
            self.accountId = accountId
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemberOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMembershipInput: AWSEncodableShape {
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        public init(membershipIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMembershipOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is deleted from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// A unique identifier for your privacy budget template.
        public let privacyBudgetTemplateIdentifier: String

        public init(membershipIdentifier: String, privacyBudgetTemplateIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePrivacyBudgetTemplateOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DifferentialPrivacyColumn: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column, such as user_id, that contains the unique identifier of your users, whose privacy you want to protect. If you want to turn on differential privacy for two or more tables in a collaboration, you must configure the same column as the user identifier column in both analysis rules.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DifferentialPrivacyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column (such as user_id) that contains the unique identifier of your users whose privacy you want to protect. If you want to turn on diﬀerential privacy for two or more tables in a collaboration, you must conﬁgure the same column as the user identiﬁer column in both analysis rules.
        public let columns: [DifferentialPrivacyColumn]

        public init(columns: [DifferentialPrivacyColumn]) {
            self.columns = columns
        }

        public func validate(name: String) throws {
            try self.validate(self.columns, name: "columns", parent: name, max: 1)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "columns"
        }
    }

    public struct DifferentialPrivacyParameters: AWSDecodableShape {
        /// Provides the sensitivity parameters that you can use to better understand the total amount of noise in query results.
        public let sensitivityParameters: [DifferentialPrivacySensitivityParameters]

        public init(sensitivityParameters: [DifferentialPrivacySensitivityParameters]) {
            self.sensitivityParameters = sensitivityParameters
        }

        private enum CodingKeys: String, CodingKey {
            case sensitivityParameters = "sensitivityParameters"
        }
    }

    public struct DifferentialPrivacyPreviewAggregation: AWSDecodableShape {
        /// The maximum number of aggregations that the member who can query can run given the epsilon and noise parameters.
        public let maxCount: Int
        /// The type of aggregation function.
        public let type: DifferentialPrivacyAggregationType

        public init(maxCount: Int, type: DifferentialPrivacyAggregationType) {
            self.maxCount = maxCount
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxCount = "maxCount"
            case type = "type"
        }
    }

    public struct DifferentialPrivacyPreviewParametersInput: AWSEncodableShape {
        /// The epsilon value that you want to preview.
        public let epsilon: Int
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int

        public init(epsilon: Int, usersNoisePerQuery: Int) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.epsilon, name: "epsilon", parent: name, max: 20)
            try self.validate(self.epsilon, name: "epsilon", parent: name, min: 1)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, max: 100)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct DifferentialPrivacyPrivacyBudget: AWSDecodableShape {
        /// This information includes the configured epsilon value and the utility in terms of total aggregations, as well as the remaining aggregations.
        public let aggregations: [DifferentialPrivacyPrivacyBudgetAggregation]
        /// The epsilon value that you configured.
        public let epsilon: Int

        public init(aggregations: [DifferentialPrivacyPrivacyBudgetAggregation], epsilon: Int) {
            self.aggregations = aggregations
            self.epsilon = epsilon
        }

        private enum CodingKeys: String, CodingKey {
            case aggregations = "aggregations"
            case epsilon = "epsilon"
        }
    }

    public struct DifferentialPrivacyPrivacyBudgetAggregation: AWSDecodableShape {
        /// The maximum number of aggregation functions that you can perform with the given privacy budget.
        public let maxCount: Int
        /// The remaining number of aggregation functions that can be run with the available privacy budget.
        public let remainingCount: Int
        /// The different types of aggregation functions that you can perform.
        public let type: DifferentialPrivacyAggregationType

        public init(maxCount: Int, remainingCount: Int, type: DifferentialPrivacyAggregationType) {
            self.maxCount = maxCount
            self.remainingCount = remainingCount
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxCount = "maxCount"
            case remainingCount = "remainingCount"
            case type = "type"
        }
    }

    public struct DifferentialPrivacyPrivacyImpact: AWSDecodableShape {
        /// The number of aggregation functions that you can perform.
        public let aggregations: [DifferentialPrivacyPreviewAggregation]

        public init(aggregations: [DifferentialPrivacyPreviewAggregation]) {
            self.aggregations = aggregations
        }

        private enum CodingKeys: String, CodingKey {
            case aggregations = "aggregations"
        }
    }

    public struct DifferentialPrivacySensitivityParameters: AWSDecodableShape {
        /// The aggregation expression that was run.
        public let aggregationExpression: String
        /// The type of aggregation function that was run.
        public let aggregationType: DifferentialPrivacyAggregationType
        /// The upper bound of the aggregation expression.
        public let maxColumnValue: Float?
        /// The lower bound of the aggregation expression.
        public let minColumnValue: Float?
        /// The maximum number of rows contributed by a user in a SQL query.
        public let userContributionLimit: Int

        public init(aggregationExpression: String, aggregationType: DifferentialPrivacyAggregationType, maxColumnValue: Float? = nil, minColumnValue: Float? = nil, userContributionLimit: Int) {
            self.aggregationExpression = aggregationExpression
            self.aggregationType = aggregationType
            self.maxColumnValue = maxColumnValue
            self.minColumnValue = minColumnValue
            self.userContributionLimit = userContributionLimit
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationExpression = "aggregationExpression"
            case aggregationType = "aggregationType"
            case maxColumnValue = "maxColumnValue"
            case minColumnValue = "minColumnValue"
            case userContributionLimit = "userContributionLimit"
        }
    }

    public struct DifferentialPrivacyTemplateParametersInput: AWSEncodableShape {
        /// The epsilon value that you want to use.
        public let epsilon: Int
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int

        public init(epsilon: Int, usersNoisePerQuery: Int) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.epsilon, name: "epsilon", parent: name, max: 20)
            try self.validate(self.epsilon, name: "epsilon", parent: name, min: 1)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, max: 100)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct DifferentialPrivacyTemplateParametersOutput: AWSDecodableShape {
        /// The epsilon value that you specified.
        public let epsilon: Int
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int

        public init(epsilon: Int, usersNoisePerQuery: Int) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct DifferentialPrivacyTemplateUpdateParameters: AWSEncodableShape {
        /// The updated epsilon value that you want to use.
        public let epsilon: Int?
        /// The updated value of noise added per query. It is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int?

        public init(epsilon: Int? = nil, usersNoisePerQuery: Int? = nil) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.epsilon, name: "epsilon", parent: name, max: 20)
            try self.validate(self.epsilon, name: "epsilon", parent: name, min: 1)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, max: 100)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct GetAnalysisTemplateInput: AWSEncodableShape {
        /// The identifier for the analysis template resource.
        public let analysisTemplateIdentifier: String
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        public init(analysisTemplateIdentifier: String, membershipIdentifier: String) {
            self.analysisTemplateIdentifier = analysisTemplateIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateIdentifier, key: "analysisTemplateIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template.
        public let analysisTemplate: AnalysisTemplate

        public init(analysisTemplate: AnalysisTemplate) {
            self.analysisTemplate = analysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplate = "analysisTemplate"
        }
    }

    public struct GetCollaborationAnalysisTemplateInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public let analysisTemplateArn: String
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String

        public init(analysisTemplateArn: String, collaborationIdentifier: String) {
            self.analysisTemplateArn = analysisTemplateArn
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateArn, key: "analysisTemplateArn")
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, max: 200)
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+$")
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template within a collaboration.
        public let collaborationAnalysisTemplate: CollaborationAnalysisTemplate

        public init(collaborationAnalysisTemplate: CollaborationAnalysisTemplate) {
            self.collaborationAnalysisTemplate = collaborationAnalysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationAnalysisTemplate = "collaborationAnalysisTemplate"
        }
    }

    public struct GetCollaborationConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// A unique identifier for the configured audience model association that you want to retrieve.
        public let configuredAudienceModelAssociationIdentifier: String

        public init(collaborationIdentifier: String, configuredAudienceModelAssociationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// The metadata of the configured audience model association.
        public let collaborationConfiguredAudienceModelAssociation: CollaborationConfiguredAudienceModelAssociation

        public init(collaborationConfiguredAudienceModelAssociation: CollaborationConfiguredAudienceModelAssociation) {
            self.collaborationConfiguredAudienceModelAssociation = collaborationConfiguredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationConfiguredAudienceModelAssociation = "collaborationConfiguredAudienceModelAssociation"
        }
    }

    public struct GetCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String

        public init(collaborationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationOutput: AWSDecodableShape {
        /// The entire collaboration for this identifier.
        public let collaboration: Collaboration

        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct GetCollaborationPrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your collaborations.
        public let collaborationIdentifier: String
        /// A unique identifier for one of your privacy budget templates.
        public let privacyBudgetTemplateIdentifier: String

        public init(collaborationIdentifier: String, privacyBudgetTemplateIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationPrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// Returns the details of the privacy budget template that you requested.
        public let collaborationPrivacyBudgetTemplate: CollaborationPrivacyBudgetTemplate

        public init(collaborationPrivacyBudgetTemplate: CollaborationPrivacyBudgetTemplate) {
            self.collaborationPrivacyBudgetTemplate = collaborationPrivacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationPrivacyBudgetTemplate = "collaborationPrivacyBudgetTemplate"
        }
    }

    public struct GetConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured audience model association that you want to retrieve.
        public let configuredAudienceModelAssociationIdentifier: String
        /// A unique identifier for the membership that contains the configured audience model association that you want to retrieve.
        public let membershipIdentifier: String

        public init(configuredAudienceModelAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// Information about the configured audience model association that you requested.
        public let configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation

        public init(configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation) {
            self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociation = "configuredAudienceModelAssociation"
        }
    }

    public struct GetConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule to be retrieved. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table to retrieve. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire analysis rule output.
        public let analysisRule: ConfiguredTableAnalysisRule

        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct GetConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique ID for the configured table association to retrieve. Currently accepts the configured table ID.
        public let configuredTableAssociationIdentifier: String
        /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        public init(configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire configured table association object.
        public let configuredTableAssociation: ConfiguredTableAssociation

        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct GetConfiguredTableInput: AWSEncodableShape {
        /// The unique ID for the configured table to retrieve.
        public let configuredTableIdentifier: String

        public init(configuredTableIdentifier: String) {
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableOutput: AWSDecodableShape {
        /// The retrieved configured table.
        public let configuredTable: ConfiguredTable

        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct GetMembershipInput: AWSEncodableShape {
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        public init(membershipIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMembershipOutput: AWSDecodableShape {
        /// The membership retrieved for the provided identifier.
        public let membership: Membership

        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct GetPrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// A unique identifier for your privacy budget template.
        public let privacyBudgetTemplateIdentifier: String

        public init(membershipIdentifier: String, privacyBudgetTemplateIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// Returns the details of the privacy budget template that you requested.
        public let privacyBudgetTemplate: PrivacyBudgetTemplate

        public init(privacyBudgetTemplate: PrivacyBudgetTemplate) {
            self.privacyBudgetTemplate = privacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case privacyBudgetTemplate = "privacyBudgetTemplate"
        }
    }

    public struct GetProtectedQueryInput: AWSEncodableShape {
        /// The identifier for a membership in a protected query instance.
        public let membershipIdentifier: String
        /// The identifier for a protected query instance.
        public let protectedQueryIdentifier: String

        public init(membershipIdentifier: String, protectedQueryIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedQueryIdentifier = protectedQueryIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedQueryIdentifier, key: "protectedQueryIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, max: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, min: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProtectedQueryOutput: AWSDecodableShape {
        /// The query processing metadata.
        public let protectedQuery: ProtectedQuery

        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct GetSchemaAnalysisRuleInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The name of the schema to retrieve the analysis rule for.
        public let name: String
        /// The type of the schema analysis rule to retrieve. Schema analysis rules are uniquely identified by a combination of the collaboration, the schema name, and their type.
        public let type: AnalysisRuleType

        public init(collaborationIdentifier: String, name: String, type: AnalysisRuleType) {
            self.collaborationIdentifier = collaborationIdentifier
            self.name = name
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.name, key: "name")
            request.encodePath(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaAnalysisRuleOutput: AWSDecodableShape {
        /// A specification about how data from the configured table can be used.
        public let analysisRule: AnalysisRule

        public init(analysisRule: AnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct GetSchemaInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The name of the relation to retrieve the schema for.
        public let name: String

        public init(collaborationIdentifier: String, name: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaOutput: AWSDecodableShape {
        /// The entire schema object.
        public let schema: Schema

        public init(schema: Schema) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct GlueTableReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database the Glue table belongs to.
        public let databaseName: String
        /// The name of the Glue table.
        public let tableName: String

        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 128)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_]+-)*([a-zA-Z0-9_]+))?$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case tableName = "tableName"
        }
    }

    public struct ListAnalysisTemplatesInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The identifier for a membership resource.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalysisTemplatesOutput: AWSDecodableShape {
        /// Lists analysis template metadata.
        public let analysisTemplateSummaries: [AnalysisTemplateSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(analysisTemplateSummaries: [AnalysisTemplateSummary], nextToken: String? = nil) {
            self.analysisTemplateSummaries = analysisTemplateSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplateSummaries = "analysisTemplateSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationAnalysisTemplatesInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationAnalysisTemplatesOutput: AWSDecodableShape {
        /// The metadata of the analysis template within a collaboration.
        public let collaborationAnalysisTemplateSummaries: [CollaborationAnalysisTemplateSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationAnalysisTemplateSummaries: [CollaborationAnalysisTemplateSummary], nextToken: String? = nil) {
            self.collaborationAnalysisTemplateSummaries = collaborationAnalysisTemplateSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationAnalysisTemplateSummaries = "collaborationAnalysisTemplateSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationConfiguredAudienceModelAssociationsInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationConfiguredAudienceModelAssociationsOutput: AWSDecodableShape {
        /// The metadata of the configured audience model association within a collaboration.
        public let collaborationConfiguredAudienceModelAssociationSummaries: [CollaborationConfiguredAudienceModelAssociationSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationConfiguredAudienceModelAssociationSummaries: [CollaborationConfiguredAudienceModelAssociationSummary], nextToken: String? = nil) {
            self.collaborationConfiguredAudienceModelAssociationSummaries = collaborationConfiguredAudienceModelAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationConfiguredAudienceModelAssociationSummaries = "collaborationConfiguredAudienceModelAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationPrivacyBudgetTemplatesInput: AWSEncodableShape {
        /// A unique identifier for one of your collaborations.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationPrivacyBudgetTemplatesOutput: AWSDecodableShape {
        /// An array that summarizes the collaboration privacy budget templates. The summary includes collaboration information, creation information, the privacy budget type.
        public let collaborationPrivacyBudgetTemplateSummaries: [CollaborationPrivacyBudgetTemplateSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationPrivacyBudgetTemplateSummaries: [CollaborationPrivacyBudgetTemplateSummary], nextToken: String? = nil) {
            self.collaborationPrivacyBudgetTemplateSummaries = collaborationPrivacyBudgetTemplateSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationPrivacyBudgetTemplateSummaries = "collaborationPrivacyBudgetTemplateSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationPrivacyBudgetsInput: AWSEncodableShape {
        /// A unique identifier for one of your collaborations.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// Specifies the type of the privacy budget.
        public let privacyBudgetType: PrivacyBudgetType

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, privacyBudgetType: PrivacyBudgetType) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.privacyBudgetType = privacyBudgetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.privacyBudgetType, key: "privacyBudgetType")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationPrivacyBudgetsOutput: AWSDecodableShape {
        /// Summaries of the collaboration privacy budgets.
        public let collaborationPrivacyBudgetSummaries: [CollaborationPrivacyBudgetSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationPrivacyBudgetSummaries: [CollaborationPrivacyBudgetSummary], nextToken: String? = nil) {
            self.collaborationPrivacyBudgetSummaries = collaborationPrivacyBudgetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationPrivacyBudgetSummaries = "collaborationPrivacyBudgetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The caller's status in a collaboration.
        public let memberStatus: FilterableMemberStatus?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, memberStatus: FilterableMemberStatus? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.memberStatus = memberStatus
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.memberStatus, key: "memberStatus")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationsOutput: AWSDecodableShape {
        /// The list of collaborations.
        public let collaborationList: [CollaborationSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationList: [CollaborationSummary], nextToken: String? = nil) {
            self.collaborationList = collaborationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationList = "collaborationList"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredAudienceModelAssociationsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// A unique identifier for a membership that contains the configured audience model associations that you want to retrieve.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredAudienceModelAssociationsOutput: AWSDecodableShape {
        /// Summaries of the configured audience model associations that you requested.
        public let configuredAudienceModelAssociationSummaries: [ConfiguredAudienceModelAssociationSummary]
        /// The token value provided to access the next page of results.
        public let nextToken: String?

        public init(configuredAudienceModelAssociationSummaries: [ConfiguredAudienceModelAssociationSummary], nextToken: String? = nil) {
            self.configuredAudienceModelAssociationSummaries = configuredAudienceModelAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociationSummaries = "configuredAudienceModelAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredTableAssociationsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// A unique identifier for the membership to list configured table associations for. Currently accepts the membership ID.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredTableAssociationsOutput: AWSDecodableShape {
        /// The retrieved list of configured table associations.
        public let configuredTableAssociationSummaries: [ConfiguredTableAssociationSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(configuredTableAssociationSummaries: [ConfiguredTableAssociationSummary], nextToken: String? = nil) {
            self.configuredTableAssociationSummaries = configuredTableAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociationSummaries = "configuredTableAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredTablesInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredTablesOutput: AWSDecodableShape {
        /// The configured tables listed by the request.
        public let configuredTableSummaries: [ConfiguredTableSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(configuredTableSummaries: [ConfiguredTableSummary], nextToken: String? = nil) {
            self.configuredTableSummaries = configuredTableSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableSummaries = "configuredTableSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembersInput: AWSEncodableShape {
        /// The identifier of the collaboration in which the members are listed.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersOutput: AWSDecodableShape {
        /// The list of members returned by the ListMembers operation.
        public let memberSummaries: [MemberSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(memberSummaries: [MemberSummary], nextToken: String? = nil) {
            self.memberSummaries = memberSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memberSummaries = "memberSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembershipsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// A filter which will return only memberships in the specified status.
        public let status: MembershipStatus?

        public init(maxResults: Int? = nil, nextToken: String? = nil, status: MembershipStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembershipsOutput: AWSDecodableShape {
        /// The list of memberships returned from the ListMemberships operation.
        public let membershipSummaries: [MembershipSummary]
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(membershipSummaries: [MembershipSummary], nextToken: String? = nil) {
            self.membershipSummaries = membershipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case membershipSummaries = "membershipSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPrivacyBudgetTemplatesInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget templates are retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPrivacyBudgetTemplatesOutput: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// An array that summarizes the privacy budget templates. The summary includes collaboration information, creation information, and privacy budget type.
        public let privacyBudgetTemplateSummaries: [PrivacyBudgetTemplateSummary]

        public init(nextToken: String? = nil, privacyBudgetTemplateSummaries: [PrivacyBudgetTemplateSummary]) {
            self.nextToken = nextToken
            self.privacyBudgetTemplateSummaries = privacyBudgetTemplateSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case privacyBudgetTemplateSummaries = "privacyBudgetTemplateSummaries"
        }
    }

    public struct ListPrivacyBudgetsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// The privacy budget type.
        public let privacyBudgetType: PrivacyBudgetType

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil, privacyBudgetType: PrivacyBudgetType) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
            self.privacyBudgetType = privacyBudgetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.privacyBudgetType, key: "privacyBudgetType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPrivacyBudgetsOutput: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// An array that summarizes the privacy budgets. The summary includes collaboration information, membership information, privacy budget template information, and privacy budget details.
        public let privacyBudgetSummaries: [PrivacyBudgetSummary]

        public init(nextToken: String? = nil, privacyBudgetSummaries: [PrivacyBudgetSummary]) {
            self.nextToken = nextToken
            self.privacyBudgetSummaries = privacyBudgetSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case privacyBudgetSummaries = "privacyBudgetSummaries"
        }
    }

    public struct ListProtectedQueriesInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service can return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The identifier for the membership in the collaboration.
        public let membershipIdentifier: String
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// A filter on the status of the protected query.
        public let status: ProtectedQueryStatus?

        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil, status: ProtectedQueryStatus? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProtectedQueriesOutput: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// A list of protected queries.
        public let protectedQueries: [ProtectedQuerySummary]

        public init(nextToken: String? = nil, protectedQueries: [ProtectedQuerySummary]) {
            self.nextToken = nextToken
            self.protectedQueries = protectedQueries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case protectedQueries = "protectedQueries"
        }
    }

    public struct ListSchemasInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call.
        public let maxResults: Int?
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// If present, filter schemas by schema type. The only valid schema type is currently `TABLE`.
        public let schemaType: SchemaType?

        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, schemaType: SchemaType? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.schemaType = schemaType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.schemaType, key: "schemaType")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemasOutput: AWSDecodableShape {
        /// The token value retrieved from a previous call to access the next page of results.
        public let nextToken: String?
        /// The retrieved list of schemas.
        public let schemaSummaries: [SchemaSummary]

        public init(nextToken: String? = nil, schemaSummaries: [SchemaSummary]) {
            self.nextToken = nextToken
            self.schemaSummaries = schemaSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemaSummaries = "schemaSummaries"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// A map of objects specifying each key name and value.
        public let tags: [String: String]

        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MemberSpecification: AWSEncodableShape {
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let accountId: String
        /// The member's display name.
        public let displayName: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// The collaboration member's payment responsibilities set by the collaboration creator.  If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        public let paymentConfiguration: PaymentConfiguration?

        public init(accountId: String, displayName: String, memberAbilities: [MemberAbility], paymentConfiguration: PaymentConfiguration? = nil) {
            self.accountId = accountId
            self.displayName = displayName
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case displayName = "displayName"
            case memberAbilities = "memberAbilities"
            case paymentConfiguration = "paymentConfiguration"
        }
    }

    public struct MemberSummary: AWSDecodableShape {
        /// The abilities granted to the collaboration member.
        public let abilities: [MemberAbility]
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let accountId: String
        /// The time when the member was created.
        public let createTime: Date
        /// The member's display name.
        public let displayName: String
        /// The unique ARN for the member's associated membership, if present.
        public let membershipArn: String?
        /// The unique ID for the member's associated membership, if present.
        public let membershipId: String?
        /// The collaboration member's payment responsibilities set by the collaboration creator.
        public let paymentConfiguration: PaymentConfiguration
        /// The status of the member.
        public let status: MemberStatus
        /// The time the member metadata was last updated.
        public let updateTime: Date

        public init(abilities: [MemberAbility], accountId: String, createTime: Date, displayName: String, membershipArn: String? = nil, membershipId: String? = nil, paymentConfiguration: PaymentConfiguration, status: MemberStatus, updateTime: Date) {
            self.abilities = abilities
            self.accountId = accountId
            self.createTime = createTime
            self.displayName = displayName
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case abilities = "abilities"
            case accountId = "accountId"
            case createTime = "createTime"
            case displayName = "displayName"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case paymentConfiguration = "paymentConfiguration"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct Membership: AWSDecodableShape {
        /// The unique ARN for the membership.
        public let arn: String
        /// The unique ARN for the membership's associated collaboration.
        public let collaborationArn: String
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let collaborationCreatorAccountId: String
        /// The display name of the collaboration creator.
        public let collaborationCreatorDisplayName: String
        /// The unique ID for the membership's collaboration.
        public let collaborationId: String
        /// The name of the membership's collaboration.
        public let collaborationName: String
        /// The time when the membership was created.
        public let createTime: Date
        /// The default protected query result configuration as specified by the member who can receive results.
        public let defaultResultConfiguration: MembershipProtectedQueryResultConfiguration?
        /// The unique ID of the membership.
        public let id: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// The payment responsibilities accepted by the collaboration member.
        public let paymentConfiguration: MembershipPaymentConfiguration
        /// An indicator as to whether query logging has been enabled or disabled for the membership.
        public let queryLogStatus: MembershipQueryLogStatus
        /// The status of the membership.
        public let status: MembershipStatus
        /// The time the membership metadata was last updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationCreatorAccountId: String, collaborationCreatorDisplayName: String, collaborationId: String, collaborationName: String, createTime: Date, defaultResultConfiguration: MembershipProtectedQueryResultConfiguration? = nil, id: String, memberAbilities: [MemberAbility], paymentConfiguration: MembershipPaymentConfiguration, queryLogStatus: MembershipQueryLogStatus, status: MembershipStatus, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.defaultResultConfiguration = defaultResultConfiguration
            self.id = id
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.queryLogStatus = queryLogStatus
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationCreatorAccountId = "collaborationCreatorAccountId"
            case collaborationCreatorDisplayName = "collaborationCreatorDisplayName"
            case collaborationId = "collaborationId"
            case collaborationName = "collaborationName"
            case createTime = "createTime"
            case defaultResultConfiguration = "defaultResultConfiguration"
            case id = "id"
            case memberAbilities = "memberAbilities"
            case paymentConfiguration = "paymentConfiguration"
            case queryLogStatus = "queryLogStatus"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct MembershipPaymentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The payment responsibilities accepted by the collaboration member for query compute costs.
        public let queryCompute: MembershipQueryComputePaymentConfig

        public init(queryCompute: MembershipQueryComputePaymentConfig) {
            self.queryCompute = queryCompute
        }

        private enum CodingKeys: String, CodingKey {
            case queryCompute = "queryCompute"
        }
    }

    public struct MembershipProtectedQueryResultConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for protected query results.
        public let outputConfiguration: MembershipProtectedQueryOutputConfiguration
        /// The unique ARN for an IAM role that is used by Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        public let roleArn: String?

        public init(outputConfiguration: MembershipProtectedQueryOutputConfiguration, roleArn: String? = nil) {
            self.outputConfiguration = outputConfiguration
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct MembershipQueryComputePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration member has accepted to pay for query compute costs (TRUE) or has not accepted to pay for query compute costs (FALSE). If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.  An error message is returned for the following reasons:    If you set the value to FALSE but you are responsible to pay for query compute costs.    If you set the value to TRUE but you are not responsible to pay for query compute costs.
        public let isResponsible: Bool

        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct MembershipSummary: AWSDecodableShape {
        /// The unique ARN for the membership.
        public let arn: String
        /// The unique ARN for the membership's associated collaboration.
        public let collaborationArn: String
        /// The identifier of the Amazon Web Services principal that created the collaboration. Currently only supports Amazon Web Services account ID.
        public let collaborationCreatorAccountId: String
        /// The display name of the collaboration creator.
        public let collaborationCreatorDisplayName: String
        /// The unique ID for the membership's collaboration.
        public let collaborationId: String
        /// The name for the membership's collaboration.
        public let collaborationName: String
        /// The time when the membership was created.
        public let createTime: Date
        /// The unique ID for the membership's collaboration.
        public let id: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// The payment responsibilities accepted by the collaboration member.
        public let paymentConfiguration: MembershipPaymentConfiguration
        /// The status of the membership.
        public let status: MembershipStatus
        /// The time the membership metadata was last updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationCreatorAccountId: String, collaborationCreatorDisplayName: String, collaborationId: String, collaborationName: String, createTime: Date, id: String, memberAbilities: [MemberAbility], paymentConfiguration: MembershipPaymentConfiguration, status: MembershipStatus, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.id = id
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationCreatorAccountId = "collaborationCreatorAccountId"
            case collaborationCreatorDisplayName = "collaborationCreatorDisplayName"
            case collaborationId = "collaborationId"
            case collaborationName = "collaborationName"
            case createTime = "createTime"
            case id = "id"
            case memberAbilities = "memberAbilities"
            case paymentConfiguration = "paymentConfiguration"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct PaymentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        public let queryCompute: QueryComputePaymentConfig

        public init(queryCompute: QueryComputePaymentConfig) {
            self.queryCompute = queryCompute
        }

        private enum CodingKeys: String, CodingKey {
            case queryCompute = "queryCompute"
        }
    }

    public struct PreviewPrivacyImpactInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. Accepts a membership ID.
        public let membershipIdentifier: String
        /// Specifies the desired epsilon and noise parameters to preview.
        public let parameters: PreviewPrivacyImpactParametersInput

        public init(membershipIdentifier: String, parameters: PreviewPrivacyImpactParametersInput) {
            self.membershipIdentifier = membershipIdentifier
            self.parameters = parameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.parameters, forKey: .parameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.parameters.validate(name: "\(name).parameters")
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
        }
    }

    public struct PreviewPrivacyImpactOutput: AWSDecodableShape {
        /// An estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters. This does not change the privacy budget.
        public let privacyImpact: PrivacyImpact

        public init(privacyImpact: PrivacyImpact) {
            self.privacyImpact = privacyImpact
        }

        private enum CodingKeys: String, CodingKey {
            case privacyImpact = "privacyImpact"
        }
    }

    public struct PrivacyBudgetSummary: AWSDecodableShape {
        /// The provided privacy budget.
        public let budget: PrivacyBudget
        /// The ARN of the collaboration that contains this privacy budget.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this privacy budget.
        public let collaborationId: String
        /// The time at which the privacy budget was created.
        public let createTime: Date
        /// The unique identifier of the privacy budget.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget summary.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// The ARN of the privacy budget template.
        public let privacyBudgetTemplateArn: String
        /// The unique identifier of the privacy budget template.
        public let privacyBudgetTemplateId: String
        /// Specifies the type of the privacy budget.
        public let type: PrivacyBudgetType
        /// The most recent time at which the privacy budget was updated.
        public let updateTime: Date

        public init(budget: PrivacyBudget, collaborationArn: String, collaborationId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, privacyBudgetTemplateArn: String, privacyBudgetTemplateId: String, type: PrivacyBudgetType, updateTime: Date) {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case budget = "budget"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case privacyBudgetTemplateArn = "privacyBudgetTemplateArn"
            case privacyBudgetTemplateId = "privacyBudgetTemplateId"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct PrivacyBudgetTemplate: AWSDecodableShape {
        /// The ARN of the privacy budget template.
        public let arn: String
        /// How often the privacy budget refreshes.  If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        public let autoRefresh: PrivacyBudgetTemplateAutoRefresh
        /// The ARN of the collaboration that contains this privacy budget template.
        public let collaborationArn: String
        /// The unique ID of the collaboration that contains this privacy budget template.
        public let collaborationId: String
        /// The time at which the privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the privacy budget template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// Specifies the epislon and noise parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateParametersOutput
        /// Specifies the type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the privacy budget template was updated.
        public let updateTime: Date

        public init(arn: String, autoRefresh: PrivacyBudgetTemplateAutoRefresh, collaborationArn: String, collaborationId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, parameters: PrivacyBudgetTemplateParametersOutput, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case autoRefresh = "autoRefresh"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct PrivacyBudgetTemplateSummary: AWSDecodableShape {
        /// The ARN of the privacy budget template.
        public let arn: String
        /// The ARN of the collaboration that contains this privacy budget template.
        public let collaborationArn: String
        /// The unique ID of the collaboration that contains this privacy budget template.
        public let collaborationId: String
        /// The time at which the privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the privacy budget template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// The type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the privacy budget template was updated.
        public let updateTime: Date

        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct ProtectedQuery: AWSDecodableShape {
        /// The time at which the protected query was created.
        public let createTime: Date
        /// The sensitivity parameters of the differential privacy results of the protected query.
        public let differentialPrivacy: DifferentialPrivacyParameters?
        /// An error thrown by the protected query.
        public let error: ProtectedQueryError?
        /// The identifier for a protected query instance.
        public let id: String
        /// The ARN of the membership.
        public let membershipArn: String
        /// The identifier for the membership.
        public let membershipId: String
        /// The result of the protected query.
        public let result: ProtectedQueryResult?
        /// Contains any details needed to write the query results.
        public let resultConfiguration: ProtectedQueryResultConfiguration?
        /// The protected query SQL parameters.
        public let sqlParameters: ProtectedQuerySQLParameters?
        /// Statistics about protected query execution.
        public let statistics: ProtectedQueryStatistics?
        /// The status of the query.
        public let status: ProtectedQueryStatus

        public init(createTime: Date, differentialPrivacy: DifferentialPrivacyParameters? = nil, error: ProtectedQueryError? = nil, id: String, membershipArn: String, membershipId: String, result: ProtectedQueryResult? = nil, resultConfiguration: ProtectedQueryResultConfiguration? = nil, sqlParameters: ProtectedQuerySQLParameters? = nil, statistics: ProtectedQueryStatistics? = nil, status: ProtectedQueryStatus) {
            self.createTime = createTime
            self.differentialPrivacy = differentialPrivacy
            self.error = error
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.result = result
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.statistics = statistics
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case differentialPrivacy = "differentialPrivacy"
            case error = "error"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case result = "result"
            case resultConfiguration = "resultConfiguration"
            case sqlParameters = "sqlParameters"
            case statistics = "statistics"
            case status = "status"
        }
    }

    public struct ProtectedQueryError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// A description of why the query failed.
        public let message: String

        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ProtectedQueryResult: AWSDecodableShape {
        /// The output of the protected query.
        public let output: ProtectedQueryOutput

        public init(output: ProtectedQueryOutput) {
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
        }
    }

    public struct ProtectedQueryResultConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for protected query results.
        public let outputConfiguration: ProtectedQueryOutputConfiguration

        public init(outputConfiguration: ProtectedQueryOutputConfiguration) {
            self.outputConfiguration = outputConfiguration
        }

        public func validate(name: String) throws {
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
        }
    }

    public struct ProtectedQueryS3Output: AWSDecodableShape {
        /// The S3 location of the result.
        public let location: String

        public init(location: String) {
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
        }
    }

    public struct ProtectedQueryS3OutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket to unload the protected query results.
        public let bucket: String
        /// The S3 prefix to unload the protected query results.
        public let keyPrefix: String?
        /// Intended file format of the result.
        public let resultFormat: ResultFormat

        public init(bucket: String, keyPrefix: String? = nil, resultFormat: ResultFormat) {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.resultFormat = resultFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, max: 512)
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, pattern: "^[\\w!.=*/-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case keyPrefix = "keyPrefix"
            case resultFormat = "resultFormat"
        }
    }

    public struct ProtectedQuerySQLParameters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public let analysisTemplateArn: String?
        /// The protected query SQL parameters.
        public let parameters: [String: String]?
        /// The query string to be submitted.
        public let queryString: String?

        public init(analysisTemplateArn: String? = nil, parameters: [String: String]? = nil, queryString: String? = nil) {
            self.analysisTemplateArn = analysisTemplateArn
            self.parameters = parameters
            self.queryString = queryString
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, max: 200)
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 100)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[0-9a-zA-Z_]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 250)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplateArn = "analysisTemplateArn"
            case parameters = "parameters"
            case queryString = "queryString"
        }
    }

    public struct ProtectedQuerySingleMemberOutput: AWSDecodableShape {
        /// The Amazon Web Services account ID of the member in the collaboration who can receive results for the query.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct ProtectedQueryStatistics: AWSDecodableShape {
        /// The duration of the Protected Query, from creation until query completion.
        public let totalDurationInMillis: Int64?

        public init(totalDurationInMillis: Int64? = nil) {
            self.totalDurationInMillis = totalDurationInMillis
        }

        private enum CodingKeys: String, CodingKey {
            case totalDurationInMillis = "totalDurationInMillis"
        }
    }

    public struct ProtectedQuerySummary: AWSDecodableShape {
        /// The time the protected query was created.
        public let createTime: Date
        /// The unique ID of the protected query.
        public let id: String
        /// The unique ARN for the membership that initiated the protected query.
        public let membershipArn: String
        /// The unique ID for the membership that initiated the protected query.
        public let membershipId: String
        /// The status of the protected query. Value values are `SUBMITTED`, `STARTED`, `CANCELLED`, `CANCELLING`, `FAILED`, `SUCCESS`, `TIMED_OUT`.
        public let status: ProtectedQueryStatus

        public init(createTime: Date, id: String, membershipArn: String, membershipId: String, status: ProtectedQueryStatus) {
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case status = "status"
        }
    }

    public struct QueryComputePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs (TRUE) or has not configured the collaboration member to pay for query compute costs (FALSE). Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a TRUE value for more than one member in the collaboration.  If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a FALSE value for the member who can query.
        public let isResponsible: Bool

        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct Schema: AWSDecodableShape {
        /// The analysis method for the schema. The only valid value is currently DIRECT_QUERY.
        public let analysisMethod: AnalysisMethod?
        /// The analysis rule types associated with the schema. Currently, only one entry is present.
        public let analysisRuleTypes: [AnalysisRuleType]
        /// The unique ARN for the collaboration that the schema belongs to.
        public let collaborationArn: String
        /// The unique ID for the collaboration that the schema belongs to.
        public let collaborationId: String
        /// The columns for the relation this schema represents.
        public let columns: [Column]
        /// The time the schema was created.
        public let createTime: Date
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        public let creatorAccountId: String
        /// A description for the schema.
        public let description: String
        /// A name for the schema. The schema relation is referred to by this name when queried by a protected query.
        public let name: String
        /// The partition keys for the dataset underlying this schema.
        public let partitionKeys: [Column]
        /// Details about the status of the schema. Currently, only one entry is present.
        public let schemaStatusDetails: [SchemaStatusDetail]
        /// The type of schema. The only valid value is currently `TABLE`.
        public let type: SchemaType
        /// The time the schema was last updated.
        public let updateTime: Date

        public init(analysisMethod: AnalysisMethod? = nil, analysisRuleTypes: [AnalysisRuleType], collaborationArn: String, collaborationId: String, columns: [Column], createTime: Date, creatorAccountId: String, description: String, name: String, partitionKeys: [Column], schemaStatusDetails: [SchemaStatusDetail], type: SchemaType, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.columns = columns
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaStatusDetails = schemaStatusDetails
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case columns = "columns"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case name = "name"
            case partitionKeys = "partitionKeys"
            case schemaStatusDetails = "schemaStatusDetails"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct SchemaAnalysisRuleRequest: AWSEncodableShape {
        /// The name of the analysis rule schema that you are requesting.
        public let name: String
        /// The type of analysis rule schema that you are requesting.
        public let type: AnalysisRuleType

        public init(name: String, type: AnalysisRuleType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct SchemaStatusDetail: AWSDecodableShape {
        /// The analysis rule type for which the schema status has been evaluated.
        public let analysisRuleType: AnalysisRuleType?
        /// The configuration details of the schema analysis rule for the given type.
        public let configurations: [SchemaConfiguration]?
        /// The reasons why the schema status is set to its current state.
        public let reasons: [SchemaStatusReason]?
        /// The status of the schema.
        public let status: SchemaStatus

        public init(analysisRuleType: AnalysisRuleType? = nil, configurations: [SchemaConfiguration]? = nil, reasons: [SchemaStatusReason]? = nil, status: SchemaStatus) {
            self.analysisRuleType = analysisRuleType
            self.configurations = configurations
            self.reasons = reasons
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRuleType = "analysisRuleType"
            case configurations = "configurations"
            case reasons = "reasons"
            case status = "status"
        }
    }

    public struct SchemaStatusReason: AWSDecodableShape {
        /// The schema status reason code.
        public let code: SchemaStatusReasonCode
        /// An explanation of the schema status reason code.
        public let message: String

        public init(code: SchemaStatusReasonCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct SchemaSummary: AWSDecodableShape {
        /// The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.
        public let analysisMethod: AnalysisMethod?
        /// The types of analysis rules that are associated with this schema object.
        public let analysisRuleTypes: [AnalysisRuleType]
        /// The unique ARN for the collaboration that the schema belongs to.
        public let collaborationArn: String
        /// The unique ID for the collaboration that the schema belongs to.
        public let collaborationId: String
        /// The time the schema object was created.
        public let createTime: Date
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        public let creatorAccountId: String
        /// The name for the schema object.
        public let name: String
        /// The type of schema object. The only valid schema type is currently `TABLE`.
        public let type: SchemaType
        /// The time the schema object was last updated.
        public let updateTime: Date

        public init(analysisMethod: AnalysisMethod? = nil, analysisRuleTypes: [AnalysisRuleType], collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, name: String, type: SchemaType, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.name = name
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case name = "name"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct StartProtectedQueryInput: AWSEncodableShape {
        /// A unique identifier for the membership to run this query against. Currently accepts a membership ID.
        public let membershipIdentifier: String
        /// The details needed to write the query results.
        public let resultConfiguration: ProtectedQueryResultConfiguration?
        /// The protected SQL query parameters.
        public let sqlParameters: ProtectedQuerySQLParameters
        /// The type of the protected query to be started.
        public let type: ProtectedQueryType

        public init(membershipIdentifier: String, resultConfiguration: ProtectedQueryResultConfiguration? = nil, sqlParameters: ProtectedQuerySQLParameters, type: ProtectedQueryType) {
            self.membershipIdentifier = membershipIdentifier
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.resultConfiguration, forKey: .resultConfiguration)
            try container.encode(self.sqlParameters, forKey: .sqlParameters)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.resultConfiguration?.validate(name: "\(name).resultConfiguration")
            try self.sqlParameters.validate(name: "\(name).sqlParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case resultConfiguration = "resultConfiguration"
            case sqlParameters = "sqlParameters"
            case type = "type"
        }
    }

    public struct StartProtectedQueryOutput: AWSDecodableShape {
        /// The protected query.
        public let protectedQuery: ProtectedQuery

        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to tag.
        public let resourceArn: String
        /// A map of objects specifying each key name and value.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
        public let resourceArn: String
        /// A list of key names of tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnalysisTemplateInput: AWSEncodableShape {
        /// The identifier for the analysis template resource.
        public let analysisTemplateIdentifier: String
        /// A new description for the analysis template.
        public let description: String?
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        public init(analysisTemplateIdentifier: String, description: String? = nil, membershipIdentifier: String) {
            self.analysisTemplateIdentifier = analysisTemplateIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateIdentifier, key: "analysisTemplateIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template.
        public let analysisTemplate: AnalysisTemplate

        public init(analysisTemplate: AnalysisTemplate) {
            self.analysisTemplate = analysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplate = "analysisTemplate"
        }
    }

    public struct UpdateCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String
        /// A description of the collaboration.
        public let description: String?
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String?

        public init(collaborationIdentifier: String, description: String? = nil, name: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateCollaborationOutput: AWSDecodableShape {
        /// The entire collaboration that has been updated.
        public let collaboration: Collaboration

        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct UpdateConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured audience model association that you want to update.
        public let configuredAudienceModelAssociationIdentifier: String
        /// A new description for the configured audience model association.
        public let description: String?
        /// A unique identifier of the membership that contains the configured audience model association that you want to update.
        public let membershipIdentifier: String
        /// A new name for the configured audience model association.
        public let name: String?

        public init(configuredAudienceModelAssociationIdentifier: String, description: String? = nil, membershipIdentifier: String, name: String? = nil) {
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// Details about the configured audience model association that you updated.
        public let configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation

        public init(configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation) {
            self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociation = "configuredAudienceModelAssociation"
        }
    }

    public struct UpdateConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The new analysis rule policy for the configured table analysis rule.
        public let analysisRulePolicy: ConfiguredTableAnalysisRulePolicy
        /// The analysis rule type to be updated. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        public init(analysisRulePolicy: ConfiguredTableAnalysisRulePolicy, analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
        }
    }

    public struct UpdateConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire updated analysis rule.
        public let analysisRule: ConfiguredTableAnalysisRule

        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct UpdateConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique identifier for the configured table association to update. Currently accepts the configured table association ID.
        public let configuredTableAssociationIdentifier: String
        /// A new description for the configured table association.
        public let description: String?
        /// The unique ID for the membership that the configured table association belongs to.
        public let membershipIdentifier: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String?

        public init(configuredTableAssociationIdentifier: String, description: String? = nil, membershipIdentifier: String, roleArn: String? = nil) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire updated configured table association.
        public let configuredTableAssociation: ConfiguredTableAssociation

        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct UpdateConfiguredTableInput: AWSEncodableShape {
        /// The identifier for the configured table to update. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String
        /// A new description for the configured table.
        public let description: String?
        /// A new name for the configured table.
        public let name: String?

        public init(configuredTableIdentifier: String, description: String? = nil, name: String? = nil) {
            self.configuredTableIdentifier = configuredTableIdentifier
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateConfiguredTableOutput: AWSDecodableShape {
        /// The updated configured table.
        public let configuredTable: ConfiguredTable

        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct UpdateMembershipInput: AWSEncodableShape {
        /// The default protected query result configuration as specified by the member who can receive results.
        public let defaultResultConfiguration: MembershipProtectedQueryResultConfiguration?
        /// The unique identifier of the membership.
        public let membershipIdentifier: String
        /// An indicator as to whether query logging has been enabled or disabled for the membership.
        public let queryLogStatus: MembershipQueryLogStatus?

        public init(defaultResultConfiguration: MembershipProtectedQueryResultConfiguration? = nil, membershipIdentifier: String, queryLogStatus: MembershipQueryLogStatus? = nil) {
            self.defaultResultConfiguration = defaultResultConfiguration
            self.membershipIdentifier = membershipIdentifier
            self.queryLogStatus = queryLogStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.defaultResultConfiguration, forKey: .defaultResultConfiguration)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.queryLogStatus, forKey: .queryLogStatus)
        }

        public func validate(name: String) throws {
            try self.defaultResultConfiguration?.validate(name: "\(name).defaultResultConfiguration")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultResultConfiguration = "defaultResultConfiguration"
            case queryLogStatus = "queryLogStatus"
        }
    }

    public struct UpdateMembershipOutput: AWSDecodableShape {
        public let membership: Membership

        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct UpdatePrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is updated in the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateUpdateParameters?
        /// A unique identifier for your privacy budget template that you want to update.
        public let privacyBudgetTemplateIdentifier: String
        /// Specifies the type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType

        public init(membershipIdentifier: String, parameters: PrivacyBudgetTemplateUpdateParameters? = nil, privacyBudgetTemplateIdentifier: String, privacyBudgetType: PrivacyBudgetType) {
            self.membershipIdentifier = membershipIdentifier
            self.parameters = parameters
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
            self.privacyBudgetType = privacyBudgetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
            try container.encode(self.privacyBudgetType, forKey: .privacyBudgetType)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.parameters?.validate(name: "\(name).parameters")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
        }
    }

    public struct UpdatePrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// Summary of the privacy budget template.
        public let privacyBudgetTemplate: PrivacyBudgetTemplate

        public init(privacyBudgetTemplate: PrivacyBudgetTemplate) {
            self.privacyBudgetTemplate = privacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case privacyBudgetTemplate = "privacyBudgetTemplate"
        }
    }

    public struct UpdateProtectedQueryInput: AWSEncodableShape {
        /// The identifier for a member of a protected query instance.
        public let membershipIdentifier: String
        /// The identifier for a protected query instance.
        public let protectedQueryIdentifier: String
        /// The target status of a query. Used to update the execution status of a currently running query.
        public let targetStatus: TargetProtectedQueryStatus

        public init(membershipIdentifier: String, protectedQueryIdentifier: String, targetStatus: TargetProtectedQueryStatus) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedQueryIdentifier = protectedQueryIdentifier
            self.targetStatus = targetStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedQueryIdentifier, key: "protectedQueryIdentifier")
            try container.encode(self.targetStatus, forKey: .targetStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, max: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, min: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetStatus = "targetStatus"
        }
    }

    public struct UpdateProtectedQueryOutput: AWSDecodableShape {
        /// The protected query output.
        public let protectedQuery: ProtectedQuery

        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct AnalysisRulePolicy: AWSDecodableShape {
        /// Controls on the query specifications that can be run on configured table.
        public let v1: AnalysisRulePolicyV1?

        public init(v1: AnalysisRulePolicyV1? = nil) {
            self.v1 = v1
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct AnalysisSource: AWSEncodableShape & AWSDecodableShape {
        /// The query text.
        public let text: String?

        public init(text: String? = nil) {
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.text, name: "text", parent: name, max: 90000)
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct ConfiguredTableAnalysisRulePolicy: AWSEncodableShape & AWSDecodableShape {
        /// Controls on the query specifications that can be run on a configured table.
        public let v1: ConfiguredTableAnalysisRulePolicyV1?

        public init(v1: ConfiguredTableAnalysisRulePolicyV1? = nil) {
            self.v1 = v1
        }

        public func validate(name: String) throws {
            try self.v1?.validate(name: "\(name).v1")
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct MembershipProtectedQueryOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let s3: ProtectedQueryS3OutputConfiguration?

        public init(s3: ProtectedQueryS3OutputConfiguration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct PreviewPrivacyImpactParametersInput: AWSEncodableShape {
        /// An array that specifies the epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyPreviewParametersInput?

        public init(differentialPrivacy: DifferentialPrivacyPreviewParametersInput? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        public func validate(name: String) throws {
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudget: AWSDecodableShape {
        /// An object that specifies the epsilon parameter and the utility in terms of total aggregations, as well as the remaining aggregations available.
        public let differentialPrivacy: DifferentialPrivacyPrivacyBudget?

        public init(differentialPrivacy: DifferentialPrivacyPrivacyBudget? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudgetTemplateParametersInput: AWSEncodableShape {
        /// An object that specifies the epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyTemplateParametersInput?

        public init(differentialPrivacy: DifferentialPrivacyTemplateParametersInput? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        public func validate(name: String) throws {
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudgetTemplateParametersOutput: AWSDecodableShape {
        /// The epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyTemplateParametersOutput?

        public init(differentialPrivacy: DifferentialPrivacyTemplateParametersOutput? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudgetTemplateUpdateParameters: AWSEncodableShape {
        /// An object that specifies the new values for the epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyTemplateUpdateParameters?

        public init(differentialPrivacy: DifferentialPrivacyTemplateUpdateParameters? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        public func validate(name: String) throws {
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyImpact: AWSDecodableShape {
        /// An object that lists the number and type of aggregation functions you can perform.
        public let differentialPrivacy: DifferentialPrivacyPrivacyImpact?

        public init(differentialPrivacy: DifferentialPrivacyPrivacyImpact? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct ProtectedQueryOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Required configuration for a protected query with an `S3` output type.
        public let s3: ProtectedQueryS3OutputConfiguration?

        public init(s3: ProtectedQueryS3OutputConfiguration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct TableReference: AWSEncodableShape & AWSDecodableShape {
        /// If present, a reference to the Glue table referred to by this table reference.
        public let glue: GlueTableReference?

        public init(glue: GlueTableReference? = nil) {
            self.glue = glue
        }

        public func validate(name: String) throws {
            try self.glue?.validate(name: "\(name).glue")
        }

        private enum CodingKeys: String, CodingKey {
            case glue = "glue"
        }
    }
}

// MARK: - Errors

/// Error enum for CleanRooms
public struct CleanRoomsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CleanRooms
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Caller does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request denied because service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the specified constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension CleanRoomsErrorType: Equatable {
    public static func == (lhs: CleanRoomsErrorType, rhs: CleanRoomsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CleanRoomsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
