//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension CleanRooms {
    // MARK: Enums

    public enum AccessDeniedExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case insufficientPermissions = "INSUFFICIENT_PERMISSIONS"
        public var description: String { return self.rawValue }
    }

    public enum AdditionalAnalyses: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowed = "ALLOWED"
        case notAllowed = "NOT_ALLOWED"
        case required = "REQUIRED"
        public var description: String { return self.rawValue }
    }

    public enum AggregateFunctionName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "AVG"
        case count = "COUNT"
        case countDistinct = "COUNT_DISTINCT"
        case sum = "SUM"
        case sumDistinct = "SUM_DISTINCT"
        public var description: String { return self.rawValue }
    }

    public enum AggregationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case countDistinct = "COUNT_DISTINCT"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pyspark10 = "PYSPARK_1_0"
        case sql = "SQL"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directJob = "DIRECT_JOB"
        case directQuery = "DIRECT_QUERY"
        case multiple = "MULTIPLE"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisRuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aggregation = "AGGREGATION"
        case custom = "CUSTOM"
        case idMappingTable = "ID_MAPPING_TABLE"
        case list = "LIST"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisTemplateValidationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalid = "INVALID"
        case unableToValidate = "UNABLE_TO_VALIDATE"
        case valid = "VALID"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisTemplateValidationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case differentialPrivacy = "DIFFERENTIAL_PRIVACY"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case additionalAnalysis = "ADDITIONAL_ANALYSIS"
        case directAnalysis = "DIRECT_ANALYSIS"
        public var description: String { return self.rawValue }
    }

    public enum AnalyticsEngine: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cleanRoomsSql = "CLEAN_ROOMS_SQL"
        case spark = "SPARK"
        public var description: String { return self.rawValue }
    }

    public enum CollaborationJobLogStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum CollaborationQueryLogStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ConfiguredTableAnalysisRuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aggregation = "AGGREGATION"
        case custom = "CUSTOM"
        case list = "LIST"
        public var description: String { return self.rawValue }
    }

    public enum ConfiguredTableAssociationAnalysisRuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aggregation = "AGGREGATION"
        case custom = "CUSTOM"
        case list = "LIST"
        public var description: String { return self.rawValue }
    }

    public enum ConflictExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case alreadyExists = "ALREADY_EXISTS"
        case invalidState = "INVALID_STATE"
        case subresourcesExist = "SUBRESOURCES_EXIST"
        public var description: String { return self.rawValue }
    }

    public enum CustomMLMemberAbility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canReceiveInferenceOutput = "CAN_RECEIVE_INFERENCE_OUTPUT"
        case canReceiveModelOutput = "CAN_RECEIVE_MODEL_OUTPUT"
        public var description: String { return self.rawValue }
    }

    public enum DifferentialPrivacyAggregationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "AVG"
        case count = "COUNT"
        case countDistinct = "COUNT_DISTINCT"
        case stddev = "STDDEV"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum FilterableMemberStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case invited = "INVITED"
        public var description: String { return self.rawValue }
    }

    public enum IdNamespaceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case source = "SOURCE"
        case target = "TARGET"
        public var description: String { return self.rawValue }
    }

    public enum JoinOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum JoinRequiredOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case queryRunner = "QUERY_RUNNER"
        public var description: String { return self.rawValue }
    }

    public enum MemberAbility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canQuery = "CAN_QUERY"
        case canReceiveResults = "CAN_RECEIVE_RESULTS"
        case canRunJob = "CAN_RUN_JOB"
        public var description: String { return self.rawValue }
    }

    public enum MemberStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case invited = "INVITED"
        case left = "LEFT"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum MembershipJobLogStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MembershipQueryLogStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum MembershipStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case collaborationDeleted = "COLLABORATION_DELETED"
        case removed = "REMOVED"
        public var description: String { return self.rawValue }
    }

    public enum ParameterType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case bigint = "BIGINT"
        case binary = "BINARY"
        case boolean = "BOOLEAN"
        case byte = "BYTE"
        case char = "CHAR"
        case character = "CHARACTER"
        case date = "DATE"
        case decimal = "DECIMAL"
        case double = "DOUBLE"
        case doublePrecision = "DOUBLE_PRECISION"
        case float = "FLOAT"
        case int = "INT"
        case integer = "INTEGER"
        case long = "LONG"
        case numeric = "NUMERIC"
        case real = "REAL"
        case short = "SHORT"
        case smallint = "SMALLINT"
        case string = "STRING"
        case time = "TIME"
        case timestamp = "TIMESTAMP"
        case timestampLtz = "TIMESTAMP_LTZ"
        case timestampNtz = "TIMESTAMP_NTZ"
        case timestamptz = "TIMESTAMPTZ"
        case timetz = "TIMETZ"
        case tinyint = "TINYINT"
        case varbyte = "VARBYTE"
        case varchar = "VARCHAR"
        public var description: String { return self.rawValue }
    }

    public enum PrivacyBudgetTemplateAutoRefresh: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case calendarMonth = "CALENDAR_MONTH"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum PrivacyBudgetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case differentialPrivacy = "DIFFERENTIAL_PRIVACY"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedJobAnalysisType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directAnalysis = "DIRECT_ANALYSIS"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case failed = "FAILED"
        case started = "STARTED"
        case submitted = "SUBMITTED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedJobType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case pyspark = "PYSPARK"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedQueryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        case cancelling = "CANCELLING"
        case failed = "FAILED"
        case started = "STARTED"
        case submitted = "SUBMITTED"
        case success = "SUCCESS"
        case timedOut = "TIMED_OUT"
        public var description: String { return self.rawValue }
    }

    public enum ProtectedQueryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case sql = "SQL"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case collaboration = "COLLABORATION"
        case configuredTable = "CONFIGURED_TABLE"
        case configuredTableAssociation = "CONFIGURED_TABLE_ASSOCIATION"
        case membership = "MEMBERSHIP"
        public var description: String { return self.rawValue }
    }

    public enum ResultFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum ScalarFunctions: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case abs = "ABS"
        case cast = "CAST"
        case ceiling = "CEILING"
        case coalesce = "COALESCE"
        case convert = "CONVERT"
        case currentDate = "CURRENT_DATE"
        case dateadd = "DATEADD"
        case extract = "EXTRACT"
        case floor = "FLOOR"
        case getdate = "GETDATE"
        case ln = "LN"
        case log = "LOG"
        case lower = "LOWER"
        case round = "ROUND"
        case rtrim = "RTRIM"
        case sqrt = "SQRT"
        case substring = "SUBSTRING"
        case toChar = "TO_CHAR"
        case toDate = "TO_DATE"
        case toNumber = "TO_NUMBER"
        case toTimestamp = "TO_TIMESTAMP"
        case trim = "TRIM"
        case trunc = "TRUNC"
        case upper = "UPPER"
        public var description: String { return self.rawValue }
    }

    public enum SchemaConfiguration: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case differentialPrivacy = "DIFFERENTIAL_PRIVACY"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notReady = "NOT_READY"
        case ready = "READY"
        public var description: String { return self.rawValue }
    }

    public enum SchemaStatusReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case additionalAnalysesNotAllowed = "ADDITIONAL_ANALYSES_NOT_ALLOWED"
        case additionalAnalysesNotConfigured = "ADDITIONAL_ANALYSES_NOT_CONFIGURED"
        case analysisProvidersNotConfigured = "ANALYSIS_PROVIDERS_NOT_CONFIGURED"
        case analysisRuleMissing = "ANALYSIS_RULE_MISSING"
        case analysisRuleTypesNotCompatible = "ANALYSIS_RULE_TYPES_NOT_COMPATIBLE"
        case analysisTemplatesNotConfigured = "ANALYSIS_TEMPLATES_NOT_CONFIGURED"
        case collaborationAnalysisRuleNotConfigured = "COLLABORATION_ANALYSIS_RULE_NOT_CONFIGURED"
        case differentialPrivacyPolicyNotConfigured = "DIFFERENTIAL_PRIVACY_POLICY_NOT_CONFIGURED"
        case idMappingTableNotPopulated = "ID_MAPPING_TABLE_NOT_POPULATED"
        case resultReceiversNotAllowed = "RESULT_RECEIVERS_NOT_ALLOWED"
        case resultReceiversNotConfigured = "RESULT_RECEIVERS_NOT_CONFIGURED"
        public var description: String { return self.rawValue }
    }

    public enum SchemaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case idMappingTable = "ID_MAPPING_TABLE"
        case table = "TABLE"
        public var description: String { return self.rawValue }
    }

    public enum SelectedAnalysisMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case directJob = "DIRECT_JOB"
        case directQuery = "DIRECT_QUERY"
        public var description: String { return self.rawValue }
    }

    public enum TargetProtectedJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        public var description: String { return self.rawValue }
    }

    public enum TargetProtectedQueryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cancelled = "CANCELLED"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case fieldValidationFailed = "FIELD_VALIDATION_FAILED"
        case iamSynchronizationDelay = "IAM_SYNCHRONIZATION_DELAY"
        case invalidConfiguration = "INVALID_CONFIGURATION"
        case invalidQuery = "INVALID_QUERY"
        public var description: String { return self.rawValue }
    }

    public enum WorkerComputeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cr1x = "CR.1X"
        case cr4x = "CR.4X"
        public var description: String { return self.rawValue }
    }

    public enum AnalysisRulePolicyV1: AWSDecodableShape, Sendable {
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(AnalysisRuleAggregation)
        /// Analysis rule type that enables custom SQL queries on a configured table.
        case custom(AnalysisRuleCustom)
        /// The ID mapping table.
        case idMappingTable(AnalysisRuleIdMappingTable)
        /// Analysis rule type that enables only list queries on a configured table.
        case list(AnalysisRuleList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(AnalysisRuleAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .custom:
                let value = try container.decode(AnalysisRuleCustom.self, forKey: .custom)
                self = .custom(value)
            case .idMappingTable:
                let value = try container.decode(AnalysisRuleIdMappingTable.self, forKey: .idMappingTable)
                self = .idMappingTable(value)
            case .list:
                let value = try container.decode(AnalysisRuleList.self, forKey: .list)
                self = .list(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case custom = "custom"
            case idMappingTable = "idMappingTable"
            case list = "list"
        }
    }

    public enum AnalysisSource: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  The artifacts of the analysis source.
        case artifacts(AnalysisTemplateArtifacts)
        /// The query text.
        case text(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .artifacts:
                let value = try container.decode(AnalysisTemplateArtifacts.self, forKey: .artifacts)
                self = .artifacts(value)
            case .text:
                let value = try container.decode(String.self, forKey: .text)
                self = .text(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .artifacts(let value):
                try container.encode(value, forKey: .artifacts)
            case .text(let value):
                try container.encode(value, forKey: .text)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .artifacts(let value):
                try value.validate(name: "\(name).artifacts")
            case .text(let value):
                try self.validate(value, name: "text", parent: name, max: 90000)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts = "artifacts"
            case text = "text"
        }
    }

    public enum ConfiguredTableAnalysisRulePolicyV1: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(AnalysisRuleAggregation)
        case custom(AnalysisRuleCustom)
        /// Analysis rule type that enables only list queries on a configured table.
        case list(AnalysisRuleList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(AnalysisRuleAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .custom:
                let value = try container.decode(AnalysisRuleCustom.self, forKey: .custom)
                self = .custom(value)
            case .list:
                let value = try container.decode(AnalysisRuleList.self, forKey: .list)
                self = .list(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .aggregation(let value):
                try container.encode(value, forKey: .aggregation)
            case .custom(let value):
                try container.encode(value, forKey: .custom)
            case .list(let value):
                try container.encode(value, forKey: .list)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .aggregation(let value):
                try value.validate(name: "\(name).aggregation")
            case .custom(let value):
                try value.validate(name: "\(name).custom")
            case .list(let value):
                try value.validate(name: "\(name).list")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case custom = "custom"
            case list = "list"
        }
    }

    public enum ConfiguredTableAssociationAnalysisRulePolicyV1: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(ConfiguredTableAssociationAnalysisRuleAggregation)
        ///  Analysis rule type that enables the table owner to approve custom SQL queries on their configured tables. It supports differential privacy.
        case custom(ConfiguredTableAssociationAnalysisRuleCustom)
        ///  Analysis rule type that enables only list queries on a configured table.
        case list(ConfiguredTableAssociationAnalysisRuleList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(ConfiguredTableAssociationAnalysisRuleAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .custom:
                let value = try container.decode(ConfiguredTableAssociationAnalysisRuleCustom.self, forKey: .custom)
                self = .custom(value)
            case .list:
                let value = try container.decode(ConfiguredTableAssociationAnalysisRuleList.self, forKey: .list)
                self = .list(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .aggregation(let value):
                try container.encode(value, forKey: .aggregation)
            case .custom(let value):
                try container.encode(value, forKey: .custom)
            case .list(let value):
                try container.encode(value, forKey: .list)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .aggregation(let value):
                try value.validate(name: "\(name).aggregation")
            case .custom(let value):
                try value.validate(name: "\(name).custom")
            case .list(let value):
                try value.validate(name: "\(name).list")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case custom = "custom"
            case list = "list"
        }
    }

    public enum ConsolidatedPolicyV1: AWSDecodableShape, Sendable {
        ///  The aggregation setting for the consolidated policy.
        case aggregation(ConsolidatedPolicyAggregation)
        ///  Custom policy
        case custom(ConsolidatedPolicyCustom)
        ///  The list of consolidated policies.
        case list(ConsolidatedPolicyList)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .aggregation:
                let value = try container.decode(ConsolidatedPolicyAggregation.self, forKey: .aggregation)
                self = .aggregation(value)
            case .custom:
                let value = try container.decode(ConsolidatedPolicyCustom.self, forKey: .custom)
                self = .custom(value)
            case .list:
                let value = try container.decode(ConsolidatedPolicyList.self, forKey: .list)
                self = .list(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case aggregation = "aggregation"
            case custom = "custom"
            case list = "list"
        }
    }

    public enum ProtectedJobOutput: AWSDecodableShape, Sendable {
        /// The list of member Amazon Web Services account(s) that received the results of the job.
        case memberList([ProtectedJobSingleMemberOutput])
        /// If present, the output for a protected job with an `S3` output type.
        case s3(ProtectedJobS3Output)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .memberList:
                let value = try container.decode([ProtectedJobSingleMemberOutput].self, forKey: .memberList)
                self = .memberList(value)
            case .s3:
                let value = try container.decode(ProtectedJobS3Output.self, forKey: .s3)
                self = .s3(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case memberList = "memberList"
            case s3 = "s3"
        }
    }

    public enum ProtectedJobOutputConfigurationOutput: AWSDecodableShape, Sendable {
        ///  The member output configuration for a protected job.
        case member(ProtectedJobMemberOutputConfigurationOutput)
        /// If present, the output for a protected job with an `S3` output type.
        case s3(ProtectedJobS3OutputConfigurationOutput)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .member:
                let value = try container.decode(ProtectedJobMemberOutputConfigurationOutput.self, forKey: .member)
                self = .member(value)
            case .s3:
                let value = try container.decode(ProtectedJobS3OutputConfigurationOutput.self, forKey: .s3)
                self = .s3(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
            case s3 = "s3"
        }
    }

    public enum ProtectedQueryOutput: AWSDecodableShape, Sendable {
        /// The list of member Amazon Web Services account(s) that received the results of the query.
        case memberList([ProtectedQuerySingleMemberOutput])
        /// If present, the output for a protected query with an `S3` output type.
        case s3(ProtectedQueryS3Output)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .memberList:
                let value = try container.decode([ProtectedQuerySingleMemberOutput].self, forKey: .memberList)
                self = .memberList(value)
            case .s3:
                let value = try container.decode(ProtectedQueryS3Output.self, forKey: .s3)
                self = .s3(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case memberList = "memberList"
            case s3 = "s3"
        }
    }

    public enum ProtectedQueryOutputConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  Required configuration for a protected query with a member output type.
        case member(ProtectedQueryMemberOutputConfiguration)
        /// Required configuration for a protected query with an s3 output type.
        case s3(ProtectedQueryS3OutputConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .member:
                let value = try container.decode(ProtectedQueryMemberOutputConfiguration.self, forKey: .member)
                self = .member(value)
            case .s3:
                let value = try container.decode(ProtectedQueryS3OutputConfiguration.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .member(let value):
                try container.encode(value, forKey: .member)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .member(let value):
                try value.validate(name: "\(name).member")
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
            case s3 = "s3"
        }
    }

    public enum TableReference: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  If present, a reference to the Athena table referred to by this table reference.
        case athena(AthenaTableReference)
        /// If present, a reference to the Glue table referred to by this table reference.
        case glue(GlueTableReference)
        ///  If present, a reference to the Snowflake table referred to by this table reference.
        case snowflake(SnowflakeTableReference)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .athena:
                let value = try container.decode(AthenaTableReference.self, forKey: .athena)
                self = .athena(value)
            case .glue:
                let value = try container.decode(GlueTableReference.self, forKey: .glue)
                self = .glue(value)
            case .snowflake:
                let value = try container.decode(SnowflakeTableReference.self, forKey: .snowflake)
                self = .snowflake(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .athena(let value):
                try container.encode(value, forKey: .athena)
            case .glue(let value):
                try container.encode(value, forKey: .glue)
            case .snowflake(let value):
                try container.encode(value, forKey: .snowflake)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .athena(let value):
                try value.validate(name: "\(name).athena")
            case .glue(let value):
                try value.validate(name: "\(name).glue")
            case .snowflake(let value):
                try value.validate(name: "\(name).snowflake")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case athena = "athena"
            case glue = "glue"
            case snowflake = "snowflake"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let message: String?
        /// A reason code for the exception.
        public let reason: AccessDeniedExceptionReason?

        @inlinable
        public init(message: String? = nil, reason: AccessDeniedExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
        }
    }

    public struct AggregateColumn: AWSEncodableShape & AWSDecodableShape {
        /// Column names in configured table of aggregate columns.
        public let columnNames: [String]
        /// Aggregation function that can be applied to aggregate column in query.
        public let function: AggregateFunctionName

        @inlinable
        public init(columnNames: [String], function: AggregateFunctionName) {
            self.columnNames = columnNames
            self.function = function
        }

        public func validate(name: String) throws {
            try self.columnNames.forEach {
                try validate($0, name: "columnNames[]", parent: name, max: 127)
                try validate($0, name: "columnNames[]", parent: name, min: 1)
                try validate($0, name: "columnNames[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case columnNames = "columnNames"
            case function = "function"
        }
    }

    public struct AggregationConstraint: AWSEncodableShape & AWSDecodableShape {
        /// Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.
        public let columnName: String
        /// The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.
        public let minimum: Int
        /// The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.
        public let type: AggregationType

        @inlinable
        public init(columnName: String, minimum: Int, type: AggregationType) {
            self.columnName = columnName
            self.minimum = minimum
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 127)
            try self.validate(self.columnName, name: "columnName", parent: name, min: 1)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case minimum = "minimum"
            case type = "type"
        }
    }

    public struct AnalysisParameter: AWSEncodableShape & AWSDecodableShape {
        /// Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        public let defaultValue: String?
        /// The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        public let name: String
        /// The type of parameter.
        public let type: ParameterType

        @inlinable
        public init(defaultValue: String? = nil, name: String, type: ParameterType) {
            self.defaultValue = defaultValue
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 250)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "defaultValue"
            case name = "name"
            case type = "type"
        }
    }

    public struct AnalysisRule: AWSDecodableShape {
        /// The unique ID for the associated collaboration.
        public let collaborationId: String
        public let collaborationPolicy: ConfiguredTableAssociationAnalysisRulePolicy?
        ///  The consolidated policy for the analysis rule.
        public let consolidatedPolicy: ConsolidatedPolicy?
        /// The time the analysis rule was created.
        public let createTime: Date
        /// The name for the analysis rule.
        public let name: String
        /// A policy that describes the associated data usage limitations.
        public let policy: AnalysisRulePolicy
        /// The type of analysis rule.
        public let type: AnalysisRuleType
        /// The time the analysis rule was last updated.
        public let updateTime: Date

        @inlinable
        public init(collaborationId: String, collaborationPolicy: ConfiguredTableAssociationAnalysisRulePolicy? = nil, consolidatedPolicy: ConsolidatedPolicy? = nil, createTime: Date, name: String, policy: AnalysisRulePolicy, type: AnalysisRuleType, updateTime: Date) {
            self.collaborationId = collaborationId
            self.collaborationPolicy = collaborationPolicy
            self.consolidatedPolicy = consolidatedPolicy
            self.createTime = createTime
            self.name = name
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationId = "collaborationId"
            case collaborationPolicy = "collaborationPolicy"
            case consolidatedPolicy = "consolidatedPolicy"
            case createTime = "createTime"
            case name = "name"
            case policy = "policy"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct AnalysisRuleAggregation: AWSEncodableShape & AWSDecodableShape {
        ///  An indicator as to whether additional analyses (such as Clean Rooms ML) can be applied to the output of the direct query.  The additionalAnalyses parameter is currently supported for the list analysis rule (AnalysisRuleList) and the custom analysis rule (AnalysisRuleCustom).
        public let additionalAnalyses: AdditionalAnalyses?
        /// The columns that query runners are allowed to use in aggregation queries.
        public let aggregateColumns: [AggregateColumn]
        /// Which logical operators (if any) are to be used in an INNER JOIN match condition. Default is AND.
        public let allowedJoinOperators: [JoinOperator]?
        /// The columns that query runners are allowed to select, group by, or filter by.
        public let dimensionColumns: [String]
        /// Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.
        public let joinColumns: [String]
        /// Control that requires member who runs query to do a join with their configured table and/or other configured table in query.
        public let joinRequired: JoinRequiredOption?
        /// Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.
        public let outputConstraints: [AggregationConstraint]
        /// Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.
        public let scalarFunctions: [ScalarFunctions]

        @inlinable
        public init(additionalAnalyses: AdditionalAnalyses? = nil, aggregateColumns: [AggregateColumn], allowedJoinOperators: [JoinOperator]? = nil, dimensionColumns: [String], joinColumns: [String], joinRequired: JoinRequiredOption? = nil, outputConstraints: [AggregationConstraint], scalarFunctions: [ScalarFunctions]) {
            self.additionalAnalyses = additionalAnalyses
            self.aggregateColumns = aggregateColumns
            self.allowedJoinOperators = allowedJoinOperators
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.joinRequired = joinRequired
            self.outputConstraints = outputConstraints
            self.scalarFunctions = scalarFunctions
        }

        public func validate(name: String) throws {
            try self.aggregateColumns.forEach {
                try $0.validate(name: "\(name).aggregateColumns[]")
            }
            try self.validate(self.allowedJoinOperators, name: "allowedJoinOperators", parent: name, max: 2)
            try self.dimensionColumns.forEach {
                try validate($0, name: "dimensionColumns[]", parent: name, max: 127)
                try validate($0, name: "dimensionColumns[]", parent: name, min: 1)
                try validate($0, name: "dimensionColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.joinColumns.forEach {
                try validate($0, name: "joinColumns[]", parent: name, max: 127)
                try validate($0, name: "joinColumns[]", parent: name, min: 1)
                try validate($0, name: "joinColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.outputConstraints.forEach {
                try $0.validate(name: "\(name).outputConstraints[]")
            }
            try self.validate(self.outputConstraints, name: "outputConstraints", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAnalyses = "additionalAnalyses"
            case aggregateColumns = "aggregateColumns"
            case allowedJoinOperators = "allowedJoinOperators"
            case dimensionColumns = "dimensionColumns"
            case joinColumns = "joinColumns"
            case joinRequired = "joinRequired"
            case outputConstraints = "outputConstraints"
            case scalarFunctions = "scalarFunctions"
        }
    }

    public struct AnalysisRuleCustom: AWSEncodableShape & AWSDecodableShape {
        ///  An indicator as to whether additional analyses (such as Clean Rooms ML) can be applied to the output of the direct query.
        public let additionalAnalyses: AdditionalAnalyses?
        /// The ARN of the analysis templates that are allowed by the custom analysis rule.
        public let allowedAnalyses: [String]
        /// The IDs of the Amazon Web Services accounts that are allowed to query by the custom analysis rule. Required when allowedAnalyses is ANY_QUERY.
        public let allowedAnalysisProviders: [String]?
        /// The differential privacy configuration.
        public let differentialPrivacy: DifferentialPrivacyConfiguration?
        ///  A list of columns that aren't allowed to be shown in the query output.
        public let disallowedOutputColumns: [String]?

        @inlinable
        public init(additionalAnalyses: AdditionalAnalyses? = nil, allowedAnalyses: [String], allowedAnalysisProviders: [String]? = nil, differentialPrivacy: DifferentialPrivacyConfiguration? = nil, disallowedOutputColumns: [String]? = nil) {
            self.additionalAnalyses = additionalAnalyses
            self.allowedAnalyses = allowedAnalyses
            self.allowedAnalysisProviders = allowedAnalysisProviders
            self.differentialPrivacy = differentialPrivacy
            self.disallowedOutputColumns = disallowedOutputColumns
        }

        public func validate(name: String) throws {
            try self.allowedAnalyses.forEach {
                try validate($0, name: "allowedAnalyses[]", parent: name, max: 200)
                try validate($0, name: "allowedAnalyses[]", parent: name, pattern: "^(ANY_QUERY|ANY_JOB|arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+)$")
            }
            try self.allowedAnalysisProviders?.forEach {
                try validate($0, name: "allowedAnalysisProviders[]", parent: name, max: 12)
                try validate($0, name: "allowedAnalysisProviders[]", parent: name, min: 12)
                try validate($0, name: "allowedAnalysisProviders[]", parent: name, pattern: "^\\d+$")
            }
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
            try self.disallowedOutputColumns?.forEach {
                try validate($0, name: "disallowedOutputColumns[]", parent: name, max: 127)
                try validate($0, name: "disallowedOutputColumns[]", parent: name, min: 1)
                try validate($0, name: "disallowedOutputColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAnalyses = "additionalAnalyses"
            case allowedAnalyses = "allowedAnalyses"
            case allowedAnalysisProviders = "allowedAnalysisProviders"
            case differentialPrivacy = "differentialPrivacy"
            case disallowedOutputColumns = "disallowedOutputColumns"
        }
    }

    public struct AnalysisRuleIdMappingTable: AWSDecodableShape {
        /// The columns that query runners are allowed to select, group by, or filter by.
        public let dimensionColumns: [String]?
        /// The columns that query runners are allowed to use in an INNER JOIN statement.
        public let joinColumns: [String]
        /// The query constraints of the analysis rule ID mapping table.
        public let queryConstraints: [QueryConstraint]

        @inlinable
        public init(dimensionColumns: [String]? = nil, joinColumns: [String], queryConstraints: [QueryConstraint]) {
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.queryConstraints = queryConstraints
        }

        private enum CodingKeys: String, CodingKey {
            case dimensionColumns = "dimensionColumns"
            case joinColumns = "joinColumns"
            case queryConstraints = "queryConstraints"
        }
    }

    public struct AnalysisRuleList: AWSEncodableShape & AWSDecodableShape {
        ///  An indicator as to whether additional analyses (such as Clean Rooms ML) can be applied to the output of the direct query.
        public let additionalAnalyses: AdditionalAnalyses?
        /// The logical operators (if any) that are to be used in an INNER JOIN match condition. Default is AND.
        public let allowedJoinOperators: [JoinOperator]?
        /// Columns that can be used to join a configured table with the table of the member who can query and other members' configured tables.
        public let joinColumns: [String]
        /// Columns that can be listed in the output.
        public let listColumns: [String]

        @inlinable
        public init(additionalAnalyses: AdditionalAnalyses? = nil, allowedJoinOperators: [JoinOperator]? = nil, joinColumns: [String], listColumns: [String]) {
            self.additionalAnalyses = additionalAnalyses
            self.allowedJoinOperators = allowedJoinOperators
            self.joinColumns = joinColumns
            self.listColumns = listColumns
        }

        public func validate(name: String) throws {
            try self.validate(self.allowedJoinOperators, name: "allowedJoinOperators", parent: name, max: 2)
            try self.joinColumns.forEach {
                try validate($0, name: "joinColumns[]", parent: name, max: 127)
                try validate($0, name: "joinColumns[]", parent: name, min: 1)
                try validate($0, name: "joinColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.listColumns.forEach {
                try validate($0, name: "listColumns[]", parent: name, max: 127)
                try validate($0, name: "listColumns[]", parent: name, min: 1)
                try validate($0, name: "listColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAnalyses = "additionalAnalyses"
            case allowedJoinOperators = "allowedJoinOperators"
            case joinColumns = "joinColumns"
            case listColumns = "listColumns"
        }
    }

    public struct AnalysisSchema: AWSEncodableShape & AWSDecodableShape {
        /// The tables referenced in the analysis schema.
        public let referencedTables: [String]?

        @inlinable
        public init(referencedTables: [String]? = nil) {
            self.referencedTables = referencedTables
        }

        public func validate(name: String) throws {
            try self.referencedTables?.forEach {
                try validate($0, name: "referencedTables[]", parent: name, max: 128)
                try validate($0, name: "referencedTables[]", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case referencedTables = "referencedTables"
        }
    }

    public struct AnalysisTemplate: AWSDecodableShape {
        /// The parameters of the analysis template.
        public let analysisParameters: [AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis templates associated collaboration.
        public let collaborationArn: String
        /// The unique ID for the associated collaboration of the analysis template.
        public let collaborationId: String
        /// The time that the analysis template was created.
        public let createTime: Date
        /// The description of the analysis template.
        public let description: String?
        /// The format of the analysis template.
        public let format: AnalysisFormat
        /// The identifier for the analysis template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        public let membershipArn: String
        /// The identifier of a member who created the analysis template.
        public let membershipId: String
        /// The name of the analysis template.
        public let name: String
        /// The entire schema object.
        public let schema: AnalysisSchema
        /// The source of the analysis template.
        public let source: AnalysisSource
        ///  The source metadata for the analysis template.
        public let sourceMetadata: AnalysisSourceMetadata?
        /// The time that the analysis template was last updated.
        public let updateTime: Date
        /// Information about the validations performed on the analysis template.
        public let validations: [AnalysisTemplateValidationStatusDetail]?

        @inlinable
        public init(analysisParameters: [AnalysisParameter]? = nil, arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, format: AnalysisFormat, id: String, membershipArn: String, membershipId: String, name: String, schema: AnalysisSchema, source: AnalysisSource, sourceMetadata: AnalysisSourceMetadata? = nil, updateTime: Date, validations: [AnalysisTemplateValidationStatusDetail]? = nil) {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.format = format
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.schema = schema
            self.source = source
            self.sourceMetadata = sourceMetadata
            self.updateTime = updateTime
            self.validations = validations
        }

        private enum CodingKeys: String, CodingKey {
            case analysisParameters = "analysisParameters"
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case format = "format"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case schema = "schema"
            case source = "source"
            case sourceMetadata = "sourceMetadata"
            case updateTime = "updateTime"
            case validations = "validations"
        }
    }

    public struct AnalysisTemplateArtifact: AWSEncodableShape & AWSDecodableShape {
        ///  The artifact location.
        public let location: S3Location

        @inlinable
        public init(location: S3Location) {
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
        }
    }

    public struct AnalysisTemplateArtifactMetadata: AWSDecodableShape {
        ///  Additional artifact hashes for the analysis template.
        public let additionalArtifactHashes: [Hash]?
        ///  The hash of the entry point for the analysis template artifact metadata.
        public let entryPointHash: Hash

        @inlinable
        public init(additionalArtifactHashes: [Hash]? = nil, entryPointHash: Hash) {
            self.additionalArtifactHashes = additionalArtifactHashes
            self.entryPointHash = entryPointHash
        }

        private enum CodingKeys: String, CodingKey {
            case additionalArtifactHashes = "additionalArtifactHashes"
            case entryPointHash = "entryPointHash"
        }
    }

    public struct AnalysisTemplateArtifacts: AWSEncodableShape & AWSDecodableShape {
        ///  Additional artifacts for the analysis template.
        public let additionalArtifacts: [AnalysisTemplateArtifact]?
        ///  The entry point for the analysis template artifacts.
        public let entryPoint: AnalysisTemplateArtifact
        ///  The role ARN for the analysis template artifacts.
        public let roleArn: String

        @inlinable
        public init(additionalArtifacts: [AnalysisTemplateArtifact]? = nil, entryPoint: AnalysisTemplateArtifact, roleArn: String) {
            self.additionalArtifacts = additionalArtifacts
            self.entryPoint = entryPoint
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.additionalArtifacts, name: "additionalArtifacts", parent: name, max: 1)
            try self.validate(self.additionalArtifacts, name: "additionalArtifacts", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalArtifacts = "additionalArtifacts"
            case entryPoint = "entryPoint"
            case roleArn = "roleArn"
        }
    }

    public struct AnalysisTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis template summarys associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the analysis template summary belongs to. Currently accepts collaboration ID.
        public let collaborationId: String
        /// The time that the analysis template summary was created.
        public let createTime: Date
        /// The description of the analysis template.
        public let description: String?
        /// The identifier of the analysis template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// The name of the analysis template.
        public let name: String
        /// The time that the analysis template summary was last updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, id: String, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct AnalysisTemplateValidationStatusDetail: AWSDecodableShape {
        /// The reasons for the validation results.
        public let reasons: [AnalysisTemplateValidationStatusReason]?
        /// The status of the validation.
        public let status: AnalysisTemplateValidationStatus
        /// The type of validation that was performed.
        public let type: AnalysisTemplateValidationType

        @inlinable
        public init(reasons: [AnalysisTemplateValidationStatusReason]? = nil, status: AnalysisTemplateValidationStatus, type: AnalysisTemplateValidationType) {
            self.reasons = reasons
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case reasons = "reasons"
            case status = "status"
            case type = "type"
        }
    }

    public struct AnalysisTemplateValidationStatusReason: AWSDecodableShape {
        /// The validation message.
        public let message: String

        @inlinable
        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct AthenaTableReference: AWSEncodableShape & AWSDecodableShape {
        ///  The database name.
        public let databaseName: String
        ///  The output location for the Athena table.
        public let outputLocation: String?
        ///  The table reference.
        public let tableName: String
        ///  The workgroup of the Athena table reference.
        public let workGroup: String

        @inlinable
        public init(databaseName: String, outputLocation: String? = nil, tableName: String, workGroup: String) {
            self.databaseName = databaseName
            self.outputLocation = outputLocation
            self.tableName = tableName
            self.workGroup = workGroup
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 128)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_]+-)*([a-zA-Z0-9_]+))?$")
            try self.validate(self.outputLocation, name: "outputLocation", parent: name, max: 1024)
            try self.validate(self.outputLocation, name: "outputLocation", parent: name, min: 8)
            try self.validate(self.outputLocation, name: "outputLocation", parent: name, pattern: "^s3://[a-z0-9.-]{3,63}(.*)$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_]+)*([a-zA-Z0-9_]+))?$")
            try self.validate(self.workGroup, name: "workGroup", parent: name, max: 128)
            try self.validate(self.workGroup, name: "workGroup", parent: name, min: 1)
            try self.validate(self.workGroup, name: "workGroup", parent: name, pattern: "^([a-zA-Z0-9._-])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case outputLocation = "outputLocation"
            case tableName = "tableName"
            case workGroup = "workGroup"
        }
    }

    public struct BatchGetCollaborationAnalysisTemplateError: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// An error code for the error.
        public let code: String
        /// A description of why the call failed.
        public let message: String

        @inlinable
        public init(arn: String, code: String, message: String) {
            self.arn = arn
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case code = "code"
            case message = "message"
        }
    }

    public struct BatchGetCollaborationAnalysisTemplateInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public let analysisTemplateArns: [String]
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String

        @inlinable
        public init(analysisTemplateArns: [String], collaborationIdentifier: String) {
            self.analysisTemplateArns = analysisTemplateArns
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisTemplateArns, forKey: .analysisTemplateArns)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisTemplateArns.forEach {
                try validate($0, name: "analysisTemplateArns[]", parent: name, max: 200)
                try validate($0, name: "analysisTemplateArns[]", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+$")
            }
            try self.validate(self.analysisTemplateArns, name: "analysisTemplateArns", parent: name, max: 10)
            try self.validate(self.analysisTemplateArns, name: "analysisTemplateArns", parent: name, min: 1)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplateArns = "analysisTemplateArns"
        }
    }

    public struct BatchGetCollaborationAnalysisTemplateOutput: AWSDecodableShape {
        /// The retrieved list of analysis templates within a collaboration.
        public let collaborationAnalysisTemplates: [CollaborationAnalysisTemplate]
        /// Error reasons for collaboration analysis templates that could not be retrieved. One error is returned for every collaboration analysis template that could not be retrieved.
        public let errors: [BatchGetCollaborationAnalysisTemplateError]

        @inlinable
        public init(collaborationAnalysisTemplates: [CollaborationAnalysisTemplate], errors: [BatchGetCollaborationAnalysisTemplateError]) {
            self.collaborationAnalysisTemplates = collaborationAnalysisTemplates
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationAnalysisTemplates = "collaborationAnalysisTemplates"
            case errors = "errors"
        }
    }

    public struct BatchGetSchemaAnalysisRuleError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// A description of why the call failed.
        public let message: String
        /// An error name for the error.
        public let name: String
        /// The analysis rule type.
        public let type: AnalysisRuleType

        @inlinable
        public init(code: String, message: String, name: String, type: AnalysisRuleType) {
            self.code = code
            self.message = message
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
            case type = "type"
        }
    }

    public struct BatchGetSchemaAnalysisRuleInput: AWSEncodableShape {
        /// The unique identifier of the collaboration that contains the schema analysis rule.
        public let collaborationIdentifier: String
        /// The information that's necessary to retrieve a schema analysis rule.
        public let schemaAnalysisRuleRequests: [SchemaAnalysisRuleRequest]

        @inlinable
        public init(collaborationIdentifier: String, schemaAnalysisRuleRequests: [SchemaAnalysisRuleRequest]) {
            self.collaborationIdentifier = collaborationIdentifier
            self.schemaAnalysisRuleRequests = schemaAnalysisRuleRequests
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encode(self.schemaAnalysisRuleRequests, forKey: .schemaAnalysisRuleRequests)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.schemaAnalysisRuleRequests.forEach {
                try $0.validate(name: "\(name).schemaAnalysisRuleRequests[]")
            }
            try self.validate(self.schemaAnalysisRuleRequests, name: "schemaAnalysisRuleRequests", parent: name, max: 25)
            try self.validate(self.schemaAnalysisRuleRequests, name: "schemaAnalysisRuleRequests", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case schemaAnalysisRuleRequests = "schemaAnalysisRuleRequests"
        }
    }

    public struct BatchGetSchemaAnalysisRuleOutput: AWSDecodableShape {
        /// The retrieved list of analysis rules.
        public let analysisRules: [AnalysisRule]
        /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
        public let errors: [BatchGetSchemaAnalysisRuleError]

        @inlinable
        public init(analysisRules: [AnalysisRule], errors: [BatchGetSchemaAnalysisRuleError]) {
            self.analysisRules = analysisRules
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRules = "analysisRules"
            case errors = "errors"
        }
    }

    public struct BatchGetSchemaError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// An error message for the error.
        public let message: String
        /// An error name for the error.
        public let name: String

        @inlinable
        public init(code: String, message: String, name: String) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
            case name = "name"
        }
    }

    public struct BatchGetSchemaInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schemas belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String
        /// The names for the schema objects to retrieve.
        public let names: [String]

        @inlinable
        public init(collaborationIdentifier: String, names: [String]) {
            self.collaborationIdentifier = collaborationIdentifier
            self.names = names
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encode(self.names, forKey: .names)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.names.forEach {
                try validate($0, name: "names[]", parent: name, max: 128)
                try validate($0, name: "names[]", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            }
            try self.validate(self.names, name: "names", parent: name, max: 25)
            try self.validate(self.names, name: "names", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case names = "names"
        }
    }

    public struct BatchGetSchemaOutput: AWSDecodableShape {
        /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
        public let errors: [BatchGetSchemaError]
        /// The retrieved list of schemas.
        public let schemas: [Schema]

        @inlinable
        public init(errors: [BatchGetSchemaError], schemas: [Schema]) {
            self.errors = errors
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case schemas = "schemas"
        }
    }

    public struct BilledJobResourceUtilization: AWSDecodableShape {
        ///  The number of Clean Rooms Processing Unit (CRPU) hours that have been billed.
        public let units: Double

        @inlinable
        public init(units: Double) {
            self.units = units
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
        }
    }

    public struct BilledResourceUtilization: AWSDecodableShape {
        ///  The number of Clean Rooms Processing Unit (CRPU) hours that have been billed.
        public let units: Double

        @inlinable
        public init(units: Double) {
            self.units = units
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
        }
    }

    public struct Collaboration: AWSDecodableShape {
        ///  The analytics engine for the collaboration.
        public let analyticsEngine: AnalyticsEngine?
        /// The unique ARN for the collaboration.
        public let arn: String
        /// The time when the collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// A display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The settings for client-side encryption for cryptographic computing.
        public let dataEncryptionMetadata: DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public let description: String?
        /// The unique ID for the collaboration.
        public let id: String
        /// An indicator as to whether job logging has been enabled or disabled  for the collaboration.  When ENABLED, Clean Rooms logs details about jobs run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let jobLogStatus: CollaborationJobLogStatus?
        /// The unique ARN for your membership within the collaboration.
        public let membershipArn: String?
        /// The unique ID for your membership within the collaboration.
        public let membershipId: String?
        /// The status of a member in a collaboration.
        public let memberStatus: MemberStatus
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration. When ENABLED, Clean Rooms logs details about queries run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let queryLogStatus: CollaborationQueryLogStatus
        /// The time the collaboration metadata was last updated.
        public let updateTime: Date

        @inlinable
        public init(analyticsEngine: AnalyticsEngine? = nil, arn: String, createTime: Date, creatorAccountId: String, creatorDisplayName: String, dataEncryptionMetadata: DataEncryptionMetadata? = nil, description: String? = nil, id: String, jobLogStatus: CollaborationJobLogStatus? = nil, membershipArn: String? = nil, membershipId: String? = nil, memberStatus: MemberStatus, name: String, queryLogStatus: CollaborationQueryLogStatus, updateTime: Date) {
            self.analyticsEngine = analyticsEngine
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.id = id
            self.jobLogStatus = jobLogStatus
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.memberStatus = memberStatus
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analyticsEngine = "analyticsEngine"
            case arn = "arn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case creatorDisplayName = "creatorDisplayName"
            case dataEncryptionMetadata = "dataEncryptionMetadata"
            case description = "description"
            case id = "id"
            case jobLogStatus = "jobLogStatus"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case memberStatus = "memberStatus"
            case name = "name"
            case queryLogStatus = "queryLogStatus"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationAnalysisTemplate: AWSDecodableShape {
        /// The analysis parameters that have been specified in the analysis template.
        public let analysisParameters: [AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis templates associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationId: String
        /// The time that the analysis template within a collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The description of the analysis template.
        public let description: String?
        /// The format of the analysis template in the collaboration.
        public let format: AnalysisFormat
        /// The identifier of the analysis template.
        public let id: String
        /// The name of the analysis template.
        public let name: String
        /// The entire schema object.
        public let schema: AnalysisSchema
        /// The source of the analysis template within a collaboration.
        public let source: AnalysisSource?
        ///  The source metadata for the collaboration analysis template.
        public let sourceMetadata: AnalysisSourceMetadata?
        /// The time that the analysis template in the collaboration was last updated.
        public let updateTime: Date
        /// The validations that were performed.
        public let validations: [AnalysisTemplateValidationStatusDetail]?

        @inlinable
        public init(analysisParameters: [AnalysisParameter]? = nil, arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, format: AnalysisFormat, id: String, name: String, schema: AnalysisSchema, source: AnalysisSource? = nil, sourceMetadata: AnalysisSourceMetadata? = nil, updateTime: Date, validations: [AnalysisTemplateValidationStatusDetail]? = nil) {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.format = format
            self.id = id
            self.name = name
            self.schema = schema
            self.source = source
            self.sourceMetadata = sourceMetadata
            self.updateTime = updateTime
            self.validations = validations
        }

        private enum CodingKeys: String, CodingKey {
            case analysisParameters = "analysisParameters"
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case format = "format"
            case id = "id"
            case name = "name"
            case schema = "schema"
            case source = "source"
            case sourceMetadata = "sourceMetadata"
            case updateTime = "updateTime"
            case validations = "validations"
        }
    }

    public struct CollaborationAnalysisTemplateSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the analysis template.
        public let arn: String
        /// The unique ARN for the analysis templates associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationId: String
        /// The time that the summary of the analysis template in a collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The description of the analysis template.
        public let description: String?
        /// The identifier of the analysis template.
        public let id: String
        /// The name of the analysis template.
        public let name: String
        /// The time that the summary of the analysis template in the collaboration was last updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationConfiguredAudienceModelAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The unique ARN for the configured audience model's associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        public let collaborationId: String
        /// The Amazon Resource Name (ARN) of the configure audience model.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The description of the configured audience model association.
        public let description: String?
        /// The identifier of the configured audience model association.
        public let id: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, configuredAudienceModelArn: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationConfiguredAudienceModelAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The unique ARN for the configured audience model's associated collaboration.
        public let collaborationArn: String
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        public let collaborationId: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The description of the configured audience model association.
        public let description: String?
        /// The identifier of the configured audience model association.
        public let id: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationIdNamespaceAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collaboration ID namespace association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains the collaboration ID namespace association.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains the collaboration ID namespace association.
        public let collaborationId: String
        /// The time at which the collaboration ID namespace association was created.
        public let createTime: Date
        /// The unique identifier of the Amazon Web Services account that created the collaboration ID namespace association.
        public let creatorAccountId: String
        /// The description of the collaboration ID namespace association.
        public let description: String?
        /// The unique identifier of the collaboration ID namespace association.
        public let id: String
        public let idMappingConfig: IdMappingConfig?
        /// The input reference configuration that's necessary to create the collaboration ID namespace association.
        public let inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig
        /// The input reference properties that are needed to create the collaboration ID namespace association.
        public let inputReferenceProperties: IdNamespaceAssociationInputReferenceProperties
        /// The name of the collaboration ID namespace association.
        public let name: String
        /// The most recent time at which the collaboration ID namespace was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, idMappingConfig: IdMappingConfig? = nil, inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig, inputReferenceProperties: IdNamespaceAssociationInputReferenceProperties, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.idMappingConfig = idMappingConfig
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case idMappingConfig = "idMappingConfig"
            case inputReferenceConfig = "inputReferenceConfig"
            case inputReferenceProperties = "inputReferenceProperties"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationIdNamespaceAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the collaboration ID namespace association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains this collaboration ID namespace association.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this collaboration ID namespace association.
        public let collaborationId: String
        /// The time at which the collaboration ID namespace association was created.
        public let createTime: Date
        /// The Amazon Web Services account that created this collaboration ID namespace association.
        public let creatorAccountId: String
        /// The description of the collaboration ID namepsace association.
        public let description: String?
        /// The unique identifier of the collaboration ID namespace association.
        public let id: String
        /// The input reference configuration that's used to create the collaboration ID namespace association.
        public let inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig
        /// The input reference properties that are used to create the collaboration ID namespace association.
        public let inputReferenceProperties: IdNamespaceAssociationInputReferencePropertiesSummary
        /// The name of the collaboration ID namespace association.
        public let name: String
        /// The most recent time at which the collaboration ID namespace association was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, description: String? = nil, id: String, inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig, inputReferenceProperties: IdNamespaceAssociationInputReferencePropertiesSummary, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case id = "id"
            case inputReferenceConfig = "inputReferenceConfig"
            case inputReferenceProperties = "inputReferenceProperties"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationPrivacyBudgetSummary: AWSDecodableShape {
        /// The includes epsilon provided and utility in terms of aggregations.
        public let budget: PrivacyBudget
        /// The ARN of the collaboration that includes this privacy budget.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that includes this privacy budget.
        public let collaborationId: String
        /// The time at which the privacy budget was created.
        public let createTime: Date
        /// The unique identifier of the account that created this privacy budget.
        public let creatorAccountId: String
        /// The unique identifier of the collaboration privacy budget.
        public let id: String
        /// The ARN of the collaboration privacy budget template.
        public let privacyBudgetTemplateArn: String
        /// The unique identifier of the collaboration privacy budget template.
        public let privacyBudgetTemplateId: String
        /// The type of privacy budget template.
        public let type: PrivacyBudgetType
        /// The most recent time at which the privacy budget was updated.
        public let updateTime: Date

        @inlinable
        public init(budget: PrivacyBudget, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, id: String, privacyBudgetTemplateArn: String, privacyBudgetTemplateId: String, type: PrivacyBudgetType, updateTime: Date) {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case budget = "budget"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case id = "id"
            case privacyBudgetTemplateArn = "privacyBudgetTemplateArn"
            case privacyBudgetTemplateId = "privacyBudgetTemplateId"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationPrivacyBudgetTemplate: AWSDecodableShape {
        /// The ARN of the collaboration privacy budget template.
        public let arn: String
        /// How often the privacy budget refreshes.  If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        public let autoRefresh: PrivacyBudgetTemplateAutoRefresh
        /// The ARN of the collaboration that includes this collaboration privacy budget template.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that includes this collaboration privacy budget template.
        public let collaborationId: String
        /// The time at which the collaboration privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the account that created this collaboration privacy budget template.
        public let creatorAccountId: String
        /// The unique identifier of the collaboration privacy budget template.
        public let id: String
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateParametersOutput
        /// The type of privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the collaboration privacy budget template was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, autoRefresh: PrivacyBudgetTemplateAutoRefresh, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, id: String, parameters: PrivacyBudgetTemplateParametersOutput, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case autoRefresh = "autoRefresh"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case id = "id"
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationPrivacyBudgetTemplateSummary: AWSDecodableShape {
        /// The ARN of the collaboration privacy budget template.
        public let arn: String
        /// The ARN of the collaboration that contains this collaboration privacy budget template.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this collaboration privacy budget template.
        public let collaborationId: String
        /// The time at which the collaboration privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the account that created this collaboration privacy budget template.
        public let creatorAccountId: String
        /// The unique identifier of the collaboration privacy budget template.
        public let id: String
        /// The type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the collaboration privacy budget template was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, id: String, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case id = "id"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct CollaborationSummary: AWSDecodableShape {
        ///  The analytics engine.
        public let analyticsEngine: AnalyticsEngine?
        /// The ARN of the collaboration.
        public let arn: String
        /// The time when the collaboration was created.
        public let createTime: Date
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let creatorAccountId: String
        /// The display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The identifier for the collaboration.
        public let id: String
        /// The ARN of a member in a collaboration.
        public let membershipArn: String?
        /// The identifier of a member in a collaboration.
        public let membershipId: String?
        /// The status of a member in a collaboration.
        public let memberStatus: MemberStatus
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String
        /// The time the collaboration metadata was last updated.
        public let updateTime: Date

        @inlinable
        public init(analyticsEngine: AnalyticsEngine? = nil, arn: String, createTime: Date, creatorAccountId: String, creatorDisplayName: String, id: String, membershipArn: String? = nil, membershipId: String? = nil, memberStatus: MemberStatus, name: String, updateTime: Date) {
            self.analyticsEngine = analyticsEngine
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.memberStatus = memberStatus
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analyticsEngine = "analyticsEngine"
            case arn = "arn"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case creatorDisplayName = "creatorDisplayName"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case memberStatus = "memberStatus"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct Column: AWSDecodableShape {
        /// The name of the column.
        public let name: String
        /// The type of the column.
        public let type: String

        @inlinable
        public init(name: String, type: String) {
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct ConfiguredAudienceModelAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains this configured audience model association.
        public let collaborationArn: String
        /// A unique identifier of the collaboration that contains this configured audience model association.
        public let collaborationId: String
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The description of the configured audience model association.
        public let description: String?
        /// A unique identifier of the configured audience model association.
        public let id: String
        /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration.
        public let manageResourcePolicies: Bool
        /// The Amazon Resource Name (ARN) of the membership that contains this configured audience model association.
        public let membershipArn: String
        /// A unique identifier for the membership that contains this configured audience model association.
        public let membershipId: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, id: String, manageResourcePolicies: Bool, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.manageResourcePolicies = manageResourcePolicies
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case manageResourcePolicies = "manageResourcePolicies"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredAudienceModelAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains the configured audience model association.
        public let collaborationArn: String
        /// A unique identifier of the collaboration that configured audience model is associated with.
        public let collaborationId: String
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        public let configuredAudienceModelArn: String
        /// The time at which the configured audience model association was created.
        public let createTime: Date
        /// The description of the configured audience model association.
        public let description: String?
        /// A unique identifier of the configured audience model association.
        public let id: String
        /// The Amazon Resource Name (ARN) of the membership that contains the configured audience model association.
        public let membershipArn: String
        /// A unique identifier of the membership that contains the configured audience model association.
        public let membershipId: String
        /// The name of the configured audience model association.
        public let name: String
        /// The most recent time at which the configured audience model association was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, configuredAudienceModelArn: String, createTime: Date, description: String? = nil, id: String, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTable: AWSDecodableShape {
        /// The columns within the underlying Glue table that can be utilized within collaborations.
        public let allowedColumns: [String]
        /// The analysis method for the configured table.  DIRECT_QUERY allows SQL queries to be run directly on this table.  DIRECT_JOB allows PySpark jobs to be run directly on this table.  MULTIPLE allows both SQL queries and PySpark jobs to be run directly on this table.
        public let analysisMethod: AnalysisMethod
        /// The types of analysis rules associated with this configured table. Currently, only one analysis rule may be associated with a configured table.
        public let analysisRuleTypes: [ConfiguredTableAnalysisRuleType]
        /// The unique ARN for the configured table.
        public let arn: String
        /// The time the configured table was created.
        public let createTime: Date
        /// A description for the configured table.
        public let description: String?
        /// The unique ID for the configured table.
        public let id: String
        /// A name for the configured table.
        public let name: String
        ///  The selected analysis methods for the configured table.
        public let selectedAnalysisMethods: [SelectedAnalysisMethod]?
        /// The table that this configured table represents.
        public let tableReference: TableReference
        /// The time the configured table was last updated
        public let updateTime: Date

        @inlinable
        public init(allowedColumns: [String], analysisMethod: AnalysisMethod, analysisRuleTypes: [ConfiguredTableAnalysisRuleType], arn: String, createTime: Date, description: String? = nil, id: String, name: String, selectedAnalysisMethods: [SelectedAnalysisMethod]? = nil, tableReference: TableReference, updateTime: Date) {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.name = name
            self.selectedAnalysisMethods = selectedAnalysisMethods
            self.tableReference = tableReference
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case allowedColumns = "allowedColumns"
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case name = "name"
            case selectedAnalysisMethods = "selectedAnalysisMethods"
            case tableReference = "tableReference"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAnalysisRule: AWSDecodableShape {
        /// The unique ARN for the configured table.
        public let configuredTableArn: String
        /// The unique ID for the configured table.
        public let configuredTableId: String
        /// The time the configured table analysis rule was created.
        public let createTime: Date
        /// The policy that controls SQL query rules.
        public let policy: ConfiguredTableAnalysisRulePolicy
        /// The type of configured table analysis rule.
        public let type: ConfiguredTableAnalysisRuleType
        /// The time the configured table analysis rule was last updated.
        public let updateTime: Date

        @inlinable
        public init(configuredTableArn: String, configuredTableId: String, createTime: Date, policy: ConfiguredTableAnalysisRulePolicy, type: ConfiguredTableAnalysisRuleType, updateTime: Date) {
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableArn = "configuredTableArn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case policy = "policy"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAssociation: AWSDecodableShape {
        ///  The analysis rule types for the configured table association.
        public let analysisRuleTypes: [ConfiguredTableAssociationAnalysisRuleType]?
        /// The unique ARN for the configured table association.
        public let arn: String
        /// The unique ARN for the configured table that the association refers to.
        public let configuredTableArn: String
        /// The unique ID for the configured table that the association refers to.
        public let configuredTableId: String
        /// The time the configured table association was created.
        public let createTime: Date
        /// A description of the configured table association.
        public let description: String?
        /// The unique ID for the configured table association.
        public let id: String
        /// The unique ARN for the membership this configured table association belongs to.
        public let membershipArn: String
        /// The unique ID for the membership this configured table association belongs to.
        public let membershipId: String
        /// The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.
        public let name: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String
        /// The time the configured table association was last updated.
        public let updateTime: Date

        @inlinable
        public init(analysisRuleTypes: [ConfiguredTableAssociationAnalysisRuleType]? = nil, arn: String, configuredTableArn: String, configuredTableId: String, createTime: Date, description: String? = nil, id: String, membershipArn: String, membershipId: String, name: String, roleArn: String, updateTime: Date) {
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.roleArn = roleArn
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case configuredTableArn = "configuredTableArn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case roleArn = "roleArn"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAssociationAnalysisRule: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the configured table association.
        public let configuredTableAssociationArn: String
        ///  The unique identifier for the configured table association.
        public let configuredTableAssociationId: String
        ///  The creation time of the configured table association analysis rule.
        public let createTime: Date
        ///  The membership identifier for the configured table association analysis rule.
        public let membershipIdentifier: String
        ///  The policy of the configured table association analysis rule.
        public let policy: ConfiguredTableAssociationAnalysisRulePolicy
        ///  The type of the configured table association analysis rule.
        public let type: ConfiguredTableAssociationAnalysisRuleType
        ///  The update time of the configured table association analysis rule.
        public let updateTime: Date

        @inlinable
        public init(configuredTableAssociationArn: String, configuredTableAssociationId: String, createTime: Date, membershipIdentifier: String, policy: ConfiguredTableAssociationAnalysisRulePolicy, type: ConfiguredTableAssociationAnalysisRuleType, updateTime: Date) {
            self.configuredTableAssociationArn = configuredTableAssociationArn
            self.configuredTableAssociationId = configuredTableAssociationId
            self.createTime = createTime
            self.membershipIdentifier = membershipIdentifier
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociationArn = "configuredTableAssociationArn"
            case configuredTableAssociationId = "configuredTableAssociationId"
            case createTime = "createTime"
            case membershipIdentifier = "membershipIdentifier"
            case policy = "policy"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableAssociationAnalysisRuleAggregation: AWSEncodableShape & AWSDecodableShape {
        ///  The list of resources or wildcards (ARNs) that are allowed to perform additional analysis on query output. The allowedAdditionalAnalyses parameter is currently supported for the list analysis rule (AnalysisRuleList) and the custom analysis rule (AnalysisRuleCustom).
        public let allowedAdditionalAnalyses: [String]?
        ///  The list of collaboration members who are allowed to receive results of queries run with this configured table.
        public let allowedResultReceivers: [String]?

        @inlinable
        public init(allowedAdditionalAnalyses: [String]? = nil, allowedResultReceivers: [String]? = nil) {
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedResultReceivers = allowedResultReceivers
        }

        public func validate(name: String) throws {
            try self.allowedAdditionalAnalyses?.forEach {
                try validate($0, name: "allowedAdditionalAnalyses[]", parent: name, max: 256)
                try validate($0, name: "allowedAdditionalAnalyses[]", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:([\\d]{12}|\\*):membership\\/[\\*\\d\\w-]+\\/configuredaudiencemodelassociation\\/[\\*\\d\\w-]+$|^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:([0-9]{12}|\\*):membership\\/[\\*\\d\\w-]+\\/configured-model-algorithm-association\\/([-a-zA-Z0-9_\\/.]+|\\*)$")
            }
            try self.validate(self.allowedAdditionalAnalyses, name: "allowedAdditionalAnalyses", parent: name, max: 25)
            try self.allowedResultReceivers?.forEach {
                try validate($0, name: "allowedResultReceivers[]", parent: name, max: 12)
                try validate($0, name: "allowedResultReceivers[]", parent: name, min: 12)
                try validate($0, name: "allowedResultReceivers[]", parent: name, pattern: "^\\d+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAdditionalAnalyses = "allowedAdditionalAnalyses"
            case allowedResultReceivers = "allowedResultReceivers"
        }
    }

    public struct ConfiguredTableAssociationAnalysisRuleCustom: AWSEncodableShape & AWSDecodableShape {
        ///  The list of resources or wildcards (ARNs) that are allowed to perform additional analysis on query output.
        public let allowedAdditionalAnalyses: [String]?
        ///  The list of collaboration members who are allowed to receive results of queries run with this configured table.
        public let allowedResultReceivers: [String]?

        @inlinable
        public init(allowedAdditionalAnalyses: [String]? = nil, allowedResultReceivers: [String]? = nil) {
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedResultReceivers = allowedResultReceivers
        }

        public func validate(name: String) throws {
            try self.allowedAdditionalAnalyses?.forEach {
                try validate($0, name: "allowedAdditionalAnalyses[]", parent: name, max: 256)
                try validate($0, name: "allowedAdditionalAnalyses[]", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:([\\d]{12}|\\*):membership\\/[\\*\\d\\w-]+\\/configuredaudiencemodelassociation\\/[\\*\\d\\w-]+$|^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:([0-9]{12}|\\*):membership\\/[\\*\\d\\w-]+\\/configured-model-algorithm-association\\/([-a-zA-Z0-9_\\/.]+|\\*)$")
            }
            try self.validate(self.allowedAdditionalAnalyses, name: "allowedAdditionalAnalyses", parent: name, max: 25)
            try self.allowedResultReceivers?.forEach {
                try validate($0, name: "allowedResultReceivers[]", parent: name, max: 12)
                try validate($0, name: "allowedResultReceivers[]", parent: name, min: 12)
                try validate($0, name: "allowedResultReceivers[]", parent: name, pattern: "^\\d+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAdditionalAnalyses = "allowedAdditionalAnalyses"
            case allowedResultReceivers = "allowedResultReceivers"
        }
    }

    public struct ConfiguredTableAssociationAnalysisRuleList: AWSEncodableShape & AWSDecodableShape {
        ///  The list of resources or wildcards (ARNs) that are allowed to perform additional analysis on query output.
        public let allowedAdditionalAnalyses: [String]?
        ///  The list of collaboration members who are allowed to receive results of queries run with this configured table.
        public let allowedResultReceivers: [String]?

        @inlinable
        public init(allowedAdditionalAnalyses: [String]? = nil, allowedResultReceivers: [String]? = nil) {
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedResultReceivers = allowedResultReceivers
        }

        public func validate(name: String) throws {
            try self.allowedAdditionalAnalyses?.forEach {
                try validate($0, name: "allowedAdditionalAnalyses[]", parent: name, max: 256)
                try validate($0, name: "allowedAdditionalAnalyses[]", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:([\\d]{12}|\\*):membership\\/[\\*\\d\\w-]+\\/configuredaudiencemodelassociation\\/[\\*\\d\\w-]+$|^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:([0-9]{12}|\\*):membership\\/[\\*\\d\\w-]+\\/configured-model-algorithm-association\\/([-a-zA-Z0-9_\\/.]+|\\*)$")
            }
            try self.validate(self.allowedAdditionalAnalyses, name: "allowedAdditionalAnalyses", parent: name, max: 25)
            try self.allowedResultReceivers?.forEach {
                try validate($0, name: "allowedResultReceivers[]", parent: name, max: 12)
                try validate($0, name: "allowedResultReceivers[]", parent: name, min: 12)
                try validate($0, name: "allowedResultReceivers[]", parent: name, pattern: "^\\d+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAdditionalAnalyses = "allowedAdditionalAnalyses"
            case allowedResultReceivers = "allowedResultReceivers"
        }
    }

    public struct ConfiguredTableAssociationSummary: AWSDecodableShape {
        /// The analysis rule types that are associated with the configured table  associations in this summary.
        public let analysisRuleTypes: [ConfiguredTableAssociationAnalysisRuleType]?
        /// The unique ARN for the configured table association.
        public let arn: String
        /// The unique configured table ID that this configured table association refers to.
        public let configuredTableId: String
        /// The time the configured table association was created.
        public let createTime: Date
        /// The unique ID for the configured table association.
        public let id: String
        /// The unique ARN for the membership that the configured table association belongs to.
        public let membershipArn: String
        /// The unique ID for the membership that the configured table association belongs to.
        public let membershipId: String
        /// The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.
        public let name: String
        /// The time the configured table association was last updated.
        public let updateTime: Date

        @inlinable
        public init(analysisRuleTypes: [ConfiguredTableAssociationAnalysisRuleType]? = nil, arn: String, configuredTableId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case configuredTableId = "configuredTableId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct ConfiguredTableSummary: AWSDecodableShape {
        /// The analysis method for the configured tables.   DIRECT_QUERY allows SQL queries to be run directly on this table.  DIRECT_JOB allows PySpark jobs to be run directly on this table.  MULTIPLE allows both SQL queries and PySpark jobs to be run directly on this table.
        public let analysisMethod: AnalysisMethod
        /// The types of analysis rules associated with this configured table.
        public let analysisRuleTypes: [ConfiguredTableAnalysisRuleType]
        /// The unique ARN of the configured table.
        public let arn: String
        /// The time the configured table was created.
        public let createTime: Date
        /// The unique ID of the configured table.
        public let id: String
        /// The name of the configured table.
        public let name: String
        ///  The selected analysis methods for the configured table summary.
        public let selectedAnalysisMethods: [SelectedAnalysisMethod]?
        /// The time the configured table was last updated.
        public let updateTime: Date

        @inlinable
        public init(analysisMethod: AnalysisMethod, analysisRuleTypes: [ConfiguredTableAnalysisRuleType], arn: String, createTime: Date, id: String, name: String, selectedAnalysisMethods: [SelectedAnalysisMethod]? = nil, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.name = name
            self.selectedAnalysisMethods = selectedAnalysisMethods
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case arn = "arn"
            case createTime = "createTime"
            case id = "id"
            case name = "name"
            case selectedAnalysisMethods = "selectedAnalysisMethods"
            case updateTime = "updateTime"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String?
        /// A reason code for the exception.
        public let reason: ConflictExceptionReason?
        /// The ID of the conflicting resource.
        public let resourceId: String?
        /// The type of the conflicting resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String? = nil, reason: ConflictExceptionReason? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.reason = reason
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case reason = "reason"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct ConsolidatedPolicyAggregation: AWSDecodableShape {
        ///  Additional analyses for the consolidated policy aggregation.
        public let additionalAnalyses: AdditionalAnalyses?
        ///  Aggregate columns in consolidated policy aggregation.
        public let aggregateColumns: [AggregateColumn]
        ///  The additional analyses allowed by the consolidated policy aggregation.
        public let allowedAdditionalAnalyses: [String]?
        ///  The allowed join operators.
        public let allowedJoinOperators: [JoinOperator]?
        ///  The allowed result receivers.
        public let allowedResultReceivers: [String]?
        ///  The dimension columns of the consolidated policy aggregation.
        public let dimensionColumns: [String]
        ///  The columns to join on.
        public let joinColumns: [String]
        ///  Join required
        public let joinRequired: JoinRequiredOption?
        ///  The output constraints of the consolidated policy aggregation.
        public let outputConstraints: [AggregationConstraint]
        ///  The scalar functions.
        public let scalarFunctions: [ScalarFunctions]

        @inlinable
        public init(additionalAnalyses: AdditionalAnalyses? = nil, aggregateColumns: [AggregateColumn], allowedAdditionalAnalyses: [String]? = nil, allowedJoinOperators: [JoinOperator]? = nil, allowedResultReceivers: [String]? = nil, dimensionColumns: [String], joinColumns: [String], joinRequired: JoinRequiredOption? = nil, outputConstraints: [AggregationConstraint], scalarFunctions: [ScalarFunctions]) {
            self.additionalAnalyses = additionalAnalyses
            self.aggregateColumns = aggregateColumns
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedJoinOperators = allowedJoinOperators
            self.allowedResultReceivers = allowedResultReceivers
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.joinRequired = joinRequired
            self.outputConstraints = outputConstraints
            self.scalarFunctions = scalarFunctions
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAnalyses = "additionalAnalyses"
            case aggregateColumns = "aggregateColumns"
            case allowedAdditionalAnalyses = "allowedAdditionalAnalyses"
            case allowedJoinOperators = "allowedJoinOperators"
            case allowedResultReceivers = "allowedResultReceivers"
            case dimensionColumns = "dimensionColumns"
            case joinColumns = "joinColumns"
            case joinRequired = "joinRequired"
            case outputConstraints = "outputConstraints"
            case scalarFunctions = "scalarFunctions"
        }
    }

    public struct ConsolidatedPolicyCustom: AWSDecodableShape {
        ///  Additional analyses for the consolidated policy.
        public let additionalAnalyses: AdditionalAnalyses?
        ///  The additional analyses allowed by the consolidated policy.
        public let allowedAdditionalAnalyses: [String]?
        ///  The allowed analyses.
        public let allowedAnalyses: [String]
        ///  The allowed analysis providers.
        public let allowedAnalysisProviders: [String]?
        ///  The allowed result receivers.
        public let allowedResultReceivers: [String]?
        public let differentialPrivacy: DifferentialPrivacyConfiguration?
        ///  Disallowed output columns
        public let disallowedOutputColumns: [String]?

        @inlinable
        public init(additionalAnalyses: AdditionalAnalyses? = nil, allowedAdditionalAnalyses: [String]? = nil, allowedAnalyses: [String], allowedAnalysisProviders: [String]? = nil, allowedResultReceivers: [String]? = nil, differentialPrivacy: DifferentialPrivacyConfiguration? = nil, disallowedOutputColumns: [String]? = nil) {
            self.additionalAnalyses = additionalAnalyses
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedAnalyses = allowedAnalyses
            self.allowedAnalysisProviders = allowedAnalysisProviders
            self.allowedResultReceivers = allowedResultReceivers
            self.differentialPrivacy = differentialPrivacy
            self.disallowedOutputColumns = disallowedOutputColumns
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAnalyses = "additionalAnalyses"
            case allowedAdditionalAnalyses = "allowedAdditionalAnalyses"
            case allowedAnalyses = "allowedAnalyses"
            case allowedAnalysisProviders = "allowedAnalysisProviders"
            case allowedResultReceivers = "allowedResultReceivers"
            case differentialPrivacy = "differentialPrivacy"
            case disallowedOutputColumns = "disallowedOutputColumns"
        }
    }

    public struct ConsolidatedPolicyList: AWSDecodableShape {
        ///  Additional analyses for the consolidated policy list.
        public let additionalAnalyses: AdditionalAnalyses?
        ///  The additional analyses allowed by the consolidated policy list.
        public let allowedAdditionalAnalyses: [String]?
        ///  The allowed join operators in the consolidated policy list.
        public let allowedJoinOperators: [JoinOperator]?
        ///  The allowed result receivers.
        public let allowedResultReceivers: [String]?
        ///  The columns to join on.
        public let joinColumns: [String]
        ///  The columns in the consolidated policy list.
        public let listColumns: [String]

        @inlinable
        public init(additionalAnalyses: AdditionalAnalyses? = nil, allowedAdditionalAnalyses: [String]? = nil, allowedJoinOperators: [JoinOperator]? = nil, allowedResultReceivers: [String]? = nil, joinColumns: [String], listColumns: [String]) {
            self.additionalAnalyses = additionalAnalyses
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedJoinOperators = allowedJoinOperators
            self.allowedResultReceivers = allowedResultReceivers
            self.joinColumns = joinColumns
            self.listColumns = listColumns
        }

        private enum CodingKeys: String, CodingKey {
            case additionalAnalyses = "additionalAnalyses"
            case allowedAdditionalAnalyses = "allowedAdditionalAnalyses"
            case allowedJoinOperators = "allowedJoinOperators"
            case allowedResultReceivers = "allowedResultReceivers"
            case joinColumns = "joinColumns"
            case listColumns = "listColumns"
        }
    }

    public struct CreateAnalysisTemplateInput: AWSEncodableShape {
        /// The parameters of the analysis template.
        public let analysisParameters: [AnalysisParameter]?
        /// The description of the analysis template.
        public let description: String?
        /// The format of the analysis template.
        public let format: AnalysisFormat
        /// The identifier for a membership resource.
        public let membershipIdentifier: String
        /// The name of the analysis template.
        public let name: String
        public let schema: AnalysisSchema?
        /// The information in the analysis template. Currently supports text, the query text for the analysis template.
        public let source: AnalysisSource
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(analysisParameters: [AnalysisParameter]? = nil, description: String? = nil, format: AnalysisFormat, membershipIdentifier: String, name: String, schema: AnalysisSchema? = nil, source: AnalysisSource, tags: [String: String]? = nil) {
            self.analysisParameters = analysisParameters
            self.description = description
            self.format = format
            self.membershipIdentifier = membershipIdentifier
            self.name = name
            self.schema = schema
            self.source = source
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.analysisParameters, forKey: .analysisParameters)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.format, forKey: .format)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.schema, forKey: .schema)
            try container.encode(self.source, forKey: .source)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.analysisParameters?.forEach {
                try $0.validate(name: "\(name).analysisParameters[]")
            }
            try self.validate(self.analysisParameters, name: "analysisParameters", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.schema?.validate(name: "\(name).schema")
            try self.source.validate(name: "\(name).source")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case analysisParameters = "analysisParameters"
            case description = "description"
            case format = "format"
            case name = "name"
            case schema = "schema"
            case source = "source"
            case tags = "tags"
        }
    }

    public struct CreateAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template.
        public let analysisTemplate: AnalysisTemplate

        @inlinable
        public init(analysisTemplate: AnalysisTemplate) {
            self.analysisTemplate = analysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplate = "analysisTemplate"
        }
    }

    public struct CreateCollaborationInput: AWSEncodableShape {
        ///  The analytics engine.
        public let analyticsEngine: AnalyticsEngine?
        /// The display name of the collaboration creator.
        public let creatorDisplayName: String
        /// The abilities granted to the collaboration creator.
        public let creatorMemberAbilities: [MemberAbility]
        /// The ML abilities granted to the collaboration creator.
        public let creatorMLMemberAbilities: MLMemberAbilities?
        /// The collaboration creator's payment responsibilities set by the collaboration creator.  If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer.
        public let creatorPaymentConfiguration: PaymentConfiguration?
        /// The settings for client-side encryption with Cryptographic Computing for Clean Rooms.
        public let dataEncryptionMetadata: DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public let description: String
        /// Specifies whether job logs are enabled for this collaboration.  When ENABLED, Clean Rooms logs details about jobs run within this collaboration; those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let jobLogStatus: CollaborationJobLogStatus?
        /// A list of initial members, not including the creator. This list is immutable.
        public let members: [MemberSpecification]
        /// The display name for a collaboration.
        public let name: String
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration. When ENABLED, Clean Rooms logs details about queries run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let queryLogStatus: CollaborationQueryLogStatus
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(analyticsEngine: AnalyticsEngine? = nil, creatorDisplayName: String, creatorMemberAbilities: [MemberAbility], creatorMLMemberAbilities: MLMemberAbilities? = nil, creatorPaymentConfiguration: PaymentConfiguration? = nil, dataEncryptionMetadata: DataEncryptionMetadata? = nil, description: String, jobLogStatus: CollaborationJobLogStatus? = nil, members: [MemberSpecification], name: String, queryLogStatus: CollaborationQueryLogStatus, tags: [String: String]? = nil) {
            self.analyticsEngine = analyticsEngine
            self.creatorDisplayName = creatorDisplayName
            self.creatorMemberAbilities = creatorMemberAbilities
            self.creatorMLMemberAbilities = creatorMLMemberAbilities
            self.creatorPaymentConfiguration = creatorPaymentConfiguration
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.jobLogStatus = jobLogStatus
            self.members = members
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, max: 100)
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, min: 1)
            try self.validate(self.creatorDisplayName, name: "creatorDisplayName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.creatorMLMemberAbilities?.validate(name: "\(name).creatorMLMemberAbilities")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.members.forEach {
                try $0.validate(name: "\(name).members[]")
            }
            try self.validate(self.members, name: "members", parent: name, max: 9)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case analyticsEngine = "analyticsEngine"
            case creatorDisplayName = "creatorDisplayName"
            case creatorMemberAbilities = "creatorMemberAbilities"
            case creatorMLMemberAbilities = "creatorMLMemberAbilities"
            case creatorPaymentConfiguration = "creatorPaymentConfiguration"
            case dataEncryptionMetadata = "dataEncryptionMetadata"
            case description = "description"
            case jobLogStatus = "jobLogStatus"
            case members = "members"
            case name = "name"
            case queryLogStatus = "queryLogStatus"
            case tags = "tags"
        }
    }

    public struct CreateCollaborationOutput: AWSDecodableShape {
        /// The collaboration.
        public let collaboration: Collaboration

        @inlinable
        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct CreateConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured audience model that you want to associate.
        public let configuredAudienceModelArn: String
        /// The name of the configured audience model association.
        public let configuredAudienceModelAssociationName: String
        /// A description of the configured audience model association.
        public let description: String?
        /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration. Setting this to TRUE requires you to have permissions to create, update, and delete the resource policy for the cleanrooms-ml resource when you call the DeleteConfiguredAudienceModelAssociation resource. In addition, if you are the collaboration creator and specify TRUE, you must have the same permissions when you call the DeleteMember and DeleteCollaboration APIs.
        public let manageResourcePolicies: Bool
        /// A unique identifier for one of your memberships for a collaboration. The configured audience model is associated to the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(configuredAudienceModelArn: String, configuredAudienceModelAssociationName: String, description: String? = nil, manageResourcePolicies: Bool, membershipIdentifier: String, tags: [String: String]? = nil) {
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.configuredAudienceModelAssociationName = configuredAudienceModelAssociationName
            self.description = description
            self.manageResourcePolicies = manageResourcePolicies
            self.membershipIdentifier = membershipIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
            try container.encode(self.configuredAudienceModelAssociationName, forKey: .configuredAudienceModelAssociationName)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.manageResourcePolicies, forKey: .manageResourcePolicies)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, max: 2048)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, min: 20)
            try self.validate(self.configuredAudienceModelArn, name: "configuredAudienceModelArn", parent: name, pattern: "^arn:aws[-a-z]*:cleanrooms-ml:[-a-z0-9]+:[0-9]{12}:configured-audience-model/[-a-zA-Z0-9_/.]+$")
            try self.validate(self.configuredAudienceModelAssociationName, name: "configuredAudienceModelAssociationName", parent: name, max: 100)
            try self.validate(self.configuredAudienceModelAssociationName, name: "configuredAudienceModelAssociationName", parent: name, min: 1)
            try self.validate(self.configuredAudienceModelAssociationName, name: "configuredAudienceModelAssociationName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelArn = "configuredAudienceModelArn"
            case configuredAudienceModelAssociationName = "configuredAudienceModelAssociationName"
            case description = "description"
            case manageResourcePolicies = "manageResourcePolicies"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// Information about the configured audience model association.
        public let configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation

        @inlinable
        public init(configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation) {
            self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociation = "configuredAudienceModelAssociation"
        }
    }

    public struct CreateConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule policy that was created for the configured table.
        public let analysisRulePolicy: ConfiguredTableAnalysisRulePolicy
        /// The type of analysis rule.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The identifier for the configured table to create the analysis rule for. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        @inlinable
        public init(analysisRulePolicy: ConfiguredTableAnalysisRulePolicy, analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            try container.encode(self.analysisRuleType, forKey: .analysisRuleType)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
            case analysisRuleType = "analysisRuleType"
        }
    }

    public struct CreateConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The analysis rule that was created for the configured table.
        public let analysisRule: ConfiguredTableAnalysisRule

        @inlinable
        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct CreateConfiguredTableAssociationAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule policy that was created for the configured table association.
        public let analysisRulePolicy: ConfiguredTableAssociationAnalysisRulePolicy
        ///  The type of analysis rule.
        public let analysisRuleType: ConfiguredTableAssociationAnalysisRuleType
        ///  The unique ID for the configured table association. Currently accepts the configured table association ID.
        public let configuredTableAssociationIdentifier: String
        ///  A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        @inlinable
        public init(analysisRulePolicy: ConfiguredTableAssociationAnalysisRulePolicy, analysisRuleType: ConfiguredTableAssociationAnalysisRuleType, configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            try container.encode(self.analysisRuleType, forKey: .analysisRuleType)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
            case analysisRuleType = "analysisRuleType"
        }
    }

    public struct CreateConfiguredTableAssociationAnalysisRuleOutput: AWSDecodableShape {
        /// The analysis rule for the congured table association. In the console, the ConfiguredTableAssociationAnalysisRule is referred to as the collaboration analysis rule.
        public let analysisRule: ConfiguredTableAssociationAnalysisRule

        @inlinable
        public init(analysisRule: ConfiguredTableAssociationAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct CreateConfiguredTableAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured table to be associated to. Currently accepts a configured table ID.
        public let configuredTableIdentifier: String
        /// A description for the configured table association.
        public let description: String?
        /// A unique identifier for one of your memberships for a collaboration. The configured table is associated to the collaboration that this membership belongs to. Currently accepts a membership ID.
        public let membershipIdentifier: String
        /// The name of the configured table association. This name is used to query the underlying configured table.
        public let name: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(configuredTableIdentifier: String, description: String? = nil, membershipIdentifier: String, name: String, roleArn: String, tags: [String: String]? = nil) {
            self.configuredTableIdentifier = configuredTableIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.name = name
            self.roleArn = roleArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.configuredTableIdentifier, forKey: .configuredTableIdentifier)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableIdentifier = "configuredTableIdentifier"
            case description = "description"
            case name = "name"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The configured table association.
        public let configuredTableAssociation: ConfiguredTableAssociation

        @inlinable
        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct CreateConfiguredTableInput: AWSEncodableShape {
        /// The columns of the underlying table that can be used by collaborations or analysis rules.
        public let allowedColumns: [String]
        /// The analysis method allowed for the configured tables.  DIRECT_QUERY allows SQL queries to be run directly on this table.  DIRECT_JOB allows PySpark jobs to be run directly on this table.  MULTIPLE allows both SQL queries and PySpark jobs to be run directly on this table.
        public let analysisMethod: AnalysisMethod
        /// A description for the configured table.
        public let description: String?
        /// The name of the configured table.
        public let name: String
        ///  The analysis methods to enable for the configured table.  When configured, you must specify at least two analysis methods.
        public let selectedAnalysisMethods: [SelectedAnalysisMethod]?
        /// A reference to the table being configured.
        public let tableReference: TableReference
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(allowedColumns: [String], analysisMethod: AnalysisMethod, description: String? = nil, name: String, selectedAnalysisMethods: [SelectedAnalysisMethod]? = nil, tableReference: TableReference, tags: [String: String]? = nil) {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.description = description
            self.name = name
            self.selectedAnalysisMethods = selectedAnalysisMethods
            self.tableReference = tableReference
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allowedColumns.forEach {
                try validate($0, name: "allowedColumns[]", parent: name, max: 128)
                try validate($0, name: "allowedColumns[]", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            }
            try self.validate(self.allowedColumns, name: "allowedColumns", parent: name, max: 225)
            try self.validate(self.allowedColumns, name: "allowedColumns", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tableReference.validate(name: "\(name).tableReference")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedColumns = "allowedColumns"
            case analysisMethod = "analysisMethod"
            case description = "description"
            case name = "name"
            case selectedAnalysisMethods = "selectedAnalysisMethods"
            case tableReference = "tableReference"
            case tags = "tags"
        }
    }

    public struct CreateConfiguredTableOutput: AWSDecodableShape {
        /// The created configured table.
        public let configuredTable: ConfiguredTable

        @inlinable
        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct CreateIdMappingTableInput: AWSEncodableShape {
        /// A description of the ID mapping table.
        public let description: String?
        /// The input reference configuration needed to create the ID mapping table.
        public let inputReferenceConfig: IdMappingTableInputReferenceConfig
        /// The Amazon Resource Name (ARN) of the Amazon Web Services KMS key. This value is used to encrypt the mapping table data that is stored by Clean Rooms.
        public let kmsKeyArn: String?
        /// The unique identifier of the membership that contains the ID mapping table.
        public let membershipIdentifier: String
        /// A name for the ID mapping table.
        public let name: String
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, inputReferenceConfig: IdMappingTableInputReferenceConfig, kmsKeyArn: String? = nil, membershipIdentifier: String, name: String, tags: [String: String]? = nil) {
            self.description = description
            self.inputReferenceConfig = inputReferenceConfig
            self.kmsKeyArn = kmsKeyArn
            self.membershipIdentifier = membershipIdentifier
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.inputReferenceConfig, forKey: .inputReferenceConfig)
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.inputReferenceConfig.validate(name: "\(name).inputReferenceConfig")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:key/[a-zA-Z0-9-]+$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case inputReferenceConfig = "inputReferenceConfig"
            case kmsKeyArn = "kmsKeyArn"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateIdMappingTableOutput: AWSDecodableShape {
        /// The ID mapping table that was created.
        public let idMappingTable: IdMappingTable

        @inlinable
        public init(idMappingTable: IdMappingTable) {
            self.idMappingTable = idMappingTable
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingTable = "idMappingTable"
        }
    }

    public struct CreateIdNamespaceAssociationInput: AWSEncodableShape {
        /// The description of the ID namespace association.
        public let description: String?
        /// The configuration settings for the ID mapping table.
        public let idMappingConfig: IdMappingConfig?
        /// The input reference configuration needed to create the ID namespace association.
        public let inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig
        /// The unique identifier of the membership that contains the ID namespace association.
        public let membershipIdentifier: String
        /// The name for the ID namespace association.
        public let name: String
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, idMappingConfig: IdMappingConfig? = nil, inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig, membershipIdentifier: String, name: String, tags: [String: String]? = nil) {
            self.description = description
            self.idMappingConfig = idMappingConfig
            self.inputReferenceConfig = inputReferenceConfig
            self.membershipIdentifier = membershipIdentifier
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.idMappingConfig, forKey: .idMappingConfig)
            try container.encode(self.inputReferenceConfig, forKey: .inputReferenceConfig)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.inputReferenceConfig.validate(name: "\(name).inputReferenceConfig")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingConfig = "idMappingConfig"
            case inputReferenceConfig = "inputReferenceConfig"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateIdNamespaceAssociationOutput: AWSDecodableShape {
        /// The ID namespace association that was created.
        public let idNamespaceAssociation: IdNamespaceAssociation

        @inlinable
        public init(idNamespaceAssociation: IdNamespaceAssociation) {
            self.idNamespaceAssociation = idNamespaceAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case idNamespaceAssociation = "idNamespaceAssociation"
        }
    }

    public struct CreateMembershipInput: AWSEncodableShape {
        /// The unique ID for the associated collaboration.
        public let collaborationIdentifier: String
        /// The default job result configuration that determines how job results are  protected and managed within this membership. This configuration applies to all  jobs.
        public let defaultJobResultConfiguration: MembershipProtectedJobResultConfiguration?
        /// The default protected query result configuration as specified by the member who can receive results.
        public let defaultResultConfiguration: MembershipProtectedQueryResultConfiguration?
        /// An indicator as to whether job logging has been enabled or disabled  for the collaboration.  When ENABLED, Clean Rooms logs details about jobs run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let jobLogStatus: MembershipJobLogStatus?
        /// The payment responsibilities accepted by the collaboration member. Not required if the collaboration member has the member ability to run queries.  Required if the collaboration member doesn't have the member ability to run queries but is configured as a payer by the collaboration creator.
        public let paymentConfiguration: MembershipPaymentConfiguration?
        /// An indicator as to whether query logging has been enabled or disabled for the membership. When ENABLED, Clean Rooms logs details about queries run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let queryLogStatus: MembershipQueryLogStatus
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(collaborationIdentifier: String, defaultJobResultConfiguration: MembershipProtectedJobResultConfiguration? = nil, defaultResultConfiguration: MembershipProtectedQueryResultConfiguration? = nil, jobLogStatus: MembershipJobLogStatus? = nil, paymentConfiguration: MembershipPaymentConfiguration? = nil, queryLogStatus: MembershipQueryLogStatus, tags: [String: String]? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.defaultJobResultConfiguration = defaultJobResultConfiguration
            self.defaultResultConfiguration = defaultResultConfiguration
            self.jobLogStatus = jobLogStatus
            self.paymentConfiguration = paymentConfiguration
            self.queryLogStatus = queryLogStatus
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.defaultJobResultConfiguration?.validate(name: "\(name).defaultJobResultConfiguration")
            try self.defaultResultConfiguration?.validate(name: "\(name).defaultResultConfiguration")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationIdentifier = "collaborationIdentifier"
            case defaultJobResultConfiguration = "defaultJobResultConfiguration"
            case defaultResultConfiguration = "defaultResultConfiguration"
            case jobLogStatus = "jobLogStatus"
            case paymentConfiguration = "paymentConfiguration"
            case queryLogStatus = "queryLogStatus"
            case tags = "tags"
        }
    }

    public struct CreateMembershipOutput: AWSDecodableShape {
        /// The membership that was created.
        public let membership: Membership

        @inlinable
        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct CreatePrivacyBudgetTemplateInput: AWSEncodableShape {
        /// How often the privacy budget refreshes.  If you plan to regularly bring new data into the collaboration, you can use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        public let autoRefresh: PrivacyBudgetTemplateAutoRefresh
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// Specifies your parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateParametersInput
        /// Specifies the type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
        public let tags: [String: String]?

        @inlinable
        public init(autoRefresh: PrivacyBudgetTemplateAutoRefresh, membershipIdentifier: String, parameters: PrivacyBudgetTemplateParametersInput, privacyBudgetType: PrivacyBudgetType, tags: [String: String]? = nil) {
            self.autoRefresh = autoRefresh
            self.membershipIdentifier = membershipIdentifier
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.autoRefresh, forKey: .autoRefresh)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.parameters, forKey: .parameters)
            try container.encode(self.privacyBudgetType, forKey: .privacyBudgetType)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.parameters.validate(name: "\(name).parameters")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case autoRefresh = "autoRefresh"
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
            case tags = "tags"
        }
    }

    public struct CreatePrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// A summary of the elements in the privacy budget template.
        public let privacyBudgetTemplate: PrivacyBudgetTemplate

        @inlinable
        public init(privacyBudgetTemplate: PrivacyBudgetTemplate) {
            self.privacyBudgetTemplate = privacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case privacyBudgetTemplate = "privacyBudgetTemplate"
        }
    }

    public struct DataEncryptionMetadata: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether encrypted tables can contain cleartext data (TRUE) or are to cryptographically process every column (FALSE).
        public let allowCleartext: Bool
        /// Indicates whether Fingerprint columns can contain duplicate entries (TRUE) or are to contain only non-repeated values (FALSE).
        public let allowDuplicates: Bool
        /// Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (TRUE) or can only be joined on Fingerprint columns of the same name (FALSE).
        public let allowJoinsOnColumnsWithDifferentNames: Bool
        /// Indicates whether NULL values are to be copied as NULL to encrypted tables (TRUE) or cryptographically processed (FALSE).
        public let preserveNulls: Bool

        @inlinable
        public init(allowCleartext: Bool, allowDuplicates: Bool, allowJoinsOnColumnsWithDifferentNames: Bool, preserveNulls: Bool) {
            self.allowCleartext = allowCleartext
            self.allowDuplicates = allowDuplicates
            self.allowJoinsOnColumnsWithDifferentNames = allowJoinsOnColumnsWithDifferentNames
            self.preserveNulls = preserveNulls
        }

        private enum CodingKeys: String, CodingKey {
            case allowCleartext = "allowCleartext"
            case allowDuplicates = "allowDuplicates"
            case allowJoinsOnColumnsWithDifferentNames = "allowJoinsOnColumnsWithDifferentNames"
            case preserveNulls = "preserveNulls"
        }
    }

    public struct DeleteAnalysisTemplateInput: AWSEncodableShape {
        /// The identifier for the analysis template resource.
        public let analysisTemplateIdentifier: String
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        @inlinable
        public init(analysisTemplateIdentifier: String, membershipIdentifier: String) {
            self.analysisTemplateIdentifier = analysisTemplateIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateIdentifier, key: "analysisTemplateIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAnalysisTemplateOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String

        @inlinable
        public init(collaborationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCollaborationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier of the configured audience model association that you want to delete.
        public let configuredAudienceModelAssociationIdentifier: String
        /// A unique identifier of the membership that contains the audience model association that you want to delete.
        public let membershipIdentifier: String

        @inlinable
        public init(configuredAudienceModelAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule type to be deleted. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        @inlinable
        public init(analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableAssociationAnalysisRuleInput: AWSEncodableShape {
        /// The type of the analysis rule that you want to delete.
        public let analysisRuleType: ConfiguredTableAssociationAnalysisRuleType
        /// The identier for the congured table association that's related to the analysis rule that you want to delete.
        public let configuredTableAssociationIdentifier: String
        ///  A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        @inlinable
        public init(analysisRuleType: ConfiguredTableAssociationAnalysisRuleType, configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableAssociationAnalysisRuleOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique ID for the configured table association to be deleted. Currently accepts the configured table ID.
        public let configuredTableAssociationIdentifier: String
        /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        @inlinable
        public init(configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableAssociationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConfiguredTableInput: AWSEncodableShape {
        /// The unique ID for the configured table to delete.
        public let configuredTableIdentifier: String

        @inlinable
        public init(configuredTableIdentifier: String) {
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConfiguredTableOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIdMappingTableInput: AWSEncodableShape {
        /// The unique identifier of the ID mapping table that you want to delete.
        public let idMappingTableIdentifier: String
        /// The unique identifier of the membership that contains the ID mapping table that you want to delete.
        public let membershipIdentifier: String

        @inlinable
        public init(idMappingTableIdentifier: String, membershipIdentifier: String) {
            self.idMappingTableIdentifier = idMappingTableIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.idMappingTableIdentifier, key: "idMappingTableIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, max: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, min: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdMappingTableOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIdNamespaceAssociationInput: AWSEncodableShape {
        /// The unique identifier of the ID namespace association that you want to delete.
        public let idNamespaceAssociationIdentifier: String
        /// The unique identifier of the membership that contains the ID namespace association that you want to delete.
        public let membershipIdentifier: String

        @inlinable
        public init(idNamespaceAssociationIdentifier: String, membershipIdentifier: String) {
            self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.idNamespaceAssociationIdentifier, key: "idNamespaceAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIdNamespaceAssociationOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMemberInput: AWSEncodableShape {
        /// The account ID of the member to remove.
        public let accountId: String
        /// The unique identifier for the associated collaboration.
        public let collaborationIdentifier: String

        @inlinable
        public init(accountId: String, collaborationIdentifier: String) {
            self.accountId = accountId
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accountId, key: "accountId")
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemberOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteMembershipInput: AWSEncodableShape {
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        @inlinable
        public init(membershipIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMembershipOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is deleted from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// A unique identifier for your privacy budget template.
        public let privacyBudgetTemplateIdentifier: String

        @inlinable
        public init(membershipIdentifier: String, privacyBudgetTemplateIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePrivacyBudgetTemplateOutput: AWSDecodableShape {
        public init() {}
    }

    public struct DifferentialPrivacyColumn: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column, such as user_id, that contains the unique identifier of your users, whose privacy you want to protect. If you want to turn on differential privacy for two or more tables in a collaboration, you must configure the same column as the user identifier column in both analysis rules.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
        }
    }

    public struct DifferentialPrivacyConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the column (such as user_id) that contains the unique identifier of your users whose privacy you want to protect. If you want to turn on dierential privacy for two or more tables in a collaboration, you must congure the same column as the user identier column in both analysis rules.
        public let columns: [DifferentialPrivacyColumn]

        @inlinable
        public init(columns: [DifferentialPrivacyColumn]) {
            self.columns = columns
        }

        public func validate(name: String) throws {
            try self.validate(self.columns, name: "columns", parent: name, max: 1)
            try self.validate(self.columns, name: "columns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "columns"
        }
    }

    public struct DifferentialPrivacyParameters: AWSDecodableShape {
        /// Provides the sensitivity parameters that you can use to better understand the total amount of noise in query results.
        public let sensitivityParameters: [DifferentialPrivacySensitivityParameters]

        @inlinable
        public init(sensitivityParameters: [DifferentialPrivacySensitivityParameters]) {
            self.sensitivityParameters = sensitivityParameters
        }

        private enum CodingKeys: String, CodingKey {
            case sensitivityParameters = "sensitivityParameters"
        }
    }

    public struct DifferentialPrivacyPreviewAggregation: AWSDecodableShape {
        /// The maximum number of aggregations that the member who can query can run given the epsilon and noise parameters.
        public let maxCount: Int
        /// The type of aggregation function.
        public let type: DifferentialPrivacyAggregationType

        @inlinable
        public init(maxCount: Int, type: DifferentialPrivacyAggregationType) {
            self.maxCount = maxCount
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxCount = "maxCount"
            case type = "type"
        }
    }

    public struct DifferentialPrivacyPreviewParametersInput: AWSEncodableShape {
        /// The epsilon value that you want to preview.
        public let epsilon: Int
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int

        @inlinable
        public init(epsilon: Int, usersNoisePerQuery: Int) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.epsilon, name: "epsilon", parent: name, max: 20)
            try self.validate(self.epsilon, name: "epsilon", parent: name, min: 1)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, max: 100)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct DifferentialPrivacyPrivacyBudget: AWSDecodableShape {
        /// This information includes the configured epsilon value and the utility in terms of total aggregations, as well as the remaining aggregations.
        public let aggregations: [DifferentialPrivacyPrivacyBudgetAggregation]
        /// The epsilon value that you configured.
        public let epsilon: Int

        @inlinable
        public init(aggregations: [DifferentialPrivacyPrivacyBudgetAggregation], epsilon: Int) {
            self.aggregations = aggregations
            self.epsilon = epsilon
        }

        private enum CodingKeys: String, CodingKey {
            case aggregations = "aggregations"
            case epsilon = "epsilon"
        }
    }

    public struct DifferentialPrivacyPrivacyBudgetAggregation: AWSDecodableShape {
        /// The maximum number of aggregation functions that you can perform with the given privacy budget.
        public let maxCount: Int
        /// The remaining number of aggregation functions that can be run with the available privacy budget.
        public let remainingCount: Int
        /// The different types of aggregation functions that you can perform.
        public let type: DifferentialPrivacyAggregationType

        @inlinable
        public init(maxCount: Int, remainingCount: Int, type: DifferentialPrivacyAggregationType) {
            self.maxCount = maxCount
            self.remainingCount = remainingCount
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case maxCount = "maxCount"
            case remainingCount = "remainingCount"
            case type = "type"
        }
    }

    public struct DifferentialPrivacyPrivacyImpact: AWSDecodableShape {
        /// The number of aggregation functions that you can perform.
        public let aggregations: [DifferentialPrivacyPreviewAggregation]

        @inlinable
        public init(aggregations: [DifferentialPrivacyPreviewAggregation]) {
            self.aggregations = aggregations
        }

        private enum CodingKeys: String, CodingKey {
            case aggregations = "aggregations"
        }
    }

    public struct DifferentialPrivacySensitivityParameters: AWSDecodableShape {
        /// The aggregation expression that was run.
        public let aggregationExpression: String
        /// The type of aggregation function that was run.
        public let aggregationType: DifferentialPrivacyAggregationType
        /// The upper bound of the aggregation expression.
        public let maxColumnValue: Float?
        /// The lower bound of the aggregation expression.
        public let minColumnValue: Float?
        /// The maximum number of rows contributed by a user in a SQL query.
        public let userContributionLimit: Int

        @inlinable
        public init(aggregationExpression: String, aggregationType: DifferentialPrivacyAggregationType, maxColumnValue: Float? = nil, minColumnValue: Float? = nil, userContributionLimit: Int) {
            self.aggregationExpression = aggregationExpression
            self.aggregationType = aggregationType
            self.maxColumnValue = maxColumnValue
            self.minColumnValue = minColumnValue
            self.userContributionLimit = userContributionLimit
        }

        private enum CodingKeys: String, CodingKey {
            case aggregationExpression = "aggregationExpression"
            case aggregationType = "aggregationType"
            case maxColumnValue = "maxColumnValue"
            case minColumnValue = "minColumnValue"
            case userContributionLimit = "userContributionLimit"
        }
    }

    public struct DifferentialPrivacyTemplateParametersInput: AWSEncodableShape {
        /// The epsilon value that you want to use.
        public let epsilon: Int
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int

        @inlinable
        public init(epsilon: Int, usersNoisePerQuery: Int) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.epsilon, name: "epsilon", parent: name, max: 20)
            try self.validate(self.epsilon, name: "epsilon", parent: name, min: 1)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, max: 100)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct DifferentialPrivacyTemplateParametersOutput: AWSDecodableShape {
        /// The epsilon value that you specified.
        public let epsilon: Int
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int

        @inlinable
        public init(epsilon: Int, usersNoisePerQuery: Int) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct DifferentialPrivacyTemplateUpdateParameters: AWSEncodableShape {
        /// The updated epsilon value that you want to use.
        public let epsilon: Int?
        /// The updated value of noise added per query. It is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public let usersNoisePerQuery: Int?

        @inlinable
        public init(epsilon: Int? = nil, usersNoisePerQuery: Int? = nil) {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }

        public func validate(name: String) throws {
            try self.validate(self.epsilon, name: "epsilon", parent: name, max: 20)
            try self.validate(self.epsilon, name: "epsilon", parent: name, min: 1)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, max: 100)
            try self.validate(self.usersNoisePerQuery, name: "usersNoisePerQuery", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case epsilon = "epsilon"
            case usersNoisePerQuery = "usersNoisePerQuery"
        }
    }

    public struct DirectAnalysisConfigurationDetails: AWSDecodableShape {
        ///  The account IDs for the member who received the results of a protected query.
        public let receiverAccountIds: [String]?

        @inlinable
        public init(receiverAccountIds: [String]? = nil) {
            self.receiverAccountIds = receiverAccountIds
        }

        private enum CodingKeys: String, CodingKey {
            case receiverAccountIds = "receiverAccountIds"
        }
    }

    public struct GetAnalysisTemplateInput: AWSEncodableShape {
        /// The identifier for the analysis template resource.
        public let analysisTemplateIdentifier: String
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        @inlinable
        public init(analysisTemplateIdentifier: String, membershipIdentifier: String) {
            self.analysisTemplateIdentifier = analysisTemplateIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateIdentifier, key: "analysisTemplateIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template.
        public let analysisTemplate: AnalysisTemplate

        @inlinable
        public init(analysisTemplate: AnalysisTemplate) {
            self.analysisTemplate = analysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplate = "analysisTemplate"
        }
    }

    public struct GetCollaborationAnalysisTemplateInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public let analysisTemplateArn: String
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String

        @inlinable
        public init(analysisTemplateArn: String, collaborationIdentifier: String) {
            self.analysisTemplateArn = analysisTemplateArn
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateArn, key: "analysisTemplateArn")
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, max: 200)
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+$")
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template within a collaboration.
        public let collaborationAnalysisTemplate: CollaborationAnalysisTemplate

        @inlinable
        public init(collaborationAnalysisTemplate: CollaborationAnalysisTemplate) {
            self.collaborationAnalysisTemplate = collaborationAnalysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationAnalysisTemplate = "collaborationAnalysisTemplate"
        }
    }

    public struct GetCollaborationConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// A unique identifier for the configured audience model association that you want to retrieve.
        public let configuredAudienceModelAssociationIdentifier: String

        @inlinable
        public init(collaborationIdentifier: String, configuredAudienceModelAssociationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// The metadata of the configured audience model association.
        public let collaborationConfiguredAudienceModelAssociation: CollaborationConfiguredAudienceModelAssociation

        @inlinable
        public init(collaborationConfiguredAudienceModelAssociation: CollaborationConfiguredAudienceModelAssociation) {
            self.collaborationConfiguredAudienceModelAssociation = collaborationConfiguredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationConfiguredAudienceModelAssociation = "collaborationConfiguredAudienceModelAssociation"
        }
    }

    public struct GetCollaborationIdNamespaceAssociationInput: AWSEncodableShape {
        /// The unique identifier of the collaboration that contains the ID namespace association that you want to retrieve.
        public let collaborationIdentifier: String
        /// The unique identifier of the ID namespace association that you want to retrieve.
        public let idNamespaceAssociationIdentifier: String

        @inlinable
        public init(collaborationIdentifier: String, idNamespaceAssociationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.idNamespaceAssociationIdentifier, key: "idNamespaceAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationIdNamespaceAssociationOutput: AWSDecodableShape {
        /// The ID namespace association that you requested.
        public let collaborationIdNamespaceAssociation: CollaborationIdNamespaceAssociation

        @inlinable
        public init(collaborationIdNamespaceAssociation: CollaborationIdNamespaceAssociation) {
            self.collaborationIdNamespaceAssociation = collaborationIdNamespaceAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationIdNamespaceAssociation = "collaborationIdNamespaceAssociation"
        }
    }

    public struct GetCollaborationInput: AWSEncodableShape {
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String

        @inlinable
        public init(collaborationIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationOutput: AWSDecodableShape {
        /// The entire collaboration for this identifier.
        public let collaboration: Collaboration

        @inlinable
        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct GetCollaborationPrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your collaborations.
        public let collaborationIdentifier: String
        /// A unique identifier for one of your privacy budget templates.
        public let privacyBudgetTemplateIdentifier: String

        @inlinable
        public init(collaborationIdentifier: String, privacyBudgetTemplateIdentifier: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCollaborationPrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// Returns the details of the privacy budget template that you requested.
        public let collaborationPrivacyBudgetTemplate: CollaborationPrivacyBudgetTemplate

        @inlinable
        public init(collaborationPrivacyBudgetTemplate: CollaborationPrivacyBudgetTemplate) {
            self.collaborationPrivacyBudgetTemplate = collaborationPrivacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationPrivacyBudgetTemplate = "collaborationPrivacyBudgetTemplate"
        }
    }

    public struct GetConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured audience model association that you want to retrieve.
        public let configuredAudienceModelAssociationIdentifier: String
        /// A unique identifier for the membership that contains the configured audience model association that you want to retrieve.
        public let membershipIdentifier: String

        @inlinable
        public init(configuredAudienceModelAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// Information about the configured audience model association that you requested.
        public let configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation

        @inlinable
        public init(configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation) {
            self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociation = "configuredAudienceModelAssociation"
        }
    }

    public struct GetConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The analysis rule to be retrieved. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table to retrieve. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        @inlinable
        public init(analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire analysis rule output.
        public let analysisRule: ConfiguredTableAnalysisRule

        @inlinable
        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct GetConfiguredTableAssociationAnalysisRuleInput: AWSEncodableShape {
        ///  The type of analysis rule that you want to retrieve.
        public let analysisRuleType: ConfiguredTableAssociationAnalysisRuleType
        ///  The identier for the congured table association that's related to the analysis rule.
        public let configuredTableAssociationIdentifier: String
        ///  A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        @inlinable
        public init(analysisRuleType: ConfiguredTableAssociationAnalysisRuleType, configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.analysisRuleType = analysisRuleType
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableAssociationAnalysisRuleOutput: AWSDecodableShape {
        /// The analysis rule for the congured table association. In the console, the ConfiguredTableAssociationAnalysisRule is referred to as the collaboration analysis rule.
        public let analysisRule: ConfiguredTableAssociationAnalysisRule

        @inlinable
        public init(analysisRule: ConfiguredTableAssociationAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct GetConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique ID for the configured table association to retrieve. Currently accepts the configured table ID.
        public let configuredTableAssociationIdentifier: String
        /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        @inlinable
        public init(configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire configured table association object.
        public let configuredTableAssociation: ConfiguredTableAssociation

        @inlinable
        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct GetConfiguredTableInput: AWSEncodableShape {
        /// The unique ID for the configured table to retrieve.
        public let configuredTableIdentifier: String

        @inlinable
        public init(configuredTableIdentifier: String) {
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetConfiguredTableOutput: AWSDecodableShape {
        /// The retrieved configured table.
        public let configuredTable: ConfiguredTable

        @inlinable
        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct GetIdMappingTableInput: AWSEncodableShape {
        /// The unique identifier of the ID mapping table identifier that you want to retrieve.
        public let idMappingTableIdentifier: String
        /// The unique identifier of the membership that contains the ID mapping table that you want to retrieve.
        public let membershipIdentifier: String

        @inlinable
        public init(idMappingTableIdentifier: String, membershipIdentifier: String) {
            self.idMappingTableIdentifier = idMappingTableIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.idMappingTableIdentifier, key: "idMappingTableIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, max: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, min: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdMappingTableOutput: AWSDecodableShape {
        /// The ID mapping table that you requested.
        public let idMappingTable: IdMappingTable

        @inlinable
        public init(idMappingTable: IdMappingTable) {
            self.idMappingTable = idMappingTable
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingTable = "idMappingTable"
        }
    }

    public struct GetIdNamespaceAssociationInput: AWSEncodableShape {
        /// The unique identifier of the ID namespace association that you want to retrieve.
        public let idNamespaceAssociationIdentifier: String
        /// The unique identifier of the membership that contains the ID namespace association that you want to retrieve.
        public let membershipIdentifier: String

        @inlinable
        public init(idNamespaceAssociationIdentifier: String, membershipIdentifier: String) {
            self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.idNamespaceAssociationIdentifier, key: "idNamespaceAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIdNamespaceAssociationOutput: AWSDecodableShape {
        /// The ID namespace association that you requested.
        public let idNamespaceAssociation: IdNamespaceAssociation

        @inlinable
        public init(idNamespaceAssociation: IdNamespaceAssociation) {
            self.idNamespaceAssociation = idNamespaceAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case idNamespaceAssociation = "idNamespaceAssociation"
        }
    }

    public struct GetMembershipInput: AWSEncodableShape {
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        @inlinable
        public init(membershipIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMembershipOutput: AWSDecodableShape {
        /// The membership retrieved for the provided identifier.
        public let membership: Membership

        @inlinable
        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct GetPrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// A unique identifier for your privacy budget template.
        public let privacyBudgetTemplateIdentifier: String

        @inlinable
        public init(membershipIdentifier: String, privacyBudgetTemplateIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// Returns the details of the privacy budget template that you requested.
        public let privacyBudgetTemplate: PrivacyBudgetTemplate

        @inlinable
        public init(privacyBudgetTemplate: PrivacyBudgetTemplate) {
            self.privacyBudgetTemplate = privacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case privacyBudgetTemplate = "privacyBudgetTemplate"
        }
    }

    public struct GetProtectedJobInput: AWSEncodableShape {
        ///  The identifier for a membership in a protected job instance.
        public let membershipIdentifier: String
        ///  The identifier for the protected job instance.
        public let protectedJobIdentifier: String

        @inlinable
        public init(membershipIdentifier: String, protectedJobIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedJobIdentifier = protectedJobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedJobIdentifier, key: "protectedJobIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.protectedJobIdentifier, name: "protectedJobIdentifier", parent: name, max: 36)
            try self.validate(self.protectedJobIdentifier, name: "protectedJobIdentifier", parent: name, min: 36)
            try self.validate(self.protectedJobIdentifier, name: "protectedJobIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProtectedJobOutput: AWSDecodableShape {
        ///  The protected job metadata.
        public let protectedJob: ProtectedJob

        @inlinable
        public init(protectedJob: ProtectedJob) {
            self.protectedJob = protectedJob
        }

        private enum CodingKeys: String, CodingKey {
            case protectedJob = "protectedJob"
        }
    }

    public struct GetProtectedQueryInput: AWSEncodableShape {
        /// The identifier for a membership in a protected query instance.
        public let membershipIdentifier: String
        /// The identifier for a protected query instance.
        public let protectedQueryIdentifier: String

        @inlinable
        public init(membershipIdentifier: String, protectedQueryIdentifier: String) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedQueryIdentifier = protectedQueryIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedQueryIdentifier, key: "protectedQueryIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, max: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, min: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProtectedQueryOutput: AWSDecodableShape {
        /// The query processing metadata.
        public let protectedQuery: ProtectedQuery

        @inlinable
        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct GetSchemaAnalysisRuleInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The name of the schema to retrieve the analysis rule for.
        public let name: String
        /// The type of the schema analysis rule to retrieve. Schema analysis rules are uniquely identified by a combination of the collaboration, the schema name, and their type.
        public let type: AnalysisRuleType

        @inlinable
        public init(collaborationIdentifier: String, name: String, type: AnalysisRuleType) {
            self.collaborationIdentifier = collaborationIdentifier
            self.name = name
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.name, key: "name")
            request.encodePath(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaAnalysisRuleOutput: AWSDecodableShape {
        /// A specification about how data from the configured table can be used.
        public let analysisRule: AnalysisRule

        @inlinable
        public init(analysisRule: AnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct GetSchemaInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The name of the relation to retrieve the schema for.
        public let name: String

        @inlinable
        public init(collaborationIdentifier: String, name: String) {
            self.collaborationIdentifier = collaborationIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodePath(self.name, key: "name")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSchemaOutput: AWSDecodableShape {
        /// The entire schema object.
        public let schema: Schema

        @inlinable
        public init(schema: Schema) {
            self.schema = schema
        }

        private enum CodingKeys: String, CodingKey {
            case schema = "schema"
        }
    }

    public struct GlueTableReference: AWSEncodableShape & AWSDecodableShape {
        /// The name of the database the Glue table belongs to.
        public let databaseName: String
        /// The name of the Glue table.
        public let tableName: String

        @inlinable
        public init(databaseName: String, tableName: String) {
            self.databaseName = databaseName
            self.tableName = tableName
        }

        public func validate(name: String) throws {
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 128)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_]+-)*([a-zA-Z0-9_]+))?$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 128)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case databaseName = "databaseName"
            case tableName = "tableName"
        }
    }

    public struct Hash: AWSDecodableShape {
        ///  The SHA-256 hash value.
        public let sha256: String?

        @inlinable
        public init(sha256: String? = nil) {
            self.sha256 = sha256
        }

        private enum CodingKeys: String, CodingKey {
            case sha256 = "sha256"
        }
    }

    public struct IdMappingConfig: AWSEncodableShape & AWSDecodableShape {
        /// An indicator as to whether you can use your column as a dimension column in the ID mapping table (TRUE) or not (FALSE). Default is FALSE.
        public let allowUseAsDimensionColumn: Bool

        @inlinable
        public init(allowUseAsDimensionColumn: Bool) {
            self.allowUseAsDimensionColumn = allowUseAsDimensionColumn
        }

        private enum CodingKeys: String, CodingKey {
            case allowUseAsDimensionColumn = "allowUseAsDimensionColumn"
        }
    }

    public struct IdMappingTable: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the ID mapping table.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID mapping table.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this ID mapping table.
        public let collaborationId: String
        /// The time at which the ID mapping table was created.
        public let createTime: Date
        /// The description of the ID mapping table.
        public let description: String?
        /// The unique identifier of the ID mapping table.
        public let id: String
        /// The input reference configuration for the ID mapping table.
        public let inputReferenceConfig: IdMappingTableInputReferenceConfig
        /// The input reference properties for the ID mapping table.
        public let inputReferenceProperties: IdMappingTableInputReferenceProperties
        /// The Amazon Resource Name (ARN) of the Amazon Web Services KMS key.
        public let kmsKeyArn: String?
        /// The Amazon Resource Name (ARN) of the membership resource for the ID mapping table.
        public let membershipArn: String
        /// The unique identifier of the membership resource for the ID mapping table.
        public let membershipId: String
        /// The name of the ID mapping table.
        public let name: String
        /// The most recent time at which the ID mapping table was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, id: String, inputReferenceConfig: IdMappingTableInputReferenceConfig, inputReferenceProperties: IdMappingTableInputReferenceProperties, kmsKeyArn: String? = nil, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.kmsKeyArn = kmsKeyArn
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case inputReferenceConfig = "inputReferenceConfig"
            case inputReferenceProperties = "inputReferenceProperties"
            case kmsKeyArn = "kmsKeyArn"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct IdMappingTableInputReferenceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the referenced resource in Entity Resolution. Valid values are ID mapping workflow ARNs.
        public let inputReferenceArn: String
        /// When TRUE, Clean Rooms manages permissions for the ID mapping table resource.  When FALSE, the resource owner manages permissions for the ID mapping table resource.
        public let manageResourcePolicies: Bool

        @inlinable
        public init(inputReferenceArn: String, manageResourcePolicies: Bool) {
            self.inputReferenceArn = inputReferenceArn
            self.manageResourcePolicies = manageResourcePolicies
        }

        public func validate(name: String) throws {
            try self.validate(self.inputReferenceArn, name: "inputReferenceArn", parent: name, max: 2048)
            try self.validate(self.inputReferenceArn, name: "inputReferenceArn", parent: name, min: 20)
            try self.validate(self.inputReferenceArn, name: "inputReferenceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn):entityresolution:.*:[0-9]+:(idmappingworkflow/.*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputReferenceArn = "inputReferenceArn"
            case manageResourcePolicies = "manageResourcePolicies"
        }
    }

    public struct IdMappingTableInputReferenceProperties: AWSDecodableShape {
        /// The input source of the ID mapping table.
        public let idMappingTableInputSource: [IdMappingTableInputSource]

        @inlinable
        public init(idMappingTableInputSource: [IdMappingTableInputSource]) {
            self.idMappingTableInputSource = idMappingTableInputSource
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingTableInputSource = "idMappingTableInputSource"
        }
    }

    public struct IdMappingTableInputSource: AWSDecodableShape {
        /// The unique identifier of the ID namespace association.
        public let idNamespaceAssociationId: String
        /// The type of the input source of the ID mapping table.
        public let type: IdNamespaceType

        @inlinable
        public init(idNamespaceAssociationId: String, type: IdNamespaceType) {
            self.idNamespaceAssociationId = idNamespaceAssociationId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case idNamespaceAssociationId = "idNamespaceAssociationId"
            case type = "type"
        }
    }

    public struct IdMappingTableSchemaTypeProperties: AWSDecodableShape {
        /// Defines which ID namespace associations are used to create the ID mapping table.
        public let idMappingTableInputSource: [IdMappingTableInputSource]

        @inlinable
        public init(idMappingTableInputSource: [IdMappingTableInputSource]) {
            self.idMappingTableInputSource = idMappingTableInputSource
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingTableInputSource = "idMappingTableInputSource"
        }
    }

    public struct IdMappingTableSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this ID mapping table.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID mapping table.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this ID mapping table.
        public let collaborationId: String
        /// The time at which this ID mapping table was created.
        public let createTime: Date
        /// The description of this ID mapping table.
        public let description: String?
        /// The unique identifier of this ID mapping table.
        public let id: String
        /// The input reference configuration for the ID mapping table.
        public let inputReferenceConfig: IdMappingTableInputReferenceConfig
        /// The Amazon Resource Name (ARN) of the membership resource for this ID mapping table.
        public let membershipArn: String
        /// The unique identifier of the membership resource for this ID mapping table.
        public let membershipId: String
        /// The name of this ID mapping table.
        public let name: String
        /// The most recent time at which this ID mapping table was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, id: String, inputReferenceConfig: IdMappingTableInputReferenceConfig, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case inputReferenceConfig = "inputReferenceConfig"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct IdNamespaceAssociation: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the ID namespace association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID namespace association.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this ID namespace association.
        public let collaborationId: String
        /// The time at which the ID namespace association was created.
        public let createTime: Date
        /// The description of the ID namespace association.
        public let description: String?
        /// The unique identifier for this ID namespace association.
        public let id: String
        /// The configuration settings for the ID mapping table.
        public let idMappingConfig: IdMappingConfig?
        /// The input reference configuration for the ID namespace association.
        public let inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig
        /// The input reference properties for the ID namespace association.
        public let inputReferenceProperties: IdNamespaceAssociationInputReferenceProperties
        /// The Amazon Resource Name (ARN) of the membership resource for this ID namespace association.
        public let membershipArn: String
        /// The unique identifier of the membership resource for this ID namespace association.
        public let membershipId: String
        /// The name of this ID namespace association.
        public let name: String
        /// The most recent time at which the ID namespace association was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, id: String, idMappingConfig: IdMappingConfig? = nil, inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig, inputReferenceProperties: IdNamespaceAssociationInputReferenceProperties, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.idMappingConfig = idMappingConfig
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case idMappingConfig = "idMappingConfig"
            case inputReferenceConfig = "inputReferenceConfig"
            case inputReferenceProperties = "inputReferenceProperties"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct IdNamespaceAssociationInputReferenceConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        public let inputReferenceArn: String
        /// When TRUE, Clean Rooms manages permissions for the ID namespace association resource. When FALSE, the resource owner manages permissions for the ID namespace association resource.
        public let manageResourcePolicies: Bool

        @inlinable
        public init(inputReferenceArn: String, manageResourcePolicies: Bool) {
            self.inputReferenceArn = inputReferenceArn
            self.manageResourcePolicies = manageResourcePolicies
        }

        public func validate(name: String) throws {
            try self.validate(self.inputReferenceArn, name: "inputReferenceArn", parent: name, max: 256)
            try self.validate(self.inputReferenceArn, name: "inputReferenceArn", parent: name, pattern: "^arn:aws:entityresolution:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:idnamespace/[\\d\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case inputReferenceArn = "inputReferenceArn"
            case manageResourcePolicies = "manageResourcePolicies"
        }
    }

    public struct IdNamespaceAssociationInputReferenceProperties: AWSDecodableShape {
        /// Defines how ID mapping workflows are supported for this ID namespace association.
        public let idMappingWorkflowsSupported: [AWSDocument]
        /// The ID namespace type for this ID namespace association.
        public let idNamespaceType: IdNamespaceType

        @inlinable
        public init(idMappingWorkflowsSupported: [AWSDocument], idNamespaceType: IdNamespaceType) {
            self.idMappingWorkflowsSupported = idMappingWorkflowsSupported
            self.idNamespaceType = idNamespaceType
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingWorkflowsSupported = "idMappingWorkflowsSupported"
            case idNamespaceType = "idNamespaceType"
        }
    }

    public struct IdNamespaceAssociationInputReferencePropertiesSummary: AWSDecodableShape {
        /// The ID namespace type for this ID namespace association.
        public let idNamespaceType: IdNamespaceType

        @inlinable
        public init(idNamespaceType: IdNamespaceType) {
            self.idNamespaceType = idNamespaceType
        }

        private enum CodingKeys: String, CodingKey {
            case idNamespaceType = "idNamespaceType"
        }
    }

    public struct IdNamespaceAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this ID namespace association.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID namespace association.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this ID namespace association.
        public let collaborationId: String
        /// The time at which this ID namespace association was created.
        public let createTime: Date
        /// The description of the ID namespace association.
        public let description: String?
        /// The unique identifier of this ID namespace association.
        public let id: String
        /// The input reference configuration details for this ID namespace association.
        public let inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig
        /// The input reference properties for this ID namespace association.
        public let inputReferenceProperties: IdNamespaceAssociationInputReferencePropertiesSummary
        /// The Amazon Resource Name (ARN) of the membership resource for this ID namespace association.
        public let membershipArn: String
        /// The unique identifier of the membership resource for this ID namespace association.
        public let membershipId: String
        /// The name of the ID namespace association.
        public let name: String
        /// The most recent time at which this ID namespace association has been updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, description: String? = nil, id: String, inputReferenceConfig: IdNamespaceAssociationInputReferenceConfig, inputReferenceProperties: IdNamespaceAssociationInputReferencePropertiesSummary, membershipArn: String, membershipId: String, name: String, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case description = "description"
            case id = "id"
            case inputReferenceConfig = "inputReferenceConfig"
            case inputReferenceProperties = "inputReferenceProperties"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case name = "name"
            case updateTime = "updateTime"
        }
    }

    public struct JobComputePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration creator has configured the collaboration member to pay for query and job compute costs (TRUE) or has not configured the  collaboration member to pay for query and job compute costs (FALSE). Exactly one member can be configured to pay for query and job compute costs. An error is returned if the collaboration creator sets a TRUE value for more  than one member in the collaboration.  An error is returned if the collaboration creator sets a  FALSE value for the member who can run queries and jobs.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct ListAnalysisTemplatesInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The identifier for a membership resource.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalysisTemplatesOutput: AWSDecodableShape {
        /// Lists analysis template metadata.
        public let analysisTemplateSummaries: [AnalysisTemplateSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(analysisTemplateSummaries: [AnalysisTemplateSummary], nextToken: String? = nil) {
            self.analysisTemplateSummaries = analysisTemplateSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplateSummaries = "analysisTemplateSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationAnalysisTemplatesInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        public let collaborationIdentifier: String
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationAnalysisTemplatesOutput: AWSDecodableShape {
        /// The metadata of the analysis template within a collaboration.
        public let collaborationAnalysisTemplateSummaries: [CollaborationAnalysisTemplateSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationAnalysisTemplateSummaries: [CollaborationAnalysisTemplateSummary], nextToken: String? = nil) {
            self.collaborationAnalysisTemplateSummaries = collaborationAnalysisTemplateSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationAnalysisTemplateSummaries = "collaborationAnalysisTemplateSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationConfiguredAudienceModelAssociationsInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationConfiguredAudienceModelAssociationsOutput: AWSDecodableShape {
        /// The metadata of the configured audience model association within a collaboration.
        public let collaborationConfiguredAudienceModelAssociationSummaries: [CollaborationConfiguredAudienceModelAssociationSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationConfiguredAudienceModelAssociationSummaries: [CollaborationConfiguredAudienceModelAssociationSummary], nextToken: String? = nil) {
            self.collaborationConfiguredAudienceModelAssociationSummaries = collaborationConfiguredAudienceModelAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationConfiguredAudienceModelAssociationSummaries = "collaborationConfiguredAudienceModelAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationIdNamespaceAssociationsInput: AWSEncodableShape {
        /// The unique identifier of the collaboration that contains the ID namespace associations that you want to retrieve.
        public let collaborationIdentifier: String
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.&gt;
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationIdNamespaceAssociationsOutput: AWSDecodableShape {
        /// The summary information of the collaboration ID namespace associations that you requested.
        public let collaborationIdNamespaceAssociationSummaries: [CollaborationIdNamespaceAssociationSummary]
        /// The token value provided to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationIdNamespaceAssociationSummaries: [CollaborationIdNamespaceAssociationSummary], nextToken: String? = nil) {
            self.collaborationIdNamespaceAssociationSummaries = collaborationIdNamespaceAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationIdNamespaceAssociationSummaries = "collaborationIdNamespaceAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationPrivacyBudgetTemplatesInput: AWSEncodableShape {
        /// A unique identifier for one of your collaborations.
        public let collaborationIdentifier: String
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationPrivacyBudgetTemplatesOutput: AWSDecodableShape {
        /// An array that summarizes the collaboration privacy budget templates. The summary includes collaboration information, creation information, the privacy budget type.
        public let collaborationPrivacyBudgetTemplateSummaries: [CollaborationPrivacyBudgetTemplateSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationPrivacyBudgetTemplateSummaries: [CollaborationPrivacyBudgetTemplateSummary], nextToken: String? = nil) {
            self.collaborationPrivacyBudgetTemplateSummaries = collaborationPrivacyBudgetTemplateSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationPrivacyBudgetTemplateSummaries = "collaborationPrivacyBudgetTemplateSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationPrivacyBudgetsInput: AWSEncodableShape {
        /// A unique identifier for one of your collaborations.
        public let collaborationIdentifier: String
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// Specifies the type of the privacy budget.
        public let privacyBudgetType: PrivacyBudgetType

        @inlinable
        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, privacyBudgetType: PrivacyBudgetType) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.privacyBudgetType = privacyBudgetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.privacyBudgetType, key: "privacyBudgetType")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationPrivacyBudgetsOutput: AWSDecodableShape {
        /// Summaries of the collaboration privacy budgets.
        public let collaborationPrivacyBudgetSummaries: [CollaborationPrivacyBudgetSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationPrivacyBudgetSummaries: [CollaborationPrivacyBudgetSummary], nextToken: String? = nil) {
            self.collaborationPrivacyBudgetSummaries = collaborationPrivacyBudgetSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationPrivacyBudgetSummaries = "collaborationPrivacyBudgetSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListCollaborationsInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The caller's status in a collaboration.
        public let memberStatus: FilterableMemberStatus?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, memberStatus: FilterableMemberStatus? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.memberStatus = memberStatus
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.memberStatus, key: "memberStatus")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListCollaborationsOutput: AWSDecodableShape {
        /// The list of collaborations.
        public let collaborationList: [CollaborationSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationList: [CollaborationSummary], nextToken: String? = nil) {
            self.collaborationList = collaborationList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case collaborationList = "collaborationList"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredAudienceModelAssociationsInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// A unique identifier for a membership that contains the configured audience model associations that you want to retrieve.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredAudienceModelAssociationsOutput: AWSDecodableShape {
        /// Summaries of the configured audience model associations that you requested.
        public let configuredAudienceModelAssociationSummaries: [ConfiguredAudienceModelAssociationSummary]
        /// The token value provided to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(configuredAudienceModelAssociationSummaries: [ConfiguredAudienceModelAssociationSummary], nextToken: String? = nil) {
            self.configuredAudienceModelAssociationSummaries = configuredAudienceModelAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociationSummaries = "configuredAudienceModelAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredTableAssociationsInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// A unique identifier for the membership to list configured table associations for. Currently accepts the membership ID.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredTableAssociationsOutput: AWSDecodableShape {
        /// The retrieved list of configured table associations.
        public let configuredTableAssociationSummaries: [ConfiguredTableAssociationSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(configuredTableAssociationSummaries: [ConfiguredTableAssociationSummary], nextToken: String? = nil) {
            self.configuredTableAssociationSummaries = configuredTableAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociationSummaries = "configuredTableAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListConfiguredTablesInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConfiguredTablesOutput: AWSDecodableShape {
        /// The configured tables listed by the request.
        public let configuredTableSummaries: [ConfiguredTableSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(configuredTableSummaries: [ConfiguredTableSummary], nextToken: String? = nil) {
            self.configuredTableSummaries = configuredTableSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableSummaries = "configuredTableSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListIdMappingTablesInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The unique identifier of the membership that contains the ID mapping tables that you want to view.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdMappingTablesOutput: AWSDecodableShape {
        /// The summary information of the ID mapping tables that you requested.
        public let idMappingTableSummaries: [IdMappingTableSummary]
        /// The token value provided to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(idMappingTableSummaries: [IdMappingTableSummary], nextToken: String? = nil) {
            self.idMappingTableSummaries = idMappingTableSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingTableSummaries = "idMappingTableSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListIdNamespaceAssociationsInput: AWSEncodableShape {
        /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
        public let maxResults: Int?
        /// The unique identifier of the membership that contains the ID namespace association that you want to view.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIdNamespaceAssociationsOutput: AWSDecodableShape {
        /// The summary information of the ID namespace associations that you requested.
        public let idNamespaceAssociationSummaries: [IdNamespaceAssociationSummary]
        /// The token value provided to access the next page of results.
        public let nextToken: String?

        @inlinable
        public init(idNamespaceAssociationSummaries: [IdNamespaceAssociationSummary], nextToken: String? = nil) {
            self.idNamespaceAssociationSummaries = idNamespaceAssociationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case idNamespaceAssociationSummaries = "idNamespaceAssociationSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembersInput: AWSEncodableShape {
        /// The identifier of the collaboration in which the members are listed.
        public let collaborationIdentifier: String
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersOutput: AWSDecodableShape {
        /// The list of members returned by the ListMembers operation.
        public let memberSummaries: [MemberSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(memberSummaries: [MemberSummary], nextToken: String? = nil) {
            self.memberSummaries = memberSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case memberSummaries = "memberSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListMembershipsInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// A filter which will return only memberships in the specified status.
        public let status: MembershipStatus?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, status: MembershipStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembershipsOutput: AWSDecodableShape {
        /// The list of memberships returned from the ListMemberships operation.
        public let membershipSummaries: [MembershipSummary]
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(membershipSummaries: [MembershipSummary], nextToken: String? = nil) {
            self.membershipSummaries = membershipSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case membershipSummaries = "membershipSummaries"
            case nextToken = "nextToken"
        }
    }

    public struct ListPrivacyBudgetTemplatesInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget templates are retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPrivacyBudgetTemplatesOutput: AWSDecodableShape {
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// An array that summarizes the privacy budget templates. The summary includes collaboration information, creation information, and privacy budget type.
        public let privacyBudgetTemplateSummaries: [PrivacyBudgetTemplateSummary]

        @inlinable
        public init(nextToken: String? = nil, privacyBudgetTemplateSummaries: [PrivacyBudgetTemplateSummary]) {
            self.nextToken = nextToken
            self.privacyBudgetTemplateSummaries = privacyBudgetTemplateSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case privacyBudgetTemplateSummaries = "privacyBudgetTemplateSummaries"
        }
    }

    public struct ListPrivacyBudgetsInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// The privacy budget type.
        public let privacyBudgetType: PrivacyBudgetType

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil, privacyBudgetType: PrivacyBudgetType) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
            self.privacyBudgetType = privacyBudgetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.privacyBudgetType, key: "privacyBudgetType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPrivacyBudgetsOutput: AWSDecodableShape {
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// An array that summarizes the privacy budgets. The summary includes collaboration information, membership information, privacy budget template information, and privacy budget details.
        public let privacyBudgetSummaries: [PrivacyBudgetSummary]

        @inlinable
        public init(nextToken: String? = nil, privacyBudgetSummaries: [PrivacyBudgetSummary]) {
            self.nextToken = nextToken
            self.privacyBudgetSummaries = privacyBudgetSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case privacyBudgetSummaries = "privacyBudgetSummaries"
        }
    }

    public struct ListProtectedJobsInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call.  The service chooses a default number if you don't set one. The service might  return a `nextToken` even if the `maxResults` value has not been met.
        public let maxResults: Int?
        /// The identifier for the membership in the collaboration.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// A filter on the status of the protected job.
        public let status: ProtectedJobStatus?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil, status: ProtectedJobStatus? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProtectedJobsOutput: AWSDecodableShape {
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// A list of protected job summaries.
        public let protectedJobs: [ProtectedJobSummary]

        @inlinable
        public init(nextToken: String? = nil, protectedJobs: [ProtectedJobSummary]) {
            self.nextToken = nextToken
            self.protectedJobs = protectedJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case protectedJobs = "protectedJobs"
        }
    }

    public struct ListProtectedQueriesInput: AWSEncodableShape {
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the  `maxResults` value has not been met.
        public let maxResults: Int?
        /// The identifier for the membership in the collaboration.
        public let membershipIdentifier: String
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// A filter on the status of the protected query.
        public let status: ProtectedQueryStatus?

        @inlinable
        public init(maxResults: Int? = nil, membershipIdentifier: String, nextToken: String? = nil, status: ProtectedQueryStatus? = nil) {
            self.maxResults = maxResults
            self.membershipIdentifier = membershipIdentifier
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProtectedQueriesOutput: AWSDecodableShape {
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// A list of protected queries.
        public let protectedQueries: [ProtectedQuerySummary]

        @inlinable
        public init(nextToken: String? = nil, protectedQueries: [ProtectedQuerySummary]) {
            self.nextToken = nextToken
            self.protectedQueries = protectedQueries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case protectedQueries = "protectedQueries"
        }
    }

    public struct ListSchemasInput: AWSEncodableShape {
        /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
        public let collaborationIdentifier: String
        /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the
        /// `maxResults` value has not been met.
        public let maxResults: Int?
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// If present, filter schemas by schema type.
        public let schemaType: SchemaType?

        @inlinable
        public init(collaborationIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, schemaType: SchemaType? = nil) {
            self.collaborationIdentifier = collaborationIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.schemaType = schemaType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.schemaType, key: "schemaType")
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10240)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSchemasOutput: AWSDecodableShape {
        /// The pagination token that's used to fetch the next set of results.
        public let nextToken: String?
        /// The retrieved list of schemas.
        public let schemaSummaries: [SchemaSummary]

        @inlinable
        public init(nextToken: String? = nil, schemaSummaries: [SchemaSummary]) {
            self.nextToken = nextToken
            self.schemaSummaries = schemaSummaries
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case schemaSummaries = "schemaSummaries"
        }
    }

    public struct ListTagsForResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceOutput: AWSDecodableShape {
        /// A map of objects specifying each key name and value.
        public let tags: [String: String]

        @inlinable
        public init(tags: [String: String]) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct MLMemberAbilities: AWSEncodableShape & AWSDecodableShape {
        /// The custom ML member abilities for a collaboration member.
        public let customMLMemberAbilities: [CustomMLMemberAbility]

        @inlinable
        public init(customMLMemberAbilities: [CustomMLMemberAbility]) {
            self.customMLMemberAbilities = customMLMemberAbilities
        }

        public func validate(name: String) throws {
            try self.validate(self.customMLMemberAbilities, name: "customMLMemberAbilities", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case customMLMemberAbilities = "customMLMemberAbilities"
        }
    }

    public struct MLPaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// The payment responsibilities accepted by the member for model inference.
        public let modelInference: ModelInferencePaymentConfig?
        /// The payment responsibilities accepted by the member for model training.
        public let modelTraining: ModelTrainingPaymentConfig?

        @inlinable
        public init(modelInference: ModelInferencePaymentConfig? = nil, modelTraining: ModelTrainingPaymentConfig? = nil) {
            self.modelInference = modelInference
            self.modelTraining = modelTraining
        }

        private enum CodingKeys: String, CodingKey {
            case modelInference = "modelInference"
            case modelTraining = "modelTraining"
        }
    }

    public struct MemberSpecification: AWSEncodableShape {
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let accountId: String
        /// The member's display name.
        public let displayName: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// The ML abilities granted to the collaboration member.
        public let mlMemberAbilities: MLMemberAbilities?
        /// The collaboration member's payment responsibilities set by the collaboration creator.  If the collaboration creator hasn't specied anyone as the member paying for query compute costs, then the member who can query is the default payer.
        public let paymentConfiguration: PaymentConfiguration?

        @inlinable
        public init(accountId: String, displayName: String, memberAbilities: [MemberAbility], mlMemberAbilities: MLMemberAbilities? = nil, paymentConfiguration: PaymentConfiguration? = nil) {
            self.accountId = accountId
            self.displayName = displayName
            self.memberAbilities = memberAbilities
            self.mlMemberAbilities = mlMemberAbilities
            self.paymentConfiguration = paymentConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
            try self.mlMemberAbilities?.validate(name: "\(name).mlMemberAbilities")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case displayName = "displayName"
            case memberAbilities = "memberAbilities"
            case mlMemberAbilities = "mlMemberAbilities"
            case paymentConfiguration = "paymentConfiguration"
        }
    }

    public struct MemberSummary: AWSDecodableShape {
        /// The abilities granted to the collaboration member.
        public let abilities: [MemberAbility]
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let accountId: String
        /// The time when the member was created.
        public let createTime: Date
        /// The member's display name.
        public let displayName: String
        /// The unique ARN for the member's associated membership, if present.
        public let membershipArn: String?
        /// The unique ID for the member's associated membership, if present.
        public let membershipId: String?
        /// Provides a summary of the ML abilities for the collaboration member.
        public let mlAbilities: MLMemberAbilities?
        /// The collaboration member's payment responsibilities set by the collaboration creator.
        public let paymentConfiguration: PaymentConfiguration
        /// The status of the member.
        public let status: MemberStatus
        /// The time the member metadata was last updated.
        public let updateTime: Date

        @inlinable
        public init(abilities: [MemberAbility], accountId: String, createTime: Date, displayName: String, membershipArn: String? = nil, membershipId: String? = nil, mlAbilities: MLMemberAbilities? = nil, paymentConfiguration: PaymentConfiguration, status: MemberStatus, updateTime: Date) {
            self.abilities = abilities
            self.accountId = accountId
            self.createTime = createTime
            self.displayName = displayName
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.mlAbilities = mlAbilities
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case abilities = "abilities"
            case accountId = "accountId"
            case createTime = "createTime"
            case displayName = "displayName"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case mlAbilities = "mlAbilities"
            case paymentConfiguration = "paymentConfiguration"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct Membership: AWSDecodableShape {
        /// The unique ARN for the membership.
        public let arn: String
        /// The unique ARN for the membership's associated collaboration.
        public let collaborationArn: String
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        public let collaborationCreatorAccountId: String
        /// The display name of the collaboration creator.
        public let collaborationCreatorDisplayName: String
        /// The unique ID for the membership's collaboration.
        public let collaborationId: String
        /// The name of the membership's collaboration.
        public let collaborationName: String
        /// The time when the membership was created.
        public let createTime: Date
        ///  The default job result configuration for the membership.
        public let defaultJobResultConfiguration: MembershipProtectedJobResultConfiguration?
        /// The default protected query result configuration as specified by the member who can receive results.
        public let defaultResultConfiguration: MembershipProtectedQueryResultConfiguration?
        /// The unique ID of the membership.
        public let id: String
        /// An indicator as to whether job logging has been enabled or disabled  for the collaboration.  When ENABLED, Clean Rooms logs details about jobs run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let jobLogStatus: MembershipJobLogStatus?
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// Specifies the ML member abilities that are granted to a collaboration member.
        public let mlMemberAbilities: MLMemberAbilities?
        /// The payment responsibilities accepted by the collaboration member.
        public let paymentConfiguration: MembershipPaymentConfiguration
        /// An indicator as to whether query logging has been enabled or disabled for the membership. When ENABLED, Clean Rooms logs details about queries run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let queryLogStatus: MembershipQueryLogStatus
        /// The status of the membership.
        public let status: MembershipStatus
        /// The time the membership metadata was last updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationCreatorAccountId: String, collaborationCreatorDisplayName: String, collaborationId: String, collaborationName: String, createTime: Date, defaultJobResultConfiguration: MembershipProtectedJobResultConfiguration? = nil, defaultResultConfiguration: MembershipProtectedQueryResultConfiguration? = nil, id: String, jobLogStatus: MembershipJobLogStatus? = nil, memberAbilities: [MemberAbility], mlMemberAbilities: MLMemberAbilities? = nil, paymentConfiguration: MembershipPaymentConfiguration, queryLogStatus: MembershipQueryLogStatus, status: MembershipStatus, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.defaultJobResultConfiguration = defaultJobResultConfiguration
            self.defaultResultConfiguration = defaultResultConfiguration
            self.id = id
            self.jobLogStatus = jobLogStatus
            self.memberAbilities = memberAbilities
            self.mlMemberAbilities = mlMemberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.queryLogStatus = queryLogStatus
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationCreatorAccountId = "collaborationCreatorAccountId"
            case collaborationCreatorDisplayName = "collaborationCreatorDisplayName"
            case collaborationId = "collaborationId"
            case collaborationName = "collaborationName"
            case createTime = "createTime"
            case defaultJobResultConfiguration = "defaultJobResultConfiguration"
            case defaultResultConfiguration = "defaultResultConfiguration"
            case id = "id"
            case jobLogStatus = "jobLogStatus"
            case memberAbilities = "memberAbilities"
            case mlMemberAbilities = "mlMemberAbilities"
            case paymentConfiguration = "paymentConfiguration"
            case queryLogStatus = "queryLogStatus"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct MembershipJobComputePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration member has accepted to pay for job  compute costs (TRUE) or has not accepted to pay for query and job compute costs (FALSE). There is only one member who pays for queries and jobs.  An error message is returned for the following reasons:    If you set the value to FALSE but you are responsible to  pay for query and job compute costs.    If you set the value to TRUE but you are not responsible to pay for query and job compute costs.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct MembershipMLPaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// The payment responsibilities accepted by the member for model inference.
        public let modelInference: MembershipModelInferencePaymentConfig?
        /// The payment responsibilities accepted by the member for model training.
        public let modelTraining: MembershipModelTrainingPaymentConfig?

        @inlinable
        public init(modelInference: MembershipModelInferencePaymentConfig? = nil, modelTraining: MembershipModelTrainingPaymentConfig? = nil) {
            self.modelInference = modelInference
            self.modelTraining = modelTraining
        }

        private enum CodingKeys: String, CodingKey {
            case modelInference = "modelInference"
            case modelTraining = "modelTraining"
        }
    }

    public struct MembershipModelInferencePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration member has accepted to pay for model inference costs (TRUE) or has not accepted to pay for model inference costs (FALSE). If the collaboration creator has not specified anyone to pay for model inference costs, then the member who can query is the default payer.  An error message is returned for the following reasons:    If you set the value to FALSE but you are responsible to pay for model inference costs.    If you set the value to TRUE but you are not responsible to pay for model inference costs.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct MembershipModelTrainingPaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration member has accepted to pay for model training costs (TRUE) or has not accepted to pay for model training costs (FALSE). If the collaboration creator has not specified anyone to pay for model training costs, then the member who can query is the default payer.  An error message is returned for the following reasons:    If you set the value to FALSE but you are responsible to pay for model training costs.    If you set the value to TRUE but you are not responsible to pay for model training costs.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct MembershipPaymentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The payment responsibilities accepted by the collaboration member for job compute costs.
        public let jobCompute: MembershipJobComputePaymentConfig?
        /// The payment responsibilities accepted by the collaboration member for machine learning costs.
        public let machineLearning: MembershipMLPaymentConfig?
        /// The payment responsibilities accepted by the collaboration member for query compute costs.
        public let queryCompute: MembershipQueryComputePaymentConfig

        @inlinable
        public init(jobCompute: MembershipJobComputePaymentConfig? = nil, machineLearning: MembershipMLPaymentConfig? = nil, queryCompute: MembershipQueryComputePaymentConfig) {
            self.jobCompute = jobCompute
            self.machineLearning = machineLearning
            self.queryCompute = queryCompute
        }

        private enum CodingKeys: String, CodingKey {
            case jobCompute = "jobCompute"
            case machineLearning = "machineLearning"
            case queryCompute = "queryCompute"
        }
    }

    public struct MembershipProtectedJobResultConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The output configuration for a protected job result.
        public let outputConfiguration: MembershipProtectedJobOutputConfiguration
        /// The unique ARN for an IAM role that is used by Clean Rooms to write protected job results to the result location, given by the member who can receive results.
        public let roleArn: String

        @inlinable
        public init(outputConfiguration: MembershipProtectedJobOutputConfiguration, roleArn: String) {
            self.outputConfiguration = outputConfiguration
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct MembershipProtectedQueryResultConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for protected query results.
        public let outputConfiguration: MembershipProtectedQueryOutputConfiguration
        /// The unique ARN for an IAM role that is used by Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        public let roleArn: String?

        @inlinable
        public init(outputConfiguration: MembershipProtectedQueryOutputConfiguration, roleArn: String? = nil) {
            self.outputConfiguration = outputConfiguration
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct MembershipQueryComputePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration member has accepted to pay for query compute costs (TRUE) or has not accepted to pay for query compute costs (FALSE). If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer.  An error message is returned for the following reasons:    If you set the value to FALSE but you are responsible to pay for query compute costs.    If you set the value to TRUE but you are not responsible to pay for query compute costs.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct MembershipSummary: AWSDecodableShape {
        /// The unique ARN for the membership.
        public let arn: String
        /// The unique ARN for the membership's associated collaboration.
        public let collaborationArn: String
        /// The identifier of the Amazon Web Services principal that created the collaboration. Currently only supports Amazon Web Services account ID.
        public let collaborationCreatorAccountId: String
        /// The display name of the collaboration creator.
        public let collaborationCreatorDisplayName: String
        /// The unique ID for the membership's collaboration.
        public let collaborationId: String
        /// The name for the membership's collaboration.
        public let collaborationName: String
        /// The time when the membership was created.
        public let createTime: Date
        /// The unique ID for the membership's collaboration.
        public let id: String
        /// The abilities granted to the collaboration member.
        public let memberAbilities: [MemberAbility]
        /// Provides a summary of the ML abilities for the collaboration member.
        public let mlMemberAbilities: MLMemberAbilities?
        /// The payment responsibilities accepted by the collaboration member.
        public let paymentConfiguration: MembershipPaymentConfiguration
        /// The status of the membership.
        public let status: MembershipStatus
        /// The time the membership metadata was last updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationCreatorAccountId: String, collaborationCreatorDisplayName: String, collaborationId: String, collaborationName: String, createTime: Date, id: String, memberAbilities: [MemberAbility], mlMemberAbilities: MLMemberAbilities? = nil, paymentConfiguration: MembershipPaymentConfiguration, status: MembershipStatus, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.id = id
            self.memberAbilities = memberAbilities
            self.mlMemberAbilities = mlMemberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationCreatorAccountId = "collaborationCreatorAccountId"
            case collaborationCreatorDisplayName = "collaborationCreatorDisplayName"
            case collaborationId = "collaborationId"
            case collaborationName = "collaborationName"
            case createTime = "createTime"
            case id = "id"
            case memberAbilities = "memberAbilities"
            case mlMemberAbilities = "mlMemberAbilities"
            case paymentConfiguration = "paymentConfiguration"
            case status = "status"
            case updateTime = "updateTime"
        }
    }

    public struct ModelInferencePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration creator has configured the collaboration member to pay for model inference costs (TRUE) or has not configured the collaboration member to pay for model inference costs (FALSE). Exactly one member can be configured to pay for model inference costs. An error is returned if the collaboration creator sets a TRUE value for more than one member in the collaboration.  If the collaboration creator hasn't specified anyone as the member paying for model inference costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a FALSE value for the member who can query.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct ModelTrainingPaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration creator has configured the collaboration member to pay for model training costs (TRUE) or has not configured the collaboration member to pay for model training costs (FALSE). Exactly one member can be configured to pay for model training costs. An error is returned if the collaboration creator sets a TRUE value for more than one member in the collaboration.  If the collaboration creator hasn't specified anyone as the member paying for model training costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a FALSE value for the member who can query.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct PaymentConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The compute configuration for the job.
        public let jobCompute: JobComputePaymentConfig?
        /// An object representing the collaboration member's machine learning payment responsibilities set by the collaboration creator.
        public let machineLearning: MLPaymentConfig?
        /// The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        public let queryCompute: QueryComputePaymentConfig

        @inlinable
        public init(jobCompute: JobComputePaymentConfig? = nil, machineLearning: MLPaymentConfig? = nil, queryCompute: QueryComputePaymentConfig) {
            self.jobCompute = jobCompute
            self.machineLearning = machineLearning
            self.queryCompute = queryCompute
        }

        private enum CodingKeys: String, CodingKey {
            case jobCompute = "jobCompute"
            case machineLearning = "machineLearning"
            case queryCompute = "queryCompute"
        }
    }

    public struct PopulateIdMappingTableInput: AWSEncodableShape {
        /// The unique identifier of the ID mapping table that you want to populate.
        public let idMappingTableIdentifier: String
        /// The unique identifier of the membership that contains the ID mapping table that you want to populate.
        public let membershipIdentifier: String

        @inlinable
        public init(idMappingTableIdentifier: String, membershipIdentifier: String) {
            self.idMappingTableIdentifier = idMappingTableIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.idMappingTableIdentifier, key: "idMappingTableIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, max: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, min: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct PopulateIdMappingTableOutput: AWSDecodableShape {
        /// The unique identifier of the mapping job that will populate the ID mapping table.
        public let idMappingJobId: String

        @inlinable
        public init(idMappingJobId: String) {
            self.idMappingJobId = idMappingJobId
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingJobId = "idMappingJobId"
        }
    }

    public struct PreviewPrivacyImpactInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. Accepts a membership ID.
        public let membershipIdentifier: String
        /// Specifies the desired epsilon and noise parameters to preview.
        public let parameters: PreviewPrivacyImpactParametersInput

        @inlinable
        public init(membershipIdentifier: String, parameters: PreviewPrivacyImpactParametersInput) {
            self.membershipIdentifier = membershipIdentifier
            self.parameters = parameters
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encode(self.parameters, forKey: .parameters)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.parameters.validate(name: "\(name).parameters")
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
        }
    }

    public struct PreviewPrivacyImpactOutput: AWSDecodableShape {
        /// An estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters. This does not change the privacy budget.
        public let privacyImpact: PrivacyImpact

        @inlinable
        public init(privacyImpact: PrivacyImpact) {
            self.privacyImpact = privacyImpact
        }

        private enum CodingKeys: String, CodingKey {
            case privacyImpact = "privacyImpact"
        }
    }

    public struct PrivacyBudgetSummary: AWSDecodableShape {
        /// The provided privacy budget.
        public let budget: PrivacyBudget
        /// The ARN of the collaboration that contains this privacy budget.
        public let collaborationArn: String
        /// The unique identifier of the collaboration that contains this privacy budget.
        public let collaborationId: String
        /// The time at which the privacy budget was created.
        public let createTime: Date
        /// The unique identifier of the privacy budget.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget summary.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// The ARN of the privacy budget template.
        public let privacyBudgetTemplateArn: String
        /// The unique identifier of the privacy budget template.
        public let privacyBudgetTemplateId: String
        /// Specifies the type of the privacy budget.
        public let type: PrivacyBudgetType
        /// The most recent time at which the privacy budget was updated.
        public let updateTime: Date

        @inlinable
        public init(budget: PrivacyBudget, collaborationArn: String, collaborationId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, privacyBudgetTemplateArn: String, privacyBudgetTemplateId: String, type: PrivacyBudgetType, updateTime: Date) {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case budget = "budget"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case privacyBudgetTemplateArn = "privacyBudgetTemplateArn"
            case privacyBudgetTemplateId = "privacyBudgetTemplateId"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct PrivacyBudgetTemplate: AWSDecodableShape {
        /// The ARN of the privacy budget template.
        public let arn: String
        /// How often the privacy budget refreshes.  If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        public let autoRefresh: PrivacyBudgetTemplateAutoRefresh
        /// The ARN of the collaboration that contains this privacy budget template.
        public let collaborationArn: String
        /// The unique ID of the collaboration that contains this privacy budget template.
        public let collaborationId: String
        /// The time at which the privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the privacy budget template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateParametersOutput
        /// Specifies the type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the privacy budget template was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, autoRefresh: PrivacyBudgetTemplateAutoRefresh, collaborationArn: String, collaborationId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, parameters: PrivacyBudgetTemplateParametersOutput, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case autoRefresh = "autoRefresh"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct PrivacyBudgetTemplateSummary: AWSDecodableShape {
        /// The ARN of the privacy budget template.
        public let arn: String
        /// The ARN of the collaboration that contains this privacy budget template.
        public let collaborationArn: String
        /// The unique ID of the collaboration that contains this privacy budget template.
        public let collaborationId: String
        /// The time at which the privacy budget template was created.
        public let createTime: Date
        /// The unique identifier of the privacy budget template.
        public let id: String
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        public let membershipArn: String
        /// The identifier for a membership resource.
        public let membershipId: String
        /// The type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType
        /// The most recent time at which the privacy budget template was updated.
        public let updateTime: Date

        @inlinable
        public init(arn: String, collaborationArn: String, collaborationId: String, createTime: Date, id: String, membershipArn: String, membershipId: String, privacyBudgetType: PrivacyBudgetType, updateTime: Date) {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case privacyBudgetType = "privacyBudgetType"
            case updateTime = "updateTime"
        }
    }

    public struct ProtectedJob: AWSDecodableShape {
        ///  The creation time of the protected job.
        public let createTime: Date
        ///  The error from the protected job.
        public let error: ProtectedJobError?
        /// The identifier for a protected job instance.
        public let id: String
        ///  The job parameters for the protected job.
        public let jobParameters: ProtectedJobParameters?
        /// The ARN of the membership.
        public let membershipArn: String
        /// he identifier for the membership.
        public let membershipId: String
        ///  The result of the protected job.
        public let result: ProtectedJobResult?
        /// Contains any details needed to write the job results.
        public let resultConfiguration: ProtectedJobResultConfigurationOutput?
        ///  The statistics of the protected job.
        public let statistics: ProtectedJobStatistics?
        ///  The status of the protected job.
        public let status: ProtectedJobStatus

        @inlinable
        public init(createTime: Date, error: ProtectedJobError? = nil, id: String, jobParameters: ProtectedJobParameters? = nil, membershipArn: String, membershipId: String, result: ProtectedJobResult? = nil, resultConfiguration: ProtectedJobResultConfigurationOutput? = nil, statistics: ProtectedJobStatistics? = nil, status: ProtectedJobStatus) {
            self.createTime = createTime
            self.error = error
            self.id = id
            self.jobParameters = jobParameters
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.result = result
            self.resultConfiguration = resultConfiguration
            self.statistics = statistics
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case error = "error"
            case id = "id"
            case jobParameters = "jobParameters"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case result = "result"
            case resultConfiguration = "resultConfiguration"
            case statistics = "statistics"
            case status = "status"
        }
    }

    public struct ProtectedJobDirectAnalysisConfigurationDetails: AWSDecodableShape {
        ///  The receiver account IDs.
        public let receiverAccountIds: [String]?

        @inlinable
        public init(receiverAccountIds: [String]? = nil) {
            self.receiverAccountIds = receiverAccountIds
        }

        private enum CodingKeys: String, CodingKey {
            case receiverAccountIds = "receiverAccountIds"
        }
    }

    public struct ProtectedJobError: AWSDecodableShape {
        ///  The error code for the protected job.
        public let code: String
        ///  The message for the protected job error.
        public let message: String

        @inlinable
        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ProtectedJobMemberOutputConfigurationInput: AWSEncodableShape {
        ///  The account ID.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct ProtectedJobMemberOutputConfigurationOutput: AWSDecodableShape {
        ///  The account ID.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct ProtectedJobParameters: AWSEncodableShape & AWSDecodableShape {
        ///  The ARN of the analysis template.
        public let analysisTemplateArn: String?

        @inlinable
        public init(analysisTemplateArn: String? = nil) {
            self.analysisTemplateArn = analysisTemplateArn
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, max: 200)
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplateArn = "analysisTemplateArn"
        }
    }

    public struct ProtectedJobReceiverConfiguration: AWSDecodableShape {
        ///  The analysis type for the protected job receiver configuration.
        public let analysisType: ProtectedJobAnalysisType
        ///  The configuration details for the protected job receiver.
        public let configurationDetails: ProtectedJobConfigurationDetails?

        @inlinable
        public init(analysisType: ProtectedJobAnalysisType, configurationDetails: ProtectedJobConfigurationDetails? = nil) {
            self.analysisType = analysisType
            self.configurationDetails = configurationDetails
        }

        private enum CodingKeys: String, CodingKey {
            case analysisType = "analysisType"
            case configurationDetails = "configurationDetails"
        }
    }

    public struct ProtectedJobResult: AWSDecodableShape {
        ///  The output of the protected job.
        public let output: ProtectedJobOutput

        @inlinable
        public init(output: ProtectedJobOutput) {
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
        }
    }

    public struct ProtectedJobResultConfigurationInput: AWSEncodableShape {
        ///  The output configuration for a protected job result.
        public let outputConfiguration: ProtectedJobOutputConfigurationInput

        @inlinable
        public init(outputConfiguration: ProtectedJobOutputConfigurationInput) {
            self.outputConfiguration = outputConfiguration
        }

        public func validate(name: String) throws {
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
        }
    }

    public struct ProtectedJobResultConfigurationOutput: AWSDecodableShape {
        /// The output configuration.
        public let outputConfiguration: ProtectedJobOutputConfigurationOutput

        @inlinable
        public init(outputConfiguration: ProtectedJobOutputConfigurationOutput) {
            self.outputConfiguration = outputConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
        }
    }

    public struct ProtectedJobS3Output: AWSDecodableShape {
        ///  The S3 location for the protected job output.
        public let location: String

        @inlinable
        public init(location: String) {
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
        }
    }

    public struct ProtectedJobS3OutputConfigurationInput: AWSEncodableShape & AWSDecodableShape {
        ///  The S3 bucket for job output.
        public let bucket: String
        /// The S3 prefix to unload the protected job results.
        public let keyPrefix: String?

        @inlinable
        public init(bucket: String, keyPrefix: String? = nil) {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
        }

        public func validate(name: String) throws {
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, max: 512)
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, pattern: "^[\\w!.=*/-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case keyPrefix = "keyPrefix"
        }
    }

    public struct ProtectedJobS3OutputConfigurationOutput: AWSDecodableShape {
        ///  The S3 bucket for job output.
        public let bucket: String
        /// The S3 prefix to unload the protected job results.
        public let keyPrefix: String?

        @inlinable
        public init(bucket: String, keyPrefix: String? = nil) {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case keyPrefix = "keyPrefix"
        }
    }

    public struct ProtectedJobSingleMemberOutput: AWSDecodableShape {
        /// The Amazon Web Services account ID of the member in the collaboration who can receive  results from analyses.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct ProtectedJobStatistics: AWSDecodableShape {
        ///  The billed resource utilization for the protected job.
        public let billedResourceUtilization: BilledJobResourceUtilization?
        /// The duration of the protected job, from creation until job completion, in milliseconds.
        public let totalDurationInMillis: Int64?

        @inlinable
        public init(billedResourceUtilization: BilledJobResourceUtilization? = nil, totalDurationInMillis: Int64? = nil) {
            self.billedResourceUtilization = billedResourceUtilization
            self.totalDurationInMillis = totalDurationInMillis
        }

        private enum CodingKeys: String, CodingKey {
            case billedResourceUtilization = "billedResourceUtilization"
            case totalDurationInMillis = "totalDurationInMillis"
        }
    }

    public struct ProtectedJobSummary: AWSDecodableShape {
        /// The time the protected job was created.
        public let createTime: Date
        ///  The ID of the protected job.
        public let id: String
        /// The unique ARN for the membership that initiated the protected job.
        public let membershipArn: String
        /// The unique ID for the membership that initiated the protected job.
        public let membershipId: String
        ///  The receiver configurations for the protected job.
        public let receiverConfigurations: [ProtectedJobReceiverConfiguration]
        /// The status of the protected job.
        public let status: ProtectedJobStatus

        @inlinable
        public init(createTime: Date, id: String, membershipArn: String, membershipId: String, receiverConfigurations: [ProtectedJobReceiverConfiguration], status: ProtectedJobStatus) {
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.receiverConfigurations = receiverConfigurations
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case receiverConfigurations = "receiverConfigurations"
            case status = "status"
        }
    }

    public struct ProtectedQuery: AWSDecodableShape {
        ///  The compute configuration for the protected query.
        public let computeConfiguration: ComputeConfiguration?
        /// The time at which the protected query was created.
        public let createTime: Date
        /// The sensitivity parameters of the differential privacy results of the protected query.
        public let differentialPrivacy: DifferentialPrivacyParameters?
        /// An error thrown by the protected query.
        public let error: ProtectedQueryError?
        /// The identifier for a protected query instance.
        public let id: String
        /// The ARN of the membership.
        public let membershipArn: String
        /// The identifier for the membership.
        public let membershipId: String
        /// The result of the protected query.
        public let result: ProtectedQueryResult?
        /// Contains any details needed to write the query results.
        public let resultConfiguration: ProtectedQueryResultConfiguration?
        /// The protected query SQL parameters.
        public let sqlParameters: ProtectedQuerySQLParameters?
        /// Statistics about protected query execution.
        public let statistics: ProtectedQueryStatistics?
        /// The status of the query.
        public let status: ProtectedQueryStatus

        @inlinable
        public init(computeConfiguration: ComputeConfiguration? = nil, createTime: Date, differentialPrivacy: DifferentialPrivacyParameters? = nil, error: ProtectedQueryError? = nil, id: String, membershipArn: String, membershipId: String, result: ProtectedQueryResult? = nil, resultConfiguration: ProtectedQueryResultConfiguration? = nil, sqlParameters: ProtectedQuerySQLParameters? = nil, statistics: ProtectedQueryStatistics? = nil, status: ProtectedQueryStatus) {
            self.computeConfiguration = computeConfiguration
            self.createTime = createTime
            self.differentialPrivacy = differentialPrivacy
            self.error = error
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.result = result
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.statistics = statistics
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case computeConfiguration = "computeConfiguration"
            case createTime = "createTime"
            case differentialPrivacy = "differentialPrivacy"
            case error = "error"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case result = "result"
            case resultConfiguration = "resultConfiguration"
            case sqlParameters = "sqlParameters"
            case statistics = "statistics"
            case status = "status"
        }
    }

    public struct ProtectedQueryError: AWSDecodableShape {
        /// An error code for the error.
        public let code: String
        /// A description of why the query failed.
        public let message: String

        @inlinable
        public init(code: String, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct ProtectedQueryMemberOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the account.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, min: 12)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d+$")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct ProtectedQueryResult: AWSDecodableShape {
        /// The output of the protected query.
        public let output: ProtectedQueryOutput

        @inlinable
        public init(output: ProtectedQueryOutput) {
            self.output = output
        }

        private enum CodingKeys: String, CodingKey {
            case output = "output"
        }
    }

    public struct ProtectedQueryResultConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration for protected query results.
        public let outputConfiguration: ProtectedQueryOutputConfiguration

        @inlinable
        public init(outputConfiguration: ProtectedQueryOutputConfiguration) {
            self.outputConfiguration = outputConfiguration
        }

        public func validate(name: String) throws {
            try self.outputConfiguration.validate(name: "\(name).outputConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case outputConfiguration = "outputConfiguration"
        }
    }

    public struct ProtectedQueryS3Output: AWSDecodableShape {
        /// The S3 location of the result.
        public let location: String

        @inlinable
        public init(location: String) {
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case location = "location"
        }
    }

    public struct ProtectedQueryS3OutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket to unload the protected query results.
        public let bucket: String
        /// The S3 prefix to unload the protected query results.
        public let keyPrefix: String?
        /// Intended file format of the result.
        public let resultFormat: ResultFormat
        /// Indicates whether files should be output as a single file (TRUE) or output as multiple files (FALSE). This parameter is only supported for analyses with the Spark analytics engine.
        public let singleFileOutput: Bool?

        @inlinable
        public init(bucket: String, keyPrefix: String? = nil, resultFormat: ResultFormat, singleFileOutput: Bool? = nil) {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.resultFormat = resultFormat
            self.singleFileOutput = singleFileOutput
        }

        public func validate(name: String) throws {
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, max: 512)
            try self.validate(self.keyPrefix, name: "keyPrefix", parent: name, pattern: "^[\\w!.=*/-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case keyPrefix = "keyPrefix"
            case resultFormat = "resultFormat"
            case singleFileOutput = "singleFileOutput"
        }
    }

    public struct ProtectedQuerySQLParameters: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public let analysisTemplateArn: String?
        /// The protected query SQL parameters.
        public let parameters: [String: String]?
        /// The query string to be submitted.
        public let queryString: String?

        @inlinable
        public init(analysisTemplateArn: String? = nil, parameters: [String: String]? = nil, queryString: String? = nil) {
            self.analysisTemplateArn = analysisTemplateArn
            self.parameters = parameters
            self.queryString = queryString
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, max: 200)
            try self.validate(self.analysisTemplateArn, name: "analysisTemplateArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:membership/[\\d\\w-]+/analysistemplate/[\\d\\w-]+$")
            try self.parameters?.forEach {
                try validate($0.key, name: "parameters.key", parent: name, max: 100)
                try validate($0.key, name: "parameters.key", parent: name, min: 1)
                try validate($0.key, name: "parameters.key", parent: name, pattern: "^[0-9a-zA-Z_]+$")
                try validate($0.value, name: "parameters[\"\($0.key)\"]", parent: name, max: 250)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplateArn = "analysisTemplateArn"
            case parameters = "parameters"
            case queryString = "queryString"
        }
    }

    public struct ProtectedQuerySingleMemberOutput: AWSDecodableShape {
        /// The Amazon Web Services account ID of the member in the collaboration who can receive results for the query.
        public let accountId: String

        @inlinable
        public init(accountId: String) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
        }
    }

    public struct ProtectedQueryStatistics: AWSDecodableShape {
        ///  The billed resource utilization.
        public let billedResourceUtilization: BilledResourceUtilization?
        /// The duration of the protected query, from creation until query completion, in milliseconds.
        public let totalDurationInMillis: Int64?

        @inlinable
        public init(billedResourceUtilization: BilledResourceUtilization? = nil, totalDurationInMillis: Int64? = nil) {
            self.billedResourceUtilization = billedResourceUtilization
            self.totalDurationInMillis = totalDurationInMillis
        }

        private enum CodingKeys: String, CodingKey {
            case billedResourceUtilization = "billedResourceUtilization"
            case totalDurationInMillis = "totalDurationInMillis"
        }
    }

    public struct ProtectedQuerySummary: AWSDecodableShape {
        /// The time the protected query was created.
        public let createTime: Date
        /// The unique ID of the protected query.
        public let id: String
        /// The unique ARN for the membership that initiated the protected query.
        public let membershipArn: String
        /// The unique ID for the membership that initiated the protected query.
        public let membershipId: String
        ///  The receiver configuration.
        public let receiverConfigurations: [ReceiverConfiguration]
        /// The status of the protected query.
        public let status: ProtectedQueryStatus

        @inlinable
        public init(createTime: Date, id: String, membershipArn: String, membershipId: String, receiverConfigurations: [ReceiverConfiguration], status: ProtectedQueryStatus) {
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.receiverConfigurations = receiverConfigurations
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createTime = "createTime"
            case id = "id"
            case membershipArn = "membershipArn"
            case membershipId = "membershipId"
            case receiverConfigurations = "receiverConfigurations"
            case status = "status"
        }
    }

    public struct QueryComputePaymentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs (TRUE) or has not configured the collaboration member to pay for query compute costs (FALSE). Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a TRUE value for more than one member in the collaboration.  If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a FALSE value for the member who can query.
        public let isResponsible: Bool

        @inlinable
        public init(isResponsible: Bool) {
            self.isResponsible = isResponsible
        }

        private enum CodingKeys: String, CodingKey {
            case isResponsible = "isResponsible"
        }
    }

    public struct QueryConstraintRequireOverlap: AWSDecodableShape {
        /// The columns that are required to overlap.
        public let columns: [String]?

        @inlinable
        public init(columns: [String]? = nil) {
            self.columns = columns
        }

        private enum CodingKeys: String, CodingKey {
            case columns = "columns"
        }
    }

    public struct ReceiverConfiguration: AWSDecodableShape {
        ///  The type of analysis for the protected query. The results of the query can be analyzed directly (DIRECT_ANALYSIS) or used as input into additional analyses (ADDITIONAL_ANALYSIS), such as a query that is a seed for a lookalike ML model.
        public let analysisType: AnalysisType
        ///  The configuration details of the receiver configuration.
        public let configurationDetails: ConfigurationDetails?

        @inlinable
        public init(analysisType: AnalysisType, configurationDetails: ConfigurationDetails? = nil) {
            self.analysisType = analysisType
            self.configurationDetails = configurationDetails
        }

        private enum CodingKeys: String, CodingKey {
            case analysisType = "analysisType"
            case configurationDetails = "configurationDetails"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The Id of the missing resource.
        public let resourceId: String
        /// The type of the missing resource.
        public let resourceType: ResourceType

        @inlinable
        public init(message: String, resourceId: String, resourceType: ResourceType) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct S3Location: AWSEncodableShape & AWSDecodableShape {
        ///  The bucket name.
        public let bucket: String
        ///  The object key.
        public let key: String

        @inlinable
        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
        }
    }

    public struct Schema: AWSDecodableShape {
        /// The analysis method for the schema.   DIRECT_QUERY allows SQL queries to be run directly on this table.  DIRECT_JOB allows PySpark jobs to be run directly on this table.  MULTIPLE allows both SQL queries and PySpark jobs to be run directly on this table.
        public let analysisMethod: AnalysisMethod?
        /// The analysis rule types that are associated with the schema. Currently, only one entry is present.
        public let analysisRuleTypes: [AnalysisRuleType]
        /// The unique Amazon Resource Name (ARN) for the collaboration that the schema belongs to.
        public let collaborationArn: String
        /// The unique ID for the collaboration that the schema belongs to.
        public let collaborationId: String
        /// The columns for the relation that this schema represents.
        public let columns: [Column]
        /// The time at which the schema was created.
        public let createTime: Date
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        public let creatorAccountId: String
        /// A description for the schema.
        public let description: String
        /// A name for the schema. The schema relation is referred to by this name when queried by a protected query.
        public let name: String
        /// The partition keys for the dataset underlying this schema.
        public let partitionKeys: [Column]
        /// Details about the status of the schema. Currently, only one entry is present.
        public let schemaStatusDetails: [SchemaStatusDetail]
        /// The schema type properties.
        public let schemaTypeProperties: SchemaTypeProperties?
        ///  The selected analysis methods for the schema.
        public let selectedAnalysisMethods: [SelectedAnalysisMethod]?
        /// The type of schema.
        public let type: SchemaType
        /// The most recent time at which the schema was updated.
        public let updateTime: Date

        @inlinable
        public init(analysisMethod: AnalysisMethod? = nil, analysisRuleTypes: [AnalysisRuleType], collaborationArn: String, collaborationId: String, columns: [Column], createTime: Date, creatorAccountId: String, description: String, name: String, partitionKeys: [Column], schemaStatusDetails: [SchemaStatusDetail], schemaTypeProperties: SchemaTypeProperties? = nil, selectedAnalysisMethods: [SelectedAnalysisMethod]? = nil, type: SchemaType, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.columns = columns
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaStatusDetails = schemaStatusDetails
            self.schemaTypeProperties = schemaTypeProperties
            self.selectedAnalysisMethods = selectedAnalysisMethods
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case columns = "columns"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case description = "description"
            case name = "name"
            case partitionKeys = "partitionKeys"
            case schemaStatusDetails = "schemaStatusDetails"
            case schemaTypeProperties = "schemaTypeProperties"
            case selectedAnalysisMethods = "selectedAnalysisMethods"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct SchemaAnalysisRuleRequest: AWSEncodableShape {
        /// The name of the analysis rule schema that you are requesting.
        public let name: String
        /// The type of analysis rule schema that you are requesting.
        public let type: AnalysisRuleType

        @inlinable
        public init(name: String, type: AnalysisRuleType) {
            self.name = name
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_](([a-zA-Z0-9_ ]+-)*([a-zA-Z0-9_ ]+))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
        }
    }

    public struct SchemaStatusDetail: AWSDecodableShape {
        /// The analysis rule type for which the schema status has been evaluated.
        public let analysisRuleType: AnalysisRuleType?
        /// The type of analysis that can be performed on the schema. A schema can have an analysisType of DIRECT_ANALYSIS, ADDITIONAL_ANALYSIS_FOR_AUDIENCE_GENERATION, or both.
        public let analysisType: AnalysisType
        /// The configuration details of the schema analysis rule for the given type.
        public let configurations: [SchemaConfiguration]?
        /// The reasons why the schema status is set to its current state.
        public let reasons: [SchemaStatusReason]?
        /// The status of the schema, indicating if it is ready to query.
        public let status: SchemaStatus

        @inlinable
        public init(analysisRuleType: AnalysisRuleType? = nil, analysisType: AnalysisType, configurations: [SchemaConfiguration]? = nil, reasons: [SchemaStatusReason]? = nil, status: SchemaStatus) {
            self.analysisRuleType = analysisRuleType
            self.analysisType = analysisType
            self.configurations = configurations
            self.reasons = reasons
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRuleType = "analysisRuleType"
            case analysisType = "analysisType"
            case configurations = "configurations"
            case reasons = "reasons"
            case status = "status"
        }
    }

    public struct SchemaStatusReason: AWSDecodableShape {
        /// The schema status reason code.
        public let code: SchemaStatusReasonCode
        /// An explanation of the schema status reason code.
        public let message: String

        @inlinable
        public init(code: SchemaStatusReasonCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct SchemaSummary: AWSDecodableShape {
        /// The analysis method for the associated schema.  DIRECT_QUERY allows SQL queries to be run directly on this table.  DIRECT_JOB allows PySpark jobs to be run directly on this table.  MULTIPLE allows both SQL queries and PySpark jobs to be run directly on this table.
        public let analysisMethod: AnalysisMethod?
        /// The types of analysis rules that are associated with this schema object.
        public let analysisRuleTypes: [AnalysisRuleType]
        /// The unique ARN for the collaboration that the schema belongs to.
        public let collaborationArn: String
        /// The unique ID for the collaboration that the schema belongs to.
        public let collaborationId: String
        /// The time the schema object was created.
        public let createTime: Date
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        public let creatorAccountId: String
        /// The name for the schema object.
        public let name: String
        ///  The selected analysis methods for the schema.
        public let selectedAnalysisMethods: [SelectedAnalysisMethod]?
        /// The type of schema object.
        public let type: SchemaType
        /// The time the schema object was last updated.
        public let updateTime: Date

        @inlinable
        public init(analysisMethod: AnalysisMethod? = nil, analysisRuleTypes: [AnalysisRuleType], collaborationArn: String, collaborationId: String, createTime: Date, creatorAccountId: String, name: String, selectedAnalysisMethods: [SelectedAnalysisMethod]? = nil, type: SchemaType, updateTime: Date) {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.name = name
            self.selectedAnalysisMethods = selectedAnalysisMethods
            self.type = type
            self.updateTime = updateTime
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case analysisRuleTypes = "analysisRuleTypes"
            case collaborationArn = "collaborationArn"
            case collaborationId = "collaborationId"
            case createTime = "createTime"
            case creatorAccountId = "creatorAccountId"
            case name = "name"
            case selectedAnalysisMethods = "selectedAnalysisMethods"
            case type = "type"
            case updateTime = "updateTime"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The name of the quota.
        public let quotaName: String
        /// The value of the quota.
        public let quotaValue: Double

        @inlinable
        public init(message: String, quotaName: String, quotaValue: Double) {
            self.message = message
            self.quotaName = quotaName
            self.quotaValue = quotaValue
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaName = "quotaName"
            case quotaValue = "quotaValue"
        }
    }

    public struct SnowflakeTableReference: AWSEncodableShape & AWSDecodableShape {
        ///  The account identifier for the Snowflake table reference.
        public let accountIdentifier: String
        ///  The name of the database the Snowflake table belongs to.
        public let databaseName: String
        ///  The schema name of the Snowflake table reference.
        public let schemaName: String
        ///  The secret ARN of the Snowflake table reference.
        public let secretArn: String
        ///  The name of the Snowflake table.
        public let tableName: String
        ///  The schema of the Snowflake table.
        public let tableSchema: SnowflakeTableSchema

        @inlinable
        public init(accountIdentifier: String, databaseName: String, schemaName: String, secretArn: String, tableName: String, tableSchema: SnowflakeTableSchema) {
            self.accountIdentifier = accountIdentifier
            self.databaseName = databaseName
            self.schemaName = schemaName
            self.secretArn = secretArn
            self.tableName = tableName
            self.tableSchema = tableSchema
        }

        public func validate(name: String) throws {
            try self.validate(self.accountIdentifier, name: "accountIdentifier", parent: name, max: 256)
            try self.validate(self.accountIdentifier, name: "accountIdentifier", parent: name, min: 3)
            try self.validate(self.accountIdentifier, name: "accountIdentifier", parent: name, pattern: "^[\\p{L}\\p{M}\\p{N}\\p{Pc}\\p{Pd}\\p{Zs}.]+$")
            try self.validate(self.databaseName, name: "databaseName", parent: name, max: 256)
            try self.validate(self.databaseName, name: "databaseName", parent: name, min: 1)
            try self.validate(self.databaseName, name: "databaseName", parent: name, pattern: "^[\\p{L}\\p{M}\\p{N}\\p{Pc}\\p{Pd}\\p{Zs}]+$")
            try self.validate(self.schemaName, name: "schemaName", parent: name, max: 256)
            try self.validate(self.schemaName, name: "schemaName", parent: name, min: 1)
            try self.validate(self.schemaName, name: "schemaName", parent: name, pattern: "^[\\p{L}\\p{M}\\p{N}\\p{Pc}\\p{Pd}\\p{Zs}]+$")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 256)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:aws:secretsmanager:[a-z]{2}-[a-z]+-[0-9]:\\d{12}:secret:.*$")
            try self.validate(self.tableName, name: "tableName", parent: name, max: 256)
            try self.validate(self.tableName, name: "tableName", parent: name, min: 1)
            try self.validate(self.tableName, name: "tableName", parent: name, pattern: "^[\\p{L}\\p{M}\\p{N}\\p{Pc}\\p{Pd}\\p{Zs}]+$")
            try self.tableSchema.validate(name: "\(name).tableSchema")
        }

        private enum CodingKeys: String, CodingKey {
            case accountIdentifier = "accountIdentifier"
            case databaseName = "databaseName"
            case schemaName = "schemaName"
            case secretArn = "secretArn"
            case tableName = "tableName"
            case tableSchema = "tableSchema"
        }
    }

    public struct SnowflakeTableSchemaV1: AWSEncodableShape & AWSDecodableShape {
        ///  The column name.
        public let columnName: String
        ///  The column's data type. Supported data types: ARRAY, BIGINT, BOOLEAN, CHAR, DATE, DECIMAL, DOUBLE, DOUBLE PRECISION, FLOAT, FLOAT4, INT, INTEGER, MAP, NUMERIC, NUMBER, REAL, SMALLINT, STRING, TIMESTAMP, TIMESTAMP_LTZ, TIMESTAMP_NTZ, DATETIME, TINYINT, VARCHAR, TEXT, CHARACTER.
        public let columnType: String

        @inlinable
        public init(columnName: String, columnType: String) {
            self.columnName = columnName
            self.columnType = columnType
        }

        public func validate(name: String) throws {
            try self.validate(self.columnName, name: "columnName", parent: name, max: 128)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "^[a-z0-9_](([a-z0-9_ ]+-)*([a-z0-9_ ]+))?$")
            try self.validate(self.columnType, name: "columnType", parent: name, max: 255)
            try self.validate(self.columnType, name: "columnType", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case columnName = "columnName"
            case columnType = "columnType"
        }
    }

    public struct StartProtectedJobInput: AWSEncodableShape {
        ///  The job parameters.
        public let jobParameters: ProtectedJobParameters
        /// A unique identifier for the membership to run this job against.  Currently accepts a membership ID.
        public let membershipIdentifier: String
        /// The details needed to write the job results.
        public let resultConfiguration: ProtectedJobResultConfigurationInput?
        ///  The type of protected job to start.
        public let type: ProtectedJobType

        @inlinable
        public init(jobParameters: ProtectedJobParameters, membershipIdentifier: String, resultConfiguration: ProtectedJobResultConfigurationInput? = nil, type: ProtectedJobType) {
            self.jobParameters = jobParameters
            self.membershipIdentifier = membershipIdentifier
            self.resultConfiguration = resultConfiguration
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.jobParameters, forKey: .jobParameters)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.resultConfiguration, forKey: .resultConfiguration)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.jobParameters.validate(name: "\(name).jobParameters")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.resultConfiguration?.validate(name: "\(name).resultConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case jobParameters = "jobParameters"
            case resultConfiguration = "resultConfiguration"
            case type = "type"
        }
    }

    public struct StartProtectedJobOutput: AWSDecodableShape {
        ///  The protected job.
        public let protectedJob: ProtectedJob

        @inlinable
        public init(protectedJob: ProtectedJob) {
            self.protectedJob = protectedJob
        }

        private enum CodingKeys: String, CodingKey {
            case protectedJob = "protectedJob"
        }
    }

    public struct StartProtectedQueryInput: AWSEncodableShape {
        ///  The compute configuration for the protected query.
        public let computeConfiguration: ComputeConfiguration?
        /// A unique identifier for the membership to run this query against. Currently accepts a membership ID.
        public let membershipIdentifier: String
        /// The details needed to write the query results.
        public let resultConfiguration: ProtectedQueryResultConfiguration?
        /// The protected SQL query parameters.
        public let sqlParameters: ProtectedQuerySQLParameters
        /// The type of the protected query to be started.
        public let type: ProtectedQueryType

        @inlinable
        public init(computeConfiguration: ComputeConfiguration? = nil, membershipIdentifier: String, resultConfiguration: ProtectedQueryResultConfiguration? = nil, sqlParameters: ProtectedQuerySQLParameters, type: ProtectedQueryType) {
            self.computeConfiguration = computeConfiguration
            self.membershipIdentifier = membershipIdentifier
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.computeConfiguration, forKey: .computeConfiguration)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.resultConfiguration, forKey: .resultConfiguration)
            try container.encode(self.sqlParameters, forKey: .sqlParameters)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.resultConfiguration?.validate(name: "\(name).resultConfiguration")
            try self.sqlParameters.validate(name: "\(name).sqlParameters")
        }

        private enum CodingKeys: String, CodingKey {
            case computeConfiguration = "computeConfiguration"
            case resultConfiguration = "resultConfiguration"
            case sqlParameters = "sqlParameters"
            case type = "type"
        }
    }

    public struct StartProtectedQueryOutput: AWSDecodableShape {
        /// The protected query.
        public let protectedQuery: ProtectedQuery

        @inlinable
        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct TagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to tag.
        public let resourceArn: String
        /// A map of objects specifying each key name and value.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceInput: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
        public let resourceArn: String
        /// A list of key names of tags to be removed.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 100)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:cleanrooms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:[\\d\\w/-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceOutput: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAnalysisTemplateInput: AWSEncodableShape {
        /// The identifier for the analysis template resource.
        public let analysisTemplateIdentifier: String
        /// A new description for the analysis template.
        public let description: String?
        /// The identifier for a membership resource.
        public let membershipIdentifier: String

        @inlinable
        public init(analysisTemplateIdentifier: String, description: String? = nil, membershipIdentifier: String) {
            self.analysisTemplateIdentifier = analysisTemplateIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.analysisTemplateIdentifier, key: "analysisTemplateIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.analysisTemplateIdentifier, name: "analysisTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
        }
    }

    public struct UpdateAnalysisTemplateOutput: AWSDecodableShape {
        /// The analysis template.
        public let analysisTemplate: AnalysisTemplate

        @inlinable
        public init(analysisTemplate: AnalysisTemplate) {
            self.analysisTemplate = analysisTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case analysisTemplate = "analysisTemplate"
        }
    }

    public struct UpdateCollaborationInput: AWSEncodableShape {
        /// The analytics engine.
        public let analyticsEngine: AnalyticsEngine?
        /// The identifier for the collaboration.
        public let collaborationIdentifier: String
        /// A description of the collaboration.
        public let description: String?
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        public let name: String?

        @inlinable
        public init(analyticsEngine: AnalyticsEngine? = nil, collaborationIdentifier: String, description: String? = nil, name: String? = nil) {
            self.analyticsEngine = analyticsEngine
            self.collaborationIdentifier = collaborationIdentifier
            self.description = description
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.analyticsEngine, forKey: .analyticsEngine)
            request.encodePath(self.collaborationIdentifier, key: "collaborationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, max: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, min: 36)
            try self.validate(self.collaborationIdentifier, name: "collaborationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analyticsEngine = "analyticsEngine"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateCollaborationOutput: AWSDecodableShape {
        /// The entire collaboration that has been updated.
        public let collaboration: Collaboration

        @inlinable
        public init(collaboration: Collaboration) {
            self.collaboration = collaboration
        }

        private enum CodingKeys: String, CodingKey {
            case collaboration = "collaboration"
        }
    }

    public struct UpdateConfiguredAudienceModelAssociationInput: AWSEncodableShape {
        /// A unique identifier for the configured audience model association that you want to update.
        public let configuredAudienceModelAssociationIdentifier: String
        /// A new description for the configured audience model association.
        public let description: String?
        /// A unique identifier of the membership that contains the configured audience model association that you want to update.
        public let membershipIdentifier: String
        /// A new name for the configured audience model association.
        public let name: String?

        @inlinable
        public init(configuredAudienceModelAssociationIdentifier: String, description: String? = nil, membershipIdentifier: String, name: String? = nil) {
            self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredAudienceModelAssociationIdentifier, key: "configuredAudienceModelAssociationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredAudienceModelAssociationIdentifier, name: "configuredAudienceModelAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateConfiguredAudienceModelAssociationOutput: AWSDecodableShape {
        /// Details about the configured audience model association that you updated.
        public let configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation

        @inlinable
        public init(configuredAudienceModelAssociation: ConfiguredAudienceModelAssociation) {
            self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredAudienceModelAssociation = "configuredAudienceModelAssociation"
        }
    }

    public struct UpdateConfiguredTableAnalysisRuleInput: AWSEncodableShape {
        /// The new analysis rule policy for the configured table analysis rule.
        public let analysisRulePolicy: ConfiguredTableAnalysisRulePolicy
        /// The analysis rule type to be updated. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
        public let analysisRuleType: ConfiguredTableAnalysisRuleType
        /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String

        @inlinable
        public init(analysisRulePolicy: ConfiguredTableAnalysisRulePolicy, analysisRuleType: ConfiguredTableAnalysisRuleType, configuredTableIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableIdentifier = configuredTableIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
        }
    }

    public struct UpdateConfiguredTableAnalysisRuleOutput: AWSDecodableShape {
        /// The entire updated analysis rule.
        public let analysisRule: ConfiguredTableAnalysisRule

        @inlinable
        public init(analysisRule: ConfiguredTableAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct UpdateConfiguredTableAssociationAnalysisRuleInput: AWSEncodableShape {
        ///  The updated analysis rule policy for the congured table association.
        public let analysisRulePolicy: ConfiguredTableAssociationAnalysisRulePolicy
        ///  The analysis rule type that you want to update.
        public let analysisRuleType: ConfiguredTableAssociationAnalysisRuleType
        ///  The identifier for the configured table association to update.
        public let configuredTableAssociationIdentifier: String
        ///  A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
        public let membershipIdentifier: String

        @inlinable
        public init(analysisRulePolicy: ConfiguredTableAssociationAnalysisRulePolicy, analysisRuleType: ConfiguredTableAssociationAnalysisRuleType, configuredTableAssociationIdentifier: String, membershipIdentifier: String) {
            self.analysisRulePolicy = analysisRulePolicy
            self.analysisRuleType = analysisRuleType
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.analysisRulePolicy, forKey: .analysisRulePolicy)
            request.encodePath(self.analysisRuleType, key: "analysisRuleType")
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.analysisRulePolicy.validate(name: "\(name).analysisRulePolicy")
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRulePolicy = "analysisRulePolicy"
        }
    }

    public struct UpdateConfiguredTableAssociationAnalysisRuleOutput: AWSDecodableShape {
        ///  The updated analysis rule for the congured table association. In the console, the ConfiguredTableAssociationAnalysisRule is referred to as the collaboration analysis rule.
        public let analysisRule: ConfiguredTableAssociationAnalysisRule

        @inlinable
        public init(analysisRule: ConfiguredTableAssociationAnalysisRule) {
            self.analysisRule = analysisRule
        }

        private enum CodingKeys: String, CodingKey {
            case analysisRule = "analysisRule"
        }
    }

    public struct UpdateConfiguredTableAssociationInput: AWSEncodableShape {
        /// The unique identifier for the configured table association to update. Currently accepts the configured table association ID.
        public let configuredTableAssociationIdentifier: String
        /// A new description for the configured table association.
        public let description: String?
        /// The unique ID for the membership that the configured table association belongs to.
        public let membershipIdentifier: String
        /// The service will assume this role to access catalog metadata and query the table.
        public let roleArn: String?

        @inlinable
        public init(configuredTableAssociationIdentifier: String, description: String? = nil, membershipIdentifier: String, roleArn: String? = nil) {
            self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
            self.description = description
            self.membershipIdentifier = membershipIdentifier
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.configuredTableAssociationIdentifier, key: "configuredTableAssociationIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableAssociationIdentifier, name: "configuredTableAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 512)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 32)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:aws:iam::[\\w]+:role/[\\w+=./@-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateConfiguredTableAssociationOutput: AWSDecodableShape {
        /// The entire updated configured table association.
        public let configuredTableAssociation: ConfiguredTableAssociation

        @inlinable
        public init(configuredTableAssociation: ConfiguredTableAssociation) {
            self.configuredTableAssociation = configuredTableAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTableAssociation = "configuredTableAssociation"
        }
    }

    public struct UpdateConfiguredTableInput: AWSEncodableShape {
        ///  The analysis method for the configured table.  DIRECT_QUERY allows SQL queries to be run directly on this table.  DIRECT_JOB allows PySpark jobs to be run directly on this table.  MULTIPLE allows both SQL queries and PySpark jobs to be run directly on this table.
        public let analysisMethod: AnalysisMethod?
        /// The identifier for the configured table to update. Currently accepts the configured table ID.
        public let configuredTableIdentifier: String
        /// A new description for the configured table.
        public let description: String?
        /// A new name for the configured table.
        public let name: String?
        ///  The selected analysis methods for the table configuration update.
        public let selectedAnalysisMethods: [SelectedAnalysisMethod]?

        @inlinable
        public init(analysisMethod: AnalysisMethod? = nil, configuredTableIdentifier: String, description: String? = nil, name: String? = nil, selectedAnalysisMethods: [SelectedAnalysisMethod]? = nil) {
            self.analysisMethod = analysisMethod
            self.configuredTableIdentifier = configuredTableIdentifier
            self.description = description
            self.name = name
            self.selectedAnalysisMethods = selectedAnalysisMethods
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.analysisMethod, forKey: .analysisMethod)
            request.encodePath(self.configuredTableIdentifier, key: "configuredTableIdentifier")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.selectedAnalysisMethods, forKey: .selectedAnalysisMethods)
        }

        public func validate(name: String) throws {
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, max: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, min: 36)
            try self.validate(self.configuredTableIdentifier, name: "configuredTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case analysisMethod = "analysisMethod"
            case description = "description"
            case name = "name"
            case selectedAnalysisMethods = "selectedAnalysisMethods"
        }
    }

    public struct UpdateConfiguredTableOutput: AWSDecodableShape {
        /// The updated configured table.
        public let configuredTable: ConfiguredTable

        @inlinable
        public init(configuredTable: ConfiguredTable) {
            self.configuredTable = configuredTable
        }

        private enum CodingKeys: String, CodingKey {
            case configuredTable = "configuredTable"
        }
    }

    public struct UpdateIdMappingTableInput: AWSEncodableShape {
        /// A new description for the ID mapping table.
        public let description: String?
        /// The unique identifier of the ID mapping table that you want to update.
        public let idMappingTableIdentifier: String
        /// The Amazon Resource Name (ARN) of the Amazon Web Services KMS key.
        public let kmsKeyArn: String?
        /// The unique identifier of the membership that contains the ID mapping table that you want to update.
        public let membershipIdentifier: String

        @inlinable
        public init(description: String? = nil, idMappingTableIdentifier: String, kmsKeyArn: String? = nil, membershipIdentifier: String) {
            self.description = description
            self.idMappingTableIdentifier = idMappingTableIdentifier
            self.kmsKeyArn = kmsKeyArn
            self.membershipIdentifier = membershipIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.idMappingTableIdentifier, key: "idMappingTableIdentifier")
            try container.encodeIfPresent(self.kmsKeyArn, forKey: .kmsKeyArn)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, max: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, min: 36)
            try self.validate(self.idMappingTableIdentifier, name: "idMappingTableIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 2048)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, min: 20)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:[\\w]{2}-[\\w]{4,9}-[\\d]:[\\d]{12}:key/[a-zA-Z0-9-]+$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case kmsKeyArn = "kmsKeyArn"
        }
    }

    public struct UpdateIdMappingTableOutput: AWSDecodableShape {
        /// The updated ID mapping table.
        public let idMappingTable: IdMappingTable

        @inlinable
        public init(idMappingTable: IdMappingTable) {
            self.idMappingTable = idMappingTable
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingTable = "idMappingTable"
        }
    }

    public struct UpdateIdNamespaceAssociationInput: AWSEncodableShape {
        /// A new description for the ID namespace association.
        public let description: String?
        /// The configuration settings for the ID mapping table.
        public let idMappingConfig: IdMappingConfig?
        /// The unique identifier of the ID namespace association that you want to update.
        public let idNamespaceAssociationIdentifier: String
        /// The unique identifier of the membership that contains the ID namespace association that you want to update.
        public let membershipIdentifier: String
        /// A new name for the ID namespace association.
        public let name: String?

        @inlinable
        public init(description: String? = nil, idMappingConfig: IdMappingConfig? = nil, idNamespaceAssociationIdentifier: String, membershipIdentifier: String, name: String? = nil) {
            self.description = description
            self.idMappingConfig = idMappingConfig
            self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
            self.membershipIdentifier = membershipIdentifier
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.idMappingConfig, forKey: .idMappingConfig)
            request.encodePath(self.idNamespaceAssociationIdentifier, key: "idNamespaceAssociationIdentifier")
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t\\r\\n]*$")
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, max: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, min: 36)
            try self.validate(self.idNamespaceAssociationIdentifier, name: "idNamespaceAssociationIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!\\s*$)[\\u0020-\\uD7FF\\uE000-\\uFFFD\\uD800\\uDBFF-\\uDC00\\uDFFF\\t]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case idMappingConfig = "idMappingConfig"
            case name = "name"
        }
    }

    public struct UpdateIdNamespaceAssociationOutput: AWSDecodableShape {
        /// The updated ID namespace association.
        public let idNamespaceAssociation: IdNamespaceAssociation

        @inlinable
        public init(idNamespaceAssociation: IdNamespaceAssociation) {
            self.idNamespaceAssociation = idNamespaceAssociation
        }

        private enum CodingKeys: String, CodingKey {
            case idNamespaceAssociation = "idNamespaceAssociation"
        }
    }

    public struct UpdateMembershipInput: AWSEncodableShape {
        ///  The default job result configuration.
        public let defaultJobResultConfiguration: MembershipProtectedJobResultConfiguration?
        /// The default protected query result configuration as specified by the member who can receive results.
        public let defaultResultConfiguration: MembershipProtectedQueryResultConfiguration?
        /// An indicator as to whether job logging has been enabled or disabled  for the collaboration.  When ENABLED, Clean Rooms logs details about jobs run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let jobLogStatus: MembershipJobLogStatus?
        /// The unique identifier of the membership.
        public let membershipIdentifier: String
        /// An indicator as to whether query logging has been enabled or disabled for the membership. When ENABLED, Clean Rooms logs details about queries run within this collaboration and those logs can be viewed in Amazon CloudWatch Logs. The default value is DISABLED.
        public let queryLogStatus: MembershipQueryLogStatus?

        @inlinable
        public init(defaultJobResultConfiguration: MembershipProtectedJobResultConfiguration? = nil, defaultResultConfiguration: MembershipProtectedQueryResultConfiguration? = nil, jobLogStatus: MembershipJobLogStatus? = nil, membershipIdentifier: String, queryLogStatus: MembershipQueryLogStatus? = nil) {
            self.defaultJobResultConfiguration = defaultJobResultConfiguration
            self.defaultResultConfiguration = defaultResultConfiguration
            self.jobLogStatus = jobLogStatus
            self.membershipIdentifier = membershipIdentifier
            self.queryLogStatus = queryLogStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.defaultJobResultConfiguration, forKey: .defaultJobResultConfiguration)
            try container.encodeIfPresent(self.defaultResultConfiguration, forKey: .defaultResultConfiguration)
            try container.encodeIfPresent(self.jobLogStatus, forKey: .jobLogStatus)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.queryLogStatus, forKey: .queryLogStatus)
        }

        public func validate(name: String) throws {
            try self.defaultJobResultConfiguration?.validate(name: "\(name).defaultJobResultConfiguration")
            try self.defaultResultConfiguration?.validate(name: "\(name).defaultResultConfiguration")
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultJobResultConfiguration = "defaultJobResultConfiguration"
            case defaultResultConfiguration = "defaultResultConfiguration"
            case jobLogStatus = "jobLogStatus"
            case queryLogStatus = "queryLogStatus"
        }
    }

    public struct UpdateMembershipOutput: AWSDecodableShape {
        public let membership: Membership

        @inlinable
        public init(membership: Membership) {
            self.membership = membership
        }

        private enum CodingKeys: String, CodingKey {
            case membership = "membership"
        }
    }

    public struct UpdatePrivacyBudgetTemplateInput: AWSEncodableShape {
        /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is updated in the collaboration that this membership belongs to. Accepts a membership ID.
        public let membershipIdentifier: String
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        public let parameters: PrivacyBudgetTemplateUpdateParameters?
        /// A unique identifier for your privacy budget template that you want to update.
        public let privacyBudgetTemplateIdentifier: String
        /// Specifies the type of the privacy budget template.
        public let privacyBudgetType: PrivacyBudgetType

        @inlinable
        public init(membershipIdentifier: String, parameters: PrivacyBudgetTemplateUpdateParameters? = nil, privacyBudgetTemplateIdentifier: String, privacyBudgetType: PrivacyBudgetType) {
            self.membershipIdentifier = membershipIdentifier
            self.parameters = parameters
            self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
            self.privacyBudgetType = privacyBudgetType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            try container.encodeIfPresent(self.parameters, forKey: .parameters)
            request.encodePath(self.privacyBudgetTemplateIdentifier, key: "privacyBudgetTemplateIdentifier")
            try container.encode(self.privacyBudgetType, forKey: .privacyBudgetType)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.parameters?.validate(name: "\(name).parameters")
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, max: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, min: 36)
            try self.validate(self.privacyBudgetTemplateIdentifier, name: "privacyBudgetTemplateIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case parameters = "parameters"
            case privacyBudgetType = "privacyBudgetType"
        }
    }

    public struct UpdatePrivacyBudgetTemplateOutput: AWSDecodableShape {
        /// Summary of the privacy budget template.
        public let privacyBudgetTemplate: PrivacyBudgetTemplate

        @inlinable
        public init(privacyBudgetTemplate: PrivacyBudgetTemplate) {
            self.privacyBudgetTemplate = privacyBudgetTemplate
        }

        private enum CodingKeys: String, CodingKey {
            case privacyBudgetTemplate = "privacyBudgetTemplate"
        }
    }

    public struct UpdateProtectedJobInput: AWSEncodableShape {
        /// The identifier for a member of a protected job instance.
        public let membershipIdentifier: String
        ///  The identifier of the protected job to update.
        public let protectedJobIdentifier: String
        /// The target status of a protected job. Used to update the execution status  of a currently running job.
        public let targetStatus: TargetProtectedJobStatus

        @inlinable
        public init(membershipIdentifier: String, protectedJobIdentifier: String, targetStatus: TargetProtectedJobStatus) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedJobIdentifier = protectedJobIdentifier
            self.targetStatus = targetStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedJobIdentifier, key: "protectedJobIdentifier")
            try container.encode(self.targetStatus, forKey: .targetStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.protectedJobIdentifier, name: "protectedJobIdentifier", parent: name, max: 36)
            try self.validate(self.protectedJobIdentifier, name: "protectedJobIdentifier", parent: name, min: 36)
            try self.validate(self.protectedJobIdentifier, name: "protectedJobIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetStatus = "targetStatus"
        }
    }

    public struct UpdateProtectedJobOutput: AWSDecodableShape {
        /// The protected job output.
        public let protectedJob: ProtectedJob

        @inlinable
        public init(protectedJob: ProtectedJob) {
            self.protectedJob = protectedJob
        }

        private enum CodingKeys: String, CodingKey {
            case protectedJob = "protectedJob"
        }
    }

    public struct UpdateProtectedQueryInput: AWSEncodableShape {
        /// The identifier for a member of a protected query instance.
        public let membershipIdentifier: String
        /// The identifier for a protected query instance.
        public let protectedQueryIdentifier: String
        /// The target status of a query. Used to update the execution status of a currently running query.
        public let targetStatus: TargetProtectedQueryStatus

        @inlinable
        public init(membershipIdentifier: String, protectedQueryIdentifier: String, targetStatus: TargetProtectedQueryStatus) {
            self.membershipIdentifier = membershipIdentifier
            self.protectedQueryIdentifier = protectedQueryIdentifier
            self.targetStatus = targetStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.membershipIdentifier, key: "membershipIdentifier")
            request.encodePath(self.protectedQueryIdentifier, key: "protectedQueryIdentifier")
            try container.encode(self.targetStatus, forKey: .targetStatus)
        }

        public func validate(name: String) throws {
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, max: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, min: 36)
            try self.validate(self.membershipIdentifier, name: "membershipIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, max: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, min: 36)
            try self.validate(self.protectedQueryIdentifier, name: "protectedQueryIdentifier", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case targetStatus = "targetStatus"
        }
    }

    public struct UpdateProtectedQueryOutput: AWSDecodableShape {
        /// The protected query output.
        public let protectedQuery: ProtectedQuery

        @inlinable
        public init(protectedQuery: ProtectedQuery) {
            self.protectedQuery = protectedQuery
        }

        private enum CodingKeys: String, CodingKey {
            case protectedQuery = "protectedQuery"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// Validation errors for specific input parameters.
        public let fieldList: [ValidationExceptionField]?
        public let message: String?
        /// A reason code for the exception.
        public let reason: ValidationExceptionReason?

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String? = nil, reason: ValidationExceptionReason? = nil) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// A message for the input validation error.
        public let message: String
        /// The name of the input parameter.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct WorkerComputeConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The number of workers.
        public let number: Int?
        ///  The worker compute configuration type.
        public let type: WorkerComputeType?

        @inlinable
        public init(number: Int? = nil, type: WorkerComputeType? = nil) {
            self.number = number
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case number = "number"
            case type = "type"
        }
    }

    public struct AnalysisRulePolicy: AWSDecodableShape {
        /// Controls on the query specifications that can be run on configured table.
        public let v1: AnalysisRulePolicyV1?

        @inlinable
        public init(v1: AnalysisRulePolicyV1? = nil) {
            self.v1 = v1
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct AnalysisSourceMetadata: AWSDecodableShape {
        ///  The artifacts of the analysis source metadata.
        public let artifacts: AnalysisTemplateArtifactMetadata?

        @inlinable
        public init(artifacts: AnalysisTemplateArtifactMetadata? = nil) {
            self.artifacts = artifacts
        }

        private enum CodingKeys: String, CodingKey {
            case artifacts = "artifacts"
        }
    }

    public struct ComputeConfiguration: AWSEncodableShape & AWSDecodableShape {
        ///  The worker configuration for the compute environment.
        public let worker: WorkerComputeConfiguration?

        @inlinable
        public init(worker: WorkerComputeConfiguration? = nil) {
            self.worker = worker
        }

        private enum CodingKeys: String, CodingKey {
            case worker = "worker"
        }
    }

    public struct ConfigurationDetails: AWSDecodableShape {
        ///  The direct analysis configuration details.
        public let directAnalysisConfigurationDetails: DirectAnalysisConfigurationDetails?

        @inlinable
        public init(directAnalysisConfigurationDetails: DirectAnalysisConfigurationDetails? = nil) {
            self.directAnalysisConfigurationDetails = directAnalysisConfigurationDetails
        }

        private enum CodingKeys: String, CodingKey {
            case directAnalysisConfigurationDetails = "directAnalysisConfigurationDetails"
        }
    }

    public struct ConfiguredTableAnalysisRulePolicy: AWSEncodableShape & AWSDecodableShape {
        /// Controls on the query specifications that can be run on a configured table.
        public let v1: ConfiguredTableAnalysisRulePolicyV1?

        @inlinable
        public init(v1: ConfiguredTableAnalysisRulePolicyV1? = nil) {
            self.v1 = v1
        }

        public func validate(name: String) throws {
            try self.v1?.validate(name: "\(name).v1")
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct ConfiguredTableAssociationAnalysisRulePolicy: AWSEncodableShape & AWSDecodableShape {
        ///  The policy for the configured table association analysis rule.
        public let v1: ConfiguredTableAssociationAnalysisRulePolicyV1?

        @inlinable
        public init(v1: ConfiguredTableAssociationAnalysisRulePolicyV1? = nil) {
            self.v1 = v1
        }

        public func validate(name: String) throws {
            try self.v1?.validate(name: "\(name).v1")
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct ConsolidatedPolicy: AWSDecodableShape {
        ///  The consolidated policy version 1.
        public let v1: ConsolidatedPolicyV1?

        @inlinable
        public init(v1: ConsolidatedPolicyV1? = nil) {
            self.v1 = v1
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }

    public struct MembershipProtectedJobOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains the configuration to write the job results to S3.
        public let s3: ProtectedJobS3OutputConfigurationInput?

        @inlinable
        public init(s3: ProtectedJobS3OutputConfigurationInput? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct MembershipProtectedQueryOutputConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let s3: ProtectedQueryS3OutputConfiguration?

        @inlinable
        public init(s3: ProtectedQueryS3OutputConfiguration? = nil) {
            self.s3 = s3
        }

        public func validate(name: String) throws {
            try self.s3?.validate(name: "\(name).s3")
        }

        private enum CodingKeys: String, CodingKey {
            case s3 = "s3"
        }
    }

    public struct PreviewPrivacyImpactParametersInput: AWSEncodableShape {
        /// An array that specifies the epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyPreviewParametersInput?

        @inlinable
        public init(differentialPrivacy: DifferentialPrivacyPreviewParametersInput? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        public func validate(name: String) throws {
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudget: AWSDecodableShape {
        /// An object that specifies the epsilon parameter and the utility in terms of total aggregations, as well as the remaining aggregations available.
        public let differentialPrivacy: DifferentialPrivacyPrivacyBudget?

        @inlinable
        public init(differentialPrivacy: DifferentialPrivacyPrivacyBudget? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudgetTemplateParametersInput: AWSEncodableShape {
        /// An object that specifies the epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyTemplateParametersInput?

        @inlinable
        public init(differentialPrivacy: DifferentialPrivacyTemplateParametersInput? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        public func validate(name: String) throws {
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudgetTemplateParametersOutput: AWSDecodableShape {
        /// The epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyTemplateParametersOutput?

        @inlinable
        public init(differentialPrivacy: DifferentialPrivacyTemplateParametersOutput? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyBudgetTemplateUpdateParameters: AWSEncodableShape {
        /// An object that specifies the new values for the epsilon and noise parameters.
        public let differentialPrivacy: DifferentialPrivacyTemplateUpdateParameters?

        @inlinable
        public init(differentialPrivacy: DifferentialPrivacyTemplateUpdateParameters? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        public func validate(name: String) throws {
            try self.differentialPrivacy?.validate(name: "\(name).differentialPrivacy")
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct PrivacyImpact: AWSDecodableShape {
        /// An object that lists the number and type of aggregation functions you can perform.
        public let differentialPrivacy: DifferentialPrivacyPrivacyImpact?

        @inlinable
        public init(differentialPrivacy: DifferentialPrivacyPrivacyImpact? = nil) {
            self.differentialPrivacy = differentialPrivacy
        }

        private enum CodingKeys: String, CodingKey {
            case differentialPrivacy = "differentialPrivacy"
        }
    }

    public struct ProtectedJobConfigurationDetails: AWSDecodableShape {
        /// The details needed to configure the direct analysis.
        public let directAnalysisConfigurationDetails: ProtectedJobDirectAnalysisConfigurationDetails?

        @inlinable
        public init(directAnalysisConfigurationDetails: ProtectedJobDirectAnalysisConfigurationDetails? = nil) {
            self.directAnalysisConfigurationDetails = directAnalysisConfigurationDetails
        }

        private enum CodingKeys: String, CodingKey {
            case directAnalysisConfigurationDetails = "directAnalysisConfigurationDetails"
        }
    }

    public struct ProtectedJobOutputConfigurationInput: AWSEncodableShape {
        ///  The member of the protected job output configuration input.
        public let member: ProtectedJobMemberOutputConfigurationInput?

        @inlinable
        public init(member: ProtectedJobMemberOutputConfigurationInput? = nil) {
            self.member = member
        }

        public func validate(name: String) throws {
            try self.member?.validate(name: "\(name).member")
        }

        private enum CodingKeys: String, CodingKey {
            case member = "member"
        }
    }

    public struct QueryConstraint: AWSDecodableShape {
        /// An array of column names that specifies which columns are required in the JOIN statement.
        public let requireOverlap: QueryConstraintRequireOverlap?

        @inlinable
        public init(requireOverlap: QueryConstraintRequireOverlap? = nil) {
            self.requireOverlap = requireOverlap
        }

        private enum CodingKeys: String, CodingKey {
            case requireOverlap = "requireOverlap"
        }
    }

    public struct SchemaTypeProperties: AWSDecodableShape {
        /// The ID mapping table for the schema type properties.
        public let idMappingTable: IdMappingTableSchemaTypeProperties?

        @inlinable
        public init(idMappingTable: IdMappingTableSchemaTypeProperties? = nil) {
            self.idMappingTable = idMappingTable
        }

        private enum CodingKeys: String, CodingKey {
            case idMappingTable = "idMappingTable"
        }
    }

    public struct SnowflakeTableSchema: AWSEncodableShape & AWSDecodableShape {
        ///  The schema of a Snowflake table.
        public let v1: [SnowflakeTableSchemaV1]?

        @inlinable
        public init(v1: [SnowflakeTableSchemaV1]? = nil) {
            self.v1 = v1
        }

        public func validate(name: String) throws {
            try self.v1?.forEach {
                try $0.validate(name: "\(name).v1[]")
            }
            try self.validate(self.v1, name: "v1", parent: name, max: 250)
            try self.validate(self.v1, name: "v1", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case v1 = "v1"
        }
    }
}

// MARK: - Errors

/// Error enum for CleanRooms
public struct CleanRoomsErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize CleanRooms
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// Caller does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// Unexpected error during processing of request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// Request references a resource which does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// Request denied because service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// Request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the specified constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension CleanRoomsErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": CleanRooms.AccessDeniedException.self,
        "ConflictException": CleanRooms.ConflictException.self,
        "ResourceNotFoundException": CleanRooms.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": CleanRooms.ServiceQuotaExceededException.self,
        "ValidationException": CleanRooms.ValidationException.self
    ]
}

extension CleanRoomsErrorType: Equatable {
    public static func == (lhs: CleanRoomsErrorType, rhs: CleanRoomsErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension CleanRoomsErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
