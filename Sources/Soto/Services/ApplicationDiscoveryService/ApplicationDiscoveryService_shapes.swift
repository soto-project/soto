//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension ApplicationDiscoveryService {
    // MARK: Enums

    public enum AgentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case blacklisted = "BLACKLISTED"
        case healthy = "HEALTHY"
        case running = "RUNNING"
        case shutdown = "SHUTDOWN"
        case unhealthy = "UNHEALTHY"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum BatchDeleteConfigurationTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case initializing = "INITIALIZING"
        case validating = "VALIDATING"
        public var description: String { return self.rawValue }
    }

    public enum BatchDeleteImportDataErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case notFound = "NOT_FOUND"
        case overLimit = "OVER_LIMIT"
        public var description: String { return self.rawValue }
    }

    public enum ConfigurationItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case application = "APPLICATION"
        case connections = "CONNECTION"
        case process = "PROCESS"
        case server = "SERVER"
        public var description: String { return self.rawValue }
    }

    public enum ContinuousExportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case error = "ERROR"
        case inactive = "INACTIVE"
        case startFailed = "START_FAILED"
        case startInProgress = "START_IN_PROGRESS"
        case stopFailed = "STOP_FAILED"
        case stopInProgress = "STOP_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum DataSource: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        public var description: String { return self.rawValue }
    }

    public enum DeleteAgentErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentInUse = "AGENT_IN_USE"
        case internalServerError = "INTERNAL_SERVER_ERROR"
        case notFound = "NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum DeletionConfigurationItemType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case server = "SERVER"
        public var description: String { return self.rawValue }
    }

    public enum ExportDataFormat: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        public var description: String { return self.rawValue }
    }

    public enum ExportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ImportStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleteComplete = "DELETE_COMPLETE"
        case deleteFailed = "DELETE_FAILED"
        case deleteFailedLimitExceeded = "DELETE_FAILED_LIMIT_EXCEEDED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case importComplete = "IMPORT_COMPLETE"
        case importCompleteWithErrors = "IMPORT_COMPLETE_WITH_ERRORS"
        case importFailed = "IMPORT_FAILED"
        case importFailedRecordLimitExceeded = "IMPORT_FAILED_RECORD_LIMIT_EXCEEDED"
        case importFailedServerLimitExceeded = "IMPORT_FAILED_SERVER_LIMIT_EXCEEDED"
        case importInProgress = "IMPORT_IN_PROGRESS"
        case internalError = "INTERNAL_ERROR"
        public var description: String { return self.rawValue }
    }

    public enum ImportTaskFilterName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case importTaskId = "IMPORT_TASK_ID"
        case name = "NAME"
        case status = "STATUS"
        public var description: String { return self.rawValue }
    }

    public enum OfferingClass: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case convertible = "CONVERTIBLE"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum OrderString: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum PurchasingOption: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allUpfront = "ALL_UPFRONT"
        case noUpfront = "NO_UPFRONT"
        case partialUpfront = "PARTIAL_UPFRONT"
        public var description: String { return self.rawValue }
    }

    public enum Tenancy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dedicated = "DEDICATED"
        case shared = "SHARED"
        public var description: String { return self.rawValue }
    }

    public enum TermLength: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case oneYear = "ONE_YEAR"
        case threeYear = "THREE_YEAR"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AgentConfigurationStatus: AWSDecodableShape {
        /// The agent ID.
        public let agentId: String?
        /// A description of the operation performed.
        public let description: String?
        /// Information about the status of the StartDataCollection and StopDataCollection operations. The system has recorded the data collection operation. The agent receives this command the next time it polls for a new command.
        public let operationSucceeded: Bool?

        public init(agentId: String? = nil, description: String? = nil, operationSucceeded: Bool? = nil) {
            self.agentId = agentId
            self.description = description
            self.operationSucceeded = operationSucceeded
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case description = "description"
            case operationSucceeded = "operationSucceeded"
        }
    }

    public struct AgentInfo: AWSDecodableShape {
        /// The agent or collector ID.
        public let agentId: String?
        /// Network details about the host where the agent or collector resides.
        public let agentNetworkInfoList: [AgentNetworkInfo]?
        /// Type of agent.
        public let agentType: String?
        /// Status of the collection process for an agent.
        public let collectionStatus: String?
        /// The ID of the connector.
        public let connectorId: String?
        /// The health of the agent.
        public let health: AgentStatus?
        /// The name of the host where the agent or collector resides. The host can be a server or virtual machine.
        public let hostName: String?
        /// Time since agent health was reported.
        public let lastHealthPingTime: String?
        /// Agent's first registration timestamp in UTC.
        public let registeredTime: String?
        /// The agent or collector version.
        public let version: String?

        public init(agentId: String? = nil, agentNetworkInfoList: [AgentNetworkInfo]? = nil, agentType: String? = nil, collectionStatus: String? = nil, connectorId: String? = nil, health: AgentStatus? = nil, hostName: String? = nil, lastHealthPingTime: String? = nil, registeredTime: String? = nil, version: String? = nil) {
            self.agentId = agentId
            self.agentNetworkInfoList = agentNetworkInfoList
            self.agentType = agentType
            self.collectionStatus = collectionStatus
            self.connectorId = connectorId
            self.health = health
            self.hostName = hostName
            self.lastHealthPingTime = lastHealthPingTime
            self.registeredTime = registeredTime
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case agentNetworkInfoList = "agentNetworkInfoList"
            case agentType = "agentType"
            case collectionStatus = "collectionStatus"
            case connectorId = "connectorId"
            case health = "health"
            case hostName = "hostName"
            case lastHealthPingTime = "lastHealthPingTime"
            case registeredTime = "registeredTime"
            case version = "version"
        }
    }

    public struct AgentNetworkInfo: AWSDecodableShape {
        /// The IP address for the host where the agent/collector resides.
        public let ipAddress: String?
        /// The MAC address for the host where the agent/collector resides.
        public let macAddress: String?

        public init(ipAddress: String? = nil, macAddress: String? = nil) {
            self.ipAddress = ipAddress
            self.macAddress = macAddress
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "ipAddress"
            case macAddress = "macAddress"
        }
    }

    public struct AssociateConfigurationItemsToApplicationRequest: AWSEncodableShape {
        /// The configuration ID of an application with which items are to be associated.
        public let applicationConfigurationId: String
        /// The ID of each configuration item to be associated with an application.
        public let configurationIds: [String]

        public init(applicationConfigurationId: String, configurationIds: [String]) {
            self.applicationConfigurationId = applicationConfigurationId
            self.configurationIds = configurationIds
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationConfigurationId, name: "applicationConfigurationId", parent: name, max: 200)
            try self.validate(self.applicationConfigurationId, name: "applicationConfigurationId", parent: name, pattern: "^\\S+$")
            try self.configurationIds.forEach {
                try validate($0, name: "configurationIds[]", parent: name, max: 200)
                try validate($0, name: "configurationIds[]", parent: name, pattern: "^\\S*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicationConfigurationId = "applicationConfigurationId"
            case configurationIds = "configurationIds"
        }
    }

    public struct AssociateConfigurationItemsToApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BatchDeleteAgentError: AWSDecodableShape {
        ///  The ID of the agent or data collector to delete.
        public let agentId: String
        ///  The type of error that occurred for the delete failed agent.  Valid status are: AGENT_IN_USE | NOT_FOUND | INTERNAL_SERVER_ERROR.
        public let errorCode: DeleteAgentErrorCode
        ///  The description of the error that occurred for the delete failed agent.
        public let errorMessage: String

        public init(agentId: String, errorCode: DeleteAgentErrorCode, errorMessage: String) {
            self.agentId = agentId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct BatchDeleteAgentsRequest: AWSEncodableShape {
        ///  The list of agents to delete.
        public let deleteAgents: [DeleteAgent]

        public init(deleteAgents: [DeleteAgent]) {
            self.deleteAgents = deleteAgents
        }

        public func validate(name: String) throws {
            try self.deleteAgents.forEach {
                try $0.validate(name: "\(name).deleteAgents[]")
            }
            try self.validate(self.deleteAgents, name: "deleteAgents", parent: name, max: 50)
            try self.validate(self.deleteAgents, name: "deleteAgents", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deleteAgents = "deleteAgents"
        }
    }

    public struct BatchDeleteAgentsResponse: AWSDecodableShape {
        ///  A list of agent IDs that failed to delete during the deletion task, each paired with an error message.
        public let errors: [BatchDeleteAgentError]?

        public init(errors: [BatchDeleteAgentError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct BatchDeleteConfigurationTask: AWSDecodableShape {
        ///  The type of configuration item to delete. Supported types are: SERVER.
        public let configurationType: DeletionConfigurationItemType?
        ///  The list of configuration IDs that were successfully deleted by the deletion task.
        public let deletedConfigurations: [String]?
        ///  A list of configuration IDs that produced warnings regarding their deletion,  paired with a warning message.
        public let deletionWarnings: [DeletionWarning]?
        ///  An epoch seconds timestamp (UTC) of when the deletion task was completed or failed.
        public let endTime: Date?
        ///  A list of configuration IDs that failed to delete during the deletion task,  each paired with an error message.
        public let failedConfigurations: [FailedConfiguration]?
        ///  The list of configuration IDs that were originally requested to be deleted by the deletion task.
        public let requestedConfigurations: [String]?
        ///  An epoch seconds timestamp (UTC) of when the deletion task was started.
        public let startTime: Date?
        ///  The current execution status of the deletion task.  Valid status are: INITIALIZING | VALIDATING | DELETING | COMPLETED | FAILED.
        public let status: BatchDeleteConfigurationTaskStatus?
        ///  The deletion task's unique identifier.
        public let taskId: String?

        public init(configurationType: DeletionConfigurationItemType? = nil, deletedConfigurations: [String]? = nil, deletionWarnings: [DeletionWarning]? = nil, endTime: Date? = nil, failedConfigurations: [FailedConfiguration]? = nil, requestedConfigurations: [String]? = nil, startTime: Date? = nil, status: BatchDeleteConfigurationTaskStatus? = nil, taskId: String? = nil) {
            self.configurationType = configurationType
            self.deletedConfigurations = deletedConfigurations
            self.deletionWarnings = deletionWarnings
            self.endTime = endTime
            self.failedConfigurations = failedConfigurations
            self.requestedConfigurations = requestedConfigurations
            self.startTime = startTime
            self.status = status
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationType = "configurationType"
            case deletedConfigurations = "deletedConfigurations"
            case deletionWarnings = "deletionWarnings"
            case endTime = "endTime"
            case failedConfigurations = "failedConfigurations"
            case requestedConfigurations = "requestedConfigurations"
            case startTime = "startTime"
            case status = "status"
            case taskId = "taskId"
        }
    }

    public struct BatchDeleteImportDataError: AWSDecodableShape {
        /// The type of error that occurred for a specific import task.
        public let errorCode: BatchDeleteImportDataErrorCode?
        /// The description of the error that occurred for a specific import task.
        public let errorDescription: String?
        /// The unique import ID associated with the error that occurred.
        public let importTaskId: String?

        public init(errorCode: BatchDeleteImportDataErrorCode? = nil, errorDescription: String? = nil, importTaskId: String? = nil) {
            self.errorCode = errorCode
            self.errorDescription = errorDescription
            self.importTaskId = importTaskId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorDescription = "errorDescription"
            case importTaskId = "importTaskId"
        }
    }

    public struct BatchDeleteImportDataRequest: AWSEncodableShape {
        ///  Set to true to remove the deleted import task from  DescribeImportTasks.
        public let deleteHistory: Bool?
        /// The IDs for the import tasks that you want to delete.
        public let importTaskIds: [String]

        public init(deleteHistory: Bool? = nil, importTaskIds: [String]) {
            self.deleteHistory = deleteHistory
            self.importTaskIds = importTaskIds
        }

        public func validate(name: String) throws {
            try self.importTaskIds.forEach {
                try validate($0, name: "importTaskIds[]", parent: name, max: 200)
                try validate($0, name: "importTaskIds[]", parent: name, pattern: "^import-task-[a-fA-F0-9]{32}$")
            }
            try self.validate(self.importTaskIds, name: "importTaskIds", parent: name, max: 10)
            try self.validate(self.importTaskIds, name: "importTaskIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case deleteHistory = "deleteHistory"
            case importTaskIds = "importTaskIds"
        }
    }

    public struct BatchDeleteImportDataResponse: AWSDecodableShape {
        /// Error messages returned for each import task that you deleted as a response for this command.
        public let errors: [BatchDeleteImportDataError]?

        public init(errors: [BatchDeleteImportDataError]? = nil) {
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "errors"
        }
    }

    public struct ConfigurationTag: AWSDecodableShape {
        /// The configuration ID for the item to tag. You can specify a list of keys and values.
        public let configurationId: String?
        /// A type of IT asset to tag.
        public let configurationType: ConfigurationItemType?
        /// A type of tag on which to filter. For example, serverType.
        public let key: String?
        /// The time the configuration tag was created in Coordinated Universal Time (UTC).
        public let timeOfCreation: Date?
        /// A value on which to filter. For example key = serverType and value = web server.
        public let value: String?

        public init(configurationId: String? = nil, configurationType: ConfigurationItemType? = nil, key: String? = nil, timeOfCreation: Date? = nil, value: String? = nil) {
            self.configurationId = configurationId
            self.configurationType = configurationType
            self.key = key
            self.timeOfCreation = timeOfCreation
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case configurationType = "configurationType"
            case key = "key"
            case timeOfCreation = "timeOfCreation"
            case value = "value"
        }
    }

    public struct ContinuousExportDescription: AWSDecodableShape {
        /// The type of data collector used to gather this data (currently only offered for AGENT).
        public let dataSource: DataSource?
        /// The unique ID assigned to this export.
        public let exportId: String?
        /// The name of the s3 bucket where the export data parquet files are stored.
        public let s3Bucket: String?
        /// An object which describes how the data is stored.    databaseName - the name of the Glue database used to store the schema.
        public let schemaStorageConfig: [String: String]?
        /// The timestamp representing when the continuous export was started.
        public let startTime: Date?
        /// Describes the status of the export. Can be one of the following values:   START_IN_PROGRESS - setting up resources to start continuous export.   START_FAILED - an error occurred setting up continuous export. To recover, call start-continuous-export again.   ACTIVE - data is being exported to the customer bucket.   ERROR - an error occurred during export. To fix the issue, call stop-continuous-export and start-continuous-export.   STOP_IN_PROGRESS - stopping the export.   STOP_FAILED - an error occurred stopping the export. To recover, call stop-continuous-export again.   INACTIVE - the continuous export has been stopped. Data is no longer being exported to the customer bucket.
        public let status: ContinuousExportStatus?
        /// Contains information about any errors that have occurred. This data type can have the following values:   ACCESS_DENIED - You don’t have permission to start Data Exploration in Amazon Athena. Contact your Amazon Web Services administrator for help. For more information, see Setting Up Amazon Web Services Application Discovery Service in the Application Discovery Service User Guide.   DELIVERY_STREAM_LIMIT_FAILURE - You reached the limit for Amazon Kinesis Data Firehose delivery streams. Reduce the number of streams or request a limit increase and try again. For more information, see Kinesis Data Streams Limits in the Amazon Kinesis Data Streams Developer Guide.   FIREHOSE_ROLE_MISSING - The Data Exploration feature is in an error state because your user is missing the Amazon Web ServicesApplicationDiscoveryServiceFirehose role. Turn on Data Exploration in Amazon Athena and try again. For more information, see Creating the Amazon Web ServicesApplicationDiscoveryServiceFirehose Role in the Application Discovery Service User Guide.   FIREHOSE_STREAM_DOES_NOT_EXIST - The Data Exploration feature is in an error state because your user is missing one or more of the Kinesis data delivery streams.   INTERNAL_FAILURE - The Data Exploration feature is in an error state because of an internal failure. Try again later. If this problem persists, contact Amazon Web Services Support.   LAKE_FORMATION_ACCESS_DENIED - You don't have sufficient lake formation permissions to start continuous export. For more information, see  Upgrading Amazon Web Services Glue Data Permissions to the Amazon Web Services Lake Formation Model  in the Amazon Web Services Lake Formation Developer Guide.  You can use one of the following two ways to resolve this issue.   If you don’t want to use the Lake Formation permission model, you can change the default Data Catalog settings to use only Amazon Web Services Identity and Access Management (IAM) access control for new databases. For more information, see Change Data Catalog Settings in the Lake Formation Developer Guide.   You can give the service-linked IAM roles AWSServiceRoleForApplicationDiscoveryServiceContinuousExport and AWSApplicationDiscoveryServiceFirehose the required Lake Formation permissions. For more information, see  Granting Database Permissions in the Lake Formation Developer Guide.    AWSServiceRoleForApplicationDiscoveryServiceContinuousExport - Grant database creator permissions, which gives the role database creation ability and implicit permissions for any created tables. For more information, see  Implicit Lake Formation Permissions  in the Lake Formation Developer Guide.   AWSApplicationDiscoveryServiceFirehose - Grant describe permissions for all tables in the database.       S3_BUCKET_LIMIT_FAILURE - You reached the limit for Amazon S3 buckets. Reduce the number of S3 buckets or request a limit increase and try again. For more information, see Bucket Restrictions and Limitations in the Amazon Simple Storage Service Developer Guide.   S3_NOT_SIGNED_UP - Your account is not signed up for the  Amazon S3 service. You must sign up before you can use Amazon S3. You can sign up at the following URL: https://aws.amazon.com/s3.
        public let statusDetail: String?
        /// The timestamp that represents when this continuous export was stopped.
        public let stopTime: Date?

        public init(dataSource: DataSource? = nil, exportId: String? = nil, s3Bucket: String? = nil, schemaStorageConfig: [String: String]? = nil, startTime: Date? = nil, status: ContinuousExportStatus? = nil, statusDetail: String? = nil, stopTime: Date? = nil) {
            self.dataSource = dataSource
            self.exportId = exportId
            self.s3Bucket = s3Bucket
            self.schemaStorageConfig = schemaStorageConfig
            self.startTime = startTime
            self.status = status
            self.statusDetail = statusDetail
            self.stopTime = stopTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
            case exportId = "exportId"
            case s3Bucket = "s3Bucket"
            case schemaStorageConfig = "schemaStorageConfig"
            case startTime = "startTime"
            case status = "status"
            case statusDetail = "statusDetail"
            case stopTime = "stopTime"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// Description of the application to be created.
        public let description: String?
        /// Name of the application to be created.
        public let name: String

        public init(description: String? = nil, name: String) {
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(^$|[\\s\\S]*\\S[\\s\\S]*)$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case name = "name"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        /// Configuration ID of an application to be created.
        public let configurationId: String?

        public init(configurationId: String? = nil) {
            self.configurationId = configurationId
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
        }
    }

    public struct CreateTagsRequest: AWSEncodableShape {
        /// A list of configuration items that you want to tag.
        public let configurationIds: [String]
        /// Tags that you want to associate with one or more configuration items. Specify the tags that you want to create in a key-value format. For example:  {"key": "serverType", "value": "webServer"}
        public let tags: [Tag]

        public init(configurationIds: [String], tags: [Tag]) {
            self.configurationIds = configurationIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configurationIds.forEach {
                try validate($0, name: "configurationIds[]", parent: name, max: 200)
                try validate($0, name: "configurationIds[]", parent: name, pattern: "^\\S*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationIds = "configurationIds"
            case tags = "tags"
        }
    }

    public struct CreateTagsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CustomerAgentInfo: AWSDecodableShape {
        /// Number of active discovery agents.
        public let activeAgents: Int
        /// Number of blacklisted discovery agents.
        public let blackListedAgents: Int
        /// Number of healthy discovery agents
        public let healthyAgents: Int
        /// Number of discovery agents with status SHUTDOWN.
        public let shutdownAgents: Int
        /// Total number of discovery agents.
        public let totalAgents: Int
        /// Number of unhealthy discovery agents.
        public let unhealthyAgents: Int
        /// Number of unknown discovery agents.
        public let unknownAgents: Int

        public init(activeAgents: Int, blackListedAgents: Int, healthyAgents: Int, shutdownAgents: Int, totalAgents: Int, unhealthyAgents: Int, unknownAgents: Int) {
            self.activeAgents = activeAgents
            self.blackListedAgents = blackListedAgents
            self.healthyAgents = healthyAgents
            self.shutdownAgents = shutdownAgents
            self.totalAgents = totalAgents
            self.unhealthyAgents = unhealthyAgents
            self.unknownAgents = unknownAgents
        }

        private enum CodingKeys: String, CodingKey {
            case activeAgents = "activeAgents"
            case blackListedAgents = "blackListedAgents"
            case healthyAgents = "healthyAgents"
            case shutdownAgents = "shutdownAgents"
            case totalAgents = "totalAgents"
            case unhealthyAgents = "unhealthyAgents"
            case unknownAgents = "unknownAgents"
        }
    }

    public struct CustomerAgentlessCollectorInfo: AWSDecodableShape {
        /// The number of active Agentless Collector collectors.
        public let activeAgentlessCollectors: Int
        /// The number of deny-listed Agentless Collector collectors.
        public let denyListedAgentlessCollectors: Int
        /// The number of healthy Agentless Collector collectors.
        public let healthyAgentlessCollectors: Int
        /// The number of Agentless Collector collectors with SHUTDOWN status.
        public let shutdownAgentlessCollectors: Int
        ///  The total number of Agentless Collector collectors.
        public let totalAgentlessCollectors: Int
        ///  The number of unhealthy Agentless Collector collectors.
        public let unhealthyAgentlessCollectors: Int
        ///  The number of unknown Agentless Collector collectors.
        public let unknownAgentlessCollectors: Int

        public init(activeAgentlessCollectors: Int, denyListedAgentlessCollectors: Int, healthyAgentlessCollectors: Int, shutdownAgentlessCollectors: Int, totalAgentlessCollectors: Int, unhealthyAgentlessCollectors: Int, unknownAgentlessCollectors: Int) {
            self.activeAgentlessCollectors = activeAgentlessCollectors
            self.denyListedAgentlessCollectors = denyListedAgentlessCollectors
            self.healthyAgentlessCollectors = healthyAgentlessCollectors
            self.shutdownAgentlessCollectors = shutdownAgentlessCollectors
            self.totalAgentlessCollectors = totalAgentlessCollectors
            self.unhealthyAgentlessCollectors = unhealthyAgentlessCollectors
            self.unknownAgentlessCollectors = unknownAgentlessCollectors
        }

        private enum CodingKeys: String, CodingKey {
            case activeAgentlessCollectors = "activeAgentlessCollectors"
            case denyListedAgentlessCollectors = "denyListedAgentlessCollectors"
            case healthyAgentlessCollectors = "healthyAgentlessCollectors"
            case shutdownAgentlessCollectors = "shutdownAgentlessCollectors"
            case totalAgentlessCollectors = "totalAgentlessCollectors"
            case unhealthyAgentlessCollectors = "unhealthyAgentlessCollectors"
            case unknownAgentlessCollectors = "unknownAgentlessCollectors"
        }
    }

    public struct CustomerConnectorInfo: AWSDecodableShape {
        /// Number of active discovery connectors.
        public let activeConnectors: Int
        /// Number of blacklisted discovery connectors.
        public let blackListedConnectors: Int
        /// Number of healthy discovery connectors.
        public let healthyConnectors: Int
        /// Number of discovery connectors with status SHUTDOWN,
        public let shutdownConnectors: Int
        /// Total number of discovery connectors.
        public let totalConnectors: Int
        /// Number of unhealthy discovery connectors.
        public let unhealthyConnectors: Int
        /// Number of unknown discovery connectors.
        public let unknownConnectors: Int

        public init(activeConnectors: Int, blackListedConnectors: Int, healthyConnectors: Int, shutdownConnectors: Int, totalConnectors: Int, unhealthyConnectors: Int, unknownConnectors: Int) {
            self.activeConnectors = activeConnectors
            self.blackListedConnectors = blackListedConnectors
            self.healthyConnectors = healthyConnectors
            self.shutdownConnectors = shutdownConnectors
            self.totalConnectors = totalConnectors
            self.unhealthyConnectors = unhealthyConnectors
            self.unknownConnectors = unknownConnectors
        }

        private enum CodingKeys: String, CodingKey {
            case activeConnectors = "activeConnectors"
            case blackListedConnectors = "blackListedConnectors"
            case healthyConnectors = "healthyConnectors"
            case shutdownConnectors = "shutdownConnectors"
            case totalConnectors = "totalConnectors"
            case unhealthyConnectors = "unhealthyConnectors"
            case unknownConnectors = "unknownConnectors"
        }
    }

    public struct CustomerMeCollectorInfo: AWSDecodableShape {
        ///  The number of active Migration Evaluator collectors.
        public let activeMeCollectors: Int
        ///  The number of deny-listed Migration Evaluator collectors.
        public let denyListedMeCollectors: Int
        ///  The number of healthy Migration Evaluator collectors.
        public let healthyMeCollectors: Int
        ///  The number of Migration Evaluator collectors with SHUTDOWN status.
        public let shutdownMeCollectors: Int
        ///  The total number of Migration Evaluator collectors.
        public let totalMeCollectors: Int
        ///  The number of unhealthy Migration Evaluator collectors.
        public let unhealthyMeCollectors: Int
        ///  The number of unknown Migration Evaluator collectors.
        public let unknownMeCollectors: Int

        public init(activeMeCollectors: Int, denyListedMeCollectors: Int, healthyMeCollectors: Int, shutdownMeCollectors: Int, totalMeCollectors: Int, unhealthyMeCollectors: Int, unknownMeCollectors: Int) {
            self.activeMeCollectors = activeMeCollectors
            self.denyListedMeCollectors = denyListedMeCollectors
            self.healthyMeCollectors = healthyMeCollectors
            self.shutdownMeCollectors = shutdownMeCollectors
            self.totalMeCollectors = totalMeCollectors
            self.unhealthyMeCollectors = unhealthyMeCollectors
            self.unknownMeCollectors = unknownMeCollectors
        }

        private enum CodingKeys: String, CodingKey {
            case activeMeCollectors = "activeMeCollectors"
            case denyListedMeCollectors = "denyListedMeCollectors"
            case healthyMeCollectors = "healthyMeCollectors"
            case shutdownMeCollectors = "shutdownMeCollectors"
            case totalMeCollectors = "totalMeCollectors"
            case unhealthyMeCollectors = "unhealthyMeCollectors"
            case unknownMeCollectors = "unknownMeCollectors"
        }
    }

    public struct DeleteAgent: AWSEncodableShape {
        ///  The ID of the agent or data collector to delete.
        public let agentId: String
        ///  Optional flag used to force delete an agent or data collector. It is needed to delete any agent in  HEALTHY/UNHEALTHY/RUNNING status. Note that deleting an agent that is actively reporting health causes it  to be re-registered with a different agent ID after data collector re-connects with Amazon Web Services.
        public let force: Bool?

        public init(agentId: String, force: Bool? = nil) {
            self.agentId = agentId
            self.force = force
        }

        public func validate(name: String) throws {
            try self.validate(self.agentId, name: "agentId", parent: name, max: 20)
            try self.validate(self.agentId, name: "agentId", parent: name, min: 10)
            try self.validate(self.agentId, name: "agentId", parent: name, pattern: "^\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case agentId = "agentId"
            case force = "force"
        }
    }

    public struct DeleteApplicationsRequest: AWSEncodableShape {
        /// Configuration ID of an application to be deleted.
        public let configurationIds: [String]

        public init(configurationIds: [String]) {
            self.configurationIds = configurationIds
        }

        public func validate(name: String) throws {
            try self.configurationIds.forEach {
                try validate($0, name: "configurationIds[]", parent: name, max: 200)
                try validate($0, name: "configurationIds[]", parent: name, pattern: "^\\S+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationIds = "configurationIds"
        }
    }

    public struct DeleteApplicationsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTagsRequest: AWSEncodableShape {
        /// A list of configuration items with tags that you want to delete.
        public let configurationIds: [String]
        /// Tags that you want to delete from one or more configuration items. Specify the tags that you want to delete in a key-value format. For example:  {"key": "serverType", "value": "webServer"}
        public let tags: [Tag]?

        public init(configurationIds: [String], tags: [Tag]? = nil) {
            self.configurationIds = configurationIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.configurationIds.forEach {
                try validate($0, name: "configurationIds[]", parent: name, max: 200)
                try validate($0, name: "configurationIds[]", parent: name, pattern: "^\\S*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationIds = "configurationIds"
            case tags = "tags"
        }
    }

    public struct DeleteTagsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletionWarning: AWSDecodableShape {
        ///  The unique identifier of the configuration that produced a warning.
        public let configurationId: String?
        ///  The integer warning code associated with the warning message.
        public let warningCode: Int?
        ///  A descriptive message of the warning the associated configuration ID produced.
        public let warningText: String?

        public init(configurationId: String? = nil, warningCode: Int? = nil, warningText: String? = nil) {
            self.configurationId = configurationId
            self.warningCode = warningCode
            self.warningText = warningText
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case warningCode = "warningCode"
            case warningText = "warningText"
        }
    }

    public struct DescribeAgentsRequest: AWSEncodableShape {
        /// The agent or the collector IDs for which you want information. If you specify no IDs, the system returns information about all agents/collectors associated with your user.
        public let agentIds: [String]?
        /// You can filter the request using various logical operators and a key-value format. For example:   {"key": "collectionStatus", "value": "STARTED"}
        public let filters: [Filter]?
        /// The total number of agents/collectors to return in a single page of output. The maximum value is 100.
        public let maxResults: Int?
        /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
        public let nextToken: String?

        public init(agentIds: [String]? = nil, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentIds = agentIds
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.agentIds?.forEach {
                try validate($0, name: "agentIds[]", parent: name, max: 20)
                try validate($0, name: "agentIds[]", parent: name, min: 10)
                try validate($0, name: "agentIds[]", parent: name, pattern: "^\\S+$")
            }
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentIds = "agentIds"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeAgentsResponse: AWSDecodableShape {
        /// Lists agents or the collector by ID or lists all agents/collectors associated with your user, if you did not specify an agent/collector ID. The output includes agent/collector IDs, IP addresses, media access control (MAC) addresses, agent/collector health, host name where the agent/collector resides, and the version number of each agent/collector.
        public let agentsInfo: [AgentInfo]?
        /// Token to retrieve the next set of results. For example, if you specified 100 IDs for DescribeAgentsRequest$agentIds but set DescribeAgentsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
        public let nextToken: String?

        public init(agentsInfo: [AgentInfo]? = nil, nextToken: String? = nil) {
            self.agentsInfo = agentsInfo
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentsInfo = "agentsInfo"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeBatchDeleteConfigurationTaskRequest: AWSEncodableShape {
        ///  The ID of the task to delete.
        public let taskId: String

        public init(taskId: String) {
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case taskId = "taskId"
        }
    }

    public struct DescribeBatchDeleteConfigurationTaskResponse: AWSDecodableShape {
        ///  The BatchDeleteConfigurationTask that represents the deletion task being executed.
        public let task: BatchDeleteConfigurationTask?

        public init(task: BatchDeleteConfigurationTask? = nil) {
            self.task = task
        }

        private enum CodingKeys: String, CodingKey {
            case task = "task"
        }
    }

    public struct DescribeConfigurationsRequest: AWSEncodableShape {
        /// One or more configuration IDs.
        public let configurationIds: [String]

        public init(configurationIds: [String]) {
            self.configurationIds = configurationIds
        }

        public func validate(name: String) throws {
            try self.configurationIds.forEach {
                try validate($0, name: "configurationIds[]", parent: name, max: 200)
                try validate($0, name: "configurationIds[]", parent: name, pattern: "^\\S*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationIds = "configurationIds"
        }
    }

    public struct DescribeConfigurationsResponse: AWSDecodableShape {
        /// A key in the response map. The value is an array of data.
        public let configurations: [[String: String]]?

        public init(configurations: [[String: String]]? = nil) {
            self.configurations = configurations
        }

        private enum CodingKeys: String, CodingKey {
            case configurations = "configurations"
        }
    }

    public struct DescribeContinuousExportsRequest: AWSEncodableShape {
        /// The unique IDs assigned to the exports.
        public let exportIds: [String]?
        /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
        public let maxResults: Int?
        /// The token from the previous call to DescribeExportTasks.
        public let nextToken: String?

        public init(exportIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.exportIds = exportIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.exportIds?.forEach {
                try validate($0, name: "exportIds[]", parent: name, max: 200)
                try validate($0, name: "exportIds[]", parent: name, pattern: "^\\S*$")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case exportIds = "exportIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeContinuousExportsResponse: AWSDecodableShape {
        /// A list of continuous export descriptions.
        public let descriptions: [ContinuousExportDescription]?
        /// The token from the previous call to DescribeExportTasks.
        public let nextToken: String?

        public init(descriptions: [ContinuousExportDescription]? = nil, nextToken: String? = nil) {
            self.descriptions = descriptions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case descriptions = "descriptions"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeExportConfigurationsRequest: AWSEncodableShape {
        /// A list of continuous export IDs to search for.
        public let exportIds: [String]?
        /// A number between 1 and 100 specifying the maximum number of continuous export descriptions returned.
        public let maxResults: Int?
        /// The token from the previous call to describe-export-tasks.
        public let nextToken: String?

        public init(exportIds: [String]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.exportIds = exportIds
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.exportIds?.forEach {
                try validate($0, name: "exportIds[]", parent: name, max: 200)
                try validate($0, name: "exportIds[]", parent: name, pattern: "^\\S*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exportIds = "exportIds"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeExportConfigurationsResponse: AWSDecodableShape {
        public let exportsInfo: [ExportInfo]?
        /// The token from the previous call to describe-export-tasks.
        public let nextToken: String?

        public init(exportsInfo: [ExportInfo]? = nil, nextToken: String? = nil) {
            self.exportsInfo = exportsInfo
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportsInfo = "exportsInfo"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeExportTasksRequest: AWSEncodableShape {
        /// One or more unique identifiers used to query the status of an export request.
        public let exportIds: [String]?
        /// One or more filters.    AgentId - ID of the agent whose collected data will be exported
        public let filters: [ExportFilter]?
        /// The maximum number of volume results returned by DescribeExportTasks in paginated output. When this parameter is used, DescribeExportTasks only returns maxResults results in a single page along with a nextToken response element.
        public let maxResults: Int?
        /// The nextToken value returned from a previous paginated DescribeExportTasks request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(exportIds: [String]? = nil, filters: [ExportFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.exportIds = exportIds
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.exportIds?.forEach {
                try validate($0, name: "exportIds[]", parent: name, max: 200)
                try validate($0, name: "exportIds[]", parent: name, pattern: "^\\S*$")
            }
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exportIds = "exportIds"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeExportTasksResponse: AWSDecodableShape {
        /// Contains one or more sets of export request details. When the status of a request is SUCCEEDED, the response includes a URL for an Amazon S3 bucket where you can view the data in a CSV file.
        public let exportsInfo: [ExportInfo]?
        /// The nextToken value to include in a future DescribeExportTasks request. When the results of a DescribeExportTasks request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
        public let nextToken: String?

        public init(exportsInfo: [ExportInfo]? = nil, nextToken: String? = nil) {
            self.exportsInfo = exportsInfo
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportsInfo = "exportsInfo"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeImportTasksRequest: AWSEncodableShape {
        /// An array of name-value pairs that you provide to filter the results for the DescribeImportTask request to a specific subset of results. Currently, wildcard values aren't supported for filters.
        public let filters: [ImportTaskFilter]?
        /// The maximum number of results that you want this request to return, up to 100.
        public let maxResults: Int?
        /// The token to request a specific page of results.
        public let nextToken: String?

        public init(filters: [ImportTaskFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeImportTasksResponse: AWSDecodableShape {
        /// The token to request the next page of results.
        public let nextToken: String?
        /// A returned array of import tasks that match any applied filters, up to the specified number of maximum results.
        public let tasks: [ImportTask]?

        public init(nextToken: String? = nil, tasks: [ImportTask]? = nil) {
            self.nextToken = nextToken
            self.tasks = tasks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tasks = "tasks"
        }
    }

    public struct DescribeTagsRequest: AWSEncodableShape {
        /// You can filter the list using a key-value format. You can separate these items by using logical operators. Allowed filters include tagKey, tagValue, and configurationId.
        public let filters: [TagFilter]?
        /// The total number of items to return in a single page of output. The maximum value is 100.
        public let maxResults: Int?
        /// A token to start the list. Use this token to get the next set of results.
        public let nextToken: String?

        public init(filters: [TagFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeTagsResponse: AWSDecodableShape {
        /// The call returns a token. Use this token to get the next set of results.
        public let nextToken: String?
        /// Depending on the input, this is a list of configuration items tagged with a specific tag, or a list of tags for a specific configuration item.
        public let tags: [ConfigurationTag]?

        public init(nextToken: String? = nil, tags: [ConfigurationTag]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tags = "tags"
        }
    }

    public struct DisassociateConfigurationItemsFromApplicationRequest: AWSEncodableShape {
        /// Configuration ID of an application from which each item is disassociated.
        public let applicationConfigurationId: String
        /// Configuration ID of each item to be disassociated from an application.
        public let configurationIds: [String]

        public init(applicationConfigurationId: String, configurationIds: [String]) {
            self.applicationConfigurationId = applicationConfigurationId
            self.configurationIds = configurationIds
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationConfigurationId, name: "applicationConfigurationId", parent: name, max: 200)
            try self.validate(self.applicationConfigurationId, name: "applicationConfigurationId", parent: name, pattern: "^\\S+$")
            try self.configurationIds.forEach {
                try validate($0, name: "configurationIds[]", parent: name, max: 200)
                try validate($0, name: "configurationIds[]", parent: name, pattern: "^\\S*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case applicationConfigurationId = "applicationConfigurationId"
            case configurationIds = "configurationIds"
        }
    }

    public struct DisassociateConfigurationItemsFromApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Ec2RecommendationsExportPreferences: AWSEncodableShape {
        ///  The recommended EC2 instance type that matches the CPU usage metric of server performance data.
        public let cpuPerformanceMetricBasis: UsageMetricBasis?
        ///  If set to true, the export  preferences is set to Ec2RecommendationsExportPreferences.
        public let enabled: Bool?
        ///  An array of instance types to exclude from recommendations.
        public let excludedInstanceTypes: [String]?
        ///  The target Amazon Web Services Region for the recommendations.  You can use any of the Region codes available for the chosen service,  as listed in Amazon Web Services service endpoints in the Amazon Web Services General Reference.
        public let preferredRegion: String?
        ///  The recommended EC2 instance type that matches the Memory usage metric of server performance data.
        public let ramPerformanceMetricBasis: UsageMetricBasis?
        ///  The contract type for a reserved instance.  If blank, we assume an On-Demand instance is preferred.
        public let reservedInstanceOptions: ReservedInstanceOptions?
        ///  The target tenancy to use for your recommended EC2 instances.
        public let tenancy: Tenancy?

        public init(cpuPerformanceMetricBasis: UsageMetricBasis? = nil, enabled: Bool? = nil, excludedInstanceTypes: [String]? = nil, preferredRegion: String? = nil, ramPerformanceMetricBasis: UsageMetricBasis? = nil, reservedInstanceOptions: ReservedInstanceOptions? = nil, tenancy: Tenancy? = nil) {
            self.cpuPerformanceMetricBasis = cpuPerformanceMetricBasis
            self.enabled = enabled
            self.excludedInstanceTypes = excludedInstanceTypes
            self.preferredRegion = preferredRegion
            self.ramPerformanceMetricBasis = ramPerformanceMetricBasis
            self.reservedInstanceOptions = reservedInstanceOptions
            self.tenancy = tenancy
        }

        public func validate(name: String) throws {
            try self.cpuPerformanceMetricBasis?.validate(name: "\(name).cpuPerformanceMetricBasis")
            try self.excludedInstanceTypes?.forEach {
                try validate($0, name: "excludedInstanceTypes[]", parent: name, max: 25)
                try validate($0, name: "excludedInstanceTypes[]", parent: name, min: 1)
                try validate($0, name: "excludedInstanceTypes[]", parent: name, pattern: "^[a-zA-Z0-9\\d\\.\\-]+$")
            }
            try self.validate(self.preferredRegion, name: "preferredRegion", parent: name, max: 30)
            try self.validate(self.preferredRegion, name: "preferredRegion", parent: name, min: 1)
            try self.validate(self.preferredRegion, name: "preferredRegion", parent: name, pattern: "^[a-z]{2}-[a-z\\-]+-[0-9]+$")
            try self.ramPerformanceMetricBasis?.validate(name: "\(name).ramPerformanceMetricBasis")
        }

        private enum CodingKeys: String, CodingKey {
            case cpuPerformanceMetricBasis = "cpuPerformanceMetricBasis"
            case enabled = "enabled"
            case excludedInstanceTypes = "excludedInstanceTypes"
            case preferredRegion = "preferredRegion"
            case ramPerformanceMetricBasis = "ramPerformanceMetricBasis"
            case reservedInstanceOptions = "reservedInstanceOptions"
            case tenancy = "tenancy"
        }
    }

    public struct ExportConfigurationsResponse: AWSDecodableShape {
        /// A unique identifier that you can use to query the export status.
        public let exportId: String?

        public init(exportId: String? = nil) {
            self.exportId = exportId
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "exportId"
        }
    }

    public struct ExportFilter: AWSEncodableShape {
        /// Supported condition: EQUALS
        public let condition: String
        /// A single ExportFilter name. Supported filters: agentIds.
        public let name: String
        /// A single agent ID for a Discovery Agent. An agent ID can be found using the DescribeAgents action. Typically an ADS agent ID is in the form o-0123456789abcdef0.
        public let values: [String]

        public init(condition: String, name: String, values: [String]) {
            self.condition = condition
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, max: 200)
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^\\S+$")
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1000)
                try validate($0, name: "values[]", parent: name, pattern: "^(^$|[\\s\\S]*\\S[\\s\\S]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case name = "name"
            case values = "values"
        }
    }

    public struct ExportInfo: AWSDecodableShape {
        /// A URL for an Amazon S3 bucket where you can review the exported data. The URL is displayed only if the export succeeded.
        public let configurationsDownloadUrl: String?
        /// A unique identifier used to query an export.
        public let exportId: String
        /// The time that the data export was initiated.
        public let exportRequestTime: Date
        /// The status of the data export job.
        public let exportStatus: ExportStatus
        /// If true, the export of agent information exceeded the size limit for a single export and the exported data is incomplete for the requested time range. To address this, select a smaller time range for the export by using startDate and endDate.
        public let isTruncated: Bool?
        /// The endTime used in the StartExportTask request. If no endTime was requested, this result does not appear in ExportInfo.
        public let requestedEndTime: Date?
        /// The value of startTime parameter in the StartExportTask request. If no startTime was requested, this result does not appear in ExportInfo.
        public let requestedStartTime: Date?
        /// A status message provided for API callers.
        public let statusMessage: String

        public init(configurationsDownloadUrl: String? = nil, exportId: String, exportRequestTime: Date, exportStatus: ExportStatus, isTruncated: Bool? = nil, requestedEndTime: Date? = nil, requestedStartTime: Date? = nil, statusMessage: String) {
            self.configurationsDownloadUrl = configurationsDownloadUrl
            self.exportId = exportId
            self.exportRequestTime = exportRequestTime
            self.exportStatus = exportStatus
            self.isTruncated = isTruncated
            self.requestedEndTime = requestedEndTime
            self.requestedStartTime = requestedStartTime
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case configurationsDownloadUrl = "configurationsDownloadUrl"
            case exportId = "exportId"
            case exportRequestTime = "exportRequestTime"
            case exportStatus = "exportStatus"
            case isTruncated = "isTruncated"
            case requestedEndTime = "requestedEndTime"
            case requestedStartTime = "requestedStartTime"
            case statusMessage = "statusMessage"
        }
    }

    public struct FailedConfiguration: AWSDecodableShape {
        ///  The unique identifier of the configuration the failed to delete.
        public let configurationId: String?
        ///  A descriptive message indicating why the associated configuration failed to delete.
        public let errorMessage: String?
        ///  The integer error code associated with the error message.
        public let errorStatusCode: Int?

        public init(configurationId: String? = nil, errorMessage: String? = nil, errorStatusCode: Int? = nil) {
            self.configurationId = configurationId
            self.errorMessage = errorMessage
            self.errorStatusCode = errorStatusCode
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case errorMessage = "errorMessage"
            case errorStatusCode = "errorStatusCode"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// A conditional operator. The following operators are valid: EQUALS, NOT_EQUALS, CONTAINS, NOT_CONTAINS. If you specify multiple filters, the system utilizes all filters as though concatenated by AND. If you specify multiple values for a particular filter, the system differentiates the values using OR. Calling either DescribeConfigurations or ListConfigurations returns attributes of matching configuration items.
        public let condition: String
        /// The name of the filter.
        public let name: String
        /// A string value on which to filter. For example, if you choose the destinationServer.osVersion filter name, you could specify Ubuntu for the value.
        public let values: [String]

        public init(condition: String, name: String, values: [String]) {
            self.condition = condition
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.condition, name: "condition", parent: name, max: 200)
            try self.validate(self.condition, name: "condition", parent: name, pattern: "^\\S+$")
            try self.validate(self.name, name: "name", parent: name, max: 10000)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\s\\S]*$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1000)
                try validate($0, name: "values[]", parent: name, pattern: "^(^$|[\\s\\S]*\\S[\\s\\S]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case name = "name"
            case values = "values"
        }
    }

    public struct GetDiscoverySummaryRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetDiscoverySummaryResponse: AWSDecodableShape {
        ///  Details about Agentless Collector collectors, including status.
        public let agentlessCollectorSummary: CustomerAgentlessCollectorInfo?
        /// Details about discovered agents, including agent status and health.
        public let agentSummary: CustomerAgentInfo?
        /// The number of applications discovered.
        public let applications: Int64?
        /// Details about discovered connectors, including connector status and health.
        public let connectorSummary: CustomerConnectorInfo?
        ///  Details about Migration Evaluator collectors, including collector status and health.
        public let meCollectorSummary: CustomerMeCollectorInfo?
        /// The number of servers discovered.
        public let servers: Int64?
        /// The number of servers mapped to applications.
        public let serversMappedToApplications: Int64?
        /// The number of servers mapped to tags.
        public let serversMappedtoTags: Int64?

        public init(agentlessCollectorSummary: CustomerAgentlessCollectorInfo? = nil, agentSummary: CustomerAgentInfo? = nil, applications: Int64? = nil, connectorSummary: CustomerConnectorInfo? = nil, meCollectorSummary: CustomerMeCollectorInfo? = nil, servers: Int64? = nil, serversMappedToApplications: Int64? = nil, serversMappedtoTags: Int64? = nil) {
            self.agentlessCollectorSummary = agentlessCollectorSummary
            self.agentSummary = agentSummary
            self.applications = applications
            self.connectorSummary = connectorSummary
            self.meCollectorSummary = meCollectorSummary
            self.servers = servers
            self.serversMappedToApplications = serversMappedToApplications
            self.serversMappedtoTags = serversMappedtoTags
        }

        private enum CodingKeys: String, CodingKey {
            case agentlessCollectorSummary = "agentlessCollectorSummary"
            case agentSummary = "agentSummary"
            case applications = "applications"
            case connectorSummary = "connectorSummary"
            case meCollectorSummary = "meCollectorSummary"
            case servers = "servers"
            case serversMappedToApplications = "serversMappedToApplications"
            case serversMappedtoTags = "serversMappedtoTags"
        }
    }

    public struct ImportTask: AWSDecodableShape {
        /// The total number of application records in the import file that failed to be imported.
        public let applicationImportFailure: Int?
        /// The total number of application records in the import file that were successfully imported.
        public let applicationImportSuccess: Int?
        /// A unique token used to prevent the same import request from occurring more than once. If you didn't provide a token, a token was automatically generated when the import task request was sent.
        public let clientRequestToken: String?
        /// A link to a compressed archive folder (in the ZIP format) that contains an error log and a file of failed records. You can use these two files to quickly identify records that failed, why they failed, and correct those records. Afterward, you can upload the corrected file to your Amazon S3 bucket and create another import task request. This field also includes authorization information so you can confirm the authenticity of the compressed archive before you download it. If some records failed to be imported we recommend that you correct the records in the failed entries file and then imports that failed entries file. This prevents you from having to correct and update the larger original file and attempt importing it again.
        public let errorsAndFailedEntriesZip: String?
        /// The time that the import task request finished, presented in the Unix time stamp format.
        public let importCompletionTime: Date?
        /// The time that the import task request was deleted, presented in the Unix time stamp format.
        public let importDeletedTime: Date?
        /// The time that the import task request was made, presented in the Unix time stamp format.
        public let importRequestTime: Date?
        /// The unique ID for a specific import task. These IDs aren't globally unique, but they are unique within an Amazon Web Services account.
        public let importTaskId: String?
        /// The URL for your import file that you've uploaded to Amazon S3.
        public let importUrl: String?
        /// A descriptive name for an import task. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
        public let name: String?
        /// The total number of server records in the import file that failed to be imported.
        public let serverImportFailure: Int?
        /// The total number of server records in the import file that were successfully imported.
        public let serverImportSuccess: Int?
        /// The status of the import task. An import can have the status of IMPORT_COMPLETE and still have some records fail to import from the overall request. More information can be found in the downloadable archive defined in the errorsAndFailedEntriesZip field, or in the Migration Hub management console.
        public let status: ImportStatus?

        public init(applicationImportFailure: Int? = nil, applicationImportSuccess: Int? = nil, clientRequestToken: String? = nil, errorsAndFailedEntriesZip: String? = nil, importCompletionTime: Date? = nil, importDeletedTime: Date? = nil, importRequestTime: Date? = nil, importTaskId: String? = nil, importUrl: String? = nil, name: String? = nil, serverImportFailure: Int? = nil, serverImportSuccess: Int? = nil, status: ImportStatus? = nil) {
            self.applicationImportFailure = applicationImportFailure
            self.applicationImportSuccess = applicationImportSuccess
            self.clientRequestToken = clientRequestToken
            self.errorsAndFailedEntriesZip = errorsAndFailedEntriesZip
            self.importCompletionTime = importCompletionTime
            self.importDeletedTime = importDeletedTime
            self.importRequestTime = importRequestTime
            self.importTaskId = importTaskId
            self.importUrl = importUrl
            self.name = name
            self.serverImportFailure = serverImportFailure
            self.serverImportSuccess = serverImportSuccess
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case applicationImportFailure = "applicationImportFailure"
            case applicationImportSuccess = "applicationImportSuccess"
            case clientRequestToken = "clientRequestToken"
            case errorsAndFailedEntriesZip = "errorsAndFailedEntriesZip"
            case importCompletionTime = "importCompletionTime"
            case importDeletedTime = "importDeletedTime"
            case importRequestTime = "importRequestTime"
            case importTaskId = "importTaskId"
            case importUrl = "importUrl"
            case name = "name"
            case serverImportFailure = "serverImportFailure"
            case serverImportSuccess = "serverImportSuccess"
            case status = "status"
        }
    }

    public struct ImportTaskFilter: AWSEncodableShape {
        /// The name, status, or import task ID for a specific import task.
        public let name: ImportTaskFilterName?
        /// An array of strings that you can provide to match against a specific name, status, or import task ID to filter the results for your import task queries.
        public let values: [String]?

        public init(name: ImportTaskFilterName? = nil, values: [String]? = nil) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.values?.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.validate(self.values, name: "values", parent: name, max: 100)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct ListConfigurationsRequest: AWSEncodableShape {
        /// A valid configuration identified by Application Discovery Service.
        public let configurationType: ConfigurationItemType
        /// You can filter the request using various logical operators and a key-value format. For example:   {"key": "serverType", "value": "webServer"}  For a complete list of filter options and guidance about using them with this action, see Using the ListConfigurations Action in the Amazon Web Services Application Discovery Service User Guide.
        public let filters: [Filter]?
        /// The total number of items to return. The maximum value is 100.
        public let maxResults: Int?
        /// Token to retrieve the next set of results. For example, if a previous call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
        public let nextToken: String?
        /// Certain filter criteria return output that can be sorted in ascending or descending order. For a list of output characteristics for each filter, see Using the ListConfigurations Action in the Amazon Web Services Application Discovery Service User Guide.
        public let orderBy: [OrderByElement]?

        public init(configurationType: ConfigurationItemType, filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, orderBy: [OrderByElement]? = nil) {
            self.configurationType = configurationType
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.orderBy = orderBy
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.orderBy?.forEach {
                try $0.validate(name: "\(name).orderBy[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationType = "configurationType"
            case filters = "filters"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case orderBy = "orderBy"
        }
    }

    public struct ListConfigurationsResponse: AWSDecodableShape {
        /// Returns configuration details, including the configuration ID, attribute names, and attribute values.
        public let configurations: [[String: String]]?
        /// Token to retrieve the next set of results. For example, if your call to ListConfigurations returned 100 items, but you set ListConfigurationsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
        public let nextToken: String?

        public init(configurations: [[String: String]]? = nil, nextToken: String? = nil) {
            self.configurations = configurations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case configurations = "configurations"
            case nextToken = "nextToken"
        }
    }

    public struct ListServerNeighborsRequest: AWSEncodableShape {
        /// Configuration ID of the server for which neighbors are being listed.
        public let configurationId: String
        /// Maximum number of results to return in a single page of output.
        public let maxResults: Int?
        /// List of configuration IDs to test for one-hop-away.
        public let neighborConfigurationIds: [String]?
        /// Token to retrieve the next set of results. For example, if you previously specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with a token. Use that token in this query to get the next set of 10.
        public let nextToken: String?
        /// Flag to indicate if port and protocol information is needed as part of the response.
        public let portInformationNeeded: Bool?

        public init(configurationId: String, maxResults: Int? = nil, neighborConfigurationIds: [String]? = nil, nextToken: String? = nil, portInformationNeeded: Bool? = nil) {
            self.configurationId = configurationId
            self.maxResults = maxResults
            self.neighborConfigurationIds = neighborConfigurationIds
            self.nextToken = nextToken
            self.portInformationNeeded = portInformationNeeded
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationId, name: "configurationId", parent: name, max: 200)
            try self.validate(self.configurationId, name: "configurationId", parent: name, pattern: "^\\S*$")
            try self.neighborConfigurationIds?.forEach {
                try validate($0, name: "neighborConfigurationIds[]", parent: name, max: 200)
                try validate($0, name: "neighborConfigurationIds[]", parent: name, pattern: "^\\S*$")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case maxResults = "maxResults"
            case neighborConfigurationIds = "neighborConfigurationIds"
            case nextToken = "nextToken"
            case portInformationNeeded = "portInformationNeeded"
        }
    }

    public struct ListServerNeighborsResponse: AWSDecodableShape {
        /// Count of distinct servers that are one hop away from the given server.
        public let knownDependencyCount: Int64?
        /// List of distinct servers that are one hop away from the given server.
        public let neighbors: [NeighborConnectionDetail]
        /// Token to retrieve the next set of results. For example, if you specified 100 IDs for ListServerNeighborsRequest$neighborConfigurationIds but set ListServerNeighborsRequest$maxResults to 10, you received a set of 10 results along with this token. Use this token in the next query to retrieve the next set of 10.
        public let nextToken: String?

        public init(knownDependencyCount: Int64? = nil, neighbors: [NeighborConnectionDetail], nextToken: String? = nil) {
            self.knownDependencyCount = knownDependencyCount
            self.neighbors = neighbors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case knownDependencyCount = "knownDependencyCount"
            case neighbors = "neighbors"
            case nextToken = "nextToken"
        }
    }

    public struct NeighborConnectionDetail: AWSDecodableShape {
        /// The number of open network connections with the neighboring server.
        public let connectionsCount: Int64
        /// The destination network port for the connection.
        public let destinationPort: Int?
        /// The ID of the server that accepted the network connection.
        public let destinationServerId: String
        /// The ID of the server that opened the network connection.
        public let sourceServerId: String
        /// The network protocol used for the connection.
        public let transportProtocol: String?

        public init(connectionsCount: Int64, destinationPort: Int? = nil, destinationServerId: String, sourceServerId: String, transportProtocol: String? = nil) {
            self.connectionsCount = connectionsCount
            self.destinationPort = destinationPort
            self.destinationServerId = destinationServerId
            self.sourceServerId = sourceServerId
            self.transportProtocol = transportProtocol
        }

        private enum CodingKeys: String, CodingKey {
            case connectionsCount = "connectionsCount"
            case destinationPort = "destinationPort"
            case destinationServerId = "destinationServerId"
            case sourceServerId = "sourceServerId"
            case transportProtocol = "transportProtocol"
        }
    }

    public struct OrderByElement: AWSEncodableShape {
        /// The field on which to order.
        public let fieldName: String
        /// Ordering direction.
        public let sortOrder: OrderString?

        public init(fieldName: String, sortOrder: OrderString? = nil) {
            self.fieldName = fieldName
            self.sortOrder = sortOrder
        }

        public func validate(name: String) throws {
            try self.validate(self.fieldName, name: "fieldName", parent: name, max: 1000)
            try self.validate(self.fieldName, name: "fieldName", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "fieldName"
            case sortOrder = "sortOrder"
        }
    }

    public struct ReservedInstanceOptions: AWSEncodableShape {
        ///  The flexibility to change the instance types needed for your Reserved Instance.
        public let offeringClass: OfferingClass
        ///  The payment plan to use for your Reserved Instance.
        public let purchasingOption: PurchasingOption
        ///  The preferred duration of the Reserved Instance term.
        public let termLength: TermLength

        public init(offeringClass: OfferingClass, purchasingOption: PurchasingOption, termLength: TermLength) {
            self.offeringClass = offeringClass
            self.purchasingOption = purchasingOption
            self.termLength = termLength
        }

        private enum CodingKeys: String, CodingKey {
            case offeringClass = "offeringClass"
            case purchasingOption = "purchasingOption"
            case termLength = "termLength"
        }
    }

    public struct StartBatchDeleteConfigurationTaskRequest: AWSEncodableShape {
        ///  The list of configuration IDs that will be deleted by the task.
        public let configurationIds: [String]
        ///  The type of configuration item to delete. Supported types are: SERVER.
        public let configurationType: DeletionConfigurationItemType

        public init(configurationIds: [String], configurationType: DeletionConfigurationItemType) {
            self.configurationIds = configurationIds
            self.configurationType = configurationType
        }

        public func validate(name: String) throws {
            try self.configurationIds.forEach {
                try validate($0, name: "configurationIds[]", parent: name, max: 200)
                try validate($0, name: "configurationIds[]", parent: name, pattern: "^\\S*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case configurationIds = "configurationIds"
            case configurationType = "configurationType"
        }
    }

    public struct StartBatchDeleteConfigurationTaskResponse: AWSDecodableShape {
        ///  The unique identifier associated with the newly started deletion task.
        public let taskId: String?

        public init(taskId: String? = nil) {
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case taskId = "taskId"
        }
    }

    public struct StartContinuousExportRequest: AWSEncodableShape {
        public init() {}
    }

    public struct StartContinuousExportResponse: AWSDecodableShape {
        /// The type of data collector used to gather this data (currently only offered for AGENT).
        public let dataSource: DataSource?
        /// The unique ID assigned to this export.
        public let exportId: String?
        /// The name of the s3 bucket where the export data parquet files are stored.
        public let s3Bucket: String?
        /// A dictionary which describes how the data is stored.    databaseName - the name of the Glue database used to store the schema.
        public let schemaStorageConfig: [String: String]?
        /// The timestamp representing when the continuous export was started.
        public let startTime: Date?

        public init(dataSource: DataSource? = nil, exportId: String? = nil, s3Bucket: String? = nil, schemaStorageConfig: [String: String]? = nil, startTime: Date? = nil) {
            self.dataSource = dataSource
            self.exportId = exportId
            self.s3Bucket = s3Bucket
            self.schemaStorageConfig = schemaStorageConfig
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "dataSource"
            case exportId = "exportId"
            case s3Bucket = "s3Bucket"
            case schemaStorageConfig = "schemaStorageConfig"
            case startTime = "startTime"
        }
    }

    public struct StartDataCollectionByAgentIdsRequest: AWSEncodableShape {
        /// The IDs of the agents from which to start collecting data. If you send a request to an agent ID that you do not have permission to contact, according to your Amazon Web Services account, the service does not throw an exception. Instead, it returns the error in the Description field. If you send a request to multiple agents and you do not have permission to contact some of those agents, the system does not throw an exception. Instead, the system shows Failed in the Description field.
        public let agentIds: [String]

        public init(agentIds: [String]) {
            self.agentIds = agentIds
        }

        public func validate(name: String) throws {
            try self.agentIds.forEach {
                try validate($0, name: "agentIds[]", parent: name, max: 20)
                try validate($0, name: "agentIds[]", parent: name, min: 10)
                try validate($0, name: "agentIds[]", parent: name, pattern: "^\\S+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentIds = "agentIds"
        }
    }

    public struct StartDataCollectionByAgentIdsResponse: AWSDecodableShape {
        /// Information about agents that were instructed to start collecting data. Information includes the agent ID, a description of the operation performed, and whether the agent configuration was updated.
        public let agentsConfigurationStatus: [AgentConfigurationStatus]?

        public init(agentsConfigurationStatus: [AgentConfigurationStatus]? = nil) {
            self.agentsConfigurationStatus = agentsConfigurationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case agentsConfigurationStatus = "agentsConfigurationStatus"
        }
    }

    public struct StartExportTaskRequest: AWSEncodableShape {
        /// The end timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, exported data includes the most recent data collected by the agent.
        public let endTime: Date?
        /// The file format for the returned export data. Default value is CSV. Note: The GRAPHML option has been deprecated.
        public let exportDataFormat: [ExportDataFormat]?
        /// If a filter is present, it selects the single agentId of the Application Discovery Agent for which data is exported. The agentId can be found in the results of the DescribeAgents API or CLI. If no filter is present, startTime and endTime are ignored and exported data includes both Amazon Web Services Application Discovery Service Agentless Collector collectors data and summary data from Application Discovery Agent agents.
        public let filters: [ExportFilter]?
        ///  Indicates the type of data that needs to be exported. Only one  ExportPreferences can be enabled at any time.
        public let preferences: ExportPreferences?
        /// The start timestamp for exported data from the single Application Discovery Agent selected in the filters. If no value is specified, data is exported starting from the first data collected by the agent.
        public let startTime: Date?

        public init(endTime: Date? = nil, exportDataFormat: [ExportDataFormat]? = nil, filters: [ExportFilter]? = nil, preferences: ExportPreferences? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.exportDataFormat = exportDataFormat
            self.filters = filters
            self.preferences = preferences
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.preferences?.validate(name: "\(name).preferences")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case exportDataFormat = "exportDataFormat"
            case filters = "filters"
            case preferences = "preferences"
            case startTime = "startTime"
        }
    }

    public struct StartExportTaskResponse: AWSDecodableShape {
        /// A unique identifier used to query the status of an export request.
        public let exportId: String?

        public init(exportId: String? = nil) {
            self.exportId = exportId
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "exportId"
        }
    }

    public struct StartImportTaskRequest: AWSEncodableShape {
        /// Optional. A unique token that you can provide to prevent the same import request from occurring more than once. If you don't provide a token, a token is automatically generated. Sending more than one StartImportTask request with the same client request token will return information about the original import task with that client request token.
        public let clientRequestToken: String?
        /// The URL for your import file that you've uploaded to Amazon S3.  If you're using the Amazon Web Services CLI, this URL is structured as follows: s3://BucketName/ImportFileName.CSV
        public let importUrl: String
        /// A descriptive name for this request. You can use this name to filter future requests related to this import task, such as identifying applications and servers that were included in this import task. We recommend that you use a meaningful name for each import task.
        public let name: String

        public init(clientRequestToken: String? = StartImportTaskRequest.idempotencyToken(), importUrl: String, name: String) {
            self.clientRequestToken = clientRequestToken
            self.importUrl = importUrl
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 100)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.importUrl, name: "importUrl", parent: name, max: 4000)
            try self.validate(self.importUrl, name: "importUrl", parent: name, min: 1)
            try self.validate(self.importUrl, name: "importUrl", parent: name, pattern: "^\\S+://\\S+/[\\s\\S]*\\S[\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "clientRequestToken"
            case importUrl = "importUrl"
            case name = "name"
        }
    }

    public struct StartImportTaskResponse: AWSDecodableShape {
        /// An array of information related to the import task request including status information, times, IDs, the Amazon S3 Object URL for the import file, and more.
        public let task: ImportTask?

        public init(task: ImportTask? = nil) {
            self.task = task
        }

        private enum CodingKeys: String, CodingKey {
            case task = "task"
        }
    }

    public struct StopContinuousExportRequest: AWSEncodableShape {
        /// The unique ID assigned to this export.
        public let exportId: String

        public init(exportId: String) {
            self.exportId = exportId
        }

        public func validate(name: String) throws {
            try self.validate(self.exportId, name: "exportId", parent: name, max: 200)
            try self.validate(self.exportId, name: "exportId", parent: name, pattern: "^\\S*$")
        }

        private enum CodingKeys: String, CodingKey {
            case exportId = "exportId"
        }
    }

    public struct StopContinuousExportResponse: AWSDecodableShape {
        /// Timestamp that represents when this continuous export started collecting data.
        public let startTime: Date?
        /// Timestamp that represents when this continuous export was stopped.
        public let stopTime: Date?

        public init(startTime: Date? = nil, stopTime: Date? = nil) {
            self.startTime = startTime
            self.stopTime = stopTime
        }

        private enum CodingKeys: String, CodingKey {
            case startTime = "startTime"
            case stopTime = "stopTime"
        }
    }

    public struct StopDataCollectionByAgentIdsRequest: AWSEncodableShape {
        /// The IDs of the agents from which to stop collecting data.
        public let agentIds: [String]

        public init(agentIds: [String]) {
            self.agentIds = agentIds
        }

        public func validate(name: String) throws {
            try self.agentIds.forEach {
                try validate($0, name: "agentIds[]", parent: name, max: 20)
                try validate($0, name: "agentIds[]", parent: name, min: 10)
                try validate($0, name: "agentIds[]", parent: name, pattern: "^\\S+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentIds = "agentIds"
        }
    }

    public struct StopDataCollectionByAgentIdsResponse: AWSDecodableShape {
        /// Information about the agents that were instructed to stop collecting data. Information includes the agent ID, a description of the operation performed, and whether the agent configuration was updated.
        public let agentsConfigurationStatus: [AgentConfigurationStatus]?

        public init(agentsConfigurationStatus: [AgentConfigurationStatus]? = nil) {
            self.agentsConfigurationStatus = agentsConfigurationStatus
        }

        private enum CodingKeys: String, CodingKey {
            case agentsConfigurationStatus = "agentsConfigurationStatus"
        }
    }

    public struct Tag: AWSEncodableShape {
        /// The type of tag on which to filter.
        public let key: String
        /// A value for a tag key on which to filter.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagFilter: AWSEncodableShape {
        /// A name of the tag filter.
        public let name: String
        /// Values for the tag filter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 1000)
                try validate($0, name: "values[]", parent: name, pattern: "^(^$|[\\s\\S]*\\S[\\s\\S]*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case values = "values"
        }
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// Configuration ID of the application to be updated.
        public let configurationId: String
        /// New description of the application to be updated.
        public let description: String?
        /// New name of the application to be updated.
        public let name: String?

        public init(configurationId: String, description: String? = nil, name: String? = nil) {
            self.configurationId = configurationId
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.configurationId, name: "configurationId", parent: name, max: 200)
            try self.validate(self.configurationId, name: "configurationId", parent: name, pattern: "^\\S+$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(^$|[\\s\\S]*\\S[\\s\\S]*)$")
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configurationId = "configurationId"
            case description = "description"
            case name = "name"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UsageMetricBasis: AWSEncodableShape {
        ///  A utilization metric that is used by the recommendations.
        public let name: String?
        ///  Specifies the percentage of the specified utilization metric that is used by the recommendations.
        public let percentageAdjust: Double?

        public init(name: String? = nil, percentageAdjust: Double? = nil) {
            self.name = name
            self.percentageAdjust = percentageAdjust
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, pattern: "^(p(\\d{1,2}|100)|AVG|SPEC|MAX)$")
            try self.validate(self.percentageAdjust, name: "percentageAdjust", parent: name, max: 100.0)
            try self.validate(self.percentageAdjust, name: "percentageAdjust", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case percentageAdjust = "percentageAdjust"
        }
    }

    public struct ExportPreferences: AWSEncodableShape {
        ///  If enabled, exported data includes EC2 instance type matches for on-premises servers  discovered through Amazon Web Services Application Discovery Service.
        public let ec2RecommendationsPreferences: Ec2RecommendationsExportPreferences?

        public init(ec2RecommendationsPreferences: Ec2RecommendationsExportPreferences? = nil) {
            self.ec2RecommendationsPreferences = ec2RecommendationsPreferences
        }

        public func validate(name: String) throws {
            try self.ec2RecommendationsPreferences?.validate(name: "\(name).ec2RecommendationsPreferences")
        }

        private enum CodingKeys: String, CodingKey {
            case ec2RecommendationsPreferences = "ec2RecommendationsPreferences"
        }
    }
}

// MARK: - Errors

/// Error enum for ApplicationDiscoveryService
public struct ApplicationDiscoveryServiceErrorType: AWSErrorType {
    enum Code: String {
        case authorizationErrorException = "AuthorizationErrorException"
        case conflictErrorException = "ConflictErrorException"
        case homeRegionNotSetException = "HomeRegionNotSetException"
        case invalidParameterException = "InvalidParameterException"
        case invalidParameterValueException = "InvalidParameterValueException"
        case limitExceededException = "LimitExceededException"
        case operationNotPermittedException = "OperationNotPermittedException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serverInternalErrorException = "ServerInternalErrorException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize ApplicationDiscoveryService
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The user does not have permission to perform the action. Check the IAM policy associated with this user.
    public static var authorizationErrorException: Self { .init(.authorizationErrorException) }
    /// Conflict error.
    public static var conflictErrorException: Self { .init(.conflictErrorException) }
    /// The home Region is not set. Set the home Region to continue.
    public static var homeRegionNotSetException: Self { .init(.homeRegionNotSetException) }
    /// One or more parameters are not valid. Verify the parameters and try again.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The value of one or more parameters are either invalid or out of range. Verify the parameter values and try again.
    public static var invalidParameterValueException: Self { .init(.invalidParameterValueException) }
    ///  The limit of 200 configuration IDs per request has been exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// This operation is not permitted.
    public static var operationNotPermittedException: Self { .init(.operationNotPermittedException) }
    /// This issue occurs when the same clientRequestToken is used with the StartImportTask action, but with different parameters. For example, you use the same request token but have two different import URLs, you can encounter this issue. If the import tasks are meant to be different, use a different clientRequestToken, and try again.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The specified configuration ID was not located. Verify the configuration ID and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The server experienced an internal error. Try again.
    public static var serverInternalErrorException: Self { .init(.serverInternalErrorException) }
}

extension ApplicationDiscoveryServiceErrorType: Equatable {
    public static func == (lhs: ApplicationDiscoveryServiceErrorType, rhs: ApplicationDiscoveryServiceErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ApplicationDiscoveryServiceErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
