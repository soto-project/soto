//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension Macie2 {
    // MARK: Enums

    public enum AdminStatus: String, CustomStringConvertible, Codable {
        case disablingInProgress = "DISABLING_IN_PROGRESS"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AllowsUnencryptedObjectUploads: String, CustomStringConvertible, Codable {
        case `false` = "FALSE"
        case `true` = "TRUE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum Currency: String, CustomStringConvertible, Codable {
        case usd = "USD"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum EffectivePermission: String, CustomStringConvertible, Codable {
        case notPublic = "NOT_PUBLIC"
        case `public` = "PUBLIC"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable {
        case aes256 = "AES256"
        case awsKms = "aws:kms"
        case none = "NONE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable {
        case clienterror = "ClientError"
        case internalerror = "InternalError"
        public var description: String { return self.rawValue }
    }

    public enum FindingActionType: String, CustomStringConvertible, Codable {
        case awsApiCall = "AWS_API_CALL"
        public var description: String { return self.rawValue }
    }

    public enum FindingCategory: String, CustomStringConvertible, Codable {
        case classification = "CLASSIFICATION"
        case policy = "POLICY"
        public var description: String { return self.rawValue }
    }

    public enum FindingPublishingFrequency: String, CustomStringConvertible, Codable {
        case fifteenMinutes = "FIFTEEN_MINUTES"
        case oneHour = "ONE_HOUR"
        case sixHours = "SIX_HOURS"
        public var description: String { return self.rawValue }
    }

    public enum FindingStatisticsSortAttributeName: String, CustomStringConvertible, Codable {
        case count
        case groupkey = "groupKey"
        public var description: String { return self.rawValue }
    }

    public enum FindingType: String, CustomStringConvertible, Codable {
        case policyIamuserS3Blockpublicaccessdisabled = "Policy:IAMUser/S3BlockPublicAccessDisabled"
        case policyIamuserS3Bucketencryptiondisabled = "Policy:IAMUser/S3BucketEncryptionDisabled"
        case policyIamuserS3Bucketpublic = "Policy:IAMUser/S3BucketPublic"
        case policyIamuserS3Bucketreplicatedexternally = "Policy:IAMUser/S3BucketReplicatedExternally"
        case policyIamuserS3Bucketsharedexternally = "Policy:IAMUser/S3BucketSharedExternally"
        case sensitivedataS3ObjectCredentials = "SensitiveData:S3Object/Credentials"
        case sensitivedataS3ObjectCustomidentifier = "SensitiveData:S3Object/CustomIdentifier"
        case sensitivedataS3ObjectFinancial = "SensitiveData:S3Object/Financial"
        case sensitivedataS3ObjectMultiple = "SensitiveData:S3Object/Multiple"
        case sensitivedataS3ObjectPersonal = "SensitiveData:S3Object/Personal"
        public var description: String { return self.rawValue }
    }

    public enum FindingsFilterAction: String, CustomStringConvertible, Codable {
        case archive = "ARCHIVE"
        case noop = "NOOP"
        public var description: String { return self.rawValue }
    }

    public enum GroupBy: String, CustomStringConvertible, Codable {
        case classificationdetailsJobid = "classificationDetails.jobId"
        case resourcesaffectedS3BucketName = "resourcesAffected.s3Bucket.name"
        case severityDescription = "severity.description"
        case type
        public var description: String { return self.rawValue }
    }

    public enum IsDefinedInJob: String, CustomStringConvertible, Codable {
        case `false` = "FALSE"
        case `true` = "TRUE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum IsMonitoredByJob: String, CustomStringConvertible, Codable {
        case `false` = "FALSE"
        case `true` = "TRUE"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum JobComparator: String, CustomStringConvertible, Codable {
        case contains = "CONTAINS"
        case eq = "EQ"
        case gt = "GT"
        case gte = "GTE"
        case lt = "LT"
        case lte = "LTE"
        case ne = "NE"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case cancelled = "CANCELLED"
        case complete = "COMPLETE"
        case idle = "IDLE"
        case paused = "PAUSED"
        case running = "RUNNING"
        case userPaused = "USER_PAUSED"
        public var description: String { return self.rawValue }
    }

    public enum JobType: String, CustomStringConvertible, Codable {
        case oneTime = "ONE_TIME"
        case scheduled = "SCHEDULED"
        public var description: String { return self.rawValue }
    }

    public enum LastRunErrorStatusCode: String, CustomStringConvertible, Codable {
        case error = "ERROR"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum ListJobsFilterKey: String, CustomStringConvertible, Codable {
        case createdat = "createdAt"
        case jobstatus = "jobStatus"
        case jobtype = "jobType"
        case name
        public var description: String { return self.rawValue }
    }

    public enum ListJobsSortAttributeName: String, CustomStringConvertible, Codable {
        case createdat = "createdAt"
        case jobstatus = "jobStatus"
        case jobtype = "jobType"
        case name
        public var description: String { return self.rawValue }
    }

    public enum MacieStatus: String, CustomStringConvertible, Codable {
        case enabled = "ENABLED"
        case paused = "PAUSED"
        public var description: String { return self.rawValue }
    }

    public enum OrderBy: String, CustomStringConvertible, Codable {
        case asc = "ASC"
        case desc = "DESC"
        public var description: String { return self.rawValue }
    }

    public enum RelationshipStatus: String, CustomStringConvertible, Codable {
        case accountsuspended = "AccountSuspended"
        case created = "Created"
        case emailverificationfailed = "EmailVerificationFailed"
        case emailverificationinprogress = "EmailVerificationInProgress"
        case enabled = "Enabled"
        case invited = "Invited"
        case paused = "Paused"
        case regiondisabled = "RegionDisabled"
        case removed = "Removed"
        case resigned = "Resigned"
        public var description: String { return self.rawValue }
    }

    public enum ScopeFilterKey: String, CustomStringConvertible, Codable {
        case objectExtension = "OBJECT_EXTENSION"
        case objectKey = "OBJECT_KEY"
        case objectLastModifiedDate = "OBJECT_LAST_MODIFIED_DATE"
        case objectSize = "OBJECT_SIZE"
        public var description: String { return self.rawValue }
    }

    public enum SearchResourcesComparator: String, CustomStringConvertible, Codable {
        case eq = "EQ"
        case ne = "NE"
        public var description: String { return self.rawValue }
    }

    public enum SearchResourcesSimpleCriterionKey: String, CustomStringConvertible, Codable {
        case accountId = "ACCOUNT_ID"
        case s3BucketEffectivePermission = "S3_BUCKET_EFFECTIVE_PERMISSION"
        case s3BucketName = "S3_BUCKET_NAME"
        case s3BucketSharedAccess = "S3_BUCKET_SHARED_ACCESS"
        public var description: String { return self.rawValue }
    }

    public enum SearchResourcesSortAttributeName: String, CustomStringConvertible, Codable {
        case accountId = "ACCOUNT_ID"
        case resourceName = "RESOURCE_NAME"
        case s3ClassifiableObjectCount = "S3_CLASSIFIABLE_OBJECT_COUNT"
        case s3ClassifiableSizeInBytes = "S3_CLASSIFIABLE_SIZE_IN_BYTES"
        public var description: String { return self.rawValue }
    }

    public enum SensitiveDataItemCategory: String, CustomStringConvertible, Codable {
        case credentials = "CREDENTIALS"
        case customIdentifier = "CUSTOM_IDENTIFIER"
        case financialInformation = "FINANCIAL_INFORMATION"
        case personalInformation = "PERSONAL_INFORMATION"
        public var description: String { return self.rawValue }
    }

    public enum SeverityDescription: String, CustomStringConvertible, Codable {
        case high = "High"
        case low = "Low"
        case medium = "Medium"
        public var description: String { return self.rawValue }
    }

    public enum SharedAccess: String, CustomStringConvertible, Codable {
        case external = "EXTERNAL"
        case `internal` = "INTERNAL"
        case notShared = "NOT_SHARED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum SimpleCriterionKeyForJob: String, CustomStringConvertible, Codable {
        case accountId = "ACCOUNT_ID"
        case s3BucketEffectivePermission = "S3_BUCKET_EFFECTIVE_PERMISSION"
        case s3BucketName = "S3_BUCKET_NAME"
        case s3BucketSharedAccess = "S3_BUCKET_SHARED_ACCESS"
        public var description: String { return self.rawValue }
    }

    public enum StorageClass: String, CustomStringConvertible, Codable {
        case deepArchive = "DEEP_ARCHIVE"
        case glacier = "GLACIER"
        case intelligentTiering = "INTELLIGENT_TIERING"
        case onezoneIa = "ONEZONE_IA"
        case reducedRedundancy = "REDUCED_REDUNDANCY"
        case standard = "STANDARD"
        case standardIa = "STANDARD_IA"
        public var description: String { return self.rawValue }
    }

    public enum TagTarget: String, CustomStringConvertible, Codable {
        case s3Object = "S3_OBJECT"
        public var description: String { return self.rawValue }
    }

    public enum TimeRange: String, CustomStringConvertible, Codable {
        case monthToDate = "MONTH_TO_DATE"
        case past30Days = "PAST_30_DAYS"
        public var description: String { return self.rawValue }
    }

    public enum `Type`: String, CustomStringConvertible, Codable {
        case aes256 = "AES256"
        case awsKms = "aws:kms"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum Unit: String, CustomStringConvertible, Codable {
        case terabytes = "TERABYTES"
        public var description: String { return self.rawValue }
    }

    public enum UsageStatisticsFilterComparator: String, CustomStringConvertible, Codable {
        case contains = "CONTAINS"
        case eq = "EQ"
        case gt = "GT"
        case gte = "GTE"
        case lt = "LT"
        case lte = "LTE"
        case ne = "NE"
        public var description: String { return self.rawValue }
    }

    public enum UsageStatisticsFilterKey: String, CustomStringConvertible, Codable {
        case accountid = "accountId"
        case freetrialstartdate = "freeTrialStartDate"
        case servicelimit = "serviceLimit"
        case total
        public var description: String { return self.rawValue }
    }

    public enum UsageStatisticsSortKey: String, CustomStringConvertible, Codable {
        case accountid = "accountId"
        case freetrialstartdate = "freeTrialStartDate"
        case servicelimitvalue = "serviceLimitValue"
        case total
        public var description: String { return self.rawValue }
    }

    public enum UsageType: String, CustomStringConvertible, Codable {
        case dataInventoryEvaluation = "DATA_INVENTORY_EVALUATION"
        case sensitiveDataDiscovery = "SENSITIVE_DATA_DISCOVERY"
        public var description: String { return self.rawValue }
    }

    public enum UserIdentityType: String, CustomStringConvertible, Codable {
        case assumedrole = "AssumedRole"
        case awsaccount = "AWSAccount"
        case awsservice = "AWSService"
        case federateduser = "FederatedUser"
        case iamuser = "IAMUser"
        case root = "Root"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AcceptInvitationRequest: AWSEncodableShape {
        public let administratorAccountId: String?
        public let invitationId: String
        public let masterAccount: String?

        public init(administratorAccountId: String? = nil, invitationId: String, masterAccount: String? = nil) {
            self.administratorAccountId = administratorAccountId
            self.invitationId = invitationId
            self.masterAccount = masterAccount
        }

        private enum CodingKeys: String, CodingKey {
            case administratorAccountId
            case invitationId
            case masterAccount
        }
    }

    public struct AcceptInvitationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AccessControlList: AWSDecodableShape {
        public let allowsPublicReadAccess: Bool?
        public let allowsPublicWriteAccess: Bool?

        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess
            case allowsPublicWriteAccess
        }
    }

    public struct AccountDetail: AWSEncodableShape {
        public let accountId: String
        public let email: String

        public init(accountId: String, email: String) {
            self.accountId = accountId
            self.email = email
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case email
        }
    }

    public struct AccountLevelPermissions: AWSDecodableShape {
        public let blockPublicAccess: BlockPublicAccess?

        public init(blockPublicAccess: BlockPublicAccess? = nil) {
            self.blockPublicAccess = blockPublicAccess
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAccess
        }
    }

    public struct AdminAccount: AWSDecodableShape {
        public let accountId: String?
        public let status: AdminStatus?

        public init(accountId: String? = nil, status: AdminStatus? = nil) {
            self.accountId = accountId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case status
        }
    }

    public struct ApiCallDetails: AWSDecodableShape {
        public let api: String?
        public let apiServiceName: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var firstSeen: Date?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastSeen: Date?

        public init(api: String? = nil, apiServiceName: String? = nil, firstSeen: Date? = nil, lastSeen: Date? = nil) {
            self.api = api
            self.apiServiceName = apiServiceName
            self.firstSeen = firstSeen
            self.lastSeen = lastSeen
        }

        private enum CodingKeys: String, CodingKey {
            case api
            case apiServiceName
            case firstSeen
            case lastSeen
        }
    }

    public struct AssumedRole: AWSDecodableShape {
        public let accessKeyId: String?
        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let sessionContext: SessionContext?

        public init(accessKeyId: String? = nil, accountId: String? = nil, arn: String? = nil, principalId: String? = nil, sessionContext: SessionContext? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.sessionContext = sessionContext
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId
            case accountId
            case arn
            case principalId
            case sessionContext
        }
    }

    public struct AwsAccount: AWSDecodableShape {
        public let accountId: String?
        public let principalId: String?

        public init(accountId: String? = nil, principalId: String? = nil) {
            self.accountId = accountId
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case principalId
        }
    }

    public struct AwsService: AWSDecodableShape {
        public let invokedBy: String?

        public init(invokedBy: String? = nil) {
            self.invokedBy = invokedBy
        }

        private enum CodingKeys: String, CodingKey {
            case invokedBy
        }
    }

    public struct BatchGetCustomDataIdentifierSummary: AWSDecodableShape {
        public let arn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let deleted: Bool?
        public let description: String?
        public let id: String?
        public let name: String?

        public init(arn: String? = nil, createdAt: Date? = nil, deleted: Bool? = nil, description: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deleted = deleted
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case deleted
            case description
            case id
            case name
        }
    }

    public struct BatchGetCustomDataIdentifiersRequest: AWSEncodableShape {
        public let ids: [String]?

        public init(ids: [String]? = nil) {
            self.ids = ids
        }

        private enum CodingKeys: String, CodingKey {
            case ids
        }
    }

    public struct BatchGetCustomDataIdentifiersResponse: AWSDecodableShape {
        public let customDataIdentifiers: [BatchGetCustomDataIdentifierSummary]?
        public let notFoundIdentifierIds: [String]?

        public init(customDataIdentifiers: [BatchGetCustomDataIdentifierSummary]? = nil, notFoundIdentifierIds: [String]? = nil) {
            self.customDataIdentifiers = customDataIdentifiers
            self.notFoundIdentifierIds = notFoundIdentifierIds
        }

        private enum CodingKeys: String, CodingKey {
            case customDataIdentifiers
            case notFoundIdentifierIds
        }
    }

    public struct BlockPublicAccess: AWSDecodableShape {
        public let blockPublicAcls: Bool?
        public let blockPublicPolicy: Bool?
        public let ignorePublicAcls: Bool?
        public let restrictPublicBuckets: Bool?

        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls
            case blockPublicPolicy
            case ignorePublicAcls
            case restrictPublicBuckets
        }
    }

    public struct BucketCountByEffectivePermission: AWSDecodableShape {
        public let publiclyAccessible: Int64?
        public let publiclyReadable: Int64?
        public let publiclyWritable: Int64?
        public let unknown: Int64?

        public init(publiclyAccessible: Int64? = nil, publiclyReadable: Int64? = nil, publiclyWritable: Int64? = nil, unknown: Int64? = nil) {
            self.publiclyAccessible = publiclyAccessible
            self.publiclyReadable = publiclyReadable
            self.publiclyWritable = publiclyWritable
            self.unknown = unknown
        }

        private enum CodingKeys: String, CodingKey {
            case publiclyAccessible
            case publiclyReadable
            case publiclyWritable
            case unknown
        }
    }

    public struct BucketCountByEncryptionType: AWSDecodableShape {
        public let kmsManaged: Int64?
        public let s3Managed: Int64?
        public let unencrypted: Int64?
        public let unknown: Int64?

        public init(kmsManaged: Int64? = nil, s3Managed: Int64? = nil, unencrypted: Int64? = nil, unknown: Int64? = nil) {
            self.kmsManaged = kmsManaged
            self.s3Managed = s3Managed
            self.unencrypted = unencrypted
            self.unknown = unknown
        }

        private enum CodingKeys: String, CodingKey {
            case kmsManaged
            case s3Managed
            case unencrypted
            case unknown
        }
    }

    public struct BucketCountBySharedAccessType: AWSDecodableShape {
        public let external: Int64?
        public let `internal`: Int64?
        public let notShared: Int64?
        public let unknown: Int64?

        public init(external: Int64? = nil, internal: Int64? = nil, notShared: Int64? = nil, unknown: Int64? = nil) {
            self.external = external
            self.`internal` = `internal`
            self.notShared = notShared
            self.unknown = unknown
        }

        private enum CodingKeys: String, CodingKey {
            case external
            case `internal`
            case notShared
            case unknown
        }
    }

    public struct BucketCountPolicyAllowsUnencryptedObjectUploads: AWSDecodableShape {
        public let allowsUnencryptedObjectUploads: Int64?
        public let deniesUnencryptedObjectUploads: Int64?
        public let unknown: Int64?

        public init(allowsUnencryptedObjectUploads: Int64? = nil, deniesUnencryptedObjectUploads: Int64? = nil, unknown: Int64? = nil) {
            self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
            self.deniesUnencryptedObjectUploads = deniesUnencryptedObjectUploads
            self.unknown = unknown
        }

        private enum CodingKeys: String, CodingKey {
            case allowsUnencryptedObjectUploads
            case deniesUnencryptedObjectUploads
            case unknown
        }
    }

    public struct BucketCriteriaAdditionalProperties: AWSEncodableShape {
        public let eq: [String]?
        public let gt: Int64?
        public let gte: Int64?
        public let lt: Int64?
        public let lte: Int64?
        public let neq: [String]?
        public let prefix: String?

        public init(eq: [String]? = nil, gt: Int64? = nil, gte: Int64? = nil, lt: Int64? = nil, lte: Int64? = nil, neq: [String]? = nil, prefix: String? = nil) {
            self.eq = eq
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.prefix = prefix
        }

        private enum CodingKeys: String, CodingKey {
            case eq
            case gt
            case gte
            case lt
            case lte
            case neq
            case prefix
        }
    }

    public struct BucketLevelPermissions: AWSDecodableShape {
        public let accessControlList: AccessControlList?
        public let blockPublicAccess: BlockPublicAccess?
        public let bucketPolicy: BucketPolicy?

        public init(accessControlList: AccessControlList? = nil, blockPublicAccess: BlockPublicAccess? = nil, bucketPolicy: BucketPolicy? = nil) {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList
            case blockPublicAccess
            case bucketPolicy
        }
    }

    public struct BucketMetadata: AWSDecodableShape {
        public let accountId: String?
        public let allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads?
        public let bucketArn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var bucketCreatedAt: Date?
        public let bucketName: String?
        public let classifiableObjectCount: Int64?
        public let classifiableSizeInBytes: Int64?
        public let jobDetails: JobDetails?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        public let objectCount: Int64?
        public let objectCountByEncryptionType: ObjectCountByEncryptionType?
        public let publicAccess: BucketPublicAccess?
        public let region: String?
        public let replicationDetails: ReplicationDetails?
        public let serverSideEncryption: BucketServerSideEncryption?
        public let sharedAccess: SharedAccess?
        public let sizeInBytes: Int64?
        public let sizeInBytesCompressed: Int64?
        public let tags: [KeyValuePair]?
        public let unclassifiableObjectCount: ObjectLevelStatistics?
        public let unclassifiableObjectSizeInBytes: ObjectLevelStatistics?
        public let versioning: Bool?

        public init(accountId: String? = nil, allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads? = nil, bucketArn: String? = nil, bucketCreatedAt: Date? = nil, bucketName: String? = nil, classifiableObjectCount: Int64? = nil, classifiableSizeInBytes: Int64? = nil, jobDetails: JobDetails? = nil, lastUpdated: Date? = nil, objectCount: Int64? = nil, objectCountByEncryptionType: ObjectCountByEncryptionType? = nil, publicAccess: BucketPublicAccess? = nil, region: String? = nil, replicationDetails: ReplicationDetails? = nil, serverSideEncryption: BucketServerSideEncryption? = nil, sharedAccess: SharedAccess? = nil, sizeInBytes: Int64? = nil, sizeInBytesCompressed: Int64? = nil, tags: [KeyValuePair]? = nil, unclassifiableObjectCount: ObjectLevelStatistics? = nil, unclassifiableObjectSizeInBytes: ObjectLevelStatistics? = nil, versioning: Bool? = nil) {
            self.accountId = accountId
            self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
            self.bucketArn = bucketArn
            self.bucketCreatedAt = bucketCreatedAt
            self.bucketName = bucketName
            self.classifiableObjectCount = classifiableObjectCount
            self.classifiableSizeInBytes = classifiableSizeInBytes
            self.jobDetails = jobDetails
            self.lastUpdated = lastUpdated
            self.objectCount = objectCount
            self.objectCountByEncryptionType = objectCountByEncryptionType
            self.publicAccess = publicAccess
            self.region = region
            self.replicationDetails = replicationDetails
            self.serverSideEncryption = serverSideEncryption
            self.sharedAccess = sharedAccess
            self.sizeInBytes = sizeInBytes
            self.sizeInBytesCompressed = sizeInBytesCompressed
            self.tags = tags
            self.unclassifiableObjectCount = unclassifiableObjectCount
            self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
            self.versioning = versioning
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case allowsUnencryptedObjectUploads
            case bucketArn
            case bucketCreatedAt
            case bucketName
            case classifiableObjectCount
            case classifiableSizeInBytes
            case jobDetails
            case lastUpdated
            case objectCount
            case objectCountByEncryptionType
            case publicAccess
            case region
            case replicationDetails
            case serverSideEncryption
            case sharedAccess
            case sizeInBytes
            case sizeInBytesCompressed
            case tags
            case unclassifiableObjectCount
            case unclassifiableObjectSizeInBytes
            case versioning
        }
    }

    public struct BucketPermissionConfiguration: AWSDecodableShape {
        public let accountLevelPermissions: AccountLevelPermissions?
        public let bucketLevelPermissions: BucketLevelPermissions?

        public init(accountLevelPermissions: AccountLevelPermissions? = nil, bucketLevelPermissions: BucketLevelPermissions? = nil) {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }

        private enum CodingKeys: String, CodingKey {
            case accountLevelPermissions
            case bucketLevelPermissions
        }
    }

    public struct BucketPolicy: AWSDecodableShape {
        public let allowsPublicReadAccess: Bool?
        public let allowsPublicWriteAccess: Bool?

        public init(allowsPublicReadAccess: Bool? = nil, allowsPublicWriteAccess: Bool? = nil) {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }

        private enum CodingKeys: String, CodingKey {
            case allowsPublicReadAccess
            case allowsPublicWriteAccess
        }
    }

    public struct BucketPublicAccess: AWSDecodableShape {
        public let effectivePermission: EffectivePermission?
        public let permissionConfiguration: BucketPermissionConfiguration?

        public init(effectivePermission: EffectivePermission? = nil, permissionConfiguration: BucketPermissionConfiguration? = nil) {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case effectivePermission
            case permissionConfiguration
        }
    }

    public struct BucketServerSideEncryption: AWSDecodableShape {
        public let kmsMasterKeyId: String?
        public let type: `Type`?

        public init(kmsMasterKeyId: String? = nil, type: `Type`? = nil) {
            self.kmsMasterKeyId = kmsMasterKeyId
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case kmsMasterKeyId
            case type
        }
    }

    public struct BucketSortCriteria: AWSEncodableShape {
        public let attributeName: String?
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case orderBy
        }
    }

    public struct Cell: AWSDecodableShape {
        public let cellReference: String?
        public let column: Int64?
        public let columnName: String?
        public let row: Int64?

        public init(cellReference: String? = nil, column: Int64? = nil, columnName: String? = nil, row: Int64? = nil) {
            self.cellReference = cellReference
            self.column = column
            self.columnName = columnName
            self.row = row
        }

        private enum CodingKeys: String, CodingKey {
            case cellReference
            case column
            case columnName
            case row
        }
    }

    public struct ClassificationDetails: AWSDecodableShape {
        public let detailedResultsLocation: String?
        public let jobArn: String?
        public let jobId: String?
        public let result: ClassificationResult?

        public init(detailedResultsLocation: String? = nil, jobArn: String? = nil, jobId: String? = nil, result: ClassificationResult? = nil) {
            self.detailedResultsLocation = detailedResultsLocation
            self.jobArn = jobArn
            self.jobId = jobId
            self.result = result
        }

        private enum CodingKeys: String, CodingKey {
            case detailedResultsLocation
            case jobArn
            case jobId
            case result
        }
    }

    public struct ClassificationExportConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let s3Destination: S3Destination?

        public init(s3Destination: S3Destination? = nil) {
            self.s3Destination = s3Destination
        }

        private enum CodingKeys: String, CodingKey {
            case s3Destination
        }
    }

    public struct ClassificationResult: AWSDecodableShape {
        public let additionalOccurrences: Bool?
        public let customDataIdentifiers: CustomDataIdentifiers?
        public let mimeType: String?
        public let sensitiveData: [SensitiveDataItem]?
        public let sizeClassified: Int64?
        public let status: ClassificationResultStatus?

        public init(additionalOccurrences: Bool? = nil, customDataIdentifiers: CustomDataIdentifiers? = nil, mimeType: String? = nil, sensitiveData: [SensitiveDataItem]? = nil, sizeClassified: Int64? = nil, status: ClassificationResultStatus? = nil) {
            self.additionalOccurrences = additionalOccurrences
            self.customDataIdentifiers = customDataIdentifiers
            self.mimeType = mimeType
            self.sensitiveData = sensitiveData
            self.sizeClassified = sizeClassified
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case additionalOccurrences
            case customDataIdentifiers
            case mimeType
            case sensitiveData
            case sizeClassified
            case status
        }
    }

    public struct ClassificationResultStatus: AWSDecodableShape {
        public let code: String?
        public let reason: String?

        public init(code: String? = nil, reason: String? = nil) {
            self.code = code
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case reason
        }
    }

    public struct CreateClassificationJobRequest: AWSEncodableShape {
        public let clientToken: String
        public let customDataIdentifierIds: [String]?
        public let description: String?
        public let initialRun: Bool?
        public let jobType: JobType
        public let name: String
        public let s3JobDefinition: S3JobDefinition
        public let samplingPercentage: Int?
        public let scheduleFrequency: JobScheduleFrequency?
        public let tags: [String: String]?

        public init(clientToken: String = CreateClassificationJobRequest.idempotencyToken(), customDataIdentifierIds: [String]? = nil, description: String? = nil, initialRun: Bool? = nil, jobType: JobType, name: String, s3JobDefinition: S3JobDefinition, samplingPercentage: Int? = nil, scheduleFrequency: JobScheduleFrequency? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.customDataIdentifierIds = customDataIdentifierIds
            self.description = description
            self.initialRun = initialRun
            self.jobType = jobType
            self.name = name
            self.s3JobDefinition = s3JobDefinition
            self.samplingPercentage = samplingPercentage
            self.scheduleFrequency = scheduleFrequency
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case customDataIdentifierIds
            case description
            case initialRun
            case jobType
            case name
            case s3JobDefinition
            case samplingPercentage
            case scheduleFrequency
            case tags
        }
    }

    public struct CreateClassificationJobResponse: AWSDecodableShape {
        public let jobArn: String?
        public let jobId: String?

        public init(jobArn: String? = nil, jobId: String? = nil) {
            self.jobArn = jobArn
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobArn
            case jobId
        }
    }

    public struct CreateCustomDataIdentifierRequest: AWSEncodableShape {
        public let clientToken: String?
        public let description: String?
        public let ignoreWords: [String]?
        public let keywords: [String]?
        public let maximumMatchDistance: Int?
        public let name: String?
        public let regex: String?
        public let tags: [String: String]?

        public init(clientToken: String? = CreateCustomDataIdentifierRequest.idempotencyToken(), description: String? = nil, ignoreWords: [String]? = nil, keywords: [String]? = nil, maximumMatchDistance: Int? = nil, name: String? = nil, regex: String? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.ignoreWords = ignoreWords
            self.keywords = keywords
            self.maximumMatchDistance = maximumMatchDistance
            self.name = name
            self.regex = regex
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case description
            case ignoreWords
            case keywords
            case maximumMatchDistance
            case name
            case regex
            case tags
        }
    }

    public struct CreateCustomDataIdentifierResponse: AWSDecodableShape {
        public let customDataIdentifierId: String?

        public init(customDataIdentifierId: String? = nil) {
            self.customDataIdentifierId = customDataIdentifierId
        }

        private enum CodingKeys: String, CodingKey {
            case customDataIdentifierId
        }
    }

    public struct CreateFindingsFilterRequest: AWSEncodableShape {
        public let action: FindingsFilterAction
        public let clientToken: String?
        public let description: String?
        public let findingCriteria: FindingCriteria
        public let name: String
        public let position: Int?
        public let tags: [String: String]?

        public init(action: FindingsFilterAction, clientToken: String? = CreateFindingsFilterRequest.idempotencyToken(), description: String? = nil, findingCriteria: FindingCriteria, name: String, position: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.description = description
            self.findingCriteria = findingCriteria
            self.name = name
            self.position = position
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case clientToken
            case description
            case findingCriteria
            case name
            case position
            case tags
        }
    }

    public struct CreateFindingsFilterResponse: AWSDecodableShape {
        public let arn: String?
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case id
        }
    }

    public struct CreateInvitationsRequest: AWSEncodableShape {
        public let accountIds: [String]
        public let disableEmailNotification: Bool?
        public let message: String?

        public init(accountIds: [String], disableEmailNotification: Bool? = nil, message: String? = nil) {
            self.accountIds = accountIds
            self.disableEmailNotification = disableEmailNotification
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
            case disableEmailNotification
            case message
        }
    }

    public struct CreateInvitationsResponse: AWSDecodableShape {
        public let unprocessedAccounts: [UnprocessedAccount]?

        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct CreateMemberRequest: AWSEncodableShape {
        public let account: AccountDetail
        public let tags: [String: String]?

        public init(account: AccountDetail, tags: [String: String]? = nil) {
            self.account = account
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case account
            case tags
        }
    }

    public struct CreateMemberResponse: AWSDecodableShape {
        public let arn: String?

        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn
        }
    }

    public struct CreateSampleFindingsRequest: AWSEncodableShape {
        public let findingTypes: [FindingType]?

        public init(findingTypes: [FindingType]? = nil) {
            self.findingTypes = findingTypes
        }

        private enum CodingKeys: String, CodingKey {
            case findingTypes
        }
    }

    public struct CreateSampleFindingsResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CriteriaBlockForJob: AWSEncodableShape & AWSDecodableShape {
        public let and: [CriteriaForJob]?

        public init(and: [CriteriaForJob]? = nil) {
            self.and = and
        }

        private enum CodingKeys: String, CodingKey {
            case and
        }
    }

    public struct CriteriaForJob: AWSEncodableShape & AWSDecodableShape {
        public let simpleCriterion: SimpleCriterionForJob?
        public let tagCriterion: TagCriterionForJob?

        public init(simpleCriterion: SimpleCriterionForJob? = nil, tagCriterion: TagCriterionForJob? = nil) {
            self.simpleCriterion = simpleCriterion
            self.tagCriterion = tagCriterion
        }

        private enum CodingKeys: String, CodingKey {
            case simpleCriterion
            case tagCriterion
        }
    }

    public struct CriterionAdditionalProperties: AWSEncodableShape & AWSDecodableShape {
        public let eq: [String]?
        public let eqExactMatch: [String]?
        public let gt: Int64?
        public let gte: Int64?
        public let lt: Int64?
        public let lte: Int64?
        public let neq: [String]?

        public init(eq: [String]? = nil, eqExactMatch: [String]? = nil, gt: Int64? = nil, gte: Int64? = nil, lt: Int64? = nil, lte: Int64? = nil, neq: [String]? = nil) {
            self.eq = eq
            self.eqExactMatch = eqExactMatch
            self.gt = gt
            self.gte = gte
            self.lt = lt
            self.lte = lte
            self.neq = neq
        }

        private enum CodingKeys: String, CodingKey {
            case eq
            case eqExactMatch
            case gt
            case gte
            case lt
            case lte
            case neq
        }
    }

    public struct CustomDataIdentifierSummary: AWSDecodableShape {
        public let arn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let description: String?
        public let id: String?
        public let name: String?

        public init(arn: String? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case description
            case id
            case name
        }
    }

    public struct CustomDataIdentifiers: AWSDecodableShape {
        public let detections: [CustomDetection]?
        public let totalCount: Int64?

        public init(detections: [CustomDetection]? = nil, totalCount: Int64? = nil) {
            self.detections = detections
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case detections
            case totalCount
        }
    }

    public struct CustomDetection: AWSDecodableShape {
        public let arn: String?
        public let count: Int64?
        public let name: String?
        public let occurrences: Occurrences?

        public init(arn: String? = nil, count: Int64? = nil, name: String? = nil, occurrences: Occurrences? = nil) {
            self.arn = arn
            self.count = count
            self.name = name
            self.occurrences = occurrences
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case count
            case name
            case occurrences
        }
    }

    public struct DailySchedule: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct DeclineInvitationsRequest: AWSEncodableShape {
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct DeclineInvitationsResponse: AWSDecodableShape {
        public let unprocessedAccounts: [UnprocessedAccount]?

        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct DefaultDetection: AWSDecodableShape {
        public let count: Int64?
        public let occurrences: Occurrences?
        public let type: String?

        public init(count: Int64? = nil, occurrences: Occurrences? = nil, type: String? = nil) {
            self.count = count
            self.occurrences = occurrences
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case occurrences
            case type
        }
    }

    public struct DeleteCustomDataIdentifierRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteCustomDataIdentifierResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteFindingsFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteFindingsFilterResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteInvitationsRequest: AWSEncodableShape {
        public let accountIds: [String]

        public init(accountIds: [String]) {
            self.accountIds = accountIds
        }

        private enum CodingKeys: String, CodingKey {
            case accountIds
        }
    }

    public struct DeleteInvitationsResponse: AWSDecodableShape {
        public let unprocessedAccounts: [UnprocessedAccount]?

        public init(unprocessedAccounts: [UnprocessedAccount]? = nil) {
            self.unprocessedAccounts = unprocessedAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case unprocessedAccounts
        }
    }

    public struct DeleteMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeBucketsRequest: AWSEncodableShape {
        public let criteria: [String: BucketCriteriaAdditionalProperties]?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortCriteria: BucketSortCriteria?

        public init(criteria: [String: BucketCriteriaAdditionalProperties]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: BucketSortCriteria? = nil) {
            self.criteria = criteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case criteria
            case maxResults
            case nextToken
            case sortCriteria
        }
    }

    public struct DescribeBucketsResponse: AWSDecodableShape {
        public let buckets: [BucketMetadata]?
        public let nextToken: String?

        public init(buckets: [BucketMetadata]? = nil, nextToken: String? = nil) {
            self.buckets = buckets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case buckets
            case nextToken
        }
    }

    public struct DescribeClassificationJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        public let jobId: String

        public init(jobId: String) {
            self.jobId = jobId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeClassificationJobResponse: AWSDecodableShape {
        public let clientToken: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let customDataIdentifierIds: [String]?
        public let description: String?
        public let initialRun: Bool?
        public let jobArn: String?
        public let jobId: String?
        public let jobStatus: JobStatus?
        public let jobType: JobType?
        public let lastRunErrorStatus: LastRunErrorStatus?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastRunTime: Date?
        public let name: String?
        public let s3JobDefinition: S3JobDefinition?
        public let samplingPercentage: Int?
        public let scheduleFrequency: JobScheduleFrequency?
        public let statistics: Statistics?
        public let tags: [String: String]?
        public let userPausedDetails: UserPausedDetails?

        public init(clientToken: String? = DescribeClassificationJobResponse.idempotencyToken(), createdAt: Date? = nil, customDataIdentifierIds: [String]? = nil, description: String? = nil, initialRun: Bool? = nil, jobArn: String? = nil, jobId: String? = nil, jobStatus: JobStatus? = nil, jobType: JobType? = nil, lastRunErrorStatus: LastRunErrorStatus? = nil, lastRunTime: Date? = nil, name: String? = nil, s3JobDefinition: S3JobDefinition? = nil, samplingPercentage: Int? = nil, scheduleFrequency: JobScheduleFrequency? = nil, statistics: Statistics? = nil, tags: [String: String]? = nil, userPausedDetails: UserPausedDetails? = nil) {
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customDataIdentifierIds = customDataIdentifierIds
            self.description = description
            self.initialRun = initialRun
            self.jobArn = jobArn
            self.jobId = jobId
            self.jobStatus = jobStatus
            self.jobType = jobType
            self.lastRunErrorStatus = lastRunErrorStatus
            self.lastRunTime = lastRunTime
            self.name = name
            self.s3JobDefinition = s3JobDefinition
            self.samplingPercentage = samplingPercentage
            self.scheduleFrequency = scheduleFrequency
            self.statistics = statistics
            self.tags = tags
            self.userPausedDetails = userPausedDetails
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case createdAt
            case customDataIdentifierIds
            case description
            case initialRun
            case jobArn
            case jobId
            case jobStatus
            case jobType
            case lastRunErrorStatus
            case lastRunTime
            case name
            case s3JobDefinition
            case samplingPercentage
            case scheduleFrequency
            case statistics
            case tags
            case userPausedDetails
        }
    }

    public struct DescribeOrganizationConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DescribeOrganizationConfigurationResponse: AWSDecodableShape {
        public let autoEnable: Bool?
        public let maxAccountLimitReached: Bool?

        public init(autoEnable: Bool? = nil, maxAccountLimitReached: Bool? = nil) {
            self.autoEnable = autoEnable
            self.maxAccountLimitReached = maxAccountLimitReached
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
            case maxAccountLimitReached
        }
    }

    public struct DisableMacieRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisableMacieResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisableOrganizationAdminAccountRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "adminAccountId", location: .querystring(locationName: "adminAccountId"))
        ]

        public let adminAccountId: String

        public init(adminAccountId: String) {
            self.adminAccountId = adminAccountId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisassociateFromAdministratorAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct DisassociateFromMasterAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateMemberResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DomainDetails: AWSDecodableShape {
        public let domainName: String?

        public init(domainName: String? = nil) {
            self.domainName = domainName
        }

        private enum CodingKeys: String, CodingKey {
            case domainName
        }
    }

    public struct EnableMacieRequest: AWSEncodableShape {
        public let clientToken: String?
        public let findingPublishingFrequency: FindingPublishingFrequency?
        public let status: MacieStatus?

        public init(clientToken: String? = EnableMacieRequest.idempotencyToken(), findingPublishingFrequency: FindingPublishingFrequency? = nil, status: MacieStatus? = nil) {
            self.clientToken = clientToken
            self.findingPublishingFrequency = findingPublishingFrequency
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case findingPublishingFrequency
            case status
        }
    }

    public struct EnableMacieResponse: AWSDecodableShape {
        public init() {}
    }

    public struct EnableOrganizationAdminAccountRequest: AWSEncodableShape {
        public let adminAccountId: String
        public let clientToken: String?

        public init(adminAccountId: String, clientToken: String? = EnableOrganizationAdminAccountRequest.idempotencyToken()) {
            self.adminAccountId = adminAccountId
            self.clientToken = clientToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccountId
            case clientToken
        }
    }

    public struct EnableOrganizationAdminAccountResponse: AWSDecodableShape {
        public init() {}
    }

    public struct FederatedUser: AWSDecodableShape {
        public let accessKeyId: String?
        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let sessionContext: SessionContext?

        public init(accessKeyId: String? = nil, accountId: String? = nil, arn: String? = nil, principalId: String? = nil, sessionContext: SessionContext? = nil) {
            self.accessKeyId = accessKeyId
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.sessionContext = sessionContext
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId
            case accountId
            case arn
            case principalId
            case sessionContext
        }
    }

    public struct Finding: AWSDecodableShape {
        public let accountId: String?
        public let archived: Bool?
        public let category: FindingCategory?
        public let classificationDetails: ClassificationDetails?
        public let count: Int64?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let description: String?
        public let id: String?
        public let partition: String?
        public let policyDetails: PolicyDetails?
        public let region: String?
        public let resourcesAffected: ResourcesAffected?
        public let sample: Bool?
        public let schemaVersion: String?
        public let severity: Severity?
        public let title: String?
        public let type: FindingType?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(accountId: String? = nil, archived: Bool? = nil, category: FindingCategory? = nil, classificationDetails: ClassificationDetails? = nil, count: Int64? = nil, createdAt: Date? = nil, description: String? = nil, id: String? = nil, partition: String? = nil, policyDetails: PolicyDetails? = nil, region: String? = nil, resourcesAffected: ResourcesAffected? = nil, sample: Bool? = nil, schemaVersion: String? = nil, severity: Severity? = nil, title: String? = nil, type: FindingType? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.archived = archived
            self.category = category
            self.classificationDetails = classificationDetails
            self.count = count
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.policyDetails = policyDetails
            self.region = region
            self.resourcesAffected = resourcesAffected
            self.sample = sample
            self.schemaVersion = schemaVersion
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case archived
            case category
            case classificationDetails
            case count
            case createdAt
            case description
            case id
            case partition
            case policyDetails
            case region
            case resourcesAffected
            case sample
            case schemaVersion
            case severity
            case title
            case type
            case updatedAt
        }
    }

    public struct FindingAction: AWSDecodableShape {
        public let actionType: FindingActionType?
        public let apiCallDetails: ApiCallDetails?

        public init(actionType: FindingActionType? = nil, apiCallDetails: ApiCallDetails? = nil) {
            self.actionType = actionType
            self.apiCallDetails = apiCallDetails
        }

        private enum CodingKeys: String, CodingKey {
            case actionType
            case apiCallDetails
        }
    }

    public struct FindingActor: AWSDecodableShape {
        public let domainDetails: DomainDetails?
        public let ipAddressDetails: IpAddressDetails?
        public let userIdentity: UserIdentity?

        public init(domainDetails: DomainDetails? = nil, ipAddressDetails: IpAddressDetails? = nil, userIdentity: UserIdentity? = nil) {
            self.domainDetails = domainDetails
            self.ipAddressDetails = ipAddressDetails
            self.userIdentity = userIdentity
        }

        private enum CodingKeys: String, CodingKey {
            case domainDetails
            case ipAddressDetails
            case userIdentity
        }
    }

    public struct FindingCriteria: AWSEncodableShape & AWSDecodableShape {
        public let criterion: [String: CriterionAdditionalProperties]?

        public init(criterion: [String: CriterionAdditionalProperties]? = nil) {
            self.criterion = criterion
        }

        private enum CodingKeys: String, CodingKey {
            case criterion
        }
    }

    public struct FindingStatisticsSortCriteria: AWSEncodableShape {
        public let attributeName: FindingStatisticsSortAttributeName?
        public let orderBy: OrderBy?

        public init(attributeName: FindingStatisticsSortAttributeName? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case orderBy
        }
    }

    public struct FindingsFilterListItem: AWSDecodableShape {
        public let action: FindingsFilterAction?
        public let arn: String?
        public let id: String?
        public let name: String?
        public let tags: [String: String]?

        public init(action: FindingsFilterAction? = nil, arn: String? = nil, id: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.arn = arn
            self.id = id
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case arn
            case id
            case name
            case tags
        }
    }

    public struct GetAdministratorAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetAdministratorAccountResponse: AWSDecodableShape {
        public let administrator: Invitation?

        public init(administrator: Invitation? = nil) {
            self.administrator = administrator
        }

        private enum CodingKeys: String, CodingKey {
            case administrator
        }
    }

    public struct GetBucketStatisticsRequest: AWSEncodableShape {
        public let accountId: String?

        public init(accountId: String? = nil) {
            self.accountId = accountId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
        }
    }

    public struct GetBucketStatisticsResponse: AWSDecodableShape {
        public let bucketCount: Int64?
        public let bucketCountByEffectivePermission: BucketCountByEffectivePermission?
        public let bucketCountByEncryptionType: BucketCountByEncryptionType?
        public let bucketCountByObjectEncryptionRequirement: BucketCountPolicyAllowsUnencryptedObjectUploads?
        public let bucketCountBySharedAccessType: BucketCountBySharedAccessType?
        public let classifiableObjectCount: Int64?
        public let classifiableSizeInBytes: Int64?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        public let objectCount: Int64?
        public let sizeInBytes: Int64?
        public let sizeInBytesCompressed: Int64?
        public let unclassifiableObjectCount: ObjectLevelStatistics?
        public let unclassifiableObjectSizeInBytes: ObjectLevelStatistics?

        public init(bucketCount: Int64? = nil, bucketCountByEffectivePermission: BucketCountByEffectivePermission? = nil, bucketCountByEncryptionType: BucketCountByEncryptionType? = nil, bucketCountByObjectEncryptionRequirement: BucketCountPolicyAllowsUnencryptedObjectUploads? = nil, bucketCountBySharedAccessType: BucketCountBySharedAccessType? = nil, classifiableObjectCount: Int64? = nil, classifiableSizeInBytes: Int64? = nil, lastUpdated: Date? = nil, objectCount: Int64? = nil, sizeInBytes: Int64? = nil, sizeInBytesCompressed: Int64? = nil, unclassifiableObjectCount: ObjectLevelStatistics? = nil, unclassifiableObjectSizeInBytes: ObjectLevelStatistics? = nil) {
            self.bucketCount = bucketCount
            self.bucketCountByEffectivePermission = bucketCountByEffectivePermission
            self.bucketCountByEncryptionType = bucketCountByEncryptionType
            self.bucketCountByObjectEncryptionRequirement = bucketCountByObjectEncryptionRequirement
            self.bucketCountBySharedAccessType = bucketCountBySharedAccessType
            self.classifiableObjectCount = classifiableObjectCount
            self.classifiableSizeInBytes = classifiableSizeInBytes
            self.lastUpdated = lastUpdated
            self.objectCount = objectCount
            self.sizeInBytes = sizeInBytes
            self.sizeInBytesCompressed = sizeInBytesCompressed
            self.unclassifiableObjectCount = unclassifiableObjectCount
            self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case bucketCount
            case bucketCountByEffectivePermission
            case bucketCountByEncryptionType
            case bucketCountByObjectEncryptionRequirement
            case bucketCountBySharedAccessType
            case classifiableObjectCount
            case classifiableSizeInBytes
            case lastUpdated
            case objectCount
            case sizeInBytes
            case sizeInBytesCompressed
            case unclassifiableObjectCount
            case unclassifiableObjectSizeInBytes
        }
    }

    public struct GetClassificationExportConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetClassificationExportConfigurationResponse: AWSDecodableShape {
        public let configuration: ClassificationExportConfiguration?

        public init(configuration: ClassificationExportConfiguration? = nil) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
        }
    }

    public struct GetCustomDataIdentifierRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetCustomDataIdentifierResponse: AWSDecodableShape {
        public let arn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let deleted: Bool?
        public let description: String?
        public let id: String?
        public let ignoreWords: [String]?
        public let keywords: [String]?
        public let maximumMatchDistance: Int?
        public let name: String?
        public let regex: String?
        public let tags: [String: String]?

        public init(arn: String? = nil, createdAt: Date? = nil, deleted: Bool? = nil, description: String? = nil, id: String? = nil, ignoreWords: [String]? = nil, keywords: [String]? = nil, maximumMatchDistance: Int? = nil, name: String? = nil, regex: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.deleted = deleted
            self.description = description
            self.id = id
            self.ignoreWords = ignoreWords
            self.keywords = keywords
            self.maximumMatchDistance = maximumMatchDistance
            self.name = name
            self.regex = regex
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case createdAt
            case deleted
            case description
            case id
            case ignoreWords
            case keywords
            case maximumMatchDistance
            case name
            case regex
            case tags
        }
    }

    public struct GetFindingStatisticsRequest: AWSEncodableShape {
        public let findingCriteria: FindingCriteria?
        public let groupBy: GroupBy
        public let size: Int?
        public let sortCriteria: FindingStatisticsSortCriteria?

        public init(findingCriteria: FindingCriteria? = nil, groupBy: GroupBy, size: Int? = nil, sortCriteria: FindingStatisticsSortCriteria? = nil) {
            self.findingCriteria = findingCriteria
            self.groupBy = groupBy
            self.size = size
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria
            case groupBy
            case size
            case sortCriteria
        }
    }

    public struct GetFindingStatisticsResponse: AWSDecodableShape {
        public let countsByGroup: [GroupCount]?

        public init(countsByGroup: [GroupCount]? = nil) {
            self.countsByGroup = countsByGroup
        }

        private enum CodingKeys: String, CodingKey {
            case countsByGroup
        }
    }

    public struct GetFindingsFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFindingsFilterResponse: AWSDecodableShape {
        public let action: FindingsFilterAction?
        public let arn: String?
        public let description: String?
        public let findingCriteria: FindingCriteria?
        public let id: String?
        public let name: String?
        public let position: Int?
        public let tags: [String: String]?

        public init(action: FindingsFilterAction? = nil, arn: String? = nil, description: String? = nil, findingCriteria: FindingCriteria? = nil, id: String? = nil, name: String? = nil, position: Int? = nil, tags: [String: String]? = nil) {
            self.action = action
            self.arn = arn
            self.description = description
            self.findingCriteria = findingCriteria
            self.id = id
            self.name = name
            self.position = position
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case arn
            case description
            case findingCriteria
            case id
            case name
            case position
            case tags
        }
    }

    public struct GetFindingsPublicationConfigurationRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetFindingsPublicationConfigurationResponse: AWSDecodableShape {
        public let securityHubConfiguration: SecurityHubConfiguration?

        public init(securityHubConfiguration: SecurityHubConfiguration? = nil) {
            self.securityHubConfiguration = securityHubConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case securityHubConfiguration
        }
    }

    public struct GetFindingsRequest: AWSEncodableShape {
        public let findingIds: [String]
        public let sortCriteria: SortCriteria?

        public init(findingIds: [String], sortCriteria: SortCriteria? = nil) {
            self.findingIds = findingIds
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds
            case sortCriteria
        }
    }

    public struct GetFindingsResponse: AWSDecodableShape {
        public let findings: [Finding]?

        public init(findings: [Finding]? = nil) {
            self.findings = findings
        }

        private enum CodingKeys: String, CodingKey {
            case findings
        }
    }

    public struct GetInvitationsCountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetInvitationsCountResponse: AWSDecodableShape {
        public let invitationsCount: Int64?

        public init(invitationsCount: Int64? = nil) {
            self.invitationsCount = invitationsCount
        }

        private enum CodingKeys: String, CodingKey {
            case invitationsCount
        }
    }

    public struct GetMacieSessionRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetMacieSessionResponse: AWSDecodableShape {
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let findingPublishingFrequency: FindingPublishingFrequency?
        public let serviceRole: String?
        public let status: MacieStatus?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(createdAt: Date? = nil, findingPublishingFrequency: FindingPublishingFrequency? = nil, serviceRole: String? = nil, status: MacieStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.findingPublishingFrequency = findingPublishingFrequency
            self.serviceRole = serviceRole
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt
            case findingPublishingFrequency
            case serviceRole
            case status
            case updatedAt
        }
    }

    public struct GetMasterAccountRequest: AWSEncodableShape {
        public init() {}
    }

    public struct GetMasterAccountResponse: AWSDecodableShape {
        public let master: Invitation?

        public init(master: Invitation? = nil) {
            self.master = master
        }

        private enum CodingKeys: String, CodingKey {
            case master
        }
    }

    public struct GetMemberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String

        public init(id: String) {
            self.id = id
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMemberResponse: AWSDecodableShape {
        public let accountId: String?
        public let administratorAccountId: String?
        public let arn: String?
        public let email: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var invitedAt: Date?
        public let masterAccountId: String?
        public let relationshipStatus: RelationshipStatus?
        public let tags: [String: String]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(accountId: String? = nil, administratorAccountId: String? = nil, arn: String? = nil, email: String? = nil, invitedAt: Date? = nil, masterAccountId: String? = nil, relationshipStatus: RelationshipStatus? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.administratorAccountId = administratorAccountId
            self.arn = arn
            self.email = email
            self.invitedAt = invitedAt
            self.masterAccountId = masterAccountId
            self.relationshipStatus = relationshipStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case administratorAccountId
            case arn
            case email
            case invitedAt
            case masterAccountId
            case relationshipStatus
            case tags
            case updatedAt
        }
    }

    public struct GetUsageStatisticsRequest: AWSEncodableShape {
        public let filterBy: [UsageStatisticsFilter]?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortBy: UsageStatisticsSortBy?
        public let timeRange: TimeRange?

        public init(filterBy: [UsageStatisticsFilter]? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortBy: UsageStatisticsSortBy? = nil, timeRange: TimeRange? = nil) {
            self.filterBy = filterBy
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortBy = sortBy
            self.timeRange = timeRange
        }

        private enum CodingKeys: String, CodingKey {
            case filterBy
            case maxResults
            case nextToken
            case sortBy
            case timeRange
        }
    }

    public struct GetUsageStatisticsResponse: AWSDecodableShape {
        public let nextToken: String?
        public let records: [UsageRecord]?
        public let timeRange: TimeRange?

        public init(nextToken: String? = nil, records: [UsageRecord]? = nil, timeRange: TimeRange? = nil) {
            self.nextToken = nextToken
            self.records = records
            self.timeRange = timeRange
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case records
            case timeRange
        }
    }

    public struct GetUsageTotalsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "timeRange", location: .querystring(locationName: "timeRange"))
        ]

        public let timeRange: String?

        public init(timeRange: String? = nil) {
            self.timeRange = timeRange
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUsageTotalsResponse: AWSDecodableShape {
        public let timeRange: TimeRange?
        public let usageTotals: [UsageTotal]?

        public init(timeRange: TimeRange? = nil, usageTotals: [UsageTotal]? = nil) {
            self.timeRange = timeRange
            self.usageTotals = usageTotals
        }

        private enum CodingKeys: String, CodingKey {
            case timeRange
            case usageTotals
        }
    }

    public struct GroupCount: AWSDecodableShape {
        public let count: Int64?
        public let groupKey: String?

        public init(count: Int64? = nil, groupKey: String? = nil) {
            self.count = count
            self.groupKey = groupKey
        }

        private enum CodingKeys: String, CodingKey {
            case count
            case groupKey
        }
    }

    public struct IamUser: AWSDecodableShape {
        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let userName: String?

        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil, userName: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case arn
            case principalId
            case userName
        }
    }

    public struct Invitation: AWSDecodableShape {
        public let accountId: String?
        public let invitationId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var invitedAt: Date?
        public let relationshipStatus: RelationshipStatus?

        public init(accountId: String? = nil, invitationId: String? = nil, invitedAt: Date? = nil, relationshipStatus: RelationshipStatus? = nil) {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case invitationId
            case invitedAt
            case relationshipStatus
        }
    }

    public struct IpAddressDetails: AWSDecodableShape {
        public let ipAddressV4: String?
        public let ipCity: IpCity?
        public let ipCountry: IpCountry?
        public let ipGeoLocation: IpGeoLocation?
        public let ipOwner: IpOwner?

        public init(ipAddressV4: String? = nil, ipCity: IpCity? = nil, ipCountry: IpCountry? = nil, ipGeoLocation: IpGeoLocation? = nil, ipOwner: IpOwner? = nil) {
            self.ipAddressV4 = ipAddressV4
            self.ipCity = ipCity
            self.ipCountry = ipCountry
            self.ipGeoLocation = ipGeoLocation
            self.ipOwner = ipOwner
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddressV4
            case ipCity
            case ipCountry
            case ipGeoLocation
            case ipOwner
        }
    }

    public struct IpCity: AWSDecodableShape {
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name
        }
    }

    public struct IpCountry: AWSDecodableShape {
        public let code: String?
        public let name: String?

        public init(code: String? = nil, name: String? = nil) {
            self.code = code
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code
            case name
        }
    }

    public struct IpGeoLocation: AWSDecodableShape {
        public let lat: Double?
        public let lon: Double?

        public init(lat: Double? = nil, lon: Double? = nil) {
            self.lat = lat
            self.lon = lon
        }

        private enum CodingKeys: String, CodingKey {
            case lat
            case lon
        }
    }

    public struct IpOwner: AWSDecodableShape {
        public let asn: String?
        public let asnOrg: String?
        public let isp: String?
        public let org: String?

        public init(asn: String? = nil, asnOrg: String? = nil, isp: String? = nil, org: String? = nil) {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }

        private enum CodingKeys: String, CodingKey {
            case asn
            case asnOrg
            case isp
            case org
        }
    }

    public struct JobDetails: AWSDecodableShape {
        public let isDefinedInJob: IsDefinedInJob?
        public let isMonitoredByJob: IsMonitoredByJob?
        public let lastJobId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastJobRunTime: Date?

        public init(isDefinedInJob: IsDefinedInJob? = nil, isMonitoredByJob: IsMonitoredByJob? = nil, lastJobId: String? = nil, lastJobRunTime: Date? = nil) {
            self.isDefinedInJob = isDefinedInJob
            self.isMonitoredByJob = isMonitoredByJob
            self.lastJobId = lastJobId
            self.lastJobRunTime = lastJobRunTime
        }

        private enum CodingKeys: String, CodingKey {
            case isDefinedInJob
            case isMonitoredByJob
            case lastJobId
            case lastJobRunTime
        }
    }

    public struct JobScheduleFrequency: AWSEncodableShape & AWSDecodableShape {
        public let dailySchedule: DailySchedule?
        public let monthlySchedule: MonthlySchedule?
        public let weeklySchedule: WeeklySchedule?

        public init(dailySchedule: DailySchedule? = nil, monthlySchedule: MonthlySchedule? = nil, weeklySchedule: WeeklySchedule? = nil) {
            self.dailySchedule = dailySchedule
            self.monthlySchedule = monthlySchedule
            self.weeklySchedule = weeklySchedule
        }

        private enum CodingKeys: String, CodingKey {
            case dailySchedule
            case monthlySchedule
            case weeklySchedule
        }
    }

    public struct JobScopeTerm: AWSEncodableShape & AWSDecodableShape {
        public let simpleScopeTerm: SimpleScopeTerm?
        public let tagScopeTerm: TagScopeTerm?

        public init(simpleScopeTerm: SimpleScopeTerm? = nil, tagScopeTerm: TagScopeTerm? = nil) {
            self.simpleScopeTerm = simpleScopeTerm
            self.tagScopeTerm = tagScopeTerm
        }

        private enum CodingKeys: String, CodingKey {
            case simpleScopeTerm
            case tagScopeTerm
        }
    }

    public struct JobScopingBlock: AWSEncodableShape & AWSDecodableShape {
        public let and: [JobScopeTerm]?

        public init(and: [JobScopeTerm]? = nil) {
            self.and = and
        }

        private enum CodingKeys: String, CodingKey {
            case and
        }
    }

    public struct JobSummary: AWSDecodableShape {
        public let bucketCriteria: S3BucketCriteriaForJob?
        public let bucketDefinitions: [S3BucketDefinitionForJob]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let jobId: String?
        public let jobStatus: JobStatus?
        public let jobType: JobType?
        public let lastRunErrorStatus: LastRunErrorStatus?
        public let name: String?
        public let userPausedDetails: UserPausedDetails?

        public init(bucketCriteria: S3BucketCriteriaForJob? = nil, bucketDefinitions: [S3BucketDefinitionForJob]? = nil, createdAt: Date? = nil, jobId: String? = nil, jobStatus: JobStatus? = nil, jobType: JobType? = nil, lastRunErrorStatus: LastRunErrorStatus? = nil, name: String? = nil, userPausedDetails: UserPausedDetails? = nil) {
            self.bucketCriteria = bucketCriteria
            self.bucketDefinitions = bucketDefinitions
            self.createdAt = createdAt
            self.jobId = jobId
            self.jobStatus = jobStatus
            self.jobType = jobType
            self.lastRunErrorStatus = lastRunErrorStatus
            self.name = name
            self.userPausedDetails = userPausedDetails
        }

        private enum CodingKeys: String, CodingKey {
            case bucketCriteria
            case bucketDefinitions
            case createdAt
            case jobId
            case jobStatus
            case jobType
            case lastRunErrorStatus
            case name
            case userPausedDetails
        }
    }

    public struct KeyValuePair: AWSDecodableShape {
        public let key: String?
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct LastRunErrorStatus: AWSDecodableShape {
        public let code: LastRunErrorStatusCode?

        public init(code: LastRunErrorStatusCode? = nil) {
            self.code = code
        }

        private enum CodingKeys: String, CodingKey {
            case code
        }
    }

    public struct ListClassificationJobsRequest: AWSEncodableShape {
        public let filterCriteria: ListJobsFilterCriteria?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortCriteria: ListJobsSortCriteria?

        public init(filterCriteria: ListJobsFilterCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: ListJobsSortCriteria? = nil) {
            self.filterCriteria = filterCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case filterCriteria
            case maxResults
            case nextToken
            case sortCriteria
        }
    }

    public struct ListClassificationJobsResponse: AWSDecodableShape {
        public let items: [JobSummary]?
        public let nextToken: String?

        public init(items: [JobSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListCustomDataIdentifiersRequest: AWSEncodableShape {
        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults
            case nextToken
        }
    }

    public struct ListCustomDataIdentifiersResponse: AWSDecodableShape {
        public let items: [CustomDataIdentifierSummary]?
        public let nextToken: String?

        public init(items: [CustomDataIdentifierSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items
            case nextToken
        }
    }

    public struct ListFindingsFiltersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFindingsFiltersResponse: AWSDecodableShape {
        public let findingsFilterListItems: [FindingsFilterListItem]?
        public let nextToken: String?

        public init(findingsFilterListItems: [FindingsFilterListItem]? = nil, nextToken: String? = nil) {
            self.findingsFilterListItems = findingsFilterListItems
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingsFilterListItems
            case nextToken
        }
    }

    public struct ListFindingsRequest: AWSEncodableShape {
        public let findingCriteria: FindingCriteria?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortCriteria: SortCriteria?

        public init(findingCriteria: FindingCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SortCriteria? = nil) {
            self.findingCriteria = findingCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case findingCriteria
            case maxResults
            case nextToken
            case sortCriteria
        }
    }

    public struct ListFindingsResponse: AWSDecodableShape {
        public let findingIds: [String]?
        public let nextToken: String?

        public init(findingIds: [String]? = nil, nextToken: String? = nil) {
            self.findingIds = findingIds
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case findingIds
            case nextToken
        }
    }

    public struct ListInvitationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInvitationsResponse: AWSDecodableShape {
        public let invitations: [Invitation]?
        public let nextToken: String?

        public init(invitations: [Invitation]? = nil, nextToken: String? = nil) {
            self.invitations = invitations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case invitations
            case nextToken
        }
    }

    public struct ListJobsFilterCriteria: AWSEncodableShape {
        public let excludes: [ListJobsFilterTerm]?
        public let includes: [ListJobsFilterTerm]?

        public init(excludes: [ListJobsFilterTerm]? = nil, includes: [ListJobsFilterTerm]? = nil) {
            self.excludes = excludes
            self.includes = includes
        }

        private enum CodingKeys: String, CodingKey {
            case excludes
            case includes
        }
    }

    public struct ListJobsFilterTerm: AWSEncodableShape {
        public let comparator: JobComparator?
        public let key: ListJobsFilterKey?
        public let values: [String]?

        public init(comparator: JobComparator? = nil, key: ListJobsFilterKey? = nil, values: [String]? = nil) {
            self.comparator = comparator
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case key
            case values
        }
    }

    public struct ListJobsSortCriteria: AWSEncodableShape {
        public let attributeName: ListJobsSortAttributeName?
        public let orderBy: OrderBy?

        public init(attributeName: ListJobsSortAttributeName? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case orderBy
        }
    }

    public struct ListMembersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "onlyAssociated", location: .querystring(locationName: "onlyAssociated"))
        ]

        public let maxResults: Int?
        public let nextToken: String?
        public let onlyAssociated: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, onlyAssociated: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.onlyAssociated = onlyAssociated
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMembersResponse: AWSDecodableShape {
        public let members: [Member]?
        public let nextToken: String?

        public init(members: [Member]? = nil, nextToken: String? = nil) {
            self.members = members
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case members
            case nextToken
        }
    }

    public struct ListOrganizationAdminAccountsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        public let maxResults: Int?
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListOrganizationAdminAccountsResponse: AWSDecodableShape {
        public let adminAccounts: [AdminAccount]?
        public let nextToken: String?

        public init(adminAccounts: [AdminAccount]? = nil, nextToken: String? = nil) {
            self.adminAccounts = adminAccounts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case adminAccounts
            case nextToken
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct MatchingBucket: AWSDecodableShape {
        public let accountId: String?
        public let bucketName: String?
        public let classifiableObjectCount: Int64?
        public let classifiableSizeInBytes: Int64?
        public let jobDetails: JobDetails?
        public let objectCount: Int64?
        public let objectCountByEncryptionType: ObjectCountByEncryptionType?
        public let sizeInBytes: Int64?
        public let sizeInBytesCompressed: Int64?
        public let unclassifiableObjectCount: ObjectLevelStatistics?
        public let unclassifiableObjectSizeInBytes: ObjectLevelStatistics?

        public init(accountId: String? = nil, bucketName: String? = nil, classifiableObjectCount: Int64? = nil, classifiableSizeInBytes: Int64? = nil, jobDetails: JobDetails? = nil, objectCount: Int64? = nil, objectCountByEncryptionType: ObjectCountByEncryptionType? = nil, sizeInBytes: Int64? = nil, sizeInBytesCompressed: Int64? = nil, unclassifiableObjectCount: ObjectLevelStatistics? = nil, unclassifiableObjectSizeInBytes: ObjectLevelStatistics? = nil) {
            self.accountId = accountId
            self.bucketName = bucketName
            self.classifiableObjectCount = classifiableObjectCount
            self.classifiableSizeInBytes = classifiableSizeInBytes
            self.jobDetails = jobDetails
            self.objectCount = objectCount
            self.objectCountByEncryptionType = objectCountByEncryptionType
            self.sizeInBytes = sizeInBytes
            self.sizeInBytesCompressed = sizeInBytesCompressed
            self.unclassifiableObjectCount = unclassifiableObjectCount
            self.unclassifiableObjectSizeInBytes = unclassifiableObjectSizeInBytes
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case bucketName
            case classifiableObjectCount
            case classifiableSizeInBytes
            case jobDetails
            case objectCount
            case objectCountByEncryptionType
            case sizeInBytes
            case sizeInBytesCompressed
            case unclassifiableObjectCount
            case unclassifiableObjectSizeInBytes
        }
    }

    public struct MatchingResource: AWSDecodableShape {
        public let matchingBucket: MatchingBucket?

        public init(matchingBucket: MatchingBucket? = nil) {
            self.matchingBucket = matchingBucket
        }

        private enum CodingKeys: String, CodingKey {
            case matchingBucket
        }
    }

    public struct Member: AWSDecodableShape {
        public let accountId: String?
        public let administratorAccountId: String?
        public let arn: String?
        public let email: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var invitedAt: Date?
        public let masterAccountId: String?
        public let relationshipStatus: RelationshipStatus?
        public let tags: [String: String]?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var updatedAt: Date?

        public init(accountId: String? = nil, administratorAccountId: String? = nil, arn: String? = nil, email: String? = nil, invitedAt: Date? = nil, masterAccountId: String? = nil, relationshipStatus: RelationshipStatus? = nil, tags: [String: String]? = nil, updatedAt: Date? = nil) {
            self.accountId = accountId
            self.administratorAccountId = administratorAccountId
            self.arn = arn
            self.email = email
            self.invitedAt = invitedAt
            self.masterAccountId = masterAccountId
            self.relationshipStatus = relationshipStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case administratorAccountId
            case arn
            case email
            case invitedAt
            case masterAccountId
            case relationshipStatus
            case tags
            case updatedAt
        }
    }

    public struct MonthlySchedule: AWSEncodableShape & AWSDecodableShape {
        public let dayOfMonth: Int?

        public init(dayOfMonth: Int? = nil) {
            self.dayOfMonth = dayOfMonth
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfMonth
        }
    }

    public struct ObjectCountByEncryptionType: AWSDecodableShape {
        public let customerManaged: Int64?
        public let kmsManaged: Int64?
        public let s3Managed: Int64?
        public let unencrypted: Int64?
        public let unknown: Int64?

        public init(customerManaged: Int64? = nil, kmsManaged: Int64? = nil, s3Managed: Int64? = nil, unencrypted: Int64? = nil, unknown: Int64? = nil) {
            self.customerManaged = customerManaged
            self.kmsManaged = kmsManaged
            self.s3Managed = s3Managed
            self.unencrypted = unencrypted
            self.unknown = unknown
        }

        private enum CodingKeys: String, CodingKey {
            case customerManaged
            case kmsManaged
            case s3Managed
            case unencrypted
            case unknown
        }
    }

    public struct ObjectLevelStatistics: AWSDecodableShape {
        public let fileType: Int64?
        public let storageClass: Int64?
        public let total: Int64?

        public init(fileType: Int64? = nil, storageClass: Int64? = nil, total: Int64? = nil) {
            self.fileType = fileType
            self.storageClass = storageClass
            self.total = total
        }

        private enum CodingKeys: String, CodingKey {
            case fileType
            case storageClass
            case total
        }
    }

    public struct Occurrences: AWSDecodableShape {
        public let cells: [Cell]?
        public let lineRanges: [Range]?
        public let offsetRanges: [Range]?
        public let pages: [Page]?
        public let records: [Record]?

        public init(cells: [Cell]? = nil, lineRanges: [Range]? = nil, offsetRanges: [Range]? = nil, pages: [Page]? = nil, records: [Record]? = nil) {
            self.cells = cells
            self.lineRanges = lineRanges
            self.offsetRanges = offsetRanges
            self.pages = pages
            self.records = records
        }

        private enum CodingKeys: String, CodingKey {
            case cells
            case lineRanges
            case offsetRanges
            case pages
            case records
        }
    }

    public struct Page: AWSDecodableShape {
        public let lineRange: Range?
        public let offsetRange: Range?
        public let pageNumber: Int64?

        public init(lineRange: Range? = nil, offsetRange: Range? = nil, pageNumber: Int64? = nil) {
            self.lineRange = lineRange
            self.offsetRange = offsetRange
            self.pageNumber = pageNumber
        }

        private enum CodingKeys: String, CodingKey {
            case lineRange
            case offsetRange
            case pageNumber
        }
    }

    public struct PolicyDetails: AWSDecodableShape {
        public let action: FindingAction?
        public let actor: FindingActor?

        public init(action: FindingAction? = nil, actor: FindingActor? = nil) {
            self.action = action
            self.actor = actor
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case actor
        }
    }

    public struct PutClassificationExportConfigurationRequest: AWSEncodableShape {
        public let configuration: ClassificationExportConfiguration

        public init(configuration: ClassificationExportConfiguration) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
        }
    }

    public struct PutClassificationExportConfigurationResponse: AWSDecodableShape {
        public let configuration: ClassificationExportConfiguration?

        public init(configuration: ClassificationExportConfiguration? = nil) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration
        }
    }

    public struct PutFindingsPublicationConfigurationRequest: AWSEncodableShape {
        public let clientToken: String?
        public let securityHubConfiguration: SecurityHubConfiguration?

        public init(clientToken: String? = PutFindingsPublicationConfigurationRequest.idempotencyToken(), securityHubConfiguration: SecurityHubConfiguration? = nil) {
            self.clientToken = clientToken
            self.securityHubConfiguration = securityHubConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case securityHubConfiguration
        }
    }

    public struct PutFindingsPublicationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Range: AWSDecodableShape {
        public let end: Int64?
        public let start: Int64?
        public let startColumn: Int64?

        public init(end: Int64? = nil, start: Int64? = nil, startColumn: Int64? = nil) {
            self.end = end
            self.start = start
            self.startColumn = startColumn
        }

        private enum CodingKeys: String, CodingKey {
            case end
            case start
            case startColumn
        }
    }

    public struct Record: AWSDecodableShape {
        public let jsonPath: String?
        public let recordIndex: Int64?

        public init(jsonPath: String? = nil, recordIndex: Int64? = nil) {
            self.jsonPath = jsonPath
            self.recordIndex = recordIndex
        }

        private enum CodingKeys: String, CodingKey {
            case jsonPath
            case recordIndex
        }
    }

    public struct ReplicationDetails: AWSDecodableShape {
        public let replicated: Bool?
        public let replicatedExternally: Bool?
        public let replicationAccounts: [String]?

        public init(replicated: Bool? = nil, replicatedExternally: Bool? = nil, replicationAccounts: [String]? = nil) {
            self.replicated = replicated
            self.replicatedExternally = replicatedExternally
            self.replicationAccounts = replicationAccounts
        }

        private enum CodingKeys: String, CodingKey {
            case replicated
            case replicatedExternally
            case replicationAccounts
        }
    }

    public struct ResourcesAffected: AWSDecodableShape {
        public let s3Bucket: S3Bucket?
        public let s3Object: S3Object?

        public init(s3Bucket: S3Bucket? = nil, s3Object: S3Object? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Object = s3Object
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket
            case s3Object
        }
    }

    public struct S3Bucket: AWSDecodableShape {
        public let allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads?
        public let arn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        public let defaultServerSideEncryption: ServerSideEncryption?
        public let name: String?
        public let owner: S3BucketOwner?
        public let publicAccess: BucketPublicAccess?
        public let tags: [KeyValuePair]?

        public init(allowsUnencryptedObjectUploads: AllowsUnencryptedObjectUploads? = nil, arn: String? = nil, createdAt: Date? = nil, defaultServerSideEncryption: ServerSideEncryption? = nil, name: String? = nil, owner: S3BucketOwner? = nil, publicAccess: BucketPublicAccess? = nil, tags: [KeyValuePair]? = nil) {
            self.allowsUnencryptedObjectUploads = allowsUnencryptedObjectUploads
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case allowsUnencryptedObjectUploads
            case arn
            case createdAt
            case defaultServerSideEncryption
            case name
            case owner
            case publicAccess
            case tags
        }
    }

    public struct S3BucketCriteriaForJob: AWSEncodableShape & AWSDecodableShape {
        public let excludes: CriteriaBlockForJob?
        public let includes: CriteriaBlockForJob?

        public init(excludes: CriteriaBlockForJob? = nil, includes: CriteriaBlockForJob? = nil) {
            self.excludes = excludes
            self.includes = includes
        }

        private enum CodingKeys: String, CodingKey {
            case excludes
            case includes
        }
    }

    public struct S3BucketDefinitionForJob: AWSEncodableShape & AWSDecodableShape {
        public let accountId: String
        public let buckets: [String]

        public init(accountId: String, buckets: [String]) {
            self.accountId = accountId
            self.buckets = buckets
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case buckets
        }
    }

    public struct S3BucketOwner: AWSDecodableShape {
        public let displayName: String?
        public let id: String?

        public init(displayName: String? = nil, id: String? = nil) {
            self.displayName = displayName
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case displayName
            case id
        }
    }

    public struct S3Destination: AWSEncodableShape & AWSDecodableShape {
        public let bucketName: String
        public let keyPrefix: String?
        public let kmsKeyArn: String

        public init(bucketName: String, keyPrefix: String? = nil, kmsKeyArn: String) {
            self.bucketName = bucketName
            self.keyPrefix = keyPrefix
            self.kmsKeyArn = kmsKeyArn
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName
            case keyPrefix
            case kmsKeyArn
        }
    }

    public struct S3JobDefinition: AWSEncodableShape & AWSDecodableShape {
        public let bucketCriteria: S3BucketCriteriaForJob?
        public let bucketDefinitions: [S3BucketDefinitionForJob]?
        public let scoping: Scoping?

        public init(bucketCriteria: S3BucketCriteriaForJob? = nil, bucketDefinitions: [S3BucketDefinitionForJob]? = nil, scoping: Scoping? = nil) {
            self.bucketCriteria = bucketCriteria
            self.bucketDefinitions = bucketDefinitions
            self.scoping = scoping
        }

        private enum CodingKeys: String, CodingKey {
            case bucketCriteria
            case bucketDefinitions
            case scoping
        }
    }

    public struct S3Object: AWSDecodableShape {
        public let bucketArn: String?
        public let eTag: String?
        public let `extension`: String?
        public let key: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastModified: Date?
        public let path: String?
        public let publicAccess: Bool?
        public let serverSideEncryption: ServerSideEncryption?
        public let size: Int64?
        public let storageClass: StorageClass?
        public let tags: [KeyValuePair]?
        public let versionId: String?

        public init(bucketArn: String? = nil, eTag: String? = nil, extension: String? = nil, key: String? = nil, lastModified: Date? = nil, path: String? = nil, publicAccess: Bool? = nil, serverSideEncryption: ServerSideEncryption? = nil, size: Int64? = nil, storageClass: StorageClass? = nil, tags: [KeyValuePair]? = nil, versionId: String? = nil) {
            self.bucketArn = bucketArn
            self.eTag = eTag
            self.`extension` = `extension`
            self.key = key
            self.lastModified = lastModified
            self.path = path
            self.publicAccess = publicAccess
            self.serverSideEncryption = serverSideEncryption
            self.size = size
            self.storageClass = storageClass
            self.tags = tags
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn
            case eTag
            case `extension`
            case key
            case lastModified
            case path
            case publicAccess
            case serverSideEncryption
            case size
            case storageClass
            case tags
            case versionId
        }
    }

    public struct Scoping: AWSEncodableShape & AWSDecodableShape {
        public let excludes: JobScopingBlock?
        public let includes: JobScopingBlock?

        public init(excludes: JobScopingBlock? = nil, includes: JobScopingBlock? = nil) {
            self.excludes = excludes
            self.includes = includes
        }

        private enum CodingKeys: String, CodingKey {
            case excludes
            case includes
        }
    }

    public struct SearchResourcesBucketCriteria: AWSEncodableShape {
        public let excludes: SearchResourcesCriteriaBlock?
        public let includes: SearchResourcesCriteriaBlock?

        public init(excludes: SearchResourcesCriteriaBlock? = nil, includes: SearchResourcesCriteriaBlock? = nil) {
            self.excludes = excludes
            self.includes = includes
        }

        private enum CodingKeys: String, CodingKey {
            case excludes
            case includes
        }
    }

    public struct SearchResourcesCriteria: AWSEncodableShape {
        public let simpleCriterion: SearchResourcesSimpleCriterion?
        public let tagCriterion: SearchResourcesTagCriterion?

        public init(simpleCriterion: SearchResourcesSimpleCriterion? = nil, tagCriterion: SearchResourcesTagCriterion? = nil) {
            self.simpleCriterion = simpleCriterion
            self.tagCriterion = tagCriterion
        }

        private enum CodingKeys: String, CodingKey {
            case simpleCriterion
            case tagCriterion
        }
    }

    public struct SearchResourcesCriteriaBlock: AWSEncodableShape {
        public let and: [SearchResourcesCriteria]?

        public init(and: [SearchResourcesCriteria]? = nil) {
            self.and = and
        }

        private enum CodingKeys: String, CodingKey {
            case and
        }
    }

    public struct SearchResourcesRequest: AWSEncodableShape {
        public let bucketCriteria: SearchResourcesBucketCriteria?
        public let maxResults: Int?
        public let nextToken: String?
        public let sortCriteria: SearchResourcesSortCriteria?

        public init(bucketCriteria: SearchResourcesBucketCriteria? = nil, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: SearchResourcesSortCriteria? = nil) {
            self.bucketCriteria = bucketCriteria
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        private enum CodingKeys: String, CodingKey {
            case bucketCriteria
            case maxResults
            case nextToken
            case sortCriteria
        }
    }

    public struct SearchResourcesResponse: AWSDecodableShape {
        public let matchingResources: [MatchingResource]?
        public let nextToken: String?

        public init(matchingResources: [MatchingResource]? = nil, nextToken: String? = nil) {
            self.matchingResources = matchingResources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case matchingResources
            case nextToken
        }
    }

    public struct SearchResourcesSimpleCriterion: AWSEncodableShape {
        public let comparator: SearchResourcesComparator?
        public let key: SearchResourcesSimpleCriterionKey?
        public let values: [String]?

        public init(comparator: SearchResourcesComparator? = nil, key: SearchResourcesSimpleCriterionKey? = nil, values: [String]? = nil) {
            self.comparator = comparator
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case key
            case values
        }
    }

    public struct SearchResourcesSortCriteria: AWSEncodableShape {
        public let attributeName: SearchResourcesSortAttributeName?
        public let orderBy: OrderBy?

        public init(attributeName: SearchResourcesSortAttributeName? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case orderBy
        }
    }

    public struct SearchResourcesTagCriterion: AWSEncodableShape {
        public let comparator: SearchResourcesComparator?
        public let tagValues: [SearchResourcesTagCriterionPair]?

        public init(comparator: SearchResourcesComparator? = nil, tagValues: [SearchResourcesTagCriterionPair]? = nil) {
            self.comparator = comparator
            self.tagValues = tagValues
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case tagValues
        }
    }

    public struct SearchResourcesTagCriterionPair: AWSEncodableShape {
        public let key: String?
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct SecurityHubConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let publishClassificationFindings: Bool
        public let publishPolicyFindings: Bool

        public init(publishClassificationFindings: Bool, publishPolicyFindings: Bool) {
            self.publishClassificationFindings = publishClassificationFindings
            self.publishPolicyFindings = publishPolicyFindings
        }

        private enum CodingKeys: String, CodingKey {
            case publishClassificationFindings
            case publishPolicyFindings
        }
    }

    public struct SensitiveDataItem: AWSDecodableShape {
        public let category: SensitiveDataItemCategory?
        public let detections: [DefaultDetection]?
        public let totalCount: Int64?

        public init(category: SensitiveDataItemCategory? = nil, detections: [DefaultDetection]? = nil, totalCount: Int64? = nil) {
            self.category = category
            self.detections = detections
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case category
            case detections
            case totalCount
        }
    }

    public struct ServerSideEncryption: AWSDecodableShape {
        public let encryptionType: EncryptionType?
        public let kmsMasterKeyId: String?

        public init(encryptionType: EncryptionType? = nil, kmsMasterKeyId: String? = nil) {
            self.encryptionType = encryptionType
            self.kmsMasterKeyId = kmsMasterKeyId
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType
            case kmsMasterKeyId
        }
    }

    public struct ServiceLimit: AWSDecodableShape {
        public let isServiceLimited: Bool?
        public let unit: Unit?
        public let value: Int64?

        public init(isServiceLimited: Bool? = nil, unit: Unit? = nil, value: Int64? = nil) {
            self.isServiceLimited = isServiceLimited
            self.unit = unit
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case isServiceLimited
            case unit
            case value
        }
    }

    public struct SessionContext: AWSDecodableShape {
        public let attributes: SessionContextAttributes?
        public let sessionIssuer: SessionIssuer?

        public init(attributes: SessionContextAttributes? = nil, sessionIssuer: SessionIssuer? = nil) {
            self.attributes = attributes
            self.sessionIssuer = sessionIssuer
        }

        private enum CodingKeys: String, CodingKey {
            case attributes
            case sessionIssuer
        }
    }

    public struct SessionContextAttributes: AWSDecodableShape {
        @OptionalCustomCoding<ISO8601DateCoder>
        public var creationDate: Date?
        public let mfaAuthenticated: Bool?

        public init(creationDate: Date? = nil, mfaAuthenticated: Bool? = nil) {
            self.creationDate = creationDate
            self.mfaAuthenticated = mfaAuthenticated
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate
            case mfaAuthenticated
        }
    }

    public struct SessionIssuer: AWSDecodableShape {
        public let accountId: String?
        public let arn: String?
        public let principalId: String?
        public let type: String?
        public let userName: String?

        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil, type: String? = nil, userName: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
            self.type = type
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case arn
            case principalId
            case type
            case userName
        }
    }

    public struct Severity: AWSDecodableShape {
        public let description: SeverityDescription?
        public let score: Int64?

        public init(description: SeverityDescription? = nil, score: Int64? = nil) {
            self.description = description
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case description
            case score
        }
    }

    public struct SimpleCriterionForJob: AWSEncodableShape & AWSDecodableShape {
        public let comparator: JobComparator?
        public let key: SimpleCriterionKeyForJob?
        public let values: [String]?

        public init(comparator: JobComparator? = nil, key: SimpleCriterionKeyForJob? = nil, values: [String]? = nil) {
            self.comparator = comparator
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case key
            case values
        }
    }

    public struct SimpleScopeTerm: AWSEncodableShape & AWSDecodableShape {
        public let comparator: JobComparator?
        public let key: ScopeFilterKey?
        public let values: [String]?

        public init(comparator: JobComparator? = nil, key: ScopeFilterKey? = nil, values: [String]? = nil) {
            self.comparator = comparator
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case key
            case values
        }
    }

    public struct SortCriteria: AWSEncodableShape {
        public let attributeName: String?
        public let orderBy: OrderBy?

        public init(attributeName: String? = nil, orderBy: OrderBy? = nil) {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName
            case orderBy
        }
    }

    public struct Statistics: AWSDecodableShape {
        public let approximateNumberOfObjectsToProcess: Double?
        public let numberOfRuns: Double?

        public init(approximateNumberOfObjectsToProcess: Double? = nil, numberOfRuns: Double? = nil) {
            self.approximateNumberOfObjectsToProcess = approximateNumberOfObjectsToProcess
            self.numberOfRuns = numberOfRuns
        }

        private enum CodingKeys: String, CodingKey {
            case approximateNumberOfObjectsToProcess
            case numberOfRuns
        }
    }

    public struct TagCriterionForJob: AWSEncodableShape & AWSDecodableShape {
        public let comparator: JobComparator?
        public let tagValues: [TagCriterionPairForJob]?

        public init(comparator: JobComparator? = nil, tagValues: [TagCriterionPairForJob]? = nil) {
            self.comparator = comparator
            self.tagValues = tagValues
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case tagValues
        }
    }

    public struct TagCriterionPairForJob: AWSEncodableShape & AWSDecodableShape {
        public let key: String?
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        public let resourceArn: String
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagScopeTerm: AWSEncodableShape & AWSDecodableShape {
        public let comparator: JobComparator?
        public let key: String?
        public let tagValues: [TagValuePair]?
        public let target: TagTarget?

        public init(comparator: JobComparator? = nil, key: String? = nil, tagValues: [TagValuePair]? = nil, target: TagTarget? = nil) {
            self.comparator = comparator
            self.key = key
            self.tagValues = tagValues
            self.target = target
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case key
            case tagValues
            case target
        }
    }

    public struct TagValuePair: AWSEncodableShape & AWSDecodableShape {
        public let key: String?
        public let value: String?

        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case value
        }
    }

    public struct TestCustomDataIdentifierRequest: AWSEncodableShape {
        public let ignoreWords: [String]?
        public let keywords: [String]?
        public let maximumMatchDistance: Int?
        public let regex: String
        public let sampleText: String

        public init(ignoreWords: [String]? = nil, keywords: [String]? = nil, maximumMatchDistance: Int? = nil, regex: String, sampleText: String) {
            self.ignoreWords = ignoreWords
            self.keywords = keywords
            self.maximumMatchDistance = maximumMatchDistance
            self.regex = regex
            self.sampleText = sampleText
        }

        private enum CodingKeys: String, CodingKey {
            case ignoreWords
            case keywords
            case maximumMatchDistance
            case regex
            case sampleText
        }
    }

    public struct TestCustomDataIdentifierResponse: AWSDecodableShape {
        public let matchCount: Int?

        public init(matchCount: Int? = nil) {
            self.matchCount = matchCount
        }

        private enum CodingKeys: String, CodingKey {
            case matchCount
        }
    }

    public struct UnprocessedAccount: AWSDecodableShape {
        public let accountId: String?
        public let errorCode: ErrorCode?
        public let errorMessage: String?

        public init(accountId: String? = nil, errorCode: ErrorCode? = nil, errorMessage: String? = nil) {
            self.accountId = accountId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case errorCode
            case errorMessage
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        public let resourceArn: String
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateClassificationJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "jobId"))
        ]

        public let jobId: String
        public let jobStatus: JobStatus

        public init(jobId: String, jobStatus: JobStatus) {
            self.jobId = jobId
            self.jobStatus = jobStatus
        }

        private enum CodingKeys: String, CodingKey {
            case jobStatus
        }
    }

    public struct UpdateClassificationJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateFindingsFilterRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let action: FindingsFilterAction?
        public let clientToken: String?
        public let description: String?
        public let findingCriteria: FindingCriteria?
        public let id: String
        public let name: String?
        public let position: Int?

        public init(action: FindingsFilterAction? = nil, clientToken: String? = UpdateFindingsFilterRequest.idempotencyToken(), description: String? = nil, findingCriteria: FindingCriteria? = nil, id: String, name: String? = nil, position: Int? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.description = description
            self.findingCriteria = findingCriteria
            self.id = id
            self.name = name
            self.position = position
        }

        private enum CodingKeys: String, CodingKey {
            case action
            case clientToken
            case description
            case findingCriteria
            case name
            case position
        }
    }

    public struct UpdateFindingsFilterResponse: AWSDecodableShape {
        public let arn: String?
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn
            case id
        }
    }

    public struct UpdateMacieSessionRequest: AWSEncodableShape {
        public let findingPublishingFrequency: FindingPublishingFrequency?
        public let status: MacieStatus?

        public init(findingPublishingFrequency: FindingPublishingFrequency? = nil, status: MacieStatus? = nil) {
            self.findingPublishingFrequency = findingPublishingFrequency
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case findingPublishingFrequency
            case status
        }
    }

    public struct UpdateMacieSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateMemberSessionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri(locationName: "id"))
        ]

        public let id: String
        public let status: MacieStatus

        public init(id: String, status: MacieStatus) {
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status
        }
    }

    public struct UpdateMemberSessionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateOrganizationConfigurationRequest: AWSEncodableShape {
        public let autoEnable: Bool

        public init(autoEnable: Bool) {
            self.autoEnable = autoEnable
        }

        private enum CodingKeys: String, CodingKey {
            case autoEnable
        }
    }

    public struct UpdateOrganizationConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UsageByAccount: AWSDecodableShape {
        public let currency: Currency?
        public let estimatedCost: String?
        public let serviceLimit: ServiceLimit?
        public let type: UsageType?

        public init(currency: Currency? = nil, estimatedCost: String? = nil, serviceLimit: ServiceLimit? = nil, type: UsageType? = nil) {
            self.currency = currency
            self.estimatedCost = estimatedCost
            self.serviceLimit = serviceLimit
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case currency
            case estimatedCost
            case serviceLimit
            case type
        }
    }

    public struct UsageRecord: AWSDecodableShape {
        public let accountId: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var freeTrialStartDate: Date?
        public let usage: [UsageByAccount]?

        public init(accountId: String? = nil, freeTrialStartDate: Date? = nil, usage: [UsageByAccount]? = nil) {
            self.accountId = accountId
            self.freeTrialStartDate = freeTrialStartDate
            self.usage = usage
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case freeTrialStartDate
            case usage
        }
    }

    public struct UsageStatisticsFilter: AWSEncodableShape {
        public let comparator: UsageStatisticsFilterComparator?
        public let key: UsageStatisticsFilterKey?
        public let values: [String]?

        public init(comparator: UsageStatisticsFilterComparator? = nil, key: UsageStatisticsFilterKey? = nil, values: [String]? = nil) {
            self.comparator = comparator
            self.key = key
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case comparator
            case key
            case values
        }
    }

    public struct UsageStatisticsSortBy: AWSEncodableShape {
        public let key: UsageStatisticsSortKey?
        public let orderBy: OrderBy?

        public init(key: UsageStatisticsSortKey? = nil, orderBy: OrderBy? = nil) {
            self.key = key
            self.orderBy = orderBy
        }

        private enum CodingKeys: String, CodingKey {
            case key
            case orderBy
        }
    }

    public struct UsageTotal: AWSDecodableShape {
        public let currency: Currency?
        public let estimatedCost: String?
        public let type: UsageType?

        public init(currency: Currency? = nil, estimatedCost: String? = nil, type: UsageType? = nil) {
            self.currency = currency
            self.estimatedCost = estimatedCost
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case currency
            case estimatedCost
            case type
        }
    }

    public struct UserIdentity: AWSDecodableShape {
        public let assumedRole: AssumedRole?
        public let awsAccount: AwsAccount?
        public let awsService: AwsService?
        public let federatedUser: FederatedUser?
        public let iamUser: IamUser?
        public let root: UserIdentityRoot?
        public let type: UserIdentityType?

        public init(assumedRole: AssumedRole? = nil, awsAccount: AwsAccount? = nil, awsService: AwsService? = nil, federatedUser: FederatedUser? = nil, iamUser: IamUser? = nil, root: UserIdentityRoot? = nil, type: UserIdentityType? = nil) {
            self.assumedRole = assumedRole
            self.awsAccount = awsAccount
            self.awsService = awsService
            self.federatedUser = federatedUser
            self.iamUser = iamUser
            self.root = root
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case assumedRole
            case awsAccount
            case awsService
            case federatedUser
            case iamUser
            case root
            case type
        }
    }

    public struct UserIdentityRoot: AWSDecodableShape {
        public let accountId: String?
        public let arn: String?
        public let principalId: String?

        public init(accountId: String? = nil, arn: String? = nil, principalId: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.principalId = principalId
        }

        private enum CodingKeys: String, CodingKey {
            case accountId
            case arn
            case principalId
        }
    }

    public struct UserPausedDetails: AWSDecodableShape {
        @OptionalCustomCoding<ISO8601DateCoder>
        public var jobExpiresAt: Date?
        public let jobImminentExpirationHealthEventArn: String?
        @OptionalCustomCoding<ISO8601DateCoder>
        public var jobPausedAt: Date?

        public init(jobExpiresAt: Date? = nil, jobImminentExpirationHealthEventArn: String? = nil, jobPausedAt: Date? = nil) {
            self.jobExpiresAt = jobExpiresAt
            self.jobImminentExpirationHealthEventArn = jobImminentExpirationHealthEventArn
            self.jobPausedAt = jobPausedAt
        }

        private enum CodingKeys: String, CodingKey {
            case jobExpiresAt
            case jobImminentExpirationHealthEventArn
            case jobPausedAt
        }
    }

    public struct WeeklySchedule: AWSEncodableShape & AWSDecodableShape {
        public let dayOfWeek: DayOfWeek?

        public init(dayOfWeek: DayOfWeek? = nil) {
            self.dayOfWeek = dayOfWeek
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfWeek
        }
    }
}
