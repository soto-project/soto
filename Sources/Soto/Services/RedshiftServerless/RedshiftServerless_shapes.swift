//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension RedshiftServerless {
    // MARK: Enums

    public enum LogExport: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectionlog = "connectionlog"
        case useractivitylog = "useractivitylog"
        case userlog = "userlog"
        public var description: String { return self.rawValue }
    }

    public enum ManagedWorkgroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case modifying = "MODIFYING"
        case notAvailable = "NOT_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum NamespaceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case deleting = "DELETING"
        case modifying = "MODIFYING"
        public var description: String { return self.rawValue }
    }

    public enum PerformanceTargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum SnapshotStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case cancelled = "CANCELLED"
        case copying = "COPYING"
        case creating = "CREATING"
        case deleted = "DELETED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case disabled = "DISABLED"
        public var description: String { return self.rawValue }
    }

    public enum UsageLimitBreachAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deactivate = "deactivate"
        case emitMetric = "emit-metric"
        case log = "log"
        public var description: String { return self.rawValue }
    }

    public enum UsageLimitPeriod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case daily = "daily"
        case monthly = "monthly"
        case weekly = "weekly"
        public var description: String { return self.rawValue }
    }

    public enum UsageLimitUsageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case crossRegionDatasharing = "cross-region-datasharing"
        case serverlessCompute = "serverless-compute"
        public var description: String { return self.rawValue }
    }

    public enum WorkgroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case modifying = "MODIFYING"
        public var description: String { return self.rawValue }
    }

    public enum Schedule: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The timestamp of when Amazon Redshift Serverless should run the scheduled action. Timestamp is in UTC. Format of at expression is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.
        case at(Date)
        /// The cron expression to use to schedule a recurring scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC. Format of cron expressions is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see  Cron Expressions in the Amazon CloudWatch Events User Guide.
        case cron(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .at:
                let value = try container.decode(Date.self, forKey: .at)
                self = .at(value)
            case .cron:
                let value = try container.decode(String.self, forKey: .cron)
                self = .cron(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .at(let value):
                try container.encode(value, forKey: .at)
            case .cron(let value):
                try container.encode(value, forKey: .cron)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case at = "at"
            case cron = "cron"
        }
    }

    // MARK: Shapes

    public struct AccessDeniedException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct Association: AWSDecodableShape {
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public let customDomainCertificateArn: String?
        /// The expiration time for the certificate.
        public let customDomainCertificateExpiryTime: Date?
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String?
        /// The name of the workgroup associated with the database.
        public let workgroupName: String?

        @inlinable
        public init(customDomainCertificateArn: String? = nil, customDomainCertificateExpiryTime: Date? = nil, customDomainName: String? = nil, workgroupName: String? = nil) {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainCertificateExpiryTime = "customDomainCertificateExpiryTime"
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct ConfigParameter: AWSEncodableShape & AWSDecodableShape {
        /// The key of the parameter. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let  you define performance boundaries. For more information about query monitoring rules and available metrics, see  Query monitoring metrics for Amazon Redshift Serverless.
        public let parameterKey: String?
        /// The value of the parameter to set.
        public let parameterValue: String?

        @inlinable
        public init(parameterKey: String? = nil, parameterValue: String? = nil) {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }

        private enum CodingKeys: String, CodingKey {
            case parameterKey = "parameterKey"
            case parameterValue = "parameterValue"
        }
    }

    public struct ConvertRecoveryPointToSnapshotRequest: AWSEncodableShape {
        /// The unique identifier of the recovery point.
        public let recoveryPointId: String
        /// How long to retain the snapshot.
        public let retentionPeriod: Int?
        /// The name of the snapshot.
        public let snapshotName: String
        /// An array of Tag objects  to associate with the created snapshot.
        public let tags: [Tag]?

        @inlinable
        public init(recoveryPointId: String, retentionPeriod: Int? = nil, snapshotName: String, tags: [Tag]? = nil) {
            self.recoveryPointId = recoveryPointId
            self.retentionPeriod = retentionPeriod
            self.snapshotName = snapshotName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryPointId = "recoveryPointId"
            case retentionPeriod = "retentionPeriod"
            case snapshotName = "snapshotName"
            case tags = "tags"
        }
    }

    public struct ConvertRecoveryPointToSnapshotResponse: AWSDecodableShape {
        /// The snapshot converted from the recovery point.
        public let snapshot: Snapshot?

        @inlinable
        public init(snapshot: Snapshot? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "snapshot"
        }
    }

    public struct CreateCustomDomainAssociationRequest: AWSEncodableShape {
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public let customDomainCertificateArn: String
        /// The custom domain name to associate with the workgroup.
        public let customDomainName: String
        /// The name of the workgroup associated with the database.
        public let workgroupName: String

        @inlinable
        public init(customDomainCertificateArn: String, customDomainName: String, workgroupName: String) {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, max: 2048)
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, min: 20)
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, pattern: "arn:[\\w+=/,.@-]+:acm:[\\w+=/,.@-]*:[0-9]+:[\\w+=,.@-]+(/[\\w+=,.@-]+)*")
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 253)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 1)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct CreateCustomDomainAssociationResponse: AWSDecodableShape {
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public let customDomainCertificateArn: String?
        /// The expiration time for the certificate.
        public let customDomainCertificateExpiryTime: Date?
        /// The custom domain name to associate with the workgroup.
        public let customDomainName: String?
        /// The name of the workgroup associated with the database.
        public let workgroupName: String?

        @inlinable
        public init(customDomainCertificateArn: String? = nil, customDomainCertificateExpiryTime: Date? = nil, customDomainName: String? = nil, workgroupName: String? = nil) {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainCertificateExpiryTime = "customDomainCertificateExpiryTime"
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct CreateEndpointAccessRequest: AWSEncodableShape {
        /// The name of the VPC endpoint. An endpoint name must contain 1-30 characters.  Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter.  The name can't contain two consecutive hyphens or end with a hyphen.
        public let endpointName: String
        /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
        public let ownerAccount: String?
        /// The unique identifers of subnets from which  Amazon Redshift Serverless chooses one to deploy a VPC endpoint.
        public let subnetIds: [String]
        /// The unique identifiers of the security group that defines the ports,  protocols, and sources for inbound traffic that you are authorizing into your endpoint.
        public let vpcSecurityGroupIds: [String]?
        /// The name of the workgroup to associate with the VPC endpoint.
        public let workgroupName: String

        @inlinable
        public init(endpointName: String, ownerAccount: String? = nil, subnetIds: [String], vpcSecurityGroupIds: [String]? = nil, workgroupName: String) {
            self.endpointName = endpointName
            self.ownerAccount = ownerAccount
            self.subnetIds = subnetIds
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "(\\d{12})")
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "endpointName"
            case ownerAccount = "ownerAccount"
            case subnetIds = "subnetIds"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
            case workgroupName = "workgroupName"
        }
    }

    public struct CreateEndpointAccessResponse: AWSDecodableShape {
        /// The created VPC endpoint.
        public let endpoint: EndpointAccess?

        @inlinable
        public init(endpoint: EndpointAccess? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
        }
    }

    public struct CreateNamespaceRequest: AWSEncodableShape {
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.  You can only use this parameter if manageAdminPassword is true.
        public let adminPasswordSecretKmsKeyId: String?
        /// The username of the administrator for the first database created in the namespace.
        public let adminUsername: String?
        /// The password of the administrator for the first database created in the namespace. You can't use adminUserPassword if manageAdminPassword is true.
        public let adminUserPassword: String?
        /// The name of the first database created in the namespace.
        public let dbName: String?
        /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
        public let defaultIamRoleArn: String?
        /// A list of IAM roles to associate with the namespace.
        public let iamRoles: [String]?
        /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
        public let kmsKeyId: String?
        /// The types of logs the namespace can export.  Available export types are userlog, connectionlog, and useractivitylog.
        public let logExports: [LogExport]?
        /// If true, Amazon Redshift uses Secrets Manager to manage the namespace's admin credentials.  You can't use adminUserPassword if manageAdminPassword is true.  If manageAdminPassword is false or not set, Amazon Redshift uses  adminUserPassword for the admin user account's password.
        public let manageAdminPassword: Bool?
        /// The name of the namespace.
        public let namespaceName: String
        /// The ARN for the Redshift application that integrates with IAM Identity Center.
        public let redshiftIdcApplicationArn: String?
        /// A list of tag instances.
        public let tags: [Tag]?

        @inlinable
        public init(adminPasswordSecretKmsKeyId: String? = nil, adminUsername: String? = nil, adminUserPassword: String? = nil, dbName: String? = nil, defaultIamRoleArn: String? = nil, iamRoles: [String]? = nil, kmsKeyId: String? = nil, logExports: [LogExport]? = nil, manageAdminPassword: Bool? = nil, namespaceName: String, redshiftIdcApplicationArn: String? = nil, tags: [Tag]? = nil) {
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.adminUserPassword = adminUserPassword
            self.dbName = dbName
            self.defaultIamRoleArn = defaultIamRoleArn
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.logExports = logExports
            self.manageAdminPassword = manageAdminPassword
            self.namespaceName = namespaceName
            self.redshiftIdcApplicationArn = redshiftIdcApplicationArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.logExports, name: "logExports", parent: name, max: 16)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.redshiftIdcApplicationArn, name: "redshiftIdcApplicationArn", parent: name, max: 1024)
            try self.validate(self.redshiftIdcApplicationArn, name: "redshiftIdcApplicationArn", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case adminPasswordSecretKmsKeyId = "adminPasswordSecretKmsKeyId"
            case adminUsername = "adminUsername"
            case adminUserPassword = "adminUserPassword"
            case dbName = "dbName"
            case defaultIamRoleArn = "defaultIamRoleArn"
            case iamRoles = "iamRoles"
            case kmsKeyId = "kmsKeyId"
            case logExports = "logExports"
            case manageAdminPassword = "manageAdminPassword"
            case namespaceName = "namespaceName"
            case redshiftIdcApplicationArn = "redshiftIdcApplicationArn"
            case tags = "tags"
        }
    }

    public struct CreateNamespaceResponse: AWSDecodableShape {
        /// The created namespace object.
        public let namespace: Namespace?

        @inlinable
        public init(namespace: Namespace? = nil) {
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
        }
    }

    public struct CreateScheduledActionRequest: AWSEncodableShape {
        /// Indicates whether the schedule is enabled. If false, the scheduled action does not trigger. For more information about state  of the scheduled action, see ScheduledAction.
        public let enabled: Bool?
        /// The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger.
        public let endTime: Date?
        /// The name of the namespace for which to create a scheduled action.
        public let namespaceName: String
        /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action.  This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots. (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.  For more information about the IAM role to use with the Amazon Redshift scheduler, see Using Identity-Based Policies for  Amazon Redshift in the Amazon Redshift Management Guide
        public let roleArn: String
        /// The schedule for a one-time (at timestamp format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC.   Format of at timestamp is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.   Format of cron expression is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see  Cron Expressions in the Amazon CloudWatch Events User Guide.
        public let schedule: Schedule
        /// The description of the scheduled action.
        public let scheduledActionDescription: String?
        /// The name of the scheduled action.
        public let scheduledActionName: String
        /// The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger.
        public let startTime: Date?
        public let targetAction: TargetAction

        @inlinable
        public init(enabled: Bool? = nil, endTime: Date? = nil, namespaceName: String, roleArn: String, schedule: Schedule, scheduledActionDescription: String? = nil, scheduledActionName: String, startTime: Date? = nil, targetAction: TargetAction) {
            self.enabled = enabled
            self.endTime = endTime
            self.namespaceName = namespaceName
            self.roleArn = roleArn
            self.schedule = schedule
            self.scheduledActionDescription = scheduledActionDescription
            self.scheduledActionName = scheduledActionName
            self.startTime = startTime
            self.targetAction = targetAction
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, max: 60)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, min: 3)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.targetAction.validate(name: "\(name).targetAction")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case endTime = "endTime"
            case namespaceName = "namespaceName"
            case roleArn = "roleArn"
            case schedule = "schedule"
            case scheduledActionDescription = "scheduledActionDescription"
            case scheduledActionName = "scheduledActionName"
            case startTime = "startTime"
            case targetAction = "targetAction"
        }
    }

    public struct CreateScheduledActionResponse: AWSDecodableShape {
        /// The returned ScheduledAction object that describes the properties of a scheduled action.
        public let scheduledAction: ScheduledActionResponse?

        @inlinable
        public init(scheduledAction: ScheduledActionResponse? = nil) {
            self.scheduledAction = scheduledAction
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledAction = "scheduledAction"
        }
    }

    public struct CreateSnapshotCopyConfigurationRequest: AWSEncodableShape {
        /// The KMS key to use to encrypt your snapshots in the destination Amazon Web Services Region.
        public let destinationKmsKeyId: String?
        /// The destination Amazon Web Services Region that you want to copy snapshots to.
        public let destinationRegion: String
        /// The name of the namespace to copy snapshots from.
        public let namespaceName: String
        /// The retention period of the snapshots that you copy to the destination Amazon Web Services Region.
        public let snapshotRetentionPeriod: Int?

        @inlinable
        public init(destinationKmsKeyId: String? = nil, destinationRegion: String, namespaceName: String, snapshotRetentionPeriod: Int? = nil) {
            self.destinationKmsKeyId = destinationKmsKeyId
            self.destinationRegion = destinationRegion
            self.namespaceName = namespaceName
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationKmsKeyId = "destinationKmsKeyId"
            case destinationRegion = "destinationRegion"
            case namespaceName = "namespaceName"
            case snapshotRetentionPeriod = "snapshotRetentionPeriod"
        }
    }

    public struct CreateSnapshotCopyConfigurationResponse: AWSDecodableShape {
        /// The snapshot copy configuration object that is returned.
        public let snapshotCopyConfiguration: SnapshotCopyConfiguration

        @inlinable
        public init(snapshotCopyConfiguration: SnapshotCopyConfiguration) {
            self.snapshotCopyConfiguration = snapshotCopyConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotCopyConfiguration = "snapshotCopyConfiguration"
        }
    }

    public struct CreateSnapshotRequest: AWSEncodableShape {
        /// The namespace to create a snapshot for.
        public let namespaceName: String
        /// How long to retain the created snapshot.
        public let retentionPeriod: Int?
        /// The name of the snapshot.
        public let snapshotName: String
        /// An array of Tag objects to associate with the snapshot.
        public let tags: [Tag]?

        @inlinable
        public init(namespaceName: String, retentionPeriod: Int? = nil, snapshotName: String, tags: [Tag]? = nil) {
            self.namespaceName = namespaceName
            self.retentionPeriod = retentionPeriod
            self.snapshotName = snapshotName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
            case retentionPeriod = "retentionPeriod"
            case snapshotName = "snapshotName"
            case tags = "tags"
        }
    }

    public struct CreateSnapshotResponse: AWSDecodableShape {
        /// The created snapshot object.
        public let snapshot: Snapshot?

        @inlinable
        public init(snapshot: Snapshot? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "snapshot"
        }
    }

    public struct CreateSnapshotScheduleActionParameters: AWSEncodableShape & AWSDecodableShape {
        /// The name of the namespace for which you want to configure a scheduled action to create a snapshot.
        public let namespaceName: String
        /// The retention period of the snapshot created by the scheduled action.
        public let retentionPeriod: Int?
        /// A string prefix that is attached to the name of the snapshot created by the scheduled action. The final  name of the snapshot is the string prefix appended by the date and time of when the snapshot was created.
        public let snapshotNamePrefix: String
        /// An array of Tag objects to associate with the snapshot.
        public let tags: [Tag]?

        @inlinable
        public init(namespaceName: String, retentionPeriod: Int? = nil, snapshotNamePrefix: String, tags: [Tag]? = nil) {
            self.namespaceName = namespaceName
            self.retentionPeriod = retentionPeriod
            self.snapshotNamePrefix = snapshotNamePrefix
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.snapshotNamePrefix, name: "snapshotNamePrefix", parent: name, max: 235)
            try self.validate(self.snapshotNamePrefix, name: "snapshotNamePrefix", parent: name, min: 1)
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
            case retentionPeriod = "retentionPeriod"
            case snapshotNamePrefix = "snapshotNamePrefix"
            case tags = "tags"
        }
    }

    public struct CreateUsageLimitRequest: AWSEncodableShape {
        /// The limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing. The value must be a positive number.
        public let amount: Int64
        /// The action that Amazon Redshift Serverless takes when the limit is reached. The default is log.
        public let breachAction: UsageLimitBreachAction?
        /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
        public let period: UsageLimitPeriod?
        /// The Amazon Resource Name (ARN) of the Amazon Redshift Serverless resource to create the usage limit for.
        public let resourceArn: String
        /// The type of Amazon Redshift Serverless usage to create a usage limit for.
        public let usageType: UsageLimitUsageType

        @inlinable
        public init(amount: Int64, breachAction: UsageLimitBreachAction? = nil, period: UsageLimitPeriod? = nil, resourceArn: String, usageType: UsageLimitUsageType) {
            self.amount = amount
            self.breachAction = breachAction
            self.period = period
            self.resourceArn = resourceArn
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case breachAction = "breachAction"
            case period = "period"
            case resourceArn = "resourceArn"
            case usageType = "usageType"
        }
    }

    public struct CreateUsageLimitResponse: AWSDecodableShape {
        /// The returned usage limit object.
        public let usageLimit: UsageLimit?

        @inlinable
        public init(usageLimit: UsageLimit? = nil) {
            self.usageLimit = usageLimit
        }

        private enum CodingKeys: String, CodingKey {
            case usageLimit = "usageLimit"
        }
    }

    public struct CreateWorkgroupRequest: AWSEncodableShape {
        /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
        public let baseCapacity: Int?
        /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let you define performance boundaries. For more information about query monitoring rules and available metrics, see   Query monitoring metrics for Amazon Redshift Serverless.
        public let configParameters: [ConfigParameter]?
        /// The value that specifies whether to turn on enhanced virtual  private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC instead of over the internet.
        public let enhancedVpcRouting: Bool?
        /// The IP address type that the workgroup supports. Possible values are ipv4 and dualstack.
        public let ipAddressType: String?
        /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
        public let maxCapacity: Int?
        /// The name of the namespace to associate with the workgroup.
        public let namespaceName: String
        /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
        public let port: Int?
        /// An object that represents the price performance target settings for the workgroup.
        public let pricePerformanceTarget: PerformanceTarget?
        /// A value that specifies whether the workgroup can be accessed from a public network.
        public let publiclyAccessible: Bool?
        /// An array of security group IDs to associate with the workgroup.
        public let securityGroupIds: [String]?
        /// An array of VPC subnet IDs to associate with the workgroup.
        public let subnetIds: [String]?
        /// A array of tag instances.
        public let tags: [Tag]?
        /// An optional parameter for the name of the track for the workgroup. If you don't provide  a track name, the workgroup is assigned to the current track.
        public let trackName: String?
        /// The name of the created workgroup.
        public let workgroupName: String

        @inlinable
        public init(baseCapacity: Int? = nil, configParameters: [ConfigParameter]? = nil, enhancedVpcRouting: Bool? = nil, ipAddressType: String? = nil, maxCapacity: Int? = nil, namespaceName: String, port: Int? = nil, pricePerformanceTarget: PerformanceTarget? = nil, publiclyAccessible: Bool? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, tags: [Tag]? = nil, trackName: String? = nil, workgroupName: String) {
            self.baseCapacity = baseCapacity
            self.configParameters = configParameters
            self.enhancedVpcRouting = enhancedVpcRouting
            self.ipAddressType = ipAddressType
            self.maxCapacity = maxCapacity
            self.namespaceName = namespaceName
            self.port = port
            self.pricePerformanceTarget = pricePerformanceTarget
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.trackName = trackName
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAddressType, name: "ipAddressType", parent: name, pattern: "^(ipv4|dualstack)$")
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.trackName, name: "trackName", parent: name, max: 256)
            try self.validate(self.trackName, name: "trackName", parent: name, min: 1)
            try self.validate(self.trackName, name: "trackName", parent: name, pattern: "^[a-zA-Z0-9_]+$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case baseCapacity = "baseCapacity"
            case configParameters = "configParameters"
            case enhancedVpcRouting = "enhancedVpcRouting"
            case ipAddressType = "ipAddressType"
            case maxCapacity = "maxCapacity"
            case namespaceName = "namespaceName"
            case port = "port"
            case pricePerformanceTarget = "pricePerformanceTarget"
            case publiclyAccessible = "publiclyAccessible"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case trackName = "trackName"
            case workgroupName = "workgroupName"
        }
    }

    public struct CreateWorkgroupResponse: AWSDecodableShape {
        /// The created workgroup object.
        public let workgroup: Workgroup?

        @inlinable
        public init(workgroup: Workgroup? = nil) {
            self.workgroup = workgroup
        }

        private enum CodingKeys: String, CodingKey {
            case workgroup = "workgroup"
        }
    }

    public struct DeleteCustomDomainAssociationRequest: AWSEncodableShape {
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String
        /// The name of the workgroup associated with the database.
        public let workgroupName: String

        @inlinable
        public init(customDomainName: String, workgroupName: String) {
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 253)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 1)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct DeleteCustomDomainAssociationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEndpointAccessRequest: AWSEncodableShape {
        /// The name of the VPC endpoint to delete.
        public let endpointName: String

        @inlinable
        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "endpointName"
        }
    }

    public struct DeleteEndpointAccessResponse: AWSDecodableShape {
        /// The deleted VPC endpoint.
        public let endpoint: EndpointAccess?

        @inlinable
        public init(endpoint: EndpointAccess? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
        }
    }

    public struct DeleteNamespaceRequest: AWSEncodableShape {
        /// The name of the snapshot to be created before the namespace is deleted.
        public let finalSnapshotName: String?
        /// How long to retain the final snapshot.
        public let finalSnapshotRetentionPeriod: Int?
        /// The name of the namespace to delete.
        public let namespaceName: String

        @inlinable
        public init(finalSnapshotName: String? = nil, finalSnapshotRetentionPeriod: Int? = nil, namespaceName: String) {
            self.finalSnapshotName = finalSnapshotName
            self.finalSnapshotRetentionPeriod = finalSnapshotRetentionPeriod
            self.namespaceName = namespaceName
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case finalSnapshotName = "finalSnapshotName"
            case finalSnapshotRetentionPeriod = "finalSnapshotRetentionPeriod"
            case namespaceName = "namespaceName"
        }
    }

    public struct DeleteNamespaceResponse: AWSDecodableShape {
        /// The deleted namespace object.
        public let namespace: Namespace

        @inlinable
        public init(namespace: Namespace) {
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the policy to delete.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteScheduledActionRequest: AWSEncodableShape {
        /// The name of the scheduled action to delete.
        public let scheduledActionName: String

        @inlinable
        public init(scheduledActionName: String) {
            self.scheduledActionName = scheduledActionName
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, max: 60)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, min: 3)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledActionName = "scheduledActionName"
        }
    }

    public struct DeleteScheduledActionResponse: AWSDecodableShape {
        /// The deleted scheduled action object.
        public let scheduledAction: ScheduledActionResponse?

        @inlinable
        public init(scheduledAction: ScheduledActionResponse? = nil) {
            self.scheduledAction = scheduledAction
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledAction = "scheduledAction"
        }
    }

    public struct DeleteSnapshotCopyConfigurationRequest: AWSEncodableShape {
        /// The ID of the snapshot copy configuration to delete.
        public let snapshotCopyConfigurationId: String

        @inlinable
        public init(snapshotCopyConfigurationId: String) {
            self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotCopyConfigurationId = "snapshotCopyConfigurationId"
        }
    }

    public struct DeleteSnapshotCopyConfigurationResponse: AWSDecodableShape {
        /// The deleted snapshot copy configuration object.
        public let snapshotCopyConfiguration: SnapshotCopyConfiguration

        @inlinable
        public init(snapshotCopyConfiguration: SnapshotCopyConfiguration) {
            self.snapshotCopyConfiguration = snapshotCopyConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotCopyConfiguration = "snapshotCopyConfiguration"
        }
    }

    public struct DeleteSnapshotRequest: AWSEncodableShape {
        /// The name of the snapshot to be deleted.
        public let snapshotName: String

        @inlinable
        public init(snapshotName: String) {
            self.snapshotName = snapshotName
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotName = "snapshotName"
        }
    }

    public struct DeleteSnapshotResponse: AWSDecodableShape {
        /// The deleted snapshot object.
        public let snapshot: Snapshot?

        @inlinable
        public init(snapshot: Snapshot? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "snapshot"
        }
    }

    public struct DeleteUsageLimitRequest: AWSEncodableShape {
        /// The unique identifier of the usage limit to delete.
        public let usageLimitId: String

        @inlinable
        public init(usageLimitId: String) {
            self.usageLimitId = usageLimitId
        }

        private enum CodingKeys: String, CodingKey {
            case usageLimitId = "usageLimitId"
        }
    }

    public struct DeleteUsageLimitResponse: AWSDecodableShape {
        /// The deleted usage limit object.
        public let usageLimit: UsageLimit?

        @inlinable
        public init(usageLimit: UsageLimit? = nil) {
            self.usageLimit = usageLimit
        }

        private enum CodingKeys: String, CodingKey {
            case usageLimit = "usageLimit"
        }
    }

    public struct DeleteWorkgroupRequest: AWSEncodableShape {
        /// The name of the workgroup to be deleted.
        public let workgroupName: String

        @inlinable
        public init(workgroupName: String) {
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workgroupName = "workgroupName"
        }
    }

    public struct DeleteWorkgroupResponse: AWSDecodableShape {
        /// The deleted workgroup object.
        public let workgroup: Workgroup

        @inlinable
        public init(workgroup: Workgroup) {
            self.workgroup = workgroup
        }

        private enum CodingKeys: String, CodingKey {
            case workgroup = "workgroup"
        }
    }

    public struct Endpoint: AWSDecodableShape {
        /// The DNS address of the VPC endpoint.
        public let address: String?
        /// The port that Amazon Redshift Serverless listens on.
        public let port: Int?
        /// An array of VpcEndpoint objects.
        public let vpcEndpoints: [VpcEndpoint]?

        @inlinable
        public init(address: String? = nil, port: Int? = nil, vpcEndpoints: [VpcEndpoint]? = nil) {
            self.address = address
            self.port = port
            self.vpcEndpoints = vpcEndpoints
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
            case port = "port"
            case vpcEndpoints = "vpcEndpoints"
        }
    }

    public struct EndpointAccess: AWSDecodableShape {
        /// The DNS address of the endpoint.
        public let address: String?
        /// The Amazon Resource Name (ARN) of the VPC endpoint.
        public let endpointArn: String?
        /// The time that the endpoint was created.
        public let endpointCreateTime: Date?
        /// The name of the VPC endpoint.
        public let endpointName: String?
        /// The status of the VPC endpoint.
        public let endpointStatus: String?
        /// The port number on which Amazon Redshift Serverless accepts incoming connections.
        public let port: Int?
        /// The unique identifier of subnets  where Amazon Redshift Serverless choose to deploy the VPC endpoint.
        public let subnetIds: [String]?
        /// The connection endpoint for connecting to Amazon Redshift Serverless.
        public let vpcEndpoint: VpcEndpoint?
        /// The security groups associated with the endpoint.
        public let vpcSecurityGroups: [VpcSecurityGroupMembership]?
        /// The name of the workgroup associated with the endpoint.
        public let workgroupName: String?

        @inlinable
        public init(address: String? = nil, endpointArn: String? = nil, endpointCreateTime: Date? = nil, endpointName: String? = nil, endpointStatus: String? = nil, port: Int? = nil, subnetIds: [String]? = nil, vpcEndpoint: VpcEndpoint? = nil, vpcSecurityGroups: [VpcSecurityGroupMembership]? = nil, workgroupName: String? = nil) {
            self.address = address
            self.endpointArn = endpointArn
            self.endpointCreateTime = endpointCreateTime
            self.endpointName = endpointName
            self.endpointStatus = endpointStatus
            self.port = port
            self.subnetIds = subnetIds
            self.vpcEndpoint = vpcEndpoint
            self.vpcSecurityGroups = vpcSecurityGroups
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case address = "address"
            case endpointArn = "endpointArn"
            case endpointCreateTime = "endpointCreateTime"
            case endpointName = "endpointName"
            case endpointStatus = "endpointStatus"
            case port = "port"
            case subnetIds = "subnetIds"
            case vpcEndpoint = "vpcEndpoint"
            case vpcSecurityGroups = "vpcSecurityGroups"
            case workgroupName = "workgroupName"
        }
    }

    public struct GetCredentialsRequest: AWSEncodableShape {
        /// The custom domain name associated with the workgroup. The custom domain name or the workgroup name must be included in the request.
        public let customDomainName: String?
        /// The name of the database to get temporary authorization to log on to. Constraints:   Must be 1 to 64 alphanumeric characters or hyphens.   Must contain only uppercase or lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.   The first character must be a letter.   Must not contain a colon ( : ) or slash ( / ).   Cannot be a reserved word. A list of reserved words can be found  in Reserved Words   in the Amazon Redshift Database Developer Guide
        public let dbName: String?
        /// The number of seconds until the returned temporary password expires. The minimum is 900 seconds, and the maximum is 3600 seconds.
        public let durationSeconds: Int?
        /// The name of the workgroup associated with the database.
        public let workgroupName: String?

        @inlinable
        public init(customDomainName: String? = nil, dbName: String? = nil, durationSeconds: Int? = nil, workgroupName: String? = nil) {
            self.customDomainName = customDomainName
            self.dbName = dbName
            self.durationSeconds = durationSeconds
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 253)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 1)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainName = "customDomainName"
            case dbName = "dbName"
            case durationSeconds = "durationSeconds"
            case workgroupName = "workgroupName"
        }
    }

    public struct GetCredentialsResponse: AWSDecodableShape {
        /// A temporary password that authorizes the user name returned by  DbUser to log on to the database DbName.
        public let dbPassword: String?
        /// A database user name that is authorized to log on to the database DbName using the password DbPassword. If the specified DbUser exists in the database,  the new user name has the same database privileges as the the user named in  DbUser. By default, the user is added to PUBLIC.
        public let dbUser: String?
        /// The date and time the password in DbPassword expires.
        public let expiration: Date?
        /// The date and time of when the DbUser and DbPassword  authorization refreshes.
        public let nextRefreshTime: Date?

        @inlinable
        public init(dbPassword: String? = nil, dbUser: String? = nil, expiration: Date? = nil, nextRefreshTime: Date? = nil) {
            self.dbPassword = dbPassword
            self.dbUser = dbUser
            self.expiration = expiration
            self.nextRefreshTime = nextRefreshTime
        }

        private enum CodingKeys: String, CodingKey {
            case dbPassword = "dbPassword"
            case dbUser = "dbUser"
            case expiration = "expiration"
            case nextRefreshTime = "nextRefreshTime"
        }
    }

    public struct GetCustomDomainAssociationRequest: AWSEncodableShape {
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String
        /// The name of the workgroup associated with the database.
        public let workgroupName: String

        @inlinable
        public init(customDomainName: String, workgroupName: String) {
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 253)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 1)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct GetCustomDomainAssociationResponse: AWSDecodableShape {
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public let customDomainCertificateArn: String?
        /// The expiration time for the certificate.
        public let customDomainCertificateExpiryTime: Date?
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String?
        /// The name of the workgroup associated with the database.
        public let workgroupName: String?

        @inlinable
        public init(customDomainCertificateArn: String? = nil, customDomainCertificateExpiryTime: Date? = nil, customDomainName: String? = nil, workgroupName: String? = nil) {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainCertificateExpiryTime = "customDomainCertificateExpiryTime"
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct GetEndpointAccessRequest: AWSEncodableShape {
        /// The name of the VPC endpoint to return information for.
        public let endpointName: String

        @inlinable
        public init(endpointName: String) {
            self.endpointName = endpointName
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "endpointName"
        }
    }

    public struct GetEndpointAccessResponse: AWSDecodableShape {
        /// The returned VPC endpoint.
        public let endpoint: EndpointAccess?

        @inlinable
        public init(endpoint: EndpointAccess? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
        }
    }

    public struct GetNamespaceRequest: AWSEncodableShape {
        /// The name of the namespace to retrieve information for.
        public let namespaceName: String

        @inlinable
        public init(namespaceName: String) {
            self.namespaceName = namespaceName
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
        }
    }

    public struct GetNamespaceResponse: AWSDecodableShape {
        /// The returned namespace object.
        public let namespace: Namespace

        @inlinable
        public init(namespace: Namespace) {
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
        }
    }

    public struct GetRecoveryPointRequest: AWSEncodableShape {
        /// The unique identifier of the recovery point to return information for.
        public let recoveryPointId: String

        @inlinable
        public init(recoveryPointId: String) {
            self.recoveryPointId = recoveryPointId
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryPointId = "recoveryPointId"
        }
    }

    public struct GetRecoveryPointResponse: AWSDecodableShape {
        /// The returned recovery point object.
        public let recoveryPoint: RecoveryPoint?

        @inlinable
        public init(recoveryPoint: RecoveryPoint? = nil) {
            self.recoveryPoint = recoveryPoint
        }

        private enum CodingKeys: String, CodingKey {
            case recoveryPoint = "recoveryPoint"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to return.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The returned resource policy.
        public let resourcePolicy: ResourcePolicy?

        @inlinable
        public init(resourcePolicy: ResourcePolicy? = nil) {
            self.resourcePolicy = resourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "resourcePolicy"
        }
    }

    public struct GetScheduledActionRequest: AWSEncodableShape {
        /// The name of the scheduled action.
        public let scheduledActionName: String

        @inlinable
        public init(scheduledActionName: String) {
            self.scheduledActionName = scheduledActionName
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, max: 60)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, min: 3)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledActionName = "scheduledActionName"
        }
    }

    public struct GetScheduledActionResponse: AWSDecodableShape {
        /// The returned scheduled action object.
        public let scheduledAction: ScheduledActionResponse?

        @inlinable
        public init(scheduledAction: ScheduledActionResponse? = nil) {
            self.scheduledAction = scheduledAction
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledAction = "scheduledAction"
        }
    }

    public struct GetSnapshotRequest: AWSEncodableShape {
        /// The owner Amazon Web Services account of a snapshot shared with another user.
        public let ownerAccount: String?
        /// The Amazon Resource Name (ARN) of the snapshot to return.
        public let snapshotArn: String?
        /// The name of the snapshot to return.
        public let snapshotName: String?

        @inlinable
        public init(ownerAccount: String? = nil, snapshotArn: String? = nil, snapshotName: String? = nil) {
            self.ownerAccount = ownerAccount
            self.snapshotArn = snapshotArn
            self.snapshotName = snapshotName
        }

        private enum CodingKeys: String, CodingKey {
            case ownerAccount = "ownerAccount"
            case snapshotArn = "snapshotArn"
            case snapshotName = "snapshotName"
        }
    }

    public struct GetSnapshotResponse: AWSDecodableShape {
        /// The returned snapshot object.
        public let snapshot: Snapshot?

        @inlinable
        public init(snapshot: Snapshot? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "snapshot"
        }
    }

    public struct GetTableRestoreStatusRequest: AWSEncodableShape {
        /// The ID of the RestoreTableFromSnapshot request to return status for.
        public let tableRestoreRequestId: String

        @inlinable
        public init(tableRestoreRequestId: String) {
            self.tableRestoreRequestId = tableRestoreRequestId
        }

        private enum CodingKeys: String, CodingKey {
            case tableRestoreRequestId = "tableRestoreRequestId"
        }
    }

    public struct GetTableRestoreStatusResponse: AWSDecodableShape {
        /// The returned TableRestoreStatus object that contains information about the status of your RestoreTableFromSnapshot request.
        public let tableRestoreStatus: TableRestoreStatus?

        @inlinable
        public init(tableRestoreStatus: TableRestoreStatus? = nil) {
            self.tableRestoreStatus = tableRestoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tableRestoreStatus = "tableRestoreStatus"
        }
    }

    public struct GetTrackRequest: AWSEncodableShape {
        /// The name of the track of which its version is fetched.
        public let trackName: String

        @inlinable
        public init(trackName: String) {
            self.trackName = trackName
        }

        public func validate(name: String) throws {
            try self.validate(self.trackName, name: "trackName", parent: name, max: 256)
            try self.validate(self.trackName, name: "trackName", parent: name, min: 1)
            try self.validate(self.trackName, name: "trackName", parent: name, pattern: "^[a-zA-Z0-9_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case trackName = "trackName"
        }
    }

    public struct GetTrackResponse: AWSDecodableShape {
        /// The version of the specified track.
        public let track: ServerlessTrack?

        @inlinable
        public init(track: ServerlessTrack? = nil) {
            self.track = track
        }

        private enum CodingKeys: String, CodingKey {
            case track = "track"
        }
    }

    public struct GetUsageLimitRequest: AWSEncodableShape {
        /// The unique identifier of the usage limit to return information for.
        public let usageLimitId: String

        @inlinable
        public init(usageLimitId: String) {
            self.usageLimitId = usageLimitId
        }

        private enum CodingKeys: String, CodingKey {
            case usageLimitId = "usageLimitId"
        }
    }

    public struct GetUsageLimitResponse: AWSDecodableShape {
        /// The returned usage limit object.
        public let usageLimit: UsageLimit?

        @inlinable
        public init(usageLimit: UsageLimit? = nil) {
            self.usageLimit = usageLimit
        }

        private enum CodingKeys: String, CodingKey {
            case usageLimit = "usageLimit"
        }
    }

    public struct GetWorkgroupRequest: AWSEncodableShape {
        /// The name of the workgroup to return information for.
        public let workgroupName: String

        @inlinable
        public init(workgroupName: String) {
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case workgroupName = "workgroupName"
        }
    }

    public struct GetWorkgroupResponse: AWSDecodableShape {
        /// The returned workgroup object.
        public let workgroup: Workgroup

        @inlinable
        public init(workgroup: Workgroup) {
            self.workgroup = workgroup
        }

        private enum CodingKeys: String, CodingKey {
            case workgroup = "workgroup"
        }
    }

    public struct ListCustomDomainAssociationsRequest: AWSEncodableShape {
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public let customDomainCertificateArn: String?
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String?
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// When nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(customDomainCertificateArn: String? = nil, customDomainName: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainName = customDomainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.customDomainCertificateArn, forKey: .customDomainCertificateArn)
            try container.encodeIfPresent(self.customDomainName, forKey: .customDomainName)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, max: 2048)
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, min: 20)
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, pattern: "arn:[\\w+=/,.@-]+:acm:[\\w+=/,.@-]*:[0-9]+:[\\w+=,.@-]+(/[\\w+=,.@-]+)*")
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 253)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 1)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainName = "customDomainName"
        }
    }

    public struct ListCustomDomainAssociationsResponse: AWSDecodableShape {
        /// A list of Association objects.
        public let associations: [Association]?
        /// When nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(associations: [Association]? = nil, nextToken: String? = nil) {
            self.associations = associations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case associations = "associations"
            case nextToken = "nextToken"
        }
    }

    public struct ListEndpointAccessRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// If your initial ListEndpointAccess operation returns a nextToken, you can include the returned nextToken in following ListEndpointAccess operations, which returns results in the next page.
        public let nextToken: String?
        /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
        public let ownerAccount: String?
        /// The unique identifier of the virtual private cloud with access to Amazon Redshift Serverless.
        public let vpcId: String?
        /// The name of the workgroup associated with the VPC endpoint to return.
        public let workgroupName: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, ownerAccount: String? = nil, vpcId: String? = nil, workgroupName: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerAccount = ownerAccount
            self.vpcId = vpcId
            self.workgroupName = workgroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.ownerAccount, forKey: .ownerAccount)
            try container.encodeIfPresent(self.vpcId, forKey: .vpcId)
            try container.encodeIfPresent(self.workgroupName, forKey: .workgroupName)
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "(\\d{12})")
        }

        private enum CodingKeys: String, CodingKey {
            case ownerAccount = "ownerAccount"
            case vpcId = "vpcId"
            case workgroupName = "workgroupName"
        }
    }

    public struct ListEndpointAccessResponse: AWSDecodableShape {
        /// The returned VPC endpoints.
        public let endpoints: [EndpointAccess]
        /// When nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(endpoints: [EndpointAccess], nextToken: String? = nil) {
            self.endpoints = endpoints
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case endpoints = "endpoints"
            case nextToken = "nextToken"
        }
    }

    public struct ListManagedWorkgroupsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number  of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// If your initial ListManagedWorkgroups operation returns a nextToken,  you can include the returned nextToken in following ListManagedWorkgroups  operations, which returns results in the next page.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) for the managed  workgroup in the AWS Glue Data Catalog.
        public let sourceArn: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, sourceArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sourceArn = sourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.sourceArn, forKey: .sourceArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 8)
            try self.validate(self.sourceArn, name: "sourceArn", parent: name, pattern: "^arn:aws[a-z-]*:glue:[a-z0-9-]+:\\d+:(database|catalog)[a-z0-9-:]*(?:/[A-Za-z0-9-_]{1,255})*$")
        }

        private enum CodingKeys: String, CodingKey {
            case sourceArn = "sourceArn"
        }
    }

    public struct ListManagedWorkgroupsResponse: AWSDecodableShape {
        /// The returned array of managed workgroups.
        public let managedWorkgroups: [ManagedWorkgroupListItem]?
        /// If nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page. To retrieve the next page, make the call again using the returned token.
        public let nextToken: String?

        @inlinable
        public init(managedWorkgroups: [ManagedWorkgroupListItem]? = nil, nextToken: String? = nil) {
            self.managedWorkgroups = managedWorkgroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case managedWorkgroups = "managedWorkgroups"
            case nextToken = "nextToken"
        }
    }

    public struct ListNamespacesRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// If your initial ListNamespaces operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListNamespacesResponse: AWSDecodableShape {
        /// The list of returned namespaces.
        public let namespaces: [Namespace]
        /// When nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(namespaces: [Namespace], nextToken: String? = nil) {
            self.namespaces = namespaces
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case namespaces = "namespaces"
            case nextToken = "nextToken"
        }
    }

    public struct ListRecoveryPointsRequest: AWSEncodableShape {
        /// The time when creation of the recovery point finished.
        public let endTime: Date?
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// The Amazon Resource Name (ARN) of the namespace from which to list recovery points.
        public let namespaceArn: String?
        /// The name of the namespace to list recovery points for.
        public let namespaceName: String?
        /// If your initial ListRecoveryPoints operation returns a nextToken, you can include the returned nextToken in following ListRecoveryPoints operations, which returns results in the next page.
        public let nextToken: String?
        /// The time when the recovery point's creation was initiated.
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, maxResults: Int? = nil, namespaceArn: String? = nil, namespaceName: String? = nil, nextToken: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.maxResults = maxResults
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.endTime, forKey: .endTime)
            request.encodeQuery(self.maxResults, key: "maxResults")
            try container.encodeIfPresent(self.namespaceArn, forKey: .namespaceArn)
            try container.encodeIfPresent(self.namespaceName, forKey: .namespaceName)
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.startTime, forKey: .startTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
            case startTime = "startTime"
        }
    }

    public struct ListRecoveryPointsResponse: AWSDecodableShape {
        /// If nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The returned recovery point objects.
        public let recoveryPoints: [RecoveryPoint]?

        @inlinable
        public init(nextToken: String? = nil, recoveryPoints: [RecoveryPoint]? = nil) {
            self.nextToken = nextToken
            self.recoveryPoints = recoveryPoints
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case recoveryPoints = "recoveryPoints"
        }
    }

    public struct ListScheduledActionsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. Use nextToken to display the next page of results.
        public let maxResults: Int?
        /// The name of namespace associated with the scheduled action to retrieve.
        public let namespaceName: String?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, namespaceName: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.namespaceName = namespaceName
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            try container.encodeIfPresent(self.namespaceName, forKey: .namespaceName)
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
        }
    }

    public struct ListScheduledActionsResponse: AWSDecodableShape {
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// All of the returned scheduled action association objects.
        public let scheduledActions: [ScheduledActionAssociation]?

        @inlinable
        public init(nextToken: String? = nil, scheduledActions: [ScheduledActionAssociation]? = nil) {
            self.nextToken = nextToken
            self.scheduledActions = scheduledActions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case scheduledActions = "scheduledActions"
        }
    }

    public struct ListSnapshotCopyConfigurationsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// The namespace from which to list all snapshot copy configurations.
        public let namespaceName: String?
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using  the returned token to retrieve the next page.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, namespaceName: String? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.namespaceName = namespaceName
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            try container.encodeIfPresent(self.namespaceName, forKey: .namespaceName)
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
        }
    }

    public struct ListSnapshotCopyConfigurationsResponse: AWSDecodableShape {
        /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using  the returned token to retrieve the next page.
        public let nextToken: String?
        /// All of the returned snapshot copy configurations.
        public let snapshotCopyConfigurations: [SnapshotCopyConfiguration]

        @inlinable
        public init(nextToken: String? = nil, snapshotCopyConfigurations: [SnapshotCopyConfiguration]) {
            self.nextToken = nextToken
            self.snapshotCopyConfigurations = snapshotCopyConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case snapshotCopyConfigurations = "snapshotCopyConfigurations"
        }
    }

    public struct ListSnapshotsRequest: AWSEncodableShape {
        /// The timestamp showing when the snapshot creation finished.
        public let endTime: Date?
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// The Amazon Resource Name (ARN) of the namespace from which to list all snapshots.
        public let namespaceArn: String?
        /// The namespace from which to list all snapshots.
        public let namespaceName: String?
        /// If nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The owner Amazon Web Services account of the snapshot.
        public let ownerAccount: String?
        /// The time when the creation of the snapshot was initiated.
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, maxResults: Int? = nil, namespaceArn: String? = nil, namespaceName: String? = nil, nextToken: String? = nil, ownerAccount: String? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.maxResults = maxResults
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.nextToken = nextToken
            self.ownerAccount = ownerAccount
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.endTime, forKey: .endTime)
            request.encodeQuery(self.maxResults, key: "maxResults")
            try container.encodeIfPresent(self.namespaceArn, forKey: .namespaceArn)
            try container.encodeIfPresent(self.namespaceName, forKey: .namespaceName)
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.ownerAccount, forKey: .ownerAccount)
            try container.encodeIfPresent(self.startTime, forKey: .startTime)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
            case ownerAccount = "ownerAccount"
            case startTime = "startTime"
        }
    }

    public struct ListSnapshotsResponse: AWSDecodableShape {
        /// If nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// All of the returned snapshot objects.
        public let snapshots: [Snapshot]?

        @inlinable
        public init(nextToken: String? = nil, snapshots: [Snapshot]? = nil) {
            self.nextToken = nextToken
            self.snapshots = snapshots
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case snapshots = "snapshots"
        }
    }

    public struct ListTableRestoreStatusRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to  return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// The namespace from which to list all of the statuses of RestoreTableFromSnapshot operations .
        public let namespaceName: String?
        /// If your initial ListTableRestoreStatus operation returns a nextToken,  you can include the returned nextToken in following ListTableRestoreStatus operations. This will return results on the next page.
        public let nextToken: String?
        /// The workgroup from which to list all of the statuses of RestoreTableFromSnapshot operations.
        public let workgroupName: String?

        @inlinable
        public init(maxResults: Int? = nil, namespaceName: String? = nil, nextToken: String? = nil, workgroupName: String? = nil) {
            self.maxResults = maxResults
            self.namespaceName = namespaceName
            self.nextToken = nextToken
            self.workgroupName = workgroupName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            try container.encodeIfPresent(self.namespaceName, forKey: .namespaceName)
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.workgroupName, forKey: .workgroupName)
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
            case workgroupName = "workgroupName"
        }
    }

    public struct ListTableRestoreStatusResponse: AWSDecodableShape {
        /// If your initial ListTableRestoreStatus operation returns a nextToken,  you can include the returned nextToken in following ListTableRestoreStatus operations. This will returns results on the next page.
        public let nextToken: String?
        /// The array of returned TableRestoreStatus objects.
        public let tableRestoreStatuses: [TableRestoreStatus]?

        @inlinable
        public init(nextToken: String? = nil, tableRestoreStatuses: [TableRestoreStatus]? = nil) {
            self.nextToken = nextToken
            self.tableRestoreStatuses = tableRestoreStatuses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tableRestoreStatuses = "tableRestoreStatuses"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A map of the key-value pairs assigned to the resource.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTracksRequest: AWSEncodableShape {
        /// The maximum number of response records to return in each call.  If the number of remaining response records exceeds the specified  MaxRecords value, a value is returned in a marker field of the response.  You can retrieve the next set of records by retrying the command with the  returned marker value.
        public let maxResults: Int?
        /// If your initial ListTracksRequest operation returns a  nextToken, you can include the returned nextToken in following ListTracksRequest operations, which returns results in the next page.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 8)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTracksResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// The returned tracks.
        public let tracks: [ServerlessTrack]?

        @inlinable
        public init(nextToken: String? = nil, tracks: [ServerlessTrack]? = nil) {
            self.nextToken = nextToken
            self.tracks = tracks
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case tracks = "tracks"
        }
    }

    public struct ListUsageLimitsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to get the next page of results. The default is 100.
        public let maxResults: Int?
        /// If your initial ListUsageLimits operation returns a nextToken, you can include the returned nextToken in following ListUsageLimits operations, which returns results in the next page.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) associated with the resource whose usage limits you want to list.
        public let resourceArn: String?
        /// The Amazon Redshift Serverless feature whose limits you want to see.
        public let usageType: UsageLimitUsageType?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceArn: String? = nil, usageType: UsageLimitUsageType? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceArn = resourceArn
            self.usageType = usageType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.resourceArn, forKey: .resourceArn)
            try container.encodeIfPresent(self.usageType, forKey: .usageType)
        }

        public func validate(name: String) throws {
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 8)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case usageType = "usageType"
        }
    }

    public struct ListUsageLimitsResponse: AWSDecodableShape {
        /// When nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  Make the call again using the returned token to retrieve the next page.
        public let nextToken: String?
        /// An array of returned usage limit objects.
        public let usageLimits: [UsageLimit]?

        @inlinable
        public init(nextToken: String? = nil, usageLimits: [UsageLimit]? = nil) {
            self.nextToken = nextToken
            self.usageLimits = usageLimits
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case usageLimits = "usageLimits"
        }
    }

    public struct ListWorkgroupsRequest: AWSEncodableShape {
        /// An optional parameter that specifies the maximum number of results to return. You can use nextToken to display the next page of results.
        public let maxResults: Int?
        /// If your initial ListWorkgroups operation returns a nextToken, you can include the returned nextToken in following ListNamespaces operations, which returns results in the next page.
        public let nextToken: String?
        /// The owner Amazon Web Services account for the Amazon Redshift Serverless workgroup.
        public let ownerAccount: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, ownerAccount: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.ownerAccount = ownerAccount
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            try container.encodeIfPresent(self.ownerAccount, forKey: .ownerAccount)
        }

        public func validate(name: String) throws {
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, max: 12)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, min: 1)
            try self.validate(self.ownerAccount, name: "ownerAccount", parent: name, pattern: "(\\d{12})")
        }

        private enum CodingKeys: String, CodingKey {
            case ownerAccount = "ownerAccount"
        }
    }

    public struct ListWorkgroupsResponse: AWSDecodableShape {
        ///  If nextToken is returned, there are more results available.  The value of nextToken is a unique pagination token for each page.  To retrieve the next page, make the call again using the returned token.
        public let nextToken: String?
        /// The returned array of workgroups.
        public let workgroups: [Workgroup]

        @inlinable
        public init(nextToken: String? = nil, workgroups: [Workgroup]) {
            self.nextToken = nextToken
            self.workgroups = workgroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case workgroups = "workgroups"
        }
    }

    public struct ManagedWorkgroupListItem: AWSDecodableShape {
        /// The creation date of the managed workgroup.
        public let creationDate: Date?
        /// The unique identifier of the managed workgroup.
        public let managedWorkgroupId: String?
        /// The name of the managed workgroup.
        public let managedWorkgroupName: String?
        /// The Amazon Resource Name (ARN) for the managed  workgroup in the AWS Glue Data Catalog.
        public let sourceArn: String?
        /// The status of the managed workgroup.
        public let status: ManagedWorkgroupStatus?

        @inlinable
        public init(creationDate: Date? = nil, managedWorkgroupId: String? = nil, managedWorkgroupName: String? = nil, sourceArn: String? = nil, status: ManagedWorkgroupStatus? = nil) {
            self.creationDate = creationDate
            self.managedWorkgroupId = managedWorkgroupId
            self.managedWorkgroupName = managedWorkgroupName
            self.sourceArn = sourceArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "creationDate"
            case managedWorkgroupId = "managedWorkgroupId"
            case managedWorkgroupName = "managedWorkgroupName"
            case sourceArn = "sourceArn"
            case status = "status"
        }
    }

    public struct Namespace: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the namespace's admin user credentials secret.
        public let adminPasswordSecretArn: String?
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
        public let adminPasswordSecretKmsKeyId: String?
        /// The username of the administrator for the first database created in the namespace.
        public let adminUsername: String?
        /// The date of when the namespace was created.
        public let creationDate: Date?
        /// The name of the first database created in the namespace.
        public let dbName: String?
        /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.
        public let defaultIamRoleArn: String?
        /// A list of IAM roles to associate with the namespace.
        public let iamRoles: [String]?
        /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
        public let kmsKeyId: String?
        /// The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.
        public let logExports: [LogExport]?
        /// The Amazon Resource Name (ARN) associated with a namespace.
        public let namespaceArn: String?
        /// The unique identifier of a namespace.
        public let namespaceId: String?
        /// The name of the namespace.  Must be between 3-64 alphanumeric characters in lowercase,  and it cannot be a reserved word. A list of reserved words can be found  in Reserved Words in the Amazon Redshift Database Developer Guide.
        public let namespaceName: String?
        /// The status of the namespace.
        public let status: NamespaceStatus?

        @inlinable
        public init(adminPasswordSecretArn: String? = nil, adminPasswordSecretKmsKeyId: String? = nil, adminUsername: String? = nil, creationDate: Date? = nil, dbName: String? = nil, defaultIamRoleArn: String? = nil, iamRoles: [String]? = nil, kmsKeyId: String? = nil, logExports: [LogExport]? = nil, namespaceArn: String? = nil, namespaceId: String? = nil, namespaceName: String? = nil, status: NamespaceStatus? = nil) {
            self.adminPasswordSecretArn = adminPasswordSecretArn
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.creationDate = creationDate
            self.dbName = dbName
            self.defaultIamRoleArn = defaultIamRoleArn
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.logExports = logExports
            self.namespaceArn = namespaceArn
            self.namespaceId = namespaceId
            self.namespaceName = namespaceName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case adminPasswordSecretArn = "adminPasswordSecretArn"
            case adminPasswordSecretKmsKeyId = "adminPasswordSecretKmsKeyId"
            case adminUsername = "adminUsername"
            case creationDate = "creationDate"
            case dbName = "dbName"
            case defaultIamRoleArn = "defaultIamRoleArn"
            case iamRoles = "iamRoles"
            case kmsKeyId = "kmsKeyId"
            case logExports = "logExports"
            case namespaceArn = "namespaceArn"
            case namespaceId = "namespaceId"
            case namespaceName = "namespaceName"
            case status = "status"
        }
    }

    public struct NetworkInterface: AWSDecodableShape {
        /// The availability Zone.
        public let availabilityZone: String?
        /// The IPv6 address of the network interface within the subnet.
        public let ipv6Address: String?
        /// The unique identifier of the network interface.
        public let networkInterfaceId: String?
        /// The IPv4 address of the network interface within the subnet.
        public let privateIpAddress: String?
        /// The unique identifier of the subnet.
        public let subnetId: String?

        @inlinable
        public init(availabilityZone: String? = nil, ipv6Address: String? = nil, networkInterfaceId: String? = nil, privateIpAddress: String? = nil, subnetId: String? = nil) {
            self.availabilityZone = availabilityZone
            self.ipv6Address = ipv6Address
            self.networkInterfaceId = networkInterfaceId
            self.privateIpAddress = privateIpAddress
            self.subnetId = subnetId
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZone = "availabilityZone"
            case ipv6Address = "ipv6Address"
            case networkInterfaceId = "networkInterfaceId"
            case privateIpAddress = "privateIpAddress"
            case subnetId = "subnetId"
        }
    }

    public struct PerformanceTarget: AWSEncodableShape & AWSDecodableShape {
        /// The target price performance level for the workgroup. Valid values include 1, 25, 50, 75, and 100. These correspond to the price performance levels LOW_COST, ECONOMICAL, BALANCED, RESOURCEFUL, and HIGH_PERFORMANCE.
        public let level: Int?
        /// Whether the price performance target is enabled for the workgroup.
        public let status: PerformanceTargetStatus?

        @inlinable
        public init(level: Int? = nil, status: PerformanceTargetStatus? = nil) {
            self.level = level
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case level = "level"
            case status = "status"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// The policy to create or update. For example, the following policy grants a user authorization to restore a snapshot.  "{\"Version\": \"2012-10-17\", \"Statement\" :  [{ \"Sid\": \"AllowUserRestoreFromSnapshot\", \"Principal\":{\"AWS\":  [\"739247239426\"]}, \"Action\": [\"redshift-serverless:RestoreFromSnapshot\"] , \"Effect\": \"Allow\" }]}"
        public let policy: String
        /// The Amazon Resource Name (ARN) of the account to create or update a resource policy for.
        public let resourceArn: String

        @inlinable
        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case resourceArn = "resourceArn"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        /// The policy that was created or updated.
        public let resourcePolicy: ResourcePolicy?

        @inlinable
        public init(resourcePolicy: ResourcePolicy? = nil) {
            self.resourcePolicy = resourcePolicy
        }

        private enum CodingKeys: String, CodingKey {
            case resourcePolicy = "resourcePolicy"
        }
    }

    public struct RecoveryPoint: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the namespace the recovery point is associated with.
        public let namespaceArn: String?
        /// The name of the namespace the recovery point is associated with.
        public let namespaceName: String?
        /// The time the recovery point is created.
        public let recoveryPointCreateTime: Date?
        /// The unique identifier of the recovery point.
        public let recoveryPointId: String?
        /// The total size of the data in the recovery point in megabytes.
        public let totalSizeInMegaBytes: Double?
        /// The name of the workgroup the recovery point is associated with.
        public let workgroupName: String?

        @inlinable
        public init(namespaceArn: String? = nil, namespaceName: String? = nil, recoveryPointCreateTime: Date? = nil, recoveryPointId: String? = nil, totalSizeInMegaBytes: Double? = nil, workgroupName: String? = nil) {
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.recoveryPointCreateTime = recoveryPointCreateTime
            self.recoveryPointId = recoveryPointId
            self.totalSizeInMegaBytes = totalSizeInMegaBytes
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
            case recoveryPointCreateTime = "recoveryPointCreateTime"
            case recoveryPointId = "recoveryPointId"
            case totalSizeInMegaBytes = "totalSizeInMegaBytes"
            case workgroupName = "workgroupName"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The name of the resource that could not be found.
        public let resourceName: String?

        @inlinable
        public init(message: String, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct ResourcePolicy: AWSDecodableShape {
        /// The resource policy.
        public let policy: String?
        /// The Amazon Resource Name (ARN) of the policy.
        public let resourceArn: String?

        @inlinable
        public init(policy: String? = nil, resourceArn: String? = nil) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case resourceArn = "resourceArn"
        }
    }

    public struct RestoreFromRecoveryPointRequest: AWSEncodableShape {
        /// The name of the namespace to restore data into.
        public let namespaceName: String
        /// The unique identifier of the recovery point to restore from.
        public let recoveryPointId: String
        /// The name of the workgroup used to restore data.
        public let workgroupName: String

        @inlinable
        public init(namespaceName: String, recoveryPointId: String, workgroupName: String) {
            self.namespaceName = namespaceName
            self.recoveryPointId = recoveryPointId
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
            case recoveryPointId = "recoveryPointId"
            case workgroupName = "workgroupName"
        }
    }

    public struct RestoreFromRecoveryPointResponse: AWSDecodableShape {
        /// The namespace that data was restored into.
        public let namespace: Namespace?
        /// The unique identifier of the recovery point used for the restore.
        public let recoveryPointId: String?

        @inlinable
        public init(namespace: Namespace? = nil, recoveryPointId: String? = nil) {
            self.namespace = namespace
            self.recoveryPointId = recoveryPointId
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
            case recoveryPointId = "recoveryPointId"
        }
    }

    public struct RestoreFromSnapshotRequest: AWSEncodableShape {
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
        public let adminPasswordSecretKmsKeyId: String?
        /// If true, Amazon Redshift uses Secrets Manager to manage the restored  snapshot's admin credentials. If MmanageAdminPassword is false or not set,  Amazon Redshift uses the admin credentials that the namespace or cluster  had at the time the snapshot was taken.
        public let manageAdminPassword: Bool?
        /// The name of the namespace to restore the snapshot to.
        public let namespaceName: String
        /// The Amazon Web Services account that owns the snapshot.
        public let ownerAccount: String?
        /// The Amazon Resource Name (ARN) of the snapshot to restore from. Required if restoring from Amazon Redshift Serverless to a provisioned cluster. Must not be specified at the same time as snapshotName. The format of the ARN is arn:aws:redshift:&lt;region&gt;:&lt;account_id&gt;:snapshot:&lt;cluster_identifier&gt;/&lt;snapshot_identifier&gt;.
        public let snapshotArn: String?
        /// The name of the snapshot to restore from. Must not be specified at the same time as snapshotArn.
        public let snapshotName: String?
        /// The name of the workgroup used to restore the snapshot.
        public let workgroupName: String

        @inlinable
        public init(adminPasswordSecretKmsKeyId: String? = nil, manageAdminPassword: Bool? = nil, namespaceName: String, ownerAccount: String? = nil, snapshotArn: String? = nil, snapshotName: String? = nil, workgroupName: String) {
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.manageAdminPassword = manageAdminPassword
            self.namespaceName = namespaceName
            self.ownerAccount = ownerAccount
            self.snapshotArn = snapshotArn
            self.snapshotName = snapshotName
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminPasswordSecretKmsKeyId = "adminPasswordSecretKmsKeyId"
            case manageAdminPassword = "manageAdminPassword"
            case namespaceName = "namespaceName"
            case ownerAccount = "ownerAccount"
            case snapshotArn = "snapshotArn"
            case snapshotName = "snapshotName"
            case workgroupName = "workgroupName"
        }
    }

    public struct RestoreFromSnapshotResponse: AWSDecodableShape {
        public let namespace: Namespace?
        /// The owner Amazon Web Services; account of the snapshot that was restored.
        public let ownerAccount: String?
        /// The name of the snapshot used to restore the namespace.
        public let snapshotName: String?

        @inlinable
        public init(namespace: Namespace? = nil, ownerAccount: String? = nil, snapshotName: String? = nil) {
            self.namespace = namespace
            self.ownerAccount = ownerAccount
            self.snapshotName = snapshotName
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
            case ownerAccount = "ownerAccount"
            case snapshotName = "snapshotName"
        }
    }

    public struct RestoreTableFromRecoveryPointRequest: AWSEncodableShape {
        /// Indicates whether name identifiers for database, schema, and table are case sensitive. If true, the names are case sensitive. If false, the names are not case sensitive. The default is false.
        public let activateCaseSensitiveIdentifier: Bool?
        /// Namespace of the recovery point to restore from.
        public let namespaceName: String
        /// The name of the table to create from the restore operation.
        public let newTableName: String
        /// The ID of the recovery point to restore the table from.
        public let recoveryPointId: String
        /// The name of the source database that contains the table being restored.
        public let sourceDatabaseName: String
        /// The name of the source schema that contains the table being restored.
        public let sourceSchemaName: String?
        /// The name of the source table being restored.
        public let sourceTableName: String
        /// The name of the database to restore the table to.
        public let targetDatabaseName: String?
        /// The name of the schema to restore the table to.
        public let targetSchemaName: String?
        /// The workgroup to restore the table to.
        public let workgroupName: String

        @inlinable
        public init(activateCaseSensitiveIdentifier: Bool? = nil, namespaceName: String, newTableName: String, recoveryPointId: String, sourceDatabaseName: String, sourceSchemaName: String? = nil, sourceTableName: String, targetDatabaseName: String? = nil, targetSchemaName: String? = nil, workgroupName: String) {
            self.activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifier
            self.namespaceName = namespaceName
            self.newTableName = newTableName
            self.recoveryPointId = recoveryPointId
            self.sourceDatabaseName = sourceDatabaseName
            self.sourceSchemaName = sourceSchemaName
            self.sourceTableName = sourceTableName
            self.targetDatabaseName = targetDatabaseName
            self.targetSchemaName = targetSchemaName
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case activateCaseSensitiveIdentifier = "activateCaseSensitiveIdentifier"
            case namespaceName = "namespaceName"
            case newTableName = "newTableName"
            case recoveryPointId = "recoveryPointId"
            case sourceDatabaseName = "sourceDatabaseName"
            case sourceSchemaName = "sourceSchemaName"
            case sourceTableName = "sourceTableName"
            case targetDatabaseName = "targetDatabaseName"
            case targetSchemaName = "targetSchemaName"
            case workgroupName = "workgroupName"
        }
    }

    public struct RestoreTableFromRecoveryPointResponse: AWSDecodableShape {
        public let tableRestoreStatus: TableRestoreStatus?

        @inlinable
        public init(tableRestoreStatus: TableRestoreStatus? = nil) {
            self.tableRestoreStatus = tableRestoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tableRestoreStatus = "tableRestoreStatus"
        }
    }

    public struct RestoreTableFromSnapshotRequest: AWSEncodableShape {
        /// Indicates whether name identifiers for database, schema, and table  are case sensitive. If true, the names are case sensitive. If  false, the names are not case sensitive. The default is false.
        public let activateCaseSensitiveIdentifier: Bool?
        /// The namespace of the snapshot to restore from.
        public let namespaceName: String
        /// The name of the table to create from the restore operation.
        public let newTableName: String
        /// The name of the snapshot to restore the table from.
        public let snapshotName: String
        /// The name of the source database that contains the table being restored.
        public let sourceDatabaseName: String
        /// The name of the source schema that contains the table being restored.
        public let sourceSchemaName: String?
        /// The name of the source table being restored.
        public let sourceTableName: String
        /// The name of the database to restore the table to.
        public let targetDatabaseName: String?
        /// The name of the schema to restore the table to.
        public let targetSchemaName: String?
        /// The workgroup to restore the table to.
        public let workgroupName: String

        @inlinable
        public init(activateCaseSensitiveIdentifier: Bool? = nil, namespaceName: String, newTableName: String, snapshotName: String, sourceDatabaseName: String, sourceSchemaName: String? = nil, sourceTableName: String, targetDatabaseName: String? = nil, targetSchemaName: String? = nil, workgroupName: String) {
            self.activateCaseSensitiveIdentifier = activateCaseSensitiveIdentifier
            self.namespaceName = namespaceName
            self.newTableName = newTableName
            self.snapshotName = snapshotName
            self.sourceDatabaseName = sourceDatabaseName
            self.sourceSchemaName = sourceSchemaName
            self.sourceTableName = sourceTableName
            self.targetDatabaseName = targetDatabaseName
            self.targetSchemaName = targetSchemaName
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case activateCaseSensitiveIdentifier = "activateCaseSensitiveIdentifier"
            case namespaceName = "namespaceName"
            case newTableName = "newTableName"
            case snapshotName = "snapshotName"
            case sourceDatabaseName = "sourceDatabaseName"
            case sourceSchemaName = "sourceSchemaName"
            case sourceTableName = "sourceTableName"
            case targetDatabaseName = "targetDatabaseName"
            case targetSchemaName = "targetSchemaName"
            case workgroupName = "workgroupName"
        }
    }

    public struct RestoreTableFromSnapshotResponse: AWSDecodableShape {
        /// The TableRestoreStatus object that contains the status of the restore operation.
        public let tableRestoreStatus: TableRestoreStatus?

        @inlinable
        public init(tableRestoreStatus: TableRestoreStatus? = nil) {
            self.tableRestoreStatus = tableRestoreStatus
        }

        private enum CodingKeys: String, CodingKey {
            case tableRestoreStatus = "tableRestoreStatus"
        }
    }

    public struct ScheduledActionAssociation: AWSDecodableShape {
        /// Name of associated Amazon Redshift Serverless namespace.
        public let namespaceName: String?
        /// Name of associated scheduled action.
        public let scheduledActionName: String?

        @inlinable
        public init(namespaceName: String? = nil, scheduledActionName: String? = nil) {
            self.namespaceName = namespaceName
            self.scheduledActionName = scheduledActionName
        }

        private enum CodingKeys: String, CodingKey {
            case namespaceName = "namespaceName"
            case scheduledActionName = "scheduledActionName"
        }
    }

    public struct ScheduledActionResponse: AWSDecodableShape {
        /// The end time of
        public let endTime: Date?
        /// The end time in UTC when the schedule is no longer active. After this time, the scheduled action does not trigger.
        public let namespaceName: String?
        /// An array of timestamps of when the next scheduled actions will trigger.
        public let nextInvocations: [Date]?
        /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action.  This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots. (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.  For more information about the IAM role to use with the Amazon Redshift scheduler, see Using Identity-Based Policies for  Amazon Redshift in the Amazon Redshift Management Guide
        public let roleArn: String?
        /// The schedule for a one-time (at timestamp format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC.   Format of at timestamp is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.   Format of cron expression is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see  Cron Expressions in the Amazon CloudWatch Events User Guide.
        public let schedule: Schedule?
        /// The description of the scheduled action.
        public let scheduledActionDescription: String?
        /// The name of the scheduled action.
        public let scheduledActionName: String?
        /// The uuid of the scheduled action.
        public let scheduledActionUuid: String?
        /// The start time in UTC when the schedule is active. Before this time, the scheduled action does not trigger.
        public let startTime: Date?
        /// The state of the scheduled action.
        public let state: State?
        public let targetAction: TargetAction?

        @inlinable
        public init(endTime: Date? = nil, namespaceName: String? = nil, nextInvocations: [Date]? = nil, roleArn: String? = nil, schedule: Schedule? = nil, scheduledActionDescription: String? = nil, scheduledActionName: String? = nil, scheduledActionUuid: String? = nil, startTime: Date? = nil, state: State? = nil, targetAction: TargetAction? = nil) {
            self.endTime = endTime
            self.namespaceName = namespaceName
            self.nextInvocations = nextInvocations
            self.roleArn = roleArn
            self.schedule = schedule
            self.scheduledActionDescription = scheduledActionDescription
            self.scheduledActionName = scheduledActionName
            self.scheduledActionUuid = scheduledActionUuid
            self.startTime = startTime
            self.state = state
            self.targetAction = targetAction
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "endTime"
            case namespaceName = "namespaceName"
            case nextInvocations = "nextInvocations"
            case roleArn = "roleArn"
            case schedule = "schedule"
            case scheduledActionDescription = "scheduledActionDescription"
            case scheduledActionName = "scheduledActionName"
            case scheduledActionUuid = "scheduledActionUuid"
            case startTime = "startTime"
            case state = "state"
            case targetAction = "targetAction"
        }
    }

    public struct ServerlessTrack: AWSDecodableShape {
        /// The name of the track. Valid values are current and trailing.
        public let trackName: String?
        /// An array of UpdateTarget objects to update with the track.
        public let updateTargets: [UpdateTarget]?
        /// The workgroup version number for the workgroup release.
        public let workgroupVersion: String?

        @inlinable
        public init(trackName: String? = nil, updateTargets: [UpdateTarget]? = nil, workgroupVersion: String? = nil) {
            self.trackName = trackName
            self.updateTargets = updateTargets
            self.workgroupVersion = workgroupVersion
        }

        private enum CodingKeys: String, CodingKey {
            case trackName = "trackName"
            case updateTargets = "updateTargets"
            case workgroupVersion = "workgroupVersion"
        }
    }

    public struct Snapshot: AWSDecodableShape {
        /// All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.
        public let accountsWithProvisionedRestoreAccess: [String]?
        /// All of the Amazon Web Services accounts that have access to  restore a snapshot to a namespace.
        public let accountsWithRestoreAccess: [String]?
        /// The size of the incremental backup in megabytes.
        public let actualIncrementalBackupSizeInMegaBytes: Double?
        /// The Amazon Resource Name (ARN) for the namespace's admin user credentials secret.
        public let adminPasswordSecretArn: String?
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.
        public let adminPasswordSecretKmsKeyId: String?
        /// The username of the database within a snapshot.
        public let adminUsername: String?
        /// The size in megabytes of the data that has been backed up to a snapshot.
        public let backupProgressInMegaBytes: Double?
        /// The rate at which data is backed up into a snapshot in megabytes per second.
        public let currentBackupRateInMegaBytesPerSecond: Double?
        /// The amount of time it took to back up data into a snapshot.
        public let elapsedTimeInSeconds: Int64?
        /// The estimated amount of seconds until the snapshot completes backup.
        public let estimatedSecondsToCompletion: Int64?
        /// The unique identifier of the KMS key used to encrypt the snapshot.
        public let kmsKeyId: String?
        /// The Amazon Resource Name (ARN) of the namespace the snapshot was created from.
        public let namespaceArn: String?
        /// The name of the namepsace.
        public let namespaceName: String?
        /// The owner Amazon Web Services; account of the snapshot.
        public let ownerAccount: String?
        /// The Amazon Resource Name (ARN) of the snapshot.
        public let snapshotArn: String?
        /// The timestamp of when the snapshot was created.
        public let snapshotCreateTime: Date?
        /// The name of the snapshot.
        public let snapshotName: String?
        /// The amount of days until the snapshot is deleted.
        public let snapshotRemainingDays: Int?
        /// The period of time, in days, of how long the snapshot is retained.
        public let snapshotRetentionPeriod: Int?
        /// The timestamp of when data within the snapshot started getting retained.
        public let snapshotRetentionStartTime: Date?
        /// The status of the snapshot.
        public let status: SnapshotStatus?
        /// The total size, in megabytes, of how big the snapshot is.
        public let totalBackupSizeInMegaBytes: Double?

        @inlinable
        public init(accountsWithProvisionedRestoreAccess: [String]? = nil, accountsWithRestoreAccess: [String]? = nil, actualIncrementalBackupSizeInMegaBytes: Double? = nil, adminPasswordSecretArn: String? = nil, adminPasswordSecretKmsKeyId: String? = nil, adminUsername: String? = nil, backupProgressInMegaBytes: Double? = nil, currentBackupRateInMegaBytesPerSecond: Double? = nil, elapsedTimeInSeconds: Int64? = nil, estimatedSecondsToCompletion: Int64? = nil, kmsKeyId: String? = nil, namespaceArn: String? = nil, namespaceName: String? = nil, ownerAccount: String? = nil, snapshotArn: String? = nil, snapshotCreateTime: Date? = nil, snapshotName: String? = nil, snapshotRemainingDays: Int? = nil, snapshotRetentionPeriod: Int? = nil, snapshotRetentionStartTime: Date? = nil, status: SnapshotStatus? = nil, totalBackupSizeInMegaBytes: Double? = nil) {
            self.accountsWithProvisionedRestoreAccess = accountsWithProvisionedRestoreAccess
            self.accountsWithRestoreAccess = accountsWithRestoreAccess
            self.actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytes
            self.adminPasswordSecretArn = adminPasswordSecretArn
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.backupProgressInMegaBytes = backupProgressInMegaBytes
            self.currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecond
            self.elapsedTimeInSeconds = elapsedTimeInSeconds
            self.estimatedSecondsToCompletion = estimatedSecondsToCompletion
            self.kmsKeyId = kmsKeyId
            self.namespaceArn = namespaceArn
            self.namespaceName = namespaceName
            self.ownerAccount = ownerAccount
            self.snapshotArn = snapshotArn
            self.snapshotCreateTime = snapshotCreateTime
            self.snapshotName = snapshotName
            self.snapshotRemainingDays = snapshotRemainingDays
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
            self.snapshotRetentionStartTime = snapshotRetentionStartTime
            self.status = status
            self.totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytes
        }

        private enum CodingKeys: String, CodingKey {
            case accountsWithProvisionedRestoreAccess = "accountsWithProvisionedRestoreAccess"
            case accountsWithRestoreAccess = "accountsWithRestoreAccess"
            case actualIncrementalBackupSizeInMegaBytes = "actualIncrementalBackupSizeInMegaBytes"
            case adminPasswordSecretArn = "adminPasswordSecretArn"
            case adminPasswordSecretKmsKeyId = "adminPasswordSecretKmsKeyId"
            case adminUsername = "adminUsername"
            case backupProgressInMegaBytes = "backupProgressInMegaBytes"
            case currentBackupRateInMegaBytesPerSecond = "currentBackupRateInMegaBytesPerSecond"
            case elapsedTimeInSeconds = "elapsedTimeInSeconds"
            case estimatedSecondsToCompletion = "estimatedSecondsToCompletion"
            case kmsKeyId = "kmsKeyId"
            case namespaceArn = "namespaceArn"
            case namespaceName = "namespaceName"
            case ownerAccount = "ownerAccount"
            case snapshotArn = "snapshotArn"
            case snapshotCreateTime = "snapshotCreateTime"
            case snapshotName = "snapshotName"
            case snapshotRemainingDays = "snapshotRemainingDays"
            case snapshotRetentionPeriod = "snapshotRetentionPeriod"
            case snapshotRetentionStartTime = "snapshotRetentionStartTime"
            case status = "status"
            case totalBackupSizeInMegaBytes = "totalBackupSizeInMegaBytes"
        }
    }

    public struct SnapshotCopyConfiguration: AWSDecodableShape {
        /// The ID of the KMS key to use to encrypt your snapshots in the destination Amazon Web Services Region.
        public let destinationKmsKeyId: String?
        /// The destination Amazon Web Services Region to copy snapshots to.
        public let destinationRegion: String?
        /// The name of the namespace to copy snapshots from in the source Amazon Web Services Region.
        public let namespaceName: String?
        /// The ARN of the snapshot copy configuration object.
        public let snapshotCopyConfigurationArn: String?
        /// The ID of the snapshot copy configuration object.
        public let snapshotCopyConfigurationId: String?
        /// The retention period of snapshots that are copied to the destination Amazon Web Services Region.
        public let snapshotRetentionPeriod: Int?

        @inlinable
        public init(destinationKmsKeyId: String? = nil, destinationRegion: String? = nil, namespaceName: String? = nil, snapshotCopyConfigurationArn: String? = nil, snapshotCopyConfigurationId: String? = nil, snapshotRetentionPeriod: Int? = nil) {
            self.destinationKmsKeyId = destinationKmsKeyId
            self.destinationRegion = destinationRegion
            self.namespaceName = namespaceName
            self.snapshotCopyConfigurationArn = snapshotCopyConfigurationArn
            self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case destinationKmsKeyId = "destinationKmsKeyId"
            case destinationRegion = "destinationRegion"
            case namespaceName = "namespaceName"
            case snapshotCopyConfigurationArn = "snapshotCopyConfigurationArn"
            case snapshotCopyConfigurationId = "snapshotCopyConfigurationId"
            case snapshotRetentionPeriod = "snapshotRetentionPeriod"
        }
    }

    public struct TableRestoreStatus: AWSDecodableShape {
        /// A message that explains the returned status. For example, if the status of the operation is FAILED, the message explains why the operation failed.
        public let message: String?
        /// The namespace of the table being restored from.
        public let namespaceName: String?
        /// The name of the table to create from the restore operation.
        public let newTableName: String?
        /// The amount of data restored to the new table so far, in megabytes (MB).
        public let progressInMegaBytes: Int64?
        /// The ID of the recovery point being restored from.
        public let recoveryPointId: String?
        /// The time that the table restore request was made,  in Universal Coordinated Time (UTC).
        public let requestTime: Date?
        /// The name of the snapshot being restored from.
        public let snapshotName: String?
        /// The name of the source database being restored from.
        public let sourceDatabaseName: String?
        /// The name of the source schema being restored from.
        public let sourceSchemaName: String?
        /// The name of the source table being restored from.
        public let sourceTableName: String?
        /// A value that describes the current state of the table restore request.  Possible values are SUCCEEDED, FAILED, CANCELED, PENDING, and IN_PROGRESS.
        public let status: String?
        /// The ID of the RestoreTableFromSnapshot request.
        public let tableRestoreRequestId: String?
        /// The name of the database to restore to.
        public let targetDatabaseName: String?
        /// The name of the schema to restore to.
        public let targetSchemaName: String?
        /// The total amount of data to restore to the new table, in megabytes (MB).
        public let totalDataInMegaBytes: Int64?
        /// The name of the workgroup being restored from.
        public let workgroupName: String?

        @inlinable
        public init(message: String? = nil, namespaceName: String? = nil, newTableName: String? = nil, progressInMegaBytes: Int64? = nil, recoveryPointId: String? = nil, requestTime: Date? = nil, snapshotName: String? = nil, sourceDatabaseName: String? = nil, sourceSchemaName: String? = nil, sourceTableName: String? = nil, status: String? = nil, tableRestoreRequestId: String? = nil, targetDatabaseName: String? = nil, targetSchemaName: String? = nil, totalDataInMegaBytes: Int64? = nil, workgroupName: String? = nil) {
            self.message = message
            self.namespaceName = namespaceName
            self.newTableName = newTableName
            self.progressInMegaBytes = progressInMegaBytes
            self.recoveryPointId = recoveryPointId
            self.requestTime = requestTime
            self.snapshotName = snapshotName
            self.sourceDatabaseName = sourceDatabaseName
            self.sourceSchemaName = sourceSchemaName
            self.sourceTableName = sourceTableName
            self.status = status
            self.tableRestoreRequestId = tableRestoreRequestId
            self.targetDatabaseName = targetDatabaseName
            self.targetSchemaName = targetSchemaName
            self.totalDataInMegaBytes = totalDataInMegaBytes
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case namespaceName = "namespaceName"
            case newTableName = "newTableName"
            case progressInMegaBytes = "progressInMegaBytes"
            case recoveryPointId = "recoveryPointId"
            case requestTime = "requestTime"
            case snapshotName = "snapshotName"
            case sourceDatabaseName = "sourceDatabaseName"
            case sourceSchemaName = "sourceSchemaName"
            case sourceTableName = "sourceTableName"
            case status = "status"
            case tableRestoreRequestId = "tableRestoreRequestId"
            case targetDatabaseName = "targetDatabaseName"
            case targetSchemaName = "targetSchemaName"
            case totalDataInMegaBytes = "totalDataInMegaBytes"
            case workgroupName = "workgroupName"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key to use in the tag.
        public let key: String
        /// The value of the tag.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceArn: String
        /// The map of the key-value pairs used to tag the resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ThrottlingException: AWSErrorShape {
        public let code: String?
        public let message: String?

        @inlinable
        public init(code: String? = nil, message: String? = nil) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "code"
            case message = "message"
        }
    }

    public struct TooManyTagsException: AWSErrorShape {
        public let message: String?
        /// The name of the resource that exceeded the number of tags allowed for a resource.
        public let resourceName: String?

        @inlinable
        public init(message: String? = nil, resourceName: String? = nil) {
            self.message = message
            self.resourceName = resourceName
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceName = "resourceName"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove tags from.
        public let resourceArn: String
        /// The tag or set of tags to remove from the resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1011)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "resourceArn"
            case tagKeys = "tagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateCustomDomainAssociationRequest: AWSEncodableShape {
        /// The custom domain name’s certificate Amazon resource name (ARN). This is optional.
        public let customDomainCertificateArn: String
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String
        /// The name of the workgroup associated with the database.
        public let workgroupName: String

        @inlinable
        public init(customDomainCertificateArn: String, customDomainName: String, workgroupName: String) {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, max: 2048)
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, min: 20)
            try self.validate(self.customDomainCertificateArn, name: "customDomainCertificateArn", parent: name, pattern: "arn:[\\w+=/,.@-]+:acm:[\\w+=/,.@-]*:[0-9]+:[\\w+=,.@-]+(/[\\w+=,.@-]+)*")
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 253)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 1)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, pattern: "^(((?!-)[A-Za-z0-9-]{0,62}[A-Za-z0-9])\\.)+((?!-)[A-Za-z0-9-]{1,62}[A-Za-z0-9])$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct UpdateCustomDomainAssociationResponse: AWSDecodableShape {
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public let customDomainCertificateArn: String?
        /// The expiration time for the certificate.
        public let customDomainCertificateExpiryTime: Date?
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String?
        /// The name of the workgroup associated with the database.
        public let workgroupName: String?

        @inlinable
        public init(customDomainCertificateArn: String? = nil, customDomainCertificateExpiryTime: Date? = nil, customDomainName: String? = nil, workgroupName: String? = nil) {
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.workgroupName = workgroupName
        }

        private enum CodingKeys: String, CodingKey {
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainCertificateExpiryTime = "customDomainCertificateExpiryTime"
            case customDomainName = "customDomainName"
            case workgroupName = "workgroupName"
        }
    }

    public struct UpdateEndpointAccessRequest: AWSEncodableShape {
        /// The name of the VPC endpoint to update.
        public let endpointName: String
        /// The list of VPC security groups associated with the endpoint after the endpoint is modified.
        public let vpcSecurityGroupIds: [String]?

        @inlinable
        public init(endpointName: String, vpcSecurityGroupIds: [String]? = nil) {
            self.endpointName = endpointName
            self.vpcSecurityGroupIds = vpcSecurityGroupIds
        }

        private enum CodingKeys: String, CodingKey {
            case endpointName = "endpointName"
            case vpcSecurityGroupIds = "vpcSecurityGroupIds"
        }
    }

    public struct UpdateEndpointAccessResponse: AWSDecodableShape {
        /// The updated VPC endpoint.
        public let endpoint: EndpointAccess?

        @inlinable
        public init(endpoint: EndpointAccess? = nil) {
            self.endpoint = endpoint
        }

        private enum CodingKeys: String, CodingKey {
            case endpoint = "endpoint"
        }
    }

    public struct UpdateNamespaceRequest: AWSEncodableShape {
        /// The ID of the Key Management Service (KMS) key used to encrypt and store the namespace's admin credentials secret.  You can only use this parameter if manageAdminPassword is true.
        public let adminPasswordSecretKmsKeyId: String?
        /// The username of the administrator for the first database created in the namespace. This parameter must be updated together with adminUserPassword.
        public let adminUsername: String?
        /// The password of the administrator for the first database created in the namespace. This parameter must be updated together with adminUsername. You can't use adminUserPassword if manageAdminPassword is true.
        public let adminUserPassword: String?
        /// The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace. This parameter must be updated together with iamRoles.
        public let defaultIamRoleArn: String?
        /// A list of IAM roles to associate with the namespace. This parameter must be updated together with defaultIamRoleArn.
        public let iamRoles: [String]?
        /// The ID of the Amazon Web Services Key Management Service key used to encrypt your data.
        public let kmsKeyId: String?
        /// The types of logs the namespace can export. The export types are userlog, connectionlog, and useractivitylog.
        public let logExports: [LogExport]?
        /// If true, Amazon Redshift uses Secrets Manager to manage the namespace's admin credentials.  You can't use adminUserPassword if manageAdminPassword is true.  If manageAdminPassword is false or not set, Amazon Redshift uses  adminUserPassword for the admin user account's password.
        public let manageAdminPassword: Bool?
        /// The name of the namespace to update. You can't update the name of a namespace once it is created.
        public let namespaceName: String

        @inlinable
        public init(adminPasswordSecretKmsKeyId: String? = nil, adminUsername: String? = nil, adminUserPassword: String? = nil, defaultIamRoleArn: String? = nil, iamRoles: [String]? = nil, kmsKeyId: String? = nil, logExports: [LogExport]? = nil, manageAdminPassword: Bool? = nil, namespaceName: String) {
            self.adminPasswordSecretKmsKeyId = adminPasswordSecretKmsKeyId
            self.adminUsername = adminUsername
            self.adminUserPassword = adminUserPassword
            self.defaultIamRoleArn = defaultIamRoleArn
            self.iamRoles = iamRoles
            self.kmsKeyId = kmsKeyId
            self.logExports = logExports
            self.manageAdminPassword = manageAdminPassword
            self.namespaceName = namespaceName
        }

        public func validate(name: String) throws {
            try self.validate(self.logExports, name: "logExports", parent: name, max: 16)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, max: 64)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, min: 3)
            try self.validate(self.namespaceName, name: "namespaceName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case adminPasswordSecretKmsKeyId = "adminPasswordSecretKmsKeyId"
            case adminUsername = "adminUsername"
            case adminUserPassword = "adminUserPassword"
            case defaultIamRoleArn = "defaultIamRoleArn"
            case iamRoles = "iamRoles"
            case kmsKeyId = "kmsKeyId"
            case logExports = "logExports"
            case manageAdminPassword = "manageAdminPassword"
            case namespaceName = "namespaceName"
        }
    }

    public struct UpdateNamespaceResponse: AWSDecodableShape {
        /// A list of tag instances.
        public let namespace: Namespace

        @inlinable
        public init(namespace: Namespace) {
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case namespace = "namespace"
        }
    }

    public struct UpdateScheduledActionRequest: AWSEncodableShape {
        /// Specifies whether to enable the scheduled action.
        public let enabled: Bool?
        /// The end time in UTC of the scheduled action to update.
        public let endTime: Date?
        /// The ARN of the IAM role to assume to run the scheduled action. This IAM role must have permission to run the Amazon Redshift Serverless API operation in the scheduled action.  This IAM role must allow the Amazon Redshift scheduler to schedule creating snapshots (Principal scheduler.redshift.amazonaws.com) to assume permissions on your behalf.  For more information about the IAM role to use with the Amazon Redshift scheduler, see Using Identity-Based Policies for  Amazon Redshift in the Amazon Redshift Management Guide
        public let roleArn: String?
        /// The schedule for a one-time (at timestamp format) or recurring (cron format) scheduled action. Schedule invocations must be separated by at least one hour. Times are in UTC.   Format of at timestamp is yyyy-mm-ddThh:mm:ss. For example, 2016-03-04T17:27:00.   Format of cron expression is (Minutes Hours Day-of-month Month Day-of-week Year). For example, "(0 10 ? * MON *)". For more information, see  Cron Expressions in the Amazon CloudWatch Events User Guide.
        public let schedule: Schedule?
        /// The descripion of the scheduled action to update to.
        public let scheduledActionDescription: String?
        /// The name of the scheduled action to update to.
        public let scheduledActionName: String
        /// The start time in UTC of the scheduled action to update to.
        public let startTime: Date?
        public let targetAction: TargetAction?

        @inlinable
        public init(enabled: Bool? = nil, endTime: Date? = nil, roleArn: String? = nil, schedule: Schedule? = nil, scheduledActionDescription: String? = nil, scheduledActionName: String, startTime: Date? = nil, targetAction: TargetAction? = nil) {
            self.enabled = enabled
            self.endTime = endTime
            self.roleArn = roleArn
            self.schedule = schedule
            self.scheduledActionDescription = scheduledActionDescription
            self.scheduledActionName = scheduledActionName
            self.startTime = startTime
            self.targetAction = targetAction
        }

        public func validate(name: String) throws {
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, max: 60)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, min: 3)
            try self.validate(self.scheduledActionName, name: "scheduledActionName", parent: name, pattern: "^[a-z0-9-]+$")
            try self.targetAction?.validate(name: "\(name).targetAction")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case endTime = "endTime"
            case roleArn = "roleArn"
            case schedule = "schedule"
            case scheduledActionDescription = "scheduledActionDescription"
            case scheduledActionName = "scheduledActionName"
            case startTime = "startTime"
            case targetAction = "targetAction"
        }
    }

    public struct UpdateScheduledActionResponse: AWSDecodableShape {
        /// The ScheduledAction object that was updated.
        public let scheduledAction: ScheduledActionResponse?

        @inlinable
        public init(scheduledAction: ScheduledActionResponse? = nil) {
            self.scheduledAction = scheduledAction
        }

        private enum CodingKeys: String, CodingKey {
            case scheduledAction = "scheduledAction"
        }
    }

    public struct UpdateSnapshotCopyConfigurationRequest: AWSEncodableShape {
        /// The ID of the snapshot copy configuration to update.
        public let snapshotCopyConfigurationId: String
        /// The new retention period of how long to keep a snapshot in the destination Amazon Web Services Region.
        public let snapshotRetentionPeriod: Int?

        @inlinable
        public init(snapshotCopyConfigurationId: String, snapshotRetentionPeriod: Int? = nil) {
            self.snapshotCopyConfigurationId = snapshotCopyConfigurationId
            self.snapshotRetentionPeriod = snapshotRetentionPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotCopyConfigurationId = "snapshotCopyConfigurationId"
            case snapshotRetentionPeriod = "snapshotRetentionPeriod"
        }
    }

    public struct UpdateSnapshotCopyConfigurationResponse: AWSDecodableShape {
        /// The updated snapshot copy configuration object.
        public let snapshotCopyConfiguration: SnapshotCopyConfiguration

        @inlinable
        public init(snapshotCopyConfiguration: SnapshotCopyConfiguration) {
            self.snapshotCopyConfiguration = snapshotCopyConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotCopyConfiguration = "snapshotCopyConfiguration"
        }
    }

    public struct UpdateSnapshotRequest: AWSEncodableShape {
        /// The new retention period of the snapshot.
        public let retentionPeriod: Int?
        /// The name of the snapshot.
        public let snapshotName: String

        @inlinable
        public init(retentionPeriod: Int? = nil, snapshotName: String) {
            self.retentionPeriod = retentionPeriod
            self.snapshotName = snapshotName
        }

        private enum CodingKeys: String, CodingKey {
            case retentionPeriod = "retentionPeriod"
            case snapshotName = "snapshotName"
        }
    }

    public struct UpdateSnapshotResponse: AWSDecodableShape {
        /// The updated snapshot object.
        public let snapshot: Snapshot?

        @inlinable
        public init(snapshot: Snapshot? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "snapshot"
        }
    }

    public struct UpdateTarget: AWSDecodableShape {
        /// The name of the new track.
        public let trackName: String?
        /// The workgroup version for the new track.
        public let workgroupVersion: String?

        @inlinable
        public init(trackName: String? = nil, workgroupVersion: String? = nil) {
            self.trackName = trackName
            self.workgroupVersion = workgroupVersion
        }

        private enum CodingKeys: String, CodingKey {
            case trackName = "trackName"
            case workgroupVersion = "workgroupVersion"
        }
    }

    public struct UpdateUsageLimitRequest: AWSEncodableShape {
        /// The new limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour.  If data-based, this amount is in terabytes (TB) of data transferred between Regions in cross-account sharing.  The value must be a positive number.
        public let amount: Int64?
        /// The new action that Amazon Redshift Serverless takes when the limit is reached.
        public let breachAction: UsageLimitBreachAction?
        /// The identifier of the usage limit to update.
        public let usageLimitId: String

        @inlinable
        public init(amount: Int64? = nil, breachAction: UsageLimitBreachAction? = nil, usageLimitId: String) {
            self.amount = amount
            self.breachAction = breachAction
            self.usageLimitId = usageLimitId
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case breachAction = "breachAction"
            case usageLimitId = "usageLimitId"
        }
    }

    public struct UpdateUsageLimitResponse: AWSDecodableShape {
        /// The updated usage limit object.
        public let usageLimit: UsageLimit?

        @inlinable
        public init(usageLimit: UsageLimit? = nil) {
            self.usageLimit = usageLimit
        }

        private enum CodingKeys: String, CodingKey {
            case usageLimit = "usageLimit"
        }
    }

    public struct UpdateWorkgroupRequest: AWSEncodableShape {
        /// The new base data warehouse capacity in Redshift Processing Units (RPUs).
        public let baseCapacity: Int?
        /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let you  define performance boundaries. For more information about query monitoring rules and available metrics, see   Query monitoring metrics for Amazon Redshift Serverless.
        public let configParameters: [ConfigParameter]?
        /// The value that specifies whether to turn on enhanced virtual  private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
        public let enhancedVpcRouting: Bool?
        /// The IP address type that the workgroup supports. Possible values are ipv4 and dualstack.
        public let ipAddressType: String?
        /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
        public let maxCapacity: Int?
        /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
        public let port: Int?
        /// An object that represents the price performance target settings for the workgroup.
        public let pricePerformanceTarget: PerformanceTarget?
        /// A value that specifies whether the workgroup can be accessible from a public network.
        public let publiclyAccessible: Bool?
        /// An array of security group IDs to associate with the workgroup.
        public let securityGroupIds: [String]?
        /// An array of VPC subnet IDs to associate with the workgroup.
        public let subnetIds: [String]?
        /// An optional parameter for the name of the track for the workgroup. If you don't provide  a track name, the workgroup is assigned to the current track.
        public let trackName: String?
        /// The name of the workgroup to update. You can't update the name of a workgroup once it is created.
        public let workgroupName: String

        @inlinable
        public init(baseCapacity: Int? = nil, configParameters: [ConfigParameter]? = nil, enhancedVpcRouting: Bool? = nil, ipAddressType: String? = nil, maxCapacity: Int? = nil, port: Int? = nil, pricePerformanceTarget: PerformanceTarget? = nil, publiclyAccessible: Bool? = nil, securityGroupIds: [String]? = nil, subnetIds: [String]? = nil, trackName: String? = nil, workgroupName: String) {
            self.baseCapacity = baseCapacity
            self.configParameters = configParameters
            self.enhancedVpcRouting = enhancedVpcRouting
            self.ipAddressType = ipAddressType
            self.maxCapacity = maxCapacity
            self.port = port
            self.pricePerformanceTarget = pricePerformanceTarget
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.trackName = trackName
            self.workgroupName = workgroupName
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAddressType, name: "ipAddressType", parent: name, pattern: "^(ipv4|dualstack)$")
            try self.validate(self.trackName, name: "trackName", parent: name, max: 256)
            try self.validate(self.trackName, name: "trackName", parent: name, min: 1)
            try self.validate(self.trackName, name: "trackName", parent: name, pattern: "^[a-zA-Z0-9_]+$")
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, max: 64)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, min: 3)
            try self.validate(self.workgroupName, name: "workgroupName", parent: name, pattern: "^[a-z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case baseCapacity = "baseCapacity"
            case configParameters = "configParameters"
            case enhancedVpcRouting = "enhancedVpcRouting"
            case ipAddressType = "ipAddressType"
            case maxCapacity = "maxCapacity"
            case port = "port"
            case pricePerformanceTarget = "pricePerformanceTarget"
            case publiclyAccessible = "publiclyAccessible"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case trackName = "trackName"
            case workgroupName = "workgroupName"
        }
    }

    public struct UpdateWorkgroupResponse: AWSDecodableShape {
        /// The updated workgroup object.
        public let workgroup: Workgroup

        @inlinable
        public init(workgroup: Workgroup) {
            self.workgroup = workgroup
        }

        private enum CodingKeys: String, CodingKey {
            case workgroup = "workgroup"
        }
    }

    public struct UsageLimit: AWSDecodableShape {
        /// The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.
        public let amount: Int64?
        /// The action that Amazon Redshift Serverless takes when the limit is reached.
        public let breachAction: UsageLimitBreachAction?
        /// The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.
        public let period: UsageLimitPeriod?
        /// The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.
        public let resourceArn: String?
        /// The Amazon Resource Name (ARN) of the resource associated with the usage limit.
        public let usageLimitArn: String?
        /// The identifier of the usage limit.
        public let usageLimitId: String?
        /// The Amazon Redshift Serverless feature to limit.
        public let usageType: UsageLimitUsageType?

        @inlinable
        public init(amount: Int64? = nil, breachAction: UsageLimitBreachAction? = nil, period: UsageLimitPeriod? = nil, resourceArn: String? = nil, usageLimitArn: String? = nil, usageLimitId: String? = nil, usageType: UsageLimitUsageType? = nil) {
            self.amount = amount
            self.breachAction = breachAction
            self.period = period
            self.resourceArn = resourceArn
            self.usageLimitArn = usageLimitArn
            self.usageLimitId = usageLimitId
            self.usageType = usageType
        }

        private enum CodingKeys: String, CodingKey {
            case amount = "amount"
            case breachAction = "breachAction"
            case period = "period"
            case resourceArn = "resourceArn"
            case usageLimitArn = "usageLimitArn"
            case usageLimitId = "usageLimitId"
            case usageType = "usageType"
        }
    }

    public struct VpcEndpoint: AWSDecodableShape {
        /// One or more network interfaces of the endpoint. Also known as an interface endpoint.
        public let networkInterfaces: [NetworkInterface]?
        /// The connection endpoint ID for connecting to Amazon Redshift Serverless.
        public let vpcEndpointId: String?
        /// The VPC identifier that the endpoint is associated with.
        public let vpcId: String?

        @inlinable
        public init(networkInterfaces: [NetworkInterface]? = nil, vpcEndpointId: String? = nil, vpcId: String? = nil) {
            self.networkInterfaces = networkInterfaces
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case networkInterfaces = "networkInterfaces"
            case vpcEndpointId = "vpcEndpointId"
            case vpcId = "vpcId"
        }
    }

    public struct VpcSecurityGroupMembership: AWSDecodableShape {
        /// The status of the VPC security group.
        public let status: String?
        /// The unique identifier of the VPC security group.
        public let vpcSecurityGroupId: String?

        @inlinable
        public init(status: String? = nil, vpcSecurityGroupId: String? = nil) {
            self.status = status
            self.vpcSecurityGroupId = vpcSecurityGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case vpcSecurityGroupId = "vpcSecurityGroupId"
        }
    }

    public struct Workgroup: AWSDecodableShape {
        /// The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).
        public let baseCapacity: Int?
        /// An array of parameters to set for advanced control over a database. The options are auto_mv, datestyle, enable_case_sensitive_identifier, enable_user_activity_logging, query_group, search_path, require_ssl, use_fips_ssl, and query monitoring metrics that let you define performance boundaries.  For more information about query monitoring rules and available metrics, see  Query monitoring metrics for Amazon Redshift Serverless.
        public let configParameters: [ConfigParameter]?
        /// The creation date of the workgroup.
        public let creationDate: Date?
        /// A list of VPCs. Each entry is the unique identifier of a virtual private cloud with access to Amazon Redshift Serverless. If all of the VPCs for the grantee are allowed, it shows an asterisk.
        public let crossAccountVpcs: [String]?
        /// The custom domain name’s certificate Amazon resource name (ARN).
        public let customDomainCertificateArn: String?
        /// The expiration time for the certificate.
        public let customDomainCertificateExpiryTime: Date?
        /// The custom domain name associated with the workgroup.
        public let customDomainName: String?
        /// The endpoint that is created from the workgroup.
        public let endpoint: Endpoint?
        /// The value that specifies whether to enable enhanced virtual  private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.
        public let enhancedVpcRouting: Bool?
        /// The IP address type that the workgroup supports. Possible values are ipv4 and dualstack.
        public let ipAddressType: String?
        /// The maximum data-warehouse capacity Amazon Redshift Serverless uses to serve queries. The max capacity is specified in RPUs.
        public let maxCapacity: Int?
        /// The namespace the workgroup is associated with.
        public let namespaceName: String?
        /// The patch version of your Amazon Redshift Serverless workgroup. For more information about patch versions, see Cluster versions for Amazon Redshift.
        public let patchVersion: String?
        /// The name for the track that you want to assign to the workgroup. When the track changes, the  workgroup is switched to the latest workgroup release available for the track. At this point, the  track name is applied.
        public let pendingTrackName: String?
        /// The custom port to use when connecting to a workgroup. Valid port ranges are 5431-5455 and 8191-8215. The default is 5439.
        public let port: Int?
        /// An object that represents the price performance target settings for the workgroup.
        public let pricePerformanceTarget: PerformanceTarget?
        /// A value that specifies whether the workgroup can be accessible from a public network.
        public let publiclyAccessible: Bool?
        /// An array of security group IDs to associate with the workgroup.
        public let securityGroupIds: [String]?
        /// The status of the workgroup.
        public let status: WorkgroupStatus?
        /// An array of subnet IDs the workgroup is associated with.
        public let subnetIds: [String]?
        /// The name of the track for the workgroup.
        public let trackName: String?
        /// The Amazon Resource Name (ARN) that links to the workgroup.
        public let workgroupArn: String?
        /// The unique identifier of the workgroup.
        public let workgroupId: String?
        /// The name of the workgroup.
        public let workgroupName: String?
        /// The Amazon Redshift Serverless version of your workgroup. For more information about Amazon Redshift Serverless versions, seeCluster versions for Amazon Redshift.
        public let workgroupVersion: String?

        @inlinable
        public init(baseCapacity: Int? = nil, configParameters: [ConfigParameter]? = nil, creationDate: Date? = nil, crossAccountVpcs: [String]? = nil, customDomainCertificateArn: String? = nil, customDomainCertificateExpiryTime: Date? = nil, customDomainName: String? = nil, endpoint: Endpoint? = nil, enhancedVpcRouting: Bool? = nil, ipAddressType: String? = nil, maxCapacity: Int? = nil, namespaceName: String? = nil, patchVersion: String? = nil, pendingTrackName: String? = nil, port: Int? = nil, pricePerformanceTarget: PerformanceTarget? = nil, publiclyAccessible: Bool? = nil, securityGroupIds: [String]? = nil, status: WorkgroupStatus? = nil, subnetIds: [String]? = nil, trackName: String? = nil, workgroupArn: String? = nil, workgroupId: String? = nil, workgroupName: String? = nil, workgroupVersion: String? = nil) {
            self.baseCapacity = baseCapacity
            self.configParameters = configParameters
            self.creationDate = creationDate
            self.crossAccountVpcs = crossAccountVpcs
            self.customDomainCertificateArn = customDomainCertificateArn
            self.customDomainCertificateExpiryTime = customDomainCertificateExpiryTime
            self.customDomainName = customDomainName
            self.endpoint = endpoint
            self.enhancedVpcRouting = enhancedVpcRouting
            self.ipAddressType = ipAddressType
            self.maxCapacity = maxCapacity
            self.namespaceName = namespaceName
            self.patchVersion = patchVersion
            self.pendingTrackName = pendingTrackName
            self.port = port
            self.pricePerformanceTarget = pricePerformanceTarget
            self.publiclyAccessible = publiclyAccessible
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.trackName = trackName
            self.workgroupArn = workgroupArn
            self.workgroupId = workgroupId
            self.workgroupName = workgroupName
            self.workgroupVersion = workgroupVersion
        }

        private enum CodingKeys: String, CodingKey {
            case baseCapacity = "baseCapacity"
            case configParameters = "configParameters"
            case creationDate = "creationDate"
            case crossAccountVpcs = "crossAccountVpcs"
            case customDomainCertificateArn = "customDomainCertificateArn"
            case customDomainCertificateExpiryTime = "customDomainCertificateExpiryTime"
            case customDomainName = "customDomainName"
            case endpoint = "endpoint"
            case enhancedVpcRouting = "enhancedVpcRouting"
            case ipAddressType = "ipAddressType"
            case maxCapacity = "maxCapacity"
            case namespaceName = "namespaceName"
            case patchVersion = "patchVersion"
            case pendingTrackName = "pendingTrackName"
            case port = "port"
            case pricePerformanceTarget = "pricePerformanceTarget"
            case publiclyAccessible = "publiclyAccessible"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case trackName = "trackName"
            case workgroupArn = "workgroupArn"
            case workgroupId = "workgroupId"
            case workgroupName = "workgroupName"
            case workgroupVersion = "workgroupVersion"
        }
    }

    public struct TargetAction: AWSEncodableShape & AWSDecodableShape {
        public let createSnapshot: CreateSnapshotScheduleActionParameters?

        @inlinable
        public init(createSnapshot: CreateSnapshotScheduleActionParameters? = nil) {
            self.createSnapshot = createSnapshot
        }

        public func validate(name: String) throws {
            try self.createSnapshot?.validate(name: "\(name).createSnapshot")
        }

        private enum CodingKeys: String, CodingKey {
            case createSnapshot = "createSnapshot"
        }
    }
}

// MARK: - Errors

/// Error enum for RedshiftServerless
public struct RedshiftServerlessErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case insufficientCapacityException = "InsufficientCapacityException"
        case internalServerException = "InternalServerException"
        case invalidPaginationException = "InvalidPaginationException"
        case ipv6CidrBlockNotFoundException = "Ipv6CidrBlockNotFoundException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyTagsException = "TooManyTagsException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize RedshiftServerless
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The submitted action has conflicts.
    public static var conflictException: Self { .init(.conflictException) }
    /// There is an insufficient capacity to perform the action.
    public static var insufficientCapacityException: Self { .init(.insufficientCapacityException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The provided pagination token is invalid.
    public static var invalidPaginationException: Self { .init(.invalidPaginationException) }
    /// There are no subnets in your VPC with associated IPv6 CIDR blocks. To use dual-stack mode, associate an IPv6 CIDR block with each subnet in your VPC.
    public static var ipv6CidrBlockNotFoundException: Self { .init(.ipv6CidrBlockNotFoundException) }
    /// The resource could not be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The service limit was exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request exceeded the number of tags allowed for a resource.
    public static var tooManyTagsException: Self { .init(.tooManyTagsException) }
    /// The input failed to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension RedshiftServerlessErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": RedshiftServerless.AccessDeniedException.self,
        "ResourceNotFoundException": RedshiftServerless.ResourceNotFoundException.self,
        "ThrottlingException": RedshiftServerless.ThrottlingException.self,
        "TooManyTagsException": RedshiftServerless.TooManyTagsException.self
    ]
}

extension RedshiftServerlessErrorType: Equatable {
    public static func == (lhs: RedshiftServerlessErrorType, rhs: RedshiftServerlessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension RedshiftServerlessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
