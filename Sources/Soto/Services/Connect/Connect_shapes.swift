//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Connect {
    // MARK: Enums

    public enum ActionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case assignContactCategory = "ASSIGN_CONTACT_CATEGORY"
        case createCase = "CREATE_CASE"
        case createTask = "CREATE_TASK"
        case endAssociatedTasks = "END_ASSOCIATED_TASKS"
        case generateEventbridgeEvent = "GENERATE_EVENTBRIDGE_EVENT"
        case sendNotification = "SEND_NOTIFICATION"
        case submitAutoEvaluation = "SUBMIT_AUTO_EVALUATION"
        case updateCase = "UPDATE_CASE"
        public var description: String { return self.rawValue }
    }

    public enum AgentAvailabilityTimer: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case timeSinceLastActivity = "TIME_SINCE_LAST_ACTIVITY"
        case timeSinceLastInbound = "TIME_SINCE_LAST_INBOUND"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatusState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case offline = "OFFLINE"
        case routable = "ROUTABLE"
        public var description: String { return self.rawValue }
    }

    public enum AnsweringMachineDetectionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case amdError = "AMD_ERROR"
        case amdNotApplicable = "AMD_NOT_APPLICABLE"
        case amdUnanswered = "AMD_UNANSWERED"
        case amdUnresolved = "AMD_UNRESOLVED"
        case answered = "ANSWERED"
        case error = "ERROR"
        case faxMachineDetected = "FAX_MACHINE_DETECTED"
        case humanAnswered = "HUMAN_ANSWERED"
        case sitToneBusy = "SIT_TONE_BUSY"
        case sitToneDetected = "SIT_TONE_DETECTED"
        case sitToneInvalidNumber = "SIT_TONE_INVALID_NUMBER"
        case undetected = "UNDETECTED"
        case voicemailBeep = "VOICEMAIL_BEEP"
        case voicemailNoBeep = "VOICEMAIL_NO_BEEP"
        public var description: String { return self.rawValue }
    }

    public enum ArtifactStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case inProgress = "IN_PROGRESS"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum AttachedFileInvalidRequestExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalidFileName = "INVALID_FILE_NAME"
        case invalidFileSize = "INVALID_FILE_SIZE"
        case invalidFileType = "INVALID_FILE_TYPE"
        public var description: String { return self.rawValue }
    }

    public enum AttachedFileServiceQuotaExceededExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case totalFileCountExceeded = "TOTAL_FILE_COUNT_EXCEEDED"
        case totalFileSizeExceeded = "TOTAL_FILE_SIZE_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum BehaviorType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case routeAnyChannel = "ROUTE_ANY_CHANNEL"
        case routeCurrentChannelOnly = "ROUTE_CURRENT_CHANNEL_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum Channel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chat = "CHAT"
        case email = "EMAIL"
        case task = "TASK"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum ChatEventType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disconnect = "DISCONNECT"
        case event = "EVENT"
        case message = "MESSAGE"
        public var description: String { return self.rawValue }
    }

    public enum Comparison: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case lt = "LT"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowModuleState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowModuleStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case published = "PUBLISHED"
        case saved = "SAVED"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case published = "PUBLISHED"
        case saved = "SAVED"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentHold = "AGENT_HOLD"
        case agentTransfer = "AGENT_TRANSFER"
        case agentWhisper = "AGENT_WHISPER"
        case campaign = "CAMPAIGN"
        case contactFlow = "CONTACT_FLOW"
        case customerHold = "CUSTOMER_HOLD"
        case customerQueue = "CUSTOMER_QUEUE"
        case customerWhisper = "CUSTOMER_WHISPER"
        case outboundWhisper = "OUTBOUND_WHISPER"
        case queueTransfer = "QUEUE_TRANSFER"
        public var description: String { return self.rawValue }
    }

    public enum ContactInitiationMethod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentReply = "AGENT_REPLY"
        case api = "API"
        case callback = "CALLBACK"
        case disconnect = "DISCONNECT"
        case externalOutbound = "EXTERNAL_OUTBOUND"
        case flow = "FLOW"
        case inbound = "INBOUND"
        case monitor = "MONITOR"
        case outbound = "OUTBOUND"
        case queueTransfer = "QUEUE_TRANSFER"
        case transfer = "TRANSFER"
        case webrtcApi = "WEBRTC_API"
        public var description: String { return self.rawValue }
    }

    public enum ContactRecordingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case ivr = "IVR"
        case screen = "SCREEN"
        public var description: String { return self.rawValue }
    }

    public enum ContactState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connected = "CONNECTED"
        case connectedOnhold = "CONNECTED_ONHOLD"
        case connecting = "CONNECTING"
        case ended = "ENDED"
        case error = "ERROR"
        case incoming = "INCOMING"
        case missed = "MISSED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum CurrentMetricName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentsAfterContactWork = "AGENTS_AFTER_CONTACT_WORK"
        case agentsAvailable = "AGENTS_AVAILABLE"
        case agentsError = "AGENTS_ERROR"
        case agentsNonProductive = "AGENTS_NON_PRODUCTIVE"
        case agentsOnCall = "AGENTS_ON_CALL"
        case agentsOnContact = "AGENTS_ON_CONTACT"
        case agentsOnline = "AGENTS_ONLINE"
        case agentsStaffed = "AGENTS_STAFFED"
        case contactsInQueue = "CONTACTS_IN_QUEUE"
        case contactsScheduled = "CONTACTS_SCHEDULED"
        case oldestContactAge = "OLDEST_CONTACT_AGE"
        case slotsActive = "SLOTS_ACTIVE"
        case slotsAvailable = "SLOTS_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum DateComparisonType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        public var description: String { return self.rawValue }
    }

    public enum DeviceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case apns = "APNS"
        case apnsSandbox = "APNS_SANDBOX"
        case gcm = "GCM"
        public var description: String { return self.rawValue }
    }

    public enum DirectoryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectManaged = "CONNECT_MANAGED"
        case existingDirectory = "EXISTING_DIRECTORY"
        case saml = "SAML"
        public var description: String { return self.rawValue }
    }

    public enum EmailHeaderType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case inReplyTo = "IN_REPLY_TO"
        case messageId = "MESSAGE_ID"
        case references = "REFERENCES"
        case xSesSpamVerdict = "X_SES_SPAM_VERDICT"
        case xSesVirusVerdict = "X_SES_VIRUS_VERDICT"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum EndpointType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectPhonenumberArn = "CONNECT_PHONENUMBER_ARN"
        case contactFlow = "CONTACT_FLOW"
        case emailAddress = "EMAIL_ADDRESS"
        case telephoneNumber = "TELEPHONE_NUMBER"
        case voip = "VOIP"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationFormQuestionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case numeric = "NUMERIC"
        case singleselect = "SINGLESELECT"
        case text = "TEXT"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationFormScoringMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case questionOnly = "QUESTION_ONLY"
        case sectionOnly = "SECTION_ONLY"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationFormScoringStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationFormSingleSelectQuestionDisplayMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case dropdown = "DROPDOWN"
        case radio = "RADIO"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationFormVersionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case draft = "DRAFT"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case draft = "DRAFT"
        case submitted = "SUBMITTED"
        public var description: String { return self.rawValue }
    }

    public enum EventSourceName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case onCaseCreate = "OnCaseCreate"
        case onCaseUpdate = "OnCaseUpdate"
        case onContactEvaluationSubmit = "OnContactEvaluationSubmit"
        case onMetricDataUpdate = "OnMetricDataUpdate"
        case onPostCallAnalysisAvailable = "OnPostCallAnalysisAvailable"
        case onPostChatAnalysisAvailable = "OnPostChatAnalysisAvailable"
        case onRealTimeCallAnalysisAvailable = "OnRealTimeCallAnalysisAvailable"
        case onRealTimeChatAnalysisAvailable = "OnRealTimeChatAnalysisAvailable"
        case onSalesforceCaseCreate = "OnSalesforceCaseCreate"
        case onZendeskTicketCreate = "OnZendeskTicketCreate"
        case onZendeskTicketStatusUpdate = "OnZendeskTicketStatusUpdate"
        public var description: String { return self.rawValue }
    }

    public enum FailureReasonCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case idempotencyException = "IDEMPOTENCY_EXCEPTION"
        case internalError = "INTERNAL_ERROR"
        case invalidAttributeKey = "INVALID_ATTRIBUTE_KEY"
        case invalidCustomerEndpoint = "INVALID_CUSTOMER_ENDPOINT"
        case invalidQueue = "INVALID_QUEUE"
        case invalidSystemEndpoint = "INVALID_SYSTEM_ENDPOINT"
        case missingCampaign = "MISSING_CAMPAIGN"
        case missingCustomerEndpoint = "MISSING_CUSTOMER_ENDPOINT"
        case missingQueueIdAndSystemEndpoint = "MISSING_QUEUE_ID_AND_SYSTEM_ENDPOINT"
        case requestThrottled = "REQUEST_THROTTLED"
        public var description: String { return self.rawValue }
    }

    public enum FileStatusType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case failed = "FAILED"
        case processing = "PROCESSING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum FileUseCaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachment = "ATTACHMENT"
        case emailMessage = "EMAIL_MESSAGE"
        public var description: String { return self.rawValue }
    }

    public enum FlowAssociationResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analyticsConnector = "ANALYTICS_CONNECTOR"
        case inboundEmail = "INBOUND_EMAIL"
        case outboundEmail = "OUTBOUND_EMAIL"
        case smsPhoneNumber = "SMS_PHONE_NUMBER"
        case whatsappMessagingPhoneNumber = "WHATSAPP_MESSAGING_PHONE_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum Grouping: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case channel = "CHANNEL"
        case queue = "QUEUE"
        case routingProfile = "ROUTING_PROFILE"
        case routingStepExpression = "ROUTING_STEP_EXPRESSION"
        public var description: String { return self.rawValue }
    }

    public enum HierarchyGroupMatchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case exact = "EXACT"
        case withChildGroups = "WITH_CHILD_GROUPS"
        public var description: String { return self.rawValue }
    }

    public enum HistoricalMetricName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case abandonTime = "ABANDON_TIME"
        case afterContactWorkTime = "AFTER_CONTACT_WORK_TIME"
        case apiContactsHandled = "API_CONTACTS_HANDLED"
        case callbackContactsHandled = "CALLBACK_CONTACTS_HANDLED"
        case contactsAbandoned = "CONTACTS_ABANDONED"
        case contactsAgentHungUpFirst = "CONTACTS_AGENT_HUNG_UP_FIRST"
        case contactsConsulted = "CONTACTS_CONSULTED"
        case contactsHandled = "CONTACTS_HANDLED"
        case contactsHandledIncoming = "CONTACTS_HANDLED_INCOMING"
        case contactsHandledOutbound = "CONTACTS_HANDLED_OUTBOUND"
        case contactsHoldAbandons = "CONTACTS_HOLD_ABANDONS"
        case contactsMissed = "CONTACTS_MISSED"
        case contactsQueued = "CONTACTS_QUEUED"
        case contactsTransferredIn = "CONTACTS_TRANSFERRED_IN"
        case contactsTransferredInFromQueue = "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
        case contactsTransferredOut = "CONTACTS_TRANSFERRED_OUT"
        case contactsTransferredOutFromQueue = "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
        case handleTime = "HANDLE_TIME"
        case holdTime = "HOLD_TIME"
        case interactionAndHoldTime = "INTERACTION_AND_HOLD_TIME"
        case interactionTime = "INTERACTION_TIME"
        case occupancy = "OCCUPANCY"
        case queueAnswerTime = "QUEUE_ANSWER_TIME"
        case queuedTime = "QUEUED_TIME"
        case serviceLevel = "SERVICE_LEVEL"
        public var description: String { return self.rawValue }
    }

    public enum HoursOfOperationDays: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum InboundMessageSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case raw = "RAW"
        public var description: String { return self.rawValue }
    }

    public enum InitiateAs: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectedToUser = "CONNECTED_TO_USER"
        public var description: String { return self.rawValue }
    }

    public enum InstanceAttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case autoResolveBestVoices = "AUTO_RESOLVE_BEST_VOICES"
        case contactLens = "CONTACT_LENS"
        case contactflowLogs = "CONTACTFLOW_LOGS"
        case earlyMedia = "EARLY_MEDIA"
        case enhancedChatMonitoring = "ENHANCED_CHAT_MONITORING"
        case enhancedContactMonitoring = "ENHANCED_CONTACT_MONITORING"
        case highVolumeOutbound = "HIGH_VOLUME_OUTBOUND"
        case inboundCalls = "INBOUND_CALLS"
        case multiPartyChatConference = "MULTI_PARTY_CHAT_CONFERENCE"
        case multiPartyConference = "MULTI_PARTY_CONFERENCE"
        case outboundCalls = "OUTBOUND_CALLS"
        case useCustomTtsVoices = "USE_CUSTOM_TTS_VOICES"
        public var description: String { return self.rawValue }
    }

    public enum InstanceReplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case instanceReplicaDeleting = "INSTANCE_REPLICA_DELETING"
        case instanceReplicationComplete = "INSTANCE_REPLICATION_COMPLETE"
        case instanceReplicationDeletionFailed = "INSTANCE_REPLICATION_DELETION_FAILED"
        case instanceReplicationFailed = "INSTANCE_REPLICATION_FAILED"
        case instanceReplicationInProgress = "INSTANCE_REPLICATION_IN_PROGRESS"
        case resourceReplicationNotStarted = "RESOURCE_REPLICATION_NOT_STARTED"
        public var description: String { return self.rawValue }
    }

    public enum InstanceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum InstanceStorageResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentEvents = "AGENT_EVENTS"
        case attachments = "ATTACHMENTS"
        case callRecordings = "CALL_RECORDINGS"
        case chatTranscripts = "CHAT_TRANSCRIPTS"
        case contactEvaluations = "CONTACT_EVALUATIONS"
        case contactTraceRecords = "CONTACT_TRACE_RECORDS"
        case emailMessages = "EMAIL_MESSAGES"
        case mediaStreams = "MEDIA_STREAMS"
        case realTimeContactAnalysisChatSegments = "REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS"
        case realTimeContactAnalysisSegments = "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
        case realTimeContactAnalysisVoiceSegments = "REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS"
        case scheduledReports = "SCHEDULED_REPORTS"
        case screenRecordings = "SCREEN_RECORDINGS"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analyticsConnector = "ANALYTICS_CONNECTOR"
        case application = "APPLICATION"
        case callTransferConnector = "CALL_TRANSFER_CONNECTOR"
        case casesDomain = "CASES_DOMAIN"
        case cognitoUserPool = "COGNITO_USER_POOL"
        case event = "EVENT"
        case fileScanner = "FILE_SCANNER"
        case pinpointApp = "PINPOINT_APP"
        case qMessageTemplates = "Q_MESSAGE_TEMPLATES"
        case sesIdentity = "SES_IDENTITY"
        case voiceId = "VOICE_ID"
        case wisdomAssistant = "WISDOM_ASSISTANT"
        case wisdomKnowledgeBase = "WISDOM_KNOWLEDGE_BASE"
        case wisdomQuickResponses = "WISDOM_QUICK_RESPONSES"
        public var description: String { return self.rawValue }
    }

    public enum IntervalPeriod: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case day = "DAY"
        case fifteenMin = "FIFTEEN_MIN"
        case hour = "HOUR"
        case thirtyMin = "THIRTY_MIN"
        case total = "TOTAL"
        case week = "WEEK"
        public var description: String { return self.rawValue }
    }

    public enum IvrRecordingTrack: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        public var description: String { return self.rawValue }
    }

    public enum LexVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case v1 = "V1"
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    public enum ListFlowAssociationResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case analyticsConnector = "ANALYTICS_CONNECTOR"
        case inboundEmail = "INBOUND_EMAIL"
        case outboundEmail = "OUTBOUND_EMAIL"
        case voicePhoneNumber = "VOICE_PHONE_NUMBER"
        case whatsappMessagingPhoneNumber = "WHATSAPP_MESSAGING_PHONE_NUMBER"
        public var description: String { return self.rawValue }
    }

    public enum MeetingFeatureStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case available = "AVAILABLE"
        case unavailable = "UNAVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum MonitorCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case barge = "BARGE"
        case silentMonitor = "SILENT_MONITOR"
        public var description: String { return self.rawValue }
    }

    public enum NotificationContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case plainText = "PLAIN_TEXT"
        public var description: String { return self.rawValue }
    }

    public enum NotificationDeliveryType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case email = "EMAIL"
        public var description: String { return self.rawValue }
    }

    public enum NumberComparisonType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equal = "EQUAL"
        case greater = "GREATER"
        case greaterOrEqual = "GREATER_OR_EQUAL"
        case lesser = "LESSER"
        case lesserOrEqual = "LESSER_OR_EQUAL"
        case notEqual = "NOT_EQUAL"
        case range = "RANGE"
        public var description: String { return self.rawValue }
    }

    public enum NumericQuestionPropertyAutomationLabel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agentInteractionDuration = "AGENT_INTERACTION_DURATION"
        case contactDuration = "CONTACT_DURATION"
        case customerHoldTime = "CUSTOMER_HOLD_TIME"
        case nonTalkTime = "NON_TALK_TIME"
        case nonTalkTimePercentage = "NON_TALK_TIME_PERCENTAGE"
        case numberOfInterruptions = "NUMBER_OF_INTERRUPTIONS"
        case overallAgentSentimentScore = "OVERALL_AGENT_SENTIMENT_SCORE"
        case overallCustomerSentimentScore = "OVERALL_CUSTOMER_SENTIMENT_SCORE"
        public var description: String { return self.rawValue }
    }

    public enum OutboundMessageSourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case raw = "RAW"
        case template = "TEMPLATE"
        public var description: String { return self.rawValue }
    }

    public enum OverrideDays: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantRole: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case customBot = "CUSTOM_BOT"
        case customer = "CUSTOMER"
        case supervisor = "SUPERVISOR"
        case system = "SYSTEM"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTimerAction: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case unset = "Unset"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTimerType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disconnectNoncustomer = "DISCONNECT_NONCUSTOMER"
        case idle = "IDLE"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberCountryCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `as` = "AS"
        case `do` = "DO"
        case `in` = "IN"
        case `is` = "IS"
        case ad = "AD"
        case ae = "AE"
        case af = "AF"
        case ag = "AG"
        case ai = "AI"
        case al = "AL"
        case am = "AM"
        case an = "AN"
        case ao = "AO"
        case aq = "AQ"
        case ar = "AR"
        case at = "AT"
        case au = "AU"
        case aw = "AW"
        case az = "AZ"
        case ba = "BA"
        case bb = "BB"
        case bd = "BD"
        case be = "BE"
        case bf = "BF"
        case bg = "BG"
        case bh = "BH"
        case bi = "BI"
        case bj = "BJ"
        case bl = "BL"
        case bm = "BM"
        case bn = "BN"
        case bo = "BO"
        case br = "BR"
        case bs = "BS"
        case bt = "BT"
        case bw = "BW"
        case by = "BY"
        case bz = "BZ"
        case ca = "CA"
        case cc = "CC"
        case cd = "CD"
        case cf = "CF"
        case cg = "CG"
        case ch = "CH"
        case ci = "CI"
        case ck = "CK"
        case cl = "CL"
        case cm = "CM"
        case cn = "CN"
        case co = "CO"
        case cr = "CR"
        case cu = "CU"
        case cv = "CV"
        case cw = "CW"
        case cx = "CX"
        case cy = "CY"
        case cz = "CZ"
        case de = "DE"
        case dj = "DJ"
        case dk = "DK"
        case dm = "DM"
        case dz = "DZ"
        case ec = "EC"
        case ee = "EE"
        case eg = "EG"
        case eh = "EH"
        case er = "ER"
        case es = "ES"
        case et = "ET"
        case fi = "FI"
        case fj = "FJ"
        case fk = "FK"
        case fm = "FM"
        case fo = "FO"
        case fr = "FR"
        case ga = "GA"
        case gb = "GB"
        case gd = "GD"
        case ge = "GE"
        case gg = "GG"
        case gh = "GH"
        case gi = "GI"
        case gl = "GL"
        case gm = "GM"
        case gn = "GN"
        case gq = "GQ"
        case gr = "GR"
        case gt = "GT"
        case gu = "GU"
        case gw = "GW"
        case gy = "GY"
        case hk = "HK"
        case hn = "HN"
        case hr = "HR"
        case ht = "HT"
        case hu = "HU"
        case id = "ID"
        case ie = "IE"
        case il = "IL"
        case im = "IM"
        case io = "IO"
        case iq = "IQ"
        case ir = "IR"
        case it = "IT"
        case je = "JE"
        case jm = "JM"
        case jo = "JO"
        case jp = "JP"
        case ke = "KE"
        case kg = "KG"
        case kh = "KH"
        case ki = "KI"
        case km = "KM"
        case kn = "KN"
        case kp = "KP"
        case kr = "KR"
        case kw = "KW"
        case ky = "KY"
        case kz = "KZ"
        case la = "LA"
        case lb = "LB"
        case lc = "LC"
        case li = "LI"
        case lk = "LK"
        case lr = "LR"
        case ls = "LS"
        case lt = "LT"
        case lu = "LU"
        case lv = "LV"
        case ly = "LY"
        case ma = "MA"
        case mc = "MC"
        case md = "MD"
        case me = "ME"
        case mf = "MF"
        case mg = "MG"
        case mh = "MH"
        case mk = "MK"
        case ml = "ML"
        case mm = "MM"
        case mn = "MN"
        case mo = "MO"
        case mp = "MP"
        case mr = "MR"
        case ms = "MS"
        case mt = "MT"
        case mu = "MU"
        case mv = "MV"
        case mw = "MW"
        case mx = "MX"
        case my = "MY"
        case mz = "MZ"
        case na = "NA"
        case nc = "NC"
        case ne = "NE"
        case ng = "NG"
        case ni = "NI"
        case nl = "NL"
        case no = "NO"
        case np = "NP"
        case nr = "NR"
        case nu = "NU"
        case nz = "NZ"
        case om = "OM"
        case pa = "PA"
        case pe = "PE"
        case pf = "PF"
        case pg = "PG"
        case ph = "PH"
        case pk = "PK"
        case pl = "PL"
        case pm = "PM"
        case pn = "PN"
        case pr = "PR"
        case pt = "PT"
        case pw = "PW"
        case py = "PY"
        case qa = "QA"
        case re = "RE"
        case ro = "RO"
        case rs = "RS"
        case ru = "RU"
        case rw = "RW"
        case sa = "SA"
        case sb = "SB"
        case sc = "SC"
        case sd = "SD"
        case se = "SE"
        case sg = "SG"
        case sh = "SH"
        case si = "SI"
        case sj = "SJ"
        case sk = "SK"
        case sl = "SL"
        case sm = "SM"
        case sn = "SN"
        case so = "SO"
        case sr = "SR"
        case st = "ST"
        case sv = "SV"
        case sx = "SX"
        case sy = "SY"
        case sz = "SZ"
        case tc = "TC"
        case td = "TD"
        case tg = "TG"
        case th = "TH"
        case tj = "TJ"
        case tk = "TK"
        case tl = "TL"
        case tm = "TM"
        case tn = "TN"
        case to = "TO"
        case tr = "TR"
        case tt = "TT"
        case tv = "TV"
        case tw = "TW"
        case tz = "TZ"
        case ua = "UA"
        case ug = "UG"
        case us = "US"
        case uy = "UY"
        case uz = "UZ"
        case va = "VA"
        case vc = "VC"
        case ve = "VE"
        case vg = "VG"
        case vi = "VI"
        case vn = "VN"
        case vu = "VU"
        case wf = "WF"
        case ws = "WS"
        case ye = "YE"
        case yt = "YT"
        case za = "ZA"
        case zm = "ZM"
        case zw = "ZW"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case did = "DID"
        case shared = "SHARED"
        case shortCode = "SHORT_CODE"
        case thirdPartyDid = "THIRD_PARTY_DID"
        case thirdPartyTf = "THIRD_PARTY_TF"
        case tollFree = "TOLL_FREE"
        case uifn = "UIFN"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberWorkflowStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case claimed = "CLAIMED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum PhoneType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deskPhone = "DESK_PHONE"
        case softPhone = "SOFT_PHONE"
        public var description: String { return self.rawValue }
    }

    public enum PropertyValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case invalidFormat = "INVALID_FORMAT"
        case notSupported = "NOT_SUPPORTED"
        case referencedResourceNotFound = "REFERENCED_RESOURCE_NOT_FOUND"
        case requiredPropertyMissing = "REQUIRED_PROPERTY_MISSING"
        case resourceNameAlreadyExists = "RESOURCE_NAME_ALREADY_EXISTS"
        case uniqueConstraintViolated = "UNIQUE_CONSTRAINT_VIOLATED"
        public var description: String { return self.rawValue }
    }

    public enum QueueStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum QueueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum QuickConnectType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case phoneNumber = "PHONE_NUMBER"
        case queue = "QUEUE"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeContactAnalysisOutputType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case raw = "Raw"
        case redacted = "Redacted"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeContactAnalysisPostContactSummaryFailureCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failedSafetyGuidelines = "FAILED_SAFETY_GUIDELINES"
        case insufficientConversationContent = "INSUFFICIENT_CONVERSATION_CONTENT"
        case internalError = "INTERNAL_ERROR"
        case invalidAnalysisConfiguration = "INVALID_ANALYSIS_CONFIGURATION"
        case quotaExceeded = "QUOTA_EXCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeContactAnalysisPostContactSummaryStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeContactAnalysisSegmentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachments = "Attachments"
        case categories = "Categories"
        case event = "Event"
        case issues = "Issues"
        case postContactSummary = "PostContactSummary"
        case transcript = "Transcript"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeContactAnalysisSentimentLabel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case negative = "NEGATIVE"
        case neutral = "NEUTRAL"
        case positive = "POSITIVE"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeContactAnalysisStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum RealTimeContactAnalysisSupportedChannel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chat = "CHAT"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case approved = "APPROVED"
        case available = "AVAILABLE"
        case deleted = "DELETED"
        case failed = "FAILED"
        case processing = "PROCESSING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case attachment = "ATTACHMENT"
        case contactAnalysis = "CONTACT_ANALYSIS"
        case date = "DATE"
        case email = "EMAIL"
        case emailMessage = "EMAIL_MESSAGE"
        case number = "NUMBER"
        case string = "STRING"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum RehydrationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case entirePastSession = "ENTIRE_PAST_SESSION"
        case fromSegment = "FROM_SEGMENT"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contact = "CONTACT"
        case contactFlow = "CONTACT_FLOW"
        case hierarchyGroup = "HIERARCHY_GROUP"
        case hierarchyLevel = "HIERARCHY_LEVEL"
        case instance = "INSTANCE"
        case participant = "PARTICIPANT"
        case phoneNumber = "PHONE_NUMBER"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum RoutingCriteriaStepStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case expired = "EXPIRED"
        case inactive = "INACTIVE"
        case joined = "JOINED"
        public var description: String { return self.rawValue }
    }

    public enum RulePublishStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case draft = "DRAFT"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum ScreenShareCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case send = "SEND"
        public var description: String { return self.rawValue }
    }

    public enum SearchContactsMatchType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case matchAll = "MATCH_ALL"
        case matchAny = "MATCH_ANY"
        public var description: String { return self.rawValue }
    }

    public enum SearchContactsTimeRangeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectedToAgentTimestamp = "CONNECTED_TO_AGENT_TIMESTAMP"
        case disconnectTimestamp = "DISCONNECT_TIMESTAMP"
        case initiationTimestamp = "INITIATION_TIMESTAMP"
        case scheduledTimestamp = "SCHEDULED_TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum SearchableQueueType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum SingleSelectQuestionRuleCategoryAutomationCondition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notPresent = "NOT_PRESENT"
        case present = "PRESENT"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SortableFieldName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case channel = "CHANNEL"
        case connectedToAgentTimestamp = "CONNECTED_TO_AGENT_TIMESTAMP"
        case disconnectTimestamp = "DISCONNECT_TIMESTAMP"
        case initiationMethod = "INITIATION_METHOD"
        case initiationTimestamp = "INITIATION_TIMESTAMP"
        case scheduledTimestamp = "SCHEDULED_TIMESTAMP"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cases = "CASES"
        case salesforce = "SALESFORCE"
        case zendesk = "ZENDESK"
        public var description: String { return self.rawValue }
    }

    public enum Statistic: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case avg = "AVG"
        case max = "MAX"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kinesisFirehose = "KINESIS_FIREHOSE"
        case kinesisStream = "KINESIS_STREAM"
        case kinesisVideoStream = "KINESIS_VIDEO_STREAM"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum StringComparisonType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contains = "CONTAINS"
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum TargetListType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case proficiencies = "PROFICIENCIES"
        public var description: String { return self.rawValue }
    }

    public enum TaskTemplateFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case boolean = "BOOLEAN"
        case dateTime = "DATE_TIME"
        case description = "DESCRIPTION"
        case email = "EMAIL"
        case expiryDuration = "EXPIRY_DURATION"
        case name = "NAME"
        case number = "NUMBER"
        case quickConnect = "QUICK_CONNECT"
        case scheduledTime = "SCHEDULED_TIME"
        case selfAssign = "SELF_ASSIGN"
        case singleSelect = "SINGLE_SELECT"
        case text = "TEXT"
        case textArea = "TEXT_AREA"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum TaskTemplateStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TimerEligibleParticipantRoles: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agent = "AGENT"
        case customer = "CUSTOMER"
        public var description: String { return self.rawValue }
    }

    public enum TrafficDistributionGroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case deletionFailed = "DELETION_FAILED"
        case pendingDeletion = "PENDING_DELETION"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TrafficType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case campaign = "CAMPAIGN"
        case general = "GENERAL"
        public var description: String { return self.rawValue }
    }

    public enum Unit: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case count = "COUNT"
        case percent = "PERCENT"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public enum UseCaseType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectCampaigns = "CONNECT_CAMPAIGNS"
        case rulesEvaluation = "RULES_EVALUATION"
        public var description: String { return self.rawValue }
    }

    public enum VideoCapability: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case send = "SEND"
        public var description: String { return self.rawValue }
    }

    public enum ViewStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case published = "PUBLISHED"
        case saved = "SAVED"
        public var description: String { return self.rawValue }
    }

    public enum ViewType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsManaged = "AWS_MANAGED"
        case customerManaged = "CUSTOMER_MANAGED"
        public var description: String { return self.rawValue }
    }

    public enum VocabularyLanguageCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case arAe = "ar-AE"
        case caEs = "ca-ES"
        case daDk = "da-DK"
        case deCh = "de-CH"
        case deDe = "de-DE"
        case enAb = "en-AB"
        case enAu = "en-AU"
        case enGb = "en-GB"
        case enIe = "en-IE"
        case enIn = "en-IN"
        case enNz = "en-NZ"
        case enUs = "en-US"
        case enWl = "en-WL"
        case enZa = "en-ZA"
        case esEs = "es-ES"
        case esUs = "es-US"
        case fiFi = "fi-FI"
        case frCa = "fr-CA"
        case frFr = "fr-FR"
        case hiIn = "hi-IN"
        case idId = "id-ID"
        case itIt = "it-IT"
        case jaJp = "ja-JP"
        case koKr = "ko-KR"
        case msMy = "ms-MY"
        case nlNl = "nl-NL"
        case noNo = "no-NO"
        case plPl = "pl-PL"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case svSe = "sv-SE"
        case tlPh = "tl-PH"
        case zhCn = "zh-CN"
        public var description: String { return self.rawValue }
    }

    public enum VocabularyState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum VoiceRecordingTrack: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case fromAgent = "FROM_AGENT"
        case toAgent = "TO_AGENT"
        public var description: String { return self.rawValue }
    }

    public enum CreatedByInfo: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// STS or IAM ARN representing the identity of API Caller. SDK users cannot populate this and this value is calculated automatically if ConnectUserArn is not provided.
        case awsIdentityArn(String)
        /// An agent ARN representing a connect user.
        case connectUserArn(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .awsIdentityArn:
                let value = try container.decode(String.self, forKey: .awsIdentityArn)
                self = .awsIdentityArn(value)
            case .connectUserArn:
                let value = try container.decode(String.self, forKey: .connectUserArn)
                self = .connectUserArn(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .awsIdentityArn(let value):
                try container.encode(value, forKey: .awsIdentityArn)
            case .connectUserArn(let value):
                try container.encode(value, forKey: .connectUserArn)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case awsIdentityArn = "AWSIdentityArn"
            case connectUserArn = "ConnectUserArn"
        }
    }

    public enum EvaluationAnswerData: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The flag to mark the question as not applicable.
        case notApplicable(Bool)
        /// The numeric value for an answer in a contact evaluation.
        case numericValue(Double)
        /// The string value for an answer in a contact evaluation.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .notApplicable:
                let value = try container.decode(Bool.self, forKey: .notApplicable)
                self = .notApplicable(value)
            case .numericValue:
                let value = try container.decode(Double.self, forKey: .numericValue)
                self = .numericValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .notApplicable(let value):
                try container.encode(value, forKey: .notApplicable)
            case .numericValue(let value):
                try container.encode(value, forKey: .numericValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .stringValue(let value):
                try self.validate(value, name: "stringValue", parent: name, max: 128)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case notApplicable = "NotApplicable"
            case numericValue = "NumericValue"
            case stringValue = "StringValue"
        }
    }

    public enum EvaluationFormItem: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The information of the question.
        case question(EvaluationFormQuestion)
        /// The information of the section.
        case section(EvaluationFormSection)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .question:
                let value = try container.decode(EvaluationFormQuestion.self, forKey: .question)
                self = .question(value)
            case .section:
                let value = try container.decode(EvaluationFormSection.self, forKey: .section)
                self = .section(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .question(let value):
                try container.encode(value, forKey: .question)
            case .section(let value):
                try container.encode(value, forKey: .section)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .question(let value):
                try value.validate(name: "\(name).question")
            case .section(let value):
                try value.validate(name: "\(name).section")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case question = "Question"
            case section = "Section"
        }
    }

    public enum EvaluationFormQuestionTypeProperties: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The properties of the numeric question.
        case numeric(EvaluationFormNumericQuestionProperties)
        /// The properties of the numeric question.
        case singleSelect(EvaluationFormSingleSelectQuestionProperties)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .numeric:
                let value = try container.decode(EvaluationFormNumericQuestionProperties.self, forKey: .numeric)
                self = .numeric(value)
            case .singleSelect:
                let value = try container.decode(EvaluationFormSingleSelectQuestionProperties.self, forKey: .singleSelect)
                self = .singleSelect(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .numeric(let value):
                try container.encode(value, forKey: .numeric)
            case .singleSelect(let value):
                try container.encode(value, forKey: .singleSelect)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .numeric(let value):
                try value.validate(name: "\(name).numeric")
            case .singleSelect(let value):
                try value.validate(name: "\(name).singleSelect")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case numeric = "Numeric"
            case singleSelect = "SingleSelect"
        }
    }

    public enum ParticipantTimerValue: AWSEncodableShape, Sendable {
        /// The timer action. Currently only one value is allowed: Unset. It deletes a timer.
        case participantTimerAction(ParticipantTimerAction)
        /// The duration of a timer, in minutes.
        case participantTimerDurationInMinutes(Int)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .participantTimerAction(let value):
                try container.encode(value, forKey: .participantTimerAction)
            case .participantTimerDurationInMinutes(let value):
                try container.encode(value, forKey: .participantTimerDurationInMinutes)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .participantTimerDurationInMinutes(let value):
                try self.validate(value, name: "participantTimerDurationInMinutes", parent: name, max: 480)
                try self.validate(value, name: "participantTimerDurationInMinutes", parent: name, min: 2)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case participantTimerAction = "ParticipantTimerAction"
            case participantTimerDurationInMinutes = "ParticipantTimerDurationInMinutes"
        }
    }

    public enum RealtimeContactAnalysisSegment: AWSDecodableShape, Sendable {
        /// The analyzed attachments.
        case attachments(RealTimeContactAnalysisSegmentAttachments)
        case categories(RealTimeContactAnalysisSegmentCategories)
        case event(RealTimeContactAnalysisSegmentEvent)
        case issues(RealTimeContactAnalysisSegmentIssues)
        /// Information about the post-contact summary.
        case postContactSummary(RealTimeContactAnalysisSegmentPostContactSummary)
        case transcript(RealTimeContactAnalysisSegmentTranscript)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .attachments:
                let value = try container.decode(RealTimeContactAnalysisSegmentAttachments.self, forKey: .attachments)
                self = .attachments(value)
            case .categories:
                let value = try container.decode(RealTimeContactAnalysisSegmentCategories.self, forKey: .categories)
                self = .categories(value)
            case .event:
                let value = try container.decode(RealTimeContactAnalysisSegmentEvent.self, forKey: .event)
                self = .event(value)
            case .issues:
                let value = try container.decode(RealTimeContactAnalysisSegmentIssues.self, forKey: .issues)
                self = .issues(value)
            case .postContactSummary:
                let value = try container.decode(RealTimeContactAnalysisSegmentPostContactSummary.self, forKey: .postContactSummary)
                self = .postContactSummary(value)
            case .transcript:
                let value = try container.decode(RealTimeContactAnalysisSegmentTranscript.self, forKey: .transcript)
                self = .transcript(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "Attachments"
            case categories = "Categories"
            case event = "Event"
            case issues = "Issues"
            case postContactSummary = "PostContactSummary"
            case transcript = "Transcript"
        }
    }

    public enum ReferenceSummary: AWSDecodableShape, Sendable {
        /// Information about the reference when the referenceType is ATTACHMENT. Otherwise, null.
        case attachment(AttachmentReference)
        /// Information about a reference when the referenceType is DATE. Otherwise, null.
        case date(DateReference)
        /// Information about a reference when the referenceType is EMAIL. Otherwise, null.
        case email(EmailReference)
        /// Information about the reference when the referenceType is EMAIL_MESSAGE. Otherwise, null.
        case emailMessage(EmailMessageReference)
        /// Information about a reference when the referenceType is NUMBER. Otherwise, null.
        case number(NumberReference)
        /// Information about a reference when the referenceType is STRING. Otherwise, null.
        case string(StringReference)
        /// Information about the reference when the referenceType is URL. Otherwise, null.
        case url(UrlReference)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .attachment:
                let value = try container.decode(AttachmentReference.self, forKey: .attachment)
                self = .attachment(value)
            case .date:
                let value = try container.decode(DateReference.self, forKey: .date)
                self = .date(value)
            case .email:
                let value = try container.decode(EmailReference.self, forKey: .email)
                self = .email(value)
            case .emailMessage:
                let value = try container.decode(EmailMessageReference.self, forKey: .emailMessage)
                self = .emailMessage(value)
            case .number:
                let value = try container.decode(NumberReference.self, forKey: .number)
                self = .number(value)
            case .string:
                let value = try container.decode(StringReference.self, forKey: .string)
                self = .string(value)
            case .url:
                let value = try container.decode(UrlReference.self, forKey: .url)
                self = .url(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case date = "Date"
            case email = "Email"
            case emailMessage = "EmailMessage"
            case number = "Number"
            case string = "String"
            case url = "Url"
        }
    }

    // MARK: Shapes

    public struct ActionSummary: AWSDecodableShape {
        /// The action type.
        public let actionType: ActionType

        @inlinable
        public init(actionType: ActionType) {
            self.actionType = actionType
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "ActionType"
        }
    }

    public struct ActivateEvaluationFormRequest: AWSEncodableShape {
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// The version of the evaluation form to activate. If the version property is not provided, the latest version of the evaluation form is activated.
        public let evaluationFormVersion: Int
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(evaluationFormId: String, evaluationFormVersion: Int = 0, instanceId: String) {
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluationFormId, key: "EvaluationFormId")
            try container.encode(self.evaluationFormVersion, forKey: .evaluationFormVersion)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 500)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
            try self.validate(self.evaluationFormVersion, name: "evaluationFormVersion", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormVersion = "EvaluationFormVersion"
        }
    }

    public struct ActivateEvaluationFormResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// A version of the evaluation form.
        public let evaluationFormVersion: Int

        @inlinable
        public init(evaluationFormArn: String, evaluationFormId: String, evaluationFormVersion: Int) {
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
            case evaluationFormVersion = "EvaluationFormVersion"
        }
    }

    public struct AdditionalEmailRecipients: AWSDecodableShape {
        /// List of additional CC email recipients for an email contact.
        public let ccList: [EmailRecipient]?
        /// List of additional TO email recipients for an email contact.
        public let toList: [EmailRecipient]?

        @inlinable
        public init(ccList: [EmailRecipient]? = nil, toList: [EmailRecipient]? = nil) {
            self.ccList = ccList
            self.toList = toList
        }

        private enum CodingKeys: String, CodingKey {
            case ccList = "CcList"
            case toList = "ToList"
        }
    }

    public struct AgentConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about traffic distributions.
        public let distributions: [Distribution]

        @inlinable
        public init(distributions: [Distribution]) {
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case distributions = "Distributions"
        }
    }

    public struct AgentContactReference: AWSDecodableShape {
        /// The state of the contact.  When AgentContactState is set to CONNECTED_ONHOLD, StateStartTimestamp is not changed. Instead, StateStartTimestamp reflects the time the contact was CONNECTED to the agent.
        public let agentContactState: ContactState?
        /// The channel of the contact.
        public let channel: Channel?
        /// The time at which the contact was connected to an agent.
        public let connectedToAgentTimestamp: Date?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?
        /// How the contact was initiated.
        public let initiationMethod: ContactInitiationMethod?
        public let queue: QueueReference?
        /// The epoch timestamp when the contact state started.
        public let stateStartTimestamp: Date?

        @inlinable
        public init(agentContactState: ContactState? = nil, channel: Channel? = nil, connectedToAgentTimestamp: Date? = nil, contactId: String? = nil, initiationMethod: ContactInitiationMethod? = nil, queue: QueueReference? = nil, stateStartTimestamp: Date? = nil) {
            self.agentContactState = agentContactState
            self.channel = channel
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.contactId = contactId
            self.initiationMethod = initiationMethod
            self.queue = queue
            self.stateStartTimestamp = stateStartTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case agentContactState = "AgentContactState"
            case channel = "Channel"
            case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
            case contactId = "ContactId"
            case initiationMethod = "InitiationMethod"
            case queue = "Queue"
            case stateStartTimestamp = "StateStartTimestamp"
        }
    }

    public struct AgentHierarchyGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the group.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct AgentHierarchyGroups: AWSEncodableShape {
        /// The identifiers for level 1 hierarchy groups.
        public let l1Ids: [String]?
        /// The identifiers for level 2 hierarchy groups.
        public let l2Ids: [String]?
        /// The identifiers for level 3 hierarchy groups.
        public let l3Ids: [String]?
        /// The identifiers for level 4 hierarchy groups.
        public let l4Ids: [String]?
        /// The identifiers for level 5 hierarchy groups.
        public let l5Ids: [String]?

        @inlinable
        public init(l1Ids: [String]? = nil, l2Ids: [String]? = nil, l3Ids: [String]? = nil, l4Ids: [String]? = nil, l5Ids: [String]? = nil) {
            self.l1Ids = l1Ids
            self.l2Ids = l2Ids
            self.l3Ids = l3Ids
            self.l4Ids = l4Ids
            self.l5Ids = l5Ids
        }

        public func validate(name: String) throws {
            try self.validate(self.l1Ids, name: "l1Ids", parent: name, max: 10)
            try self.validate(self.l2Ids, name: "l2Ids", parent: name, max: 10)
            try self.validate(self.l3Ids, name: "l3Ids", parent: name, max: 10)
            try self.validate(self.l4Ids, name: "l4Ids", parent: name, max: 10)
            try self.validate(self.l5Ids, name: "l5Ids", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case l1Ids = "L1Ids"
            case l2Ids = "L2Ids"
            case l3Ids = "L3Ids"
            case l4Ids = "L4Ids"
            case l5Ids = "L5Ids"
        }
    }

    public struct AgentInfo: AWSDecodableShape {
        /// Agent pause duration for a contact in seconds.
        public let agentPauseDurationInSeconds: Int?
        public let capabilities: ParticipantCapabilities?
        /// The timestamp when the contact was connected to the agent.
        public let connectedToAgentTimestamp: Date?
        /// Information regarding Agents device.
        public let deviceInfo: DeviceInfo?
        /// The agent hierarchy groups for the agent.
        public let hierarchyGroups: HierarchyGroups?
        /// The identifier of the agent who accepted the contact.
        public let id: String?

        @inlinable
        public init(agentPauseDurationInSeconds: Int? = nil, capabilities: ParticipantCapabilities? = nil, connectedToAgentTimestamp: Date? = nil, deviceInfo: DeviceInfo? = nil, hierarchyGroups: HierarchyGroups? = nil, id: String? = nil) {
            self.agentPauseDurationInSeconds = agentPauseDurationInSeconds
            self.capabilities = capabilities
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.deviceInfo = deviceInfo
            self.hierarchyGroups = hierarchyGroups
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case agentPauseDurationInSeconds = "AgentPauseDurationInSeconds"
            case capabilities = "Capabilities"
            case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
            case deviceInfo = "DeviceInfo"
            case hierarchyGroups = "HierarchyGroups"
            case id = "Id"
        }
    }

    public struct AgentQualityMetrics: AWSDecodableShape {
        /// Information about the audio quality of the Agent
        public let audio: AudioQualityMetricsInfo?

        @inlinable
        public init(audio: AudioQualityMetricsInfo? = nil) {
            self.audio = audio
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
        }
    }

    public struct AgentStatus: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent status.
        public let agentStatusARN: String?
        /// The identifier of the agent status.
        public let agentStatusId: String?
        /// The description of the agent status.
        public let description: String?
        /// The display order of the agent status.
        public let displayOrder: Int?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the agent status.
        public let name: String?
        /// The state of the agent status.
        public let state: AgentStatusState?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of agent status.
        public let type: AgentStatusType?

        @inlinable
        public init(agentStatusARN: String? = nil, agentStatusId: String? = nil, description: String? = nil, displayOrder: Int? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, state: AgentStatusState? = nil, tags: [String: String]? = nil, type: AgentStatusType? = nil) {
            self.agentStatusARN = agentStatusARN
            self.agentStatusId = agentStatusId
            self.description = description
            self.displayOrder = displayOrder
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusARN = "AgentStatusARN"
            case agentStatusId = "AgentStatusId"
            case description = "Description"
            case displayOrder = "DisplayOrder"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct AgentStatusReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent's status.
        public let statusArn: String?
        /// The name of the agent status.
        public let statusName: String?
        /// The start timestamp of the agent's status.
        public let statusStartTimestamp: Date?

        @inlinable
        public init(statusArn: String? = nil, statusName: String? = nil, statusStartTimestamp: Date? = nil) {
            self.statusArn = statusArn
            self.statusName = statusName
            self.statusStartTimestamp = statusStartTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case statusArn = "StatusArn"
            case statusName = "StatusName"
            case statusStartTimestamp = "StatusStartTimestamp"
        }
    }

    public struct AgentStatusSearchCriteria: AWSEncodableShape {
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name, description, state, type, displayOrder, and resourceID.
        public let andConditions: [AgentStatusSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [AgentStatusSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name, description, state, type, displayOrder, and resourceID.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [AgentStatusSearchCriteria]? = nil, orConditions: [AgentStatusSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct AgentStatusSearchFilter: AWSEncodableShape {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:    The top level list specifies conditions that need to be applied with OR operator.   The inner list specifies conditions that need to be applied with AND operator.
        public let attributeFilter: ControlPlaneAttributeFilter?

        @inlinable
        public init(attributeFilter: ControlPlaneAttributeFilter? = nil) {
            self.attributeFilter = attributeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "AttributeFilter"
        }
    }

    public struct AgentStatusSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the agent status.
        public let arn: String?
        /// The identifier for an agent status.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the agent status.
        public let name: String?
        /// The type of the agent status.
        public let type: AgentStatusType?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, type: AgentStatusType? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct AgentsCriteria: AWSEncodableShape & AWSDecodableShape {
        /// An object to specify a list of agents, by user ID.
        public let agentIds: [String]?

        @inlinable
        public init(agentIds: [String]? = nil) {
            self.agentIds = agentIds
        }

        public func validate(name: String) throws {
            try self.agentIds?.forEach {
                try validate($0, name: "agentIds[]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case agentIds = "AgentIds"
        }
    }

    public struct AllowedCapabilities: AWSEncodableShape {
        /// Information about the agent's video sharing capabilities.
        public let agent: ParticipantCapabilities?
        /// Information about the customer's video sharing capabilities.
        public let customer: ParticipantCapabilities?

        @inlinable
        public init(agent: ParticipantCapabilities? = nil, customer: ParticipantCapabilities? = nil) {
            self.agent = agent
            self.customer = customer
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "Agent"
            case customer = "Customer"
        }
    }

    public struct AnalyticsDataAssociationResult: AWSDecodableShape {
        /// The identifier of the dataset.
        public let dataSetId: String?
        /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
        public let resourceShareArn: String?
        /// The Resource Access Manager share ID.
        public let resourceShareId: String?
        /// The Amazon Web Services Resource Access Manager status of association.
        public let resourceShareStatus: String?
        /// The identifier of the target account.
        public let targetAccountId: String?

        @inlinable
        public init(dataSetId: String? = nil, resourceShareArn: String? = nil, resourceShareId: String? = nil, resourceShareStatus: String? = nil, targetAccountId: String? = nil) {
            self.dataSetId = dataSetId
            self.resourceShareArn = resourceShareArn
            self.resourceShareId = resourceShareId
            self.resourceShareStatus = resourceShareStatus
            self.targetAccountId = targetAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case resourceShareArn = "ResourceShareArn"
            case resourceShareId = "ResourceShareId"
            case resourceShareStatus = "ResourceShareStatus"
            case targetAccountId = "TargetAccountId"
        }
    }

    public struct AnalyticsDataSetsResult: AWSDecodableShape {
        /// The identifier of the dataset.
        public let dataSetId: String?
        /// The name of the dataset.
        public let dataSetName: String?

        @inlinable
        public init(dataSetId: String? = nil, dataSetName: String? = nil) {
            self.dataSetId = dataSetId
            self.dataSetName = dataSetName
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case dataSetName = "DataSetName"
        }
    }

    public struct AnswerMachineDetectionConfig: AWSEncodableShape {
        /// Wait for the answering machine prompt.
        public let awaitAnswerMachinePrompt: Bool?
        /// The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to true, TrafficType must be set as CAMPAIGN.
        public let enableAnswerMachineDetection: Bool?

        @inlinable
        public init(awaitAnswerMachinePrompt: Bool? = nil, enableAnswerMachineDetection: Bool? = nil) {
            self.awaitAnswerMachinePrompt = awaitAnswerMachinePrompt
            self.enableAnswerMachineDetection = enableAnswerMachineDetection
        }

        private enum CodingKeys: String, CodingKey {
            case awaitAnswerMachinePrompt = "AwaitAnswerMachinePrompt"
            case enableAnswerMachineDetection = "EnableAnswerMachineDetection"
        }
    }

    public struct Application: AWSEncodableShape & AWSDecodableShape {
        /// The permissions that the agent is granted on the application. Only the ACCESS permission is supported.
        public let applicationPermissions: [String]?
        /// Namespace of the application that you want to give access to.
        public let namespace: String?

        @inlinable
        public init(applicationPermissions: [String]? = nil, namespace: String? = nil) {
            self.applicationPermissions = applicationPermissions
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.applicationPermissions?.forEach {
                try validate($0, name: "applicationPermissions[]", parent: name, max: 128)
                try validate($0, name: "applicationPermissions[]", parent: name, min: 1)
            }
            try self.validate(self.applicationPermissions, name: "applicationPermissions", parent: name, max: 10)
            try self.validate(self.applicationPermissions, name: "applicationPermissions", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, max: 128)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case applicationPermissions = "ApplicationPermissions"
            case namespace = "Namespace"
        }
    }

    public struct AssignContactCategoryActionDefinition: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AssociateAnalyticsDataSetRequest: AWSEncodableShape {
        /// The identifier of the dataset to associate with the target account.
        public let dataSetId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the target account.  Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
        public let targetAccountId: String?

        @inlinable
        public init(dataSetId: String, instanceId: String, targetAccountId: String? = nil) {
            self.dataSetId = dataSetId
            self.instanceId = instanceId
            self.targetAccountId = targetAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataSetId, forKey: .dataSetId)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.targetAccountId, forKey: .targetAccountId)
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetId, name: "dataSetId", parent: name, max: 255)
            try self.validate(self.dataSetId, name: "dataSetId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case targetAccountId = "TargetAccountId"
        }
    }

    public struct AssociateAnalyticsDataSetResponse: AWSDecodableShape {
        /// The identifier of the dataset that was associated.
        public let dataSetId: String?
        /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
        public let resourceShareArn: String?
        /// The Resource Access Manager share ID that is generated.
        public let resourceShareId: String?
        /// The identifier of the target account.
        public let targetAccountId: String?

        @inlinable
        public init(dataSetId: String? = nil, resourceShareArn: String? = nil, resourceShareId: String? = nil, targetAccountId: String? = nil) {
            self.dataSetId = dataSetId
            self.resourceShareArn = resourceShareArn
            self.resourceShareId = resourceShareId
            self.targetAccountId = targetAccountId
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case resourceShareArn = "ResourceShareArn"
            case resourceShareId = "ResourceShareId"
            case targetAccountId = "TargetAccountId"
        }
    }

    public struct AssociateApprovedOriginRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The domain to add to your allow list.
        public let origin: String

        @inlinable
        public init(clientToken: String? = AssociateApprovedOriginRequest.idempotencyToken(), instanceId: String, origin: String) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.origin, forKey: .origin)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.origin, name: "origin", parent: name, max: 267)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case origin = "Origin"
        }
    }

    public struct AssociateBotRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        public let lexBot: LexBot?
        /// The Amazon Lex V2 bot to associate with the instance.
        public let lexV2Bot: LexV2Bot?

        @inlinable
        public init(clientToken: String? = AssociateBotRequest.idempotencyToken(), instanceId: String, lexBot: LexBot? = nil, lexV2Bot: LexV2Bot? = nil) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.lexBot, forKey: .lexBot)
            try container.encodeIfPresent(self.lexV2Bot, forKey: .lexV2Bot)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.lexBot?.validate(name: "\(name).lexBot")
            try self.lexV2Bot?.validate(name: "\(name).lexV2Bot")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case lexBot = "LexBot"
            case lexV2Bot = "LexV2Bot"
        }
    }

    public struct AssociateDefaultVocabularyRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The identifier of the custom vocabulary. If this is empty, the default is set to none.
        public let vocabularyId: String?

        @inlinable
        public init(instanceId: String, languageCode: VocabularyLanguageCode, vocabularyId: String? = nil) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.vocabularyId = vocabularyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.languageCode, key: "LanguageCode")
            try container.encodeIfPresent(self.vocabularyId, forKey: .vocabularyId)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, max: 500)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vocabularyId = "VocabularyId"
        }
    }

    public struct AssociateDefaultVocabularyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateFlowRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let flowId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the resource.   Amazon Web Services End User Messaging SMS phone number ARN when using SMS_PHONE_NUMBER    Amazon Web Services End User Messaging Social phone number ARN when using WHATSAPP_MESSAGING_PHONE_NUMBER
        public let resourceId: String
        /// A valid resource type.
        public let resourceType: FlowAssociationResourceType

        @inlinable
        public init(flowId: String, instanceId: String, resourceId: String, resourceType: FlowAssociationResourceType) {
            self.flowId = flowId
            self.instanceId = instanceId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.flowId, forKey: .flowId)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.resourceId, forKey: .resourceId)
            try container.encode(self.resourceType, forKey: .resourceType)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case flowId = "FlowId"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct AssociateFlowResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateInstanceStorageConfigRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A valid resource type. To enable streaming for real-time analysis of contacts, use the following types:   For chat contacts, use REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS.   For voice contacts, use REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS.     REAL_TIME_CONTACT_ANALYSIS_SEGMENTS is deprecated, but it is still supported and will apply only to VOICE channel contacts. Use REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS for voice contacts moving forward. If you have previously associated a stream with REAL_TIME_CONTACT_ANALYSIS_SEGMENTS, no action is needed to update the stream to REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS.
        public let resourceType: InstanceStorageResourceType
        /// A valid storage type.
        public let storageConfig: InstanceStorageConfig

        @inlinable
        public init(clientToken: String? = AssociateInstanceStorageConfigRequest.idempotencyToken(), instanceId: String, resourceType: InstanceStorageResourceType, storageConfig: InstanceStorageConfig) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.resourceType = resourceType
            self.storageConfig = storageConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.resourceType, forKey: .resourceType)
            try container.encode(self.storageConfig, forKey: .storageConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.storageConfig.validate(name: "\(name).storageConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case resourceType = "ResourceType"
            case storageConfig = "StorageConfig"
        }
    }

    public struct AssociateInstanceStorageConfigResponse: AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?

        @inlinable
        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
        }
    }

    public struct AssociateLambdaFunctionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.
        public let functionArn: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(clientToken: String? = AssociateLambdaFunctionRequest.idempotencyToken(), functionArn: String, instanceId: String) {
            self.clientToken = clientToken
            self.functionArn = functionArn
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.functionArn, forKey: .functionArn)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.functionArn, name: "functionArn", parent: name, max: 140)
            try self.validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case functionArn = "FunctionArn"
        }
    }

    public struct AssociateLexBotRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The Amazon Lex bot to associate with the instance.
        public let lexBot: LexBot

        @inlinable
        public init(clientToken: String? = AssociateLexBotRequest.idempotencyToken(), instanceId: String, lexBot: LexBot) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.lexBot = lexBot
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.lexBot, forKey: .lexBot)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.lexBot.validate(name: "\(name).lexBot")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case lexBot = "LexBot"
        }
    }

    public struct AssociatePhoneNumberContactFlowRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        @inlinable
        public init(contactFlowId: String, instanceId: String, phoneNumberId: String) {
            self.contactFlowId = contactFlowId
            self.instanceId = instanceId
            self.phoneNumberId = phoneNumberId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.contactFlowId, forKey: .contactFlowId)
            try container.encode(self.instanceId, forKey: .instanceId)
            request.encodePath(self.phoneNumberId, key: "PhoneNumberId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case instanceId = "InstanceId"
        }
    }

    public struct AssociateQueueQuickConnectsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String
        /// The quick connects to associate with this queue.
        public let quickConnectIds: [String]

        @inlinable
        public init(instanceId: String, queueId: String, quickConnectIds: [String]) {
            self.instanceId = instanceId
            self.queueId = queueId
            self.quickConnectIds = quickConnectIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.queueId, key: "QueueId")
            try container.encode(self.quickConnectIds, forKey: .quickConnectIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, max: 50)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectIds = "QuickConnectIds"
        }
    }

    public struct AssociateRoutingProfileQueuesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The queues to associate with this routing profile.
        public let queueConfigs: [RoutingProfileQueueConfig]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(instanceId: String, queueConfigs: [RoutingProfileQueueConfig], routingProfileId: String) {
            self.instanceId = instanceId
            self.queueConfigs = queueConfigs
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.queueConfigs, forKey: .queueConfigs)
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.queueConfigs.forEach {
                try $0.validate(name: "\(name).queueConfigs[]")
            }
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, max: 10)
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queueConfigs = "QueueConfigs"
        }
    }

    public struct AssociateSecurityKeyRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A valid security key in PEM format as a String.
        public let key: String

        @inlinable
        public init(clientToken: String? = AssociateSecurityKeyRequest.idempotencyToken(), instanceId: String, key: String) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.key = key
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.key, forKey: .key)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case key = "Key"
        }
    }

    public struct AssociateSecurityKeyResponse: AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?

        @inlinable
        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
        }
    }

    public struct AssociateTrafficDistributionGroupUserRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN of the traffic distribution group.
        public let trafficDistributionGroupId: String
        /// The identifier of the user account. This can be the ID or the ARN of the user.
        public let userId: String

        @inlinable
        public init(instanceId: String, trafficDistributionGroupId: String, userId: String) {
            self.instanceId = instanceId
            self.trafficDistributionGroupId = trafficDistributionGroupId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.instanceId, forKey: .instanceId)
            request.encodePath(self.trafficDistributionGroupId, key: "TrafficDistributionGroupId")
            try container.encode(self.userId, forKey: .userId)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.trafficDistributionGroupId, name: "trafficDistributionGroupId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case userId = "UserId"
        }
    }

    public struct AssociateTrafficDistributionGroupUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateUserProficienciesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN of the instance).
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String
        /// The proficiencies to associate with the user.
        public let userProficiencies: [UserProficiency]

        @inlinable
        public init(instanceId: String, userId: String, userProficiencies: [UserProficiency]) {
            self.instanceId = instanceId
            self.userId = userId
            self.userProficiencies = userProficiencies
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
            try container.encode(self.userProficiencies, forKey: .userProficiencies)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.userProficiencies.forEach {
                try $0.validate(name: "\(name).userProficiencies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userProficiencies = "UserProficiencies"
        }
    }

    public struct AssociatedContactSummary: AWSDecodableShape {
        /// How the contact reached your contact center.
        public let channel: Channel?
        /// The Amazon Resource Name (ARN) of the contact
        public let contactArn: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?
        /// The timestamp when the customer endpoint disconnected from Amazon Connect.
        public let disconnectTimestamp: Date?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public let initialContactId: String?
        /// Indicates how the contact was initiated.
        public let initiationMethod: ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time.
        public let initiationTimestamp: Date?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public let previousContactId: String?
        /// The contactId that is related to this contact.
        public let relatedContactId: String?

        @inlinable
        public init(channel: Channel? = nil, contactArn: String? = nil, contactId: String? = nil, disconnectTimestamp: Date? = nil, initialContactId: String? = nil, initiationMethod: ContactInitiationMethod? = nil, initiationTimestamp: Date? = nil, previousContactId: String? = nil, relatedContactId: String? = nil) {
            self.channel = channel
            self.contactArn = contactArn
            self.contactId = contactId
            self.disconnectTimestamp = disconnectTimestamp
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.previousContactId = previousContactId
            self.relatedContactId = relatedContactId
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case contactArn = "ContactArn"
            case contactId = "ContactId"
            case disconnectTimestamp = "DisconnectTimestamp"
            case initialContactId = "InitialContactId"
            case initiationMethod = "InitiationMethod"
            case initiationTimestamp = "InitiationTimestamp"
            case previousContactId = "PreviousContactId"
            case relatedContactId = "RelatedContactId"
        }
    }

    public struct AttachedFile: AWSDecodableShape {
        /// The resource to which the attached file is (being) uploaded to. Cases are the only current supported resource.  This value must be a valid ARN.
        public let associatedResourceArn: String?
        /// Represents the identity that created the file.
        public let createdBy: CreatedByInfo?
        /// The time of Creation of the file resource as an ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2024-05-03T02:41:28.172Z.
        public let creationTime: String
        /// The unique identifier of the attached file resource (ARN).
        public let fileArn: String
        /// The unique identifier of the attached file resource.
        public let fileId: String
        /// A case-sensitive name of the attached file being uploaded.
        public let fileName: String
        /// The size of the attached file in bytes.
        public let fileSizeInBytes: Int64
        /// The current status of the attached file.
        public let fileStatus: FileStatusType
        /// The use case for the file.
        public let fileUseCaseType: FileUseCaseType?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(associatedResourceArn: String? = nil, createdBy: CreatedByInfo? = nil, creationTime: String, fileArn: String, fileId: String, fileName: String, fileSizeInBytes: Int64, fileStatus: FileStatusType, fileUseCaseType: FileUseCaseType? = nil, tags: [String: String]? = nil) {
            self.associatedResourceArn = associatedResourceArn
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.fileArn = fileArn
            self.fileId = fileId
            self.fileName = fileName
            self.fileSizeInBytes = fileSizeInBytes
            self.fileStatus = fileStatus
            self.fileUseCaseType = fileUseCaseType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResourceArn = "AssociatedResourceArn"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case fileArn = "FileArn"
            case fileId = "FileId"
            case fileName = "FileName"
            case fileSizeInBytes = "FileSizeInBytes"
            case fileStatus = "FileStatus"
            case fileUseCaseType = "FileUseCaseType"
            case tags = "Tags"
        }
    }

    public struct AttachedFileError: AWSDecodableShape {
        ///  Status code describing the failure.
        public let errorCode: String?
        /// Why the attached file couldn't be retrieved.
        public let errorMessage: String?
        /// The unique identifier of the attached file resource.
        public let fileId: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil, fileId: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.fileId = fileId
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
            case fileId = "FileId"
        }
    }

    public struct AttachmentReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the attachment reference.
        public let arn: String?
        /// Identifier of the attachment reference.
        public let name: String?
        /// Status of the attachment reference type.
        public let status: ReferenceStatus?
        /// The location path of the attachment reference.
        public let value: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil, status: ReferenceStatus? = nil, value: String? = nil) {
            self.arn = arn
            self.name = name
            self.status = status
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
            case status = "Status"
            case value = "Value"
        }
    }

    public struct Attendee: AWSDecodableShape {
        /// The Amazon Chime SDK attendee ID.
        public let attendeeId: String?
        /// The join token used by the Amazon Chime SDK attendee.
        public let joinToken: String?

        @inlinable
        public init(attendeeId: String? = nil, joinToken: String? = nil) {
            self.attendeeId = attendeeId
            self.joinToken = joinToken
        }

        private enum CodingKeys: String, CodingKey {
            case attendeeId = "AttendeeId"
            case joinToken = "JoinToken"
        }
    }

    public struct Attribute: AWSDecodableShape {
        /// The type of attribute.
        public let attributeType: InstanceAttributeType?
        /// The value of the attribute.
        public let value: String?

        @inlinable
        public init(attributeType: InstanceAttributeType? = nil, value: String? = nil) {
            self.attributeType = attributeType
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attributeType = "AttributeType"
            case value = "Value"
        }
    }

    public struct AttributeAndCondition: AWSEncodableShape {
        public let hierarchyGroupCondition: HierarchyGroupCondition?
        /// A leaf node condition which can be used to specify a tag condition.
        public let tagConditions: [TagCondition]?

        @inlinable
        public init(hierarchyGroupCondition: HierarchyGroupCondition? = nil, tagConditions: [TagCondition]? = nil) {
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.tagConditions = tagConditions
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupCondition = "HierarchyGroupCondition"
            case tagConditions = "TagConditions"
        }
    }

    public struct AttributeCondition: AWSEncodableShape & AWSDecodableShape {
        /// The operator of the condition.
        public let comparisonOperator: String?
        /// An object to define AgentsCriteria.
        public let matchCriteria: MatchCriteria?
        /// The name of predefined attribute.
        public let name: String?
        /// The proficiency level of the condition.
        public let proficiencyLevel: Float?
        /// An Object to define the minimum and maximum proficiency levels.
        public let range: Range?
        /// The value of predefined attribute.
        public let value: String?

        @inlinable
        public init(comparisonOperator: String? = nil, matchCriteria: MatchCriteria? = nil, name: String? = nil, proficiencyLevel: Float? = nil, range: Range? = nil, value: String? = nil) {
            self.comparisonOperator = comparisonOperator
            self.matchCriteria = matchCriteria
            self.name = name
            self.proficiencyLevel = proficiencyLevel
            self.range = range
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.comparisonOperator, name: "comparisonOperator", parent: name, max: 127)
            try self.validate(self.comparisonOperator, name: "comparisonOperator", parent: name, min: 1)
            try self.matchCriteria?.validate(name: "\(name).matchCriteria")
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.proficiencyLevel, name: "proficiencyLevel", parent: name, max: 5.0)
            try self.validate(self.proficiencyLevel, name: "proficiencyLevel", parent: name, min: 1.0)
            try self.range?.validate(name: "\(name).range")
            try self.validate(self.value, name: "value", parent: name, max: 128)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonOperator = "ComparisonOperator"
            case matchCriteria = "MatchCriteria"
            case name = "Name"
            case proficiencyLevel = "ProficiencyLevel"
            case range = "Range"
            case value = "Value"
        }
    }

    public struct AudioFeatures: AWSDecodableShape {
        /// Makes echo reduction available to clients who connect to the meeting.
        public let echoReduction: MeetingFeatureStatus?

        @inlinable
        public init(echoReduction: MeetingFeatureStatus? = nil) {
            self.echoReduction = echoReduction
        }

        private enum CodingKeys: String, CodingKey {
            case echoReduction = "EchoReduction"
        }
    }

    public struct AudioQualityMetricsInfo: AWSDecodableShape {
        /// List of potential issues causing degradation of quality on a media connection. If the service did not detect any potential quality issues the list is empty. Valid values: HighPacketLoss | HighRoundTripTime | HighJitterBuffer
        public let potentialQualityIssues: [String]?
        /// Number measuring the estimated quality of the media connection.
        public let qualityScore: Float?

        @inlinable
        public init(potentialQualityIssues: [String]? = nil, qualityScore: Float? = nil) {
            self.potentialQualityIssues = potentialQualityIssues
            self.qualityScore = qualityScore
        }

        private enum CodingKeys: String, CodingKey {
            case potentialQualityIssues = "PotentialQualityIssues"
            case qualityScore = "QualityScore"
        }
    }

    public struct AuthenticationProfile: AWSDecodableShape {
        /// A list of IP address range strings that are allowed to access the Amazon Connect instance. For more information about how to configure IP addresses, see Configure IP address based access control in the Amazon Connect Administrator Guide.
        public let allowedIps: [String]?
        /// The Amazon Resource Name (ARN) for the authentication profile.
        public let arn: String?
        /// A list of IP address range strings that are blocked from accessing the Amazon Connect instance. For more information about how to configure IP addresses, see Configure IP address based access control in the Amazon Connect Administrator Guide.
        public let blockedIps: [String]?
        /// The timestamp when the authentication profile was created.
        public let createdTime: Date?
        /// The description for the authentication profile.
        public let description: String?
        /// A unique identifier for the authentication profile.
        public let id: String?
        /// Shows whether the authentication profile is the default authentication profile for the Amazon Connect instance. The default authentication profile applies to all agents in an Amazon Connect instance, unless overridden by another authentication profile.
        public let isDefault: Bool?
        /// The Amazon Web Services Region where the authentication profile was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when the authentication profile was last modified.
        public let lastModifiedTime: Date?
        /// The long lived session duration for users logged in to Amazon Connect, in minutes. After this time period, users must log in again. For more information, see Configure the session duration in the Amazon Connect Administrator Guide.
        public let maxSessionDuration: Int?
        /// The name for the authentication profile.
        public let name: String?
        /// The short lived session duration configuration for users logged in to Amazon Connect, in minutes. This value determines the maximum possible time before an agent is authenticated. For more information, see Configure the session duration in the Amazon Connect Administrator Guide.
        public let periodicSessionDuration: Int?

        @inlinable
        public init(allowedIps: [String]? = nil, arn: String? = nil, blockedIps: [String]? = nil, createdTime: Date? = nil, description: String? = nil, id: String? = nil, isDefault: Bool? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, maxSessionDuration: Int? = nil, name: String? = nil, periodicSessionDuration: Int? = nil) {
            self.allowedIps = allowedIps
            self.arn = arn
            self.blockedIps = blockedIps
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.isDefault = isDefault
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.maxSessionDuration = maxSessionDuration
            self.name = name
            self.periodicSessionDuration = periodicSessionDuration
        }

        private enum CodingKeys: String, CodingKey {
            case allowedIps = "AllowedIps"
            case arn = "Arn"
            case blockedIps = "BlockedIps"
            case createdTime = "CreatedTime"
            case description = "Description"
            case id = "Id"
            case isDefault = "IsDefault"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case maxSessionDuration = "MaxSessionDuration"
            case name = "Name"
            case periodicSessionDuration = "PeriodicSessionDuration"
        }
    }

    public struct AuthenticationProfileSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the authentication profile summary.
        public let arn: String?
        /// The unique identifier of the authentication profile.
        public let id: String?
        /// Shows whether the authentication profile is the default authentication profile for the Amazon Connect instance. The default authentication profile applies to all agents in an Amazon Connect instance, unless overridden by another authentication profile.
        public let isDefault: Bool?
        /// The Amazon Web Services Region when the authentication profile summary was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when the authentication profile summary was last modified.
        public let lastModifiedTime: Date?
        /// The name of the authentication profile summary.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, isDefault: Bool? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case isDefault = "IsDefault"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct AvailableNumberSummary: AWSDecodableShape {
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?

        @inlinable
        public init(phoneNumber: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberType: PhoneNumberType? = nil) {
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumber = "PhoneNumber"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberType = "PhoneNumberType"
        }
    }

    public struct BatchAssociateAnalyticsDataSetRequest: AWSEncodableShape {
        /// An array of dataset identifiers to associate.
        public let dataSetIds: [String]
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the target account.  Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
        public let targetAccountId: String?

        @inlinable
        public init(dataSetIds: [String], instanceId: String, targetAccountId: String? = nil) {
            self.dataSetIds = dataSetIds
            self.instanceId = instanceId
            self.targetAccountId = targetAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataSetIds, forKey: .dataSetIds)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.targetAccountId, forKey: .targetAccountId)
        }

        public func validate(name: String) throws {
            try self.dataSetIds.forEach {
                try validate($0, name: "dataSetIds[]", parent: name, max: 255)
                try validate($0, name: "dataSetIds[]", parent: name, min: 1)
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIds = "DataSetIds"
            case targetAccountId = "TargetAccountId"
        }
    }

    public struct BatchAssociateAnalyticsDataSetResponse: AWSDecodableShape {
        /// Information about associations that are successfully created: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn.
        public let created: [AnalyticsDataAssociationResult]?
        /// A list of errors for datasets that aren't successfully associated with the target account.
        public let errors: [ErrorResult]?

        @inlinable
        public init(created: [AnalyticsDataAssociationResult]? = nil, errors: [ErrorResult]? = nil) {
            self.created = created
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case created = "Created"
            case errors = "Errors"
        }
    }

    public struct BatchDisassociateAnalyticsDataSetRequest: AWSEncodableShape {
        /// An array of associated dataset identifiers to remove.
        public let dataSetIds: [String]
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the target account.  Use to disassociate a dataset from a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
        public let targetAccountId: String?

        @inlinable
        public init(dataSetIds: [String], instanceId: String, targetAccountId: String? = nil) {
            self.dataSetIds = dataSetIds
            self.instanceId = instanceId
            self.targetAccountId = targetAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataSetIds, forKey: .dataSetIds)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.targetAccountId, forKey: .targetAccountId)
        }

        public func validate(name: String) throws {
            try self.dataSetIds.forEach {
                try validate($0, name: "dataSetIds[]", parent: name, max: 255)
                try validate($0, name: "dataSetIds[]", parent: name, min: 1)
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetIds = "DataSetIds"
            case targetAccountId = "TargetAccountId"
        }
    }

    public struct BatchDisassociateAnalyticsDataSetResponse: AWSDecodableShape {
        /// An array of successfully disassociated dataset identifiers.
        public let deleted: [String]?
        /// A list of errors for any datasets not successfully removed.
        public let errors: [ErrorResult]?

        @inlinable
        public init(deleted: [String]? = nil, errors: [ErrorResult]? = nil) {
            self.deleted = deleted
            self.errors = errors
        }

        private enum CodingKeys: String, CodingKey {
            case deleted = "Deleted"
            case errors = "Errors"
        }
    }

    public struct BatchGetAttachedFileMetadataRequest: AWSEncodableShape {
        /// The resource to which the attached file is (being) uploaded to. The supported resources are Cases and Email.  This value must be a valid ARN.
        public let associatedResourceArn: String
        /// The unique identifiers of the attached file resource.
        public let fileIds: [String]
        /// The unique identifier of the Connect instance.
        public let instanceId: String

        @inlinable
        public init(associatedResourceArn: String, fileIds: [String], instanceId: String) {
            self.associatedResourceArn = associatedResourceArn
            self.fileIds = fileIds
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.associatedResourceArn, key: "associatedResourceArn")
            try container.encode(self.fileIds, forKey: .fileIds)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.fileIds.forEach {
                try validate($0, name: "fileIds[]", parent: name, max: 256)
                try validate($0, name: "fileIds[]", parent: name, min: 1)
            }
            try self.validate(self.fileIds, name: "fileIds", parent: name, max: 100)
            try self.validate(self.fileIds, name: "fileIds", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileIds = "FileIds"
        }
    }

    public struct BatchGetAttachedFileMetadataResponse: AWSDecodableShape {
        /// List of errors of attached files that could not be retrieved.
        public let errors: [AttachedFileError]?
        /// List of attached files that were successfully retrieved.
        public let files: [AttachedFile]?

        @inlinable
        public init(errors: [AttachedFileError]? = nil, files: [AttachedFile]? = nil) {
            self.errors = errors
            self.files = files
        }

        private enum CodingKeys: String, CodingKey {
            case errors = "Errors"
            case files = "Files"
        }
    }

    public struct BatchGetFlowAssociationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A list of resource identifiers to retrieve flow associations.   Amazon Web Services End User Messaging SMS phone number ARN when using SMS_PHONE_NUMBER    Amazon Web Services End User Messaging Social phone number ARN when using WHATSAPP_MESSAGING_PHONE_NUMBER
        public let resourceIds: [String]
        /// The type of resource association.
        public let resourceType: ListFlowAssociationResourceType?

        @inlinable
        public init(instanceId: String, resourceIds: [String], resourceType: ListFlowAssociationResourceType? = nil) {
            self.instanceId = instanceId
            self.resourceIds = resourceIds
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.resourceIds, forKey: .resourceIds)
            try container.encodeIfPresent(self.resourceType, forKey: .resourceType)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, max: 100)
            try self.validate(self.resourceIds, name: "resourceIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceIds = "ResourceIds"
            case resourceType = "ResourceType"
        }
    }

    public struct BatchGetFlowAssociationResponse: AWSDecodableShape {
        /// Information about flow associations.
        public let flowAssociationSummaryList: [FlowAssociationSummary]?

        @inlinable
        public init(flowAssociationSummaryList: [FlowAssociationSummary]? = nil) {
            self.flowAssociationSummaryList = flowAssociationSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case flowAssociationSummaryList = "FlowAssociationSummaryList"
        }
    }

    public struct BatchPutContactRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// List of individual contact requests.
        public let contactDataRequestList: [ContactDataRequest]
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(clientToken: String? = BatchPutContactRequest.idempotencyToken(), contactDataRequestList: [ContactDataRequest], instanceId: String) {
            self.clientToken = clientToken
            self.contactDataRequestList = contactDataRequestList
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.contactDataRequestList, forKey: .contactDataRequestList)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.contactDataRequestList.forEach {
                try $0.validate(name: "\(name).contactDataRequestList[]")
            }
            try self.validate(self.contactDataRequestList, name: "contactDataRequestList", parent: name, max: 25)
            try self.validate(self.contactDataRequestList, name: "contactDataRequestList", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case contactDataRequestList = "ContactDataRequestList"
        }
    }

    public struct BatchPutContactResponse: AWSDecodableShape {
        /// List of requests for which contact creation failed.
        public let failedRequestList: [FailedRequest]?
        /// List of requests for which contact was successfully created.
        public let successfulRequestList: [SuccessfulRequest]?

        @inlinable
        public init(failedRequestList: [FailedRequest]? = nil, successfulRequestList: [SuccessfulRequest]? = nil) {
            self.failedRequestList = failedRequestList
            self.successfulRequestList = successfulRequestList
        }

        private enum CodingKeys: String, CodingKey {
            case failedRequestList = "FailedRequestList"
            case successfulRequestList = "SuccessfulRequestList"
        }
    }

    public struct Campaign: AWSEncodableShape & AWSDecodableShape {
        /// A unique identifier for a campaign.
        public let campaignId: String?

        @inlinable
        public init(campaignId: String? = nil) {
            self.campaignId = campaignId
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignId, name: "campaignId", parent: name, max: 100)
            try self.validate(self.campaignId, name: "campaignId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "CampaignId"
        }
    }

    public struct ChatEvent: AWSEncodableShape {
        /// Content of the message or event. This is required when Type is MESSAGE and for certain ContentTypes when Type is EVENT.   For allowed message content, see the Content parameter in the SendMessage topic in the Amazon Connect Participant Service API Reference.   For allowed event content, see the Content parameter in the SendEvent topic in the Amazon Connect Participant Service API Reference.
        public let content: String?
        /// Type of content. This is required when Type is MESSAGE or EVENT.    For allowed message content types, see the ContentType parameter in the SendMessage topic in the Amazon Connect Participant Service API Reference.   For allowed event content types, see the ContentType parameter in the SendEvent topic in the Amazon Connect Participant Service API Reference.
        public let contentType: String?
        /// Type of chat integration event.
        public let type: ChatEventType

        @inlinable
        public init(content: String? = nil, contentType: String? = nil, type: ChatEventType) {
            self.content = content
            self.contentType = contentType
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 16384)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 100)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
            case type = "Type"
        }
    }

    public struct ChatMessage: AWSEncodableShape {
        /// The content of the chat message.    For text/plain and text/markdown, the Length Constraints are Minimum of 1, Maximum of 1024.    For application/json, the Length Constraints are Minimum of 1, Maximum of 12000.    For application/vnd.amazonaws.connect.message.interactive.response, the Length Constraints are Minimum of 1, Maximum of 12288.
        public let content: String
        /// The type of the content. Supported types are text/plain, text/markdown, application/json, and application/vnd.amazonaws.connect.message.interactive.response.
        public let contentType: String

        @inlinable
        public init(content: String, contentType: String) {
            self.content = content
            self.contentType = contentType
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 16384)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 100)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
        }
    }

    public struct ChatParticipantRoleConfig: AWSEncodableShape {
        /// A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.
        public let participantTimerConfigList: [ParticipantTimerConfiguration]

        @inlinable
        public init(participantTimerConfigList: [ParticipantTimerConfiguration]) {
            self.participantTimerConfigList = participantTimerConfigList
        }

        public func validate(name: String) throws {
            try self.participantTimerConfigList.forEach {
                try $0.validate(name: "\(name).participantTimerConfigList[]")
            }
            try self.validate(self.participantTimerConfigList, name: "participantTimerConfigList", parent: name, max: 6)
            try self.validate(self.participantTimerConfigList, name: "participantTimerConfigList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case participantTimerConfigList = "ParticipantTimerConfigList"
        }
    }

    public struct ChatStreamingConfiguration: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.
        public let streamingEndpointArn: String

        @inlinable
        public init(streamingEndpointArn: String) {
            self.streamingEndpointArn = streamingEndpointArn
        }

        public func validate(name: String) throws {
            try self.validate(self.streamingEndpointArn, name: "streamingEndpointArn", parent: name, max: 350)
            try self.validate(self.streamingEndpointArn, name: "streamingEndpointArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case streamingEndpointArn = "StreamingEndpointArn"
        }
    }

    public struct ClaimPhoneNumberRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. Pattern: ^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can find the instance ID in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
        public let instanceId: String?
        /// The phone number you want to claim. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String
        /// The description of the phone number.
        public let phoneNumberDescription: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
        public let targetArn: String?

        @inlinable
        public init(clientToken: String? = ClaimPhoneNumberRequest.idempotencyToken(), instanceId: String? = nil, phoneNumber: String, phoneNumberDescription: String? = nil, tags: [String: String]? = nil, targetArn: String? = nil) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.phoneNumber = phoneNumber
            self.phoneNumberDescription = phoneNumberDescription
            self.tags = tags
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, max: 500)
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, pattern: "^[\\W\\S_]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case instanceId = "InstanceId"
            case phoneNumber = "PhoneNumber"
            case phoneNumberDescription = "PhoneNumberDescription"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct ClaimPhoneNumberResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?

        @inlinable
        public init(phoneNumberArn: String? = nil, phoneNumberId: String? = nil) {
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct ClaimedPhoneNumberSummary: AWSDecodableShape {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String?
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The description of the phone number.
        public let phoneNumberDescription: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?
        /// The status of the phone number.    CLAIMED means the previous ClaimPhoneNumber or UpdatePhoneNumber operation succeeded.    IN_PROGRESS means a ClaimPhoneNumber, UpdatePhoneNumber, or UpdatePhoneNumberMetadata operation is still in progress and has not yet completed. You can call DescribePhoneNumber at a later time to verify if the previous operation has completed.    FAILED indicates that the previous ClaimPhoneNumber or UpdatePhoneNumber operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the TargetArn value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a FAILED status from a ClaimPhoneNumber API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.    You will not be billed for the phone number during the 1-day period if number claiming fails.
        public let phoneNumberStatus: PhoneNumberStatus?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?
        /// The claimed phone number ARN that was previously imported from the external service, such as Amazon Web Services End User Messaging. If it is from Amazon Web Services End User Messaging, it looks like the ARN of the phone number that was imported from Amazon Web Services End User Messaging.
        public let sourcePhoneNumberArn: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through.
        public let targetArn: String?

        @inlinable
        public init(instanceId: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberDescription: String? = nil, phoneNumberId: String? = nil, phoneNumberStatus: PhoneNumberStatus? = nil, phoneNumberType: PhoneNumberType? = nil, sourcePhoneNumberArn: String? = nil, tags: [String: String]? = nil, targetArn: String? = nil) {
            self.instanceId = instanceId
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
            self.phoneNumberStatus = phoneNumberStatus
            self.phoneNumberType = phoneNumberType
            self.sourcePhoneNumberArn = sourcePhoneNumberArn
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberDescription = "PhoneNumberDescription"
            case phoneNumberId = "PhoneNumberId"
            case phoneNumberStatus = "PhoneNumberStatus"
            case phoneNumberType = "PhoneNumberType"
            case sourcePhoneNumberArn = "SourcePhoneNumberArn"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct CommonAttributeAndCondition: AWSEncodableShape {
        /// A leaf node condition which can be used to specify a tag condition.
        public let tagConditions: [TagCondition]?

        @inlinable
        public init(tagConditions: [TagCondition]? = nil) {
            self.tagConditions = tagConditions
        }

        private enum CodingKeys: String, CodingKey {
            case tagConditions = "TagConditions"
        }
    }

    public struct CompleteAttachedFileUploadRequest: AWSEncodableShape {
        /// The resource to which the attached file is (being) uploaded to. The supported resources are Cases and Email.  This value must be a valid ARN.
        public let associatedResourceArn: String
        /// The unique identifier of the attached file resource.
        public let fileId: String
        /// The unique identifier of the Amazon Connect instance.
        public let instanceId: String

        @inlinable
        public init(associatedResourceArn: String, fileId: String, instanceId: String) {
            self.associatedResourceArn = associatedResourceArn
            self.fileId = fileId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.associatedResourceArn, key: "associatedResourceArn")
            request.encodePath(self.fileId, key: "FileId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileId, name: "fileId", parent: name, max: 256)
            try self.validate(self.fileId, name: "fileId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CompleteAttachedFileUploadResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Condition: AWSEncodableShape {
        /// A leaf node condition which can be used to specify a numeric condition.
        public let numberCondition: NumberCondition?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name and value.
        public let stringCondition: StringCondition?

        @inlinable
        public init(numberCondition: NumberCondition? = nil, stringCondition: StringCondition? = nil) {
            self.numberCondition = numberCondition
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case numberCondition = "NumberCondition"
            case stringCondition = "StringCondition"
        }
    }

    public struct ConnectionData: AWSDecodableShape {
        /// The attendee information, including attendee ID and join token.
        public let attendee: Attendee?
        /// A meeting created using the Amazon Chime SDK.
        public let meeting: Meeting?

        @inlinable
        public init(attendee: Attendee? = nil, meeting: Meeting? = nil) {
            self.attendee = attendee
            self.meeting = meeting
        }

        private enum CodingKeys: String, CodingKey {
            case attendee = "Attendee"
            case meeting = "Meeting"
        }
    }

    public struct Contact: AWSDecodableShape {
        /// List of additional email addresses for an email contact.
        public let additionalEmailRecipients: AdditionalEmailRecipients?
        /// Information about the agent who accepted the contact.
        public let agentInfo: AgentInfo?
        /// Indicates how an outbound campaign call is actually disposed if the contact is connected to Amazon Connect.
        public let answeringMachineDetectionStatus: AnsweringMachineDetectionStatus?
        /// The Amazon Resource Name (ARN) for the contact.
        public let arn: String?
        public let campaign: Campaign?
        /// How the contact reached your contact center.
        public let channel: Channel?
        /// The timestamp when customer endpoint connected to Amazon Connect.
        public let connectedToSystemTimestamp: Date?
        /// This is the root contactId which is used as a unique identifier for all subsequent contacts in a contact tree.
        public let contactAssociationId: String?
        /// Information about the Customer on the contact.
        public let customer: Customer?
        /// The customer or external third party participant endpoint.
        public let customerEndpoint: EndpointInfo?
        /// The customer's identification number. For example, the CustomerId may be a customer number from your CRM. You can create a Lambda function to pull the unique customer ID of the caller from your CRM system. If you enable Amazon Connect Voice ID capability, this attribute is populated with the CustomerSpeakerId of the caller.
        public let customerId: String?
        /// Information about customers voice activity.
        public let customerVoiceActivity: CustomerVoiceActivity?
        /// The description of the contact.
        public let description: String?
        /// Information about the call disconnect experience.
        public let disconnectDetails: DisconnectDetails?
        /// The date and time that the customer endpoint disconnected from the current contact, in UTC time. In transfer scenarios, the DisconnectTimestamp of the previous contact indicates the date and time when that contact ended.
        public let disconnectTimestamp: Date?
        /// The identifier for the contact.
        public let id: String?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public let initialContactId: String?
        /// Indicates how the contact was initiated.
        public let initiationMethod: ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time. For INBOUND, this is when the contact arrived. For OUTBOUND, this is when the agent began dialing. For CALLBACK, this is when the callback contact was created. For TRANSFER and QUEUE_TRANSFER, this is when the transfer was initiated. For API, this is when the request arrived. For EXTERNAL_OUTBOUND, this is when the agent started dialing the external participant. For MONITOR, this is when the supervisor started listening to a contact.
        public let initiationTimestamp: Date?
        /// The timestamp when the contact was last paused.
        public let lastPausedTimestamp: Date?
        /// The timestamp when the contact was last resumed.
        public let lastResumedTimestamp: Date?
        /// The timestamp when contact was last updated.
        public let lastUpdateTimestamp: Date?
        /// The name of the contact.
        public let name: String?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public let previousContactId: String?
        /// Information about the quality of the participant's media connection.
        public let qualityMetrics: QualityMetrics?
        /// If this contact was queued, this contains information about the queue.
        public let queueInfo: QueueInfo?
        /// An integer that represents the queue priority to be applied to the contact (lower priorities are routed preferentially). Cannot be specified if the QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be larger than zero, and a valid integer value. Default Value is 5.
        public let queuePriority: Int64?
        /// An integer that represents the queue time adjust to be applied to the contact, in seconds (longer / larger queue time are routed preferentially). Cannot be specified if the QueuePriority is specified. Must be statically defined and a valid integer value.
        public let queueTimeAdjustmentSeconds: Int?
        /// The contactId that is related to this contact.
        public let relatedContactId: String?
        /// Latest routing criteria on the contact.
        public let routingCriteria: RoutingCriteria?
        /// The timestamp, in Unix epoch time format, at which to start running the inbound flow.
        public let scheduledTimestamp: Date?
        /// A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes and can be accessed in flows. Attribute keys can include only alphanumeric, -, and _ characters. This field can be used to show channel subtype. For example, connect:Guide or connect:SMS.
        public let segmentAttributes: [String: SegmentAttributeValue]?
        /// The system endpoint. For INBOUND, this is the phone number or email address that the customer dialed. For OUTBOUND and EXTERNAL_OUTBOUND, this is the outbound caller ID number assigned to the outbound queue that is used to dial the customer. For callback, this shows up as Softphone for calls handled by agents with softphone.
        public let systemEndpoint: EndpointInfo?
        /// Tags associated with the contact. This contains both Amazon Web Services generated and user-defined tags.
        public let tags: [String: String]?
        /// Total pause count for a contact.
        public let totalPauseCount: Int?
        /// Total pause duration for a contact in seconds.
        public let totalPauseDurationInSeconds: Int?
        /// Information about Amazon Connect Wisdom.
        public let wisdomInfo: WisdomInfo?

        @inlinable
        public init(additionalEmailRecipients: AdditionalEmailRecipients? = nil, agentInfo: AgentInfo? = nil, answeringMachineDetectionStatus: AnsweringMachineDetectionStatus? = nil, arn: String? = nil, campaign: Campaign? = nil, channel: Channel? = nil, connectedToSystemTimestamp: Date? = nil, contactAssociationId: String? = nil, customer: Customer? = nil, customerEndpoint: EndpointInfo? = nil, customerId: String? = nil, customerVoiceActivity: CustomerVoiceActivity? = nil, description: String? = nil, disconnectDetails: DisconnectDetails? = nil, disconnectTimestamp: Date? = nil, id: String? = nil, initialContactId: String? = nil, initiationMethod: ContactInitiationMethod? = nil, initiationTimestamp: Date? = nil, lastPausedTimestamp: Date? = nil, lastResumedTimestamp: Date? = nil, lastUpdateTimestamp: Date? = nil, name: String? = nil, previousContactId: String? = nil, qualityMetrics: QualityMetrics? = nil, queueInfo: QueueInfo? = nil, queuePriority: Int64? = nil, queueTimeAdjustmentSeconds: Int? = nil, relatedContactId: String? = nil, routingCriteria: RoutingCriteria? = nil, scheduledTimestamp: Date? = nil, segmentAttributes: [String: SegmentAttributeValue]? = nil, systemEndpoint: EndpointInfo? = nil, tags: [String: String]? = nil, totalPauseCount: Int? = nil, totalPauseDurationInSeconds: Int? = nil, wisdomInfo: WisdomInfo? = nil) {
            self.additionalEmailRecipients = additionalEmailRecipients
            self.agentInfo = agentInfo
            self.answeringMachineDetectionStatus = answeringMachineDetectionStatus
            self.arn = arn
            self.campaign = campaign
            self.channel = channel
            self.connectedToSystemTimestamp = connectedToSystemTimestamp
            self.contactAssociationId = contactAssociationId
            self.customer = customer
            self.customerEndpoint = customerEndpoint
            self.customerId = customerId
            self.customerVoiceActivity = customerVoiceActivity
            self.description = description
            self.disconnectDetails = disconnectDetails
            self.disconnectTimestamp = disconnectTimestamp
            self.id = id
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.lastPausedTimestamp = lastPausedTimestamp
            self.lastResumedTimestamp = lastResumedTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.name = name
            self.previousContactId = previousContactId
            self.qualityMetrics = qualityMetrics
            self.queueInfo = queueInfo
            self.queuePriority = queuePriority
            self.queueTimeAdjustmentSeconds = queueTimeAdjustmentSeconds
            self.relatedContactId = relatedContactId
            self.routingCriteria = routingCriteria
            self.scheduledTimestamp = scheduledTimestamp
            self.segmentAttributes = segmentAttributes
            self.systemEndpoint = systemEndpoint
            self.tags = tags
            self.totalPauseCount = totalPauseCount
            self.totalPauseDurationInSeconds = totalPauseDurationInSeconds
            self.wisdomInfo = wisdomInfo
        }

        private enum CodingKeys: String, CodingKey {
            case additionalEmailRecipients = "AdditionalEmailRecipients"
            case agentInfo = "AgentInfo"
            case answeringMachineDetectionStatus = "AnsweringMachineDetectionStatus"
            case arn = "Arn"
            case campaign = "Campaign"
            case channel = "Channel"
            case connectedToSystemTimestamp = "ConnectedToSystemTimestamp"
            case contactAssociationId = "ContactAssociationId"
            case customer = "Customer"
            case customerEndpoint = "CustomerEndpoint"
            case customerId = "CustomerId"
            case customerVoiceActivity = "CustomerVoiceActivity"
            case description = "Description"
            case disconnectDetails = "DisconnectDetails"
            case disconnectTimestamp = "DisconnectTimestamp"
            case id = "Id"
            case initialContactId = "InitialContactId"
            case initiationMethod = "InitiationMethod"
            case initiationTimestamp = "InitiationTimestamp"
            case lastPausedTimestamp = "LastPausedTimestamp"
            case lastResumedTimestamp = "LastResumedTimestamp"
            case lastUpdateTimestamp = "LastUpdateTimestamp"
            case name = "Name"
            case previousContactId = "PreviousContactId"
            case qualityMetrics = "QualityMetrics"
            case queueInfo = "QueueInfo"
            case queuePriority = "QueuePriority"
            case queueTimeAdjustmentSeconds = "QueueTimeAdjustmentSeconds"
            case relatedContactId = "RelatedContactId"
            case routingCriteria = "RoutingCriteria"
            case scheduledTimestamp = "ScheduledTimestamp"
            case segmentAttributes = "SegmentAttributes"
            case systemEndpoint = "SystemEndpoint"
            case tags = "Tags"
            case totalPauseCount = "TotalPauseCount"
            case totalPauseDurationInSeconds = "TotalPauseDurationInSeconds"
            case wisdomInfo = "WisdomInfo"
        }
    }

    public struct ContactAnalysis: AWSEncodableShape {
        /// Search criteria based on transcript analyzed by Amazon Connect Contact Lens.
        public let transcript: Transcript?

        @inlinable
        public init(transcript: Transcript? = nil) {
            self.transcript = transcript
        }

        public func validate(name: String) throws {
            try self.transcript?.validate(name: "\(name).transcript")
        }

        private enum CodingKeys: String, CodingKey {
            case transcript = "Transcript"
        }
    }

    public struct ContactConfiguration: AWSEncodableShape {
        /// The identifier of the contact within the Amazon Connect instance.
        public let contactId: String
        /// Whether to include raw connect message in the push notification payload. Default is False.
        public let includeRawMessage: Bool?
        /// The role of the participant in the chat conversation.  Only CUSTOMER is currently supported. Any other values other than CUSTOMER will result in an exception (4xx error).
        public let participantRole: ParticipantRole?

        @inlinable
        public init(contactId: String, includeRawMessage: Bool? = nil, participantRole: ParticipantRole? = nil) {
            self.contactId = contactId
            self.includeRawMessage = includeRawMessage
            self.participantRole = participantRole
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case includeRawMessage = "IncludeRawMessage"
            case participantRole = "ParticipantRole"
        }
    }

    public struct ContactDataRequest: AWSEncodableShape {
        /// List of attributes to be stored in a contact.
        public let attributes: [String: String]?
        /// Structure to store information associated with a campaign.
        public let campaign: Campaign?
        /// Endpoint of the customer for which contact will be initiated.
        public let customerEndpoint: Endpoint?
        /// The identifier of the queue associated with the Amazon Connect instance in which contacts that are created will be queued.
        public let queueId: String?
        /// Identifier to uniquely identify individual requests in the batch.
        public let requestIdentifier: String?
        /// Endpoint associated with the Amazon Connect instance from which outbound contact will be initiated for the campaign.
        public let systemEndpoint: Endpoint?

        @inlinable
        public init(attributes: [String: String]? = nil, campaign: Campaign? = nil, customerEndpoint: Endpoint? = nil, queueId: String? = nil, requestIdentifier: String? = nil, systemEndpoint: Endpoint? = nil) {
            self.attributes = attributes
            self.campaign = campaign
            self.customerEndpoint = customerEndpoint
            self.queueId = queueId
            self.requestIdentifier = requestIdentifier
            self.systemEndpoint = systemEndpoint
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.campaign?.validate(name: "\(name).campaign")
            try self.customerEndpoint?.validate(name: "\(name).customerEndpoint")
            try self.validate(self.requestIdentifier, name: "requestIdentifier", parent: name, max: 80)
            try self.systemEndpoint?.validate(name: "\(name).systemEndpoint")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case campaign = "Campaign"
            case customerEndpoint = "CustomerEndpoint"
            case queueId = "QueueId"
            case requestIdentifier = "RequestIdentifier"
            case systemEndpoint = "SystemEndpoint"
        }
    }

    public struct ContactFilter: AWSEncodableShape {
        /// A list of up to 9 contact states.
        public let contactStates: [ContactState]?

        @inlinable
        public init(contactStates: [ContactState]? = nil) {
            self.contactStates = contactStates
        }

        public func validate(name: String) throws {
            try self.validate(self.contactStates, name: "contactStates", parent: name, max: 9)
        }

        private enum CodingKeys: String, CodingKey {
            case contactStates = "ContactStates"
        }
    }

    public struct ContactFlow: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String?
        /// The JSON string that represents the content of the flow. For an example, see Example flow in Amazon Connect Flow language.  Length Constraints: Minimum length of 1. Maximum length of 256000.
        public let content: String?
        /// The description of the flow.
        public let description: String?
        /// Indicates the checksum value of the flow content.
        public let flowContentSha256: String?
        /// The identifier of the flow.
        public let id: String?
        /// The region in which the flow was last modified
        public let lastModifiedRegion: String?
        /// The time at which the flow was last modified.
        public let lastModifiedTime: Date?
        /// The name of the flow.
        public let name: String?
        /// The type of flow.
        public let state: ContactFlowState?
        /// The status of the flow.
        public let status: ContactFlowStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of the flow. For descriptions of the available types, see Choose a flow type in the Amazon Connect Administrator Guide.
        public let type: ContactFlowType?
        /// The identifier of the flow version.
        public let version: Int64?
        /// The description of the flow version.
        public let versionDescription: String?

        @inlinable
        public init(arn: String? = nil, content: String? = nil, description: String? = nil, flowContentSha256: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, state: ContactFlowState? = nil, status: ContactFlowStatus? = nil, tags: [String: String]? = nil, type: ContactFlowType? = nil, version: Int64? = nil, versionDescription: String? = nil) {
            self.arn = arn
            self.content = content
            self.description = description
            self.flowContentSha256 = flowContentSha256
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.status = status
            self.tags = tags
            self.type = type
            self.version = version
            self.versionDescription = versionDescription
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case description = "Description"
            case flowContentSha256 = "FlowContentSha256"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case state = "State"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
            case version = "Version"
            case versionDescription = "VersionDescription"
        }
    }

    public struct ContactFlowModule: AWSDecodableShape {
        /// The Amazon Resource Name (ARN).
        public let arn: String?
        /// The JSON string that represents the content of the flow. For an example, see Example flow in Amazon Connect Flow language.
        public let content: String?
        /// The description of the flow module.
        public let description: String?
        /// The identifier of the flow module.
        public let id: String?
        /// The name of the flow module.
        public let name: String?
        /// The type of flow module.
        public let state: ContactFlowModuleState?
        /// The status of the flow module.
        public let status: ContactFlowModuleStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, content: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, state: ContactFlowModuleState? = nil, status: ContactFlowModuleStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case state = "State"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct ContactFlowModuleSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [ContactFlowModuleSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [ContactFlowModuleSearchCriteria]?
        /// The state of the flow.
        public let stateCondition: ContactFlowModuleState?
        /// The status of the flow.
        public let statusCondition: ContactFlowModuleStatus?
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [ContactFlowModuleSearchCriteria]? = nil, orConditions: [ContactFlowModuleSearchCriteria]? = nil, stateCondition: ContactFlowModuleState? = nil, statusCondition: ContactFlowModuleStatus? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stateCondition = stateCondition
            self.statusCondition = statusCondition
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stateCondition = "StateCondition"
            case statusCondition = "StatusCondition"
            case stringCondition = "StringCondition"
        }
    }

    public struct ContactFlowModuleSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct ContactFlowModuleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow module.
        public let arn: String?
        /// The identifier of the flow module.
        public let id: String?
        /// The name of the flow module.
        public let name: String?
        /// The type of flow module.
        public let state: ContactFlowModuleState?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil, state: ContactFlowModuleState? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case state = "State"
        }
    }

    public struct ContactFlowSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [ContactFlowSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [ContactFlowSearchCriteria]?
        /// The state of the flow.
        public let stateCondition: ContactFlowState?
        /// The status of the flow.
        public let statusCondition: ContactFlowStatus?
        public let stringCondition: StringCondition?
        /// The type of flow.
        public let typeCondition: ContactFlowType?

        @inlinable
        public init(andConditions: [ContactFlowSearchCriteria]? = nil, orConditions: [ContactFlowSearchCriteria]? = nil, stateCondition: ContactFlowState? = nil, statusCondition: ContactFlowStatus? = nil, stringCondition: StringCondition? = nil, typeCondition: ContactFlowType? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stateCondition = stateCondition
            self.statusCondition = statusCondition
            self.stringCondition = stringCondition
            self.typeCondition = typeCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stateCondition = "StateCondition"
            case statusCondition = "StatusCondition"
            case stringCondition = "StringCondition"
            case typeCondition = "TypeCondition"
        }
    }

    public struct ContactFlowSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct ContactFlowSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String?
        /// The type of flow.
        public let contactFlowState: ContactFlowState?
        /// The status of the flow.
        public let contactFlowStatus: ContactFlowStatus?
        /// The type of flow.
        public let contactFlowType: ContactFlowType?
        /// The identifier of the flow.
        public let id: String?
        /// The name of the flow.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, contactFlowState: ContactFlowState? = nil, contactFlowStatus: ContactFlowStatus? = nil, contactFlowType: ContactFlowType? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.contactFlowState = contactFlowState
            self.contactFlowStatus = contactFlowStatus
            self.contactFlowType = contactFlowType
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case contactFlowState = "ContactFlowState"
            case contactFlowStatus = "ContactFlowStatus"
            case contactFlowType = "ContactFlowType"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ContactFlowVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the view version.
        public let arn: String?
        /// The identifier of the flow version.
        public let version: Int64?
        /// The description of the flow version.
        public let versionDescription: String?

        @inlinable
        public init(arn: String? = nil, version: Int64? = nil, versionDescription: String? = nil) {
            self.arn = arn
            self.version = version
            self.versionDescription = versionDescription
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case version = "Version"
            case versionDescription = "VersionDescription"
        }
    }

    public struct ContactSearchSummary: AWSDecodableShape {
        /// Information about the agent who accepted the contact.
        public let agentInfo: ContactSearchSummaryAgentInfo?
        /// The Amazon Resource Name (ARN) of the contact.
        public let arn: String?
        /// How the contact reached your contact center.
        public let channel: Channel?
        /// The timestamp when the customer endpoint disconnected from Amazon Connect.
        public let disconnectTimestamp: Date?
        /// The identifier of the contact summary.
        public let id: String?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public let initialContactId: String?
        /// Indicates how the contact was initiated.
        public let initiationMethod: ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time. For INBOUND, this is when the contact arrived. For OUTBOUND, this is when the agent began dialing. For CALLBACK, this is when the callback contact was created. For TRANSFER and QUEUE_TRANSFER, this is when the transfer was initiated. For API, this is when the request arrived. For EXTERNAL_OUTBOUND, this is when the agent started dialing the external participant. For MONITOR, this is when the supervisor started listening to a contact.
        public let initiationTimestamp: Date?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public let previousContactId: String?
        /// If this contact was queued, this contains information about the queue.
        public let queueInfo: ContactSearchSummaryQueueInfo?
        /// The timestamp, in Unix epoch time format, at which to start running the inbound flow.
        public let scheduledTimestamp: Date?
        /// Set of segment attributes for a contact.
        public let segmentAttributes: [String: ContactSearchSummarySegmentAttributeValue]?

        @inlinable
        public init(agentInfo: ContactSearchSummaryAgentInfo? = nil, arn: String? = nil, channel: Channel? = nil, disconnectTimestamp: Date? = nil, id: String? = nil, initialContactId: String? = nil, initiationMethod: ContactInitiationMethod? = nil, initiationTimestamp: Date? = nil, previousContactId: String? = nil, queueInfo: ContactSearchSummaryQueueInfo? = nil, scheduledTimestamp: Date? = nil, segmentAttributes: [String: ContactSearchSummarySegmentAttributeValue]? = nil) {
            self.agentInfo = agentInfo
            self.arn = arn
            self.channel = channel
            self.disconnectTimestamp = disconnectTimestamp
            self.id = id
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.previousContactId = previousContactId
            self.queueInfo = queueInfo
            self.scheduledTimestamp = scheduledTimestamp
            self.segmentAttributes = segmentAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case agentInfo = "AgentInfo"
            case arn = "Arn"
            case channel = "Channel"
            case disconnectTimestamp = "DisconnectTimestamp"
            case id = "Id"
            case initialContactId = "InitialContactId"
            case initiationMethod = "InitiationMethod"
            case initiationTimestamp = "InitiationTimestamp"
            case previousContactId = "PreviousContactId"
            case queueInfo = "QueueInfo"
            case scheduledTimestamp = "ScheduledTimestamp"
            case segmentAttributes = "SegmentAttributes"
        }
    }

    public struct ContactSearchSummaryAgentInfo: AWSDecodableShape {
        /// The timestamp when the contact was connected to the agent.
        public let connectedToAgentTimestamp: Date?
        /// The identifier of the agent who accepted the contact.
        public let id: String?

        @inlinable
        public init(connectedToAgentTimestamp: Date? = nil, id: String? = nil) {
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
            case id = "Id"
        }
    }

    public struct ContactSearchSummaryQueueInfo: AWSDecodableShape {
        /// The timestamp when the contact was added to the queue.
        public let enqueueTimestamp: Date?
        /// The unique identifier for the queue.
        public let id: String?

        @inlinable
        public init(enqueueTimestamp: Date? = nil, id: String? = nil) {
            self.enqueueTimestamp = enqueueTimestamp
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case enqueueTimestamp = "EnqueueTimestamp"
            case id = "Id"
        }
    }

    public struct ContactSearchSummarySegmentAttributeValue: AWSDecodableShape {
        /// The value of a segment attribute represented as a string.
        public let valueString: String?

        @inlinable
        public init(valueString: String? = nil) {
            self.valueString = valueString
        }

        private enum CodingKeys: String, CodingKey {
            case valueString = "ValueString"
        }
    }

    public struct ControlPlaneAttributeFilter: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andCondition: CommonAttributeAndCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [CommonAttributeAndCondition]?
        public let tagCondition: TagCondition?

        @inlinable
        public init(andCondition: CommonAttributeAndCondition? = nil, orConditions: [CommonAttributeAndCondition]? = nil, tagCondition: TagCondition? = nil) {
            self.andCondition = andCondition
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andCondition = "AndCondition"
            case orConditions = "OrConditions"
            case tagCondition = "TagCondition"
        }
    }

    public struct ControlPlaneTagFilter: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [TagCondition]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [[TagCondition]]?
        /// A leaf node condition which can be used to specify a tag condition.
        public let tagCondition: TagCondition?

        @inlinable
        public init(andConditions: [TagCondition]? = nil, orConditions: [[TagCondition]]? = nil, tagCondition: TagCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case tagCondition = "TagCondition"
        }
    }

    public struct ControlPlaneUserAttributeFilter: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andCondition: AttributeAndCondition?
        public let hierarchyGroupCondition: HierarchyGroupCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [AttributeAndCondition]?
        public let tagCondition: TagCondition?

        @inlinable
        public init(andCondition: AttributeAndCondition? = nil, hierarchyGroupCondition: HierarchyGroupCondition? = nil, orConditions: [AttributeAndCondition]? = nil, tagCondition: TagCondition? = nil) {
            self.andCondition = andCondition
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andCondition = "AndCondition"
            case hierarchyGroupCondition = "HierarchyGroupCondition"
            case orConditions = "OrConditions"
            case tagCondition = "TagCondition"
        }
    }

    public struct CreateAgentStatusRequest: AWSEncodableShape {
        /// The description of the status.
        public let description: String?
        /// The display order of the status.
        public let displayOrder: Int?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the status.
        public let name: String
        /// The state of the status.
        public let state: AgentStatusState
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, displayOrder: Int? = nil, instanceId: String, name: String, state: AgentStatusState, tags: [String: String]? = nil) {
            self.description = description
            self.displayOrder = displayOrder
            self.instanceId = instanceId
            self.name = name
            self.state = state
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayOrder, forKey: .displayOrder)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.state, forKey: .state)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, max: 50)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayOrder = "DisplayOrder"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct CreateAgentStatusResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent status.
        public let agentStatusARN: String?
        /// The identifier of the agent status.
        public let agentStatusId: String?

        @inlinable
        public init(agentStatusARN: String? = nil, agentStatusId: String? = nil) {
            self.agentStatusARN = agentStatusARN
            self.agentStatusId = agentStatusId
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusARN = "AgentStatusARN"
            case agentStatusId = "AgentStatusId"
        }
    }

    public struct CreateCaseActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects with Field ID and Value data.
        public let fields: [FieldValue]
        /// A unique identifier of a template.
        public let templateId: String

        @inlinable
        public init(fields: [FieldValue], templateId: String) {
            self.fields = fields
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.templateId, name: "templateId", parent: name, max: 500)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case templateId = "TemplateId"
        }
    }

    public struct CreateContactFlowModuleRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The JSON string that represents the content of the flow. For an example, see Example flow in Amazon Connect Flow language.
        public let content: String
        /// The description of the flow module.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the flow module.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateContactFlowModuleRequest.idempotencyToken(), content: String, description: String? = nil, instanceId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.content = content
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.content, name: "content", parent: name, max: 256000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case content = "Content"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateContactFlowModuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow module.
        public let arn: String?
        /// The identifier of the flow module.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateContactFlowRequest: AWSEncodableShape {
        /// The JSON string that represents the content of the flow. For an example, see Example flow in Amazon Connect Flow language.  Length Constraints: Minimum length of 1. Maximum length of 256000.
        public let content: String
        /// The description of the flow.
        public let description: String?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The name of the flow.
        public let name: String
        /// Indicates the flow status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content. the SAVED status does not initiate validation of the content. SAVED | PUBLISHED.
        public let status: ContactFlowStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of the flow. For descriptions of the available types, see Choose a flow type in the Amazon Connect Administrator Guide.
        public let type: ContactFlowType

        @inlinable
        public init(content: String, description: String? = nil, instanceId: String, name: String, status: ContactFlowStatus? = nil, tags: [String: String]? = nil, type: ContactFlowType) {
            self.content = content
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case description = "Description"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct CreateContactFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let contactFlowArn: String?
        /// The identifier of the flow.
        public let contactFlowId: String?
        /// Indicates the checksum value of the latest published flow content.
        public let flowContentSha256: String?

        @inlinable
        public init(contactFlowArn: String? = nil, contactFlowId: String? = nil, flowContentSha256: String? = nil) {
            self.contactFlowArn = contactFlowArn
            self.contactFlowId = contactFlowId
            self.flowContentSha256 = flowContentSha256
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowArn = "ContactFlowArn"
            case contactFlowId = "ContactFlowId"
            case flowContentSha256 = "FlowContentSha256"
        }
    }

    public struct CreateContactFlowVersionRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the flow version.
        public let contactFlowVersion: Int64?
        /// The description of the flow version.
        public let description: String?
        /// Indicates the checksum value of the flow content.
        public let flowContentSha256: String?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedTime: Date?

        @inlinable
        public init(contactFlowId: String, contactFlowVersion: Int64? = nil, description: String? = nil, flowContentSha256: String? = nil, instanceId: String, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil) {
            self.contactFlowId = contactFlowId
            self.contactFlowVersion = contactFlowVersion
            self.description = description
            self.flowContentSha256 = flowContentSha256
            self.instanceId = instanceId
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            try container.encodeIfPresent(self.contactFlowVersion, forKey: .contactFlowVersion)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.flowContentSha256, forKey: .flowContentSha256)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.lastModifiedRegion, forKey: .lastModifiedRegion)
            try container.encodeIfPresent(self.lastModifiedTime, forKey: .lastModifiedTime)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowVersion, name: "contactFlowVersion", parent: name, min: 1)
            try self.validate(self.flowContentSha256, name: "flowContentSha256", parent: name, max: 64)
            try self.validate(self.flowContentSha256, name: "flowContentSha256", parent: name, min: 1)
            try self.validate(self.flowContentSha256, name: "flowContentSha256", parent: name, pattern: "^[a-zA-Z0-9]{64}$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.lastModifiedRegion, name: "lastModifiedRegion", parent: name, pattern: "^[a-z]{2}(-[a-z]+){1,2}(-[0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowVersion = "ContactFlowVersion"
            case description = "Description"
            case flowContentSha256 = "FlowContentSha256"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
        }
    }

    public struct CreateContactFlowVersionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let contactFlowArn: String?
        /// The identifier of the flow version.
        public let version: Int64?

        @inlinable
        public init(contactFlowArn: String? = nil, version: Int64? = nil) {
            self.contactFlowArn = contactFlowArn
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowArn = "ContactFlowArn"
            case version = "Version"
        }
    }

    public struct CreateContactRequest: AWSEncodableShape {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// The channel for the contact  CreateContact only supports the EMAIL channel. The following information that states other channels are supported is incorrect. We are working to update this topic.
        public let channel: Channel
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A description of the contact.
        public let description: String?
        /// Number of minutes the contact will be active for before expiring
        public let expiryDurationInMinutes: Int?
        /// Initial state of the contact when it's created
        public let initiateAs: InitiateAs?
        /// Indicates how the contact was initiated.   CreateContact only supports the following initiation methods: OUTBOUND, AGENT_REPLY, and FLOW. The following information that states other initiation methods are supported is incorrect. We are working to update this topic.
        public let initiationMethod: ContactInitiationMethod
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of a the contact.
        public let name: String?
        /// The ID of the previous contact when creating a transfer contact. This value can be provided only for external audio contacts. For more information, see Integrate Amazon Connect Contact Lens with external voice systems in the Amazon Connect Administrator Guide.
        public let previousContactId: String?
        /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Tasks can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL | ATTACHMENT.
        public let references: [String: Reference]?
        /// The unique identifier for an Amazon Connect contact. This identifier is related to the contact starting.
        public let relatedContactId: String?
        /// A set of system defined key-value pairs stored on individual contact segments (unique contact ID) using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows. Attribute keys can include only alphanumeric, -, and _. This field can be used to set Segment Contact Expiry as a duration in minutes.  To set contact expiry, a ValueMap must be specified containing the integer number of minutes the contact will be active for before expiring, with SegmentAttributes like {  "connect:ContactExpiry": {"ValueMap" : { "ExpiryDuration": { "ValueInteger": 135}}}}.
        public let segmentAttributes: [String: SegmentAttributeValue]?
        /// User details for the contact
        public let userInfo: UserInfo?

        @inlinable
        public init(attributes: [String: String]? = nil, channel: Channel, clientToken: String? = CreateContactRequest.idempotencyToken(), description: String? = nil, expiryDurationInMinutes: Int? = nil, initiateAs: InitiateAs? = nil, initiationMethod: ContactInitiationMethod, instanceId: String, name: String? = nil, previousContactId: String? = nil, references: [String: Reference]? = nil, relatedContactId: String? = nil, segmentAttributes: [String: SegmentAttributeValue]? = nil, userInfo: UserInfo? = nil) {
            self.attributes = attributes
            self.channel = channel
            self.clientToken = clientToken
            self.description = description
            self.expiryDurationInMinutes = expiryDurationInMinutes
            self.initiateAs = initiateAs
            self.initiationMethod = initiationMethod
            self.instanceId = instanceId
            self.name = name
            self.previousContactId = previousContactId
            self.references = references
            self.relatedContactId = relatedContactId
            self.segmentAttributes = segmentAttributes
            self.userInfo = userInfo
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.previousContactId, name: "previousContactId", parent: name, max: 256)
            try self.validate(self.previousContactId, name: "previousContactId", parent: name, min: 1)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, max: 256)
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, min: 1)
            try self.segmentAttributes?.forEach {
                try validate($0.key, name: "segmentAttributes.key", parent: name, max: 128)
                try validate($0.key, name: "segmentAttributes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).segmentAttributes[\"\($0.key)\"]")
            }
            try self.userInfo?.validate(name: "\(name).userInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case channel = "Channel"
            case clientToken = "ClientToken"
            case description = "Description"
            case expiryDurationInMinutes = "ExpiryDurationInMinutes"
            case initiateAs = "InitiateAs"
            case initiationMethod = "InitiationMethod"
            case instanceId = "InstanceId"
            case name = "Name"
            case previousContactId = "PreviousContactId"
            case references = "References"
            case relatedContactId = "RelatedContactId"
            case segmentAttributes = "SegmentAttributes"
            case userInfo = "UserInfo"
        }
    }

    public struct CreateContactResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created contact.
        public let contactArn: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?

        @inlinable
        public init(contactArn: String? = nil, contactId: String? = nil) {
            self.contactArn = contactArn
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case contactId = "ContactId"
        }
    }

    public struct CreateEmailAddressRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the email address.
        public let description: String?
        /// The display name of email address
        public let displayName: String?
        /// The email address with the instance, in [^\s@]+@[^\s@]+\.[^\s@]+ format.
        public let emailAddress: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = nil, description: String? = nil, displayName: String? = nil, emailAddress: String, instanceId: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.instanceId = instanceId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encode(self.emailAddress, forKey: .emailAddress)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 255)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case displayName = "DisplayName"
            case emailAddress = "EmailAddress"
            case tags = "Tags"
        }
    }

    public struct CreateEmailAddressResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the email address.
        public let emailAddressArn: String?
        /// The identifier of the email address.
        public let emailAddressId: String?

        @inlinable
        public init(emailAddressArn: String? = nil, emailAddressId: String? = nil) {
            self.emailAddressArn = emailAddressArn
            self.emailAddressId = emailAddressId
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddressArn = "EmailAddressArn"
            case emailAddressId = "EmailAddressId"
        }
    }

    public struct CreateEvaluationFormRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the evaluation form.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Items that are part of the evaluation form.  The total number of sections and questions must not exceed 100 each.  Questions must be contained in a section.
        public let items: [EvaluationFormItem]
        /// A scoring strategy of the evaluation form.
        public let scoringStrategy: EvaluationFormScoringStrategy?
        /// A title of the evaluation form.
        public let title: String

        @inlinable
        public init(clientToken: String? = CreateEvaluationFormRequest.idempotencyToken(), description: String? = nil, instanceId: String, items: [EvaluationFormItem], scoringStrategy: EvaluationFormScoringStrategy? = nil, title: String) {
            self.clientToken = clientToken
            self.description = description
            self.instanceId = instanceId
            self.items = items
            self.scoringStrategy = scoringStrategy
            self.title = title
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.items, forKey: .items)
            try container.encodeIfPresent(self.scoringStrategy, forKey: .scoringStrategy)
            try container.encode(self.title, forKey: .title)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, max: 100)
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 128)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case items = "Items"
            case scoringStrategy = "ScoringStrategy"
            case title = "Title"
        }
    }

    public struct CreateEvaluationFormResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String

        @inlinable
        public init(evaluationFormArn: String, evaluationFormId: String) {
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
        }
    }

    public struct CreateHoursOfOperationOverrideRequest: AWSEncodableShape {
        /// Configuration information for the hours of operation override: day, start time, and end time.
        public let config: [HoursOfOperationOverrideConfig]
        /// The description of the hours of operation override.
        public let description: String?
        /// The date from when the hours of operation override would be effective.
        public let effectiveFrom: String
        /// The date until when the hours of operation override would be effective.
        public let effectiveTill: String
        /// The identifier for the hours of operation
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The name of the hours of operation override.
        public let name: String

        @inlinable
        public init(config: [HoursOfOperationOverrideConfig], description: String? = nil, effectiveFrom: String, effectiveTill: String, hoursOfOperationId: String, instanceId: String, name: String) {
            self.config = config
            self.description = description
            self.effectiveFrom = effectiveFrom
            self.effectiveTill = effectiveTill
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.config, forKey: .config)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.effectiveFrom, forKey: .effectiveFrom)
            try container.encode(self.effectiveTill, forKey: .effectiveTill)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.config.forEach {
                try $0.validate(name: "\(name).config[]")
            }
            try self.validate(self.config, name: "config", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\P{C}\\r\\n\\t]{1,250}$")
            try self.validate(self.effectiveFrom, name: "effectiveFrom", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
            try self.validate(self.effectiveTill, name: "effectiveTill", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\P{C}\\r\\n\\t]{1,127}$")
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case effectiveFrom = "EffectiveFrom"
            case effectiveTill = "EffectiveTill"
            case name = "Name"
        }
    }

    public struct CreateHoursOfOperationOverrideResponse: AWSDecodableShape {
        /// The identifier for the hours of operation override.
        public let hoursOfOperationOverrideId: String?

        @inlinable
        public init(hoursOfOperationOverrideId: String? = nil) {
            self.hoursOfOperationOverrideId = hoursOfOperationOverrideId
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationOverrideId = "HoursOfOperationOverrideId"
        }
    }

    public struct CreateHoursOfOperationRequest: AWSEncodableShape {
        /// Configuration information for the hours of operation: day, start time, and end time.
        public let config: [HoursOfOperationConfig]
        /// The description of the hours of operation.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the hours of operation.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The time zone of the hours of operation.
        public let timeZone: String

        @inlinable
        public init(config: [HoursOfOperationConfig], description: String? = nil, instanceId: String, name: String, tags: [String: String]? = nil, timeZone: String) {
            self.config = config
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.tags = tags
            self.timeZone = timeZone
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.config, forKey: .config)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.timeZone, forKey: .timeZone)
        }

        public func validate(name: String) throws {
            try self.config.forEach {
                try $0.validate(name: "\(name).config[]")
            }
            try self.validate(self.config, name: "config", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
            case timeZone = "TimeZone"
        }
    }

    public struct CreateHoursOfOperationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public let hoursOfOperationArn: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String?

        @inlinable
        public init(hoursOfOperationArn: String? = nil, hoursOfOperationId: String? = nil) {
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationArn = "HoursOfOperationArn"
            case hoursOfOperationId = "HoursOfOperationId"
        }
    }

    public struct CreateInstanceRequest: AWSEncodableShape {
        /// The idempotency token.
        public let clientToken: String?
        /// The identifier for the directory.
        public let directoryId: String?
        /// The type of identity management for your Amazon Connect users.
        public let identityManagementType: DirectoryType
        /// Your contact center handles incoming contacts.
        public let inboundCallsEnabled: Bool
        /// The name for your instance.
        public let instanceAlias: String?
        /// Your contact center allows outbound calls.
        public let outboundCallsEnabled: Bool
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateInstanceRequest.idempotencyToken(), directoryId: String? = nil, identityManagementType: DirectoryType, inboundCallsEnabled: Bool, instanceAlias: String? = nil, outboundCallsEnabled: Bool, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.directoryId = directoryId
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAlias = instanceAlias
            self.outboundCallsEnabled = outboundCallsEnabled
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.directoryId, name: "directoryId", parent: name, max: 12)
            try self.validate(self.directoryId, name: "directoryId", parent: name, min: 12)
            try self.validate(self.directoryId, name: "directoryId", parent: name, pattern: "^d-[0-9a-f]{10}$")
            try self.validate(self.instanceAlias, name: "instanceAlias", parent: name, max: 45)
            try self.validate(self.instanceAlias, name: "instanceAlias", parent: name, min: 1)
            try self.validate(self.instanceAlias, name: "instanceAlias", parent: name, pattern: "^(?!d-)([\\da-zA-Z]+)([-]*[\\da-zA-Z])*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case directoryId = "DirectoryId"
            case identityManagementType = "IdentityManagementType"
            case inboundCallsEnabled = "InboundCallsEnabled"
            case instanceAlias = "InstanceAlias"
            case outboundCallsEnabled = "OutboundCallsEnabled"
            case tags = "Tags"
        }
    }

    public struct CreateInstanceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the instance.
        public let arn: String?
        /// The identifier for the instance.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateIntegrationAssociationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The Amazon Resource Name (ARN) of the integration.  When integrating with Amazon Web Services End User Messaging, the Amazon Connect and Amazon Web Services End User Messaging instances must be in the same account.
        public let integrationArn: String
        /// The type of information to be ingested.
        public let integrationType: IntegrationType
        /// The name of the external application. This field is only required for the EVENT integration type.
        public let sourceApplicationName: String?
        /// The URL for the external application. This field is only required for the EVENT integration type.
        public let sourceApplicationUrl: String?
        /// The type of the data source. This field is only required for the EVENT integration type.
        public let sourceType: SourceType?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(instanceId: String, integrationArn: String, integrationType: IntegrationType, sourceApplicationName: String? = nil, sourceApplicationUrl: String? = nil, sourceType: SourceType? = nil, tags: [String: String]? = nil) {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationType = integrationType
            self.sourceApplicationName = sourceApplicationName
            self.sourceApplicationUrl = sourceApplicationUrl
            self.sourceType = sourceType
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.integrationArn, forKey: .integrationArn)
            try container.encode(self.integrationType, forKey: .integrationType)
            try container.encodeIfPresent(self.sourceApplicationName, forKey: .sourceApplicationName)
            try container.encodeIfPresent(self.sourceApplicationUrl, forKey: .sourceApplicationUrl)
            try container.encodeIfPresent(self.sourceType, forKey: .sourceType)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.sourceApplicationName, name: "sourceApplicationName", parent: name, max: 100)
            try self.validate(self.sourceApplicationName, name: "sourceApplicationName", parent: name, min: 1)
            try self.validate(self.sourceApplicationName, name: "sourceApplicationName", parent: name, pattern: "^[a-zA-Z0-9_ -]+$")
            try self.validate(self.sourceApplicationUrl, name: "sourceApplicationUrl", parent: name, max: 2000)
            try self.validate(self.sourceApplicationUrl, name: "sourceApplicationUrl", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case integrationArn = "IntegrationArn"
            case integrationType = "IntegrationType"
            case sourceApplicationName = "SourceApplicationName"
            case sourceApplicationUrl = "SourceApplicationUrl"
            case sourceType = "SourceType"
            case tags = "Tags"
        }
    }

    public struct CreateIntegrationAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the association.
        public let integrationAssociationArn: String?
        /// The identifier for the integration association.
        public let integrationAssociationId: String?

        @inlinable
        public init(integrationAssociationArn: String? = nil, integrationAssociationId: String? = nil) {
            self.integrationAssociationArn = integrationAssociationArn
            self.integrationAssociationId = integrationAssociationId
        }

        private enum CodingKeys: String, CodingKey {
            case integrationAssociationArn = "IntegrationAssociationArn"
            case integrationAssociationId = "IntegrationAssociationId"
        }
    }

    public struct CreateParticipantRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the contact in this instance of Amazon Connect.  Only contacts in the CHAT channel are supported.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Information identifying the participant.  The only Valid value for ParticipantRole is CUSTOM_BOT.   DisplayName is Required.
        public let participantDetails: ParticipantDetailsToAdd

        @inlinable
        public init(clientToken: String? = CreateParticipantRequest.idempotencyToken(), contactId: String, instanceId: String, participantDetails: ParticipantDetailsToAdd) {
            self.clientToken = clientToken
            self.contactId = contactId
            self.instanceId = instanceId
            self.participantDetails = participantDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.participantDetails.validate(name: "\(name).participantDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case participantDetails = "ParticipantDetails"
        }
    }

    public struct CreateParticipantResponse: AWSDecodableShape {
        /// The token used by the chat participant to call CreateParticipantConnection. The participant token is valid for the lifetime of a chat participant.
        public let participantCredentials: ParticipantTokenCredentials?
        /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
        public let participantId: String?

        @inlinable
        public init(participantCredentials: ParticipantTokenCredentials? = nil, participantId: String? = nil) {
            self.participantCredentials = participantCredentials
            self.participantId = participantId
        }

        private enum CodingKeys: String, CodingKey {
            case participantCredentials = "ParticipantCredentials"
            case participantId = "ParticipantId"
        }
    }

    public struct CreatePersistentContactAssociationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// This is the contactId of the current contact that the CreatePersistentContactAssociation API is being called from.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The contactId chosen for rehydration depends on the type chosen.    ENTIRE_PAST_SESSION: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the initialContactId of the past ended chat session in the sourceContactId field. In this type, Amazon Connect determines what the most recent chat contact on the past ended chat session and uses it to start a persistent chat.     FROM_SEGMENT: Rehydrates a chat from the specified past chat contact provided in the sourceContactId field.    The actual contactId used for rehydration is provided in the response of this API. To illustrate how to use rehydration type, consider the following example: A customer starts a chat session. Agent a1 accepts the chat and a conversation starts between the customer and Agent a1. This first contact creates a contact ID C1. Agent a1 then transfers the chat to Agent a2. This creates another contact ID C2. At this point Agent a2 ends the chat. The customer is forwarded to the disconnect flow for a post chat survey that creates another contact ID C3. After the chat survey, the chat session ends. Later, the customer returns and wants to resume their past chat session. At this point, the customer can have following use cases:     Use Case 1: The customer wants to continue the past chat session but they want to hide the post chat survey. For this they will use the following configuration:    Configuration    SourceContactId = "C2"   RehydrationType = "FROM_SEGMENT"      Expected behavior    This starts a persistent chat session from the specified past ended contact (C2). Transcripts of past chat sessions C2 and C1 are accessible in the current persistent chat session. Note that chat segment C3 is dropped from the persistent chat session.        Use Case 2: The customer wants to continue the past chat session and see the transcript of the entire past engagement, including the post chat survey. For this they will use the following configuration:    Configuration    SourceContactId = "C1"   RehydrationType = "ENTIRE_PAST_SESSION"      Expected behavior    This starts a persistent chat session from the most recently ended chat contact (C3). Transcripts of past chat sessions C3, C2 and C1 are accessible in the current persistent chat session.
        public let rehydrationType: RehydrationType
        /// The contactId from which a persistent chat session must be started.
        public let sourceContactId: String

        @inlinable
        public init(clientToken: String? = nil, initialContactId: String, instanceId: String, rehydrationType: RehydrationType, sourceContactId: String) {
            self.clientToken = clientToken
            self.initialContactId = initialContactId
            self.instanceId = instanceId
            self.rehydrationType = rehydrationType
            self.sourceContactId = sourceContactId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.initialContactId, key: "InitialContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.rehydrationType, forKey: .rehydrationType)
            try container.encode(self.sourceContactId, forKey: .sourceContactId)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.sourceContactId, name: "sourceContactId", parent: name, max: 256)
            try self.validate(self.sourceContactId, name: "sourceContactId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case rehydrationType = "RehydrationType"
            case sourceContactId = "SourceContactId"
        }
    }

    public struct CreatePersistentContactAssociationResponse: AWSDecodableShape {
        /// The contactId from which a persistent chat session is started. This field is populated only for persistent chat.
        public let continuedFromContactId: String?

        @inlinable
        public init(continuedFromContactId: String? = nil) {
            self.continuedFromContactId = continuedFromContactId
        }

        private enum CodingKeys: String, CodingKey {
            case continuedFromContactId = "ContinuedFromContactId"
        }
    }

    public struct CreatePredefinedAttributeRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        ///  The name of the predefined attribute.
        public let name: String
        ///  The values of the predefined attribute.
        public let values: PredefinedAttributeValues

        @inlinable
        public init(instanceId: String, name: String, values: PredefinedAttributeValues) {
            self.instanceId = instanceId
            self.name = name
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.values, forKey: .values)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values.validate(name: "\(name).values")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct CreatePromptRequest: AWSEncodableShape {
        /// The description of the prompt.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the prompt.
        public let name: String
        /// The URI for the S3 bucket where the prompt is stored. You can provide S3 pre-signed URLs returned by the
        /// GetPromptFile API instead of providing S3 URIs.
        public let s3Uri: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, instanceId: String, name: String, s3Uri: String, tags: [String: String]? = nil) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.s3Uri = s3Uri
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.s3Uri, forKey: .s3Uri)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 2000)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://\\S+/.+|https://\\\\S+\\\\.s3\\\\.\\\\S+\\\\.amazonaws\\\\.com/\\\\S+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case s3Uri = "S3Uri"
            case tags = "Tags"
        }
    }

    public struct CreatePromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let promptARN: String?
        /// A unique identifier for the prompt.
        public let promptId: String?

        @inlinable
        public init(promptARN: String? = nil, promptId: String? = nil) {
            self.promptARN = promptARN
            self.promptId = promptId
        }

        private enum CodingKeys: String, CodingKey {
            case promptARN = "PromptARN"
            case promptId = "PromptId"
        }
    }

    public struct CreatePushNotificationRegistrationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The contact configuration for push notification registration.
        public let contactConfiguration: ContactConfiguration
        /// The push notification token issued by the Apple or Google gateways.
        public let deviceToken: String
        /// The device type to use when sending the message.
        public let deviceType: DeviceType
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The Amazon Resource Name (ARN) of the Pinpoint application.
        public let pinpointAppArn: String

        @inlinable
        public init(clientToken: String? = CreatePushNotificationRegistrationRequest.idempotencyToken(), contactConfiguration: ContactConfiguration, deviceToken: String, deviceType: DeviceType, instanceId: String, pinpointAppArn: String) {
            self.clientToken = clientToken
            self.contactConfiguration = contactConfiguration
            self.deviceToken = deviceToken
            self.deviceType = deviceType
            self.instanceId = instanceId
            self.pinpointAppArn = pinpointAppArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.contactConfiguration, forKey: .contactConfiguration)
            try container.encode(self.deviceToken, forKey: .deviceToken)
            try container.encode(self.deviceType, forKey: .deviceType)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.pinpointAppArn, forKey: .pinpointAppArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.contactConfiguration.validate(name: "\(name).contactConfiguration")
            try self.validate(self.deviceToken, name: "deviceToken", parent: name, max: 500)
            try self.validate(self.deviceToken, name: "deviceToken", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case contactConfiguration = "ContactConfiguration"
            case deviceToken = "DeviceToken"
            case deviceType = "DeviceType"
            case pinpointAppArn = "PinpointAppArn"
        }
    }

    public struct CreatePushNotificationRegistrationResponse: AWSDecodableShape {
        /// The identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(registrationId: String) {
            self.registrationId = registrationId
        }

        private enum CodingKeys: String, CodingKey {
            case registrationId = "RegistrationId"
        }
    }

    public struct CreateQueueRequest: AWSEncodableShape {
        /// The description of the queue.
        public let description: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public let maxContacts: Int?
        /// The name of the queue.
        public let name: String
        /// The outbound caller ID name, number, and outbound whisper flow.
        public let outboundCallerConfig: OutboundCallerConfig?
        /// The outbound email address ID for a specified queue.
        public let outboundEmailConfig: OutboundEmailConfig?
        /// The quick connects available to agents who are working the queue.
        public let quickConnectIds: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, hoursOfOperationId: String, instanceId: String, maxContacts: Int? = nil, name: String, outboundCallerConfig: OutboundCallerConfig? = nil, outboundEmailConfig: OutboundEmailConfig? = nil, quickConnectIds: [String]? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.maxContacts = maxContacts
            self.name = name
            self.outboundCallerConfig = outboundCallerConfig
            self.outboundEmailConfig = outboundEmailConfig
            self.quickConnectIds = quickConnectIds
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.hoursOfOperationId, forKey: .hoursOfOperationId)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.maxContacts, forKey: .maxContacts)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.outboundCallerConfig, forKey: .outboundCallerConfig)
            try container.encodeIfPresent(self.outboundEmailConfig, forKey: .outboundEmailConfig)
            try container.encodeIfPresent(self.quickConnectIds, forKey: .quickConnectIds)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxContacts, name: "maxContacts", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outboundCallerConfig?.validate(name: "\(name).outboundCallerConfig")
            try self.outboundEmailConfig?.validate(name: "\(name).outboundEmailConfig")
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, max: 50)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case hoursOfOperationId = "HoursOfOperationId"
            case maxContacts = "MaxContacts"
            case name = "Name"
            case outboundCallerConfig = "OutboundCallerConfig"
            case outboundEmailConfig = "OutboundEmailConfig"
            case quickConnectIds = "QuickConnectIds"
            case tags = "Tags"
        }
    }

    public struct CreateQueueResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the queue.
        public let queueArn: String?
        /// The identifier for the queue.
        public let queueId: String?

        @inlinable
        public init(queueArn: String? = nil, queueId: String? = nil) {
            self.queueArn = queueArn
            self.queueId = queueId
        }

        private enum CodingKeys: String, CodingKey {
            case queueArn = "QueueArn"
            case queueId = "QueueId"
        }
    }

    public struct CreateQuickConnectRequest: AWSEncodableShape {
        /// The description of the quick connect.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique name of the quick connect.
        public let name: String
        /// Configuration settings for the quick connect.
        public let quickConnectConfig: QuickConnectConfig
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, instanceId: String, name: String, quickConnectConfig: QuickConnectConfig, tags: [String: String]? = nil) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.quickConnectConfig = quickConnectConfig
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.quickConnectConfig, forKey: .quickConnectConfig)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.quickConnectConfig.validate(name: "\(name).quickConnectConfig")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case quickConnectConfig = "QuickConnectConfig"
            case tags = "Tags"
        }
    }

    public struct CreateQuickConnectResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the quick connect.
        public let quickConnectARN: String?
        /// The identifier for the quick connect.
        public let quickConnectId: String?

        @inlinable
        public init(quickConnectARN: String? = nil, quickConnectId: String? = nil) {
            self.quickConnectARN = quickConnectARN
            self.quickConnectId = quickConnectId
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectARN = "QuickConnectARN"
            case quickConnectId = "QuickConnectId"
        }
    }

    public struct CreateRoutingProfileRequest: AWSEncodableShape {
        /// Whether agents with this routing profile will have their routing order calculated based on longest idle time or time since their last inbound contact.
        public let agentAvailabilityTimer: AgentAvailabilityTimer?
        /// The default outbound queue for the routing profile.
        public let defaultOutboundQueueId: String
        /// Description of the routing profile. Must not be more than 250 characters.
        public let description: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public let mediaConcurrencies: [MediaConcurrency]
        /// The name of the routing profile. Must not be more than 127 characters.
        public let name: String
        /// The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls. The limit of 10 array members applies to the maximum number of RoutingProfileQueueConfig objects that can be passed during a CreateRoutingProfile API request. It is different from the quota of 50 queues per routing profile per instance that is listed in Amazon Connect service quotas.
        public let queueConfigs: [RoutingProfileQueueConfig]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(agentAvailabilityTimer: AgentAvailabilityTimer? = nil, defaultOutboundQueueId: String, description: String, instanceId: String, mediaConcurrencies: [MediaConcurrency], name: String, queueConfigs: [RoutingProfileQueueConfig]? = nil, tags: [String: String]? = nil) {
            self.agentAvailabilityTimer = agentAvailabilityTimer
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.description = description
            self.instanceId = instanceId
            self.mediaConcurrencies = mediaConcurrencies
            self.name = name
            self.queueConfigs = queueConfigs
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.agentAvailabilityTimer, forKey: .agentAvailabilityTimer)
            try container.encode(self.defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
            try container.encode(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.mediaConcurrencies, forKey: .mediaConcurrencies)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.queueConfigs, forKey: .queueConfigs)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.mediaConcurrencies.forEach {
                try $0.validate(name: "\(name).mediaConcurrencies[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.queueConfigs?.forEach {
                try $0.validate(name: "\(name).queueConfigs[]")
            }
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, max: 10)
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agentAvailabilityTimer = "AgentAvailabilityTimer"
            case defaultOutboundQueueId = "DefaultOutboundQueueId"
            case description = "Description"
            case mediaConcurrencies = "MediaConcurrencies"
            case name = "Name"
            case queueConfigs = "QueueConfigs"
            case tags = "Tags"
        }
    }

    public struct CreateRoutingProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let routingProfileArn: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String?

        @inlinable
        public init(routingProfileArn: String? = nil, routingProfileId: String? = nil) {
            self.routingProfileArn = routingProfileArn
            self.routingProfileId = routingProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case routingProfileArn = "RoutingProfileArn"
            case routingProfileId = "RoutingProfileId"
        }
    }

    public struct CreateRuleRequest: AWSEncodableShape {
        /// A list of actions to be run when the rule is triggered.
        public let actions: [RuleAction]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The conditions of the rule.
        public let function: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique name for the rule.
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// The event source to trigger the rule.
        public let triggerEventSource: RuleTriggerEventSource

        @inlinable
        public init(actions: [RuleAction], clientToken: String? = CreateRuleRequest.idempotencyToken(), function: String, instanceId: String, name: String, publishStatus: RulePublishStatus, triggerEventSource: RuleTriggerEventSource) {
            self.actions = actions
            self.clientToken = clientToken
            self.function = function
            self.instanceId = instanceId
            self.name = name
            self.publishStatus = publishStatus
            self.triggerEventSource = triggerEventSource
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actions, forKey: .actions)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.function, forKey: .function)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.publishStatus, forKey: .publishStatus)
            try container.encode(self.triggerEventSource, forKey: .triggerEventSource)
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.triggerEventSource.validate(name: "\(name).triggerEventSource")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case clientToken = "ClientToken"
            case function = "Function"
            case name = "Name"
            case publishStatus = "PublishStatus"
            case triggerEventSource = "TriggerEventSource"
        }
    }

    public struct CreateRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rule.
        public let ruleArn: String
        /// A unique identifier for the rule.
        public let ruleId: String

        @inlinable
        public init(ruleArn: String, ruleId: String) {
            self.ruleArn = ruleArn
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
            case ruleId = "RuleId"
        }
    }

    public struct CreateSecurityProfileRequest: AWSEncodableShape {
        /// The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlHierarchyGroupId: String?
        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlTags: [String: String]?
        /// A list of third-party applications that the security profile will give access to.
        public let applications: [Application]?
        /// The description of the security profile.
        public let description: String?
        /// The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: User.
        public let hierarchyRestrictedResources: [String]?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Permissions assigned to the security profile. For a list of valid permissions, see List of security profile permissions.
        public let permissions: [String]?
        /// The name of the security profile.
        public let securityProfileName: String
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect. For a list of Amazon Connect resources that you can tag, see Add tags to resources in Amazon Connect in the Amazon Connect Administrator Guide.
        public let tagRestrictedResources: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(allowedAccessControlHierarchyGroupId: String? = nil, allowedAccessControlTags: [String: String]? = nil, applications: [Application]? = nil, description: String? = nil, hierarchyRestrictedResources: [String]? = nil, instanceId: String, permissions: [String]? = nil, securityProfileName: String, tagRestrictedResources: [String]? = nil, tags: [String: String]? = nil) {
            self.allowedAccessControlHierarchyGroupId = allowedAccessControlHierarchyGroupId
            self.allowedAccessControlTags = allowedAccessControlTags
            self.applications = applications
            self.description = description
            self.hierarchyRestrictedResources = hierarchyRestrictedResources
            self.instanceId = instanceId
            self.permissions = permissions
            self.securityProfileName = securityProfileName
            self.tagRestrictedResources = tagRestrictedResources
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedAccessControlHierarchyGroupId, forKey: .allowedAccessControlHierarchyGroupId)
            try container.encodeIfPresent(self.allowedAccessControlTags, forKey: .allowedAccessControlTags)
            try container.encodeIfPresent(self.applications, forKey: .applications)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.hierarchyRestrictedResources, forKey: .hierarchyRestrictedResources)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            try container.encode(self.securityProfileName, forKey: .securityProfileName)
            try container.encodeIfPresent(self.tagRestrictedResources, forKey: .tagRestrictedResources)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.allowedAccessControlTags?.forEach {
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, max: 128)
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, min: 1)
                try validate($0.value, name: "allowedAccessControlTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.allowedAccessControlTags, name: "allowedAccessControlTags", parent: name, max: 4)
            try self.applications?.forEach {
                try $0.validate(name: "\(name).applications[]")
            }
            try self.validate(self.applications, name: "applications", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.hierarchyRestrictedResources?.forEach {
                try validate($0, name: "hierarchyRestrictedResources[]", parent: name, max: 128)
                try validate($0, name: "hierarchyRestrictedResources[]", parent: name, min: 1)
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, max: 128)
                try validate($0, name: "permissions[]", parent: name, min: 1)
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 500)
            try self.validate(self.securityProfileName, name: "securityProfileName", parent: name, max: 127)
            try self.validate(self.securityProfileName, name: "securityProfileName", parent: name, min: 1)
            try self.validate(self.securityProfileName, name: "securityProfileName", parent: name, pattern: "^[ a-zA-Z0-9_@-]+$")
            try self.tagRestrictedResources?.forEach {
                try validate($0, name: "tagRestrictedResources[]", parent: name, max: 128)
                try validate($0, name: "tagRestrictedResources[]", parent: name, min: 1)
            }
            try self.validate(self.tagRestrictedResources, name: "tagRestrictedResources", parent: name, max: 10)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAccessControlHierarchyGroupId = "AllowedAccessControlHierarchyGroupId"
            case allowedAccessControlTags = "AllowedAccessControlTags"
            case applications = "Applications"
            case description = "Description"
            case hierarchyRestrictedResources = "HierarchyRestrictedResources"
            case permissions = "Permissions"
            case securityProfileName = "SecurityProfileName"
            case tagRestrictedResources = "TagRestrictedResources"
            case tags = "Tags"
        }
    }

    public struct CreateSecurityProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the security profile.
        public let securityProfileArn: String?
        /// The identifier for the security profle.
        public let securityProfileId: String?

        @inlinable
        public init(securityProfileArn: String? = nil, securityProfileId: String? = nil) {
            self.securityProfileArn = securityProfileArn
            self.securityProfileId = securityProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case securityProfileArn = "SecurityProfileArn"
            case securityProfileId = "SecurityProfileId"
        }
    }

    public struct CreateTaskTemplateRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the task template.
        public let name: String
        /// The ContactFlowId for the flow that will be run if this template is used to create a self-assigned task.
        public let selfAssignFlowId: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        @inlinable
        public init(clientToken: String? = CreateTaskTemplateRequest.idempotencyToken(), constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField], instanceId: String, name: String, selfAssignFlowId: String? = nil, status: TaskTemplateStatus? = nil) {
            self.clientToken = clientToken
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.instanceId = instanceId
            self.name = name
            self.selfAssignFlowId = selfAssignFlowId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.constraints, forKey: .constraints)
            try container.encodeIfPresent(self.contactFlowId, forKey: .contactFlowId)
            try container.encodeIfPresent(self.defaults, forKey: .defaults)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.fields, forKey: .fields)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.selfAssignFlowId, forKey: .selfAssignFlowId)
            try container.encodeIfPresent(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.constraints?.validate(name: "\(name).constraints")
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.defaults?.validate(name: "\(name).defaults")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.selfAssignFlowId, name: "selfAssignFlowId", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case name = "Name"
            case selfAssignFlowId = "SelfAssignFlowId"
            case status = "Status"
        }
    }

    public struct CreateTaskTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the task template resource.
        public let arn: String
        /// The identifier of the task template resource.
        public let id: String

        @inlinable
        public init(arn: String, id: String) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateTrafficDistributionGroupRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A description for the traffic distribution group.
        public let description: String?
        /// The identifier of the Amazon Connect instance that has been replicated. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name for the traffic distribution group.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateTrafficDistributionGroupRequest.idempotencyToken(), description: String? = nil, instanceId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(^[\\S].*[\\S]$)|(^[\\S]$)$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(^[\\S].*[\\S]$)|(^[\\S]$)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case instanceId = "InstanceId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateTrafficDistributionGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN of the traffic distribution group.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateUseCaseRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
        public let useCaseType: UseCaseType

        @inlinable
        public init(instanceId: String, integrationAssociationId: String, tags: [String: String]? = nil, useCaseType: UseCaseType) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
            self.tags = tags
            self.useCaseType = useCaseType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.integrationAssociationId, key: "IntegrationAssociationId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.useCaseType, forKey: .useCaseType)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case useCaseType = "UseCaseType"
        }
    }

    public struct CreateUseCaseResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the use case.
        public let useCaseArn: String?
        /// The identifier of the use case.
        public let useCaseId: String?

        @inlinable
        public init(useCaseArn: String? = nil, useCaseId: String? = nil) {
            self.useCaseArn = useCaseArn
            self.useCaseId = useCaseId
        }

        private enum CodingKeys: String, CodingKey {
            case useCaseArn = "UseCaseArn"
            case useCaseId = "UseCaseId"
        }
    }

    public struct CreateUserHierarchyGroupRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the user hierarchy group. Must not be more than 100 characters.
        public let name: String
        /// The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.
        public let parentGroupId: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(instanceId: String, name: String, parentGroupId: String? = nil, tags: [String: String]? = nil) {
            self.instanceId = instanceId
            self.name = name
            self.parentGroupId = parentGroupId
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.parentGroupId, forKey: .parentGroupId)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parentGroupId = "ParentGroupId"
            case tags = "Tags"
        }
    }

    public struct CreateUserHierarchyGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let hierarchyGroupArn: String?
        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String?

        @inlinable
        public init(hierarchyGroupArn: String? = nil, hierarchyGroupId: String? = nil) {
            self.hierarchyGroupArn = hierarchyGroupArn
            self.hierarchyGroupId = hierarchyGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupArn = "HierarchyGroupArn"
            case hierarchyGroupId = "HierarchyGroupId"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory. This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.
        public let directoryUserId: String?
        /// The identifier of the hierarchy group for the user.
        public let hierarchyGroupId: String?
        /// The information about the identity of the user.
        public let identityInfo: UserIdentityInfo?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
        public let password: String?
        /// The phone settings for the user.
        public let phoneConfig: UserPhoneConfig
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String
        /// The identifier of the security profile for the user.
        public let securityProfileIds: [String]
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+. Username can include @ only if used in an email format. For example:   Correct: testuser   Correct: testuser@example.com   Incorrect: testuser@example
        public let username: String

        @inlinable
        public init(directoryUserId: String? = nil, hierarchyGroupId: String? = nil, identityInfo: UserIdentityInfo? = nil, instanceId: String, password: String? = nil, phoneConfig: UserPhoneConfig, routingProfileId: String, securityProfileIds: [String], tags: [String: String]? = nil, username: String) {
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.identityInfo = identityInfo
            self.instanceId = instanceId
            self.password = password
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.directoryUserId, forKey: .directoryUserId)
            try container.encodeIfPresent(self.hierarchyGroupId, forKey: .hierarchyGroupId)
            try container.encodeIfPresent(self.identityInfo, forKey: .identityInfo)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.password, forKey: .password)
            try container.encode(self.phoneConfig, forKey: .phoneConfig)
            try container.encode(self.routingProfileId, forKey: .routingProfileId)
            try container.encode(self.securityProfileIds, forKey: .securityProfileIds)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.username, forKey: .username)
        }

        public func validate(name: String) throws {
            try self.identityInfo?.validate(name: "\(name).identityInfo")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, pattern: "^/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d\\S]{8,64}$/$")
            try self.phoneConfig.validate(name: "\(name).phoneConfig")
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, max: 10)
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 100)
            try self.validate(self.username, name: "username", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case identityInfo = "IdentityInfo"
            case password = "Password"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user account.
        public let userArn: String?
        /// The identifier of the user account.
        public let userId: String?

        @inlinable
        public init(userArn: String? = nil, userId: String? = nil) {
            self.userArn = userArn
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userArn = "UserArn"
            case userId = "UserId"
        }
    }

    public struct CreateViewRequest: AWSEncodableShape {
        /// A unique Id for each create view request to avoid duplicate view creation. For example, the view is idempotent ClientToken is provided.
        public let clientToken: String?
        /// View content containing all content necessary to render a view except for runtime input data. The total uncompressed content has a maximum file size of 400kB.
        public let content: ViewInputContent
        /// The description of the view.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the view.
        public let name: String
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public let status: ViewStatus
        /// The tags associated with the view resource (not specific to view version).These tags can be used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = nil, content: ViewInputContent, description: String? = nil, instanceId: String, name: String, status: ViewStatus, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.content = content
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.status = status
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.status, forKey: .status)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@]*)$")
            try self.content.validate(name: "\(name).content")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^([\\p{L}\\p{N}_.:\\/=+\\-@,()']+[\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@,()']*)$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([\\p{L}\\p{N}_.:\\/=+\\-@()']+[\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@()']*)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case content = "Content"
            case description = "Description"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct CreateViewResponse: AWSDecodableShape {
        /// A view resource object. Contains metadata and content necessary to render the view.
        public let view: View?

        @inlinable
        public init(view: View? = nil) {
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case view = "View"
        }
    }

    public struct CreateViewVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The description for the version being published.
        public let versionDescription: String?
        /// Indicates the checksum value of the latest published view content.
        public let viewContentSha256: String?
        /// The identifier of the view. Both ViewArn and ViewId can be used.
        public let viewId: String

        @inlinable
        public init(instanceId: String, versionDescription: String? = nil, viewContentSha256: String? = nil, viewId: String) {
            self.instanceId = instanceId
            self.versionDescription = versionDescription
            self.viewContentSha256 = viewContentSha256
            self.viewId = viewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.versionDescription, forKey: .versionDescription)
            try container.encodeIfPresent(self.viewContentSha256, forKey: .viewContentSha256)
            request.encodePath(self.viewId, key: "ViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, max: 4096)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, min: 1)
            try self.validate(self.versionDescription, name: "versionDescription", parent: name, pattern: "^([\\p{L}\\p{N}_.:\\/=+\\-@,()']+[\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@,()']*)$")
            try self.validate(self.viewContentSha256, name: "viewContentSha256", parent: name, max: 64)
            try self.validate(self.viewContentSha256, name: "viewContentSha256", parent: name, min: 1)
            try self.validate(self.viewContentSha256, name: "viewContentSha256", parent: name, pattern: "^[a-zA-Z0-9]$")
            try self.validate(self.viewId, name: "viewId", parent: name, max: 500)
            try self.validate(self.viewId, name: "viewId", parent: name, min: 1)
            try self.validate(self.viewId, name: "viewId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/$]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case versionDescription = "VersionDescription"
            case viewContentSha256 = "ViewContentSha256"
        }
    }

    public struct CreateViewVersionResponse: AWSDecodableShape {
        /// All view data is contained within the View object.
        public let view: View?

        @inlinable
        public init(view: View? = nil) {
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case view = "View"
        }
    }

    public struct CreateVocabularyRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.
        public let clientToken: String?
        /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see Create a custom vocabulary using a table.
        public let content: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// A unique name of the custom vocabulary.
        public let vocabularyName: String

        @inlinable
        public init(clientToken: String? = CreateVocabularyRequest.idempotencyToken(), content: String, instanceId: String, languageCode: VocabularyLanguageCode, tags: [String: String]? = nil, vocabularyName: String) {
            self.clientToken = clientToken
            self.content = content
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.tags = tags
            self.vocabularyName = vocabularyName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.languageCode, forKey: .languageCode)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.vocabularyName, forKey: .vocabularyName)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.content, name: "content", parent: name, max: 60000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, max: 140)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, min: 1)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case content = "Content"
            case languageCode = "LanguageCode"
            case tags = "Tags"
            case vocabularyName = "VocabularyName"
        }
    }

    public struct CreateVocabularyResponse: AWSDecodableShape {
        /// The current state of the custom vocabulary.
        public let state: VocabularyState
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let vocabularyArn: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        @inlinable
        public init(state: VocabularyState, vocabularyArn: String, vocabularyId: String) {
            self.state = state
            self.vocabularyArn = vocabularyArn
            self.vocabularyId = vocabularyId
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case vocabularyArn = "VocabularyArn"
            case vocabularyId = "VocabularyId"
        }
    }

    public struct Credentials: AWSDecodableShape {
        /// An access token generated for a federated user to access Amazon Connect.
        public let accessToken: String?
        /// A token generated with an expiration time for the session a user is logged in to Amazon Connect.
        public let accessTokenExpiration: Date?
        /// Renews a token generated for a user to access the Amazon Connect instance.
        public let refreshToken: String?
        /// Renews the expiration timer for a generated token.
        public let refreshTokenExpiration: Date?

        @inlinable
        public init(accessToken: String? = nil, accessTokenExpiration: Date? = nil, refreshToken: String? = nil, refreshTokenExpiration: Date? = nil) {
            self.accessToken = accessToken
            self.accessTokenExpiration = accessTokenExpiration
            self.refreshToken = refreshToken
            self.refreshTokenExpiration = refreshTokenExpiration
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "AccessToken"
            case accessTokenExpiration = "AccessTokenExpiration"
            case refreshToken = "RefreshToken"
            case refreshTokenExpiration = "RefreshTokenExpiration"
        }
    }

    public struct CrossChannelBehavior: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the other channels that can be routed to an agent handling their current channel.
        public let behaviorType: BehaviorType

        @inlinable
        public init(behaviorType: BehaviorType) {
            self.behaviorType = behaviorType
        }

        private enum CodingKeys: String, CodingKey {
            case behaviorType = "BehaviorType"
        }
    }

    public struct CurrentMetric: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric.
        public let name: CurrentMetricName?
        /// The unit for the metric.
        public let unit: Unit?

        @inlinable
        public init(name: CurrentMetricName? = nil, unit: Unit? = nil) {
            self.name = name
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case unit = "Unit"
        }
    }

    public struct CurrentMetricData: AWSDecodableShape {
        /// Information about the metric.
        public let metric: CurrentMetric?
        /// The value of the metric.
        public let value: Double?

        @inlinable
        public init(metric: CurrentMetric? = nil, value: Double? = nil) {
            self.metric = metric
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case value = "Value"
        }
    }

    public struct CurrentMetricResult: AWSDecodableShape {
        /// The set of metrics.
        public let collections: [CurrentMetricData]?
        /// The dimensions for the metrics.
        public let dimensions: Dimensions?

        @inlinable
        public init(collections: [CurrentMetricData]? = nil, dimensions: Dimensions? = nil) {
            self.collections = collections
            self.dimensions = dimensions
        }

        private enum CodingKeys: String, CodingKey {
            case collections = "Collections"
            case dimensions = "Dimensions"
        }
    }

    public struct CurrentMetricSortCriteria: AWSEncodableShape {
        public let sortByMetric: CurrentMetricName?
        /// The way to sort.
        public let sortOrder: SortOrder?

        @inlinable
        public init(sortByMetric: CurrentMetricName? = nil, sortOrder: SortOrder? = nil) {
            self.sortByMetric = sortByMetric
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortByMetric = "SortByMetric"
            case sortOrder = "SortOrder"
        }
    }

    public struct Customer: AWSDecodableShape {
        public let capabilities: ParticipantCapabilities?
        /// Information regarding Customers device.
        public let deviceInfo: DeviceInfo?

        @inlinable
        public init(capabilities: ParticipantCapabilities? = nil, deviceInfo: DeviceInfo? = nil) {
            self.capabilities = capabilities
            self.deviceInfo = deviceInfo
        }

        private enum CodingKeys: String, CodingKey {
            case capabilities = "Capabilities"
            case deviceInfo = "DeviceInfo"
        }
    }

    public struct CustomerQualityMetrics: AWSDecodableShape {
        /// Information about the audio quality of the Customer
        public let audio: AudioQualityMetricsInfo?

        @inlinable
        public init(audio: AudioQualityMetricsInfo? = nil) {
            self.audio = audio
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
        }
    }

    public struct CustomerVoiceActivity: AWSDecodableShape {
        /// Timestamp that measures the end of the customer greeting from an outbound voice call.
        public let greetingEndTimestamp: Date?
        /// Timestamp that measures the beginning of the customer greeting from an outbound voice call.
        public let greetingStartTimestamp: Date?

        @inlinable
        public init(greetingEndTimestamp: Date? = nil, greetingStartTimestamp: Date? = nil) {
            self.greetingEndTimestamp = greetingEndTimestamp
            self.greetingStartTimestamp = greetingStartTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case greetingEndTimestamp = "GreetingEndTimestamp"
            case greetingStartTimestamp = "GreetingStartTimestamp"
        }
    }

    public struct DateCondition: AWSEncodableShape {
        /// An object to specify the hours of operation override date condition comparisonType.
        public let comparisonType: DateComparisonType?
        /// An object to specify the hours of operation override date field.
        public let fieldName: String?
        /// An object to specify the hours of operation override date value.
        public let value: String?

        @inlinable
        public init(comparisonType: DateComparisonType? = nil, fieldName: String? = nil, value: String? = nil) {
            self.comparisonType = comparisonType
            self.fieldName = fieldName
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonType = "ComparisonType"
            case fieldName = "FieldName"
            case value = "Value"
        }
    }

    public struct DateReference: AWSDecodableShape {
        /// Identifier of the date reference.
        public let name: String?
        /// A valid date.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct DeactivateEvaluationFormRequest: AWSEncodableShape {
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// A version of the evaluation form. If the version property is not provided, the latest version of the evaluation form is deactivated.
        public let evaluationFormVersion: Int
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(evaluationFormId: String, evaluationFormVersion: Int = 0, instanceId: String) {
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluationFormId, key: "EvaluationFormId")
            try container.encode(self.evaluationFormVersion, forKey: .evaluationFormVersion)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 500)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
            try self.validate(self.evaluationFormVersion, name: "evaluationFormVersion", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormVersion = "EvaluationFormVersion"
        }
    }

    public struct DeactivateEvaluationFormResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// The version of the deactivated evaluation form resource.
        public let evaluationFormVersion: Int

        @inlinable
        public init(evaluationFormArn: String, evaluationFormId: String, evaluationFormVersion: Int) {
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
            case evaluationFormVersion = "EvaluationFormVersion"
        }
    }

    public struct DefaultVocabulary: AWSDecodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String
        /// A unique name of the custom vocabulary.
        public let vocabularyName: String

        @inlinable
        public init(instanceId: String, languageCode: VocabularyLanguageCode, vocabularyId: String, vocabularyName: String) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.vocabularyId = vocabularyId
            self.vocabularyName = vocabularyName
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case languageCode = "LanguageCode"
            case vocabularyId = "VocabularyId"
            case vocabularyName = "VocabularyName"
        }
    }

    public struct DeleteAttachedFileRequest: AWSEncodableShape {
        /// The resource to which the attached file is (being) uploaded to. Cases are the only current supported resource.  This value must be a valid ARN.
        public let associatedResourceArn: String
        /// The unique identifier of the attached file resource.
        public let fileId: String
        /// The unique identifier of the Connect instance.
        public let instanceId: String

        @inlinable
        public init(associatedResourceArn: String, fileId: String, instanceId: String) {
            self.associatedResourceArn = associatedResourceArn
            self.fileId = fileId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.associatedResourceArn, key: "associatedResourceArn")
            request.encodePath(self.fileId, key: "FileId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileId, name: "fileId", parent: name, max: 256)
            try self.validate(self.fileId, name: "fileId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAttachedFileResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContactEvaluationRequest: AWSEncodableShape {
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(evaluationId: String, instanceId: String) {
            self.evaluationId = evaluationId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluationId, key: "EvaluationId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, max: 500)
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContactFlowModuleRequest: AWSEncodableShape {
        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowModuleId: String, instanceId: String) {
            self.contactFlowModuleId = contactFlowModuleId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowModuleId, key: "ContactFlowModuleId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContactFlowModuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContactFlowRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowId: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContactFlowResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContactFlowVersionRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the flow version.
        public let contactFlowVersion: Int64
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowId: String, contactFlowVersion: Int64, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.contactFlowVersion = contactFlowVersion
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            request.encodePath(self.contactFlowVersion, key: "ContactFlowVersion")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowVersion, name: "contactFlowVersion", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContactFlowVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEmailAddressRequest: AWSEncodableShape {
        /// The identifier of the email address.
        public let emailAddressId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(emailAddressId: String, instanceId: String) {
            self.emailAddressId = emailAddressId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.emailAddressId, key: "EmailAddressId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.emailAddressId, name: "emailAddressId", parent: name, max: 500)
            try self.validate(self.emailAddressId, name: "emailAddressId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteEmailAddressResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteEvaluationFormRequest: AWSEncodableShape {
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormVersion: Int?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(evaluationFormId: String, evaluationFormVersion: Int? = nil, instanceId: String) {
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluationFormId, key: "EvaluationFormId")
            request.encodeQuery(self.evaluationFormVersion, key: "version")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 500)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
            try self.validate(self.evaluationFormVersion, name: "evaluationFormVersion", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteHoursOfOperationOverrideRequest: AWSEncodableShape {
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier for the hours of operation override.
        public let hoursOfOperationOverrideId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        @inlinable
        public init(hoursOfOperationId: String, hoursOfOperationOverrideId: String, instanceId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.hoursOfOperationOverrideId = hoursOfOperationOverrideId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.hoursOfOperationOverrideId, key: "HoursOfOperationOverrideId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.hoursOfOperationOverrideId, name: "hoursOfOperationOverrideId", parent: name, max: 36)
            try self.validate(self.hoursOfOperationOverrideId, name: "hoursOfOperationOverrideId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteHoursOfOperationRequest: AWSEncodableShape {
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(hoursOfOperationId: String, instanceId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInstanceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(clientToken: String? = DeleteInstanceRequest.idempotencyToken(), instanceId: String) {
            self.clientToken = clientToken
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIntegrationAssociationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String

        @inlinable
        public init(instanceId: String, integrationAssociationId: String) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.integrationAssociationId, key: "IntegrationAssociationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePredefinedAttributeRequest: AWSEncodableShape {
        ///  The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        ///  The name of the predefined attribute.
        public let name: String

        @inlinable
        public init(instanceId: String, name: String) {
            self.instanceId = instanceId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the prompt.
        public let promptId: String

        @inlinable
        public init(instanceId: String, promptId: String) {
            self.instanceId = instanceId
            self.promptId = promptId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.promptId, key: "PromptId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.promptId, name: "promptId", parent: name, max: 256)
            try self.validate(self.promptId, name: "promptId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePushNotificationRegistrationRequest: AWSEncodableShape {
        /// The identifier of the contact within the Amazon Connect instance.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the registration.
        public let registrationId: String

        @inlinable
        public init(contactId: String, instanceId: String, registrationId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.registrationId = registrationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.contactId, key: "contactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.registrationId, key: "RegistrationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 256)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePushNotificationRegistrationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteQueueRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(instanceId: String, queueId: String) {
            self.instanceId = instanceId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQuickConnectRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the quick connect.
        public let quickConnectId: String

        @inlinable
        public init(instanceId: String, quickConnectId: String) {
            self.instanceId = instanceId
            self.quickConnectId = quickConnectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.quickConnectId, key: "QuickConnectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRoutingProfileRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(instanceId: String, routingProfileId: String) {
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the rule.
        public let ruleId: String

        @inlinable
        public init(instanceId: String, ruleId: String) {
            self.instanceId = instanceId
            self.ruleId = ruleId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.ruleId, key: "RuleId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 256)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSecurityProfileRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the security profle.
        public let securityProfileId: String

        @inlinable
        public init(instanceId: String, securityProfileId: String) {
            self.instanceId = instanceId
            self.securityProfileId = securityProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.securityProfileId, key: "SecurityProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTaskTemplateRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the task template.
        public let taskTemplateId: String

        @inlinable
        public init(instanceId: String, taskTemplateId: String) {
            self.instanceId = instanceId
            self.taskTemplateId = taskTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.taskTemplateId, key: "TaskTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTaskTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrafficDistributionGroupRequest: AWSEncodableShape {
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN of the traffic distribution group.
        public let trafficDistributionGroupId: String

        @inlinable
        public init(trafficDistributionGroupId: String) {
            self.trafficDistributionGroupId = trafficDistributionGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trafficDistributionGroupId, key: "TrafficDistributionGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.trafficDistributionGroupId, name: "trafficDistributionGroupId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrafficDistributionGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUseCaseRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String
        /// The identifier for the use case.
        public let useCaseId: String

        @inlinable
        public init(instanceId: String, integrationAssociationId: String, useCaseId: String) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
            self.useCaseId = useCaseId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.integrationAssociationId, key: "IntegrationAssociationId")
            request.encodePath(self.useCaseId, key: "UseCaseId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
            try self.validate(self.useCaseId, name: "useCaseId", parent: name, max: 200)
            try self.validate(self.useCaseId, name: "useCaseId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserHierarchyGroupRequest: AWSEncodableShape {
        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(hierarchyGroupId: String, instanceId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hierarchyGroupId, key: "HierarchyGroupId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the user.
        public let userId: String

        @inlinable
        public init(instanceId: String, userId: String) {
            self.instanceId = instanceId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteViewRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the view. Both ViewArn and ViewId can be used.
        public let viewId: String

        @inlinable
        public init(instanceId: String, viewId: String) {
            self.instanceId = instanceId
            self.viewId = viewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.viewId, key: "ViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.viewId, name: "viewId", parent: name, max: 500)
            try self.validate(self.viewId, name: "viewId", parent: name, min: 1)
            try self.validate(self.viewId, name: "viewId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/$]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteViewResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteViewVersionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the view. Both ViewArn and ViewId can be used.
        public let viewId: String
        /// The version number of the view.
        public let viewVersion: Int

        @inlinable
        public init(instanceId: String, viewId: String, viewVersion: Int) {
            self.instanceId = instanceId
            self.viewId = viewId
            self.viewVersion = viewVersion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.viewId, key: "ViewId")
            request.encodePath(self.viewVersion, key: "ViewVersion")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.viewId, name: "viewId", parent: name, max: 500)
            try self.validate(self.viewId, name: "viewId", parent: name, min: 1)
            try self.validate(self.viewId, name: "viewId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/$]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteViewVersionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteVocabularyRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        @inlinable
        public init(instanceId: String, vocabularyId: String) {
            self.instanceId = instanceId
            self.vocabularyId = vocabularyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.vocabularyId, key: "VocabularyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, max: 500)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVocabularyResponse: AWSDecodableShape {
        /// The current state of the custom vocabulary.
        public let state: VocabularyState
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let vocabularyArn: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        @inlinable
        public init(state: VocabularyState, vocabularyArn: String, vocabularyId: String) {
            self.state = state
            self.vocabularyArn = vocabularyArn
            self.vocabularyId = vocabularyId
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case vocabularyArn = "VocabularyArn"
            case vocabularyId = "VocabularyId"
        }
    }

    public struct DescribeAgentStatusRequest: AWSEncodableShape {
        /// The identifier for the agent status.
        public let agentStatusId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(agentStatusId: String, instanceId: String) {
            self.agentStatusId = agentStatusId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentStatusId, key: "AgentStatusId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAgentStatusResponse: AWSDecodableShape {
        /// The agent status.
        public let agentStatus: AgentStatus?

        @inlinable
        public init(agentStatus: AgentStatus? = nil) {
            self.agentStatus = agentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatus = "AgentStatus"
        }
    }

    public struct DescribeAuthenticationProfileRequest: AWSEncodableShape {
        /// A unique identifier for the authentication profile.
        public let authenticationProfileId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(authenticationProfileId: String, instanceId: String) {
            self.authenticationProfileId = authenticationProfileId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.authenticationProfileId, key: "AuthenticationProfileId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationProfileId, name: "authenticationProfileId", parent: name, max: 100)
            try self.validate(self.authenticationProfileId, name: "authenticationProfileId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAuthenticationProfileResponse: AWSDecodableShape {
        /// The authentication profile object being described.
        public let authenticationProfile: AuthenticationProfile?

        @inlinable
        public init(authenticationProfile: AuthenticationProfile? = nil) {
            self.authenticationProfile = authenticationProfile
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationProfile = "AuthenticationProfile"
        }
    }

    public struct DescribeContactEvaluationRequest: AWSEncodableShape {
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(evaluationId: String, instanceId: String) {
            self.evaluationId = evaluationId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluationId, key: "EvaluationId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, max: 500)
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactEvaluationResponse: AWSDecodableShape {
        /// Information about the evaluation form completed for a specific contact.
        public let evaluation: Evaluation
        /// Information about the evaluation form.
        public let evaluationForm: EvaluationFormContent

        @inlinable
        public init(evaluation: Evaluation, evaluationForm: EvaluationFormContent) {
            self.evaluation = evaluation
            self.evaluationForm = evaluationForm
        }

        private enum CodingKeys: String, CodingKey {
            case evaluation = "Evaluation"
            case evaluationForm = "EvaluationForm"
        }
    }

    public struct DescribeContactFlowModuleRequest: AWSEncodableShape {
        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowModuleId: String, instanceId: String) {
            self.contactFlowModuleId = contactFlowModuleId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowModuleId, key: "ContactFlowModuleId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactFlowModuleResponse: AWSDecodableShape {
        /// Information about the flow module.
        public let contactFlowModule: ContactFlowModule?

        @inlinable
        public init(contactFlowModule: ContactFlowModule? = nil) {
            self.contactFlowModule = contactFlowModule
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowModule = "ContactFlowModule"
        }
    }

    public struct DescribeContactFlowRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowId: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactFlowResponse: AWSDecodableShape {
        /// Information about the flow.
        public let contactFlow: ContactFlow?

        @inlinable
        public init(contactFlow: ContactFlow? = nil) {
            self.contactFlow = contactFlow
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlow = "ContactFlow"
        }
    }

    public struct DescribeContactRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactId: String, instanceId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "ContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactResponse: AWSDecodableShape {
        /// Information about the contact.
        public let contact: Contact?

        @inlinable
        public init(contact: Contact? = nil) {
            self.contact = contact
        }

        private enum CodingKeys: String, CodingKey {
            case contact = "Contact"
        }
    }

    public struct DescribeEmailAddressRequest: AWSEncodableShape {
        /// The identifier of the email address.
        public let emailAddressId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(emailAddressId: String, instanceId: String) {
            self.emailAddressId = emailAddressId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.emailAddressId, key: "EmailAddressId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.emailAddressId, name: "emailAddressId", parent: name, max: 500)
            try self.validate(self.emailAddressId, name: "emailAddressId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeEmailAddressResponse: AWSDecodableShape {
        /// The email address creation timestamp in ISO 8601 Datetime.
        public let createTimestamp: String?
        /// The description of the email address.
        public let description: String?
        /// The display name of email address
        public let displayName: String?
        /// The email address with the instance, in [^\s@]+@[^\s@]+\.[^\s@]+ format.
        public let emailAddress: String?
        /// The Amazon Resource Name (ARN) of the email address.
        public let emailAddressArn: String?
        /// The identifier of the email address.
        public let emailAddressId: String?
        /// The email address last modification timestamp in ISO 8601 Datetime.
        public let modifiedTimestamp: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(createTimestamp: String? = nil, description: String? = nil, displayName: String? = nil, emailAddress: String? = nil, emailAddressArn: String? = nil, emailAddressId: String? = nil, modifiedTimestamp: String? = nil, tags: [String: String]? = nil) {
            self.createTimestamp = createTimestamp
            self.description = description
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.emailAddressArn = emailAddressArn
            self.emailAddressId = emailAddressId
            self.modifiedTimestamp = modifiedTimestamp
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createTimestamp = "CreateTimestamp"
            case description = "Description"
            case displayName = "DisplayName"
            case emailAddress = "EmailAddress"
            case emailAddressArn = "EmailAddressArn"
            case emailAddressId = "EmailAddressId"
            case modifiedTimestamp = "ModifiedTimestamp"
            case tags = "Tags"
        }
    }

    public struct DescribeEvaluationFormRequest: AWSEncodableShape {
        /// A unique identifier for the contact evaluation.
        public let evaluationFormId: String
        /// A version of the evaluation form.
        public let evaluationFormVersion: Int?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(evaluationFormId: String, evaluationFormVersion: Int? = nil, instanceId: String) {
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluationFormId, key: "EvaluationFormId")
            request.encodeQuery(self.evaluationFormVersion, key: "version")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 500)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
            try self.validate(self.evaluationFormVersion, name: "evaluationFormVersion", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeEvaluationFormResponse: AWSDecodableShape {
        /// Information about the evaluation form.
        public let evaluationForm: EvaluationForm

        @inlinable
        public init(evaluationForm: EvaluationForm) {
            self.evaluationForm = evaluationForm
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationForm = "EvaluationForm"
        }
    }

    public struct DescribeHoursOfOperationOverrideRequest: AWSEncodableShape {
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier for the hours of operation override.
        public let hoursOfOperationOverrideId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        @inlinable
        public init(hoursOfOperationId: String, hoursOfOperationOverrideId: String, instanceId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.hoursOfOperationOverrideId = hoursOfOperationOverrideId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.hoursOfOperationOverrideId, key: "HoursOfOperationOverrideId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.hoursOfOperationOverrideId, name: "hoursOfOperationOverrideId", parent: name, max: 36)
            try self.validate(self.hoursOfOperationOverrideId, name: "hoursOfOperationOverrideId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHoursOfOperationOverrideResponse: AWSDecodableShape {
        /// Information about the hours of operations override.
        public let hoursOfOperationOverride: HoursOfOperationOverride?

        @inlinable
        public init(hoursOfOperationOverride: HoursOfOperationOverride? = nil) {
            self.hoursOfOperationOverride = hoursOfOperationOverride
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationOverride = "HoursOfOperationOverride"
        }
    }

    public struct DescribeHoursOfOperationRequest: AWSEncodableShape {
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(hoursOfOperationId: String, instanceId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHoursOfOperationResponse: AWSDecodableShape {
        /// The hours of operation.
        public let hoursOfOperation: HoursOfOperation?

        @inlinable
        public init(hoursOfOperation: HoursOfOperation? = nil) {
            self.hoursOfOperation = hoursOfOperation
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperation = "HoursOfOperation"
        }
    }

    public struct DescribeInstanceAttributeRequest: AWSEncodableShape {
        /// The type of attribute.
        public let attributeType: InstanceAttributeType
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(attributeType: InstanceAttributeType, instanceId: String) {
            self.attributeType = attributeType
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attributeType, key: "AttributeType")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceAttributeResponse: AWSDecodableShape {
        /// The type of attribute.
        public let attribute: Attribute?

        @inlinable
        public init(attribute: Attribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct DescribeInstanceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceResponse: AWSDecodableShape {
        /// The name of the instance.
        public let instance: Instance?
        /// Status information about the replication process. This field is included only when you are using the ReplicateInstance API to replicate an Amazon Connect instance across Amazon Web Services Regions. For information about replicating Amazon Connect instances, see Create a replica of your existing Amazon Connect instance in the Amazon Connect Administrator Guide.
        public let replicationConfiguration: ReplicationConfiguration?

        @inlinable
        public init(instance: Instance? = nil, replicationConfiguration: ReplicationConfiguration? = nil) {
            self.instance = instance
            self.replicationConfiguration = replicationConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case instance = "Instance"
            case replicationConfiguration = "ReplicationConfiguration"
        }
    }

    public struct DescribeInstanceStorageConfigRequest: AWSEncodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType

        @inlinable
        public init(associationId: String, instanceId: String, resourceType: InstanceStorageResourceType) {
            self.associationId = associationId
            self.instanceId = instanceId
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "AssociationId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceStorageConfigResponse: AWSDecodableShape {
        /// A valid storage type.
        public let storageConfig: InstanceStorageConfig?

        @inlinable
        public init(storageConfig: InstanceStorageConfig? = nil) {
            self.storageConfig = storageConfig
        }

        private enum CodingKeys: String, CodingKey {
            case storageConfig = "StorageConfig"
        }
    }

    public struct DescribePhoneNumberRequest: AWSEncodableShape {
        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        @inlinable
        public init(phoneNumberId: String) {
            self.phoneNumberId = phoneNumberId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.phoneNumberId, key: "PhoneNumberId")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePhoneNumberResponse: AWSDecodableShape {
        /// Information about a phone number that's been claimed to your Amazon Connect instance or traffic distribution group.
        public let claimedPhoneNumberSummary: ClaimedPhoneNumberSummary?

        @inlinable
        public init(claimedPhoneNumberSummary: ClaimedPhoneNumberSummary? = nil) {
            self.claimedPhoneNumberSummary = claimedPhoneNumberSummary
        }

        private enum CodingKeys: String, CodingKey {
            case claimedPhoneNumberSummary = "ClaimedPhoneNumberSummary"
        }
    }

    public struct DescribePredefinedAttributeRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the predefined attribute.
        public let name: String

        @inlinable
        public init(instanceId: String, name: String) {
            self.instanceId = instanceId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.name, key: "Name")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePredefinedAttributeResponse: AWSDecodableShape {
        /// Information about the predefined attribute.
        public let predefinedAttribute: PredefinedAttribute?

        @inlinable
        public init(predefinedAttribute: PredefinedAttribute? = nil) {
            self.predefinedAttribute = predefinedAttribute
        }

        private enum CodingKeys: String, CodingKey {
            case predefinedAttribute = "PredefinedAttribute"
        }
    }

    public struct DescribePromptRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the prompt.
        public let promptId: String

        @inlinable
        public init(instanceId: String, promptId: String) {
            self.instanceId = instanceId
            self.promptId = promptId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.promptId, key: "PromptId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.promptId, name: "promptId", parent: name, max: 256)
            try self.validate(self.promptId, name: "promptId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePromptResponse: AWSDecodableShape {
        /// Information about the prompt.
        public let prompt: Prompt?

        @inlinable
        public init(prompt: Prompt? = nil) {
            self.prompt = prompt
        }

        private enum CodingKeys: String, CodingKey {
            case prompt = "Prompt"
        }
    }

    public struct DescribeQueueRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(instanceId: String, queueId: String) {
            self.instanceId = instanceId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeQueueResponse: AWSDecodableShape {
        /// The name of the queue.
        public let queue: Queue?

        @inlinable
        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "Queue"
        }
    }

    public struct DescribeQuickConnectRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the quick connect.
        public let quickConnectId: String

        @inlinable
        public init(instanceId: String, quickConnectId: String) {
            self.instanceId = instanceId
            self.quickConnectId = quickConnectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.quickConnectId, key: "QuickConnectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeQuickConnectResponse: AWSDecodableShape {
        /// Information about the quick connect.
        public let quickConnect: QuickConnect?

        @inlinable
        public init(quickConnect: QuickConnect? = nil) {
            self.quickConnect = quickConnect
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnect = "QuickConnect"
        }
    }

    public struct DescribeRoutingProfileRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(instanceId: String, routingProfileId: String) {
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRoutingProfileResponse: AWSDecodableShape {
        /// The routing profile.
        public let routingProfile: RoutingProfile?

        @inlinable
        public init(routingProfile: RoutingProfile? = nil) {
            self.routingProfile = routingProfile
        }

        private enum CodingKeys: String, CodingKey {
            case routingProfile = "RoutingProfile"
        }
    }

    public struct DescribeRuleRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the rule.
        public let ruleId: String

        @inlinable
        public init(instanceId: String, ruleId: String) {
            self.instanceId = instanceId
            self.ruleId = ruleId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.ruleId, key: "RuleId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 256)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRuleResponse: AWSDecodableShape {
        /// Information about the rule.
        public let rule: Rule

        @inlinable
        public init(rule: Rule) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
        }
    }

    public struct DescribeSecurityProfileRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the security profle.
        public let securityProfileId: String

        @inlinable
        public init(instanceId: String, securityProfileId: String) {
            self.instanceId = instanceId
            self.securityProfileId = securityProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.securityProfileId, key: "SecurityProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSecurityProfileResponse: AWSDecodableShape {
        /// The security profile.
        public let securityProfile: SecurityProfile?

        @inlinable
        public init(securityProfile: SecurityProfile? = nil) {
            self.securityProfile = securityProfile
        }

        private enum CodingKeys: String, CodingKey {
            case securityProfile = "SecurityProfile"
        }
    }

    public struct DescribeTrafficDistributionGroupRequest: AWSEncodableShape {
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let trafficDistributionGroupId: String

        @inlinable
        public init(trafficDistributionGroupId: String) {
            self.trafficDistributionGroupId = trafficDistributionGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.trafficDistributionGroupId, key: "TrafficDistributionGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.trafficDistributionGroupId, name: "trafficDistributionGroupId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTrafficDistributionGroupResponse: AWSDecodableShape {
        /// Information about the traffic distribution group.
        public let trafficDistributionGroup: TrafficDistributionGroup?

        @inlinable
        public init(trafficDistributionGroup: TrafficDistributionGroup? = nil) {
            self.trafficDistributionGroup = trafficDistributionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case trafficDistributionGroup = "TrafficDistributionGroup"
        }
    }

    public struct DescribeUserHierarchyGroupRequest: AWSEncodableShape {
        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(hierarchyGroupId: String, instanceId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hierarchyGroupId, key: "HierarchyGroupId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserHierarchyGroupResponse: AWSDecodableShape {
        /// Information about the hierarchy group.
        public let hierarchyGroup: HierarchyGroup?

        @inlinable
        public init(hierarchyGroup: HierarchyGroup? = nil) {
            self.hierarchyGroup = hierarchyGroup
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroup = "HierarchyGroup"
        }
    }

    public struct DescribeUserHierarchyStructureRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserHierarchyStructureResponse: AWSDecodableShape {
        /// Information about the hierarchy structure.
        public let hierarchyStructure: HierarchyStructure?

        @inlinable
        public init(hierarchyStructure: HierarchyStructure? = nil) {
            self.hierarchyStructure = hierarchyStructure
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyStructure = "HierarchyStructure"
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(instanceId: String, userId: String) {
            self.instanceId = instanceId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        /// Information about the user account and configuration settings.
        public let user: User?

        @inlinable
        public init(user: User? = nil) {
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case user = "User"
        }
    }

    public struct DescribeViewRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The ViewId of the view. This must be an ARN for Amazon Web Services managed views.
        public let viewId: String

        @inlinable
        public init(instanceId: String, viewId: String) {
            self.instanceId = instanceId
            self.viewId = viewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.viewId, key: "ViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.viewId, name: "viewId", parent: name, max: 500)
            try self.validate(self.viewId, name: "viewId", parent: name, min: 1)
            try self.validate(self.viewId, name: "viewId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/$]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeViewResponse: AWSDecodableShape {
        /// All view data is contained within the View object.
        public let view: View?

        @inlinable
        public init(view: View? = nil) {
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case view = "View"
        }
    }

    public struct DescribeVocabularyRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        @inlinable
        public init(instanceId: String, vocabularyId: String) {
            self.instanceId = instanceId
            self.vocabularyId = vocabularyId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.vocabularyId, key: "VocabularyId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, max: 500)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVocabularyResponse: AWSDecodableShape {
        /// A list of specific words that you want Contact Lens for Amazon Connect to recognize in your audio input. They are generally domain-specific words and phrases, words that Contact Lens is not recognizing, or proper nouns.
        public let vocabulary: Vocabulary

        @inlinable
        public init(vocabulary: Vocabulary) {
            self.vocabulary = vocabulary
        }

        private enum CodingKeys: String, CodingKey {
            case vocabulary = "Vocabulary"
        }
    }

    public struct DeviceInfo: AWSDecodableShape {
        /// Operating system that the participant used for the call.
        public let operatingSystem: String?
        /// Name of the platform that the participant used for the call.
        public let platformName: String?
        /// Version of the platform that the participant used for the call.
        public let platformVersion: String?

        @inlinable
        public init(operatingSystem: String? = nil, platformName: String? = nil, platformVersion: String? = nil) {
            self.operatingSystem = operatingSystem
            self.platformName = platformName
            self.platformVersion = platformVersion
        }

        private enum CodingKeys: String, CodingKey {
            case operatingSystem = "OperatingSystem"
            case platformName = "PlatformName"
            case platformVersion = "PlatformVersion"
        }
    }

    public struct Dimensions: AWSDecodableShape {
        /// The channel used for grouping and filters.
        public let channel: Channel?
        /// Information about the queue for which metrics are returned.
        public let queue: QueueReference?
        public let routingProfile: RoutingProfileReference?
        /// The expression of a step in a routing criteria.
        public let routingStepExpression: String?

        @inlinable
        public init(channel: Channel? = nil, queue: QueueReference? = nil, routingProfile: RoutingProfileReference? = nil, routingStepExpression: String? = nil) {
            self.channel = channel
            self.queue = queue
            self.routingProfile = routingProfile
            self.routingStepExpression = routingStepExpression
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case queue = "Queue"
            case routingProfile = "RoutingProfile"
            case routingStepExpression = "RoutingStepExpression"
        }
    }

    public struct DisassociateAnalyticsDataSetRequest: AWSEncodableShape {
        /// The identifier of the dataset to remove.
        public let dataSetId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the target account.  Use to associate a dataset to a different account than the one containing the Amazon Connect instance. If not specified, by default this value is the Amazon Web Services account that has the Amazon Connect instance.
        public let targetAccountId: String?

        @inlinable
        public init(dataSetId: String, instanceId: String, targetAccountId: String? = nil) {
            self.dataSetId = dataSetId
            self.instanceId = instanceId
            self.targetAccountId = targetAccountId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.dataSetId, forKey: .dataSetId)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.targetAccountId, forKey: .targetAccountId)
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetId, name: "dataSetId", parent: name, max: 255)
            try self.validate(self.dataSetId, name: "dataSetId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSetId = "DataSetId"
            case targetAccountId = "TargetAccountId"
        }
    }

    public struct DisassociateApprovedOriginRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The domain URL of the integrated application.
        public let origin: String

        @inlinable
        public init(clientToken: String? = DisassociateApprovedOriginRequest.idempotencyToken(), instanceId: String, origin: String) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.origin = origin
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.origin, key: "origin")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.origin, name: "origin", parent: name, max: 267)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateBotRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        public let lexBot: LexBot?
        /// The Amazon Lex V2 bot to disassociate from the instance.
        public let lexV2Bot: LexV2Bot?

        @inlinable
        public init(clientToken: String? = DisassociateBotRequest.idempotencyToken(), instanceId: String, lexBot: LexBot? = nil, lexV2Bot: LexV2Bot? = nil) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.lexBot, forKey: .lexBot)
            try container.encodeIfPresent(self.lexV2Bot, forKey: .lexV2Bot)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.lexBot?.validate(name: "\(name).lexBot")
            try self.lexV2Bot?.validate(name: "\(name).lexV2Bot")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case lexBot = "LexBot"
            case lexV2Bot = "LexV2Bot"
        }
    }

    public struct DisassociateFlowRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the resource.   Amazon Web Services End User Messaging SMS phone number ARN when using SMS_PHONE_NUMBER    Amazon Web Services End User Messaging Social phone number ARN when using WHATSAPP_MESSAGING_PHONE_NUMBER
        public let resourceId: String
        /// A valid resource type.
        public let resourceType: FlowAssociationResourceType

        @inlinable
        public init(instanceId: String, resourceId: String, resourceType: FlowAssociationResourceType) {
            self.instanceId = instanceId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.resourceId, key: "ResourceId")
            request.encodePath(self.resourceType, key: "ResourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateFlowResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateInstanceStorageConfigRequest: AWSEncodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType

        @inlinable
        public init(associationId: String, clientToken: String? = DisassociateInstanceStorageConfigRequest.idempotencyToken(), instanceId: String, resourceType: InstanceStorageResourceType) {
            self.associationId = associationId
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "AssociationId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateLambdaFunctionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the Lambda function being disassociated.
        public let functionArn: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance..
        public let instanceId: String

        @inlinable
        public init(clientToken: String? = DisassociateLambdaFunctionRequest.idempotencyToken(), functionArn: String, instanceId: String) {
            self.clientToken = clientToken
            self.functionArn = functionArn
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeQuery(self.functionArn, key: "functionArn")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.functionArn, name: "functionArn", parent: name, max: 140)
            try self.validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateLexBotRequest: AWSEncodableShape {
        /// The name of the Amazon Lex bot. Maximum character limit of 50.
        public let botName: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The Amazon Web Services Region in which the Amazon Lex bot has been created.
        public let lexRegion: String

        @inlinable
        public init(botName: String, clientToken: String? = DisassociateLexBotRequest.idempotencyToken(), instanceId: String, lexRegion: String) {
            self.botName = botName
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.lexRegion = lexRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.botName, key: "botName")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.lexRegion, key: "lexRegion")
        }

        public func validate(name: String) throws {
            try self.validate(self.botName, name: "botName", parent: name, max: 50)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.lexRegion, name: "lexRegion", parent: name, max: 60)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociatePhoneNumberContactFlowRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        @inlinable
        public init(instanceId: String, phoneNumberId: String) {
            self.instanceId = instanceId
            self.phoneNumberId = phoneNumberId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.instanceId, key: "instanceId")
            request.encodePath(self.phoneNumberId, key: "PhoneNumberId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateQueueQuickConnectsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String
        /// The quick connects to disassociate from the queue.
        public let quickConnectIds: [String]

        @inlinable
        public init(instanceId: String, queueId: String, quickConnectIds: [String]) {
            self.instanceId = instanceId
            self.queueId = queueId
            self.quickConnectIds = quickConnectIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.queueId, key: "QueueId")
            try container.encode(self.quickConnectIds, forKey: .quickConnectIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, max: 50)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectIds = "QuickConnectIds"
        }
    }

    public struct DisassociateRoutingProfileQueuesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The queues to disassociate from this routing profile.
        public let queueReferences: [RoutingProfileQueueReference]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(instanceId: String, queueReferences: [RoutingProfileQueueReference], routingProfileId: String) {
            self.instanceId = instanceId
            self.queueReferences = queueReferences
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.queueReferences, forKey: .queueReferences)
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queueReferences = "QueueReferences"
        }
    }

    public struct DisassociateSecurityKeyRequest: AWSEncodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(associationId: String, clientToken: String? = DisassociateSecurityKeyRequest.idempotencyToken(), instanceId: String) {
            self.associationId = associationId
            self.clientToken = clientToken
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "AssociationId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrafficDistributionGroupUserRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN of the traffic distribution group.
        public let trafficDistributionGroupId: String
        /// The identifier for the user. This can be the ID or the ARN of the user.
        public let userId: String

        @inlinable
        public init(instanceId: String, trafficDistributionGroupId: String, userId: String) {
            self.instanceId = instanceId
            self.trafficDistributionGroupId = trafficDistributionGroupId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.instanceId, key: "InstanceId")
            request.encodePath(self.trafficDistributionGroupId, key: "TrafficDistributionGroupId")
            request.encodeQuery(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.trafficDistributionGroupId, name: "trafficDistributionGroupId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateTrafficDistributionGroupUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociateUserProficienciesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String
        /// The proficiencies to disassociate from the user.
        public let userProficiencies: [UserProficiencyDisassociate]

        @inlinable
        public init(instanceId: String, userId: String, userProficiencies: [UserProficiencyDisassociate]) {
            self.instanceId = instanceId
            self.userId = userId
            self.userProficiencies = userProficiencies
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
            try container.encode(self.userProficiencies, forKey: .userProficiencies)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.userProficiencies.forEach {
                try $0.validate(name: "\(name).userProficiencies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userProficiencies = "UserProficiencies"
        }
    }

    public struct DisconnectDetails: AWSDecodableShape {
        /// Indicates the potential disconnection issues for a call. This field is not populated if the service does not detect potential issues.
        public let potentialDisconnectIssue: String?

        @inlinable
        public init(potentialDisconnectIssue: String? = nil) {
            self.potentialDisconnectIssue = potentialDisconnectIssue
        }

        private enum CodingKeys: String, CodingKey {
            case potentialDisconnectIssue = "PotentialDisconnectIssue"
        }
    }

    public struct DisconnectReason: AWSEncodableShape {
        /// A code that indicates how the contact was terminated.
        public let code: String?

        @inlinable
        public init(code: String? = nil) {
            self.code = code
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
        }
    }

    public struct DismissUserContactRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(contactId: String, instanceId: String, userId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.contactId, forKey: .contactId)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct DismissUserContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Distribution: AWSEncodableShape & AWSDecodableShape {
        /// The percentage of the traffic that is distributed, in increments of 10.
        public let percentage: Int
        /// The Amazon Web Services Region where the traffic is distributed.
        public let region: String

        @inlinable
        public init(percentage: Int, region: String) {
            self.percentage = percentage
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.percentage, name: "percentage", parent: name, max: 100)
            try self.validate(self.percentage, name: "percentage", parent: name, min: 0)
            try self.validate(self.region, name: "region", parent: name, max: 31)
            try self.validate(self.region, name: "region", parent: name, min: 8)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[a-z]{2}(-[a-z]+){1,2}(-[0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case percentage = "Percentage"
            case region = "Region"
        }
    }

    public struct DownloadUrlMetadata: AWSDecodableShape {
        /// A pre-signed URL that should be used to download the attached file.
        public let url: String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let urlExpiry: String?

        @inlinable
        public init(url: String? = nil, urlExpiry: String? = nil) {
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case url = "Url"
            case urlExpiry = "UrlExpiry"
        }
    }

    public struct EffectiveHoursOfOperations: AWSDecodableShape {
        /// The date that the hours of operation or overrides applies to.
        public let date: String?
        /// Information about the hours of operations with the effective override applied.
        public let operationalHours: [OperationalHour]?

        @inlinable
        public init(date: String? = nil, operationalHours: [OperationalHour]? = nil) {
            self.date = date
            self.operationalHours = operationalHours
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case operationalHours = "OperationalHours"
        }
    }

    public struct EmailAddressInfo: AWSEncodableShape {
        /// The display name of email address.
        public let displayName: String?
        /// The email address with the instance, in [^\s@]+@[^\s@]+\.[^\s@]+ format.
        public let emailAddress: String

        @inlinable
        public init(displayName: String? = nil, emailAddress: String) {
            self.displayName = displayName
            self.emailAddress = emailAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 255)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case emailAddress = "EmailAddress"
        }
    }

    public struct EmailAddressMetadata: AWSDecodableShape {
        /// The description of the email address.
        public let description: String?
        /// The display name of email address.
        public let displayName: String?
        /// The email address with the instance, in [^\s@]+@[^\s@]+\.[^\s@]+ format.
        public let emailAddress: String?
        /// The Amazon Resource Name (ARN) of the email address.
        public let emailAddressArn: String?
        /// The identifier of the email address.
        public let emailAddressId: String?

        @inlinable
        public init(description: String? = nil, displayName: String? = nil, emailAddress: String? = nil, emailAddressArn: String? = nil, emailAddressId: String? = nil) {
            self.description = description
            self.displayName = displayName
            self.emailAddress = emailAddress
            self.emailAddressArn = emailAddressArn
            self.emailAddressId = emailAddressId
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case emailAddress = "EmailAddress"
            case emailAddressArn = "EmailAddressArn"
            case emailAddressId = "EmailAddressId"
        }
    }

    public struct EmailAddressSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [EmailAddressSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [EmailAddressSearchCriteria]?
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [EmailAddressSearchCriteria]? = nil, orConditions: [EmailAddressSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct EmailAddressSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct EmailAttachment: AWSEncodableShape {
        /// A case-sensitive name of the attached file being uploaded.
        public let fileName: String
        /// The pre-signed URLs for the S3 bucket where the email attachment is stored.
        public let s3Url: String

        @inlinable
        public init(fileName: String, s3Url: String) {
            self.fileName = fileName
            self.s3Url = s3Url
        }

        public func validate(name: String) throws {
            try self.validate(self.fileName, name: "fileName", parent: name, max: 256)
            try self.validate(self.fileName, name: "fileName", parent: name, min: 1)
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.s3Url, name: "s3Url", parent: name, max: 2000)
            try self.validate(self.s3Url, name: "s3Url", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case fileName = "FileName"
            case s3Url = "S3Url"
        }
    }

    public struct EmailMessageReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the email message reference
        public let arn: String?
        /// The name of the email message reference
        public let name: String?

        @inlinable
        public init(arn: String? = nil, name: String? = nil) {
            self.arn = arn
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case name = "Name"
        }
    }

    public struct EmailRecipient: AWSDecodableShape {
        /// Address of the email recipient. Type: String Length Constraints: Minimum length of 1. Maximum length of 256.
        public let address: String?
        /// Display name of the email recipient. Type: String Length Constraints: Minimum length of 1. Maximum length of 256.
        public let displayName: String?

        @inlinable
        public init(address: String? = nil, displayName: String? = nil) {
            self.address = address
            self.displayName = displayName
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case displayName = "DisplayName"
        }
    }

    public struct EmailReference: AWSDecodableShape {
        /// Identifier of the email reference.
        public let name: String?
        /// A valid email address.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct EmptyFieldValue: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct EncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of encryption.
        public let encryptionType: EncryptionType
        /// The full ARN of the encryption key.   Be sure to provide the full ARN of the encryption key, not just the ID. Amazon Connect supports only KMS keys with the default key spec of  SYMMETRIC_DEFAULT .
        public let keyId: String

        @inlinable
        public init(encryptionType: EncryptionType, keyId: String) {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }

        public func validate(name: String) throws {
            try self.validate(self.keyId, name: "keyId", parent: name, max: 128)
            try self.validate(self.keyId, name: "keyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "EncryptionType"
            case keyId = "KeyId"
        }
    }

    public struct EndAssociatedTasksActionDefinition: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct Endpoint: AWSEncodableShape {
        /// Address of the endpoint.
        public let address: String?
        /// Type of the endpoint.
        public let type: EndpointType?

        @inlinable
        public init(address: String? = nil, type: EndpointType? = nil) {
            self.address = address
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.address, name: "address", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case type = "Type"
        }
    }

    public struct EndpointInfo: AWSDecodableShape {
        /// Address of the endpoint.
        public let address: String?
        /// Display name of the endpoint.
        public let displayName: String?
        /// Type of endpoint.
        public let type: EndpointType?

        @inlinable
        public init(address: String? = nil, displayName: String? = nil, type: EndpointType? = nil) {
            self.address = address
            self.displayName = displayName
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case address = "Address"
            case displayName = "DisplayName"
            case type = "Type"
        }
    }

    public struct ErrorResult: AWSDecodableShape {
        /// The error code.
        public let errorCode: String?
        /// The corresponding error message for the error code.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: String? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "ErrorCode"
            case errorMessage = "ErrorMessage"
        }
    }

    public struct Evaluation: AWSDecodableShape {
        /// A map of question identifiers to answer value.
        public let answers: [String: EvaluationAnswerOutput]
        /// The timestamp for when the evaluation was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        public let evaluationArn: String
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String
        /// The timestamp for when the evaluation was last updated.
        public let lastModifiedTime: Date
        /// Metadata about the contact evaluation.
        public let metadata: EvaluationMetadata
        /// A map of question identifiers to note value.
        public let notes: [String: EvaluationNote]
        /// A map of item (section or question) identifiers to score value.
        public let scores: [String: EvaluationScore]?
        /// The status of the contact evaluation.
        public let status: EvaluationStatus
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(answers: [String: EvaluationAnswerOutput], createdTime: Date, evaluationArn: String, evaluationId: String, lastModifiedTime: Date, metadata: EvaluationMetadata, notes: [String: EvaluationNote], scores: [String: EvaluationScore]? = nil, status: EvaluationStatus, tags: [String: String]? = nil) {
            self.answers = answers
            self.createdTime = createdTime
            self.evaluationArn = evaluationArn
            self.evaluationId = evaluationId
            self.lastModifiedTime = lastModifiedTime
            self.metadata = metadata
            self.notes = notes
            self.scores = scores
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case answers = "Answers"
            case createdTime = "CreatedTime"
            case evaluationArn = "EvaluationArn"
            case evaluationId = "EvaluationId"
            case lastModifiedTime = "LastModifiedTime"
            case metadata = "Metadata"
            case notes = "Notes"
            case scores = "Scores"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct EvaluationAnswerInput: AWSEncodableShape {
        /// The value for an answer in a contact evaluation.
        public let value: EvaluationAnswerData?

        @inlinable
        public init(value: EvaluationAnswerData? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct EvaluationAnswerOutput: AWSDecodableShape {
        /// The system suggested value for an answer in a contact evaluation.
        public let systemSuggestedValue: EvaluationAnswerData?
        /// The value for an answer in a contact evaluation.
        public let value: EvaluationAnswerData?

        @inlinable
        public init(systemSuggestedValue: EvaluationAnswerData? = nil, value: EvaluationAnswerData? = nil) {
            self.systemSuggestedValue = systemSuggestedValue
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case systemSuggestedValue = "SystemSuggestedValue"
            case value = "Value"
        }
    }

    public struct EvaluationForm: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        public let createdBy: String
        /// The timestamp for when the evaluation form was created.
        public let createdTime: Date
        /// The description of the evaluation form.
        public let description: String?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// A version of the evaluation form.
        public let evaluationFormVersion: Int
        /// Items that are part of the evaluation form.  The total number of sections and questions must not exceed 100 each.  Questions must be contained in a section.
        public let items: [EvaluationFormItem]
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        public let lastModifiedBy: String
        /// The timestamp for when the evaluation form was last updated.
        public let lastModifiedTime: Date
        /// The flag indicating whether the evaluation form is locked for changes.
        public let locked: Bool
        /// A scoring strategy of the evaluation form.
        public let scoringStrategy: EvaluationFormScoringStrategy?
        /// The status of the evaluation form.
        public let status: EvaluationFormVersionStatus
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// A title of the evaluation form.
        public let title: String

        @inlinable
        public init(createdBy: String, createdTime: Date, description: String? = nil, evaluationFormArn: String, evaluationFormId: String, evaluationFormVersion: Int, items: [EvaluationFormItem], lastModifiedBy: String, lastModifiedTime: Date, locked: Bool, scoringStrategy: EvaluationFormScoringStrategy? = nil, status: EvaluationFormVersionStatus, tags: [String: String]? = nil, title: String) {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.description = description
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.items = items
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.locked = locked
            self.scoringStrategy = scoringStrategy
            self.status = status
            self.tags = tags
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case createdTime = "CreatedTime"
            case description = "Description"
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
            case evaluationFormVersion = "EvaluationFormVersion"
            case items = "Items"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case locked = "Locked"
            case scoringStrategy = "ScoringStrategy"
            case status = "Status"
            case tags = "Tags"
            case title = "Title"
        }
    }

    public struct EvaluationFormContent: AWSDecodableShape {
        /// The description of the evaluation form.
        public let description: String?
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// A version of the evaluation form.
        public let evaluationFormVersion: Int
        /// Items that are part of the evaluation form.  The total number of sections and questions must not exceed 100 each.  Questions must be contained in a section.
        public let items: [EvaluationFormItem]
        /// A scoring strategy of the evaluation form.
        public let scoringStrategy: EvaluationFormScoringStrategy?
        /// A title of the evaluation form.
        public let title: String

        @inlinable
        public init(description: String? = nil, evaluationFormArn: String, evaluationFormId: String, evaluationFormVersion: Int, items: [EvaluationFormItem], scoringStrategy: EvaluationFormScoringStrategy? = nil, title: String) {
            self.description = description
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.items = items
            self.scoringStrategy = scoringStrategy
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
            case evaluationFormVersion = "EvaluationFormVersion"
            case items = "Items"
            case scoringStrategy = "ScoringStrategy"
            case title = "Title"
        }
    }

    public struct EvaluationFormNumericQuestionOption: AWSEncodableShape & AWSDecodableShape {
        /// The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        public let automaticFail: Bool?
        /// The maximum answer value of the range option.
        public let maxValue: Int
        /// The minimum answer value of the range option.
        public let minValue: Int
        /// The score assigned to answer values within the range option.
        public let score: Int?

        @inlinable
        public init(automaticFail: Bool? = nil, maxValue: Int, minValue: Int, score: Int? = nil) {
            self.automaticFail = automaticFail
            self.maxValue = maxValue
            self.minValue = minValue
            self.score = score
        }

        public func validate(name: String) throws {
            try self.validate(self.score, name: "score", parent: name, max: 10)
            try self.validate(self.score, name: "score", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case automaticFail = "AutomaticFail"
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case score = "Score"
        }
    }

    public struct EvaluationFormNumericQuestionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The automation properties of the numeric question.
        public let automation: EvaluationFormNumericQuestionAutomation?
        /// The maximum answer value.
        public let maxValue: Int
        /// The minimum answer value.
        public let minValue: Int
        /// The scoring options of the numeric question.
        public let options: [EvaluationFormNumericQuestionOption]?

        @inlinable
        public init(automation: EvaluationFormNumericQuestionAutomation? = nil, maxValue: Int, minValue: Int, options: [EvaluationFormNumericQuestionOption]? = nil) {
            self.automation = automation
            self.maxValue = maxValue
            self.minValue = minValue
            self.options = options
        }

        public func validate(name: String) throws {
            try self.options?.forEach {
                try $0.validate(name: "\(name).options[]")
            }
            try self.validate(self.options, name: "options", parent: name, max: 10)
            try self.validate(self.options, name: "options", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case automation = "Automation"
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case options = "Options"
        }
    }

    public struct EvaluationFormQuestion: AWSEncodableShape & AWSDecodableShape {
        /// The instructions of the section.
        public let instructions: String?
        /// The flag to enable not applicable answers to the question.
        public let notApplicableEnabled: Bool?
        /// The type of the question.
        public let questionType: EvaluationFormQuestionType
        /// The properties of the type of question. Text questions do not have to define question type properties.
        public let questionTypeProperties: EvaluationFormQuestionTypeProperties?
        /// The identifier of the question. An identifier must be unique within the evaluation form.
        public let refId: String
        /// The title of the question.
        public let title: String
        /// The scoring weight of the section.
        public let weight: Double?

        @inlinable
        public init(instructions: String? = nil, notApplicableEnabled: Bool? = nil, questionType: EvaluationFormQuestionType, questionTypeProperties: EvaluationFormQuestionTypeProperties? = nil, refId: String, title: String, weight: Double? = nil) {
            self.instructions = instructions
            self.notApplicableEnabled = notApplicableEnabled
            self.questionType = questionType
            self.questionTypeProperties = questionTypeProperties
            self.refId = refId
            self.title = title
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.instructions, name: "instructions", parent: name, max: 1024)
            try self.questionTypeProperties?.validate(name: "\(name).questionTypeProperties")
            try self.validate(self.refId, name: "refId", parent: name, max: 40)
            try self.validate(self.refId, name: "refId", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 350)
            try self.validate(self.weight, name: "weight", parent: name, max: 100.0)
            try self.validate(self.weight, name: "weight", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case instructions = "Instructions"
            case notApplicableEnabled = "NotApplicableEnabled"
            case questionType = "QuestionType"
            case questionTypeProperties = "QuestionTypeProperties"
            case refId = "RefId"
            case title = "Title"
            case weight = "Weight"
        }
    }

    public struct EvaluationFormScoringStrategy: AWSEncodableShape & AWSDecodableShape {
        /// The scoring mode of the evaluation form.
        public let mode: EvaluationFormScoringMode
        /// The scoring status of the evaluation form.
        public let status: EvaluationFormScoringStatus

        @inlinable
        public init(mode: EvaluationFormScoringMode, status: EvaluationFormScoringStatus) {
            self.mode = mode
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
            case status = "Status"
        }
    }

    public struct EvaluationFormSection: AWSEncodableShape & AWSDecodableShape {
        /// The instructions of the section.
        public let instructions: String?
        /// The items of the section.
        public let items: [EvaluationFormItem]
        /// The identifier of the section. An identifier must be unique within the evaluation form.
        public let refId: String
        /// The title of the section.
        public let title: String
        /// The scoring weight of the section.
        public let weight: Double?

        @inlinable
        public init(instructions: String? = nil, items: [EvaluationFormItem], refId: String, title: String, weight: Double? = nil) {
            self.instructions = instructions
            self.items = items
            self.refId = refId
            self.title = title
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.instructions, name: "instructions", parent: name, max: 1024)
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, max: 100)
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.refId, name: "refId", parent: name, max: 40)
            try self.validate(self.refId, name: "refId", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 128)
            try self.validate(self.weight, name: "weight", parent: name, max: 100.0)
            try self.validate(self.weight, name: "weight", parent: name, min: 0.0)
        }

        private enum CodingKeys: String, CodingKey {
            case instructions = "Instructions"
            case items = "Items"
            case refId = "RefId"
            case title = "Title"
            case weight = "Weight"
        }
    }

    public struct EvaluationFormSingleSelectQuestionAutomation: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the default answer option, when none of the automation options match the criteria.
        public let defaultOptionRefId: String?
        /// The automation options of the single select question.
        public let options: [EvaluationFormSingleSelectQuestionAutomationOption]

        @inlinable
        public init(defaultOptionRefId: String? = nil, options: [EvaluationFormSingleSelectQuestionAutomationOption]) {
            self.defaultOptionRefId = defaultOptionRefId
            self.options = options
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultOptionRefId, name: "defaultOptionRefId", parent: name, max: 40)
            try self.validate(self.defaultOptionRefId, name: "defaultOptionRefId", parent: name, min: 1)
            try self.options.forEach {
                try $0.validate(name: "\(name).options[]")
            }
            try self.validate(self.options, name: "options", parent: name, max: 20)
            try self.validate(self.options, name: "options", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultOptionRefId = "DefaultOptionRefId"
            case options = "Options"
        }
    }

    public struct EvaluationFormSingleSelectQuestionOption: AWSEncodableShape & AWSDecodableShape {
        /// The flag to mark the option as automatic fail. If an automatic fail answer is provided, the overall evaluation gets a score of 0.
        public let automaticFail: Bool?
        /// The identifier of the answer option. An identifier must be unique within the question.
        public let refId: String
        /// The score assigned to the answer option.
        public let score: Int?
        /// The title of the answer option.
        public let text: String

        @inlinable
        public init(automaticFail: Bool? = nil, refId: String, score: Int? = nil, text: String) {
            self.automaticFail = automaticFail
            self.refId = refId
            self.score = score
            self.text = text
        }

        public func validate(name: String) throws {
            try self.validate(self.refId, name: "refId", parent: name, max: 40)
            try self.validate(self.refId, name: "refId", parent: name, min: 1)
            try self.validate(self.score, name: "score", parent: name, max: 10)
            try self.validate(self.score, name: "score", parent: name, min: 0)
            try self.validate(self.text, name: "text", parent: name, max: 128)
        }

        private enum CodingKeys: String, CodingKey {
            case automaticFail = "AutomaticFail"
            case refId = "RefId"
            case score = "Score"
            case text = "Text"
        }
    }

    public struct EvaluationFormSingleSelectQuestionProperties: AWSEncodableShape & AWSDecodableShape {
        /// The display mode of the single select question.
        public let automation: EvaluationFormSingleSelectQuestionAutomation?
        /// The display mode of the single select question.
        public let displayAs: EvaluationFormSingleSelectQuestionDisplayMode?
        /// The answer options of the single select question.
        public let options: [EvaluationFormSingleSelectQuestionOption]

        @inlinable
        public init(automation: EvaluationFormSingleSelectQuestionAutomation? = nil, displayAs: EvaluationFormSingleSelectQuestionDisplayMode? = nil, options: [EvaluationFormSingleSelectQuestionOption]) {
            self.automation = automation
            self.displayAs = displayAs
            self.options = options
        }

        public func validate(name: String) throws {
            try self.automation?.validate(name: "\(name).automation")
            try self.options.forEach {
                try $0.validate(name: "\(name).options[]")
            }
            try self.validate(self.options, name: "options", parent: name, max: 256)
            try self.validate(self.options, name: "options", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case automation = "Automation"
            case displayAs = "DisplayAs"
            case options = "Options"
        }
    }

    public struct EvaluationFormSummary: AWSDecodableShape {
        /// The version of the active evaluation form version.
        public let activeVersion: Int?
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        public let createdBy: String
        /// The timestamp for when the evaluation form was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        ///  The Amazon Resource Name (ARN) of the user who last activated the evaluation form.
        public let lastActivatedBy: String?
        /// The timestamp for when the evaluation form was last activated.
        public let lastActivatedTime: Date?
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        public let lastModifiedBy: String
        /// The timestamp for when the evaluation form was last updated.
        public let lastModifiedTime: Date
        /// The version number of the latest evaluation form version.
        public let latestVersion: Int
        /// A title of the evaluation form.
        public let title: String

        @inlinable
        public init(activeVersion: Int? = nil, createdBy: String, createdTime: Date, evaluationFormArn: String, evaluationFormId: String, lastActivatedBy: String? = nil, lastActivatedTime: Date? = nil, lastModifiedBy: String, lastModifiedTime: Date, latestVersion: Int, title: String) {
            self.activeVersion = activeVersion
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.lastActivatedBy = lastActivatedBy
            self.lastActivatedTime = lastActivatedTime
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.latestVersion = latestVersion
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case activeVersion = "ActiveVersion"
            case createdBy = "CreatedBy"
            case createdTime = "CreatedTime"
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
            case lastActivatedBy = "LastActivatedBy"
            case lastActivatedTime = "LastActivatedTime"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case latestVersion = "LatestVersion"
            case title = "Title"
        }
    }

    public struct EvaluationFormVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
        public let createdBy: String
        /// The timestamp for when the evaluation form was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) for the evaluation form resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// A version of the evaluation form.
        public let evaluationFormVersion: Int
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation form.
        public let lastModifiedBy: String
        /// The timestamp for when the evaluation form was last updated.
        public let lastModifiedTime: Date
        /// The flag indicating whether the evaluation form is locked for changes.
        public let locked: Bool
        /// The status of the evaluation form.
        public let status: EvaluationFormVersionStatus

        @inlinable
        public init(createdBy: String, createdTime: Date, evaluationFormArn: String, evaluationFormId: String, evaluationFormVersion: Int, lastModifiedBy: String, lastModifiedTime: Date, locked: Bool, status: EvaluationFormVersionStatus) {
            self.createdBy = createdBy
            self.createdTime = createdTime
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.lastModifiedBy = lastModifiedBy
            self.lastModifiedTime = lastModifiedTime
            self.locked = locked
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case createdTime = "CreatedTime"
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
            case evaluationFormVersion = "EvaluationFormVersion"
            case lastModifiedBy = "LastModifiedBy"
            case lastModifiedTime = "LastModifiedTime"
            case locked = "Locked"
            case status = "Status"
        }
    }

    public struct EvaluationMetadata: AWSDecodableShape {
        /// The identifier of the agent who performed the contact.
        public let contactAgentId: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
        public let evaluatorArn: String
        /// The overall score of the contact evaluation.
        public let score: EvaluationScore?

        @inlinable
        public init(contactAgentId: String? = nil, contactId: String, evaluatorArn: String, score: EvaluationScore? = nil) {
            self.contactAgentId = contactAgentId
            self.contactId = contactId
            self.evaluatorArn = evaluatorArn
            self.score = score
        }

        private enum CodingKeys: String, CodingKey {
            case contactAgentId = "ContactAgentId"
            case contactId = "ContactId"
            case evaluatorArn = "EvaluatorArn"
            case score = "Score"
        }
    }

    public struct EvaluationNote: AWSEncodableShape & AWSDecodableShape {
        /// The note for an item (section or question) in a contact evaluation.  Even though a note in an evaluation can have up to 3072 chars, there is also a limit on the total number of chars for all the notes in the evaluation combined. Assuming there are N questions in the evaluation being submitted, then the max char limit for all notes combined is N x 1024.
        public let value: String?

        @inlinable
        public init(value: String? = nil) {
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 3072)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct EvaluationScore: AWSDecodableShape {
        /// The flag that marks the item as automatic fail. If the item or a child item gets an automatic fail answer, this flag will be true.
        public let automaticFail: Bool?
        /// The flag to mark the item as not applicable for scoring.
        public let notApplicable: Bool?
        /// The score percentage for an item in a contact evaluation.
        public let percentage: Double?

        @inlinable
        public init(automaticFail: Bool? = nil, notApplicable: Bool? = nil, percentage: Double? = nil) {
            self.automaticFail = automaticFail
            self.notApplicable = notApplicable
            self.percentage = percentage
        }

        private enum CodingKeys: String, CodingKey {
            case automaticFail = "AutomaticFail"
            case notApplicable = "NotApplicable"
            case percentage = "Percentage"
        }
    }

    public struct EvaluationSummary: AWSDecodableShape {
        /// The timestamp for when the evaluation was created.
        public let createdTime: Date
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        public let evaluationArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// A title of the evaluation form.
        public let evaluationFormTitle: String
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String
        /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
        public let evaluatorArn: String
        /// The timestamp for when the evaluation was last updated.
        public let lastModifiedTime: Date
        /// The overall score of the contact evaluation.
        public let score: EvaluationScore?
        /// The status of the contact evaluation.
        public let status: EvaluationStatus

        @inlinable
        public init(createdTime: Date, evaluationArn: String, evaluationFormId: String, evaluationFormTitle: String, evaluationId: String, evaluatorArn: String, lastModifiedTime: Date, score: EvaluationScore? = nil, status: EvaluationStatus) {
            self.createdTime = createdTime
            self.evaluationArn = evaluationArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormTitle = evaluationFormTitle
            self.evaluationId = evaluationId
            self.evaluatorArn = evaluatorArn
            self.lastModifiedTime = lastModifiedTime
            self.score = score
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdTime = "CreatedTime"
            case evaluationArn = "EvaluationArn"
            case evaluationFormId = "EvaluationFormId"
            case evaluationFormTitle = "EvaluationFormTitle"
            case evaluationId = "EvaluationId"
            case evaluatorArn = "EvaluatorArn"
            case lastModifiedTime = "LastModifiedTime"
            case score = "Score"
            case status = "Status"
        }
    }

    public struct EventBridgeActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The name.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Expiry: AWSDecodableShape {
        /// The number of seconds to wait before expiring the routing step.
        public let durationInSeconds: Int?
        /// The timestamp indicating when the routing step expires.
        public let expiryTimestamp: Date?

        @inlinable
        public init(durationInSeconds: Int? = nil, expiryTimestamp: Date? = nil) {
            self.durationInSeconds = durationInSeconds
            self.expiryTimestamp = expiryTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case durationInSeconds = "DurationInSeconds"
            case expiryTimestamp = "ExpiryTimestamp"
        }
    }

    public struct Expression: AWSEncodableShape & AWSDecodableShape {
        /// List of routing expressions which will be AND-ed together.
        public let andExpression: [Expression]?
        /// An object to specify the predefined attribute condition.
        public let attributeCondition: AttributeCondition?
        public let notAttributeCondition: AttributeCondition?
        /// List of routing expressions which will be OR-ed together.
        public let orExpression: [Expression]?

        @inlinable
        public init(andExpression: [Expression]? = nil, attributeCondition: AttributeCondition? = nil, notAttributeCondition: AttributeCondition? = nil, orExpression: [Expression]? = nil) {
            self.andExpression = andExpression
            self.attributeCondition = attributeCondition
            self.notAttributeCondition = notAttributeCondition
            self.orExpression = orExpression
        }

        public func validate(name: String) throws {
            try self.andExpression?.forEach {
                try $0.validate(name: "\(name).andExpression[]")
            }
            try self.attributeCondition?.validate(name: "\(name).attributeCondition")
            try self.notAttributeCondition?.validate(name: "\(name).notAttributeCondition")
            try self.orExpression?.forEach {
                try $0.validate(name: "\(name).orExpression[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andExpression = "AndExpression"
            case attributeCondition = "AttributeCondition"
            case notAttributeCondition = "NotAttributeCondition"
            case orExpression = "OrExpression"
        }
    }

    public struct FailedRequest: AWSDecodableShape {
        /// Reason code for the failure.
        public let failureReasonCode: FailureReasonCode?
        /// Why the request to create a contact failed.
        public let failureReasonMessage: String?
        /// Request identifier provided in the API call in the ContactDataRequest to create a contact.
        public let requestIdentifier: String?

        @inlinable
        public init(failureReasonCode: FailureReasonCode? = nil, failureReasonMessage: String? = nil, requestIdentifier: String? = nil) {
            self.failureReasonCode = failureReasonCode
            self.failureReasonMessage = failureReasonMessage
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case failureReasonCode = "FailureReasonCode"
            case failureReasonMessage = "FailureReasonMessage"
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct FieldValue: AWSEncodableShape & AWSDecodableShape {
        /// Unique identifier of a field.
        public let id: String
        /// Union of potential field value types.
        public let value: FieldValueUnion

        @inlinable
        public init(id: String, value: FieldValueUnion) {
            self.id = id
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 500)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case value = "Value"
        }
    }

    public struct FieldValueUnion: AWSEncodableShape & AWSDecodableShape {
        /// A Boolean number value type.
        public let booleanValue: Bool?
        /// A Double number value type.
        public let doubleValue: Double?
        /// An empty value.
        public let emptyValue: EmptyFieldValue?
        /// String value type.
        public let stringValue: String?

        @inlinable
        public init(booleanValue: Bool? = nil, doubleValue: Double? = nil, emptyValue: EmptyFieldValue? = nil, stringValue: String? = nil) {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.emptyValue = emptyValue
            self.stringValue = stringValue
        }

        public func validate(name: String) throws {
            try self.validate(self.stringValue, name: "stringValue", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case booleanValue = "BooleanValue"
            case doubleValue = "DoubleValue"
            case emptyValue = "EmptyValue"
            case stringValue = "StringValue"
        }
    }

    public struct FilterV2: AWSEncodableShape {
        /// The key to use for filtering data. For example, QUEUE, ROUTING_PROFILE, AGENT, CHANNEL, AGENT_HIERARCHY_LEVEL_ONE, AGENT_HIERARCHY_LEVEL_TWO, AGENT_HIERARCHY_LEVEL_THREE, AGENT_HIERARCHY_LEVEL_FOUR, AGENT_HIERARCHY_LEVEL_FIVE. There must be at least 1 key and a maximum 5 keys.
        public let filterKey: String?
        /// The identifiers to use for filtering data. For example, if you have a filter key of QUEUE, you would add queue IDs or ARNs in FilterValues.
        public let filterValues: [String]?

        @inlinable
        public init(filterKey: String? = nil, filterValues: [String]? = nil) {
            self.filterKey = filterKey
            self.filterValues = filterValues
        }

        public func validate(name: String) throws {
            try self.validate(self.filterKey, name: "filterKey", parent: name, max: 250)
            try self.validate(self.filterKey, name: "filterKey", parent: name, min: 1)
            try self.filterValues?.forEach {
                try validate($0, name: "filterValues[]", parent: name, max: 250)
                try validate($0, name: "filterValues[]", parent: name, min: 1)
            }
            try self.validate(self.filterValues, name: "filterValues", parent: name, max: 100)
            try self.validate(self.filterValues, name: "filterValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filterKey = "FilterKey"
            case filterValues = "FilterValues"
        }
    }

    public struct Filters: AWSEncodableShape {
        /// The channel to use to filter the metrics.
        public let channels: [Channel]?
        /// The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The GetCurrentMetricsData API in particular requires a queue when you include a Filter in your request.
        public let queues: [String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public let routingProfiles: [String]?
        /// A list of expressions as a filter, in which an expression is an object of a step in a routing criteria.
        public let routingStepExpressions: [String]?

        @inlinable
        public init(channels: [Channel]? = nil, queues: [String]? = nil, routingProfiles: [String]? = nil, routingStepExpressions: [String]? = nil) {
            self.channels = channels
            self.queues = queues
            self.routingProfiles = routingProfiles
            self.routingStepExpressions = routingStepExpressions
        }

        public func validate(name: String) throws {
            try self.validate(self.channels, name: "channels", parent: name, max: 4)
            try self.validate(self.queues, name: "queues", parent: name, max: 100)
            try self.validate(self.queues, name: "queues", parent: name, min: 1)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, max: 100)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, min: 1)
            try self.routingStepExpressions?.forEach {
                try validate($0, name: "routingStepExpressions[]", parent: name, max: 3000)
                try validate($0, name: "routingStepExpressions[]", parent: name, min: 1)
            }
            try self.validate(self.routingStepExpressions, name: "routingStepExpressions", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case queues = "Queues"
            case routingProfiles = "RoutingProfiles"
            case routingStepExpressions = "RoutingStepExpressions"
        }
    }

    public struct FlowAssociationSummary: AWSDecodableShape {
        /// The identifier of the flow.
        public let flowId: String?
        /// The identifier of the resource.
        public let resourceId: String?
        /// The type of resource association.
        public let resourceType: ListFlowAssociationResourceType?

        @inlinable
        public init(flowId: String? = nil, resourceId: String? = nil, resourceType: ListFlowAssociationResourceType? = nil) {
            self.flowId = flowId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case flowId = "FlowId"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct GetAttachedFileRequest: AWSEncodableShape {
        /// The resource to which the attached file is (being) uploaded to. The supported resources are Cases and Email.  This value must be a valid ARN.
        public let associatedResourceArn: String
        /// The unique identifier of the attached file resource.
        public let fileId: String
        /// The unique identifier of the Amazon Connect instance.
        public let instanceId: String
        /// Optional override for the expiry of the pre-signed S3 URL in seconds. The default value is 300.
        public let urlExpiryInSeconds: Int?

        @inlinable
        public init(associatedResourceArn: String, fileId: String, instanceId: String, urlExpiryInSeconds: Int? = nil) {
            self.associatedResourceArn = associatedResourceArn
            self.fileId = fileId
            self.instanceId = instanceId
            self.urlExpiryInSeconds = urlExpiryInSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.associatedResourceArn, key: "associatedResourceArn")
            request.encodePath(self.fileId, key: "FileId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.urlExpiryInSeconds, key: "urlExpiryInSeconds")
        }

        public func validate(name: String) throws {
            try self.validate(self.fileId, name: "fileId", parent: name, max: 256)
            try self.validate(self.fileId, name: "fileId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.urlExpiryInSeconds, name: "urlExpiryInSeconds", parent: name, max: 300)
            try self.validate(self.urlExpiryInSeconds, name: "urlExpiryInSeconds", parent: name, min: 5)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAttachedFileResponse: AWSDecodableShape {
        /// The resource to which the attached file is (being) uploaded to. Cases are the only current supported resource.
        public let associatedResourceArn: String?
        /// Represents the identity that created the file.
        public let createdBy: CreatedByInfo?
        /// The time of Creation of the file resource as an ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2024-05-03T02:41:28.172Z.
        public let creationTime: String?
        /// URL and expiry to be used when downloading the attached file.
        public let downloadUrlMetadata: DownloadUrlMetadata?
        /// The unique identifier of the attached file resource (ARN).
        public let fileArn: String?
        /// The unique identifier of the attached file resource.
        public let fileId: String?
        /// A case-sensitive name of the attached file being uploaded.
        public let fileName: String?
        /// The size of the attached file in bytes.
        public let fileSizeInBytes: Int64
        /// The current status of the attached file.
        public let fileStatus: FileStatusType?
        /// The use case for the file.
        public let fileUseCaseType: FileUseCaseType?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(associatedResourceArn: String? = nil, createdBy: CreatedByInfo? = nil, creationTime: String? = nil, downloadUrlMetadata: DownloadUrlMetadata? = nil, fileArn: String? = nil, fileId: String? = nil, fileName: String? = nil, fileSizeInBytes: Int64, fileStatus: FileStatusType? = nil, fileUseCaseType: FileUseCaseType? = nil, tags: [String: String]? = nil) {
            self.associatedResourceArn = associatedResourceArn
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.downloadUrlMetadata = downloadUrlMetadata
            self.fileArn = fileArn
            self.fileId = fileId
            self.fileName = fileName
            self.fileSizeInBytes = fileSizeInBytes
            self.fileStatus = fileStatus
            self.fileUseCaseType = fileUseCaseType
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case associatedResourceArn = "AssociatedResourceArn"
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case downloadUrlMetadata = "DownloadUrlMetadata"
            case fileArn = "FileArn"
            case fileId = "FileId"
            case fileName = "FileName"
            case fileSizeInBytes = "FileSizeInBytes"
            case fileStatus = "FileStatus"
            case fileUseCaseType = "FileUseCaseType"
            case tags = "Tags"
        }
    }

    public struct GetContactAttributesRequest: AWSEncodableShape {
        /// The identifier of the initial contact.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        @inlinable
        public init(initialContactId: String, instanceId: String) {
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.initialContactId, key: "InitialContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContactAttributesResponse: AWSDecodableShape {
        /// Information about the attributes.
        public let attributes: [String: String]?

        @inlinable
        public init(attributes: [String: String]? = nil) {
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
        }
    }

    public struct GetCurrentMetricDataRequest: AWSEncodableShape {
        /// The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see Real-time Metrics Definitions in the Amazon Connect Administrator Guide.  AGENTS_AFTER_CONTACT_WORK  Unit: COUNT Name in real-time metrics report: ACW   AGENTS_AVAILABLE  Unit: COUNT Name in real-time metrics report: Available   AGENTS_ERROR  Unit: COUNT Name in real-time metrics report: Error   AGENTS_NON_PRODUCTIVE  Unit: COUNT Name in real-time metrics report: NPT (Non-Productive Time)   AGENTS_ON_CALL  Unit: COUNT Name in real-time metrics report: On contact   AGENTS_ON_CONTACT  Unit: COUNT Name in real-time metrics report: On contact   AGENTS_ONLINE  Unit: COUNT Name in real-time metrics report: Online   AGENTS_STAFFED  Unit: COUNT Name in real-time metrics report: Staffed   CONTACTS_IN_QUEUE  Unit: COUNT Name in real-time metrics report: In queue   CONTACTS_SCHEDULED  Unit: COUNT Name in real-time metrics report: Scheduled   OLDEST_CONTACT_AGE  Unit: SECONDS When you use groupings, Unit says SECONDS and the Value is returned in SECONDS.  When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:  { "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 } The actual OLDEST_CONTACT_AGE is 24 seconds. When the filter RoutingStepExpression is used, this metric is still calculated from enqueue time. For example, if a contact that has been queued under for 10 seconds has expired and  becomes active, then OLDEST_CONTACT_AGE for this queue will be counted starting from 10, not 0. Name in real-time metrics report: Oldest   SLOTS_ACTIVE  Unit: COUNT Name in real-time metrics report: Active   SLOTS_AVAILABLE  Unit: COUNT Name in real-time metrics report: Availability
        public let currentMetrics: [CurrentMetric]
        /// The filters to apply to returned metrics. You can filter up to the following limits:   Queues: 100   Routing profiles: 100   Channels: 3 (VOICE, CHAT, and TASK channels are supported.)   RoutingStepExpressions: 50   Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request. When using the RoutingStepExpression filter, you need to pass exactly one QueueId. The filter is also case sensitive so when using the RoutingStepExpression filter, grouping by ROUTING_STEP_EXPRESSION is required. Currently tagging is only supported on the resources that are passed in the filter.
        public let filters: Filters
        /// The grouping applied to the metrics returned. For example, when grouped by QUEUE, the metrics returned apply to each queue rather than aggregated for all queues.    If you group by CHANNEL, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.   If you group by ROUTING_PROFILE, you must include either a queue or routing profile filter. In addition, a routing profile filter is required for metrics CONTACTS_SCHEDULED, CONTACTS_IN_QUEUE, and  OLDEST_CONTACT_AGE.   If no Grouping is included in the request, a summary of metrics is returned.   When using the RoutingStepExpression filter, group by ROUTING_STEP_EXPRESSION is required.
        public let groupings: [Grouping]?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?
        /// The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on AGENTS_ONLINE, DESCENDING. The metric collection is sorted based on the input metrics. Note the following:   Sorting on SLOTS_ACTIVE and SLOTS_AVAILABLE is not supported.
        public let sortCriteria: [CurrentMetricSortCriteria]?

        @inlinable
        public init(currentMetrics: [CurrentMetric], filters: Filters, groupings: [Grouping]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [CurrentMetricSortCriteria]? = nil) {
            self.currentMetrics = currentMetrics
            self.filters = filters
            self.groupings = groupings
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.currentMetrics, forKey: .currentMetrics)
            try container.encode(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.groupings, forKey: .groupings)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.sortCriteria, forKey: .sortCriteria)
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.groupings, name: "groupings", parent: name, max: 2)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentMetrics = "CurrentMetrics"
            case filters = "Filters"
            case groupings = "Groupings"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct GetCurrentMetricDataResponse: AWSDecodableShape {
        /// The total count of the result, regardless of the current page size.
        public let approximateTotalCount: Int64?
        /// The time at which the metrics were retrieved and cached for pagination.
        public let dataSnapshotTime: Date?
        /// Information about the real-time metrics.
        public let metricResults: [CurrentMetricResult]?
        /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, dataSnapshotTime: Date? = nil, metricResults: [CurrentMetricResult]? = nil, nextToken: String? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.dataSnapshotTime = dataSnapshotTime
            self.metricResults = metricResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case dataSnapshotTime = "DataSnapshotTime"
            case metricResults = "MetricResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCurrentUserDataRequest: AWSEncodableShape {
        /// The filters to apply to returned user data. You can filter up to the following limits:   Queues: 100   Routing profiles: 100   Agents: 100   Contact states: 9   User hierarchy groups: 1   The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups.  Currently tagging is only supported on the resources that are passed in the filter.
        public let filters: UserDataFilters
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(filters: UserDataFilters, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.filters, forKey: .filters)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCurrentUserDataResponse: AWSDecodableShape {
        /// The total count of the result, regardless of the current page size.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A list of the user data that is returned.
        public let userDataList: [UserData]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, userDataList: [UserData]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.userDataList = userDataList
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case userDataList = "UserDataList"
        }
    }

    public struct GetEffectiveHoursOfOperationsRequest: AWSEncodableShape {
        /// The Date from when the hours of operation are listed.
        public let fromDate: String
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The Date until when the hours of operation are listed.
        public let toDate: String

        @inlinable
        public init(fromDate: String, hoursOfOperationId: String, instanceId: String, toDate: String) {
            self.fromDate = fromDate
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.toDate = toDate
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.fromDate, key: "fromDate")
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.toDate, key: "toDate")
        }

        public func validate(name: String) throws {
            try self.validate(self.fromDate, name: "fromDate", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.toDate, name: "toDate", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetEffectiveHoursOfOperationsResponse: AWSDecodableShape {
        /// Information about the effective hours of operations
        public let effectiveHoursOfOperationList: [EffectiveHoursOfOperations]?
        /// The time zone for the hours of operation.
        public let timeZone: String?

        @inlinable
        public init(effectiveHoursOfOperationList: [EffectiveHoursOfOperations]? = nil, timeZone: String? = nil) {
            self.effectiveHoursOfOperationList = effectiveHoursOfOperationList
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case effectiveHoursOfOperationList = "EffectiveHoursOfOperationList"
            case timeZone = "TimeZone"
        }
    }

    public struct GetFederationTokenRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFederationTokenResponse: AWSDecodableShape {
        /// The credentials to use for federation.
        public let credentials: Credentials?
        /// The URL to sign into the user's instance.
        public let signInUrl: String?
        /// The Amazon Resource Name (ARN) of the user.
        public let userArn: String?
        /// The identifier for the user. This can be the ID or the ARN of the user.
        public let userId: String?

        @inlinable
        public init(credentials: Credentials? = nil, signInUrl: String? = nil, userArn: String? = nil, userId: String? = nil) {
            self.credentials = credentials
            self.signInUrl = signInUrl
            self.userArn = userArn
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case signInUrl = "SignInUrl"
            case userArn = "UserArn"
            case userId = "UserId"
        }
    }

    public struct GetFlowAssociationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the resource.   Amazon Web Services End User Messaging SMS phone number ARN when using SMS_PHONE_NUMBER    Amazon Web Services End User Messaging Social phone number ARN when using WHATSAPP_MESSAGING_PHONE_NUMBER
        public let resourceId: String
        /// A valid resource type.
        public let resourceType: FlowAssociationResourceType

        @inlinable
        public init(instanceId: String, resourceId: String, resourceType: FlowAssociationResourceType) {
            self.instanceId = instanceId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.resourceId, key: "ResourceId")
            request.encodePath(self.resourceType, key: "ResourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFlowAssociationResponse: AWSDecodableShape {
        /// The identifier of the flow.
        public let flowId: String?
        /// The identifier of the resource.
        public let resourceId: String?
        /// A valid resource type.
        public let resourceType: FlowAssociationResourceType?

        @inlinable
        public init(flowId: String? = nil, resourceId: String? = nil, resourceType: FlowAssociationResourceType? = nil) {
            self.flowId = flowId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case flowId = "FlowId"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct GetMetricDataRequest: AWSEncodableShape {
        /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp. The time range between the start and end time must be less than 24 hours.
        public let endTime: Date
        /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported. RoutingStepExpression is not a valid filter for GetMetricData and we recommend switching to GetMetricDataV2 for more up-to-date features.  To filter by Queues, enter the queue ID/ARN, not the name of the queue.
        public let filters: Filters
        /// The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues. If no grouping is specified, a summary of metrics for all queues is returned. RoutingStepExpression is not a valid filter for GetMetricData and we recommend switching to GetMetricDataV2 for more up-to-date features.
        public let groupings: [Grouping]?
        /// The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see Historical Metrics Definitions in the Amazon Connect Administrator Guide.  This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list).    ABANDON_TIME  Unit: SECONDS Statistic: AVG  AFTER_CONTACT_WORK_TIME  Unit: SECONDS Statistic: AVG  API_CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CALLBACK_CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CONTACTS_ABANDONED  Unit: COUNT Statistic: SUM  CONTACTS_AGENT_HUNG_UP_FIRST  Unit: COUNT Statistic: SUM  CONTACTS_CONSULTED  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED_INCOMING  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED_OUTBOUND  Unit: COUNT Statistic: SUM  CONTACTS_HOLD_ABANDONS  Unit: COUNT Statistic: SUM  CONTACTS_MISSED  Unit: COUNT Statistic: SUM  CONTACTS_QUEUED  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_IN  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_IN_FROM_QUEUE  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_OUT  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_OUT_FROM_QUEUE  Unit: COUNT Statistic: SUM  HANDLE_TIME  Unit: SECONDS Statistic: AVG  HOLD_TIME  Unit: SECONDS Statistic: AVG  INTERACTION_AND_HOLD_TIME  Unit: SECONDS Statistic: AVG  INTERACTION_TIME  Unit: SECONDS Statistic: AVG  OCCUPANCY  Unit: PERCENT Statistic: AVG  QUEUE_ANSWER_TIME  Unit: SECONDS Statistic: AVG  QUEUED_TIME  Unit: SECONDS Statistic: MAX  SERVICE_LEVEL  You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: PERCENT Statistic: AVG Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than").
        public let historicalMetrics: [HistoricalMetric]
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15. The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, filters: Filters, groupings: [Grouping]? = nil, historicalMetrics: [HistoricalMetric], instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.filters = filters
            self.groupings = groupings
            self.historicalMetrics = historicalMetrics
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.endTime, forKey: .endTime)
            try container.encode(self.filters, forKey: .filters)
            try container.encodeIfPresent(self.groupings, forKey: .groupings)
            try container.encode(self.historicalMetrics, forKey: .historicalMetrics)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.startTime, forKey: .startTime)
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.groupings, name: "groupings", parent: name, max: 2)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filters = "Filters"
            case groupings = "Groupings"
            case historicalMetrics = "HistoricalMetrics"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetMetricDataResponse: AWSDecodableShape {
        /// Information about the historical metrics. If no grouping is specified, a summary of metric data is returned.
        public let metricResults: [HistoricalMetricResult]?
        /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?

        @inlinable
        public init(metricResults: [HistoricalMetricResult]? = nil, nextToken: String? = nil) {
            self.metricResults = metricResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricResults = "MetricResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetMetricDataV2Request: AWSEncodableShape {
        /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be later than the start time timestamp. It cannot be later than the current timestamp.
        public let endTime: Date
        /// The filters to apply to returned metrics. You can filter on the following resources:   Agents   Campaigns   Channels   Feature   Queues   Routing profiles   Routing step expression   User hierarchy groups   At least one filter must be passed from queues, routing profiles, agents, or user hierarchy groups. For metrics for outbound campaigns analytics, you can also use campaigns to satisfy at least one filter requirement. To filter by phone number, see Create a historical metrics report in the Amazon Connect Administrator Guide. Note the following limits:    Filter keys: A maximum of 5 filter keys are supported in a single request. Valid filter keys: AGENT | AGENT_HIERARCHY_LEVEL_ONE | AGENT_HIERARCHY_LEVEL_TWO | AGENT_HIERARCHY_LEVEL_THREE | AGENT_HIERARCHY_LEVEL_FOUR | AGENT_HIERARCHY_LEVEL_FIVE | ANSWERING_MACHINE_DETECTION_STATUS | BOT_ID | BOT_ALIAS | BOT_VERSION | BOT_LOCALE | BOT_INTENT_NAME | CAMPAIGN | CAMPAIGN_DELIVERY_EVENT_TYPE |CASE_TEMPLATE_ARN | CASE_STATUS | CHANNEL | contact/segmentAttributes/connect:Subtype | DISCONNECT_REASON | EVALUATION_FORM | EVALUATION_SECTION | EVALUATION_QUESTION | EVALUATION_SOURCE | FEATURE | FLOW_ACTION_ID | FLOW_TYPE | FLOWS_MODULE_RESOURCE_ID | FLOWS_NEXT_RESOURCE_ID | FLOWS_NEXT_RESOURCE_QUEUE_ID | FLOWS_OUTCOME_TYPE | FLOWS_RESOURCE_ID | FORM_VERSION | INITIATION_METHOD | INVOKING_RESOURCE_PUBLISHED_TIMESTAMP | INVOKING_RESOURCE_TYPE | PARENT_FLOWS_RESOURCE_ID | RESOURCE_PUBLISHED_TIMESTAMP | ROUTING_PROFILE | ROUTING_STEP_EXPRESSION | QUEUE | Q_CONNECT_ENABLED |     Filter values: A maximum of 100 filter values are supported in a single request. VOICE, CHAT, and TASK are valid filterValue for the CHANNEL filter key. They do not count towards limitation of 100 filter values. For example, a GetMetricDataV2 request can filter by 50 queues, 35 agents, and 15 routing profiles for a total of 100 filter values, along with 3 channel filters.   contact_lens_conversational_analytics is a valid filterValue for the FEATURE filter key. It is available only to contacts analyzed by Contact Lens conversational analytics.  connect:Chat, connect:SMS, connect:Telephony, and connect:WebRTC are valid filterValue examples (not exhaustive) for the contact/segmentAttributes/connect:Subtype filter key.  ROUTING_STEP_EXPRESSION is a valid filter key with a filter value up to 3000 length. This filter is case and order sensitive. JSON string fields must be sorted in ascending order and JSON array order should be kept as is.  Q_CONNECT_ENABLED. TRUE and FALSE are the only valid filterValues for the Q_CONNECT_ENABLED filter key.    TRUE includes all contacts that had Amazon Q in Connect enabled as part of the flow.   FALSE includes all contacts that did not have Amazon Q in Connect enabled as part of the flow   This filter is available only for contact record-driven metrics.   Campaign ARNs are valid filterValues for the CAMPAIGN filter key.
        public let filters: [FilterV2]
        /// The grouping applied to the metrics that are returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values that are returned apply to the metrics for each queue. They are not aggregated for all queues. If no grouping is specified, a summary of all metrics is returned. Valid grouping keys: AGENT | AGENT_HIERARCHY_LEVEL_ONE | AGENT_HIERARCHY_LEVEL_TWO | AGENT_HIERARCHY_LEVEL_THREE | AGENT_HIERARCHY_LEVEL_FOUR | AGENT_HIERARCHY_LEVEL_FIVE | ANSWERING_MACHINE_DETECTION_STATUS | BOT_ID | BOT_ALIAS | BOT_VERSION | BOT_LOCALE | BOT_INTENT_NAME | CAMPAIGN | CAMPAIGN_DELIVERY_EVENT_TYPE | CASE_TEMPLATE_ARN | CASE_STATUS | CHANNEL | contact/segmentAttributes/connect:Subtype | DISCONNECT_REASON | EVALUATION_FORM | EVALUATION_SECTION | EVALUATION_QUESTION | EVALUATION_SOURCE | FLOWS_RESOURCE_ID | FLOWS_MODULE_RESOURCE_ID | FLOW_ACTION_ID | FLOW_TYPE | FLOWS_OUTCOME_TYPE | FORM_VERSION | INITIATION_METHOD | INVOKING_RESOURCE_PUBLISHED_TIMESTAMP | INVOKING_RESOURCE_TYPE | PARENT_FLOWS_RESOURCE_ID | Q_CONNECT_ENABLED | QUEUE | RESOURCE_PUBLISHED_TIMESTAMP | ROUTING_PROFILE | ROUTING_STEP_EXPRESSION  Type: Array of strings Array Members: Maximum number of 4 items Required: No
        public let groupings: [String]?
        /// The interval period and timezone to apply to returned metrics.    IntervalPeriod: An aggregated grouping applied to request metrics. Valid IntervalPeriod values are: FIFTEEN_MIN | THIRTY_MIN | HOUR | DAY | WEEK | TOTAL.  For example, if IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime differs by 1 day, then Amazon Connect returns 48 results in the response. Each result is aggregated by the THIRTY_MIN period. By default Amazon Connect aggregates results based on the TOTAL interval period.  The following list describes restrictions on StartTime and EndTime based on which IntervalPeriod is requested.     FIFTEEN_MIN: The difference between StartTime and EndTime must be less than 3 days.    THIRTY_MIN: The difference between StartTime and EndTime must be less than 3 days.    HOUR: The difference between StartTime and EndTime must be less than 3 days.    DAY: The difference between StartTime and EndTime must be less than 35 days.    WEEK: The difference between StartTime and EndTime must be less than 35 days.    TOTAL: The difference between StartTime and EndTime must be less than 35 days.      TimeZone: The timezone applied to requested metrics.
        public let interval: IntervalDetails?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The metrics to retrieve. Specify the name, groupings, and filters for each metric. The following historical metrics are available. For a description of each metric, see Historical metrics definitions in the Amazon Connect Administrator Guide.  ABANDONMENT_RATE  Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Abandonment rate   AGENT_ADHERENT_TIME  This metric is available only in Amazon Web Services Regions where Forecasting, capacity planning, and scheduling is available. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy  UI name: Adherent time   AGENT_ANSWER_RATE  Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: Agent answer rate   AGENT_NON_ADHERENT_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: Non-adherent time   AGENT_NON_RESPONSE  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy  UI name: Agent non-response   AGENT_NON_RESPONSE_WITHOUT_CUSTOMER_ABANDONS  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy Data for this metric is available starting from October 1, 2023 0:00:00 GMT. UI name: Agent non-response without customer abandons   AGENT_OCCUPANCY  Unit: Percentage Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy  UI name: Occupancy   AGENT_SCHEDULE_ADHERENCE  This metric is available only in Amazon Web Services Regions where Forecasting, capacity planning, and scheduling is available. Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: Adherence   AGENT_SCHEDULED_TIME  This metric is available only in Amazon Web Services Regions where Forecasting, capacity planning, and scheduling is available. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: Scheduled time   AVG_ABANDON_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average queue abandon time   AVG_ACTIVE_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Average active time   AVG_AFTER_CONTACT_WORK_TIME  Unit: Seconds Valid metric filter key: INITIATION_METHOD  Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average after contact work time   Feature is a valid filter but not a valid grouping.   AVG_AGENT_CONNECTING_TIME  Unit: Seconds Valid metric filter key: INITIATION_METHOD. For now, this metric only supports the following as INITIATION_METHOD: INBOUND | OUTBOUND | CALLBACK | API  Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: Average agent API connecting time   The Negate key in metric-level filters is not applicable for this metric.   AVG_AGENT_PAUSE_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Average agent pause time   AVG_BOT_CONVERSATION_TIME  Unit: Seconds Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Bot ID, Bot alias, Bot version, Bot locale, Flows resource ID, Flows module resource ID, Flow type, Flow action ID, Invoking resource published timestamp, Initiation method, Invoking resource type, Parent flows resource ID UI name: Average bot conversation time   AVG_BOT_CONVERSATION_TURNS  Unit: Count Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Bot ID, Bot alias, Bot version, Bot locale, Flows resource ID, Flows module resource ID, Flow type, Flow action ID, Invoking resource published timestamp, Initiation method, Invoking resource type, Parent flows resource ID UI name: Average bot conversation turns   AVG_CASE_RELATED_CONTACTS  Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: Average contacts per case   AVG_CASE_RESOLUTION_TIME  Unit: Seconds Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: Average case resolution time   AVG_CONTACT_DURATION  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average contact duration   Feature is a valid filter but not a valid grouping.   AVG_CONVERSATION_DURATION  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average conversation duration   AVG_DIALS_PER_MINUTE  This metric is available only for outbound campaigns that use the agent assisted voice and automated voice delivery modes. Unit: Count Valid groupings and filters: Agent, Campaign, Queue, Routing Profile UI name: Average dials per minute   AVG_EVALUATION_SCORE  Unit: Percent Valid groupings and filters: Agent, Agent Hierarchy, Channel, Evaluation Form ID, Evaluation Section ID, Evaluation Question ID, Evaluation Source, Form Version, Queue, Routing Profile UI name: Average agent evaluation score   AVG_FLOW_TIME  Unit: Seconds Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: Average flow time   AVG_GREETING_TIME_AGENT  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average agent greeting time   AVG_HANDLE_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, RoutingStepExpression UI name: Average handle time   Feature is a valid filter but not a valid grouping.   AVG_HOLD_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average customer hold time   Feature is a valid filter but not a valid grouping.   AVG_HOLD_TIME_ALL_CONTACTS  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average customer hold time all contacts   AVG_HOLDS  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average holds   Feature is a valid filter but not a valid grouping.   AVG_INTERACTION_AND_HOLD_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average agent interaction and customer hold time   AVG_INTERACTION_TIME  Unit: Seconds Valid metric filter key: INITIATION_METHOD  Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average agent interaction time   Feature is a valid filter but not a valid grouping.   AVG_INTERRUPTIONS_AGENT  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average agent interruptions   AVG_INTERRUPTION_TIME_AGENT  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average agent interruption time   AVG_NON_TALK_TIME  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average non-talk time   AVG_QUEUE_ANSWER_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average queue answer time   Feature is a valid filter but not a valid grouping.   AVG_RESOLUTION_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average resolution time   AVG_TALK_TIME  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average talk time   AVG_TALK_TIME_AGENT  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average agent talk time   AVG_TALK_TIME_CUSTOMER  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Average customer talk time   AVG_WAIT_TIME_AFTER_CUSTOMER_CONNECTION  This metric is available only for outbound campaigns that use the agent assisted voice and automated voice delivery modes. Unit: Seconds Valid groupings and filters: Campaign UI name: Average wait time after customer connection   AVG_WEIGHTED_EVALUATION_SCORE  Unit: Percent Valid groupings and filters: Agent, Agent Hierarchy, Channel, Evaluation Form Id, Evaluation Section ID, Evaluation Question ID, Evaluation Source, Form Version, Queue, Routing Profile UI name: Average weighted agent evaluation score   BOT_CONVERSATIONS_COMPLETED  Unit: Count Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Bot ID, Bot alias, Bot version, Bot locale, Flows resource ID, Flows module resource ID, Flow type, Flow action ID, Invoking resource published timestamp, Initiation method, Invoking resource type, Parent flows resource ID UI name: Bot conversations   BOT_INTENTS_COMPLETED  Unit: Count Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Bot ID, Bot alias, Bot version, Bot locale, Bot intent name, Flows resource ID, Flows module resource ID, Flow type, Flow action ID, Invoking resource published timestamp, Initiation method, Invoking resource type, Parent flows resource ID UI name: Bot intents completed   CAMPAIGN_CONTACTS_ABANDONED_AFTER_X  This metric is available only for outbound campaigns using the agent assisted voice and automated voice delivery modes. Unit: Count Valid groupings and filters: Agent, Campaign Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter GT (for Greater than). UI name: Campaign contacts abandoned after X   CAMPAIGN_CONTACTS_ABANDONED_AFTER_X_RATE  This metric is available only for outbound campaigns using the agent assisted voice and automated voice delivery modes. Unit: Percent Valid groupings and filters: Agent, Campaign Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter GT (for Greater than). UI name: Campaign contacts abandoned after X rate   CAMPAIGN_INTERACTIONS  This metric is available only for outbound campaigns using the email delivery mode.  Unit: Count Valid metric filter key: CAMPAIGN_INTERACTION_EVENT_TYPE Valid groupings and filters: Campaign UI name: Campaign interactions   CAMPAIGN_SEND_ATTEMPTS  This metric is available only for outbound campaigns. Unit: Count Valid groupings and filters: Campaign, Channel, contact/segmentAttributes/connect:Subtype  UI name: Campaign send attempts   CASES_CREATED  Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: Cases created   CONTACTS_CREATED  Unit: Count Valid metric filter key: INITIATION_METHOD  Valid groupings and filters: Queue, Channel, Routing Profile, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contacts created   Feature is a valid filter but not a valid grouping.   CONTACTS_HANDLED  Unit: Count Valid metric filter key: INITIATION_METHOD, DISCONNECT_REASON  Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, RoutingStepExpression, Q in Connect UI name: API contacts handled   Feature is a valid filter but not a valid grouping.   CONTACTS_HANDLED_BY_CONNECTED_TO_AGENT  Unit: Count Valid metric filter key: INITIATION_METHOD  Valid groupings and filters: Queue, Channel, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contacts handled (connected to agent timestamp)   CONTACTS_HOLD_ABANDONS  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contacts hold disconnect   CONTACTS_ON_HOLD_AGENT_DISCONNECT  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Contacts hold agent disconnect   CONTACTS_ON_HOLD_CUSTOMER_DISCONNECT  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Contacts hold customer disconnect   CONTACTS_PUT_ON_HOLD  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Contacts put on hold   CONTACTS_TRANSFERRED_OUT_EXTERNAL  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Contacts transferred out external   CONTACTS_TRANSFERRED_OUT_INTERNAL  Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Contacts transferred out internal   CONTACTS_QUEUED  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contacts queued   CONTACTS_QUEUED_BY_ENQUEUE  Unit: Count Valid groupings and filters: Queue, Channel, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype UI name: Contacts queued (enqueue timestamp)   CONTACTS_REMOVED_FROM_QUEUE_IN_X  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you can use LT (for "Less than") or LTE (for "Less than equal"). UI name: Contacts removed from queue in X seconds   CONTACTS_RESOLVED_IN_X  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you can use LT (for "Less than") or LTE (for "Less than equal"). UI name: Contacts resolved in X   CONTACTS_TRANSFERRED_OUT  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contacts transferred out   Feature is a valid filter but not a valid grouping.   CONTACTS_TRANSFERRED_OUT_BY_AGENT  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contacts transferred out by agent   CONTACTS_TRANSFERRED_OUT_FROM_QUEUE  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contacts transferred out queue   CURRENT_CASES  Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: Current cases   DELIVERY_ATTEMPTS  This metric is available only for outbound campaigns. Unit: Count Valid metric filter key: ANSWERING_MACHINE_DETECTION_STATUS, CAMPAIGN_DELIVERY_EVENT_TYPE, DISCONNECT_REASON  Valid groupings and filters: Agent, Answering Machine Detection Status, Campaign, Campaign Delivery EventType, Channel, contact/segmentAttributes/connect:Subtype, Disconnect Reason, Queue, Routing Profile UI name: Delivery attempts   Campaign Delivery EventType filter and grouping are only available for SMS and Email campaign delivery modes. Agent, Queue, Routing Profile, Answering Machine Detection Status and Disconnect Reason are only available for agent assisted voice and automated voice delivery modes.    DELIVERY_ATTEMPT_DISPOSITION_RATE  This metric is available only for outbound campaigns. Dispositions for the agent assisted voice and automated voice delivery modes are only available with answering machine detection enabled. Unit: Percent Valid metric filter key: ANSWERING_MACHINE_DETECTION_STATUS, CAMPAIGN_DELIVERY_EVENT_TYPE, DISCONNECT_REASON  Valid groupings and filters: Agent, Answering Machine Detection Status, Campaign, Channel, contact/segmentAttributes/connect:Subtype, Disconnect Reason, Queue, Routing Profile UI name: Delivery attempt disposition rate   Campaign Delivery Event Type filter and grouping are only available for SMS and Email campaign delivery modes. Agent, Queue, Routing Profile, Answering Machine Detection Status and Disconnect Reason are only available for agent assisted voice and automated voice delivery modes.    EVALUATIONS_PERFORMED  Unit: Count Valid groupings and filters: Agent, Agent Hierarchy, Channel, Evaluation Form ID, Evaluation Source, Form Version, Queue, Routing Profile UI name: Evaluations performed   FLOWS_OUTCOME  Unit: Count Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: Flows outcome   FLOWS_STARTED  Unit: Count Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows resource ID, Initiation method, Resource published timestamp UI name: Flows started   HUMAN_ANSWERED_CALLS  This metric is available only for outbound campaigns. Dispositions for the agent assisted voice and automated voice delivery modes are only available with answering machine detection enabled.  Unit: Count Valid groupings and filters: Agent, Campaign UI name: Human answered   MAX_FLOW_TIME  Unit: Seconds Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: Maximum flow time   MAX_QUEUED_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Maximum queued time   MIN_FLOW_TIME  Unit: Seconds Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: Minimum flow time   PERCENT_AUTOMATIC_FAILS  Unit: Percent Valid groupings and filters: Agent, Agent Hierarchy, Channel, Evaluation Form ID, Evaluation Source, Form Version, Queue, Routing Profile UI name: Automatic fails percent   PERCENT_BOT_CONVERSATIONS_OUTCOME  Unit: Percent Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Bot ID, Bot alias, Bot version, Bot locale, Flows resource ID, Flows module resource ID, Flow type, Flow action ID, Invoking resource published timestamp, Initiation method, Invoking resource type, Parent flows resource ID UI name: Percent bot conversations outcome   PERCENT_BOT_INTENTS_OUTCOME  Unit: Percent Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Bot ID, Bot alias, Bot version, Bot locale, Bot intent name, Flows resource ID, Flows module resource ID, Flow type, Flow action ID, Invoking resource published timestamp, Initiation method, Invoking resource type, Parent flows resource ID UI name: Percent bot intents outcome   PERCENT_CASES_FIRST_CONTACT_RESOLVED  Unit: Percent Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: Cases resolved on first contact   PERCENT_CONTACTS_STEP_EXPIRED  Unit: Percent Valid groupings and filters: Queue, RoutingStepExpression UI name: This metric is available in Real-time Metrics UI but not on the Historical Metrics UI.  PERCENT_CONTACTS_STEP_JOINED  Unit: Percent Valid groupings and filters: Queue, RoutingStepExpression UI name: This metric is available in Real-time Metrics UI but not on the Historical Metrics UI.  PERCENT_FLOWS_OUTCOME  Unit: Percent Valid metric filter key: FLOWS_OUTCOME_TYPE  Valid groupings and filters: Channel, contact/segmentAttributes/connect:Subtype, Flow type, Flows module resource ID, Flows next resource ID, Flows next resource queue ID, Flows outcome type, Flows resource ID, Initiation method, Resource published timestamp UI name: Flows outcome percentage.  The FLOWS_OUTCOME_TYPE is not a valid grouping.   PERCENT_NON_TALK_TIME  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Non-talk time percent   PERCENT_TALK_TIME  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Talk time percent   PERCENT_TALK_TIME_AGENT  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Agent talk time percent   PERCENT_TALK_TIME_CUSTOMER  This metric is available only for contacts analyzed by Contact Lens conversational analytics. Unit: Percentage Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Customer talk time percent   REOPENED_CASE_ACTIONS  Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: Cases reopened   RESOLVED_CASE_ACTIONS  Unit: Count Required filter key: CASE_TEMPLATE_ARN Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS UI name: Cases resolved   SERVICE_LEVEL  You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: Percent Valid groupings and filters: Queue, Channel, Routing Profile, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you can use LT (for "Less than") or LTE (for "Less than equal"). UI name: Service level X   STEP_CONTACTS_QUEUED  Unit: Count Valid groupings and filters: Queue, RoutingStepExpression UI name: This metric is available in Real-time Metrics UI but not on the Historical Metrics UI.  SUM_AFTER_CONTACT_WORK_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: After contact work time   SUM_CONNECTING_TIME_AGENT  Unit: Seconds Valid metric filter key: INITIATION_METHOD. This metric only supports the following filter keys as INITIATION_METHOD: INBOUND | OUTBOUND | CALLBACK | API  Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: Agent API connecting time   The Negate key in metric-level filters is not applicable for this metric.   CONTACTS_ABANDONED  Unit: Count Metric filter:    Valid values: API| Incoming | Outbound | Transfer | Callback | Queue_Transfer| Disconnect    Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, RoutingStepExpression, Q in Connect UI name: Contact abandoned   SUM_CONTACTS_ABANDONED_IN_X  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you can use LT (for "Less than") or LTE (for "Less than equal"). UI name: Contacts abandoned in X seconds   SUM_CONTACTS_ANSWERED_IN_X  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you can use LT (for "Less than") or LTE (for "Less than equal"). UI name: Contacts answered in X seconds   SUM_CONTACT_FLOW_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Contact flow time   SUM_CONTACT_TIME_AGENT  Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: Agent on contact time   SUM_CONTACTS_DISCONNECTED   Valid metric filter key: DISCONNECT_REASON  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Contact disconnected   SUM_ERROR_STATUS_TIME_AGENT  Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: Error status time   SUM_HANDLE_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Contact handle time   SUM_HOLD_TIME  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Customer hold time   SUM_IDLE_TIME_AGENT  Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: Agent idle time   SUM_INTERACTION_AND_HOLD_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy, Q in Connect UI name: Agent interaction and hold time   SUM_INTERACTION_TIME  Unit: Seconds Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent Hierarchy UI name: Agent interaction time   SUM_NON_PRODUCTIVE_TIME_AGENT  Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: Non-Productive Time   SUM_ONLINE_TIME_AGENT  Unit: Seconds Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy UI name: Online time   SUM_RETRY_CALLBACK_ATTEMPTS  Unit: Count Valid groupings and filters: Queue, Channel, Routing Profile, contact/segmentAttributes/connect:Subtype, Q in Connect UI name: Callback attempts
        public let metrics: [MetricV2]
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The Amazon Resource Name (ARN) of the resource. This includes the instanceId an Amazon Connect instance.
        public let resourceArn: String
        /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be before the end time timestamp. The start and end time depends on the IntervalPeriod selected. By default the time range between start and end time is 35 days. Historical metrics are available for 3 months.
        public let startTime: Date

        @inlinable
        public init(endTime: Date, filters: [FilterV2], groupings: [String]? = nil, interval: IntervalDetails? = nil, maxResults: Int? = nil, metrics: [MetricV2], nextToken: String? = nil, resourceArn: String, startTime: Date) {
            self.endTime = endTime
            self.filters = filters
            self.groupings = groupings
            self.interval = interval
            self.maxResults = maxResults
            self.metrics = metrics
            self.nextToken = nextToken
            self.resourceArn = resourceArn
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.filters.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.filters, name: "filters", parent: name, max: 5)
            try self.validate(self.filters, name: "filters", parent: name, min: 1)
            try self.validate(self.groupings, name: "groupings", parent: name, max: 4)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.metrics.forEach {
                try $0.validate(name: "\(name).metrics[]")
            }
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filters = "Filters"
            case groupings = "Groupings"
            case interval = "Interval"
            case maxResults = "MaxResults"
            case metrics = "Metrics"
            case nextToken = "NextToken"
            case resourceArn = "ResourceArn"
            case startTime = "StartTime"
        }
    }

    public struct GetMetricDataV2Response: AWSDecodableShape {
        /// Information about the metrics requested in the API request If no grouping is specified, a summary of metric data is returned.
        public let metricResults: [MetricResultV2]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(metricResults: [MetricResultV2]? = nil, nextToken: String? = nil) {
            self.metricResults = metricResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricResults = "MetricResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetPromptFileRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A unique identifier for the prompt.
        public let promptId: String

        @inlinable
        public init(instanceId: String, promptId: String) {
            self.instanceId = instanceId
            self.promptId = promptId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.promptId, key: "PromptId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.promptId, name: "promptId", parent: name, max: 256)
            try self.validate(self.promptId, name: "promptId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPromptFileResponse: AWSDecodableShape {
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// A generated URL to the prompt that can be given to an unauthorized user so they can access the prompt in S3.
        public let promptPresignedUrl: String?

        @inlinable
        public init(lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, promptPresignedUrl: String? = nil) {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.promptPresignedUrl = promptPresignedUrl
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case promptPresignedUrl = "PromptPresignedUrl"
        }
    }

    public struct GetTaskTemplateRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The system generated version of a task template that is associated with a task, when the task is created.
        public let snapshotVersion: String?
        /// A unique identifier for the task template.
        public let taskTemplateId: String

        @inlinable
        public init(instanceId: String, snapshotVersion: String? = nil, taskTemplateId: String) {
            self.instanceId = instanceId
            self.snapshotVersion = snapshotVersion
            self.taskTemplateId = taskTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.snapshotVersion, key: "snapshotVersion")
            request.encodePath(self.taskTemplateId, key: "TaskTemplateId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTaskTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN).
        public let arn: String
        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The timestamp when the task template was created.
        public let createdTime: Date?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]?
        /// A unique identifier for the task template.
        public let id: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String?
        /// The timestamp when the task template was last modified.
        public let lastModifiedTime: Date?
        /// The name of the task template.
        public let name: String
        /// ContactFlowId for the flow that will be run if this template is used to create a self-assigned task
        public let selfAssignFlowId: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, createdTime: Date? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField]? = nil, id: String, instanceId: String? = nil, lastModifiedTime: Date? = nil, name: String, selfAssignFlowId: String? = nil, status: TaskTemplateStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.createdTime = createdTime
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.id = id
            self.instanceId = instanceId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.selfAssignFlowId = selfAssignFlowId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case createdTime = "CreatedTime"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case id = "Id"
            case instanceId = "InstanceId"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case selfAssignFlowId = "SelfAssignFlowId"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetTrafficDistributionRequest: AWSEncodableShape {
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String

        @inlinable
        public init(id: String) {
            self.id = id
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.id, key: "Id")
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTrafficDistributionResponse: AWSDecodableShape {
        /// The distribution of agents between the instance and its replica(s).
        public let agentConfig: AgentConfig?
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String?
        /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
        public let signInConfig: SignInConfig?
        /// The distribution of traffic between the instance and its replicas.
        public let telephonyConfig: TelephonyConfig?

        @inlinable
        public init(agentConfig: AgentConfig? = nil, arn: String? = nil, id: String? = nil, signInConfig: SignInConfig? = nil, telephonyConfig: TelephonyConfig? = nil) {
            self.agentConfig = agentConfig
            self.arn = arn
            self.id = id
            self.signInConfig = signInConfig
            self.telephonyConfig = telephonyConfig
        }

        private enum CodingKeys: String, CodingKey {
            case agentConfig = "AgentConfig"
            case arn = "Arn"
            case id = "Id"
            case signInConfig = "SignInConfig"
            case telephonyConfig = "TelephonyConfig"
        }
    }

    public struct HierarchyGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let arn: String?
        /// Information about the levels in the hierarchy group.
        public let hierarchyPath: HierarchyPath?
        /// The identifier of the hierarchy group.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The identifier of the level in the hierarchy group.
        public let levelId: String?
        /// The name of the hierarchy group.
        public let name: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, hierarchyPath: HierarchyPath? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, levelId: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.hierarchyPath = hierarchyPath
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.levelId = levelId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case hierarchyPath = "HierarchyPath"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case levelId = "LevelId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct HierarchyGroupCondition: AWSEncodableShape {
        /// The type of hierarchy group match.
        public let hierarchyGroupMatchType: HierarchyGroupMatchType?
        /// The value in the hierarchy group condition.
        public let value: String?

        @inlinable
        public init(hierarchyGroupMatchType: HierarchyGroupMatchType? = nil, value: String? = nil) {
            self.hierarchyGroupMatchType = hierarchyGroupMatchType
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupMatchType = "HierarchyGroupMatchType"
            case value = "Value"
        }
    }

    public struct HierarchyGroupSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let arn: String?
        /// The identifier of the hierarchy group.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the hierarchy group.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct HierarchyGroupSummaryReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the hierarchy group.
        public let arn: String?
        /// The unique identifier for the hierarchy group.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct HierarchyGroups: AWSDecodableShape {
        /// The group at level one of the agent hierarchy.
        public let level1: AgentHierarchyGroup?
        /// The group at level two of the agent hierarchy.
        public let level2: AgentHierarchyGroup?
        /// The group at level three of the agent hierarchy.
        public let level3: AgentHierarchyGroup?
        /// The group at level four of the agent hierarchy.
        public let level4: AgentHierarchyGroup?
        /// The group at level five of the agent hierarchy.
        public let level5: AgentHierarchyGroup?

        @inlinable
        public init(level1: AgentHierarchyGroup? = nil, level2: AgentHierarchyGroup? = nil, level3: AgentHierarchyGroup? = nil, level4: AgentHierarchyGroup? = nil, level5: AgentHierarchyGroup? = nil) {
            self.level1 = level1
            self.level2 = level2
            self.level3 = level3
            self.level4 = level4
            self.level5 = level5
        }

        private enum CodingKeys: String, CodingKey {
            case level1 = "Level1"
            case level2 = "Level2"
            case level3 = "Level3"
            case level4 = "Level4"
            case level5 = "Level5"
        }
    }

    public struct HierarchyLevel: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy level.
        public let arn: String?
        /// The identifier of the hierarchy level.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the hierarchy level.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct HierarchyLevelUpdate: AWSEncodableShape {
        /// The name of the user hierarchy level. Must not be more than 50 characters.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct HierarchyPath: AWSDecodableShape {
        /// Information about level five.
        public let levelFive: HierarchyGroupSummary?
        /// Information about level four.
        public let levelFour: HierarchyGroupSummary?
        /// Information about level one.
        public let levelOne: HierarchyGroupSummary?
        /// Information about level three.
        public let levelThree: HierarchyGroupSummary?
        /// Information about level two.
        public let levelTwo: HierarchyGroupSummary?

        @inlinable
        public init(levelFive: HierarchyGroupSummary? = nil, levelFour: HierarchyGroupSummary? = nil, levelOne: HierarchyGroupSummary? = nil, levelThree: HierarchyGroupSummary? = nil, levelTwo: HierarchyGroupSummary? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HierarchyPathReference: AWSDecodableShape {
        /// Information about level five.
        public let levelFive: HierarchyGroupSummaryReference?
        /// Information about level four.
        public let levelFour: HierarchyGroupSummaryReference?
        /// Information about level one.
        public let levelOne: HierarchyGroupSummaryReference?
        /// Information about level three.
        public let levelThree: HierarchyGroupSummaryReference?
        /// Information about level two.
        public let levelTwo: HierarchyGroupSummaryReference?

        @inlinable
        public init(levelFive: HierarchyGroupSummaryReference? = nil, levelFour: HierarchyGroupSummaryReference? = nil, levelOne: HierarchyGroupSummaryReference? = nil, levelThree: HierarchyGroupSummaryReference? = nil, levelTwo: HierarchyGroupSummaryReference? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HierarchyStructure: AWSDecodableShape {
        /// Information about level five.
        public let levelFive: HierarchyLevel?
        /// Information about level four.
        public let levelFour: HierarchyLevel?
        /// Information about level one.
        public let levelOne: HierarchyLevel?
        /// Information about level three.
        public let levelThree: HierarchyLevel?
        /// Information about level two.
        public let levelTwo: HierarchyLevel?

        @inlinable
        public init(levelFive: HierarchyLevel? = nil, levelFour: HierarchyLevel? = nil, levelOne: HierarchyLevel? = nil, levelThree: HierarchyLevel? = nil, levelTwo: HierarchyLevel? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HierarchyStructureUpdate: AWSEncodableShape {
        /// The update for level five.
        public let levelFive: HierarchyLevelUpdate?
        /// The update for level four.
        public let levelFour: HierarchyLevelUpdate?
        /// The update for level one.
        public let levelOne: HierarchyLevelUpdate?
        /// The update for level three.
        public let levelThree: HierarchyLevelUpdate?
        /// The update for level two.
        public let levelTwo: HierarchyLevelUpdate?

        @inlinable
        public init(levelFive: HierarchyLevelUpdate? = nil, levelFour: HierarchyLevelUpdate? = nil, levelOne: HierarchyLevelUpdate? = nil, levelThree: HierarchyLevelUpdate? = nil, levelTwo: HierarchyLevelUpdate? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HistoricalMetric: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric.
        public let name: HistoricalMetricName?
        /// The statistic for the metric.
        public let statistic: Statistic?
        /// The threshold for the metric, used with service level metrics.
        public let threshold: Threshold?
        /// The unit for the metric.
        public let unit: Unit?

        @inlinable
        public init(name: HistoricalMetricName? = nil, statistic: Statistic? = nil, threshold: Threshold? = nil, unit: Unit? = nil) {
            self.name = name
            self.statistic = statistic
            self.threshold = threshold
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case statistic = "Statistic"
            case threshold = "Threshold"
            case unit = "Unit"
        }
    }

    public struct HistoricalMetricData: AWSDecodableShape {
        /// Information about the metric.
        public let metric: HistoricalMetric?
        /// The value of the metric.
        public let value: Double?

        @inlinable
        public init(metric: HistoricalMetric? = nil, value: Double? = nil) {
            self.metric = metric
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case value = "Value"
        }
    }

    public struct HistoricalMetricResult: AWSDecodableShape {
        /// The set of metrics.
        public let collections: [HistoricalMetricData]?
        /// The dimension for the metrics.
        public let dimensions: Dimensions?

        @inlinable
        public init(collections: [HistoricalMetricData]? = nil, dimensions: Dimensions? = nil) {
            self.collections = collections
            self.dimensions = dimensions
        }

        private enum CodingKeys: String, CodingKey {
            case collections = "Collections"
            case dimensions = "Dimensions"
        }
    }

    public struct HoursOfOperation: AWSDecodableShape {
        /// Configuration information for the hours of operation.
        public let config: [HoursOfOperationConfig]?
        /// The description for the hours of operation.
        public let description: String?
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public let hoursOfOperationArn: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name for the hours of operation.
        public let name: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The time zone for the hours of operation.
        public let timeZone: String?

        @inlinable
        public init(config: [HoursOfOperationConfig]? = nil, description: String? = nil, hoursOfOperationArn: String? = nil, hoursOfOperationId: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, tags: [String: String]? = nil, timeZone: String? = nil) {
            self.config = config
            self.description = description
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.tags = tags
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case hoursOfOperationArn = "HoursOfOperationArn"
            case hoursOfOperationId = "HoursOfOperationId"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case tags = "Tags"
            case timeZone = "TimeZone"
        }
    }

    public struct HoursOfOperationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The day that the hours of operation applies to.
        public let day: HoursOfOperationDays
        /// The end time that your contact center closes.
        public let endTime: HoursOfOperationTimeSlice
        /// The start time that your contact center opens.
        public let startTime: HoursOfOperationTimeSlice

        @inlinable
        public init(day: HoursOfOperationDays, endTime: HoursOfOperationTimeSlice, startTime: HoursOfOperationTimeSlice) {
            self.day = day
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.endTime.validate(name: "\(name).endTime")
            try self.startTime.validate(name: "\(name).startTime")
        }

        private enum CodingKeys: String, CodingKey {
            case day = "Day"
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct HoursOfOperationOverride: AWSDecodableShape {
        /// Configuration information for the hours of operation override: day, start time, and end time.
        public let config: [HoursOfOperationOverrideConfig]?
        /// The description of the hours of operation override.
        public let description: String?
        /// The date from which the hours of operation override would be effective.
        public let effectiveFrom: String?
        /// The date till which the hours of operation override would be effective.
        public let effectiveTill: String?
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public let hoursOfOperationArn: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String?
        /// The identifier for the hours of operation override.
        public let hoursOfOperationOverrideId: String?
        /// The name of the hours of operation override.
        public let name: String?

        @inlinable
        public init(config: [HoursOfOperationOverrideConfig]? = nil, description: String? = nil, effectiveFrom: String? = nil, effectiveTill: String? = nil, hoursOfOperationArn: String? = nil, hoursOfOperationId: String? = nil, hoursOfOperationOverrideId: String? = nil, name: String? = nil) {
            self.config = config
            self.description = description
            self.effectiveFrom = effectiveFrom
            self.effectiveTill = effectiveTill
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
            self.hoursOfOperationOverrideId = hoursOfOperationOverrideId
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case effectiveFrom = "EffectiveFrom"
            case effectiveTill = "EffectiveTill"
            case hoursOfOperationArn = "HoursOfOperationArn"
            case hoursOfOperationId = "HoursOfOperationId"
            case hoursOfOperationOverrideId = "HoursOfOperationOverrideId"
            case name = "Name"
        }
    }

    public struct HoursOfOperationOverrideConfig: AWSEncodableShape & AWSDecodableShape {
        /// The day that the hours of operation override applies to.
        public let day: OverrideDays?
        /// The end time that your contact center closes if overrides are applied.
        public let endTime: OverrideTimeSlice?
        /// The start time when your contact center opens if overrides are applied.
        public let startTime: OverrideTimeSlice?

        @inlinable
        public init(day: OverrideDays? = nil, endTime: OverrideTimeSlice? = nil, startTime: OverrideTimeSlice? = nil) {
            self.day = day
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.endTime?.validate(name: "\(name).endTime")
            try self.startTime?.validate(name: "\(name).startTime")
        }

        private enum CodingKeys: String, CodingKey {
            case day = "Day"
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct HoursOfOperationOverrideSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [HoursOfOperationOverrideSearchCriteria]?
        /// A leaf node condition which can be used to specify a date condition.
        public let dateCondition: DateCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [HoursOfOperationOverrideSearchCriteria]?
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [HoursOfOperationOverrideSearchCriteria]? = nil, dateCondition: DateCondition? = nil, orConditions: [HoursOfOperationOverrideSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.dateCondition = dateCondition
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        public func validate(name: String) throws {
            try self.andConditions?.forEach {
                try $0.validate(name: "\(name).andConditions[]")
            }
            try self.dateCondition?.validate(name: "\(name).dateCondition")
            try self.orConditions?.forEach {
                try $0.validate(name: "\(name).orConditions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case dateCondition = "DateCondition"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct HoursOfOperationSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [HoursOfOperationSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [HoursOfOperationSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name, description, timezone, and resourceID.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [HoursOfOperationSearchCriteria]? = nil, orConditions: [HoursOfOperationSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct HoursOfOperationSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct HoursOfOperationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hours of operation.
        public let arn: String?
        /// The identifier of the hours of operation.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the hours of operation.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct HoursOfOperationTimeSlice: AWSEncodableShape & AWSDecodableShape {
        /// The hours.
        public let hours: Int
        /// The minutes.
        public let minutes: Int

        @inlinable
        public init(hours: Int, minutes: Int) {
            self.hours = hours
            self.minutes = minutes
        }

        public func validate(name: String) throws {
            try self.validate(self.hours, name: "hours", parent: name, max: 23)
            try self.validate(self.hours, name: "hours", parent: name, min: 0)
            try self.validate(self.minutes, name: "minutes", parent: name, max: 59)
            try self.validate(self.minutes, name: "minutes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case hours = "Hours"
            case minutes = "Minutes"
        }
    }

    public struct ImportPhoneNumberRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The description of the phone number.
        public let phoneNumberDescription: String?
        /// The claimed phone number ARN being imported from the external service, such as Amazon Web Services End User Messaging. If it is from Amazon Web Services End User Messaging, it looks like the ARN of the phone number to import from Amazon Web Services End User Messaging.
        public let sourcePhoneNumberArn: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = ImportPhoneNumberRequest.idempotencyToken(), instanceId: String, phoneNumberDescription: String? = nil, sourcePhoneNumberArn: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.phoneNumberDescription = phoneNumberDescription
            self.sourcePhoneNumberArn = sourcePhoneNumberArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, max: 500)
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, pattern: "^[\\W\\S_]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case instanceId = "InstanceId"
            case phoneNumberDescription = "PhoneNumberDescription"
            case sourcePhoneNumberArn = "SourcePhoneNumberArn"
            case tags = "Tags"
        }
    }

    public struct ImportPhoneNumberResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?

        @inlinable
        public init(phoneNumberArn: String? = nil, phoneNumberId: String? = nil) {
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct InboundAdditionalRecipients: AWSEncodableShape {
        /// The additional recipients information present in cc list.
        public let ccAddresses: [EmailAddressInfo]?
        /// The additional recipients information present in to list.
        public let toAddresses: [EmailAddressInfo]?

        @inlinable
        public init(ccAddresses: [EmailAddressInfo]? = nil, toAddresses: [EmailAddressInfo]? = nil) {
            self.ccAddresses = ccAddresses
            self.toAddresses = toAddresses
        }

        public func validate(name: String) throws {
            try self.ccAddresses?.forEach {
                try $0.validate(name: "\(name).ccAddresses[]")
            }
            try self.validate(self.ccAddresses, name: "ccAddresses", parent: name, max: 10)
            try self.validate(self.ccAddresses, name: "ccAddresses", parent: name, min: 1)
            try self.toAddresses?.forEach {
                try $0.validate(name: "\(name).toAddresses[]")
            }
            try self.validate(self.toAddresses, name: "toAddresses", parent: name, max: 10)
            try self.validate(self.toAddresses, name: "toAddresses", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ccAddresses = "CcAddresses"
            case toAddresses = "ToAddresses"
        }
    }

    public struct InboundEmailContent: AWSEncodableShape {
        /// The message source type, that is, RAW.
        public let messageSourceType: InboundMessageSourceType
        /// The raw email body content.
        public let rawMessage: InboundRawMessage?

        @inlinable
        public init(messageSourceType: InboundMessageSourceType, rawMessage: InboundRawMessage? = nil) {
            self.messageSourceType = messageSourceType
            self.rawMessage = rawMessage
        }

        public func validate(name: String) throws {
            try self.rawMessage?.validate(name: "\(name).rawMessage")
        }

        private enum CodingKeys: String, CodingKey {
            case messageSourceType = "MessageSourceType"
            case rawMessage = "RawMessage"
        }
    }

    public struct InboundRawMessage: AWSEncodableShape {
        /// The email message body.
        public let body: String
        /// Type of content, that is, text/plain or text/html.
        public let contentType: String
        /// Headers present in inbound email.
        public let headers: [EmailHeaderType: String]?
        /// The email subject.
        public let subject: String

        @inlinable
        public init(body: String, contentType: String, headers: [EmailHeaderType: String]? = nil, subject: String) {
            self.body = body
            self.contentType = contentType
            self.headers = headers
            self.subject = subject
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 5242880)
            try self.validate(self.body, name: "body", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 100)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.headers?.forEach {
                try validate($0.value, name: "headers[\"\($0.key)\"]", parent: name, max: 20000)
                try validate($0.value, name: "headers[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.subject, name: "subject", parent: name, max: 998)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case contentType = "ContentType"
            case headers = "Headers"
            case subject = "Subject"
        }
    }

    public struct Instance: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the instance.
        public let arn: String?
        /// When the instance was created.
        public let createdTime: Date?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let id: String?
        /// The identity management type.
        public let identityManagementType: DirectoryType?
        /// Whether inbound calls are enabled.
        public let inboundCallsEnabled: Bool?
        /// This URL allows contact center users to access the Amazon Connect admin website.
        public let instanceAccessUrl: String?
        /// The alias of instance.
        public let instanceAlias: String?
        /// The state of the instance.
        public let instanceStatus: InstanceStatus?
        /// Whether outbound calls are enabled.
        public let outboundCallsEnabled: Bool?
        /// The service role of the instance.
        public let serviceRole: String?
        /// Relevant details why the instance was not successfully created.
        public let statusReason: InstanceStatusReason?
        /// The tags of an instance.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, createdTime: Date? = nil, id: String? = nil, identityManagementType: DirectoryType? = nil, inboundCallsEnabled: Bool? = nil, instanceAccessUrl: String? = nil, instanceAlias: String? = nil, instanceStatus: InstanceStatus? = nil, outboundCallsEnabled: Bool? = nil, serviceRole: String? = nil, statusReason: InstanceStatusReason? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAccessUrl = instanceAccessUrl
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
            self.statusReason = statusReason
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case id = "Id"
            case identityManagementType = "IdentityManagementType"
            case inboundCallsEnabled = "InboundCallsEnabled"
            case instanceAccessUrl = "InstanceAccessUrl"
            case instanceAlias = "InstanceAlias"
            case instanceStatus = "InstanceStatus"
            case outboundCallsEnabled = "OutboundCallsEnabled"
            case serviceRole = "ServiceRole"
            case statusReason = "StatusReason"
            case tags = "Tags"
        }
    }

    public struct InstanceStatusReason: AWSDecodableShape {
        /// The message.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct InstanceStorageConfig: AWSEncodableShape & AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?
        /// The configuration of the Kinesis Firehose delivery stream.
        public let kinesisFirehoseConfig: KinesisFirehoseConfig?
        /// The configuration of the Kinesis data stream.
        public let kinesisStreamConfig: KinesisStreamConfig?
        /// The configuration of the Kinesis video stream.
        public let kinesisVideoStreamConfig: KinesisVideoStreamConfig?
        /// The S3 bucket configuration.
        public let s3Config: S3Config?
        /// A valid storage type.
        public let storageType: StorageType

        @inlinable
        public init(associationId: String? = nil, kinesisFirehoseConfig: KinesisFirehoseConfig? = nil, kinesisStreamConfig: KinesisStreamConfig? = nil, kinesisVideoStreamConfig: KinesisVideoStreamConfig? = nil, s3Config: S3Config? = nil, storageType: StorageType) {
            self.associationId = associationId
            self.kinesisFirehoseConfig = kinesisFirehoseConfig
            self.kinesisStreamConfig = kinesisStreamConfig
            self.kinesisVideoStreamConfig = kinesisVideoStreamConfig
            self.s3Config = s3Config
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.kinesisVideoStreamConfig?.validate(name: "\(name).kinesisVideoStreamConfig")
            try self.s3Config?.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case kinesisFirehoseConfig = "KinesisFirehoseConfig"
            case kinesisStreamConfig = "KinesisStreamConfig"
            case kinesisVideoStreamConfig = "KinesisVideoStreamConfig"
            case s3Config = "S3Config"
            case storageType = "StorageType"
        }
    }

    public struct InstanceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the instance.
        public let arn: String?
        /// When the instance was created.
        public let createdTime: Date?
        /// The identifier of the instance.
        public let id: String?
        /// The identity management type of the instance.
        public let identityManagementType: DirectoryType?
        /// Whether inbound calls are enabled.
        public let inboundCallsEnabled: Bool?
        /// This URL allows contact center users to access the Amazon Connect admin website.
        public let instanceAccessUrl: String?
        /// The alias of the instance.
        public let instanceAlias: String?
        /// The state of the instance.
        public let instanceStatus: InstanceStatus?
        /// Whether outbound calls are enabled.
        public let outboundCallsEnabled: Bool?
        /// The service role of the instance.
        public let serviceRole: String?

        @inlinable
        public init(arn: String? = nil, createdTime: Date? = nil, id: String? = nil, identityManagementType: DirectoryType? = nil, inboundCallsEnabled: Bool? = nil, instanceAccessUrl: String? = nil, instanceAlias: String? = nil, instanceStatus: InstanceStatus? = nil, outboundCallsEnabled: Bool? = nil, serviceRole: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAccessUrl = instanceAccessUrl
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case id = "Id"
            case identityManagementType = "IdentityManagementType"
            case inboundCallsEnabled = "InboundCallsEnabled"
            case instanceAccessUrl = "InstanceAccessUrl"
            case instanceAlias = "InstanceAlias"
            case instanceStatus = "InstanceStatus"
            case outboundCallsEnabled = "OutboundCallsEnabled"
            case serviceRole = "ServiceRole"
        }
    }

    public struct IntegrationAssociationSummary: AWSDecodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String?
        /// The Amazon Resource Name (ARN) for the AppIntegration.
        public let integrationArn: String?
        /// The Amazon Resource Name (ARN) for the AppIntegration association.
        public let integrationAssociationArn: String?
        /// The identifier for the AppIntegration association.
        public let integrationAssociationId: String?
        /// The integration type.
        public let integrationType: IntegrationType?
        /// The user-provided, friendly name for the external application.
        public let sourceApplicationName: String?
        /// The URL for the external application.
        public let sourceApplicationUrl: String?
        /// The name of the source.
        public let sourceType: SourceType?

        @inlinable
        public init(instanceId: String? = nil, integrationArn: String? = nil, integrationAssociationArn: String? = nil, integrationAssociationId: String? = nil, integrationType: IntegrationType? = nil, sourceApplicationName: String? = nil, sourceApplicationUrl: String? = nil, sourceType: SourceType? = nil) {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationAssociationArn = integrationAssociationArn
            self.integrationAssociationId = integrationAssociationId
            self.integrationType = integrationType
            self.sourceApplicationName = sourceApplicationName
            self.sourceApplicationUrl = sourceApplicationUrl
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case integrationArn = "IntegrationArn"
            case integrationAssociationArn = "IntegrationAssociationArn"
            case integrationAssociationId = "IntegrationAssociationId"
            case integrationType = "IntegrationType"
            case sourceApplicationName = "SourceApplicationName"
            case sourceApplicationUrl = "SourceApplicationUrl"
            case sourceType = "SourceType"
        }
    }

    public struct IntervalDetails: AWSEncodableShape {
        ///  IntervalPeriod: An aggregated grouping applied to request metrics. Valid IntervalPeriod values are: FIFTEEN_MIN | THIRTY_MIN | HOUR | DAY | WEEK | TOTAL.  For example, if IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime differs by 1 day, then Amazon Connect returns 48 results in the response. Each result is aggregated by the THIRTY_MIN period. By default Amazon Connect aggregates results based on the TOTAL interval period.  The following list describes restrictions on StartTime and EndTime based on what IntervalPeriod is requested.     FIFTEEN_MIN: The difference between StartTime and EndTime must be less than 3 days.    THIRTY_MIN: The difference between StartTime and EndTime must be less than 3 days.    HOUR: The difference between StartTime and EndTime must be less than 3 days.    DAY: The difference between StartTime and EndTime must be less than 35 days.    WEEK: The difference between StartTime and EndTime must be less than 35 days.    TOTAL: The difference between StartTime and EndTime must be less than 35 days.
        public let intervalPeriod: IntervalPeriod?
        /// The timezone applied to requested metrics.
        public let timeZone: String?

        @inlinable
        public init(intervalPeriod: IntervalPeriod? = nil, timeZone: String? = nil) {
            self.intervalPeriod = intervalPeriod
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case intervalPeriod = "IntervalPeriod"
            case timeZone = "TimeZone"
        }
    }

    public struct InvalidContactFlowException: AWSErrorShape {
        /// The problems with the flow. Please fix before trying again.
        public let problems: [ProblemDetail]?

        @inlinable
        public init(problems: [ProblemDetail]? = nil) {
            self.problems = problems
        }

        private enum CodingKeys: String, CodingKey {
            case problems = "problems"
        }
    }

    public struct InvalidContactFlowModuleException: AWSErrorShape {
        public let problems: [ProblemDetail]?

        @inlinable
        public init(problems: [ProblemDetail]? = nil) {
            self.problems = problems
        }

        private enum CodingKeys: String, CodingKey {
            case problems = "Problems"
        }
    }

    public struct InvalidRequestException: AWSErrorShape {
        /// The message about the request.
        public let message: String?
        public let reason: InvalidRequestExceptionReason?

        @inlinable
        public init(message: String? = nil, reason: InvalidRequestExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct InvisibleFieldInfo: AWSEncodableShape & AWSDecodableShape {
        /// Identifier of the invisible field.
        public let id: TaskTemplateFieldIdentifier?

        @inlinable
        public init(id: TaskTemplateFieldIdentifier? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct KinesisFirehoseConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let firehoseArn: String

        @inlinable
        public init(firehoseArn: String) {
            self.firehoseArn = firehoseArn
        }

        private enum CodingKeys: String, CodingKey {
            case firehoseArn = "FirehoseArn"
        }
    }

    public struct KinesisStreamConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data stream.
        public let streamArn: String

        @inlinable
        public init(streamArn: String) {
            self.streamArn = streamArn
        }

        private enum CodingKeys: String, CodingKey {
            case streamArn = "StreamArn"
        }
    }

    public struct KinesisVideoStreamConfig: AWSEncodableShape & AWSDecodableShape {
        /// The encryption configuration.
        public let encryptionConfig: EncryptionConfig
        /// The prefix of the video stream.
        public let prefix: String
        /// The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data.
        public let retentionPeriodHours: Int

        @inlinable
        public init(encryptionConfig: EncryptionConfig, prefix: String, retentionPeriodHours: Int) {
            self.encryptionConfig = encryptionConfig
            self.prefix = prefix
            self.retentionPeriodHours = retentionPeriodHours
        }

        public func validate(name: String) throws {
            try self.encryptionConfig.validate(name: "\(name).encryptionConfig")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.retentionPeriodHours, name: "retentionPeriodHours", parent: name, max: 87600)
            try self.validate(self.retentionPeriodHours, name: "retentionPeriodHours", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
            case prefix = "Prefix"
            case retentionPeriodHours = "RetentionPeriodHours"
        }
    }

    public struct LexBot: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Region where the Amazon Lex bot was created.
        public let lexRegion: String
        /// The name of the Amazon Lex bot.
        public let name: String

        @inlinable
        public init(lexRegion: String, name: String) {
            self.lexRegion = lexRegion
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.lexRegion, name: "lexRegion", parent: name, max: 60)
            try self.validate(self.name, name: "name", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case lexRegion = "LexRegion"
            case name = "Name"
        }
    }

    public struct LexBotConfig: AWSDecodableShape {
        public let lexBot: LexBot?
        /// Configuration information of an Amazon Lex V2 bot.
        public let lexV2Bot: LexV2Bot?

        @inlinable
        public init(lexBot: LexBot? = nil, lexV2Bot: LexV2Bot? = nil) {
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }

        private enum CodingKeys: String, CodingKey {
            case lexBot = "LexBot"
            case lexV2Bot = "LexV2Bot"
        }
    }

    public struct LexV2Bot: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.
        public let aliasArn: String?

        @inlinable
        public init(aliasArn: String? = nil) {
            self.aliasArn = aliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasArn, name: "aliasArn", parent: name, max: 100)
            try self.validate(self.aliasArn, name: "aliasArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case aliasArn = "AliasArn"
        }
    }

    public struct ListAgentStatusRequest: AWSEncodableShape {
        /// Available agent status types.
        public let agentStatusTypes: [AgentStatusType]?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(agentStatusTypes: [AgentStatusType]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentStatusTypes = agentStatusTypes
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.agentStatusTypes, key: "AgentStatusTypes")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.agentStatusTypes, name: "agentStatusTypes", parent: name, max: 3)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentStatusResponse: AWSDecodableShape {
        /// A summary of agent statuses.
        public let agentStatusSummaryList: [AgentStatusSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(agentStatusSummaryList: [AgentStatusSummary]? = nil, nextToken: String? = nil) {
            self.agentStatusSummaryList = agentStatusSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusSummaryList = "AgentStatusSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAnalyticsDataAssociationsRequest: AWSEncodableShape {
        /// The identifier of the dataset to get the association status.
        public let dataSetId: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(dataSetId: String? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.dataSetId = dataSetId
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.dataSetId, key: "DataSetId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSetId, name: "dataSetId", parent: name, max: 255)
            try self.validate(self.dataSetId, name: "dataSetId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalyticsDataAssociationsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// An array of successful results: DataSetId, TargetAccountId, ResourceShareId, ResourceShareArn. This is a paginated API, so nextToken is given if there are more results to be returned.
        public let results: [AnalyticsDataAssociationResult]?

        @inlinable
        public init(nextToken: String? = nil, results: [AnalyticsDataAssociationResult]? = nil) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListAnalyticsDataLakeDataSetsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAnalyticsDataLakeDataSetsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// An array of successful results: DataSetId, DataSetName. This is a paginated API, so nextToken is given if there are more results to be returned.
        public let results: [AnalyticsDataSetsResult]?

        @inlinable
        public init(nextToken: String? = nil, results: [AnalyticsDataSetsResult]? = nil) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListApprovedOriginsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApprovedOriginsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The approved origins.
        public let origins: [String]?

        @inlinable
        public init(nextToken: String? = nil, origins: [String]? = nil) {
            self.nextToken = nextToken
            self.origins = origins
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case origins = "Origins"
        }
    }

    public struct ListAssociatedContactsRequest: AWSEncodableShape {
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The maximum number of results to return per page. The default MaxResult size is 25. Valid Range: Minimum value of 1. Maximum value of 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactId: String, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.contactId, key: "contactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAssociatedContactsResponse: AWSDecodableShape {
        /// List of the contact summary for all the contacts in contact tree associated with unique identifier.
        public let contactSummaryList: [AssociatedContactSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactSummaryList: [AssociatedContactSummary]? = nil, nextToken: String? = nil) {
            self.contactSummaryList = contactSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactSummaryList = "ContactSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListAuthenticationProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAuthenticationProfilesResponse: AWSDecodableShape {
        /// A summary of a given authentication profile.
        public let authenticationProfileSummaryList: [AuthenticationProfileSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(authenticationProfileSummaryList: [AuthenticationProfileSummary]? = nil, nextToken: String? = nil) {
            self.authenticationProfileSummaryList = authenticationProfileSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationProfileSummaryList = "AuthenticationProfileSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListBotsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The version of Amazon Lex or Amazon Lex V2.
        public let lexVersion: LexVersion
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, lexVersion: LexVersion, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.lexVersion = lexVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.lexVersion, key: "lexVersion")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBotsResponse: AWSDecodableShape {
        /// The names and Amazon Web Services Regions of the Amazon Lex or Amazon Lex V2 bots associated with the specified instance.
        public let lexBots: [LexBotConfig]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(lexBots: [LexBotConfig]? = nil, nextToken: String? = nil) {
            self.lexBots = lexBots
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lexBots = "LexBots"
            case nextToken = "NextToken"
        }
    }

    public struct ListCondition: AWSEncodableShape {
        /// A list of Condition objects which would be applied together with an AND condition.
        public let conditions: [Condition]?
        /// The type of target list that will be used to filter the users.
        public let targetListType: TargetListType?

        @inlinable
        public init(conditions: [Condition]? = nil, targetListType: TargetListType? = nil) {
            self.conditions = conditions
            self.targetListType = targetListType
        }

        private enum CodingKeys: String, CodingKey {
            case conditions = "Conditions"
            case targetListType = "TargetListType"
        }
    }

    public struct ListContactEvaluationsRequest: AWSEncodableShape {
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.  This is not expected to be set because the value returned in the previous response is always null.
        public let nextToken: String?

        @inlinable
        public init(contactId: String, instanceId: String, nextToken: String? = nil) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.contactId, key: "contactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactEvaluationsResponse: AWSDecodableShape {
        /// Provides details about a list of contact evaluations belonging to an instance.
        public let evaluationSummaryList: [EvaluationSummary]
        /// If there are additional results, this is the token for the next set of results.  This is always returned as null in the response.
        public let nextToken: String?

        @inlinable
        public init(evaluationSummaryList: [EvaluationSummary], nextToken: String? = nil) {
            self.evaluationSummaryList = evaluationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationSummaryList = "EvaluationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListContactFlowModulesRequest: AWSEncodableShape {
        /// The state of the flow module.
        public let contactFlowModuleState: ContactFlowModuleState?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactFlowModuleState: ContactFlowModuleState? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactFlowModuleState = contactFlowModuleState
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.contactFlowModuleState, key: "state")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactFlowModulesResponse: AWSDecodableShape {
        /// Information about the flow module.
        public let contactFlowModulesSummaryList: [ContactFlowModuleSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactFlowModulesSummaryList: [ContactFlowModuleSummary]? = nil, nextToken: String? = nil) {
            self.contactFlowModulesSummaryList = contactFlowModulesSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowModulesSummaryList = "ContactFlowModulesSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListContactFlowVersionsRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactFlowId: String, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactFlowId = contactFlowId
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactFlowVersionsResponse: AWSDecodableShape {
        /// A list of flow version summaries.
        public let contactFlowVersionSummaryList: [ContactFlowVersionSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactFlowVersionSummaryList: [ContactFlowVersionSummary]? = nil, nextToken: String? = nil) {
            self.contactFlowVersionSummaryList = contactFlowVersionSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowVersionSummaryList = "ContactFlowVersionSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListContactFlowsRequest: AWSEncodableShape {
        /// The type of flow.
        public let contactFlowTypes: [ContactFlowType]?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactFlowTypes: [ContactFlowType]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactFlowTypes = contactFlowTypes
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.contactFlowTypes, key: "contactFlowTypes")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowTypes, name: "contactFlowTypes", parent: name, max: 10)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactFlowsResponse: AWSDecodableShape {
        /// Information about the flows.
        public let contactFlowSummaryList: [ContactFlowSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(contactFlowSummaryList: [ContactFlowSummary]? = nil, nextToken: String? = nil) {
            self.contactFlowSummaryList = contactFlowSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowSummaryList = "ContactFlowSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListContactReferencesRequest: AWSEncodableShape {
        /// The identifier of the initial contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.  This is not expected to be set, because the value returned in the previous response is always null.
        public let nextToken: String?
        /// The type of reference.
        public let referenceTypes: [ReferenceType]

        @inlinable
        public init(contactId: String, instanceId: String, nextToken: String? = nil, referenceTypes: [ReferenceType]) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.nextToken = nextToken
            self.referenceTypes = referenceTypes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "ContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.referenceTypes, key: "referenceTypes")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.referenceTypes, name: "referenceTypes", parent: name, max: 6)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactReferencesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.  This is always returned as null in the response.
        public let nextToken: String?
        /// Information about the flows.
        public let referenceSummaryList: [ReferenceSummary]?

        @inlinable
        public init(nextToken: String? = nil, referenceSummaryList: [ReferenceSummary]? = nil) {
            self.nextToken = nextToken
            self.referenceSummaryList = referenceSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case referenceSummaryList = "ReferenceSummaryList"
        }
    }

    public struct ListDefaultVocabulariesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, languageCode: VocabularyLanguageCode? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.languageCode, forKey: .languageCode)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "LanguageCode"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDefaultVocabulariesResponse: AWSDecodableShape {
        /// A list of default vocabularies.
        public let defaultVocabularyList: [DefaultVocabulary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(defaultVocabularyList: [DefaultVocabulary], nextToken: String? = nil) {
            self.defaultVocabularyList = defaultVocabularyList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case defaultVocabularyList = "DefaultVocabularyList"
            case nextToken = "NextToken"
        }
    }

    public struct ListEvaluationFormVersionsRequest: AWSEncodableShape {
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(evaluationFormId: String, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.evaluationFormId = evaluationFormId
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.evaluationFormId, key: "EvaluationFormId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 500)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEvaluationFormVersionsResponse: AWSDecodableShape {
        /// Provides details about a list of evaluation forms belonging to an instance.
        public let evaluationFormVersionSummaryList: [EvaluationFormVersionSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(evaluationFormVersionSummaryList: [EvaluationFormVersionSummary], nextToken: String? = nil) {
            self.evaluationFormVersionSummaryList = evaluationFormVersionSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormVersionSummaryList = "EvaluationFormVersionSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListEvaluationFormsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListEvaluationFormsResponse: AWSDecodableShape {
        /// Provides details about a list of evaluation forms belonging to an instance.
        public let evaluationFormSummaryList: [EvaluationFormSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(evaluationFormSummaryList: [EvaluationFormSummary], nextToken: String? = nil) {
            self.evaluationFormSummaryList = evaluationFormSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormSummaryList = "EvaluationFormSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListFlowAssociationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A valid resource type.
        public let resourceType: ListFlowAssociationResourceType?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, resourceType: ListFlowAssociationResourceType? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "ResourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListFlowAssociationsResponse: AWSDecodableShape {
        /// Summary of flow associations.
        public let flowAssociationSummaryList: [FlowAssociationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(flowAssociationSummaryList: [FlowAssociationSummary]? = nil, nextToken: String? = nil) {
            self.flowAssociationSummaryList = flowAssociationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case flowAssociationSummaryList = "FlowAssociationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListHoursOfOperationOverridesRequest: AWSEncodableShape {
        /// The identifier for the hours of operation
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100. Valid Range: Minimum value of 1. Maximum value of 1000.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(hoursOfOperationId: String, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHoursOfOperationOverridesResponse: AWSDecodableShape {
        /// Information about the hours of operation override.
        public let hoursOfOperationOverrideList: [HoursOfOperationOverride]?
        /// The AWS Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(hoursOfOperationOverrideList: [HoursOfOperationOverride]? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, nextToken: String? = nil) {
            self.hoursOfOperationOverrideList = hoursOfOperationOverrideList
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationOverrideList = "HoursOfOperationOverrideList"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case nextToken = "NextToken"
        }
    }

    public struct ListHoursOfOperationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHoursOfOperationsResponse: AWSDecodableShape {
        /// Information about the hours of operation.
        public let hoursOfOperationSummaryList: [HoursOfOperationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(hoursOfOperationSummaryList: [HoursOfOperationSummary]? = nil, nextToken: String? = nil) {
            self.hoursOfOperationSummaryList = hoursOfOperationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationSummaryList = "HoursOfOperationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListInstanceAttributesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 7)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstanceAttributesResponse: AWSDecodableShape {
        /// The attribute types.
        public let attributes: [Attribute]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(attributes: [Attribute]? = nil, nextToken: String? = nil) {
            self.attributes = attributes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case nextToken = "NextToken"
        }
    }

    public struct ListInstanceStorageConfigsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, resourceType: InstanceStorageResourceType) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceType, key: "resourceType")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstanceStorageConfigsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A valid storage type.
        public let storageConfigs: [InstanceStorageConfig]?

        @inlinable
        public init(nextToken: String? = nil, storageConfigs: [InstanceStorageConfig]? = nil) {
            self.nextToken = nextToken
            self.storageConfigs = storageConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case storageConfigs = "StorageConfigs"
        }
    }

    public struct ListInstancesRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstancesResponse: AWSDecodableShape {
        /// Information about the instances.
        public let instanceSummaryList: [InstanceSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceSummaryList: [InstanceSummary]? = nil, nextToken: String? = nil) {
            self.instanceSummaryList = instanceSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceSummaryList = "InstanceSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListIntegrationAssociationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The Amazon Resource Name (ARN) of the integration.
        public let integrationArn: String?
        /// The integration type.
        public let integrationType: IntegrationType?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, integrationArn: String? = nil, integrationType: IntegrationType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationType = integrationType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.integrationArn, key: "integrationArn")
            request.encodeQuery(self.integrationType, key: "integrationType")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIntegrationAssociationsResponse: AWSDecodableShape {
        /// The associations.
        public let integrationAssociationSummaryList: [IntegrationAssociationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(integrationAssociationSummaryList: [IntegrationAssociationSummary]? = nil, nextToken: String? = nil) {
            self.integrationAssociationSummaryList = integrationAssociationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case integrationAssociationSummaryList = "IntegrationAssociationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListLambdaFunctionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLambdaFunctionsResponse: AWSDecodableShape {
        /// The Lambdafunction ARNs associated with the specified instance.
        public let lambdaFunctions: [String]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(lambdaFunctions: [String]? = nil, nextToken: String? = nil) {
            self.lambdaFunctions = lambdaFunctions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctions = "LambdaFunctions"
            case nextToken = "NextToken"
        }
    }

    public struct ListLexBotsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. If no value is specified, the default is 10.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLexBotsResponse: AWSDecodableShape {
        /// The names and Amazon Web Services Regions of the Amazon Lex bots associated with the specified instance.
        public let lexBots: [LexBot]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(lexBots: [LexBot]? = nil, nextToken: String? = nil) {
            self.lexBots = lexBots
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lexBots = "LexBots"
            case nextToken = "NextToken"
        }
    }

    public struct ListPhoneNumbersRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The ISO country code.
        public let phoneNumberCountryCodes: [PhoneNumberCountryCode]?
        /// The type of phone number.  We recommend using ListPhoneNumbersV2 to return phone number types. While ListPhoneNumbers returns number types UIFN, SHARED, THIRD_PARTY_TF, and THIRD_PARTY_DID, it incorrectly lists them as TOLL_FREE or DID.
        public let phoneNumberTypes: [PhoneNumberType]?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, phoneNumberCountryCodes: [PhoneNumberCountryCode]? = nil, phoneNumberTypes: [PhoneNumberType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberCountryCodes = phoneNumberCountryCodes
            self.phoneNumberTypes = phoneNumberTypes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.phoneNumberCountryCodes, key: "phoneNumberCountryCodes")
            request.encodeQuery(self.phoneNumberTypes, key: "phoneNumberTypes")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.phoneNumberCountryCodes, name: "phoneNumberCountryCodes", parent: name, max: 10)
            try self.validate(self.phoneNumberTypes, name: "phoneNumberTypes", parent: name, max: 6)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPhoneNumbersResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the phone numbers.
        public let phoneNumberSummaryList: [PhoneNumberSummary]?

        @inlinable
        public init(nextToken: String? = nil, phoneNumberSummaryList: [PhoneNumberSummary]? = nil) {
            self.nextToken = nextToken
            self.phoneNumberSummaryList = phoneNumberSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case phoneNumberSummaryList = "PhoneNumberSummaryList"
        }
    }

    public struct ListPhoneNumbersSummary: AWSDecodableShape {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String?
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The description of the phone number.
        public let phoneNumberDescription: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?
        /// The claimed phone number ARN that was previously imported from the external service, such as Amazon Web Services End User Messaging. If it is from Amazon Web Services End User Messaging, it looks like the ARN of the phone number that was imported from Amazon Web Services End User Messaging.
        public let sourcePhoneNumberArn: String?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through.
        public let targetArn: String?

        @inlinable
        public init(instanceId: String? = nil, phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberDescription: String? = nil, phoneNumberId: String? = nil, phoneNumberType: PhoneNumberType? = nil, sourcePhoneNumberArn: String? = nil, targetArn: String? = nil) {
            self.instanceId = instanceId
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
            self.phoneNumberType = phoneNumberType
            self.sourcePhoneNumberArn = sourcePhoneNumberArn
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberDescription = "PhoneNumberDescription"
            case phoneNumberId = "PhoneNumberId"
            case phoneNumberType = "PhoneNumberType"
            case sourcePhoneNumberArn = "SourcePhoneNumberArn"
            case targetArn = "TargetArn"
        }
    }

    public struct ListPhoneNumbersV2Request: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can find the instance ID in the Amazon Resource Name (ARN) of the instance. If both TargetArn and InstanceId are not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same AWS Region as the request.
        public let instanceId: String?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The ISO country code.
        public let phoneNumberCountryCodes: [PhoneNumberCountryCode]?
        /// The prefix of the phone number. If provided, it must contain + as part of the country code.
        public let phoneNumberPrefix: String?
        /// The type of phone number.
        public let phoneNumberTypes: [PhoneNumberType]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. If both TargetArn and InstanceId input are not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.
        public let targetArn: String?

        @inlinable
        public init(instanceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, phoneNumberCountryCodes: [PhoneNumberCountryCode]? = nil, phoneNumberPrefix: String? = nil, phoneNumberTypes: [PhoneNumberType]? = nil, targetArn: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberCountryCodes = phoneNumberCountryCodes
            self.phoneNumberPrefix = phoneNumberPrefix
            self.phoneNumberTypes = phoneNumberTypes
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.phoneNumberCountryCodes, name: "phoneNumberCountryCodes", parent: name, max: 10)
            try self.validate(self.phoneNumberPrefix, name: "phoneNumberPrefix", parent: name, pattern: "^\\\\+?[0-9]{1,11}$")
            try self.validate(self.phoneNumberTypes, name: "phoneNumberTypes", parent: name, max: 6)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case phoneNumberCountryCodes = "PhoneNumberCountryCodes"
            case phoneNumberPrefix = "PhoneNumberPrefix"
            case phoneNumberTypes = "PhoneNumberTypes"
            case targetArn = "TargetArn"
        }
    }

    public struct ListPhoneNumbersV2Response: AWSDecodableShape {
        /// Information about phone numbers that have been claimed to your Amazon Connect instances or traffic distribution groups.
        public let listPhoneNumbersSummaryList: [ListPhoneNumbersSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(listPhoneNumbersSummaryList: [ListPhoneNumbersSummary]? = nil, nextToken: String? = nil) {
            self.listPhoneNumbersSummaryList = listPhoneNumbersSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case listPhoneNumbersSummaryList = "ListPhoneNumbersSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredefinedAttributesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPredefinedAttributesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Summary of the predefined attributes.
        public let predefinedAttributeSummaryList: [PredefinedAttributeSummary]?

        @inlinable
        public init(nextToken: String? = nil, predefinedAttributeSummaryList: [PredefinedAttributeSummary]? = nil) {
            self.nextToken = nextToken
            self.predefinedAttributeSummaryList = predefinedAttributeSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case predefinedAttributeSummaryList = "PredefinedAttributeSummaryList"
        }
    }

    public struct ListPromptsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPromptsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the prompts.
        public let promptSummaryList: [PromptSummary]?

        @inlinable
        public init(nextToken: String? = nil, promptSummaryList: [PromptSummary]? = nil) {
            self.nextToken = nextToken
            self.promptSummaryList = promptSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case promptSummaryList = "PromptSummaryList"
        }
    }

    public struct ListQueueQuickConnectsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueueQuickConnectsResponse: AWSDecodableShape {
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the quick connects.
        public let quickConnectSummaryList: [QuickConnectSummary]?

        @inlinable
        public init(lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, nextToken: String? = nil, quickConnectSummaryList: [QuickConnectSummary]? = nil) {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.nextToken = nextToken
            self.quickConnectSummaryList = quickConnectSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case nextToken = "NextToken"
            case quickConnectSummaryList = "QuickConnectSummaryList"
        }
    }

    public struct ListQueuesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of queue.
        public let queueTypes: [QueueType]?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, queueTypes: [QueueType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueTypes = queueTypes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.queueTypes, key: "queueTypes")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueTypes, name: "queueTypes", parent: name, max: 2)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueuesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the queues.
        public let queueSummaryList: [QueueSummary]?

        @inlinable
        public init(nextToken: String? = nil, queueSummaryList: [QueueSummary]? = nil) {
            self.nextToken = nextToken
            self.queueSummaryList = queueSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case queueSummaryList = "QueueSummaryList"
        }
    }

    public struct ListQuickConnectsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public let quickConnectTypes: [QuickConnectType]?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, quickConnectTypes: [QuickConnectType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.quickConnectTypes = quickConnectTypes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.quickConnectTypes, key: "QuickConnectTypes")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.quickConnectTypes, name: "quickConnectTypes", parent: name, max: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQuickConnectsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the quick connects.
        public let quickConnectSummaryList: [QuickConnectSummary]?

        @inlinable
        public init(nextToken: String? = nil, quickConnectSummaryList: [QuickConnectSummary]? = nil) {
            self.nextToken = nextToken
            self.quickConnectSummaryList = quickConnectSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case quickConnectSummaryList = "QuickConnectSummaryList"
        }
    }

    public struct ListRealtimeContactAnalysisSegmentsV2Request: AWSEncodableShape {
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The Contact Lens output type to be returned.
        public let outputType: RealTimeContactAnalysisOutputType
        /// Enum with segment types . Each value corresponds to a segment type returned in the segments list of the API. Each segment type has its own structure. Different channels may have different sets of supported segment types.
        public let segmentTypes: [RealTimeContactAnalysisSegmentType]

        @inlinable
        public init(contactId: String, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, outputType: RealTimeContactAnalysisOutputType, segmentTypes: [RealTimeContactAnalysisSegmentType]) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outputType = outputType
            self.segmentTypes = segmentTypes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "ContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.outputType, forKey: .outputType)
            try container.encode(self.segmentTypes, forKey: .segmentTypes)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.segmentTypes, name: "segmentTypes", parent: name, max: 6)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case outputType = "OutputType"
            case segmentTypes = "SegmentTypes"
        }
    }

    public struct ListRealtimeContactAnalysisSegmentsV2Response: AWSDecodableShape {
        /// The channel of the contact.   Only CHAT is supported. This API does not support VOICE. If you attempt to use it for the VOICE channel, an InvalidRequestException error occurs.
        public let channel: RealTimeContactAnalysisSupportedChannel
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// An analyzed transcript or category.
        public let segments: [RealtimeContactAnalysisSegment]
        /// Status of real-time contact analysis.
        public let status: RealTimeContactAnalysisStatus

        @inlinable
        public init(channel: RealTimeContactAnalysisSupportedChannel, nextToken: String? = nil, segments: [RealtimeContactAnalysisSegment], status: RealTimeContactAnalysisStatus) {
            self.channel = channel
            self.nextToken = nextToken
            self.segments = segments
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case nextToken = "NextToken"
            case segments = "Segments"
            case status = "Status"
        }
    }

    public struct ListRoutingProfileQueuesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, routingProfileId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutingProfileQueuesResponse: AWSDecodableShape {
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the routing profiles.
        public let routingProfileQueueConfigSummaryList: [RoutingProfileQueueConfigSummary]?

        @inlinable
        public init(lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, nextToken: String? = nil, routingProfileQueueConfigSummaryList: [RoutingProfileQueueConfigSummary]? = nil) {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.nextToken = nextToken
            self.routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case nextToken = "NextToken"
            case routingProfileQueueConfigSummaryList = "RoutingProfileQueueConfigSummaryList"
        }
    }

    public struct ListRoutingProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutingProfilesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the routing profiles.
        public let routingProfileSummaryList: [RoutingProfileSummary]?

        @inlinable
        public init(nextToken: String? = nil, routingProfileSummaryList: [RoutingProfileSummary]? = nil) {
            self.nextToken = nextToken
            self.routingProfileSummaryList = routingProfileSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case routingProfileSummaryList = "RoutingProfileSummaryList"
        }
    }

    public struct ListRulesRequest: AWSEncodableShape {
        /// The name of the event source.
        public let eventSourceName: EventSourceName?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus?

        @inlinable
        public init(eventSourceName: EventSourceName? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, publishStatus: RulePublishStatus? = nil) {
            self.eventSourceName = eventSourceName
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.publishStatus = publishStatus
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.eventSourceName, key: "eventSourceName")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.publishStatus, key: "publishStatus")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRulesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Summary information about a rule.
        public let ruleSummaryList: [RuleSummary]

        @inlinable
        public init(nextToken: String? = nil, ruleSummaryList: [RuleSummary]) {
            self.nextToken = nextToken
            self.ruleSummaryList = ruleSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case ruleSummaryList = "RuleSummaryList"
        }
    }

    public struct ListSecurityKeysRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityKeysResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The security keys.
        public let securityKeys: [SecurityKey]?

        @inlinable
        public init(nextToken: String? = nil, securityKeys: [SecurityKey]? = nil) {
            self.nextToken = nextToken
            self.securityKeys = securityKeys
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityKeys = "SecurityKeys"
        }
    }

    public struct ListSecurityProfileApplicationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier for the security profle.
        public let securityProfileId: String

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, securityProfileId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.securityProfileId = securityProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.securityProfileId, key: "SecurityProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityProfileApplicationsResponse: AWSDecodableShape {
        /// A list of the third-party application's metadata.
        public let applications: [Application]?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(applications: [Application]? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, nextToken: String? = nil) {
            self.applications = applications
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "Applications"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case nextToken = "NextToken"
        }
    }

    public struct ListSecurityProfilePermissionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier for the security profle.
        public let securityProfileId: String

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, securityProfileId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.securityProfileId = securityProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.securityProfileId, key: "SecurityProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityProfilePermissionsResponse: AWSDecodableShape {
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The permissions granted to the security profile. For a complete list of valid permissions, see List of security profile permissions.
        public let permissions: [String]?

        @inlinable
        public init(lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, nextToken: String? = nil, permissions: [String]? = nil) {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case nextToken = "NextToken"
            case permissions = "Permissions"
        }
    }

    public struct ListSecurityProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityProfilesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the security profiles.
        public let securityProfileSummaryList: [SecurityProfileSummary]?

        @inlinable
        public init(nextToken: String? = nil, securityProfileSummaryList: [SecurityProfileSummary]? = nil) {
            self.nextToken = nextToken
            self.securityProfileSummaryList = securityProfileSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityProfileSummaryList = "SecurityProfileSummaryList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource. All Amazon Connect resources (instances, queues, flows, routing profiles, etc) have an ARN. To locate the ARN for an instance, for example, see Find your Amazon Connect instance ID/ARN.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTaskTemplatesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.  It is not expected that you set this.
        public let maxResults: Int?
        /// The name of the task template.
        public let name: String?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.  It is not expected that you set this because the value returned in the previous response is always null.
        public let nextToken: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, status: TaskTemplateStatus? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.name, key: "name")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.status, key: "status")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTaskTemplatesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.  This is always returned as a null in the response.
        public let nextToken: String?
        /// Provides details about a list of task templates belonging to an instance.
        public let taskTemplates: [TaskTemplateMetadata]?

        @inlinable
        public init(nextToken: String? = nil, taskTemplates: [TaskTemplateMetadata]? = nil) {
            self.nextToken = nextToken
            self.taskTemplates = taskTemplates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case taskTemplates = "TaskTemplates"
        }
    }

    public struct ListTrafficDistributionGroupUsersRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let trafficDistributionGroupId: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, trafficDistributionGroupId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.trafficDistributionGroupId = trafficDistributionGroupId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.trafficDistributionGroupId, key: "TrafficDistributionGroupId")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.trafficDistributionGroupId, name: "trafficDistributionGroupId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrafficDistributionGroupUsersResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A list of traffic distribution group users.
        public let trafficDistributionGroupUserSummaryList: [TrafficDistributionGroupUserSummary]?

        @inlinable
        public init(nextToken: String? = nil, trafficDistributionGroupUserSummaryList: [TrafficDistributionGroupUserSummary]? = nil) {
            self.nextToken = nextToken
            self.trafficDistributionGroupUserSummaryList = trafficDistributionGroupUserSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trafficDistributionGroupUserSummaryList = "TrafficDistributionGroupUserSummaryList"
        }
    }

    public struct ListTrafficDistributionGroupsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.instanceId, key: "instanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrafficDistributionGroupsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A list of traffic distribution groups.
        public let trafficDistributionGroupSummaryList: [TrafficDistributionGroupSummary]?

        @inlinable
        public init(nextToken: String? = nil, trafficDistributionGroupSummaryList: [TrafficDistributionGroupSummary]? = nil) {
            self.nextToken = nextToken
            self.trafficDistributionGroupSummaryList = trafficDistributionGroupSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trafficDistributionGroupSummaryList = "TrafficDistributionGroupSummaryList"
        }
    }

    public struct ListUseCasesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, integrationAssociationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.integrationAssociationId, key: "IntegrationAssociationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUseCasesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The use cases.
        public let useCaseSummaryList: [UseCase]?

        @inlinable
        public init(nextToken: String? = nil, useCaseSummaryList: [UseCase]? = nil) {
            self.nextToken = nextToken
            self.useCaseSummaryList = useCaseSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case useCaseSummaryList = "UseCaseSummaryList"
        }
    }

    public struct ListUserHierarchyGroupsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserHierarchyGroupsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the hierarchy groups.
        public let userHierarchyGroupSummaryList: [HierarchyGroupSummary]?

        @inlinable
        public init(nextToken: String? = nil, userHierarchyGroupSummaryList: [HierarchyGroupSummary]? = nil) {
            self.nextToken = nextToken
            self.userHierarchyGroupSummaryList = userHierarchyGroupSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userHierarchyGroupSummaryList = "UserHierarchyGroupSummaryList"
        }
    }

    public struct ListUserProficienciesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, userId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserProficienciesResponse: AWSDecodableShape {
        /// The region in which a user's proficiencies were last modified.
        public let lastModifiedRegion: String?
        /// The last time that the user's proficiencies are were modified.
        public let lastModifiedTime: Date?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the user proficiencies.
        public let userProficiencyList: [UserProficiency]?

        @inlinable
        public init(lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, nextToken: String? = nil, userProficiencyList: [UserProficiency]? = nil) {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.nextToken = nextToken
            self.userProficiencyList = userProficiencyList
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case nextToken = "NextToken"
            case userProficiencyList = "UserProficiencyList"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the users.
        public let userSummaryList: [UserSummary]?

        @inlinable
        public init(nextToken: String? = nil, userSummaryList: [UserSummary]? = nil) {
            self.nextToken = nextToken
            self.userSummaryList = userSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userSummaryList = "UserSummaryList"
        }
    }

    public struct ListViewVersionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the view. Both ViewArn and ViewId can be used.
        public let viewId: String

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, viewId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.viewId = viewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.viewId, key: "ViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=\\/+_.-]+$")
            try self.validate(self.viewId, name: "viewId", parent: name, max: 500)
            try self.validate(self.viewId, name: "viewId", parent: name, min: 1)
            try self.validate(self.viewId, name: "viewId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/$]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListViewVersionsResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of view version summaries.
        public let viewVersionSummaryList: [ViewVersionSummary]?

        @inlinable
        public init(nextToken: String? = nil, viewVersionSummaryList: [ViewVersionSummary]? = nil) {
            self.nextToken = nextToken
            self.viewVersionSummaryList = viewVersionSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case viewVersionSummaryList = "ViewVersionSummaryList"
        }
    }

    public struct ListViewsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of the view.
        public let type: ViewType?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, type: ViewType? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.type, key: "type")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 4096)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=\\/+_.-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListViewsResponse: AWSDecodableShape {
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A list of view summaries.
        public let viewsSummaryList: [ViewSummary]?

        @inlinable
        public init(nextToken: String? = nil, viewsSummaryList: [ViewSummary]? = nil) {
            self.nextToken = nextToken
            self.viewsSummaryList = viewsSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case viewsSummaryList = "ViewsSummaryList"
        }
    }

    public struct MatchCriteria: AWSEncodableShape & AWSDecodableShape {
        /// An object to define agentIds.
        public let agentsCriteria: AgentsCriteria?

        @inlinable
        public init(agentsCriteria: AgentsCriteria? = nil) {
            self.agentsCriteria = agentsCriteria
        }

        public func validate(name: String) throws {
            try self.agentsCriteria?.validate(name: "\(name).agentsCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case agentsCriteria = "AgentsCriteria"
        }
    }

    public struct MediaConcurrency: AWSEncodableShape & AWSDecodableShape {
        /// The channels that agents can handle in the Contact Control Panel (CCP).
        public let channel: Channel
        /// The number of contacts an agent can have on a channel simultaneously. Valid Range for VOICE: Minimum value of 1. Maximum value of 1. Valid Range for CHAT: Minimum value of 1. Maximum value of 10. Valid Range for TASK: Minimum value of 1. Maximum value of 10.
        public let concurrency: Int
        /// Defines the cross-channel routing behavior for each channel that is enabled for this Routing Profile. For example, this allows you to offer an agent a different contact from another channel when they are currently working with a contact from a Voice channel.
        public let crossChannelBehavior: CrossChannelBehavior?

        @inlinable
        public init(channel: Channel, concurrency: Int, crossChannelBehavior: CrossChannelBehavior? = nil) {
            self.channel = channel
            self.concurrency = concurrency
            self.crossChannelBehavior = crossChannelBehavior
        }

        public func validate(name: String) throws {
            try self.validate(self.concurrency, name: "concurrency", parent: name, max: 10)
            try self.validate(self.concurrency, name: "concurrency", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case concurrency = "Concurrency"
            case crossChannelBehavior = "CrossChannelBehavior"
        }
    }

    public struct MediaPlacement: AWSDecodableShape {
        /// The audio fallback URL.
        public let audioFallbackUrl: String?
        /// The audio host URL.
        public let audioHostUrl: String?
        /// The event ingestion URL to which you send client meeting events.
        public let eventIngestionUrl: String?
        /// The signaling URL.
        public let signalingUrl: String?
        /// The turn control URL.
        public let turnControlUrl: String?

        @inlinable
        public init(audioFallbackUrl: String? = nil, audioHostUrl: String? = nil, eventIngestionUrl: String? = nil, signalingUrl: String? = nil, turnControlUrl: String? = nil) {
            self.audioFallbackUrl = audioFallbackUrl
            self.audioHostUrl = audioHostUrl
            self.eventIngestionUrl = eventIngestionUrl
            self.signalingUrl = signalingUrl
            self.turnControlUrl = turnControlUrl
        }

        private enum CodingKeys: String, CodingKey {
            case audioFallbackUrl = "AudioFallbackUrl"
            case audioHostUrl = "AudioHostUrl"
            case eventIngestionUrl = "EventIngestionUrl"
            case signalingUrl = "SignalingUrl"
            case turnControlUrl = "TurnControlUrl"
        }
    }

    public struct Meeting: AWSDecodableShape {
        /// The media placement for the meeting.
        public let mediaPlacement: MediaPlacement?
        /// The Amazon Web Services Region in which you create the meeting.
        public let mediaRegion: String?
        /// The configuration settings of the features available to a meeting.
        public let meetingFeatures: MeetingFeaturesConfiguration?
        /// The Amazon Chime SDK meeting ID.
        public let meetingId: String?

        @inlinable
        public init(mediaPlacement: MediaPlacement? = nil, mediaRegion: String? = nil, meetingFeatures: MeetingFeaturesConfiguration? = nil, meetingId: String? = nil) {
            self.mediaPlacement = mediaPlacement
            self.mediaRegion = mediaRegion
            self.meetingFeatures = meetingFeatures
            self.meetingId = meetingId
        }

        private enum CodingKeys: String, CodingKey {
            case mediaPlacement = "MediaPlacement"
            case mediaRegion = "MediaRegion"
            case meetingFeatures = "MeetingFeatures"
            case meetingId = "MeetingId"
        }
    }

    public struct MeetingFeaturesConfiguration: AWSDecodableShape {
        /// The configuration settings for the audio features available to a meeting.
        public let audio: AudioFeatures?

        @inlinable
        public init(audio: AudioFeatures? = nil) {
            self.audio = audio
        }

        private enum CodingKeys: String, CodingKey {
            case audio = "Audio"
        }
    }

    public struct MetricDataV2: AWSDecodableShape {
        /// The metric name, thresholds, and metric filters of the returned metric.
        public let metric: MetricV2?
        /// The corresponding value of the metric returned in the response.
        public let value: Double?

        @inlinable
        public init(metric: MetricV2? = nil, value: Double? = nil) {
            self.metric = metric
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case value = "Value"
        }
    }

    public struct MetricFilterV2: AWSEncodableShape & AWSDecodableShape {
        /// The key to use for filtering data.  Valid metric filter keys:    ANSWERING_MACHINE_DETECTION_STATUS   CASE_STATUS   DISCONNECT_REASON   FLOWS_ACTION_IDENTIFIER   FLOWS_NEXT_ACTION_IDENTIFIER   FLOWS_OUTCOME_TYPE   FLOWS_RESOURCE_TYPE   INITIATION_METHOD
        public let metricFilterKey: String?
        /// The values to use for filtering data. Values for metric-level filters can be either a fixed set of values or a customized list, depending on the use case. For valid values of metric-level filters INITIATION_METHOD, DISCONNECT_REASON, and ANSWERING_MACHINE_DETECTION_STATUS, see ContactTraceRecord in the Amazon Connect Administrator Guide.  For valid values of the metric-level filter FLOWS_OUTCOME_TYPE, see the description for the Flow outcome metric in the Amazon Connect Administrator Guide. For valid values of the metric-level filter BOT_CONVERSATION_OUTCOME_TYPE, see the description for the Bot conversations completed in the Amazon Connect Administrator Guide. For valid values of the metric-level filter BOT_INTENT_OUTCOME_TYPE, see the description for the Bot intents completed metric in the Amazon Connect Administrator Guide.
        public let metricFilterValues: [String]?
        /// If set to true, the API response contains results that filter out the results matched by the metric-level filters condition. By default, Negate is set to false.
        public let negate: Bool?

        @inlinable
        public init(metricFilterKey: String? = nil, metricFilterValues: [String]? = nil, negate: Bool? = nil) {
            self.metricFilterKey = metricFilterKey
            self.metricFilterValues = metricFilterValues
            self.negate = negate
        }

        public func validate(name: String) throws {
            try self.validate(self.metricFilterValues, name: "metricFilterValues", parent: name, max: 10)
            try self.validate(self.metricFilterValues, name: "metricFilterValues", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metricFilterKey = "MetricFilterKey"
            case metricFilterValues = "MetricFilterValues"
            case negate = "Negate"
        }
    }

    public struct MetricInterval: AWSDecodableShape {
        /// The timestamp, in UNIX Epoch time format. End time is based on the interval period selected. For example, If IntervalPeriod is selected THIRTY_MIN, StartTime and EndTime in the API request differs by 1 day, then 48 results are returned in the response. Each result is aggregated by the 30 minutes period, with each StartTime and EndTime differing by 30 minutes.
        public let endTime: Date?
        /// The interval period provided in the API request.
        public let interval: IntervalPeriod?
        /// The timestamp, in UNIX Epoch time format. Start time is based on the interval period selected.
        public let startTime: Date?

        @inlinable
        public init(endTime: Date? = nil, interval: IntervalPeriod? = nil, startTime: Date? = nil) {
            self.endTime = endTime
            self.interval = interval
            self.startTime = startTime
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case interval = "Interval"
            case startTime = "StartTime"
        }
    }

    public struct MetricResultV2: AWSDecodableShape {
        /// The set of metrics.
        public let collections: [MetricDataV2]?
        /// The dimension for the metrics.
        public let dimensions: [String: String]?
        /// The interval period with the start and end time for the metrics.
        public let metricInterval: MetricInterval?

        @inlinable
        public init(collections: [MetricDataV2]? = nil, dimensions: [String: String]? = nil, metricInterval: MetricInterval? = nil) {
            self.collections = collections
            self.dimensions = dimensions
            self.metricInterval = metricInterval
        }

        private enum CodingKeys: String, CodingKey {
            case collections = "Collections"
            case dimensions = "Dimensions"
            case metricInterval = "MetricInterval"
        }
    }

    public struct MetricV2: AWSEncodableShape & AWSDecodableShape {
        /// Contains the filters to be used when returning data.
        public let metricFilters: [MetricFilterV2]?
        /// The name of the metric.  This parameter is required. The following Required = No is incorrect.
        public let name: String?
        /// Contains information about the threshold for service level metrics.
        public let threshold: [ThresholdV2]?

        @inlinable
        public init(metricFilters: [MetricFilterV2]? = nil, name: String? = nil, threshold: [ThresholdV2]? = nil) {
            self.metricFilters = metricFilters
            self.name = name
            self.threshold = threshold
        }

        public func validate(name: String) throws {
            try self.metricFilters?.forEach {
                try $0.validate(name: "\(name).metricFilters[]")
            }
            try self.validate(self.metricFilters, name: "metricFilters", parent: name, max: 2)
            try self.threshold?.forEach {
                try $0.validate(name: "\(name).threshold[]")
            }
            try self.validate(self.threshold, name: "threshold", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metricFilters = "MetricFilters"
            case name = "Name"
            case threshold = "Threshold"
        }
    }

    public struct MonitorContactRequest: AWSEncodableShape {
        /// Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge. AllowedMonitorCapabilities is required if barge is enabled.
        public let allowedMonitorCapabilities: [MonitorCapability]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(allowedMonitorCapabilities: [MonitorCapability]? = nil, clientToken: String? = MonitorContactRequest.idempotencyToken(), contactId: String, instanceId: String, userId: String) {
            self.allowedMonitorCapabilities = allowedMonitorCapabilities
            self.clientToken = clientToken
            self.contactId = contactId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.allowedMonitorCapabilities, name: "allowedMonitorCapabilities", parent: name, max: 2)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedMonitorCapabilities = "AllowedMonitorCapabilities"
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case userId = "UserId"
        }
    }

    public struct MonitorContactResponse: AWSDecodableShape {
        /// The ARN of the contact.
        public let contactArn: String?
        /// The identifier of the contact.
        public let contactId: String?

        @inlinable
        public init(contactArn: String? = nil, contactId: String? = nil) {
            self.contactArn = contactArn
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case contactId = "ContactId"
        }
    }

    public struct NewSessionDetails: AWSEncodableShape {
        ///  A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes.  There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        public let participantDetails: ParticipantDetails?
        public let streamingConfiguration: ChatStreamingConfiguration?
        ///  The supported chat message content types. Supported types are text/plain, text/markdown, application/json, application/vnd.amazonaws.connect.message.interactive, and application/vnd.amazonaws.connect.message.interactive.response.  Content types must always contain  text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain: [text/plain, text/markdown, application/json],  [text/markdown, text/plain], [text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response].
        public let supportedMessagingContentTypes: [String]?

        @inlinable
        public init(attributes: [String: String]? = nil, participantDetails: ParticipantDetails? = nil, streamingConfiguration: ChatStreamingConfiguration? = nil, supportedMessagingContentTypes: [String]? = nil) {
            self.attributes = attributes
            self.participantDetails = participantDetails
            self.streamingConfiguration = streamingConfiguration
            self.supportedMessagingContentTypes = supportedMessagingContentTypes
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.participantDetails?.validate(name: "\(name).participantDetails")
            try self.streamingConfiguration?.validate(name: "\(name).streamingConfiguration")
            try self.supportedMessagingContentTypes?.forEach {
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, max: 100)
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case participantDetails = "ParticipantDetails"
            case streamingConfiguration = "StreamingConfiguration"
            case supportedMessagingContentTypes = "SupportedMessagingContentTypes"
        }
    }

    public struct NotificationRecipientType: AWSEncodableShape & AWSDecodableShape {
        /// A list of user IDs. Supports variable injection of $.ContactLens.ContactEvaluation.Agent.AgentId for OnContactEvaluationSubmit event source.
        public let userIds: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.
        public let userTags: [String: String]?

        @inlinable
        public init(userIds: [String]? = nil, userTags: [String: String]? = nil) {
            self.userIds = userIds
            self.userTags = userTags
        }

        private enum CodingKeys: String, CodingKey {
            case userIds = "UserIds"
            case userTags = "UserTags"
        }
    }

    public struct NumberCondition: AWSEncodableShape {
        /// The type of comparison to be made when evaluating the number condition.
        public let comparisonType: NumberComparisonType?
        /// The name of the field in the number condition.
        public let fieldName: String?
        /// The maxValue to be used while evaluating the number condition.
        public let maxValue: Int?
        /// The minValue to be used while evaluating the number condition.
        public let minValue: Int?

        @inlinable
        public init(comparisonType: NumberComparisonType? = nil, fieldName: String? = nil, maxValue: Int? = nil, minValue: Int? = nil) {
            self.comparisonType = comparisonType
            self.fieldName = fieldName
            self.maxValue = maxValue
            self.minValue = minValue
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonType = "ComparisonType"
            case fieldName = "FieldName"
            case maxValue = "MaxValue"
            case minValue = "MinValue"
        }
    }

    public struct NumberReference: AWSDecodableShape {
        /// Identifier of the number reference.
        public let name: String?
        /// A valid number.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct NumericQuestionPropertyValueAutomation: AWSEncodableShape & AWSDecodableShape {
        /// The property label of the automation.
        public let label: NumericQuestionPropertyAutomationLabel

        @inlinable
        public init(label: NumericQuestionPropertyAutomationLabel) {
            self.label = label
        }

        private enum CodingKeys: String, CodingKey {
            case label = "Label"
        }
    }

    public struct OperationalHour: AWSDecodableShape {
        /// The end time that your contact center closes.
        public let end: OverrideTimeSlice?
        /// The start time that your contact center opens.
        public let start: OverrideTimeSlice?

        @inlinable
        public init(end: OverrideTimeSlice? = nil, start: OverrideTimeSlice? = nil) {
            self.end = end
            self.start = start
        }

        private enum CodingKeys: String, CodingKey {
            case end = "End"
            case start = "Start"
        }
    }

    public struct OutboundAdditionalRecipients: AWSEncodableShape {
        /// The additional CC email address recipients information.
        public let ccEmailAddresses: [EmailAddressInfo]?

        @inlinable
        public init(ccEmailAddresses: [EmailAddressInfo]? = nil) {
            self.ccEmailAddresses = ccEmailAddresses
        }

        public func validate(name: String) throws {
            try self.ccEmailAddresses?.forEach {
                try $0.validate(name: "\(name).ccEmailAddresses[]")
            }
            try self.validate(self.ccEmailAddresses, name: "ccEmailAddresses", parent: name, max: 10)
            try self.validate(self.ccEmailAddresses, name: "ccEmailAddresses", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case ccEmailAddresses = "CcEmailAddresses"
        }
    }

    public struct OutboundCallerConfig: AWSEncodableShape & AWSDecodableShape {
        /// The caller ID name.
        public let outboundCallerIdName: String?
        /// The caller ID number.
        public let outboundCallerIdNumberId: String?
        /// The outbound whisper flow to be used during an outbound call.
        public let outboundFlowId: String?

        @inlinable
        public init(outboundCallerIdName: String? = nil, outboundCallerIdNumberId: String? = nil, outboundFlowId: String? = nil) {
            self.outboundCallerIdName = outboundCallerIdName
            self.outboundCallerIdNumberId = outboundCallerIdNumberId
            self.outboundFlowId = outboundFlowId
        }

        public func validate(name: String) throws {
            try self.validate(self.outboundCallerIdName, name: "outboundCallerIdName", parent: name, max: 255)
            try self.validate(self.outboundCallerIdName, name: "outboundCallerIdName", parent: name, min: 1)
            try self.validate(self.outboundFlowId, name: "outboundFlowId", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case outboundCallerIdName = "OutboundCallerIdName"
            case outboundCallerIdNumberId = "OutboundCallerIdNumberId"
            case outboundFlowId = "OutboundFlowId"
        }
    }

    public struct OutboundEmailConfig: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the email address.
        public let outboundEmailAddressId: String?

        @inlinable
        public init(outboundEmailAddressId: String? = nil) {
            self.outboundEmailAddressId = outboundEmailAddressId
        }

        public func validate(name: String) throws {
            try self.validate(self.outboundEmailAddressId, name: "outboundEmailAddressId", parent: name, max: 500)
            try self.validate(self.outboundEmailAddressId, name: "outboundEmailAddressId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case outboundEmailAddressId = "OutboundEmailAddressId"
        }
    }

    public struct OutboundEmailContent: AWSEncodableShape {
        /// The message source type, that is, RAW or TEMPLATE.
        public let messageSourceType: OutboundMessageSourceType
        /// The raw email body content.
        public let rawMessage: OutboundRawMessage?
        /// Information about template message configuration.
        public let templatedMessageConfig: TemplatedMessageConfig?

        @inlinable
        public init(messageSourceType: OutboundMessageSourceType, rawMessage: OutboundRawMessage? = nil, templatedMessageConfig: TemplatedMessageConfig? = nil) {
            self.messageSourceType = messageSourceType
            self.rawMessage = rawMessage
            self.templatedMessageConfig = templatedMessageConfig
        }

        public func validate(name: String) throws {
            try self.rawMessage?.validate(name: "\(name).rawMessage")
            try self.templatedMessageConfig?.validate(name: "\(name).templatedMessageConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case messageSourceType = "MessageSourceType"
            case rawMessage = "RawMessage"
            case templatedMessageConfig = "TemplatedMessageConfig"
        }
    }

    public struct OutboundRawMessage: AWSEncodableShape {
        /// The email message body.
        public let body: String
        /// Type of content, that is, text/plain or text/html.
        public let contentType: String
        /// The email subject.
        public let subject: String

        @inlinable
        public init(body: String, contentType: String, subject: String) {
            self.body = body
            self.contentType = contentType
            self.subject = subject
        }

        public func validate(name: String) throws {
            try self.validate(self.body, name: "body", parent: name, max: 5242880)
            try self.validate(self.body, name: "body", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 100)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.validate(self.subject, name: "subject", parent: name, max: 998)
            try self.validate(self.subject, name: "subject", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case body = "Body"
            case contentType = "ContentType"
            case subject = "Subject"
        }
    }

    public struct OverrideTimeSlice: AWSEncodableShape & AWSDecodableShape {
        /// The hours.
        public let hours: Int
        /// The minutes.
        public let minutes: Int

        @inlinable
        public init(hours: Int, minutes: Int) {
            self.hours = hours
            self.minutes = minutes
        }

        public func validate(name: String) throws {
            try self.validate(self.hours, name: "hours", parent: name, max: 23)
            try self.validate(self.hours, name: "hours", parent: name, min: 0)
            try self.validate(self.minutes, name: "minutes", parent: name, max: 59)
            try self.validate(self.minutes, name: "minutes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case hours = "Hours"
            case minutes = "Minutes"
        }
    }

    public struct ParticipantCapabilities: AWSEncodableShape & AWSDecodableShape {
        /// The screen sharing capability that is enabled for the participant. SEND indicates the participant can share their screen.
        public let screenShare: ScreenShareCapability?
        /// The configuration having the video and screen sharing capabilities for participants over the call.
        public let video: VideoCapability?

        @inlinable
        public init(screenShare: ScreenShareCapability? = nil, video: VideoCapability? = nil) {
            self.screenShare = screenShare
            self.video = video
        }

        private enum CodingKeys: String, CodingKey {
            case screenShare = "ScreenShare"
            case video = "Video"
        }
    }

    public struct ParticipantDetails: AWSEncodableShape {
        /// Display name of the participant.
        public let displayName: String

        @inlinable
        public init(displayName: String) {
            self.displayName = displayName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
        }
    }

    public struct ParticipantDetailsToAdd: AWSEncodableShape {
        /// The display name of the participant.
        public let displayName: String?
        /// The role of the participant being added.
        public let participantRole: ParticipantRole?

        @inlinable
        public init(displayName: String? = nil, participantRole: ParticipantRole? = nil) {
            self.displayName = displayName
            self.participantRole = participantRole
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case participantRole = "ParticipantRole"
        }
    }

    public struct ParticipantTimerConfiguration: AWSEncodableShape {
        /// The role of the participant in the chat conversation.
        public let participantRole: TimerEligibleParticipantRoles
        /// The type of timer. IDLE indicates the timer applies for considering a human chat participant as idle. DISCONNECT_NONCUSTOMER indicates the timer applies to automatically disconnecting a chat participant due to idleness.
        public let timerType: ParticipantTimerType
        /// The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.
        public let timerValue: ParticipantTimerValue

        @inlinable
        public init(participantRole: TimerEligibleParticipantRoles, timerType: ParticipantTimerType, timerValue: ParticipantTimerValue) {
            self.participantRole = participantRole
            self.timerType = timerType
            self.timerValue = timerValue
        }

        public func validate(name: String) throws {
            try self.timerValue.validate(name: "\(name).timerValue")
        }

        private enum CodingKeys: String, CodingKey {
            case participantRole = "ParticipantRole"
            case timerType = "TimerType"
            case timerValue = "TimerValue"
        }
    }

    public struct ParticipantTokenCredentials: AWSDecodableShape {
        /// The expiration of the token. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let expiry: String?
        /// The token used by the chat participant to call CreateParticipantConnection. The participant token is valid for the lifetime of a chat participant.
        public let participantToken: String?

        @inlinable
        public init(expiry: String? = nil, participantToken: String? = nil) {
            self.expiry = expiry
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case expiry = "Expiry"
            case participantToken = "ParticipantToken"
        }
    }

    public struct PauseContactRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String?
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowId: String? = nil, contactId: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct PauseContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct PersistentChat: AWSEncodableShape {
        /// The contactId that is used for rehydration depends on the rehydration type. RehydrationType is required for persistent chat.     ENTIRE_PAST_SESSION: Rehydrates a chat from the most recently terminated past chat contact of the specified past ended chat session. To use this type, provide the initialContactId of the past ended chat session in the sourceContactId field. In this type, Amazon Connect determines the most recent chat contact on the specified chat session that has ended, and uses it to start a persistent chat.     FROM_SEGMENT: Rehydrates a chat from the past chat contact that is specified in the sourceContactId field.    The actual contactId used for rehydration is provided in the response of this API.
        public let rehydrationType: RehydrationType?
        /// The contactId from which a persistent chat session must be started.
        public let sourceContactId: String?

        @inlinable
        public init(rehydrationType: RehydrationType? = nil, sourceContactId: String? = nil) {
            self.rehydrationType = rehydrationType
            self.sourceContactId = sourceContactId
        }

        public func validate(name: String) throws {
            try self.validate(self.sourceContactId, name: "sourceContactId", parent: name, max: 256)
            try self.validate(self.sourceContactId, name: "sourceContactId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case rehydrationType = "RehydrationType"
            case sourceContactId = "SourceContactId"
        }
    }

    public struct PhoneNumberQuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The phone number in E.164 format.
        public let phoneNumber: String

        @inlinable
        public init(phoneNumber: String) {
            self.phoneNumber = phoneNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct PhoneNumberStatus: AWSDecodableShape {
        /// The status message.
        public let message: String?
        /// The status.
        public let status: PhoneNumberWorkflowStatus?

        @inlinable
        public init(message: String? = nil, status: PhoneNumberWorkflowStatus? = nil) {
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case status = "Status"
        }
    }

    public struct PhoneNumberSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the phone number.
        public let arn: String?
        /// The identifier of the phone number.
        public let id: String?
        /// The phone number.
        public let phoneNumber: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, phoneNumber: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberType: PhoneNumberType? = nil) {
            self.arn = arn
            self.id = id
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case phoneNumber = "PhoneNumber"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberType = "PhoneNumberType"
        }
    }

    public struct PredefinedAttribute: AWSDecodableShape {
        /// Last modified region.
        public let lastModifiedRegion: String?
        /// Last modified time.
        public let lastModifiedTime: Date?
        /// The name of the predefined attribute.
        public let name: String?
        /// The values of the predefined attribute.
        public let values: PredefinedAttributeValues?

        @inlinable
        public init(lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, values: PredefinedAttributeValues? = nil) {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case values = "Values"
        }
    }

    public struct PredefinedAttributeSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [PredefinedAttributeSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [PredefinedAttributeSearchCriteria]?
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [PredefinedAttributeSearchCriteria]? = nil, orConditions: [PredefinedAttributeSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct PredefinedAttributeSummary: AWSDecodableShape {
        /// Last modified region.
        public let lastModifiedRegion: String?
        /// Last modified time.
        public let lastModifiedTime: Date?
        /// The name of the predefined attribute.
        public let name: String?

        @inlinable
        public init(lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct ProblemDetail: AWSDecodableShape {
        /// The problem detail's message.
        public let message: String?

        @inlinable
        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct Prompt: AWSDecodableShape {
        /// The description of the prompt.
        public let description: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the prompt.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the prompt.
        public let promptARN: String?
        /// A unique identifier for the prompt.
        public let promptId: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, promptARN: String? = nil, promptId: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.promptARN = promptARN
            self.promptId = promptId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case promptARN = "PromptARN"
            case promptId = "PromptId"
            case tags = "Tags"
        }
    }

    public struct PromptSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [PromptSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [PromptSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name, description, and resourceID.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [PromptSearchCriteria]? = nil, orConditions: [PromptSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct PromptSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct PromptSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let arn: String?
        /// The identifier of the prompt.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the prompt.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct PropertyValidationException: AWSErrorShape {
        public let message: String
        public let propertyList: [PropertyValidationExceptionProperty]?

        @inlinable
        public init(message: String, propertyList: [PropertyValidationExceptionProperty]? = nil) {
            self.message = message
            self.propertyList = propertyList
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case propertyList = "PropertyList"
        }
    }

    public struct PropertyValidationExceptionProperty: AWSDecodableShape {
        /// A message describing why the property is not valid.
        public let message: String
        /// The full property path.
        public let propertyPath: String
        /// Why the property is not valid.
        public let reason: PropertyValidationExceptionReason

        @inlinable
        public init(message: String, propertyPath: String, reason: PropertyValidationExceptionReason) {
            self.message = message
            self.propertyPath = propertyPath
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case propertyPath = "PropertyPath"
            case reason = "Reason"
        }
    }

    public struct PutUserStatusRequest: AWSEncodableShape {
        /// The identifier of the agent status.
        public let agentStatusId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the user.
        public let userId: String

        @inlinable
        public init(agentStatusId: String, instanceId: String, userId: String) {
            self.agentStatusId = agentStatusId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentStatusId, forKey: .agentStatusId)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusId = "AgentStatusId"
        }
    }

    public struct PutUserStatusResponse: AWSDecodableShape {
        public init() {}
    }

    public struct QualityMetrics: AWSDecodableShape {
        /// Information about the quality of Agent media connection.
        public let agent: AgentQualityMetrics?
        /// Information about the quality of Customer media connection.
        public let customer: CustomerQualityMetrics?

        @inlinable
        public init(agent: AgentQualityMetrics? = nil, customer: CustomerQualityMetrics? = nil) {
            self.agent = agent
            self.customer = customer
        }

        private enum CodingKeys: String, CodingKey {
            case agent = "Agent"
            case customer = "Customer"
        }
    }

    public struct Queue: AWSDecodableShape {
        /// The description of the queue.
        public let description: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public let maxContacts: Int?
        /// The name of the queue.
        public let name: String?
        /// The outbound caller ID name, number, and outbound whisper flow.
        public let outboundCallerConfig: OutboundCallerConfig?
        /// The outbound email address ID for a specified queue.
        public let outboundEmailConfig: OutboundEmailConfig?
        /// The Amazon Resource Name (ARN) for the queue.
        public let queueArn: String?
        /// The identifier for the queue.
        public let queueId: String?
        /// The status of the queue.
        public let status: QueueStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, hoursOfOperationId: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, maxContacts: Int? = nil, name: String? = nil, outboundCallerConfig: OutboundCallerConfig? = nil, outboundEmailConfig: OutboundEmailConfig? = nil, queueArn: String? = nil, queueId: String? = nil, status: QueueStatus? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.maxContacts = maxContacts
            self.name = name
            self.outboundCallerConfig = outboundCallerConfig
            self.outboundEmailConfig = outboundEmailConfig
            self.queueArn = queueArn
            self.queueId = queueId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case hoursOfOperationId = "HoursOfOperationId"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case maxContacts = "MaxContacts"
            case name = "Name"
            case outboundCallerConfig = "OutboundCallerConfig"
            case outboundEmailConfig = "OutboundEmailConfig"
            case queueArn = "QueueArn"
            case queueId = "QueueId"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct QueueInfo: AWSDecodableShape {
        /// The timestamp when the contact was added to the queue.
        public let enqueueTimestamp: Date?
        /// The unique identifier for the queue.
        public let id: String?

        @inlinable
        public init(enqueueTimestamp: Date? = nil, id: String? = nil) {
            self.enqueueTimestamp = enqueueTimestamp
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case enqueueTimestamp = "EnqueueTimestamp"
            case id = "Id"
        }
    }

    public struct QueueInfoInput: AWSEncodableShape {
        /// The identifier of the queue.
        public let id: String?

        @inlinable
        public init(id: String? = nil) {
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct QueueQuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(contactFlowId: String, queueId: String) {
            self.contactFlowId = contactFlowId
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case queueId = "QueueId"
        }
    }

    public struct QueueReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the queue.
        public let arn: String?
        /// The identifier of the queue.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct QueueSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [QueueSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [QueueSearchCriteria]?
        /// The type of queue.
        public let queueTypeCondition: SearchableQueueType?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name, description, and resourceID.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [QueueSearchCriteria]? = nil, orConditions: [QueueSearchCriteria]? = nil, queueTypeCondition: SearchableQueueType? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.queueTypeCondition = queueTypeCondition
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case queueTypeCondition = "QueueTypeCondition"
            case stringCondition = "StringCondition"
        }
    }

    public struct QueueSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct QueueSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the queue.
        public let arn: String?
        /// The identifier of the queue.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the queue.
        public let name: String?
        /// The type of queue.
        public let queueType: QueueType?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, queueType: QueueType? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.queueType = queueType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case queueType = "QueueType"
        }
    }

    public struct QuickConnect: AWSDecodableShape {
        /// The description.
        public let description: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the quick connect.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the quick connect.
        public let quickConnectARN: String?
        /// Contains information about the quick connect.
        public let quickConnectConfig: QuickConnectConfig?
        /// The identifier for the quick connect.
        public let quickConnectId: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(description: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, quickConnectARN: String? = nil, quickConnectConfig: QuickConnectConfig? = nil, quickConnectId: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickConnectARN = quickConnectARN
            self.quickConnectConfig = quickConnectConfig
            self.quickConnectId = quickConnectId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case quickConnectARN = "QuickConnectARN"
            case quickConnectConfig = "QuickConnectConfig"
            case quickConnectId = "QuickConnectId"
            case tags = "Tags"
        }
    }

    public struct QuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        public let phoneConfig: PhoneNumberQuickConnectConfig?
        /// The queue configuration. This is required only if QuickConnectType is QUEUE.
        public let queueConfig: QueueQuickConnectConfig?
        /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public let quickConnectType: QuickConnectType
        /// The user configuration. This is required only if QuickConnectType is USER.
        public let userConfig: UserQuickConnectConfig?

        @inlinable
        public init(phoneConfig: PhoneNumberQuickConnectConfig? = nil, queueConfig: QueueQuickConnectConfig? = nil, quickConnectType: QuickConnectType, userConfig: UserQuickConnectConfig? = nil) {
            self.phoneConfig = phoneConfig
            self.queueConfig = queueConfig
            self.quickConnectType = quickConnectType
            self.userConfig = userConfig
        }

        public func validate(name: String) throws {
            try self.phoneConfig?.validate(name: "\(name).phoneConfig")
            try self.queueConfig?.validate(name: "\(name).queueConfig")
            try self.userConfig?.validate(name: "\(name).userConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneConfig = "PhoneConfig"
            case queueConfig = "QueueConfig"
            case quickConnectType = "QuickConnectType"
            case userConfig = "UserConfig"
        }
    }

    public struct QuickConnectSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [QuickConnectSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [QuickConnectSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name, description, and resourceID.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [QuickConnectSearchCriteria]? = nil, orConditions: [QuickConnectSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct QuickConnectSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct QuickConnectSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the quick connect.
        public let arn: String?
        /// The identifier for the quick connect.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the quick connect.
        public let name: String?
        /// The type of quick connect. In the Amazon Connect admin website, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public let quickConnectType: QuickConnectType?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, quickConnectType: QuickConnectType? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.quickConnectType = quickConnectType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case quickConnectType = "QuickConnectType"
        }
    }

    public struct Range: AWSEncodableShape & AWSDecodableShape {
        /// The maximum proficiency level of the range.
        public let maxProficiencyLevel: Float?
        /// The minimum proficiency level of the range.
        public let minProficiencyLevel: Float?

        @inlinable
        public init(maxProficiencyLevel: Float? = nil, minProficiencyLevel: Float? = nil) {
            self.maxProficiencyLevel = maxProficiencyLevel
            self.minProficiencyLevel = minProficiencyLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.maxProficiencyLevel, name: "maxProficiencyLevel", parent: name, max: 5.0)
            try self.validate(self.maxProficiencyLevel, name: "maxProficiencyLevel", parent: name, min: 1.0)
            try self.validate(self.minProficiencyLevel, name: "minProficiencyLevel", parent: name, max: 5.0)
            try self.validate(self.minProficiencyLevel, name: "minProficiencyLevel", parent: name, min: 1.0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxProficiencyLevel = "MaxProficiencyLevel"
            case minProficiencyLevel = "MinProficiencyLevel"
        }
    }

    public struct ReadOnlyFieldInfo: AWSEncodableShape & AWSDecodableShape {
        /// Identifier of the read-only field.
        public let id: TaskTemplateFieldIdentifier?

        @inlinable
        public init(id: TaskTemplateFieldIdentifier? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct RealTimeContactAnalysisAttachment: AWSDecodableShape {
        /// A unique identifier for the attachment.
        public let attachmentId: String
        /// A case-sensitive name of the attachment being uploaded. Can be redacted.
        public let attachmentName: String
        /// Describes the MIME file type of the attachment. For a list of supported file types, see Feature specifications in the Amazon Connect Administrator Guide.
        public let contentType: String?
        /// Status of the attachment.
        public let status: ArtifactStatus?

        @inlinable
        public init(attachmentId: String, attachmentName: String, contentType: String? = nil, status: ArtifactStatus? = nil) {
            self.attachmentId = attachmentId
            self.attachmentName = attachmentName
            self.contentType = contentType
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "AttachmentId"
            case attachmentName = "AttachmentName"
            case contentType = "ContentType"
            case status = "Status"
        }
    }

    public struct RealTimeContactAnalysisCategoryDetails: AWSDecodableShape {
        /// List of PointOfInterest - objects describing a single match of a rule.
        public let pointsOfInterest: [RealTimeContactAnalysisPointOfInterest]

        @inlinable
        public init(pointsOfInterest: [RealTimeContactAnalysisPointOfInterest]) {
            self.pointsOfInterest = pointsOfInterest
        }

        private enum CodingKeys: String, CodingKey {
            case pointsOfInterest = "PointsOfInterest"
        }
    }

    public struct RealTimeContactAnalysisCharacterInterval: AWSDecodableShape {
        /// The beginning of the character interval.
        public let beginOffsetChar: Int
        /// The end of the character interval.
        public let endOffsetChar: Int

        @inlinable
        public init(beginOffsetChar: Int, endOffsetChar: Int) {
            self.beginOffsetChar = beginOffsetChar
            self.endOffsetChar = endOffsetChar
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffsetChar = "BeginOffsetChar"
            case endOffsetChar = "EndOffsetChar"
        }
    }

    public struct RealTimeContactAnalysisIssueDetected: AWSDecodableShape {
        /// List of the transcript items (segments) that are associated with a given issue.
        public let transcriptItems: [RealTimeContactAnalysisTranscriptItemWithContent]

        @inlinable
        public init(transcriptItems: [RealTimeContactAnalysisTranscriptItemWithContent]) {
            self.transcriptItems = transcriptItems
        }

        private enum CodingKeys: String, CodingKey {
            case transcriptItems = "TranscriptItems"
        }
    }

    public struct RealTimeContactAnalysisPointOfInterest: AWSDecodableShape {
        /// List of the transcript items (segments) that are associated with a given point of interest.
        public let transcriptItems: [RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]?

        @inlinable
        public init(transcriptItems: [RealTimeContactAnalysisTranscriptItemWithCharacterOffsets]? = nil) {
            self.transcriptItems = transcriptItems
        }

        private enum CodingKeys: String, CodingKey {
            case transcriptItems = "TranscriptItems"
        }
    }

    public struct RealTimeContactAnalysisSegmentAttachments: AWSDecodableShape {
        /// List of objects describing an individual attachment.
        public let attachments: [RealTimeContactAnalysisAttachment]
        /// The display name of the participant. Can be redacted.
        public let displayName: String?
        /// The identifier of the segment.
        public let id: String
        /// The identifier of the participant.
        public let participantId: String
        /// The role of the participant. For example, is it a customer, agent, or system.
        public let participantRole: ParticipantRole
        /// Field describing the time of the event. It can have different representations of time.
        public let time: RealTimeContactAnalysisTimeData

        @inlinable
        public init(attachments: [RealTimeContactAnalysisAttachment], displayName: String? = nil, id: String, participantId: String, participantRole: ParticipantRole, time: RealTimeContactAnalysisTimeData) {
            self.attachments = attachments
            self.displayName = displayName
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "Attachments"
            case displayName = "DisplayName"
            case id = "Id"
            case participantId = "ParticipantId"
            case participantRole = "ParticipantRole"
            case time = "Time"
        }
    }

    public struct RealTimeContactAnalysisSegmentCategories: AWSDecodableShape {
        /// Map between the name of the matched rule and RealTimeContactAnalysisCategoryDetails.
        public let matchedDetails: [String: RealTimeContactAnalysisCategoryDetails]

        @inlinable
        public init(matchedDetails: [String: RealTimeContactAnalysisCategoryDetails]) {
            self.matchedDetails = matchedDetails
        }

        private enum CodingKeys: String, CodingKey {
            case matchedDetails = "MatchedDetails"
        }
    }

    public struct RealTimeContactAnalysisSegmentEvent: AWSDecodableShape {
        /// The display name of the participant. Can be redacted.
        public let displayName: String?
        /// Type of the event. For example, application/vnd.amazonaws.connect.event.participant.left.
        public let eventType: String
        /// The identifier of the contact event.
        public let id: String
        /// The identifier of the participant.
        public let participantId: String?
        /// The role of the participant. For example, is it a customer, agent, or system.
        public let participantRole: ParticipantRole?
        /// Field describing the time of the event. It can have different representations of time.
        public let time: RealTimeContactAnalysisTimeData

        @inlinable
        public init(displayName: String? = nil, eventType: String, id: String, participantId: String? = nil, participantRole: ParticipantRole? = nil, time: RealTimeContactAnalysisTimeData) {
            self.displayName = displayName
            self.eventType = eventType
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case eventType = "EventType"
            case id = "Id"
            case participantId = "ParticipantId"
            case participantRole = "ParticipantRole"
            case time = "Time"
        }
    }

    public struct RealTimeContactAnalysisSegmentIssues: AWSDecodableShape {
        /// List of the issues detected.
        public let issuesDetected: [RealTimeContactAnalysisIssueDetected]

        @inlinable
        public init(issuesDetected: [RealTimeContactAnalysisIssueDetected]) {
            self.issuesDetected = issuesDetected
        }

        private enum CodingKeys: String, CodingKey {
            case issuesDetected = "IssuesDetected"
        }
    }

    public struct RealTimeContactAnalysisSegmentPostContactSummary: AWSDecodableShape {
        /// The content of the summary.
        public let content: String?
        /// If the summary failed to be generated, one of the following failure codes occurs:    QUOTA_EXCEEDED: The number of concurrent analytics jobs reached your service quota.    INSUFFICIENT_CONVERSATION_CONTENT: The conversation needs to have at least one turn from both the participants in order to generate the summary.    FAILED_SAFETY_GUIDELINES: The generated summary cannot be provided because it failed to meet system safety guidelines.    INVALID_ANALYSIS_CONFIGURATION: This code occurs when, for example, you're using a language that isn't supported by generative AI-powered post-contact summaries.     INTERNAL_ERROR: Internal system error.
        public let failureCode: RealTimeContactAnalysisPostContactSummaryFailureCode?
        /// Whether the summary was successfully COMPLETED or FAILED to be generated.
        public let status: RealTimeContactAnalysisPostContactSummaryStatus

        @inlinable
        public init(content: String? = nil, failureCode: RealTimeContactAnalysisPostContactSummaryFailureCode? = nil, status: RealTimeContactAnalysisPostContactSummaryStatus) {
            self.content = content
            self.failureCode = failureCode
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case failureCode = "FailureCode"
            case status = "Status"
        }
    }

    public struct RealTimeContactAnalysisSegmentTranscript: AWSDecodableShape {
        /// The content of the transcript. Can be redacted.
        public let content: String
        /// The type of content of the item. For example, text/plain.
        public let contentType: String?
        /// The display name of the participant.
        public let displayName: String?
        /// The identifier of the transcript.
        public let id: String
        /// The identifier of the participant.
        public let participantId: String
        /// The role of the participant. For example, is it a customer, agent, or system.
        public let participantRole: ParticipantRole
        /// Object describing redaction that was applied to the transcript. If transcript has the field it means part of the transcript was redacted.
        public let redaction: RealTimeContactAnalysisTranscriptItemRedaction?
        /// The sentiment detected for this piece of transcript.
        public let sentiment: RealTimeContactAnalysisSentimentLabel?
        /// Field describing the time of the event. It can have different representations of time.
        public let time: RealTimeContactAnalysisTimeData

        @inlinable
        public init(content: String, contentType: String? = nil, displayName: String? = nil, id: String, participantId: String, participantRole: ParticipantRole, redaction: RealTimeContactAnalysisTranscriptItemRedaction? = nil, sentiment: RealTimeContactAnalysisSentimentLabel? = nil, time: RealTimeContactAnalysisTimeData) {
            self.content = content
            self.contentType = contentType
            self.displayName = displayName
            self.id = id
            self.participantId = participantId
            self.participantRole = participantRole
            self.redaction = redaction
            self.sentiment = sentiment
            self.time = time
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
            case displayName = "DisplayName"
            case id = "Id"
            case participantId = "ParticipantId"
            case participantRole = "ParticipantRole"
            case redaction = "Redaction"
            case sentiment = "Sentiment"
            case time = "Time"
        }
    }

    public struct RealTimeContactAnalysisTranscriptItemRedaction: AWSDecodableShape {
        /// List of character intervals each describing a part of the text that was redacted. For OutputType.Raw, part of the original text that contains data that can be redacted. For  OutputType.Redacted, part of the string with redaction tag.
        public let characterOffsets: [RealTimeContactAnalysisCharacterInterval]?

        @inlinable
        public init(characterOffsets: [RealTimeContactAnalysisCharacterInterval]? = nil) {
            self.characterOffsets = characterOffsets
        }

        private enum CodingKeys: String, CodingKey {
            case characterOffsets = "CharacterOffsets"
        }
    }

    public struct RealTimeContactAnalysisTranscriptItemWithCharacterOffsets: AWSDecodableShape {
        /// List of character intervals within transcript content/text.
        public let characterOffsets: RealTimeContactAnalysisCharacterInterval?
        /// Transcript identifier. Matches the identifier from one of the TranscriptSegments.
        public let id: String

        @inlinable
        public init(characterOffsets: RealTimeContactAnalysisCharacterInterval? = nil, id: String) {
            self.characterOffsets = characterOffsets
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case characterOffsets = "CharacterOffsets"
            case id = "Id"
        }
    }

    public struct RealTimeContactAnalysisTranscriptItemWithContent: AWSDecodableShape {
        public let characterOffsets: RealTimeContactAnalysisCharacterInterval?
        /// Part of the transcript content that contains identified issue. Can be redacted
        public let content: String?
        /// Transcript identifier. Matches the identifier from one of the TranscriptSegments.
        public let id: String

        @inlinable
        public init(characterOffsets: RealTimeContactAnalysisCharacterInterval? = nil, content: String? = nil, id: String) {
            self.characterOffsets = characterOffsets
            self.content = content
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case characterOffsets = "CharacterOffsets"
            case content = "Content"
            case id = "Id"
        }
    }

    public struct Reference: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the reference
        public let arn: String?
        /// Status of the attachment reference type.
        public let status: ReferenceStatus?
        /// Relevant details why the reference was not successfully created.
        public let statusReason: String?
        /// The type of the reference. DATE must be of type Epoch timestamp.
        public let type: ReferenceType
        /// A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        public let value: String?

        @inlinable
        public init(arn: String? = nil, status: ReferenceStatus? = nil, statusReason: String? = nil, type: ReferenceType, value: String? = nil) {
            self.arn = arn
            self.status = status
            self.statusReason = statusReason
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 256)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^[-:/A-Za-z0-9]+$")
            try self.validate(self.statusReason, name: "statusReason", parent: name, max: 100)
            try self.validate(self.value, name: "value", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case status = "Status"
            case statusReason = "StatusReason"
            case type = "Type"
            case value = "Value"
        }
    }

    public struct ReleasePhoneNumberRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        @inlinable
        public init(clientToken: String? = ReleasePhoneNumberRequest.idempotencyToken(), phoneNumberId: String) {
            self.clientToken = clientToken
            self.phoneNumberId = phoneNumberId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodePath(self.phoneNumberId, key: "PhoneNumberId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ReplicateInstanceRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance. You can provide the InstanceId, or the entire ARN.
        public let instanceId: String
        /// The alias for the replicated instance. The ReplicaAlias must be unique.
        public let replicaAlias: String
        /// The Amazon Web Services Region where to replicate the Amazon Connect instance.
        public let replicaRegion: String

        @inlinable
        public init(clientToken: String? = ReplicateInstanceRequest.idempotencyToken(), instanceId: String, replicaAlias: String, replicaRegion: String) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.replicaAlias = replicaAlias
            self.replicaRegion = replicaRegion
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.replicaAlias, forKey: .replicaAlias)
            try container.encode(self.replicaRegion, forKey: .replicaRegion)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.replicaAlias, name: "replicaAlias", parent: name, max: 45)
            try self.validate(self.replicaAlias, name: "replicaAlias", parent: name, min: 1)
            try self.validate(self.replicaAlias, name: "replicaAlias", parent: name, pattern: "^(?!d-)([\\da-zA-Z]+)([-]*[\\da-zA-Z])*$")
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, max: 31)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, min: 8)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, pattern: "^[a-z]{2}(-[a-z]+){1,2}(-[0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case replicaAlias = "ReplicaAlias"
            case replicaRegion = "ReplicaRegion"
        }
    }

    public struct ReplicateInstanceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replicated instance.
        public let arn: String?
        /// The identifier of the replicated instance. You can find the instanceId in the ARN of the instance. The replicated instance has the same identifier as the instance it was replicated from.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct ReplicationConfiguration: AWSDecodableShape {
        /// The URL that is used to sign-in to your Amazon Connect instance according to your traffic distribution group configuration. For more information about sign-in and traffic distribution groups, see Important things to know in the Create traffic distribution groups topic in the Amazon Connect Administrator Guide.
        public let globalSignInEndpoint: String?
        /// A list of replication status summaries. The summaries contain details about the replication of configuration information for Amazon Connect resources, for each Amazon Web Services Region.
        public let replicationStatusSummaryList: [ReplicationStatusSummary]?
        /// The Amazon Web Services Region where the source Amazon Connect instance was created. This is the Region where the ReplicateInstance API was called to start the replication process.
        public let sourceRegion: String?

        @inlinable
        public init(globalSignInEndpoint: String? = nil, replicationStatusSummaryList: [ReplicationStatusSummary]? = nil, sourceRegion: String? = nil) {
            self.globalSignInEndpoint = globalSignInEndpoint
            self.replicationStatusSummaryList = replicationStatusSummaryList
            self.sourceRegion = sourceRegion
        }

        private enum CodingKeys: String, CodingKey {
            case globalSignInEndpoint = "GlobalSignInEndpoint"
            case replicationStatusSummaryList = "ReplicationStatusSummaryList"
            case sourceRegion = "SourceRegion"
        }
    }

    public struct ReplicationStatusSummary: AWSDecodableShape {
        /// The Amazon Web Services Region. This can be either the source or the replica Region, depending where it appears in the summary list.
        public let region: String?
        /// The state of the replication.
        public let replicationStatus: InstanceReplicationStatus?
        /// A description of the replication status. Use this information to resolve any issues that are preventing the successful replication of your Amazon Connect instance to another Region.
        public let replicationStatusReason: String?

        @inlinable
        public init(region: String? = nil, replicationStatus: InstanceReplicationStatus? = nil, replicationStatusReason: String? = nil) {
            self.region = region
            self.replicationStatus = replicationStatus
            self.replicationStatusReason = replicationStatusReason
        }

        private enum CodingKeys: String, CodingKey {
            case region = "Region"
            case replicationStatus = "ReplicationStatus"
            case replicationStatusReason = "ReplicationStatusReason"
        }
    }

    public struct RequiredFieldInfo: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the field.
        public let id: TaskTemplateFieldIdentifier?

        @inlinable
        public init(id: TaskTemplateFieldIdentifier? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct ResourceInUseException: AWSErrorShape {
        public let message: String?
        /// The identifier for the resource.
        public let resourceId: String?
        /// The type of resource.
        public let resourceType: ResourceType?

        @inlinable
        public init(message: String? = nil, resourceId: String? = nil, resourceType: ResourceType? = nil) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resourceId = "ResourceId"
            case resourceType = "ResourceType"
        }
    }

    public struct ResourceTagsSearchCriteria: AWSEncodableShape {
        /// The search criteria to be used to return tags.
        public let tagSearchCondition: TagSearchCondition?

        @inlinable
        public init(tagSearchCondition: TagSearchCondition? = nil) {
            self.tagSearchCondition = tagSearchCondition
        }

        public func validate(name: String) throws {
            try self.tagSearchCondition?.validate(name: "\(name).tagSearchCondition")
        }

        private enum CodingKeys: String, CodingKey {
            case tagSearchCondition = "TagSearchCondition"
        }
    }

    public struct ResumeContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The type of recording being operated on.
        public let contactRecordingType: ContactRecordingType?
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactId: String, contactRecordingType: ContactRecordingType? = nil, initialContactId: String, instanceId: String) {
            self.contactId = contactId
            self.contactRecordingType = contactRecordingType
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case contactRecordingType = "ContactRecordingType"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct ResumeContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ResumeContactRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String?
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowId: String? = nil, contactId: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct ResumeContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RoutingCriteria: AWSDecodableShape {
        /// The timestamp indicating when the routing criteria is set to active. A routing criteria is activated when contact is transferred to a queue. ActivationTimestamp will be set on routing criteria for contacts in agent queue even though Routing criteria is never activated for contacts in agent queue.
        public let activationTimestamp: Date?
        /// Information about the index of the routing criteria.
        public let index: Int?
        /// List of routing steps. When Amazon Connect does not find an available agent meeting the requirements in a step for a given step duration, the routing criteria will move on to the next step sequentially until a join is completed with an agent. When all steps are exhausted, the contact will be offered to any agent in the queue.
        public let steps: [Step]?

        @inlinable
        public init(activationTimestamp: Date? = nil, index: Int? = nil, steps: [Step]? = nil) {
            self.activationTimestamp = activationTimestamp
            self.index = index
            self.steps = steps
        }

        private enum CodingKeys: String, CodingKey {
            case activationTimestamp = "ActivationTimestamp"
            case index = "Index"
            case steps = "Steps"
        }
    }

    public struct RoutingCriteriaInput: AWSEncodableShape {
        /// When Amazon Connect does not find an available agent meeting the requirements in a step for a given step duration, the routing criteria will move on to the next step sequentially until a join is completed with an agent. When all steps are exhausted, the contact will be offered to any agent in the queue.
        public let steps: [RoutingCriteriaInputStep]?

        @inlinable
        public init(steps: [RoutingCriteriaInputStep]? = nil) {
            self.steps = steps
        }

        public func validate(name: String) throws {
            try self.steps?.forEach {
                try $0.validate(name: "\(name).steps[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case steps = "Steps"
        }
    }

    public struct RoutingCriteriaInputStep: AWSEncodableShape {
        /// An object to specify the expiration of a routing step.
        public let expiry: RoutingCriteriaInputStepExpiry?
        /// A tagged union to specify expression for a routing step.
        public let expression: Expression?

        @inlinable
        public init(expiry: RoutingCriteriaInputStepExpiry? = nil, expression: Expression? = nil) {
            self.expiry = expiry
            self.expression = expression
        }

        public func validate(name: String) throws {
            try self.expression?.validate(name: "\(name).expression")
        }

        private enum CodingKeys: String, CodingKey {
            case expiry = "Expiry"
            case expression = "Expression"
        }
    }

    public struct RoutingCriteriaInputStepExpiry: AWSEncodableShape {
        /// The number of seconds that the contact will be routed only to agents matching this routing step, if expiry was configured for this routing step.
        public let durationInSeconds: Int?

        @inlinable
        public init(durationInSeconds: Int? = nil) {
            self.durationInSeconds = durationInSeconds
        }

        private enum CodingKeys: String, CodingKey {
            case durationInSeconds = "DurationInSeconds"
        }
    }

    public struct RoutingProfile: AWSDecodableShape {
        /// Whether agents with this routing profile will have their routing order calculated based on time since their last inbound contact or longest idle time.
        public let agentAvailabilityTimer: AgentAvailabilityTimer?
        /// The IDs of the associated queue.
        public let associatedQueueIds: [String]?
        /// The identifier of the default outbound queue for this routing profile.
        public let defaultOutboundQueueId: String?
        /// The description of the routing profile.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String?
        /// Whether this a default routing profile.
        public let isDefault: Bool?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public let mediaConcurrencies: [MediaConcurrency]?
        /// The name of the routing profile.
        public let name: String?
        /// The number of associated queues in routing profile.
        public let numberOfAssociatedQueues: Int64?
        /// The number of associated users in routing profile.
        public let numberOfAssociatedUsers: Int64?
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let routingProfileArn: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(agentAvailabilityTimer: AgentAvailabilityTimer? = nil, associatedQueueIds: [String]? = nil, defaultOutboundQueueId: String? = nil, description: String? = nil, instanceId: String? = nil, isDefault: Bool? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, mediaConcurrencies: [MediaConcurrency]? = nil, name: String? = nil, numberOfAssociatedQueues: Int64? = nil, numberOfAssociatedUsers: Int64? = nil, routingProfileArn: String? = nil, routingProfileId: String? = nil, tags: [String: String]? = nil) {
            self.agentAvailabilityTimer = agentAvailabilityTimer
            self.associatedQueueIds = associatedQueueIds
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.description = description
            self.instanceId = instanceId
            self.isDefault = isDefault
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.mediaConcurrencies = mediaConcurrencies
            self.name = name
            self.numberOfAssociatedQueues = numberOfAssociatedQueues
            self.numberOfAssociatedUsers = numberOfAssociatedUsers
            self.routingProfileArn = routingProfileArn
            self.routingProfileId = routingProfileId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case agentAvailabilityTimer = "AgentAvailabilityTimer"
            case associatedQueueIds = "AssociatedQueueIds"
            case defaultOutboundQueueId = "DefaultOutboundQueueId"
            case description = "Description"
            case instanceId = "InstanceId"
            case isDefault = "IsDefault"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case mediaConcurrencies = "MediaConcurrencies"
            case name = "Name"
            case numberOfAssociatedQueues = "NumberOfAssociatedQueues"
            case numberOfAssociatedUsers = "NumberOfAssociatedUsers"
            case routingProfileArn = "RoutingProfileArn"
            case routingProfileId = "RoutingProfileId"
            case tags = "Tags"
        }
    }

    public struct RoutingProfileQueueConfig: AWSEncodableShape {
        /// The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see Queues: priority and delay in the Amazon Connect Administrator Guide.
        public let delay: Int
        /// The order in which contacts are to be handled for the queue. For more information, see Queues: priority and delay.
        public let priority: Int
        /// Contains information about a queue resource.
        public let queueReference: RoutingProfileQueueReference

        @inlinable
        public init(delay: Int, priority: Int, queueReference: RoutingProfileQueueReference) {
            self.delay = delay
            self.priority = priority
            self.queueReference = queueReference
        }

        public func validate(name: String) throws {
            try self.validate(self.delay, name: "delay", parent: name, max: 9999)
            try self.validate(self.delay, name: "delay", parent: name, min: 0)
            try self.validate(self.priority, name: "priority", parent: name, max: 99)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delay = "Delay"
            case priority = "Priority"
            case queueReference = "QueueReference"
        }
    }

    public struct RoutingProfileQueueConfigSummary: AWSDecodableShape {
        /// The channels this queue supports.
        public let channel: Channel
        /// The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see Queues: priority and delay in the Amazon Connect Administrator Guide.
        public let delay: Int
        /// The order in which contacts are to be handled for the queue. For more information, see Queues: priority and delay.
        public let priority: Int
        /// The Amazon Resource Name (ARN) of the queue.
        public let queueArn: String
        /// The identifier for the queue.
        public let queueId: String
        /// The name of the queue.
        public let queueName: String

        @inlinable
        public init(channel: Channel, delay: Int, priority: Int, queueArn: String, queueId: String, queueName: String) {
            self.channel = channel
            self.delay = delay
            self.priority = priority
            self.queueArn = queueArn
            self.queueId = queueId
            self.queueName = queueName
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case delay = "Delay"
            case priority = "Priority"
            case queueArn = "QueueArn"
            case queueId = "QueueId"
            case queueName = "QueueName"
        }
    }

    public struct RoutingProfileQueueReference: AWSEncodableShape {
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public let channel: Channel
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(channel: Channel, queueId: String) {
            self.channel = channel
            self.queueId = queueId
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case queueId = "QueueId"
        }
    }

    public struct RoutingProfileReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let arn: String?
        /// The identifier of the routing profile.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct RoutingProfileSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [RoutingProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [RoutingProfileSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are associatedQueueIds, name, description, and resourceID.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [RoutingProfileSearchCriteria]? = nil, orConditions: [RoutingProfileSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct RoutingProfileSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct RoutingProfileSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let arn: String?
        /// The identifier of the routing profile.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the routing profile.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct Rule: AWSDecodableShape {
        /// A list of actions to be run when the rule is triggered.
        public let actions: [RuleAction]
        /// The timestamp for when the rule was created.
        public let createdTime: Date
        /// The conditions of the rule.
        public let function: String
        /// The Amazon Resource Name (ARN) of the user who last updated the rule.
        public let lastUpdatedBy: String
        /// The timestamp for the when the rule was last updated.
        public let lastUpdatedTime: Date
        /// The name of the rule.
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// The Amazon Resource Name (ARN) of the rule.
        public let ruleArn: String
        /// A unique identifier for the rule.
        public let ruleId: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The event source to trigger the rule.
        public let triggerEventSource: RuleTriggerEventSource

        @inlinable
        public init(actions: [RuleAction], createdTime: Date, function: String, lastUpdatedBy: String, lastUpdatedTime: Date, name: String, publishStatus: RulePublishStatus, ruleArn: String, ruleId: String, tags: [String: String]? = nil, triggerEventSource: RuleTriggerEventSource) {
            self.actions = actions
            self.createdTime = createdTime
            self.function = function
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.tags = tags
            self.triggerEventSource = triggerEventSource
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case createdTime = "CreatedTime"
            case function = "Function"
            case lastUpdatedBy = "LastUpdatedBy"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case publishStatus = "PublishStatus"
            case ruleArn = "RuleArn"
            case ruleId = "RuleId"
            case tags = "Tags"
            case triggerEventSource = "TriggerEventSource"
        }
    }

    public struct RuleAction: AWSEncodableShape & AWSDecodableShape {
        /// The type of action that creates a rule.
        public let actionType: ActionType
        /// Information about the contact category action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public let assignContactCategoryAction: AssignContactCategoryActionDefinition?
        /// Information about the create case action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnPostChatAnalysisAvailable.
        public let createCaseAction: CreateCaseActionDefinition?
        /// Information about the end associated tasks action. Supported only for TriggerEventSource values: OnCaseUpdate.
        public let endAssociatedTasksAction: EndAssociatedTasksActionDefinition?
        /// Information about the EventBridge action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnContactEvaluationSubmit | OnMetricDataUpdate
        public let eventBridgeAction: EventBridgeActionDefinition?
        /// Information about the send notification action. Supported only for TriggerEventSource values: OnPostCallAnalysisAvailable | OnRealTimeCallAnalysisAvailable | OnRealTimeChatAnalysisAvailable | OnPostChatAnalysisAvailable | OnContactEvaluationSubmit | OnMetricDataUpdate
        public let sendNotificationAction: SendNotificationActionDefinition?
        /// Information about the submit automated evaluation action.
        public let submitAutoEvaluationAction: SubmitAutoEvaluationActionDefinition?
        /// Information about the task action. This field is required if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public let taskAction: TaskActionDefinition?
        /// Information about the update case action. Supported only for TriggerEventSource values: OnCaseCreate | OnCaseUpdate.
        public let updateCaseAction: UpdateCaseActionDefinition?

        @inlinable
        public init(actionType: ActionType, assignContactCategoryAction: AssignContactCategoryActionDefinition? = nil, createCaseAction: CreateCaseActionDefinition? = nil, endAssociatedTasksAction: EndAssociatedTasksActionDefinition? = nil, eventBridgeAction: EventBridgeActionDefinition? = nil, sendNotificationAction: SendNotificationActionDefinition? = nil, submitAutoEvaluationAction: SubmitAutoEvaluationActionDefinition? = nil, taskAction: TaskActionDefinition? = nil, updateCaseAction: UpdateCaseActionDefinition? = nil) {
            self.actionType = actionType
            self.assignContactCategoryAction = assignContactCategoryAction
            self.createCaseAction = createCaseAction
            self.endAssociatedTasksAction = endAssociatedTasksAction
            self.eventBridgeAction = eventBridgeAction
            self.sendNotificationAction = sendNotificationAction
            self.submitAutoEvaluationAction = submitAutoEvaluationAction
            self.taskAction = taskAction
            self.updateCaseAction = updateCaseAction
        }

        public func validate(name: String) throws {
            try self.createCaseAction?.validate(name: "\(name).createCaseAction")
            try self.eventBridgeAction?.validate(name: "\(name).eventBridgeAction")
            try self.sendNotificationAction?.validate(name: "\(name).sendNotificationAction")
            try self.submitAutoEvaluationAction?.validate(name: "\(name).submitAutoEvaluationAction")
            try self.taskAction?.validate(name: "\(name).taskAction")
            try self.updateCaseAction?.validate(name: "\(name).updateCaseAction")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "ActionType"
            case assignContactCategoryAction = "AssignContactCategoryAction"
            case createCaseAction = "CreateCaseAction"
            case endAssociatedTasksAction = "EndAssociatedTasksAction"
            case eventBridgeAction = "EventBridgeAction"
            case sendNotificationAction = "SendNotificationAction"
            case submitAutoEvaluationAction = "SubmitAutoEvaluationAction"
            case taskAction = "TaskAction"
            case updateCaseAction = "UpdateCaseAction"
        }
    }

    public struct RuleSummary: AWSDecodableShape {
        /// A list of ActionTypes associated with a rule.
        public let actionSummaries: [ActionSummary]
        /// The timestamp for when the rule was created.
        public let createdTime: Date
        /// The name of the event source.
        public let eventSourceName: EventSourceName
        /// The timestamp for when the rule was last updated.
        public let lastUpdatedTime: Date
        /// The name of the rule.
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// The Amazon Resource Name (ARN) of the rule.
        public let ruleArn: String
        /// A unique identifier for the rule.
        public let ruleId: String

        @inlinable
        public init(actionSummaries: [ActionSummary], createdTime: Date, eventSourceName: EventSourceName, lastUpdatedTime: Date, name: String, publishStatus: RulePublishStatus, ruleArn: String, ruleId: String) {
            self.actionSummaries = actionSummaries
            self.createdTime = createdTime
            self.eventSourceName = eventSourceName
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case actionSummaries = "ActionSummaries"
            case createdTime = "CreatedTime"
            case eventSourceName = "EventSourceName"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case publishStatus = "PublishStatus"
            case ruleArn = "RuleArn"
            case ruleId = "RuleId"
        }
    }

    public struct RuleTriggerEventSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the event source.
        public let eventSourceName: EventSourceName
        /// The identifier for the integration association.
        public let integrationAssociationId: String?

        @inlinable
        public init(eventSourceName: EventSourceName, integrationAssociationId: String? = nil) {
            self.eventSourceName = eventSourceName
            self.integrationAssociationId = integrationAssociationId
        }

        public func validate(name: String) throws {
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventSourceName = "EventSourceName"
            case integrationAssociationId = "IntegrationAssociationId"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket name.
        public let bucketName: String
        /// The S3 bucket prefix.
        public let bucketPrefix: String
        /// The Amazon S3 encryption configuration.
        public let encryptionConfig: EncryptionConfig?

        @inlinable
        public init(bucketName: String, bucketPrefix: String, encryptionConfig: EncryptionConfig? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.encryptionConfig = encryptionConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 128)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 1)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 128)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, min: 1)
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case bucketPrefix = "BucketPrefix"
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct SearchAgentStatusesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return agent statuses.
        public let searchCriteria: AgentStatusSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: AgentStatusSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: AgentStatusSearchCriteria? = nil, searchFilter: AgentStatusSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchAgentStatusesResponse: AWSDecodableShape {
        /// The search criteria to be used to return agent statuses.
        public let agentStatuses: [AgentStatus]?
        /// The total number of agent statuses which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(agentStatuses: [AgentStatus]? = nil, approximateTotalCount: Int64? = nil, nextToken: String? = nil) {
            self.agentStatuses = agentStatuses
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatuses = "AgentStatuses"
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
        }
    }

    public struct SearchAvailablePhoneNumbersRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can find the instance ID in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
        public let instanceId: String?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode
        /// The prefix of the phone number. If provided, it must contain + as part of the country code.
        public let phoneNumberPrefix: String?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
        public let targetArn: String?

        @inlinable
        public init(instanceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode, phoneNumberPrefix: String? = nil, phoneNumberType: PhoneNumberType, targetArn: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberPrefix = phoneNumberPrefix
            self.phoneNumberType = phoneNumberType
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.phoneNumberPrefix, name: "phoneNumberPrefix", parent: name, pattern: "^\\\\+?[0-9]{1,11}$")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberPrefix = "PhoneNumberPrefix"
            case phoneNumberType = "PhoneNumberType"
            case targetArn = "TargetArn"
        }
    }

    public struct SearchAvailablePhoneNumbersResponse: AWSDecodableShape {
        /// A list of available phone numbers that you can claim to your Amazon Connect instance or traffic distribution group.
        public let availableNumbersList: [AvailableNumberSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(availableNumbersList: [AvailableNumberSummary]? = nil, nextToken: String? = nil) {
            self.availableNumbersList = availableNumbersList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case availableNumbersList = "AvailableNumbersList"
            case nextToken = "NextToken"
        }
    }

    public struct SearchContactFlowModulesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return flow modules.  The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will result in invalid results.
        public let searchCriteria: ContactFlowModuleSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: ContactFlowModuleSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: ContactFlowModuleSearchCriteria? = nil, searchFilter: ContactFlowModuleSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchContactFlowModulesResponse: AWSDecodableShape {
        /// The total number of flows which matched your search query.
        public let approximateTotalCount: Int64?
        /// The search criteria to be used to return flow modules.
        public let contactFlowModules: [ContactFlowModule]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, contactFlowModules: [ContactFlowModule]? = nil, nextToken: String? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.contactFlowModules = contactFlowModules
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case contactFlowModules = "ContactFlowModules"
            case nextToken = "NextToken"
        }
    }

    public struct SearchContactFlowsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return flows.  The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will result in invalid results.
        public let searchCriteria: ContactFlowSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: ContactFlowSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: ContactFlowSearchCriteria? = nil, searchFilter: ContactFlowSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchContactFlowsResponse: AWSDecodableShape {
        /// The total number of flows which matched your search query.
        public let approximateTotalCount: Int64?
        /// Information about the flows.
        public let contactFlows: [ContactFlow]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, contactFlows: [ContactFlow]? = nil, nextToken: String? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.contactFlows = contactFlows
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case contactFlows = "ContactFlows"
            case nextToken = "NextToken"
        }
    }

    public struct SearchContactsRequest: AWSEncodableShape {
        /// The identifier of Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return contacts.
        public let searchCriteria: SearchCriteria?
        /// Specifies a field to sort by and a sort order.
        public let sort: Sort?
        /// Time range that you want to search results.
        public let timeRange: SearchContactsTimeRange

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: SearchCriteria? = nil, sort: Sort? = nil, timeRange: SearchContactsTimeRange) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.sort = sort
            self.timeRange = timeRange
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchCriteria?.validate(name: "\(name).searchCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case sort = "Sort"
            case timeRange = "TimeRange"
        }
    }

    public struct SearchContactsResponse: AWSDecodableShape {
        /// Information about the contacts.
        public let contacts: [ContactSearchSummary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The total number of contacts which matched your search query.
        public let totalCount: Int64?

        @inlinable
        public init(contacts: [ContactSearchSummary], nextToken: String? = nil, totalCount: Int64? = nil) {
            self.contacts = contacts
            self.nextToken = nextToken
            self.totalCount = totalCount
        }

        private enum CodingKeys: String, CodingKey {
            case contacts = "Contacts"
            case nextToken = "NextToken"
            case totalCount = "TotalCount"
        }
    }

    public struct SearchContactsTimeRange: AWSEncodableShape {
        /// The end time of the time range.
        public let endTime: Date
        /// The start time of the time range.
        public let startTime: Date
        /// The type of timestamp to search.
        public let type: SearchContactsTimeRangeType

        @inlinable
        public init(endTime: Date, startTime: Date, type: SearchContactsTimeRangeType) {
            self.endTime = endTime
            self.startTime = startTime
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case startTime = "StartTime"
            case type = "Type"
        }
    }

    public struct SearchCriteria: AWSEncodableShape {
        /// The agent hierarchy groups of the agent at the time of handling the contact.
        public let agentHierarchyGroups: AgentHierarchyGroups?
        /// The identifiers of agents who handled the contacts.
        public let agentIds: [String]?
        /// The list of channels associated with contacts.
        public let channels: [Channel]?
        /// Search criteria based on analysis outputs from Amazon Connect Contact Lens.
        public let contactAnalysis: ContactAnalysis?
        /// The list of initiation methods associated with contacts.
        public let initiationMethods: [ContactInitiationMethod]?
        /// The list of queue IDs associated with contacts.
        public let queueIds: [String]?
        /// The search criteria based on user-defined contact attributes that have been configured for contact search. For more information, see Search by custom contact attributes in the Amazon Connect Administrator Guide.  To use SearchableContactAttributes in a search request, the GetContactAttributes action is required to perform an API request. For more information, see https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonconnect.html#amazonconnect-actions-as-permissionsActions defined by Amazon Connect.
        public let searchableContactAttributes: SearchableContactAttributes?
        /// The search criteria based on searchable segment attributes of a contact.
        public let searchableSegmentAttributes: SearchableSegmentAttributes?

        @inlinable
        public init(agentHierarchyGroups: AgentHierarchyGroups? = nil, agentIds: [String]? = nil, channels: [Channel]? = nil, contactAnalysis: ContactAnalysis? = nil, initiationMethods: [ContactInitiationMethod]? = nil, queueIds: [String]? = nil, searchableContactAttributes: SearchableContactAttributes? = nil, searchableSegmentAttributes: SearchableSegmentAttributes? = nil) {
            self.agentHierarchyGroups = agentHierarchyGroups
            self.agentIds = agentIds
            self.channels = channels
            self.contactAnalysis = contactAnalysis
            self.initiationMethods = initiationMethods
            self.queueIds = queueIds
            self.searchableContactAttributes = searchableContactAttributes
            self.searchableSegmentAttributes = searchableSegmentAttributes
        }

        public func validate(name: String) throws {
            try self.agentHierarchyGroups?.validate(name: "\(name).agentHierarchyGroups")
            try self.agentIds?.forEach {
                try validate($0, name: "agentIds[]", parent: name, max: 256)
                try validate($0, name: "agentIds[]", parent: name, min: 1)
            }
            try self.validate(self.agentIds, name: "agentIds", parent: name, max: 100)
            try self.contactAnalysis?.validate(name: "\(name).contactAnalysis")
            try self.validate(self.queueIds, name: "queueIds", parent: name, max: 100)
            try self.searchableContactAttributes?.validate(name: "\(name).searchableContactAttributes")
            try self.searchableSegmentAttributes?.validate(name: "\(name).searchableSegmentAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case agentHierarchyGroups = "AgentHierarchyGroups"
            case agentIds = "AgentIds"
            case channels = "Channels"
            case contactAnalysis = "ContactAnalysis"
            case initiationMethods = "InitiationMethods"
            case queueIds = "QueueIds"
            case searchableContactAttributes = "SearchableContactAttributes"
            case searchableSegmentAttributes = "SearchableSegmentAttributes"
        }
    }

    public struct SearchEmailAddressesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return email addresses.
        public let searchCriteria: EmailAddressSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: EmailAddressSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: EmailAddressSearchCriteria? = nil, searchFilter: EmailAddressSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchEmailAddressesResponse: AWSDecodableShape {
        /// The total number of email addresses which matched your search query.
        public let approximateTotalCount: Int64?
        /// List of email addresses matching SearchFilter and SearchCriteria
        public let emailAddresses: [EmailAddressMetadata]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, emailAddresses: [EmailAddressMetadata]? = nil, nextToken: String? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.emailAddresses = emailAddresses
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case emailAddresses = "EmailAddresses"
            case nextToken = "NextToken"
        }
    }

    public struct SearchHoursOfOperationOverridesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximum number of results to return per page. Valid Range: Minimum value of 1. Maximum value of 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. Length Constraints: Minimum length of 1. Maximum length of 2500.
        public let nextToken: String?
        /// The search criteria to be used to return hours of operations overrides.
        public let searchCriteria: HoursOfOperationOverrideSearchCriteria?
        public let searchFilter: HoursOfOperationSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: HoursOfOperationOverrideSearchCriteria? = nil, searchFilter: HoursOfOperationSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchCriteria?.validate(name: "\(name).searchCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchHoursOfOperationOverridesResponse: AWSDecodableShape {
        /// The total number of hours of operations which matched your search query.
        public let approximateTotalCount: Int64?
        /// Information about the hours of operations overrides.
        public let hoursOfOperationOverrides: [HoursOfOperationOverride]?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. Length Constraints: Minimum length of 1. Maximum length of 2500.
        public let nextToken: String?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, hoursOfOperationOverrides: [HoursOfOperationOverride]? = nil, nextToken: String? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.hoursOfOperationOverrides = hoursOfOperationOverrides
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case hoursOfOperationOverrides = "HoursOfOperationOverrides"
            case nextToken = "NextToken"
        }
    }

    public struct SearchHoursOfOperationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return hours of operations.
        public let searchCriteria: HoursOfOperationSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: HoursOfOperationSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: HoursOfOperationSearchCriteria? = nil, searchFilter: HoursOfOperationSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchHoursOfOperationsResponse: AWSDecodableShape {
        /// The total number of hours of operations which matched your search query.
        public let approximateTotalCount: Int64?
        /// Information about the hours of operations.
        public let hoursOfOperations: [HoursOfOperation]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, hoursOfOperations: [HoursOfOperation]? = nil, nextToken: String? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.hoursOfOperations = hoursOfOperations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case hoursOfOperations = "HoursOfOperations"
            case nextToken = "NextToken"
        }
    }

    public struct SearchPredefinedAttributesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return predefined attributes.
        public let searchCriteria: PredefinedAttributeSearchCriteria?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: PredefinedAttributeSearchCriteria? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
        }
    }

    public struct SearchPredefinedAttributesResponse: AWSDecodableShape {
        /// The approximate number of predefined attributes which matched your search query.
        public let approximateTotalCount: Int64?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// Predefined attributes matched by the search criteria.
        public let predefinedAttributes: [PredefinedAttribute]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, predefinedAttributes: [PredefinedAttribute]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.predefinedAttributes = predefinedAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case predefinedAttributes = "PredefinedAttributes"
        }
    }

    public struct SearchPromptsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return prompts.
        public let searchCriteria: PromptSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: PromptSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: PromptSearchCriteria? = nil, searchFilter: PromptSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchPromptsResponse: AWSDecodableShape {
        /// The total number of quick connects which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the prompts.
        public let prompts: [Prompt]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, prompts: [Prompt]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.prompts = prompts
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case prompts = "Prompts"
        }
    }

    public struct SearchQueuesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return queues.  The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
        public let searchCriteria: QueueSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: QueueSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: QueueSearchCriteria? = nil, searchFilter: QueueSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchQueuesResponse: AWSDecodableShape {
        /// The total number of queues which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the queues.
        public let queues: [Queue]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, queues: [Queue]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.queues = queues
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case queues = "Queues"
        }
    }

    public struct SearchQuickConnectsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return quick connects.
        public let searchCriteria: QuickConnectSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: QuickConnectSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: QuickConnectSearchCriteria? = nil, searchFilter: QuickConnectSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchQuickConnectsResponse: AWSDecodableShape {
        /// The total number of quick connects which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the quick connects.
        public let quickConnects: [QuickConnect]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, quickConnects: [QuickConnect]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.quickConnects = quickConnects
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case quickConnects = "QuickConnects"
        }
    }

    public struct SearchResourceTagsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The list of resource types to be used to search tags from. If not provided or if any empty list is provided, this API will search from all supported resource types. Note that lowercase and - are required.  Supported resource types    agent   agent-state   routing-profile   standard-queue   security-profile   operating-hours   prompt   contact-flow   flow- module   transfer-destination (also known as quick connect)
        public let resourceTypes: [String]?
        /// The search criteria to be used to return tags.
        public let searchCriteria: ResourceTagsSearchCriteria?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, resourceTypes: [String]? = nil, searchCriteria: ResourceTagsSearchCriteria? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceTypes = resourceTypes
            self.searchCriteria = searchCriteria
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.searchCriteria?.validate(name: "\(name).searchCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case resourceTypes = "ResourceTypes"
            case searchCriteria = "SearchCriteria"
        }
    }

    public struct SearchResourceTagsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A list of tags used in the Amazon Connect instance.
        public let tags: [TagSet]?

        @inlinable
        public init(nextToken: String? = nil, tags: [TagSet]? = nil) {
            self.nextToken = nextToken
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case tags = "Tags"
        }
    }

    public struct SearchRoutingProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return routing profiles.  The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
        public let searchCriteria: RoutingProfileSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: RoutingProfileSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: RoutingProfileSearchCriteria? = nil, searchFilter: RoutingProfileSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchRoutingProfilesResponse: AWSDecodableShape {
        /// The total number of routing profiles which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the routing profiles.
        public let routingProfiles: [RoutingProfile]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, routingProfiles: [RoutingProfile]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.routingProfiles = routingProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case routingProfiles = "RoutingProfiles"
        }
    }

    public struct SearchSecurityProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return security profiles.   The name field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.   The currently supported value for FieldName: name
        public let searchCriteria: SecurityProfileSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: SecurityProfilesSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: SecurityProfileSearchCriteria? = nil, searchFilter: SecurityProfilesSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchSecurityProfilesResponse: AWSDecodableShape {
        /// The total number of security profiles which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the security profiles.
        public let securityProfiles: [SecurityProfileSearchSummary]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, securityProfiles: [SecurityProfileSearchSummary]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.securityProfiles = securityProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case securityProfiles = "SecurityProfiles"
        }
    }

    public struct SearchUserHierarchyGroupsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return UserHierarchyGroups.
        public let searchCriteria: UserHierarchyGroupSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: UserHierarchyGroupSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: UserHierarchyGroupSearchCriteria? = nil, searchFilter: UserHierarchyGroupSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchUserHierarchyGroupsResponse: AWSDecodableShape {
        /// The total number of userHierarchyGroups which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the userHierarchyGroups.
        public let userHierarchyGroups: [HierarchyGroup]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, userHierarchyGroups: [HierarchyGroup]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.userHierarchyGroups = userHierarchyGroups
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case userHierarchyGroups = "UserHierarchyGroups"
        }
    }

    public struct SearchUsersRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        public let searchCriteria: UserSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: UserSearchFilter?

        @inlinable
        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: UserSearchCriteria? = nil, searchFilter: UserSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 500)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchUsersResponse: AWSDecodableShape {
        /// The total number of users who matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the users.
        public let users: [UserSearchSummary]?

        @inlinable
        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, users: [UserSearchSummary]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case users = "Users"
        }
    }

    public struct SearchVocabulariesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The starting pattern of the name of the vocabulary.
        public let nameStartsWith: String?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The current state of the custom vocabulary.
        public let state: VocabularyState?

        @inlinable
        public init(instanceId: String, languageCode: VocabularyLanguageCode? = nil, maxResults: Int? = nil, nameStartsWith: String? = nil, nextToken: String? = nil, state: VocabularyState? = nil) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.maxResults = maxResults
            self.nameStartsWith = nameStartsWith
            self.nextToken = nextToken
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.languageCode, forKey: .languageCode)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nameStartsWith, forKey: .nameStartsWith)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encodeIfPresent(self.state, forKey: .state)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameStartsWith, name: "nameStartsWith", parent: name, max: 140)
            try self.validate(self.nameStartsWith, name: "nameStartsWith", parent: name, min: 1)
            try self.validate(self.nameStartsWith, name: "nameStartsWith", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131070)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "LanguageCode"
            case maxResults = "MaxResults"
            case nameStartsWith = "NameStartsWith"
            case nextToken = "NextToken"
            case state = "State"
        }
    }

    public struct SearchVocabulariesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The list of the available custom vocabularies.
        public let vocabularySummaryList: [VocabularySummary]?

        @inlinable
        public init(nextToken: String? = nil, vocabularySummaryList: [VocabularySummary]? = nil) {
            self.nextToken = nextToken
            self.vocabularySummaryList = vocabularySummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case vocabularySummaryList = "VocabularySummaryList"
        }
    }

    public struct SearchableContactAttributes: AWSEncodableShape {
        /// The list of criteria based on user-defined contact attributes that are configured for contact search.
        public let criteria: [SearchableContactAttributesCriteria]
        /// The match type combining search criteria using multiple searchable contact attributes.
        public let matchType: SearchContactsMatchType?

        @inlinable
        public init(criteria: [SearchableContactAttributesCriteria], matchType: SearchContactsMatchType? = nil) {
            self.criteria = criteria
            self.matchType = matchType
        }

        public func validate(name: String) throws {
            try self.criteria.forEach {
                try $0.validate(name: "\(name).criteria[]")
            }
            try self.validate(self.criteria, name: "criteria", parent: name, max: 15)
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "Criteria"
            case matchType = "MatchType"
        }
    }

    public struct SearchableContactAttributesCriteria: AWSEncodableShape {
        /// The key containing a searchable user-defined contact attribute.
        public let key: String
        /// The list of values to search for within a user-defined contact attribute.
        public let values: [String]

        @inlinable
        public init(key: String, values: [String]) {
            self.key = key
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 100)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 100)
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case values = "Values"
        }
    }

    public struct SearchableSegmentAttributes: AWSEncodableShape {
        /// The list of criteria based on searchable segment attributes.
        public let criteria: [SearchableSegmentAttributesCriteria]
        /// The match type combining search criteria using multiple searchable segment attributes.
        public let matchType: SearchContactsMatchType?

        @inlinable
        public init(criteria: [SearchableSegmentAttributesCriteria], matchType: SearchContactsMatchType? = nil) {
            self.criteria = criteria
            self.matchType = matchType
        }

        public func validate(name: String) throws {
            try self.criteria.forEach {
                try $0.validate(name: "\(name).criteria[]")
            }
            try self.validate(self.criteria, name: "criteria", parent: name, max: 15)
            try self.validate(self.criteria, name: "criteria", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "Criteria"
            case matchType = "MatchType"
        }
    }

    public struct SearchableSegmentAttributesCriteria: AWSEncodableShape {
        /// The key containing a searchable segment attribute.
        public let key: String
        /// The list of values to search for within a searchable segment attribute.
        public let values: [String]

        @inlinable
        public init(key: String, values: [String]) {
            self.key = key
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 64)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 128)
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case values = "Values"
        }
    }

    public struct SecurityKey: AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?
        /// When the security key was created.
        public let creationTime: Date?
        /// The key of the security key.
        public let key: String?

        @inlinable
        public init(associationId: String? = nil, creationTime: Date? = nil, key: String? = nil) {
            self.associationId = associationId
            self.creationTime = creationTime
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case creationTime = "CreationTime"
            case key = "Key"
        }
    }

    public struct SecurityProfile: AWSDecodableShape {
        /// The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlHierarchyGroupId: String?
        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlTags: [String: String]?
        /// The Amazon Resource Name (ARN) for the security profile.
        public let arn: String?
        /// The description of the security profile.
        public let description: String?
        /// The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: User.
        public let hierarchyRestrictedResources: [String]?
        /// The identifier for the security profile.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The organization resource identifier for the security profile.
        public let organizationResourceId: String?
        /// The name for the security profile.
        public let securityProfileName: String?
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
        public let tagRestrictedResources: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(allowedAccessControlHierarchyGroupId: String? = nil, allowedAccessControlTags: [String: String]? = nil, arn: String? = nil, description: String? = nil, hierarchyRestrictedResources: [String]? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, organizationResourceId: String? = nil, securityProfileName: String? = nil, tagRestrictedResources: [String]? = nil, tags: [String: String]? = nil) {
            self.allowedAccessControlHierarchyGroupId = allowedAccessControlHierarchyGroupId
            self.allowedAccessControlTags = allowedAccessControlTags
            self.arn = arn
            self.description = description
            self.hierarchyRestrictedResources = hierarchyRestrictedResources
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tagRestrictedResources = tagRestrictedResources
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAccessControlHierarchyGroupId = "AllowedAccessControlHierarchyGroupId"
            case allowedAccessControlTags = "AllowedAccessControlTags"
            case arn = "Arn"
            case description = "Description"
            case hierarchyRestrictedResources = "HierarchyRestrictedResources"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case organizationResourceId = "OrganizationResourceId"
            case securityProfileName = "SecurityProfileName"
            case tagRestrictedResources = "TagRestrictedResources"
            case tags = "Tags"
        }
    }

    public struct SecurityProfileSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [SecurityProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [SecurityProfileSearchCriteria]?
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [SecurityProfileSearchCriteria]? = nil, orConditions: [SecurityProfileSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct SecurityProfileSearchSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the security profile.
        public let arn: String?
        /// The description of the security profile.
        public let description: String?
        /// The identifier of the security profile.
        public let id: String?
        /// The organization resource identifier.
        public let organizationResourceId: String?
        /// The name of the security profile.
        public let securityProfileName: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, id: String? = nil, organizationResourceId: String? = nil, securityProfileName: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case organizationResourceId = "OrganizationResourceId"
            case securityProfileName = "SecurityProfileName"
            case tags = "Tags"
        }
    }

    public struct SecurityProfileSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the security profile.
        public let arn: String?
        /// The identifier of the security profile.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The name of the security profile.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
        }
    }

    public struct SecurityProfilesSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct SegmentAttributeValue: AWSEncodableShape & AWSDecodableShape {
        /// The value of a segment attribute.
        public let valueInteger: Int?
        /// The value of a segment attribute.
        public let valueMap: [String: SegmentAttributeValue]?
        /// The value of a segment attribute.
        public let valueString: String?

        @inlinable
        public init(valueInteger: Int? = nil, valueMap: [String: SegmentAttributeValue]? = nil, valueString: String? = nil) {
            self.valueInteger = valueInteger
            self.valueMap = valueMap
            self.valueString = valueString
        }

        public func validate(name: String) throws {
            try self.valueMap?.forEach {
                try validate($0.key, name: "valueMap.key", parent: name, max: 128)
                try validate($0.key, name: "valueMap.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).valueMap[\"\($0.key)\"]")
            }
            try self.validate(self.valueString, name: "valueString", parent: name, max: 1024)
        }

        private enum CodingKeys: String, CodingKey {
            case valueInteger = "ValueInteger"
            case valueMap = "ValueMap"
            case valueString = "ValueString"
        }
    }

    public struct SendChatIntegrationEventRequest: AWSEncodableShape {
        /// Chat system identifier, used in part to uniquely identify chat. This is associated with the Amazon Connect instance and flow to be used to start chats. For Server Migration Service, this is the phone number destination of inbound Server Migration Service messages represented by an Amazon Web Services End User Messaging phone number ARN.
        public let destinationId: String
        /// Chat integration event payload
        public let event: ChatEvent
        /// Contact properties to apply when starting a new chat. If the integration event is handled with an existing chat, this is ignored.
        public let newSessionDetails: NewSessionDetails?
        /// External identifier of chat customer participant, used in part to uniquely identify a chat. For SMS, this is the E164 phone number of the chat customer participant.
        public let sourceId: String
        /// Classification of a channel. This is used in part to uniquely identify chat.  Valid value: ["connect:sms", connect:"WhatsApp"]
        public let subtype: String?

        @inlinable
        public init(destinationId: String, event: ChatEvent, newSessionDetails: NewSessionDetails? = nil, sourceId: String, subtype: String? = nil) {
            self.destinationId = destinationId
            self.event = event
            self.newSessionDetails = newSessionDetails
            self.sourceId = sourceId
            self.subtype = subtype
        }

        public func validate(name: String) throws {
            try self.validate(self.destinationId, name: "destinationId", parent: name, max: 255)
            try self.validate(self.destinationId, name: "destinationId", parent: name, min: 1)
            try self.event.validate(name: "\(name).event")
            try self.newSessionDetails?.validate(name: "\(name).newSessionDetails")
            try self.validate(self.sourceId, name: "sourceId", parent: name, max: 255)
            try self.validate(self.sourceId, name: "sourceId", parent: name, min: 1)
            try self.validate(self.subtype, name: "subtype", parent: name, max: 100)
            try self.validate(self.subtype, name: "subtype", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case destinationId = "DestinationId"
            case event = "Event"
            case newSessionDetails = "NewSessionDetails"
            case sourceId = "SourceId"
            case subtype = "Subtype"
        }
    }

    public struct SendChatIntegrationEventResponse: AWSDecodableShape {
        /// Identifier of chat contact used to handle integration event. This may be null if the integration event is not valid without an already existing chat contact.
        public let initialContactId: String?
        /// Whether handling the integration event resulted in creating a new chat or acting on existing chat.
        public let newChatCreated: Bool?

        @inlinable
        public init(initialContactId: String? = nil, newChatCreated: Bool? = nil) {
            self.initialContactId = initialContactId
            self.newChatCreated = newChatCreated
        }

        private enum CodingKeys: String, CodingKey {
            case initialContactId = "InitialContactId"
            case newChatCreated = "NewChatCreated"
        }
    }

    public struct SendNotificationActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Notification content. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let content: String
        /// Content type format.
        public let contentType: NotificationContentType
        /// Notification delivery method.
        public let deliveryMethod: NotificationDeliveryType
        /// Notification recipient.
        public let recipient: NotificationRecipientType
        /// The subject of the email if the delivery method is EMAIL. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let subject: String?

        @inlinable
        public init(content: String, contentType: NotificationContentType, deliveryMethod: NotificationDeliveryType, recipient: NotificationRecipientType, subject: String? = nil) {
            self.content = content
            self.contentType = contentType
            self.deliveryMethod = deliveryMethod
            self.recipient = recipient
            self.subject = subject
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 1024)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.subject, name: "subject", parent: name, max: 200)
            try self.validate(self.subject, name: "subject", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
            case deliveryMethod = "DeliveryMethod"
            case recipient = "Recipient"
            case subject = "Subject"
        }
    }

    public struct SendOutboundEmailRequest: AWSEncodableShape {
        /// The additional recipients address of the email in CC.
        public let additionalRecipients: OutboundAdditionalRecipients?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The email address to send the email to.
        public let destinationEmailAddress: EmailAddressInfo
        /// The email message body to be sent to the newly created email.
        public let emailMessage: OutboundEmailContent
        /// The email address to be used for sending email.
        public let fromEmailAddress: EmailAddressInfo
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A Campaign object need for Campaign traffic type.
        public let sourceCampaign: SourceCampaign?
        /// Denotes the class of traffic.
        public let trafficType: TrafficType

        @inlinable
        public init(additionalRecipients: OutboundAdditionalRecipients? = nil, clientToken: String? = SendOutboundEmailRequest.idempotencyToken(), destinationEmailAddress: EmailAddressInfo, emailMessage: OutboundEmailContent, fromEmailAddress: EmailAddressInfo, instanceId: String, sourceCampaign: SourceCampaign? = nil, trafficType: TrafficType) {
            self.additionalRecipients = additionalRecipients
            self.clientToken = clientToken
            self.destinationEmailAddress = destinationEmailAddress
            self.emailMessage = emailMessage
            self.fromEmailAddress = fromEmailAddress
            self.instanceId = instanceId
            self.sourceCampaign = sourceCampaign
            self.trafficType = trafficType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.additionalRecipients, forKey: .additionalRecipients)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.destinationEmailAddress, forKey: .destinationEmailAddress)
            try container.encode(self.emailMessage, forKey: .emailMessage)
            try container.encode(self.fromEmailAddress, forKey: .fromEmailAddress)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.sourceCampaign, forKey: .sourceCampaign)
            try container.encode(self.trafficType, forKey: .trafficType)
        }

        public func validate(name: String) throws {
            try self.additionalRecipients?.validate(name: "\(name).additionalRecipients")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.destinationEmailAddress.validate(name: "\(name).destinationEmailAddress")
            try self.emailMessage.validate(name: "\(name).emailMessage")
            try self.fromEmailAddress.validate(name: "\(name).fromEmailAddress")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.sourceCampaign?.validate(name: "\(name).sourceCampaign")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalRecipients = "AdditionalRecipients"
            case clientToken = "ClientToken"
            case destinationEmailAddress = "DestinationEmailAddress"
            case emailMessage = "EmailMessage"
            case fromEmailAddress = "FromEmailAddress"
            case sourceCampaign = "SourceCampaign"
            case trafficType = "TrafficType"
        }
    }

    public struct SendOutboundEmailResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String?
        public let reason: ServiceQuotaExceededExceptionReason?

        @inlinable
        public init(message: String? = nil, reason: ServiceQuotaExceededExceptionReason? = nil) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct SignInConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about traffic distributions.
        public let distributions: [SignInDistribution]

        @inlinable
        public init(distributions: [SignInDistribution]) {
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case distributions = "Distributions"
        }
    }

    public struct SignInDistribution: AWSEncodableShape & AWSDecodableShape {
        /// Whether sign in distribution is enabled.
        public let enabled: Bool
        /// The Amazon Web Services Region of the sign in distribution.
        public let region: String

        @inlinable
        public init(enabled: Bool, region: String) {
            self.enabled = enabled
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.region, name: "region", parent: name, max: 31)
            try self.validate(self.region, name: "region", parent: name, min: 8)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[a-z]{2}(-[a-z]+){1,2}(-[0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "Enabled"
            case region = "Region"
        }
    }

    public struct SingleSelectQuestionRuleCategoryAutomation: AWSEncodableShape & AWSDecodableShape {
        ///  The category name, as defined in Rules.
        public let category: String
        /// The condition to apply for the automation option. If the condition is PRESENT, then the option is applied when the contact data includes the category. Similarly, if the condition is NOT_PRESENT, then the option is applied when the contact data does not include the category.
        public let condition: SingleSelectQuestionRuleCategoryAutomationCondition
        /// The identifier of the answer option.
        public let optionRefId: String

        @inlinable
        public init(category: String, condition: SingleSelectQuestionRuleCategoryAutomationCondition, optionRefId: String) {
            self.category = category
            self.condition = condition
            self.optionRefId = optionRefId
        }

        public func validate(name: String) throws {
            try self.validate(self.category, name: "category", parent: name, max: 50)
            try self.validate(self.category, name: "category", parent: name, min: 1)
            try self.validate(self.optionRefId, name: "optionRefId", parent: name, max: 40)
            try self.validate(self.optionRefId, name: "optionRefId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case category = "Category"
            case condition = "Condition"
            case optionRefId = "OptionRefId"
        }
    }

    public struct Sort: AWSEncodableShape {
        /// The name of the field on which to sort.
        public let fieldName: SortableFieldName
        /// An ascending or descending sort.
        public let order: SortOrder

        @inlinable
        public init(fieldName: SortableFieldName, order: SortOrder) {
            self.fieldName = fieldName
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case fieldName = "FieldName"
            case order = "Order"
        }
    }

    public struct SourceCampaign: AWSEncodableShape {
        /// A unique identifier for a campaign.
        public let campaignId: String?
        /// A unique identifier for a each request part of same campaign.
        public let outboundRequestId: String?

        @inlinable
        public init(campaignId: String? = nil, outboundRequestId: String? = nil) {
            self.campaignId = campaignId
            self.outboundRequestId = outboundRequestId
        }

        public func validate(name: String) throws {
            try self.validate(self.campaignId, name: "campaignId", parent: name, max: 100)
            try self.validate(self.campaignId, name: "campaignId", parent: name, min: 1)
            try self.validate(self.outboundRequestId, name: "outboundRequestId", parent: name, max: 36)
            try self.validate(self.outboundRequestId, name: "outboundRequestId", parent: name, min: 36)
        }

        private enum CodingKeys: String, CodingKey {
            case campaignId = "CampaignId"
            case outboundRequestId = "OutboundRequestId"
        }
    }

    public struct StartAttachedFileUploadRequest: AWSEncodableShape {
        /// The resource to which the attached file is (being) uploaded to. The supported resources are Cases and Email.  This value must be a valid ARN.
        public let associatedResourceArn: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// Represents the identity that created the file.
        public let createdBy: CreatedByInfo?
        /// A case-sensitive name of the attached file being uploaded.
        public let fileName: String
        /// The size of the attached file in bytes.
        public let fileSizeInBytes: Int64
        /// The use case for the file.  Only ATTACHMENTS are supported.
        public let fileUseCaseType: FileUseCaseType
        /// The unique identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// Optional override for the expiry of the pre-signed S3 URL in seconds. The default value is 300.
        public let urlExpiryInSeconds: Int?

        @inlinable
        public init(associatedResourceArn: String, clientToken: String? = StartAttachedFileUploadRequest.idempotencyToken(), createdBy: CreatedByInfo? = nil, fileName: String, fileSizeInBytes: Int64, fileUseCaseType: FileUseCaseType, instanceId: String, tags: [String: String]? = nil, urlExpiryInSeconds: Int? = nil) {
            self.associatedResourceArn = associatedResourceArn
            self.clientToken = clientToken
            self.createdBy = createdBy
            self.fileName = fileName
            self.fileSizeInBytes = fileSizeInBytes
            self.fileUseCaseType = fileUseCaseType
            self.instanceId = instanceId
            self.tags = tags
            self.urlExpiryInSeconds = urlExpiryInSeconds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.associatedResourceArn, key: "associatedResourceArn")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.createdBy, forKey: .createdBy)
            try container.encode(self.fileName, forKey: .fileName)
            try container.encode(self.fileSizeInBytes, forKey: .fileSizeInBytes)
            try container.encode(self.fileUseCaseType, forKey: .fileUseCaseType)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.urlExpiryInSeconds, forKey: .urlExpiryInSeconds)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.fileName, name: "fileName", parent: name, max: 256)
            try self.validate(self.fileName, name: "fileName", parent: name, min: 1)
            try self.validate(self.fileName, name: "fileName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.fileSizeInBytes, name: "fileSizeInBytes", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.urlExpiryInSeconds, name: "urlExpiryInSeconds", parent: name, max: 300)
            try self.validate(self.urlExpiryInSeconds, name: "urlExpiryInSeconds", parent: name, min: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case createdBy = "CreatedBy"
            case fileName = "FileName"
            case fileSizeInBytes = "FileSizeInBytes"
            case fileUseCaseType = "FileUseCaseType"
            case tags = "Tags"
            case urlExpiryInSeconds = "UrlExpiryInSeconds"
        }
    }

    public struct StartAttachedFileUploadResponse: AWSDecodableShape {
        /// Represents the identity that created the file.
        public let createdBy: CreatedByInfo?
        /// The time of Creation of the file resource as an ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2024-05-03T02:41:28.172Z.
        public let creationTime: String?
        /// The unique identifier of the attached file resource (ARN).
        public let fileArn: String?
        /// The unique identifier of the attached file resource.
        public let fileId: String?
        /// The current status of the attached file.
        public let fileStatus: FileStatusType?
        /// The headers to be provided while uploading the file to the URL.
        public let uploadUrlMetadata: UploadUrlMetadata?

        @inlinable
        public init(createdBy: CreatedByInfo? = nil, creationTime: String? = nil, fileArn: String? = nil, fileId: String? = nil, fileStatus: FileStatusType? = nil, uploadUrlMetadata: UploadUrlMetadata? = nil) {
            self.createdBy = createdBy
            self.creationTime = creationTime
            self.fileArn = fileArn
            self.fileId = fileId
            self.fileStatus = fileStatus
            self.uploadUrlMetadata = uploadUrlMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case createdBy = "CreatedBy"
            case creationTime = "CreationTime"
            case fileArn = "FileArn"
            case fileId = "FileId"
            case fileStatus = "FileStatus"
            case uploadUrlMetadata = "UploadUrlMetadata"
        }
    }

    public struct StartChatContactRequest: AWSEncodableShape {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes.  There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minimum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).
        public let chatDurationInMinutes: Int?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String
        /// The customer's identification number. For example, the CustomerId may be a customer number from your CRM.
        public let customerId: String?
        /// The initial message to be sent to the newly created chat. If you have a Lex bot in your flow, the initial message is not delivered to the Lex bot.
        public let initialMessage: ChatMessage?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Information identifying the participant.
        public let participantDetails: ParticipantDetails
        /// Enable persistent chats. For more information about enabling persistent chat, and for example use cases and how to configure for them, see Enable persistent chat.
        public let persistentChat: PersistentChat?
        /// The unique identifier for an Amazon Connect contact. This identifier is related to the chat starting.  You cannot provide data for both RelatedContactId and PersistentChat.
        public let relatedContactId: String?
        /// A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows. Attribute keys can include only alphanumeric, -, and _. This field can be used to show channel subtype, such as connect:Guide.  The types application/vnd.amazonaws.connect.message.interactive and application/vnd.amazonaws.connect.message.interactive.response must be present in the SupportedMessagingContentTypes field of this API in order to set SegmentAttributes as { "connect:Subtype": {"valueString" : "connect:Guide" }}.
        public let segmentAttributes: [String: SegmentAttributeValue]?
        /// The supported chat message content types. Supported types are text/plain, text/markdown, application/json, application/vnd.amazonaws.connect.message.interactive, and application/vnd.amazonaws.connect.message.interactive.response.  Content types must always contain text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain: [text/plain, text/markdown, application/json], [text/markdown, text/plain], [text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response].   The type application/vnd.amazonaws.connect.message.interactive is required to use the Show view flow block.
        public let supportedMessagingContentTypes: [String]?

        @inlinable
        public init(attributes: [String: String]? = nil, chatDurationInMinutes: Int? = nil, clientToken: String? = StartChatContactRequest.idempotencyToken(), contactFlowId: String, customerId: String? = nil, initialMessage: ChatMessage? = nil, instanceId: String, participantDetails: ParticipantDetails, persistentChat: PersistentChat? = nil, relatedContactId: String? = nil, segmentAttributes: [String: SegmentAttributeValue]? = nil, supportedMessagingContentTypes: [String]? = nil) {
            self.attributes = attributes
            self.chatDurationInMinutes = chatDurationInMinutes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.customerId = customerId
            self.initialMessage = initialMessage
            self.instanceId = instanceId
            self.participantDetails = participantDetails
            self.persistentChat = persistentChat
            self.relatedContactId = relatedContactId
            self.segmentAttributes = segmentAttributes
            self.supportedMessagingContentTypes = supportedMessagingContentTypes
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.chatDurationInMinutes, name: "chatDurationInMinutes", parent: name, max: 10080)
            try self.validate(self.chatDurationInMinutes, name: "chatDurationInMinutes", parent: name, min: 60)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.customerId, name: "customerId", parent: name, max: 128)
            try self.validate(self.customerId, name: "customerId", parent: name, min: 1)
            try self.initialMessage?.validate(name: "\(name).initialMessage")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.participantDetails.validate(name: "\(name).participantDetails")
            try self.persistentChat?.validate(name: "\(name).persistentChat")
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, max: 256)
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, min: 1)
            try self.segmentAttributes?.forEach {
                try validate($0.key, name: "segmentAttributes.key", parent: name, max: 128)
                try validate($0.key, name: "segmentAttributes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).segmentAttributes[\"\($0.key)\"]")
            }
            try self.supportedMessagingContentTypes?.forEach {
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, max: 100)
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case chatDurationInMinutes = "ChatDurationInMinutes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case customerId = "CustomerId"
            case initialMessage = "InitialMessage"
            case instanceId = "InstanceId"
            case participantDetails = "ParticipantDetails"
            case persistentChat = "PersistentChat"
            case relatedContactId = "RelatedContactId"
            case segmentAttributes = "SegmentAttributes"
            case supportedMessagingContentTypes = "SupportedMessagingContentTypes"
        }
    }

    public struct StartChatContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?
        /// The contactId from which a persistent chat session is started. This field is populated only for persistent chats.
        public let continuedFromContactId: String?
        /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
        public let participantId: String?
        /// The token used by the chat participant to call CreateParticipantConnection. The participant token is valid for the lifetime of a chat participant.
        public let participantToken: String?

        @inlinable
        public init(contactId: String? = nil, continuedFromContactId: String? = nil, participantId: String? = nil, participantToken: String? = nil) {
            self.contactId = contactId
            self.continuedFromContactId = continuedFromContactId
            self.participantId = participantId
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case continuedFromContactId = "ContinuedFromContactId"
            case participantId = "ParticipantId"
            case participantToken = "ParticipantToken"
        }
    }

    public struct StartContactEvaluationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(clientToken: String? = StartContactEvaluationRequest.idempotencyToken(), contactId: String, evaluationFormId: String, instanceId: String) {
            self.clientToken = clientToken
            self.contactId = contactId
            self.evaluationFormId = evaluationFormId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.contactId, forKey: .contactId)
            try container.encode(self.evaluationFormId, forKey: .evaluationFormId)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 500)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case evaluationFormId = "EvaluationFormId"
        }
    }

    public struct StartContactEvaluationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        public let evaluationArn: String
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String

        @inlinable
        public init(evaluationArn: String, evaluationId: String) {
            self.evaluationArn = evaluationArn
            self.evaluationId = evaluationId
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationArn = "EvaluationArn"
            case evaluationId = "EvaluationId"
        }
    }

    public struct StartContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The person being recorded.
        public let voiceRecordingConfiguration: VoiceRecordingConfiguration

        @inlinable
        public init(contactId: String, initialContactId: String, instanceId: String, voiceRecordingConfiguration: VoiceRecordingConfiguration) {
            self.contactId = contactId
            self.initialContactId = initialContactId
            self.instanceId = instanceId
            self.voiceRecordingConfiguration = voiceRecordingConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
            case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
        }
    }

    public struct StartContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartContactStreamingRequest: AWSEncodableShape {
        /// The streaming configuration, such as the Amazon SNS streaming endpoint.
        public let chatStreamingConfiguration: ChatStreamingConfiguration
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(chatStreamingConfiguration: ChatStreamingConfiguration, clientToken: String = StartContactStreamingRequest.idempotencyToken(), contactId: String, instanceId: String) {
            self.chatStreamingConfiguration = chatStreamingConfiguration
            self.clientToken = clientToken
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.chatStreamingConfiguration.validate(name: "\(name).chatStreamingConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case chatStreamingConfiguration = "ChatStreamingConfiguration"
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct StartContactStreamingResponse: AWSDecodableShape {
        /// The identifier of the streaming configuration enabled.
        public let streamingId: String

        @inlinable
        public init(streamingId: String) {
            self.streamingId = streamingId
        }

        private enum CodingKeys: String, CodingKey {
            case streamingId = "StreamingId"
        }
    }

    public struct StartEmailContactRequest: AWSEncodableShape {
        /// The addtional recipients address of the email.
        public let additionalRecipients: InboundAdditionalRecipients?
        /// List of S3 presigned URLs of email attachments and their file name.
        public let attachments: [EmailAttachment]?
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the flow for initiating the emails. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String?
        /// A description of the email contact.
        public let description: String?
        /// The email address associated with the instance.
        public let destinationEmailAddress: String
        /// The email message body to be sent to the newly created email.
        public let emailMessage: InboundEmailContent
        /// The email address of the customer.
        public let fromEmailAddress: EmailAddressInfo
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of a email that is shown to an agent in the Contact Control Panel (CCP).
        public let name: String?
        /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Emails can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE. EMAIL | EMAIL_MESSAGE |ATTACHMENT are not a supported reference type during email creation.
        public let references: [String: Reference]?
        /// The contactId that is related to this contact. Linking emails together by using RelatedContactID copies over contact attributes from the related email contact to the new email contact. All updates to user-defined attributes in the new email contact are limited to the individual contact ID. There are no limits to the number of contacts that can be linked by using RelatedContactId.
        public let relatedContactId: String?
        /// A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows. Attribute keys can include only alphanumeric, -, and _. This field can be used to show channel subtype, such as connect:Guide.  To set contact expiry, a ValueMap must be specified containing the integer number of minutes the contact will be active for before expiring, with SegmentAttributes like {  "connect:ContactExpiry": {"ValueMap" : { "ExpiryDuration": { "ValueInteger":135}}}}.
        public let segmentAttributes: [String: SegmentAttributeValue]?

        @inlinable
        public init(additionalRecipients: InboundAdditionalRecipients? = nil, attachments: [EmailAttachment]? = nil, attributes: [String: String]? = nil, clientToken: String? = StartEmailContactRequest.idempotencyToken(), contactFlowId: String? = nil, description: String? = nil, destinationEmailAddress: String, emailMessage: InboundEmailContent, fromEmailAddress: EmailAddressInfo, instanceId: String, name: String? = nil, references: [String: Reference]? = nil, relatedContactId: String? = nil, segmentAttributes: [String: SegmentAttributeValue]? = nil) {
            self.additionalRecipients = additionalRecipients
            self.attachments = attachments
            self.attributes = attributes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.description = description
            self.destinationEmailAddress = destinationEmailAddress
            self.emailMessage = emailMessage
            self.fromEmailAddress = fromEmailAddress
            self.instanceId = instanceId
            self.name = name
            self.references = references
            self.relatedContactId = relatedContactId
            self.segmentAttributes = segmentAttributes
        }

        public func validate(name: String) throws {
            try self.additionalRecipients?.validate(name: "\(name).additionalRecipients")
            try self.attachments?.forEach {
                try $0.validate(name: "\(name).attachments[]")
            }
            try self.validate(self.attachments, name: "attachments", parent: name, max: 10)
            try self.validate(self.attachments, name: "attachments", parent: name, min: 1)
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.destinationEmailAddress, name: "destinationEmailAddress", parent: name, max: 255)
            try self.validate(self.destinationEmailAddress, name: "destinationEmailAddress", parent: name, min: 1)
            try self.validate(self.destinationEmailAddress, name: "destinationEmailAddress", parent: name, pattern: "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$")
            try self.emailMessage.validate(name: "\(name).emailMessage")
            try self.fromEmailAddress.validate(name: "\(name).fromEmailAddress")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, max: 256)
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, min: 1)
            try self.segmentAttributes?.forEach {
                try validate($0.key, name: "segmentAttributes.key", parent: name, max: 128)
                try validate($0.key, name: "segmentAttributes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).segmentAttributes[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case additionalRecipients = "AdditionalRecipients"
            case attachments = "Attachments"
            case attributes = "Attributes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case description = "Description"
            case destinationEmailAddress = "DestinationEmailAddress"
            case emailMessage = "EmailMessage"
            case fromEmailAddress = "FromEmailAddress"
            case instanceId = "InstanceId"
            case name = "Name"
            case references = "References"
            case relatedContactId = "RelatedContactId"
            case segmentAttributes = "SegmentAttributes"
        }
    }

    public struct StartEmailContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?

        @inlinable
        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct StartOutboundChatContactRequest: AWSEncodableShape {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes.
        public let attributes: [String: String]?
        /// The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minimum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).
        public let chatDurationInMinutes: Int?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the AWS SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
        public let clientToken: String?
        /// The identifier of the flow for the call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:   arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/123ec456-a007-89c0-1234-xxxxxxxxxxxx
        public let contactFlowId: String
        public let destinationEndpoint: Endpoint
        public let initialSystemMessage: ChatMessage?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        public let participantDetails: ParticipantDetails?
        /// The unique identifier for an Amazon Connect contact. This identifier is related to the contact starting.
        public let relatedContactId: String?
        /// A set of system defined key-value pairs stored on individual contact segments using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows.   Attribute keys can include only alphanumeric, -, and _.   This field can be used to show channel subtype, such as connect:Guide and connect:SMS.
        public let segmentAttributes: [String: SegmentAttributeValue]
        public let sourceEndpoint: Endpoint
        /// The supported chat message content types. Supported types are:    text/plain     text/markdown     application/json, application/vnd.amazonaws.connect.message.interactive     application/vnd.amazonaws.connect.message.interactive.response    Content types must always contain text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain:    [text/plain, text/markdown, application/json]     [text/markdown, text/plain]     [text/plain, application/json, application/vnd.amazonaws.connect.message.interactive.response]
        public let supportedMessagingContentTypes: [String]?

        @inlinable
        public init(attributes: [String: String]? = nil, chatDurationInMinutes: Int? = nil, clientToken: String? = StartOutboundChatContactRequest.idempotencyToken(), contactFlowId: String, destinationEndpoint: Endpoint, initialSystemMessage: ChatMessage? = nil, instanceId: String, participantDetails: ParticipantDetails? = nil, relatedContactId: String? = nil, segmentAttributes: [String: SegmentAttributeValue], sourceEndpoint: Endpoint, supportedMessagingContentTypes: [String]? = nil) {
            self.attributes = attributes
            self.chatDurationInMinutes = chatDurationInMinutes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.destinationEndpoint = destinationEndpoint
            self.initialSystemMessage = initialSystemMessage
            self.instanceId = instanceId
            self.participantDetails = participantDetails
            self.relatedContactId = relatedContactId
            self.segmentAttributes = segmentAttributes
            self.sourceEndpoint = sourceEndpoint
            self.supportedMessagingContentTypes = supportedMessagingContentTypes
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.chatDurationInMinutes, name: "chatDurationInMinutes", parent: name, max: 10080)
            try self.validate(self.chatDurationInMinutes, name: "chatDurationInMinutes", parent: name, min: 60)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.destinationEndpoint.validate(name: "\(name).destinationEndpoint")
            try self.initialSystemMessage?.validate(name: "\(name).initialSystemMessage")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.participantDetails?.validate(name: "\(name).participantDetails")
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, max: 256)
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, min: 1)
            try self.segmentAttributes.forEach {
                try validate($0.key, name: "segmentAttributes.key", parent: name, max: 128)
                try validate($0.key, name: "segmentAttributes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).segmentAttributes[\"\($0.key)\"]")
            }
            try self.sourceEndpoint.validate(name: "\(name).sourceEndpoint")
            try self.supportedMessagingContentTypes?.forEach {
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, max: 100)
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case chatDurationInMinutes = "ChatDurationInMinutes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case destinationEndpoint = "DestinationEndpoint"
            case initialSystemMessage = "InitialSystemMessage"
            case instanceId = "InstanceId"
            case participantDetails = "ParticipantDetails"
            case relatedContactId = "RelatedContactId"
            case segmentAttributes = "SegmentAttributes"
            case sourceEndpoint = "SourceEndpoint"
            case supportedMessagingContentTypes = "SupportedMessagingContentTypes"
        }
    }

    public struct StartOutboundChatContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?

        @inlinable
        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct StartOutboundEmailContactRequest: AWSEncodableShape {
        /// The addtional recipients address of email in CC.
        public let additionalRecipients: OutboundAdditionalRecipients?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The email address of the customer.
        public let destinationEmailAddress: EmailAddressInfo
        /// The email message body to be sent to the newly created email.
        public let emailMessage: OutboundEmailContent
        /// The email address associated with the instance.
        public let fromEmailAddress: EmailAddressInfo?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(additionalRecipients: OutboundAdditionalRecipients? = nil, clientToken: String? = StartOutboundEmailContactRequest.idempotencyToken(), contactId: String, destinationEmailAddress: EmailAddressInfo, emailMessage: OutboundEmailContent, fromEmailAddress: EmailAddressInfo? = nil, instanceId: String) {
            self.additionalRecipients = additionalRecipients
            self.clientToken = clientToken
            self.contactId = contactId
            self.destinationEmailAddress = destinationEmailAddress
            self.emailMessage = emailMessage
            self.fromEmailAddress = fromEmailAddress
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.additionalRecipients?.validate(name: "\(name).additionalRecipients")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.destinationEmailAddress.validate(name: "\(name).destinationEmailAddress")
            try self.emailMessage.validate(name: "\(name).emailMessage")
            try self.fromEmailAddress?.validate(name: "\(name).fromEmailAddress")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case additionalRecipients = "AdditionalRecipients"
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case destinationEmailAddress = "DestinationEmailAddress"
            case emailMessage = "EmailMessage"
            case fromEmailAddress = "FromEmailAddress"
            case instanceId = "InstanceId"
        }
    }

    public struct StartOutboundEmailContactResponse: AWSDecodableShape {
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?

        @inlinable
        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct StartOutboundVoiceContactRequest: AWSEncodableShape {
        /// Configuration of the answering machine detection for this outbound call.
        public let answerMachineDetectionConfig: AnswerMachineDetectionConfig?
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// The campaign identifier of the outbound communication.
        public let campaignId: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
        public let clientToken: String?
        /// The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String
        /// A description of the voice contact that is shown to an agent in the Contact Control Panel (CCP).
        public let description: String?
        /// The phone number of the customer, in E.164 format.
        public let destinationPhoneNumber: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of a voice contact that is shown to an agent in the Contact Control Panel (CCP).
        public let name: String?
        /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.
        public let queueId: String?
        /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Contacts can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during voice contact creation.
        public let references: [String: Reference]?
        /// The contactId that is related to this contact. Linking voice, task, or chat by using RelatedContactID copies over contact attributes from the related contact to the new contact. All updates to user-defined attributes in the new contact are limited to the individual contact ID. There are no limits to the number of contacts that can be linked by using RelatedContactId.
        public let relatedContactId: String?
        /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
        public let sourcePhoneNumber: String?
        /// Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is GENERAL. Use CAMPAIGN if EnableAnswerMachineDetection is set to true. For all other cases, use GENERAL.
        public let trafficType: TrafficType?

        @inlinable
        public init(answerMachineDetectionConfig: AnswerMachineDetectionConfig? = nil, attributes: [String: String]? = nil, campaignId: String? = nil, clientToken: String? = StartOutboundVoiceContactRequest.idempotencyToken(), contactFlowId: String, description: String? = nil, destinationPhoneNumber: String, instanceId: String, name: String? = nil, queueId: String? = nil, references: [String: Reference]? = nil, relatedContactId: String? = nil, sourcePhoneNumber: String? = nil, trafficType: TrafficType? = nil) {
            self.answerMachineDetectionConfig = answerMachineDetectionConfig
            self.attributes = attributes
            self.campaignId = campaignId
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.description = description
            self.destinationPhoneNumber = destinationPhoneNumber
            self.instanceId = instanceId
            self.name = name
            self.queueId = queueId
            self.references = references
            self.relatedContactId = relatedContactId
            self.sourcePhoneNumber = sourcePhoneNumber
            self.trafficType = trafficType
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.campaignId, name: "campaignId", parent: name, max: 100)
            try self.validate(self.campaignId, name: "campaignId", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, max: 256)
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, min: 1)
            try self.validate(self.sourcePhoneNumber, name: "sourcePhoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case answerMachineDetectionConfig = "AnswerMachineDetectionConfig"
            case attributes = "Attributes"
            case campaignId = "CampaignId"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case description = "Description"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case instanceId = "InstanceId"
            case name = "Name"
            case queueId = "QueueId"
            case references = "References"
            case relatedContactId = "RelatedContactId"
            case sourcePhoneNumber = "SourcePhoneNumber"
            case trafficType = "TrafficType"
        }
    }

    public struct StartOutboundVoiceContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?

        @inlinable
        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct StartScreenSharingRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(clientToken: String? = StartScreenSharingRequest.idempotencyToken(), contactId: String, instanceId: String) {
            self.clientToken = clientToken
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct StartScreenSharingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartTaskContactRequest: AWSEncodableShape {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String?
        /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of a task that is shown to an agent in the Contact Control Panel (CCP).
        public let name: String
        /// The identifier of the previous chat, voice, or task contact. Any updates to user-defined attributes to task contacts linked using the same PreviousContactID will affect every contact in the chain. There can be a maximum of 12 linked task contacts in a chain.
        public let previousContactId: String?
        /// The identifier for the quick connect. Tasks that are created by using QuickConnectId will use the flow that is defined on agent or queue quick connect. For more information about quick connects, see Create quick connects.
        public let quickConnectId: String?
        /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Tasks can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during task creation.
        public let references: [String: Reference]?
        /// The contactId that is related to this contact. Linking tasks together by using RelatedContactID copies over contact attributes from the related task contact to the new task contact. All updates to user-defined attributes in the new task contact are limited to the individual contact ID, unlike what happens when tasks are linked by using PreviousContactID. There are no limits to the number of contacts that can be linked by using RelatedContactId.
        public let relatedContactId: String?
        /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
        public let scheduledTime: Date?
        /// A set of system defined key-value pairs stored on individual contact segments (unique contact ID) using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows. Attribute keys can include only alphanumeric, -, and _. This field can be used to set Contact Expiry as a duration in minutes and set a UserId for the User who created a task.  To set contact expiry, a ValueMap must be specified containing the integer number of minutes the contact will be active for before expiring, with SegmentAttributes like {  "connect:ContactExpiry": {"ValueMap" : { "ExpiryDuration": { "ValueInteger": 135}}}}.  To set the created by user, a valid AgentResourceId must be supplied, with SegmentAttributes like { "connect:CreatedByUser" { "ValueString": "arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/agent/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"}}}.
        public let segmentAttributes: [String: SegmentAttributeValue]?
        /// A unique identifier for the task template. For more information about task templates, see Create task templates in the Amazon Connect Administrator Guide.
        public let taskTemplateId: String?

        @inlinable
        public init(attributes: [String: String]? = nil, clientToken: String? = StartTaskContactRequest.idempotencyToken(), contactFlowId: String? = nil, description: String? = nil, instanceId: String, name: String, previousContactId: String? = nil, quickConnectId: String? = nil, references: [String: Reference]? = nil, relatedContactId: String? = nil, scheduledTime: Date? = nil, segmentAttributes: [String: SegmentAttributeValue]? = nil, taskTemplateId: String? = nil) {
            self.attributes = attributes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.previousContactId = previousContactId
            self.quickConnectId = quickConnectId
            self.references = references
            self.relatedContactId = relatedContactId
            self.scheduledTime = scheduledTime
            self.segmentAttributes = segmentAttributes
            self.taskTemplateId = taskTemplateId
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.previousContactId, name: "previousContactId", parent: name, max: 256)
            try self.validate(self.previousContactId, name: "previousContactId", parent: name, min: 1)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, max: 256)
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, min: 1)
            try self.segmentAttributes?.forEach {
                try validate($0.key, name: "segmentAttributes.key", parent: name, max: 128)
                try validate($0.key, name: "segmentAttributes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).segmentAttributes[\"\($0.key)\"]")
            }
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case description = "Description"
            case instanceId = "InstanceId"
            case name = "Name"
            case previousContactId = "PreviousContactId"
            case quickConnectId = "QuickConnectId"
            case references = "References"
            case relatedContactId = "RelatedContactId"
            case scheduledTime = "ScheduledTime"
            case segmentAttributes = "SegmentAttributes"
            case taskTemplateId = "TaskTemplateId"
        }
    }

    public struct StartTaskContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?

        @inlinable
        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct StartWebRTCContactRequest: AWSEncodableShape {
        /// Information about the video sharing capabilities of the participants (customer, agent).
        public let allowedCapabilities: AllowedCapabilities?
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, -, and _ characters.
        public let attributes: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
        public let clientToken: String?
        /// The identifier of the flow for the call. To see the ContactFlowId in the Amazon Connect admin website, on the navigation menu go to Routing, Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String
        /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        public let participantDetails: ParticipantDetails
        /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP). Tasks can have the following reference types at the time of creation: URL | NUMBER | STRING | DATE | EMAIL. ATTACHMENT is not a supported reference type during task creation.
        public let references: [String: Reference]?
        /// The unique identifier for an Amazon Connect contact. This identifier is related to the contact starting.
        public let relatedContactId: String?

        @inlinable
        public init(allowedCapabilities: AllowedCapabilities? = nil, attributes: [String: String]? = nil, clientToken: String? = StartWebRTCContactRequest.idempotencyToken(), contactFlowId: String, description: String? = nil, instanceId: String, participantDetails: ParticipantDetails, references: [String: Reference]? = nil, relatedContactId: String? = nil) {
            self.allowedCapabilities = allowedCapabilities
            self.attributes = attributes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.description = description
            self.instanceId = instanceId
            self.participantDetails = participantDetails
            self.references = references
            self.relatedContactId = relatedContactId
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.participantDetails.validate(name: "\(name).participantDetails")
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, max: 256)
            try self.validate(self.relatedContactId, name: "relatedContactId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedCapabilities = "AllowedCapabilities"
            case attributes = "Attributes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case description = "Description"
            case instanceId = "InstanceId"
            case participantDetails = "ParticipantDetails"
            case references = "References"
            case relatedContactId = "RelatedContactId"
        }
    }

    public struct StartWebRTCContactResponse: AWSDecodableShape {
        /// Information required for the client application (mobile application or website) to connect to the call.
        public let connectionData: ConnectionData?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?
        /// The identifier for a contact participant. The ParticipantId for a contact participant is the same throughout the contact lifecycle.
        public let participantId: String?
        /// The token used by the contact participant to call the CreateParticipantConnection API. The participant token is valid for the lifetime of a contact participant.
        public let participantToken: String?

        @inlinable
        public init(connectionData: ConnectionData? = nil, contactId: String? = nil, participantId: String? = nil, participantToken: String? = nil) {
            self.connectionData = connectionData
            self.contactId = contactId
            self.participantId = participantId
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectionData = "ConnectionData"
            case contactId = "ContactId"
            case participantId = "ParticipantId"
            case participantToken = "ParticipantToken"
        }
    }

    public struct Step: AWSDecodableShape {
        /// An object to specify the expiration of a routing step.
        public let expiry: Expiry?
        /// A tagged union to specify expression for a routing step.
        public let expression: Expression?
        /// Represents status of the Routing step.
        public let status: RoutingCriteriaStepStatus?

        @inlinable
        public init(expiry: Expiry? = nil, expression: Expression? = nil, status: RoutingCriteriaStepStatus? = nil) {
            self.expiry = expiry
            self.expression = expression
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case expiry = "Expiry"
            case expression = "Expression"
            case status = "Status"
        }
    }

    public struct StopContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The type of recording being operated on.
        public let contactRecordingType: ContactRecordingType?
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactId: String, contactRecordingType: ContactRecordingType? = nil, initialContactId: String, instanceId: String) {
            self.contactId = contactId
            self.contactRecordingType = contactRecordingType
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case contactRecordingType = "ContactRecordingType"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct StopContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopContactRequest: AWSEncodableShape {
        /// The ID of the contact.
        public let contactId: String
        /// The reason a contact can be disconnected. Only Amazon Connect outbound campaigns can provide this field.
        public let disconnectReason: DisconnectReason?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactId: String, disconnectReason: DisconnectReason? = nil, instanceId: String) {
            self.contactId = contactId
            self.disconnectReason = disconnectReason
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case disconnectReason = "DisconnectReason"
            case instanceId = "InstanceId"
        }
    }

    public struct StopContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopContactStreamingRequest: AWSEncodableShape {
        /// The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the streaming configuration enabled.
        public let streamingId: String

        @inlinable
        public init(contactId: String, instanceId: String, streamingId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.streamingId = streamingId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.streamingId, name: "streamingId", parent: name, max: 100)
            try self.validate(self.streamingId, name: "streamingId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case streamingId = "StreamingId"
        }
    }

    public struct StopContactStreamingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StringCondition: AWSEncodableShape {
        /// The type of comparison to be made when evaluating the string condition.
        public let comparisonType: StringComparisonType?
        /// The name of the field in the string condition.
        public let fieldName: String?
        /// The value of the string.
        public let value: String?

        @inlinable
        public init(comparisonType: StringComparisonType? = nil, fieldName: String? = nil, value: String? = nil) {
            self.comparisonType = comparisonType
            self.fieldName = fieldName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonType = "ComparisonType"
            case fieldName = "FieldName"
            case value = "Value"
        }
    }

    public struct StringReference: AWSDecodableShape {
        /// Identifier of the string reference.
        public let name: String?
        /// A valid string.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct SubmitAutoEvaluationActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the auto-evaluation enabled form.
        public let evaluationFormId: String

        @inlinable
        public init(evaluationFormId: String) {
            self.evaluationFormId = evaluationFormId
        }

        public func validate(name: String) throws {
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 256)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormId = "EvaluationFormId"
        }
    }

    public struct SubmitContactEvaluationRequest: AWSEncodableShape {
        /// A map of question identifiers to answer value.
        public let answers: [String: EvaluationAnswerInput]?
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A map of question identifiers to note value.
        public let notes: [String: EvaluationNote]?

        @inlinable
        public init(answers: [String: EvaluationAnswerInput]? = nil, evaluationId: String, instanceId: String, notes: [String: EvaluationNote]? = nil) {
            self.answers = answers
            self.evaluationId = evaluationId
            self.instanceId = instanceId
            self.notes = notes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.answers, forKey: .answers)
            request.encodePath(self.evaluationId, key: "EvaluationId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.notes, forKey: .notes)
        }

        public func validate(name: String) throws {
            try self.answers?.forEach {
                try validate($0.key, name: "answers.key", parent: name, max: 500)
                try validate($0.key, name: "answers.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).answers[\"\($0.key)\"]")
            }
            try self.validate(self.answers, name: "answers", parent: name, max: 100)
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, max: 500)
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.notes?.forEach {
                try validate($0.key, name: "notes.key", parent: name, max: 500)
                try validate($0.key, name: "notes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).notes[\"\($0.key)\"]")
            }
            try self.validate(self.notes, name: "notes", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case answers = "Answers"
            case notes = "Notes"
        }
    }

    public struct SubmitContactEvaluationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        public let evaluationArn: String
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String

        @inlinable
        public init(evaluationArn: String, evaluationId: String) {
            self.evaluationArn = evaluationArn
            self.evaluationId = evaluationId
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationArn = "EvaluationArn"
            case evaluationId = "EvaluationId"
        }
    }

    public struct SuccessfulRequest: AWSDecodableShape {
        /// The contactId of the contact that was created successfully.
        public let contactId: String?
        /// Request identifier provided in the API call in the ContactDataRequest to create a contact.
        public let requestIdentifier: String?

        @inlinable
        public init(contactId: String? = nil, requestIdentifier: String? = nil) {
            self.contactId = contactId
            self.requestIdentifier = requestIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case requestIdentifier = "RequestIdentifier"
        }
    }

    public struct SuspendContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The type of recording being operated on.
        public let contactRecordingType: ContactRecordingType?
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactId: String, contactRecordingType: ContactRecordingType? = nil, initialContactId: String, instanceId: String) {
            self.contactId = contactId
            self.contactRecordingType = contactRecordingType
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case contactRecordingType = "ContactRecordingType"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct SuspendContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagCondition: AWSEncodableShape {
        /// The tag key in the tag condition.
        public let tagKey: String?
        /// The tag value in the tag condition.
        public let tagValue: String?

        @inlinable
        public init(tagKey: String? = nil, tagValue: String? = nil) {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }

        private enum CodingKeys: String, CodingKey {
            case tagKey = "TagKey"
            case tagValue = "TagValue"
        }
    }

    public struct TagContactRequest: AWSEncodableShape {
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The tags to be assigned to the contact resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.  Authorization is not supported by this tag.
        public let tags: [String: String]

        @inlinable
        public init(contactId: String, instanceId: String, tags: [String: String]) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 6)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case tags = "Tags"
        }
    }

    public struct TagContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagSearchCondition: AWSEncodableShape {
        /// The tag key used in the tag search condition.
        public let tagKey: String?
        /// The type of comparison to be made when evaluating the tag key in tag search condition.
        public let tagKeyComparisonType: StringComparisonType?
        /// The tag value used in the tag search condition.
        public let tagValue: String?
        /// The type of comparison to be made when evaluating the tag value in tag search condition.
        public let tagValueComparisonType: StringComparisonType?

        @inlinable
        public init(tagKey: String? = nil, tagKeyComparisonType: StringComparisonType? = nil, tagValue: String? = nil, tagValueComparisonType: StringComparisonType? = nil) {
            self.tagKey = tagKey
            self.tagKeyComparisonType = tagKeyComparisonType
            self.tagValue = tagValue
            self.tagValueComparisonType = tagValueComparisonType
        }

        public func validate(name: String) throws {
            try self.validate(self.tagKey, name: "tagKey", parent: name, max: 128)
            try self.validate(self.tagValue, name: "tagValue", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case tagKey = "tagKey"
            case tagKeyComparisonType = "tagKeyComparisonType"
            case tagValue = "tagValue"
            case tagValueComparisonType = "tagValueComparisonType"
        }
    }

    public struct TagSet: AWSDecodableShape {
        /// The tag key in the TagSet.
        public let key: String?
        /// The tag value in the tagSet.
        public let value: String?

        @inlinable
        public init(key: String? = nil, value: String? = nil) {
            self.key = key
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TaskActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The description. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let description: String?
        /// The name. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let name: String
        /// Information about the reference when the referenceType is URL. Otherwise, null. (Supports variable injection in the Value field.)
        public let references: [String: Reference]?

        @inlinable
        public init(contactFlowId: String, description: String? = nil, name: String, references: [String: Reference]? = nil) {
            self.contactFlowId = contactFlowId
            self.description = description
            self.name = name
            self.references = references
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, max: 512)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case description = "Description"
            case name = "Name"
            case references = "References"
        }
    }

    public struct TaskTemplateConstraints: AWSEncodableShape & AWSDecodableShape {
        /// Lists the fields that are invisible to agents.
        public let invisibleFields: [InvisibleFieldInfo]?
        /// Lists the fields that are read-only to agents, and cannot be edited.
        public let readOnlyFields: [ReadOnlyFieldInfo]?
        /// Lists the fields that are required to be filled by agents.
        public let requiredFields: [RequiredFieldInfo]?

        @inlinable
        public init(invisibleFields: [InvisibleFieldInfo]? = nil, readOnlyFields: [ReadOnlyFieldInfo]? = nil, requiredFields: [RequiredFieldInfo]? = nil) {
            self.invisibleFields = invisibleFields
            self.readOnlyFields = readOnlyFields
            self.requiredFields = requiredFields
        }

        public func validate(name: String) throws {
            try self.invisibleFields?.forEach {
                try $0.validate(name: "\(name).invisibleFields[]")
            }
            try self.readOnlyFields?.forEach {
                try $0.validate(name: "\(name).readOnlyFields[]")
            }
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invisibleFields = "InvisibleFields"
            case readOnlyFields = "ReadOnlyFields"
            case requiredFields = "RequiredFields"
        }
    }

    public struct TaskTemplateDefaultFieldValue: AWSEncodableShape & AWSDecodableShape {
        /// Default value for the field.
        public let defaultValue: String?
        /// Identifier of a field.
        public let id: TaskTemplateFieldIdentifier?

        @inlinable
        public init(defaultValue: String? = nil, id: TaskTemplateFieldIdentifier? = nil) {
            self.defaultValue = defaultValue
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 4096)
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case id = "Id"
        }
    }

    public struct TaskTemplateDefaults: AWSEncodableShape & AWSDecodableShape {
        /// Default value for the field.
        public let defaultFieldValues: [TaskTemplateDefaultFieldValue]?

        @inlinable
        public init(defaultFieldValues: [TaskTemplateDefaultFieldValue]? = nil) {
            self.defaultFieldValues = defaultFieldValues
        }

        public func validate(name: String) throws {
            try self.defaultFieldValues?.forEach {
                try $0.validate(name: "\(name).defaultFieldValues[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case defaultFieldValues = "DefaultFieldValues"
        }
    }

    public struct TaskTemplateField: AWSEncodableShape & AWSDecodableShape {
        /// The description of the field.
        public let description: String?
        /// The unique identifier for the field.
        public let id: TaskTemplateFieldIdentifier
        /// A list of options for a single select field.
        public let singleSelectOptions: [String]?
        /// Indicates the type of field.
        public let type: TaskTemplateFieldType?

        @inlinable
        public init(description: String? = nil, id: TaskTemplateFieldIdentifier, singleSelectOptions: [String]? = nil, type: TaskTemplateFieldType? = nil) {
            self.description = description
            self.id = id
            self.singleSelectOptions = singleSelectOptions
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.id.validate(name: "\(name).id")
            try self.singleSelectOptions?.forEach {
                try validate($0, name: "singleSelectOptions[]", parent: name, max: 100)
                try validate($0, name: "singleSelectOptions[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case singleSelectOptions = "SingleSelectOptions"
            case type = "Type"
        }
    }

    public struct TaskTemplateFieldIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the task template field.
        public let name: String?

        @inlinable
        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct TaskTemplateMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the task template.
        public let arn: String?
        /// The timestamp when the task template was created.
        public let createdTime: Date?
        /// The description of the task template.
        public let description: String?
        /// A unique identifier for the task template.
        public let id: String?
        /// The timestamp when the task template was last modified.
        public let lastModifiedTime: Date?
        /// The name of the task template.
        public let name: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        @inlinable
        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, id: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, status: TaskTemplateStatus? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case id = "Id"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct TelephonyConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about traffic distributions.
        public let distributions: [Distribution]

        @inlinable
        public init(distributions: [Distribution]) {
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case distributions = "Distributions"
        }
    }

    public struct TemplateAttributes: AWSEncodableShape {
        /// An object that specifies the custom attributes values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template.
        public let customAttributes: [String: String]?
        /// An object that specifies the customer profile attributes values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template.
        public let customerProfileAttributes: String?

        @inlinable
        public init(customAttributes: [String: String]? = nil, customerProfileAttributes: String? = nil) {
            self.customAttributes = customAttributes
            self.customerProfileAttributes = customerProfileAttributes
        }

        public func validate(name: String) throws {
            try self.customAttributes?.forEach {
                try validate($0.key, name: "customAttributes.key", parent: name, max: 32767)
                try validate($0.key, name: "customAttributes.key", parent: name, min: 1)
                try validate($0.value, name: "customAttributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case customAttributes = "CustomAttributes"
            case customerProfileAttributes = "CustomerProfileAttributes"
        }
    }

    public struct TemplatedMessageConfig: AWSEncodableShape {
        /// The identifier of the knowledge base. Can be either the ID or the ARN. URLs cannot contain the ARN.
        public let knowledgeBaseId: String
        /// The identifier of the message template Id.
        public let messageTemplateId: String
        /// Information about template attributes, that is, CustomAttributes or CustomerProfileAttributes.
        public let templateAttributes: TemplateAttributes

        @inlinable
        public init(knowledgeBaseId: String, messageTemplateId: String, templateAttributes: TemplateAttributes) {
            self.knowledgeBaseId = knowledgeBaseId
            self.messageTemplateId = messageTemplateId
            self.templateAttributes = templateAttributes
        }

        public func validate(name: String) throws {
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, max: 500)
            try self.validate(self.knowledgeBaseId, name: "knowledgeBaseId", parent: name, min: 1)
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, max: 500)
            try self.validate(self.messageTemplateId, name: "messageTemplateId", parent: name, min: 1)
            try self.templateAttributes.validate(name: "\(name).templateAttributes")
        }

        private enum CodingKeys: String, CodingKey {
            case knowledgeBaseId = "KnowledgeBaseId"
            case messageTemplateId = "MessageTemplateId"
            case templateAttributes = "TemplateAttributes"
        }
    }

    public struct Threshold: AWSEncodableShape & AWSDecodableShape {
        /// The type of comparison. Only "less than" (LT) comparisons are supported.
        public let comparison: Comparison?
        /// The threshold value to compare.
        public let thresholdValue: Double?

        @inlinable
        public init(comparison: Comparison? = nil, thresholdValue: Double? = nil) {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case thresholdValue = "ThresholdValue"
        }
    }

    public struct ThresholdV2: AWSEncodableShape & AWSDecodableShape {
        /// The type of comparison. Currently, "less than" (LT), "less than equal" (LTE), and "greater than" (GT) comparisons are supported.
        public let comparison: String?
        /// The threshold value to compare.
        public let thresholdValue: Double?

        @inlinable
        public init(comparison: String? = nil, thresholdValue: Double? = nil) {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }

        public func validate(name: String) throws {
            try self.validate(self.comparison, name: "comparison", parent: name, max: 250)
            try self.validate(self.comparison, name: "comparison", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case thresholdValue = "ThresholdValue"
        }
    }

    public struct TrafficDistributionGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The description of the traffic distribution group.
        public let description: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String?
        /// The Amazon Resource Name (ARN).
        public let instanceArn: String?
        /// Whether this is the default traffic distribution group created during instance replication. The default traffic distribution group cannot be deleted by the DeleteTrafficDistributionGroup API. The default traffic distribution group is deleted as part of the process for deleting a replica.  The SignInConfig distribution is available only on a
        /// default TrafficDistributionGroup (see the IsDefault parameter in the
        /// TrafficDistributionGroup data type). If you call UpdateTrafficDistribution with a modified SignInConfig and a non-default TrafficDistributionGroup, an InvalidRequestException is returned.
        public let isDefault: Bool?
        /// The name of the traffic distribution group.
        public let name: String?
        /// The status of the traffic distribution group.    CREATION_IN_PROGRESS means the previous CreateTrafficDistributionGroup operation is still in progress and has not yet completed.    ACTIVE means the previous CreateTrafficDistributionGroup operation has succeeded.    CREATION_FAILED indicates that the previous CreateTrafficDistributionGroup operation has failed.    PENDING_DELETION means the previous DeleteTrafficDistributionGroup operation is still in progress and has not yet completed.    DELETION_FAILED means the previous DeleteTrafficDistributionGroup operation has failed.    UPDATE_IN_PROGRESS means the previous UpdateTrafficDistribution operation is still in progress and has not yet completed.
        public let status: TrafficDistributionGroupStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, id: String? = nil, instanceArn: String? = nil, isDefault: Bool? = nil, name: String? = nil, status: TrafficDistributionGroupStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.instanceArn = instanceArn
            self.isDefault = isDefault
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case instanceArn = "InstanceArn"
            case isDefault = "IsDefault"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct TrafficDistributionGroupSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let instanceArn: String?
        /// Whether this is the default traffic distribution group created during instance replication. The default traffic distribution group cannot be deleted by the DeleteTrafficDistributionGroup API. The default traffic distribution group is deleted as part of the process for deleting a replica.
        public let isDefault: Bool?
        /// The name of the traffic distribution group.
        public let name: String?
        /// The status of the traffic distribution group.     CREATION_IN_PROGRESS means the previous CreateTrafficDistributionGroup operation is still in progress and has not yet completed.    ACTIVE means the previous CreateTrafficDistributionGroup operation has succeeded.    CREATION_FAILED indicates that the previous CreateTrafficDistributionGroup operation has failed.    PENDING_DELETION means the previous DeleteTrafficDistributionGroup operation is still in progress and has not yet completed.    DELETION_FAILED means the previous DeleteTrafficDistributionGroup operation has failed.    UPDATE_IN_PROGRESS means the previous UpdateTrafficDistributionGroup operation is still in progress and has not yet completed.
        public let status: TrafficDistributionGroupStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, instanceArn: String? = nil, isDefault: Bool? = nil, name: String? = nil, status: TrafficDistributionGroupStatus? = nil) {
            self.arn = arn
            self.id = id
            self.instanceArn = instanceArn
            self.isDefault = isDefault
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case instanceArn = "InstanceArn"
            case isDefault = "IsDefault"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct TrafficDistributionGroupUserSummary: AWSDecodableShape {
        /// The identifier for the user. This can be the ID or the ARN of the user.
        public let userId: String?

        @inlinable
        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "UserId"
        }
    }

    public struct Transcript: AWSEncodableShape {
        /// The list of search criteria based on Contact Lens conversational analytics transcript.
        public let criteria: [TranscriptCriteria]
        /// The match type combining search criteria using multiple transcript criteria.
        public let matchType: SearchContactsMatchType?

        @inlinable
        public init(criteria: [TranscriptCriteria], matchType: SearchContactsMatchType? = nil) {
            self.criteria = criteria
            self.matchType = matchType
        }

        public func validate(name: String) throws {
            try self.criteria.forEach {
                try $0.validate(name: "\(name).criteria[]")
            }
            try self.validate(self.criteria, name: "criteria", parent: name, max: 6)
        }

        private enum CodingKeys: String, CodingKey {
            case criteria = "Criteria"
            case matchType = "MatchType"
        }
    }

    public struct TranscriptCriteria: AWSEncodableShape {
        /// The match type combining search criteria using multiple search texts in a transcript criteria.
        public let matchType: SearchContactsMatchType
        /// The participant role in a transcript
        public let participantRole: ParticipantRole
        /// The words or phrases used to search within a transcript.
        public let searchText: [String]

        @inlinable
        public init(matchType: SearchContactsMatchType, participantRole: ParticipantRole, searchText: [String]) {
            self.matchType = matchType
            self.participantRole = participantRole
            self.searchText = searchText
        }

        public func validate(name: String) throws {
            try self.searchText.forEach {
                try validate($0, name: "searchText[]", parent: name, max: 128)
            }
            try self.validate(self.searchText, name: "searchText", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case matchType = "MatchType"
            case participantRole = "ParticipantRole"
            case searchText = "SearchText"
        }
    }

    public struct TransferContactRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String?
        /// The identifier for the user. This can be the ID or the ARN of the user.
        public let userId: String?

        @inlinable
        public init(clientToken: String? = TransferContactRequest.idempotencyToken(), contactFlowId: String, contactId: String, instanceId: String, queueId: String? = nil, userId: String? = nil) {
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.contactId = contactId
            self.instanceId = instanceId
            self.queueId = queueId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case queueId = "QueueId"
            case userId = "UserId"
        }
    }

    public struct TransferContactResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the contact.
        public let contactArn: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?

        @inlinable
        public init(contactArn: String? = nil, contactId: String? = nil) {
            self.contactArn = contactArn
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case contactId = "ContactId"
        }
    }

    public struct UntagContactRequest: AWSEncodableShape {
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A list of tag keys. Existing tags on the contact whose keys are members of this list will be removed.
        public let tagKeys: [String]

        @inlinable
        public init(contactId: String, instanceId: String, tagKeys: [String]) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "ContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.tagKeys, key: "TagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 6)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateAgentStatusRequest: AWSEncodableShape {
        /// The identifier of the agent status.
        public let agentStatusId: String
        /// The description of the agent status.
        public let description: String?
        /// The display order of the agent status.
        public let displayOrder: Int?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the agent status.
        public let name: String?
        /// A number indicating the reset order of the agent status.
        public let resetOrderNumber: Bool?
        /// The state of the agent status.
        public let state: AgentStatusState?

        @inlinable
        public init(agentStatusId: String, description: String? = nil, displayOrder: Int? = nil, instanceId: String, name: String? = nil, resetOrderNumber: Bool? = nil, state: AgentStatusState? = nil) {
            self.agentStatusId = agentStatusId
            self.description = description
            self.displayOrder = displayOrder
            self.instanceId = instanceId
            self.name = name
            self.resetOrderNumber = resetOrderNumber
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.agentStatusId, key: "AgentStatusId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayOrder, forKey: .displayOrder)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.resetOrderNumber, forKey: .resetOrderNumber)
            try container.encodeIfPresent(self.state, forKey: .state)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, max: 50)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayOrder = "DisplayOrder"
            case name = "Name"
            case resetOrderNumber = "ResetOrderNumber"
            case state = "State"
        }
    }

    public struct UpdateAuthenticationProfileRequest: AWSEncodableShape {
        /// A list of IP address range strings that are allowed to access the instance. For more information on how to configure IP addresses, seeConfigure session timeouts in the Amazon Connect Administrator Guide.
        public let allowedIps: [String]?
        /// A unique identifier for the authentication profile.
        public let authenticationProfileId: String
        /// A list of IP address range strings that are blocked from accessing the instance. For more information on how to configure IP addresses, For more information on how to configure IP addresses, see Configure IP-based access control in the Amazon Connect Administrator Guide.
        public let blockedIps: [String]?
        /// The description for the authentication profile.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name for the authentication profile.
        public let name: String?
        /// The short lived session duration configuration for users logged in to Amazon Connect, in minutes. This value determines the maximum possible time before an agent is authenticated. For more information, For more information on how to configure IP addresses, see Configure session timeouts in the Amazon Connect Administrator Guide.
        public let periodicSessionDuration: Int?

        @inlinable
        public init(allowedIps: [String]? = nil, authenticationProfileId: String, blockedIps: [String]? = nil, description: String? = nil, instanceId: String, name: String? = nil, periodicSessionDuration: Int? = nil) {
            self.allowedIps = allowedIps
            self.authenticationProfileId = authenticationProfileId
            self.blockedIps = blockedIps
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.periodicSessionDuration = periodicSessionDuration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedIps, forKey: .allowedIps)
            request.encodePath(self.authenticationProfileId, key: "AuthenticationProfileId")
            try container.encodeIfPresent(self.blockedIps, forKey: .blockedIps)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.periodicSessionDuration, forKey: .periodicSessionDuration)
        }

        public func validate(name: String) throws {
            try self.allowedIps?.forEach {
                try validate($0, name: "allowedIps[]", parent: name, max: 50)
                try validate($0, name: "allowedIps[]", parent: name, min: 2)
                try validate($0, name: "allowedIps[]", parent: name, pattern: "^[A-Za-z0-9:/]*$")
            }
            try self.validate(self.authenticationProfileId, name: "authenticationProfileId", parent: name, max: 100)
            try self.validate(self.authenticationProfileId, name: "authenticationProfileId", parent: name, min: 1)
            try self.blockedIps?.forEach {
                try validate($0, name: "blockedIps[]", parent: name, max: 50)
                try validate($0, name: "blockedIps[]", parent: name, min: 2)
                try validate($0, name: "blockedIps[]", parent: name, pattern: "^[A-Za-z0-9:/]*$")
            }
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.periodicSessionDuration, name: "periodicSessionDuration", parent: name, max: 60)
            try self.validate(self.periodicSessionDuration, name: "periodicSessionDuration", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedIps = "AllowedIps"
            case blockedIps = "BlockedIps"
            case description = "Description"
            case name = "Name"
            case periodicSessionDuration = "PeriodicSessionDuration"
        }
    }

    public struct UpdateCaseActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// An array of objects with Field ID and Value data.
        public let fields: [FieldValue]

        @inlinable
        public init(fields: [FieldValue]) {
            self.fields = fields
        }

        public func validate(name: String) throws {
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
        }
    }

    public struct UpdateContactAttributesRequest: AWSEncodableShape {
        /// The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes. You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters. In the Set contact attributes block, when the attributes for a contact exceed 32 KB, the contact is routed down the Error branch of the flow. As a mitigation, consider the following options:   Remove unnecessary attributes by setting their values to empty.   If the attributes are only used in one flow and don't need to be referred to outside of that flow (for example, by a Lambda or another flow), then use flow attributes. This way you aren't needlessly persisting the 32 KB of information from one flow to another. For more information, see Flow block: Set contact attributes in the Amazon Connect Administrator Guide.
        public let attributes: [String: String]
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(attributes: [String: String], initialContactId: String, instanceId: String) {
            self.attributes = attributes
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.attributes.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct UpdateContactAttributesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactEvaluationRequest: AWSEncodableShape {
        /// A map of question identifiers to answer value.
        public let answers: [String: EvaluationAnswerInput]?
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A map of question identifiers to note value.
        public let notes: [String: EvaluationNote]?

        @inlinable
        public init(answers: [String: EvaluationAnswerInput]? = nil, evaluationId: String, instanceId: String, notes: [String: EvaluationNote]? = nil) {
            self.answers = answers
            self.evaluationId = evaluationId
            self.instanceId = instanceId
            self.notes = notes
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.answers, forKey: .answers)
            request.encodePath(self.evaluationId, key: "EvaluationId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.notes, forKey: .notes)
        }

        public func validate(name: String) throws {
            try self.answers?.forEach {
                try validate($0.key, name: "answers.key", parent: name, max: 500)
                try validate($0.key, name: "answers.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).answers[\"\($0.key)\"]")
            }
            try self.validate(self.answers, name: "answers", parent: name, max: 100)
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, max: 500)
            try self.validate(self.evaluationId, name: "evaluationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.notes?.forEach {
                try validate($0.key, name: "notes.key", parent: name, max: 500)
                try validate($0.key, name: "notes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).notes[\"\($0.key)\"]")
            }
            try self.validate(self.notes, name: "notes", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case answers = "Answers"
            case notes = "Notes"
        }
    }

    public struct UpdateContactEvaluationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        public let evaluationArn: String
        /// A unique identifier for the contact evaluation.
        public let evaluationId: String

        @inlinable
        public init(evaluationArn: String, evaluationId: String) {
            self.evaluationArn = evaluationArn
            self.evaluationId = evaluationId
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationArn = "EvaluationArn"
            case evaluationId = "EvaluationId"
        }
    }

    public struct UpdateContactFlowContentRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The JSON string that represents the content of the flow. For an example, see Example flow in Amazon Connect Flow language.  Length Constraints: Minimum length of 1. Maximum length of 256000.
        public let content: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowId: String, content: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.content = content
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct UpdateContactFlowContentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactFlowMetadataRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The state of flow.
        public let contactFlowState: ContactFlowState?
        /// The description of the flow.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the flow.
        public let name: String?

        @inlinable
        public init(contactFlowId: String, contactFlowState: ContactFlowState? = nil, description: String? = nil, instanceId: String, name: String? = nil) {
            self.contactFlowId = contactFlowId
            self.contactFlowState = contactFlowState
            self.description = description
            self.instanceId = instanceId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            try container.encodeIfPresent(self.contactFlowState, forKey: .contactFlowState)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowState = "ContactFlowState"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateContactFlowMetadataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactFlowModuleContentRequest: AWSEncodableShape {
        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The JSON string that represents the content of the flow. For an example, see Example flow in Amazon Connect Flow language.
        public let content: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(contactFlowModuleId: String, content: String, instanceId: String) {
            self.contactFlowModuleId = contactFlowModuleId
            self.content = content
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowModuleId, key: "ContactFlowModuleId")
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, max: 256000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct UpdateContactFlowModuleContentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactFlowModuleMetadataRequest: AWSEncodableShape {
        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The description of the flow module.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the flow module.
        public let name: String?
        /// The state of flow module.
        public let state: ContactFlowModuleState?

        @inlinable
        public init(contactFlowModuleId: String, description: String? = nil, instanceId: String, name: String? = nil, state: ContactFlowModuleState? = nil) {
            self.contactFlowModuleId = contactFlowModuleId
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowModuleId, key: "ContactFlowModuleId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.state, forKey: .state)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case state = "State"
        }
    }

    public struct UpdateContactFlowModuleMetadataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactFlowNameRequest: AWSEncodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The description of the flow.
        public let description: String?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The name of the flow.
        public let name: String?

        @inlinable
        public init(contactFlowId: String, description: String? = nil, instanceId: String, name: String? = nil) {
            self.contactFlowId = contactFlowId
            self.description = description
            self.instanceId = instanceId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactFlowId, key: "ContactFlowId")
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateContactFlowNameResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactRequest: AWSEncodableShape {
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.
        public let contactId: String
        /// The endpoint of the customer for which the contact was initiated. For external audio contacts, this is usually the end customer's phone number. This value can only be updated for external audio contacts. For more information, see Amazon Connect Contact Lens integration in the Amazon Connect Administrator Guide.
        public let customerEndpoint: Endpoint?
        /// The description of the contact.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the contact.
        public let name: String?
        ///  Information about the queue associated with a contact. This parameter can only be updated for external audio contacts. It is used when you integrate third-party systems with Contact Lens for analytics. For more information, see Amazon Connect Contact Lens integration in the  Amazon Connect Administrator Guide.
        public let queueInfo: QueueInfoInput?
        /// Well-formed data on contact, shown to agents on Contact Control Panel (CCP).
        public let references: [String: Reference]?
        /// A set of system defined key-value pairs stored on individual contact segments (unique contact ID) using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows. Attribute keys can include only alphanumeric, -, and _. This field can be used to show channel subtype, such as connect:Guide. Currently Contact Expiry is the only segment attribute which can be updated by using the UpdateContact API.
        public let segmentAttributes: [String: SegmentAttributeValue]?
        /// External system endpoint for the contact was initiated. For external audio contacts, this is the phone number of the external system such as the contact center. This value can only be updated for external audio contacts. For more information, see Amazon Connect Contact Lens integration in the Amazon Connect Administrator Guide.
        public let systemEndpoint: Endpoint?
        /// Information about the agent associated with a contact. This parameter can only be updated for external audio contacts. It is used when you integrate third-party systems with Contact Lens for analytics. For more information, see Amazon Connect Contact Lens integration in the  Amazon Connect Administrator Guide.
        public let userInfo: UserInfo?

        @inlinable
        public init(contactId: String, customerEndpoint: Endpoint? = nil, description: String? = nil, instanceId: String, name: String? = nil, queueInfo: QueueInfoInput? = nil, references: [String: Reference]? = nil, segmentAttributes: [String: SegmentAttributeValue]? = nil, systemEndpoint: Endpoint? = nil, userInfo: UserInfo? = nil) {
            self.contactId = contactId
            self.customerEndpoint = customerEndpoint
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.queueInfo = queueInfo
            self.references = references
            self.segmentAttributes = segmentAttributes
            self.systemEndpoint = systemEndpoint
            self.userInfo = userInfo
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "ContactId")
            try container.encodeIfPresent(self.customerEndpoint, forKey: .customerEndpoint)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.queueInfo, forKey: .queueInfo)
            try container.encodeIfPresent(self.references, forKey: .references)
            try container.encodeIfPresent(self.segmentAttributes, forKey: .segmentAttributes)
            try container.encodeIfPresent(self.systemEndpoint, forKey: .systemEndpoint)
            try container.encodeIfPresent(self.userInfo, forKey: .userInfo)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.customerEndpoint?.validate(name: "\(name).customerEndpoint")
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
            try self.segmentAttributes?.forEach {
                try validate($0.key, name: "segmentAttributes.key", parent: name, max: 128)
                try validate($0.key, name: "segmentAttributes.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).segmentAttributes[\"\($0.key)\"]")
            }
            try self.systemEndpoint?.validate(name: "\(name).systemEndpoint")
            try self.userInfo?.validate(name: "\(name).userInfo")
        }

        private enum CodingKeys: String, CodingKey {
            case customerEndpoint = "CustomerEndpoint"
            case description = "Description"
            case name = "Name"
            case queueInfo = "QueueInfo"
            case references = "References"
            case segmentAttributes = "SegmentAttributes"
            case systemEndpoint = "SystemEndpoint"
            case userInfo = "UserInfo"
        }
    }

    public struct UpdateContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactRoutingDataRequest: AWSEncodableShape {
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Priority of the contact in the queue. The default priority for new contacts is 5. You can raise the priority of a contact compared to other contacts in the queue by assigning them a higher priority, such as 1 or 2.
        public let queuePriority: Int64?
        /// The number of seconds to add or subtract from the contact's routing age. Contacts are routed to agents on a first-come, first-serve basis. This means that changing their amount of time in queue compared to others also changes their position in queue.
        public let queueTimeAdjustmentSeconds: Int?
        /// Updates the routing criteria on the contact. These properties can be used to change how a contact is routed within the queue.
        public let routingCriteria: RoutingCriteriaInput?

        @inlinable
        public init(contactId: String, instanceId: String, queuePriority: Int64? = nil, queueTimeAdjustmentSeconds: Int? = nil, routingCriteria: RoutingCriteriaInput? = nil) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.queuePriority = queuePriority
            self.queueTimeAdjustmentSeconds = queueTimeAdjustmentSeconds
            self.routingCriteria = routingCriteria
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.contactId, key: "ContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.queuePriority, forKey: .queuePriority)
            try container.encodeIfPresent(self.queueTimeAdjustmentSeconds, forKey: .queueTimeAdjustmentSeconds)
            try container.encodeIfPresent(self.routingCriteria, forKey: .routingCriteria)
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.queuePriority, name: "queuePriority", parent: name, max: 9223372036854775807)
            try self.validate(self.queuePriority, name: "queuePriority", parent: name, min: 1)
            try self.routingCriteria?.validate(name: "\(name).routingCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case queuePriority = "QueuePriority"
            case queueTimeAdjustmentSeconds = "QueueTimeAdjustmentSeconds"
            case routingCriteria = "RoutingCriteria"
        }
    }

    public struct UpdateContactRoutingDataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactScheduleRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
        public let scheduledTime: Date

        @inlinable
        public init(contactId: String, instanceId: String, scheduledTime: Date) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.scheduledTime = scheduledTime
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case scheduledTime = "ScheduledTime"
        }
    }

    public struct UpdateContactScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateEmailAddressMetadataRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the email address.
        public let description: String?
        /// The display name of email address.
        public let displayName: String?
        /// The identifier of the email address.
        public let emailAddressId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(clientToken: String? = nil, description: String? = nil, displayName: String? = nil, emailAddressId: String, instanceId: String) {
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.emailAddressId = emailAddressId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.emailAddressId, key: "EmailAddressId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.emailAddressId, name: "emailAddressId", parent: name, max: 500)
            try self.validate(self.emailAddressId, name: "emailAddressId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case displayName = "DisplayName"
        }
    }

    public struct UpdateEmailAddressMetadataResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the email address.
        public let emailAddressArn: String?
        /// The identifier of the email address.
        public let emailAddressId: String?

        @inlinable
        public init(emailAddressArn: String? = nil, emailAddressId: String? = nil) {
            self.emailAddressArn = emailAddressArn
            self.emailAddressId = emailAddressId
        }

        private enum CodingKeys: String, CodingKey {
            case emailAddressArn = "EmailAddressArn"
            case emailAddressId = "EmailAddressId"
        }
    }

    public struct UpdateEvaluationFormRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A flag indicating whether the operation must create a new version.
        public let createNewVersion: Bool?
        /// The description of the evaluation form.
        public let description: String?
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// A version of the evaluation form to update.
        public let evaluationFormVersion: Int
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Items that are part of the evaluation form.  The total number of sections and questions must not exceed 100 each.  Questions must be contained in a section.
        public let items: [EvaluationFormItem]
        /// A scoring strategy of the evaluation form.
        public let scoringStrategy: EvaluationFormScoringStrategy?
        /// A title of the evaluation form.
        public let title: String

        @inlinable
        public init(clientToken: String? = UpdateEvaluationFormRequest.idempotencyToken(), createNewVersion: Bool? = nil, description: String? = nil, evaluationFormId: String, evaluationFormVersion: Int = 0, instanceId: String, items: [EvaluationFormItem], scoringStrategy: EvaluationFormScoringStrategy? = nil, title: String) {
            self.clientToken = clientToken
            self.createNewVersion = createNewVersion
            self.description = description
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
            self.instanceId = instanceId
            self.items = items
            self.scoringStrategy = scoringStrategy
            self.title = title
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.createNewVersion, forKey: .createNewVersion)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.evaluationFormId, key: "EvaluationFormId")
            try container.encode(self.evaluationFormVersion, forKey: .evaluationFormVersion)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.items, forKey: .items)
            try container.encodeIfPresent(self.scoringStrategy, forKey: .scoringStrategy)
            try container.encode(self.title, forKey: .title)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 1024)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, max: 500)
            try self.validate(self.evaluationFormId, name: "evaluationFormId", parent: name, min: 1)
            try self.validate(self.evaluationFormVersion, name: "evaluationFormVersion", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.items.forEach {
                try $0.validate(name: "\(name).items[]")
            }
            try self.validate(self.items, name: "items", parent: name, max: 100)
            try self.validate(self.items, name: "items", parent: name, min: 1)
            try self.validate(self.title, name: "title", parent: name, max: 128)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case createNewVersion = "CreateNewVersion"
            case description = "Description"
            case evaluationFormVersion = "EvaluationFormVersion"
            case items = "Items"
            case scoringStrategy = "ScoringStrategy"
            case title = "Title"
        }
    }

    public struct UpdateEvaluationFormResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the contact evaluation resource.
        public let evaluationFormArn: String
        /// The unique identifier for the evaluation form.
        public let evaluationFormId: String
        /// The version of the updated evaluation form resource.
        public let evaluationFormVersion: Int

        @inlinable
        public init(evaluationFormArn: String, evaluationFormId: String, evaluationFormVersion: Int) {
            self.evaluationFormArn = evaluationFormArn
            self.evaluationFormId = evaluationFormId
            self.evaluationFormVersion = evaluationFormVersion
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationFormArn = "EvaluationFormArn"
            case evaluationFormId = "EvaluationFormId"
            case evaluationFormVersion = "EvaluationFormVersion"
        }
    }

    public struct UpdateHoursOfOperationOverrideRequest: AWSEncodableShape {
        /// Configuration information for the hours of operation override: day, start time, and end time.
        public let config: [HoursOfOperationOverrideConfig]?
        /// The description of the hours of operation override.
        public let description: String?
        /// The date from when the hours of operation override would be effective.
        public let effectiveFrom: String?
        /// The date till when the hours of operation override would be effective.
        public let effectiveTill: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier for the hours of operation override.
        public let hoursOfOperationOverrideId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The name of the hours of operation override.
        public let name: String?

        @inlinable
        public init(config: [HoursOfOperationOverrideConfig]? = nil, description: String? = nil, effectiveFrom: String? = nil, effectiveTill: String? = nil, hoursOfOperationId: String, hoursOfOperationOverrideId: String, instanceId: String, name: String? = nil) {
            self.config = config
            self.description = description
            self.effectiveFrom = effectiveFrom
            self.effectiveTill = effectiveTill
            self.hoursOfOperationId = hoursOfOperationId
            self.hoursOfOperationOverrideId = hoursOfOperationOverrideId
            self.instanceId = instanceId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.config, forKey: .config)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.effectiveFrom, forKey: .effectiveFrom)
            try container.encodeIfPresent(self.effectiveTill, forKey: .effectiveTill)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.hoursOfOperationOverrideId, key: "HoursOfOperationOverrideId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.config?.forEach {
                try $0.validate(name: "\(name).config[]")
            }
            try self.validate(self.config, name: "config", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\P{C}\\r\\n\\t]{1,250}$")
            try self.validate(self.effectiveFrom, name: "effectiveFrom", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
            try self.validate(self.effectiveTill, name: "effectiveTill", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}$")
            try self.validate(self.hoursOfOperationOverrideId, name: "hoursOfOperationOverrideId", parent: name, max: 36)
            try self.validate(self.hoursOfOperationOverrideId, name: "hoursOfOperationOverrideId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\P{C}\\r\\n\\t]{1,127}$")
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case effectiveFrom = "EffectiveFrom"
            case effectiveTill = "EffectiveTill"
            case name = "Name"
        }
    }

    public struct UpdateHoursOfOperationRequest: AWSEncodableShape {
        /// Configuration information of the hours of operation.
        public let config: [HoursOfOperationConfig]?
        /// The description of the hours of operation.
        public let description: String?
        /// The identifier of the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the hours of operation.
        public let name: String?
        /// The time zone of the hours of operation.
        public let timeZone: String?

        @inlinable
        public init(config: [HoursOfOperationConfig]? = nil, description: String? = nil, hoursOfOperationId: String, instanceId: String, name: String? = nil, timeZone: String? = nil) {
            self.config = config
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.name = name
            self.timeZone = timeZone
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.config, forKey: .config)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.hoursOfOperationId, key: "HoursOfOperationId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.timeZone, forKey: .timeZone)
        }

        public func validate(name: String) throws {
            try self.config?.forEach {
                try $0.validate(name: "\(name).config[]")
            }
            try self.validate(self.config, name: "config", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case name = "Name"
            case timeZone = "TimeZone"
        }
    }

    public struct UpdateInstanceAttributeRequest: AWSEncodableShape {
        /// The type of attribute.  Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web ServicesSupport for allowlisting.
        public let attributeType: InstanceAttributeType
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The value for the attribute. Maximum character limit is 100.
        public let value: String

        @inlinable
        public init(attributeType: InstanceAttributeType, clientToken: String? = UpdateInstanceAttributeRequest.idempotencyToken(), instanceId: String, value: String) {
            self.attributeType = attributeType
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.value = value
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.attributeType, key: "AttributeType")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.value, forKey: .value)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 100)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case value = "Value"
        }
    }

    public struct UpdateInstanceStorageConfigRequest: AWSEncodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType
        public let storageConfig: InstanceStorageConfig

        @inlinable
        public init(associationId: String, clientToken: String? = UpdateInstanceStorageConfigRequest.idempotencyToken(), instanceId: String, resourceType: InstanceStorageResourceType, storageConfig: InstanceStorageConfig) {
            self.associationId = associationId
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.resourceType = resourceType
            self.storageConfig = storageConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.associationId, key: "AssociationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodeQuery(self.resourceType, key: "resourceType")
            try container.encode(self.storageConfig, forKey: .storageConfig)
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.storageConfig.validate(name: "\(name).storageConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case storageConfig = "StorageConfig"
        }
    }

    public struct UpdateParticipantAuthenticationRequest: AWSEncodableShape {
        /// The code query parameter provided by Cognito in the redirectUri.
        public let code: String?
        /// The error query parameter provided by Cognito in the redirectUri.
        public let error: String?
        /// The error_description parameter provided by Cognito in the redirectUri.
        public let errorDescription: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The state query parameter that was provided by Cognito in the redirectUri. This will also match the state parameter provided in the AuthenticationUrl from the GetAuthenticationUrl response.
        public let state: String

        @inlinable
        public init(code: String? = nil, error: String? = nil, errorDescription: String? = nil, instanceId: String, state: String) {
            self.code = code
            self.error = error
            self.errorDescription = errorDescription
            self.instanceId = instanceId
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.code, name: "code", parent: name, max: 2048)
            try self.validate(self.code, name: "code", parent: name, min: 1)
            try self.validate(self.error, name: "error", parent: name, max: 2048)
            try self.validate(self.error, name: "error", parent: name, min: 1)
            try self.validate(self.error, name: "error", parent: name, pattern: "^[\\x20-\\x21\\x23-\\x5B\\x5D-\\x7E]*$")
            try self.validate(self.errorDescription, name: "errorDescription", parent: name, max: 2048)
            try self.validate(self.errorDescription, name: "errorDescription", parent: name, min: 1)
            try self.validate(self.errorDescription, name: "errorDescription", parent: name, pattern: "^[\\x20-\\x21\\x23-\\x5B\\x5D-\\x7E]*$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.state, name: "state", parent: name, max: 1000)
            try self.validate(self.state, name: "state", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case error = "Error"
            case errorDescription = "ErrorDescription"
            case instanceId = "InstanceId"
            case state = "State"
        }
    }

    public struct UpdateParticipantAuthenticationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateParticipantRoleConfigRequest: AWSEncodableShape {
        /// The Amazon Connect channel you want to configure.
        public let channelConfiguration: UpdateParticipantRoleConfigChannelInfo
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(channelConfiguration: UpdateParticipantRoleConfigChannelInfo, contactId: String, instanceId: String) {
            self.channelConfiguration = channelConfiguration
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.channelConfiguration, forKey: .channelConfiguration)
            request.encodePath(self.contactId, key: "ContactId")
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.channelConfiguration.validate(name: "\(name).channelConfiguration")
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channelConfiguration = "ChannelConfiguration"
        }
    }

    public struct UpdateParticipantRoleConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePhoneNumberMetadataRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The description of the phone number.
        public let phoneNumberDescription: String?
        /// The Amazon Resource Name (ARN) or resource ID of the phone number.
        public let phoneNumberId: String

        @inlinable
        public init(clientToken: String? = UpdatePhoneNumberMetadataRequest.idempotencyToken(), phoneNumberDescription: String? = nil, phoneNumberId: String) {
            self.clientToken = clientToken
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.phoneNumberDescription, forKey: .phoneNumberDescription)
            request.encodePath(self.phoneNumberId, key: "PhoneNumberId")
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, max: 500)
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, pattern: "^[\\W\\S_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case phoneNumberDescription = "PhoneNumberDescription"
        }
    }

    public struct UpdatePhoneNumberRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance that phone numbers are claimed to. You can find the instance ID in the Amazon Resource Name (ARN) of the instance. You must enter InstanceId or TargetArn.
        public let instanceId: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone number inbound traffic is routed through. You must enter InstanceId or TargetArn.
        public let targetArn: String?

        @inlinable
        public init(clientToken: String? = UpdatePhoneNumberRequest.idempotencyToken(), instanceId: String? = nil, phoneNumberId: String, targetArn: String? = nil) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.phoneNumberId = phoneNumberId
            self.targetArn = targetArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.instanceId, forKey: .instanceId)
            request.encodePath(self.phoneNumberId, key: "PhoneNumberId")
            try container.encodeIfPresent(self.targetArn, forKey: .targetArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case instanceId = "InstanceId"
            case targetArn = "TargetArn"
        }
    }

    public struct UpdatePhoneNumberResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?

        @inlinable
        public init(phoneNumberArn: String? = nil, phoneNumberId: String? = nil) {
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct UpdatePredefinedAttributeRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the predefined attribute.
        public let name: String
        /// The values of the predefined attribute.
        public let values: PredefinedAttributeValues?

        @inlinable
        public init(instanceId: String, name: String, values: PredefinedAttributeValues? = nil) {
            self.instanceId = instanceId
            self.name = name
            self.values = values
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.name, key: "Name")
            try container.encodeIfPresent(self.values, forKey: .values)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 64)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.values?.validate(name: "\(name).values")
        }

        private enum CodingKeys: String, CodingKey {
            case values = "Values"
        }
    }

    public struct UpdatePromptRequest: AWSEncodableShape {
        /// A description of the prompt.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the prompt.
        public let name: String?
        /// A unique identifier for the prompt.
        public let promptId: String
        /// The URI for the S3 bucket where the prompt is stored. You can provide S3 pre-signed URLs returned by the
        /// GetPromptFile API instead of providing S3 URIs.
        public let s3Uri: String?

        @inlinable
        public init(description: String? = nil, instanceId: String, name: String? = nil, promptId: String, s3Uri: String? = nil) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.promptId = promptId
            self.s3Uri = s3Uri
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.promptId, key: "PromptId")
            try container.encodeIfPresent(self.s3Uri, forKey: .s3Uri)
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.promptId, name: "promptId", parent: name, max: 256)
            try self.validate(self.promptId, name: "promptId", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, max: 2000)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, min: 1)
            try self.validate(self.s3Uri, name: "s3Uri", parent: name, pattern: "^s3://\\S+/.+|https://\\\\S+\\\\.s3\\\\.\\\\S+\\\\.amazonaws\\\\.com/\\\\S+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case s3Uri = "S3Uri"
        }
    }

    public struct UpdatePromptResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let promptARN: String?
        /// A unique identifier for the prompt.
        public let promptId: String?

        @inlinable
        public init(promptARN: String? = nil, promptId: String? = nil) {
            self.promptARN = promptARN
            self.promptId = promptId
        }

        private enum CodingKeys: String, CodingKey {
            case promptARN = "PromptARN"
            case promptId = "PromptId"
        }
    }

    public struct UpdateQueueHoursOfOperationRequest: AWSEncodableShape {
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(hoursOfOperationId: String, instanceId: String, queueId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.hoursOfOperationId, forKey: .hoursOfOperationId)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationId = "HoursOfOperationId"
        }
    }

    public struct UpdateQueueMaxContactsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public let maxContacts: Int?
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(instanceId: String, maxContacts: Int? = nil, queueId: String) {
            self.instanceId = instanceId
            self.maxContacts = maxContacts
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.maxContacts, forKey: .maxContacts)
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxContacts, name: "maxContacts", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxContacts = "MaxContacts"
        }
    }

    public struct UpdateQueueNameRequest: AWSEncodableShape {
        /// The description of the queue.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the queue.
        public let name: String?
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(description: String? = nil, instanceId: String, name: String? = nil, queueId: String) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateQueueOutboundCallerConfigRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The outbound caller ID name, number, and outbound whisper flow.
        public let outboundCallerConfig: OutboundCallerConfig
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(instanceId: String, outboundCallerConfig: OutboundCallerConfig, queueId: String) {
            self.instanceId = instanceId
            self.outboundCallerConfig = outboundCallerConfig
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.outboundCallerConfig, forKey: .outboundCallerConfig)
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.outboundCallerConfig.validate(name: "\(name).outboundCallerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case outboundCallerConfig = "OutboundCallerConfig"
        }
    }

    public struct UpdateQueueOutboundEmailConfigRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The outbound email address ID for a specified queue.
        public let outboundEmailConfig: OutboundEmailConfig
        /// The identifier for the queue.
        public let queueId: String

        @inlinable
        public init(instanceId: String, outboundEmailConfig: OutboundEmailConfig, queueId: String) {
            self.instanceId = instanceId
            self.outboundEmailConfig = outboundEmailConfig
            self.queueId = queueId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.outboundEmailConfig, forKey: .outboundEmailConfig)
            request.encodePath(self.queueId, key: "QueueId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.outboundEmailConfig.validate(name: "\(name).outboundEmailConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case outboundEmailConfig = "OutboundEmailConfig"
        }
    }

    public struct UpdateQueueStatusRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String
        /// The status of the queue.
        public let status: QueueStatus

        @inlinable
        public init(instanceId: String, queueId: String, status: QueueStatus) {
            self.instanceId = instanceId
            self.queueId = queueId
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.queueId, key: "QueueId")
            try container.encode(self.status, forKey: .status)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct UpdateQuickConnectConfigRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Information about the configuration settings for the quick connect.
        public let quickConnectConfig: QuickConnectConfig
        /// The identifier for the quick connect.
        public let quickConnectId: String

        @inlinable
        public init(instanceId: String, quickConnectConfig: QuickConnectConfig, quickConnectId: String) {
            self.instanceId = instanceId
            self.quickConnectConfig = quickConnectConfig
            self.quickConnectId = quickConnectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.quickConnectConfig, forKey: .quickConnectConfig)
            request.encodePath(self.quickConnectId, key: "QuickConnectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.quickConnectConfig.validate(name: "\(name).quickConnectConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectConfig = "QuickConnectConfig"
        }
    }

    public struct UpdateQuickConnectNameRequest: AWSEncodableShape {
        /// The description of the quick connect.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the quick connect.
        public let name: String?
        /// The identifier for the quick connect.
        public let quickConnectId: String

        @inlinable
        public init(description: String? = nil, instanceId: String, name: String? = nil, quickConnectId: String) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.quickConnectId = quickConnectId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.quickConnectId, key: "QuickConnectId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateRoutingProfileAgentAvailabilityTimerRequest: AWSEncodableShape {
        /// Whether agents with this routing profile will have their routing order calculated based on time since their last inbound contact or longest idle time.
        public let agentAvailabilityTimer: AgentAvailabilityTimer
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(agentAvailabilityTimer: AgentAvailabilityTimer, instanceId: String, routingProfileId: String) {
            self.agentAvailabilityTimer = agentAvailabilityTimer
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.agentAvailabilityTimer, forKey: .agentAvailabilityTimer)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agentAvailabilityTimer = "AgentAvailabilityTimer"
        }
    }

    public struct UpdateRoutingProfileConcurrencyRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The channels that agents can handle in the Contact Control Panel (CCP).
        public let mediaConcurrencies: [MediaConcurrency]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(instanceId: String, mediaConcurrencies: [MediaConcurrency], routingProfileId: String) {
            self.instanceId = instanceId
            self.mediaConcurrencies = mediaConcurrencies
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.mediaConcurrencies, forKey: .mediaConcurrencies)
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.mediaConcurrencies.forEach {
                try $0.validate(name: "\(name).mediaConcurrencies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case mediaConcurrencies = "MediaConcurrencies"
        }
    }

    public struct UpdateRoutingProfileDefaultOutboundQueueRequest: AWSEncodableShape {
        /// The identifier for the default outbound queue.
        public let defaultOutboundQueueId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(defaultOutboundQueueId: String, instanceId: String, routingProfileId: String) {
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.defaultOutboundQueueId, forKey: .defaultOutboundQueueId)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultOutboundQueueId = "DefaultOutboundQueueId"
        }
    }

    public struct UpdateRoutingProfileNameRequest: AWSEncodableShape {
        /// The description of the routing profile. Must not be more than 250 characters.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the routing profile. Must not be more than 127 characters.
        public let name: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(description: String? = nil, instanceId: String, name: String? = nil, routingProfileId: String) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateRoutingProfileQueuesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.
        public let queueConfigs: [RoutingProfileQueueConfig]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        @inlinable
        public init(instanceId: String, queueConfigs: [RoutingProfileQueueConfig], routingProfileId: String) {
            self.instanceId = instanceId
            self.queueConfigs = queueConfigs
            self.routingProfileId = routingProfileId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.queueConfigs, forKey: .queueConfigs)
            request.encodePath(self.routingProfileId, key: "RoutingProfileId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.queueConfigs.forEach {
                try $0.validate(name: "\(name).queueConfigs[]")
            }
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, max: 10)
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queueConfigs = "QueueConfigs"
        }
    }

    public struct UpdateRuleRequest: AWSEncodableShape {
        /// A list of actions to be run when the rule is triggered.
        public let actions: [RuleAction]
        /// The conditions of the rule.
        public let function: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the rule. You can change the name only if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// A unique identifier for the rule.
        public let ruleId: String

        @inlinable
        public init(actions: [RuleAction], function: String, instanceId: String, name: String, publishStatus: RulePublishStatus, ruleId: String) {
            self.actions = actions
            self.function = function
            self.instanceId = instanceId
            self.name = name
            self.publishStatus = publishStatus
            self.ruleId = ruleId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actions, forKey: .actions)
            try container.encode(self.function, forKey: .function)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
            try container.encode(self.publishStatus, forKey: .publishStatus)
            request.encodePath(self.ruleId, key: "RuleId")
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 256)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case function = "Function"
            case name = "Name"
            case publishStatus = "PublishStatus"
        }
    }

    public struct UpdateSecurityProfileRequest: AWSEncodableShape {
        /// The identifier of the hierarchy group that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlHierarchyGroupId: String?
        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlTags: [String: String]?
        /// A list of the third-party application's metadata.
        public let applications: [Application]?
        /// The description of the security profile.
        public let description: String?
        /// The list of resources that a security profile applies hierarchy restrictions to in Amazon Connect. Following are acceptable ResourceNames: User.
        public let hierarchyRestrictedResources: [String]?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The permissions granted to a security profile. For a list of valid permissions, see List of security profile permissions.
        public let permissions: [String]?
        /// The identifier for the security profle.
        public let securityProfileId: String
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
        public let tagRestrictedResources: [String]?

        @inlinable
        public init(allowedAccessControlHierarchyGroupId: String? = nil, allowedAccessControlTags: [String: String]? = nil, applications: [Application]? = nil, description: String? = nil, hierarchyRestrictedResources: [String]? = nil, instanceId: String, permissions: [String]? = nil, securityProfileId: String, tagRestrictedResources: [String]? = nil) {
            self.allowedAccessControlHierarchyGroupId = allowedAccessControlHierarchyGroupId
            self.allowedAccessControlTags = allowedAccessControlTags
            self.applications = applications
            self.description = description
            self.hierarchyRestrictedResources = hierarchyRestrictedResources
            self.instanceId = instanceId
            self.permissions = permissions
            self.securityProfileId = securityProfileId
            self.tagRestrictedResources = tagRestrictedResources
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowedAccessControlHierarchyGroupId, forKey: .allowedAccessControlHierarchyGroupId)
            try container.encodeIfPresent(self.allowedAccessControlTags, forKey: .allowedAccessControlTags)
            try container.encodeIfPresent(self.applications, forKey: .applications)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.hierarchyRestrictedResources, forKey: .hierarchyRestrictedResources)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.permissions, forKey: .permissions)
            request.encodePath(self.securityProfileId, key: "SecurityProfileId")
            try container.encodeIfPresent(self.tagRestrictedResources, forKey: .tagRestrictedResources)
        }

        public func validate(name: String) throws {
            try self.allowedAccessControlTags?.forEach {
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, max: 128)
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, min: 1)
                try validate($0.value, name: "allowedAccessControlTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.allowedAccessControlTags, name: "allowedAccessControlTags", parent: name, max: 4)
            try self.applications?.forEach {
                try $0.validate(name: "\(name).applications[]")
            }
            try self.validate(self.applications, name: "applications", parent: name, max: 10)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.hierarchyRestrictedResources?.forEach {
                try validate($0, name: "hierarchyRestrictedResources[]", parent: name, max: 128)
                try validate($0, name: "hierarchyRestrictedResources[]", parent: name, min: 1)
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, max: 128)
                try validate($0, name: "permissions[]", parent: name, min: 1)
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 500)
            try self.tagRestrictedResources?.forEach {
                try validate($0, name: "tagRestrictedResources[]", parent: name, max: 128)
                try validate($0, name: "tagRestrictedResources[]", parent: name, min: 1)
            }
            try self.validate(self.tagRestrictedResources, name: "tagRestrictedResources", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAccessControlHierarchyGroupId = "AllowedAccessControlHierarchyGroupId"
            case allowedAccessControlTags = "AllowedAccessControlTags"
            case applications = "Applications"
            case description = "Description"
            case hierarchyRestrictedResources = "HierarchyRestrictedResources"
            case permissions = "Permissions"
            case tagRestrictedResources = "TagRestrictedResources"
        }
    }

    public struct UpdateTaskTemplateRequest: AWSEncodableShape {
        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the task template.
        public let name: String?
        /// The ContactFlowId for the flow that will be run if this template is used to create a self-assigned task.
        public let selfAssignFlowId: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?
        /// A unique identifier for the task template.
        public let taskTemplateId: String

        @inlinable
        public init(constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField]? = nil, instanceId: String, name: String? = nil, selfAssignFlowId: String? = nil, status: TaskTemplateStatus? = nil, taskTemplateId: String) {
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.instanceId = instanceId
            self.name = name
            self.selfAssignFlowId = selfAssignFlowId
            self.status = status
            self.taskTemplateId = taskTemplateId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.constraints, forKey: .constraints)
            try container.encodeIfPresent(self.contactFlowId, forKey: .contactFlowId)
            try container.encodeIfPresent(self.defaults, forKey: .defaults)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.fields, forKey: .fields)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            try container.encodeIfPresent(self.selfAssignFlowId, forKey: .selfAssignFlowId)
            try container.encodeIfPresent(self.status, forKey: .status)
            request.encodePath(self.taskTemplateId, key: "TaskTemplateId")
        }

        public func validate(name: String) throws {
            try self.constraints?.validate(name: "\(name).constraints")
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.defaults?.validate(name: "\(name).defaults")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.fields?.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.selfAssignFlowId, name: "selfAssignFlowId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case name = "Name"
            case selfAssignFlowId = "SelfAssignFlowId"
            case status = "Status"
        }
    }

    public struct UpdateTaskTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the task template resource.
        public let arn: String?
        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The timestamp when the task template was created.
        public let createdTime: Date?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]?
        /// The identifier of the task template resource.
        public let id: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String?
        /// The timestamp when the task template was last modified.
        public let lastModifiedTime: Date?
        /// The name of the task template.
        public let name: String?
        /// The ContactFlowId for the flow that will be run if this template is used to create a self-assigned task.
        public let selfAssignFlowId: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        @inlinable
        public init(arn: String? = nil, constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, createdTime: Date? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField]? = nil, id: String? = nil, instanceId: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, selfAssignFlowId: String? = nil, status: TaskTemplateStatus? = nil) {
            self.arn = arn
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.createdTime = createdTime
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.id = id
            self.instanceId = instanceId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.selfAssignFlowId = selfAssignFlowId
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case createdTime = "CreatedTime"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case id = "Id"
            case instanceId = "InstanceId"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case selfAssignFlowId = "SelfAssignFlowId"
            case status = "Status"
        }
    }

    public struct UpdateTrafficDistributionRequest: AWSEncodableShape {
        /// The distribution of agents between the instance and its replica(s).
        public let agentConfig: AgentConfig?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String
        /// The distribution that determines which Amazon Web Services Regions should be used to sign in agents in to both the instance and its replica(s).
        public let signInConfig: SignInConfig?
        /// The distribution of traffic between the instance and its replica(s).
        public let telephonyConfig: TelephonyConfig?

        @inlinable
        public init(agentConfig: AgentConfig? = nil, id: String, signInConfig: SignInConfig? = nil, telephonyConfig: TelephonyConfig? = nil) {
            self.agentConfig = agentConfig
            self.id = id
            self.signInConfig = signInConfig
            self.telephonyConfig = telephonyConfig
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.agentConfig, forKey: .agentConfig)
            request.encodePath(self.id, key: "Id")
            try container.encodeIfPresent(self.signInConfig, forKey: .signInConfig)
            try container.encodeIfPresent(self.telephonyConfig, forKey: .telephonyConfig)
        }

        public func validate(name: String) throws {
            try self.agentConfig?.validate(name: "\(name).agentConfig")
            try self.validate(self.id, name: "id", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.signInConfig?.validate(name: "\(name).signInConfig")
            try self.telephonyConfig?.validate(name: "\(name).telephonyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case agentConfig = "AgentConfig"
            case signInConfig = "SignInConfig"
            case telephonyConfig = "TelephonyConfig"
        }
    }

    public struct UpdateTrafficDistributionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateUserHierarchyGroupNameRequest: AWSEncodableShape {
        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The name of the hierarchy group. Must not be more than 100 characters.
        public let name: String

        @inlinable
        public init(hierarchyGroupId: String, instanceId: String, name: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
            self.name = name
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.hierarchyGroupId, key: "HierarchyGroupId")
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.name, forKey: .name)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateUserHierarchyRequest: AWSEncodableShape {
        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String?
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(hierarchyGroupId: String? = nil, instanceId: String, userId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.hierarchyGroupId, forKey: .hierarchyGroupId)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupId = "HierarchyGroupId"
        }
    }

    public struct UpdateUserHierarchyStructureRequest: AWSEncodableShape {
        /// The hierarchy levels to update.
        public let hierarchyStructure: HierarchyStructureUpdate
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String

        @inlinable
        public init(hierarchyStructure: HierarchyStructureUpdate, instanceId: String) {
            self.hierarchyStructure = hierarchyStructure
            self.instanceId = instanceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.hierarchyStructure, forKey: .hierarchyStructure)
            request.encodePath(self.instanceId, key: "InstanceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyStructure = "HierarchyStructure"
        }
    }

    public struct UpdateUserIdentityInfoRequest: AWSEncodableShape {
        /// The identity information for the user.
        public let identityInfo: UserIdentityInfo
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(identityInfo: UserIdentityInfo, instanceId: String, userId: String) {
            self.identityInfo = identityInfo
            self.instanceId = instanceId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.identityInfo, forKey: .identityInfo)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.identityInfo.validate(name: "\(name).identityInfo")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityInfo = "IdentityInfo"
        }
    }

    public struct UpdateUserPhoneConfigRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// Information about phone configuration settings for the user.
        public let phoneConfig: UserPhoneConfig
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(instanceId: String, phoneConfig: UserPhoneConfig, userId: String) {
            self.instanceId = instanceId
            self.phoneConfig = phoneConfig
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.phoneConfig, forKey: .phoneConfig)
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.phoneConfig.validate(name: "\(name).phoneConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneConfig = "PhoneConfig"
        }
    }

    public struct UpdateUserProficienciesRequest: AWSEncodableShape {
        ///  The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String
        /// The proficiencies to be updated for the user. Proficiencies must first be associated to the user. You can do this using AssociateUserProficiencies API.
        public let userProficiencies: [UserProficiency]

        @inlinable
        public init(instanceId: String, userId: String, userProficiencies: [UserProficiency]) {
            self.instanceId = instanceId
            self.userId = userId
            self.userProficiencies = userProficiencies
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            request.encodePath(self.userId, key: "UserId")
            try container.encode(self.userProficiencies, forKey: .userProficiencies)
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.userProficiencies.forEach {
                try $0.validate(name: "\(name).userProficiencies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userProficiencies = "UserProficiencies"
        }
    }

    public struct UpdateUserRoutingProfileRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(instanceId: String, routingProfileId: String, userId: String) {
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.routingProfileId, forKey: .routingProfileId)
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case routingProfileId = "RoutingProfileId"
        }
    }

    public struct UpdateUserSecurityProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instance ID in the Amazon Resource Name (ARN) of the instance.
        public let instanceId: String
        /// The identifiers of the security profiles for the user.
        public let securityProfileIds: [String]
        /// The identifier of the user account.
        public let userId: String

        @inlinable
        public init(instanceId: String, securityProfileIds: [String], userId: String) {
            self.instanceId = instanceId
            self.securityProfileIds = securityProfileIds
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.securityProfileIds, forKey: .securityProfileIds)
            request.encodePath(self.userId, key: "UserId")
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, max: 10)
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityProfileIds = "SecurityProfileIds"
        }
    }

    public struct UpdateViewContentRequest: AWSEncodableShape {
        /// View content containing all content necessary to render a view except for runtime input data and the runtime input schema, which is auto-generated by this operation. The total uncompressed content has a maximum file size of 400kB.
        public let content: ViewInputContent
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public let status: ViewStatus
        /// The identifier of the view. Both ViewArn and ViewId can be used.
        public let viewId: String

        @inlinable
        public init(content: ViewInputContent, instanceId: String, status: ViewStatus, viewId: String) {
            self.content = content
            self.instanceId = instanceId
            self.status = status
            self.viewId = viewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.content, forKey: .content)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encode(self.status, forKey: .status)
            request.encodePath(self.viewId, key: "ViewId")
        }

        public func validate(name: String) throws {
            try self.content.validate(name: "\(name).content")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.viewId, name: "viewId", parent: name, max: 500)
            try self.validate(self.viewId, name: "viewId", parent: name, min: 1)
            try self.validate(self.viewId, name: "viewId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/$]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case status = "Status"
        }
    }

    public struct UpdateViewContentResponse: AWSDecodableShape {
        /// A view resource object. Contains metadata and content necessary to render the view.
        public let view: View?

        @inlinable
        public init(view: View? = nil) {
            self.view = view
        }

        private enum CodingKeys: String, CodingKey {
            case view = "View"
        }
    }

    public struct UpdateViewMetadataRequest: AWSEncodableShape {
        /// The description of the view.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the view.
        public let name: String?
        /// The identifier of the view. Both ViewArn and ViewId can be used.
        public let viewId: String

        @inlinable
        public init(description: String? = nil, instanceId: String, name: String? = nil, viewId: String) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.viewId = viewId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            request.encodePath(self.instanceId, key: "InstanceId")
            try container.encodeIfPresent(self.name, forKey: .name)
            request.encodePath(self.viewId, key: "ViewId")
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^([\\p{L}\\p{N}_.:\\/=+\\-@,()']+[\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@,()']*)$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/]+$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^([\\p{L}\\p{N}_.:\\/=+\\-@()']+[\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@()']*)$")
            try self.validate(self.viewId, name: "viewId", parent: name, max: 500)
            try self.validate(self.viewId, name: "viewId", parent: name, min: 1)
            try self.validate(self.viewId, name: "viewId", parent: name, pattern: "^[a-zA-Z0-9\\_\\-:\\/$]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateViewMetadataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UploadUrlMetadata: AWSDecodableShape {
        /// A map of headers that should be provided when uploading the attached file.
        public let headersToInclude: [String: String]?
        /// A pre-signed S3 URL that should be used for uploading the attached file.
        public let url: String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public let urlExpiry: String?

        @inlinable
        public init(headersToInclude: [String: String]? = nil, url: String? = nil, urlExpiry: String? = nil) {
            self.headersToInclude = headersToInclude
            self.url = url
            self.urlExpiry = urlExpiry
        }

        private enum CodingKeys: String, CodingKey {
            case headersToInclude = "HeadersToInclude"
            case url = "Url"
            case urlExpiry = "UrlExpiry"
        }
    }

    public struct UrlReference: AWSDecodableShape {
        /// Identifier of the URL reference.
        public let name: String?
        /// A valid URL.
        public let value: String?

        @inlinable
        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct UseCase: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the use case.
        public let useCaseArn: String?
        /// The identifier for the use case.
        public let useCaseId: String?
        /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
        public let useCaseType: UseCaseType?

        @inlinable
        public init(useCaseArn: String? = nil, useCaseId: String? = nil, useCaseType: UseCaseType? = nil) {
            self.useCaseArn = useCaseArn
            self.useCaseId = useCaseId
            self.useCaseType = useCaseType
        }

        private enum CodingKeys: String, CodingKey {
            case useCaseArn = "UseCaseArn"
            case useCaseId = "UseCaseId"
            case useCaseType = "UseCaseType"
        }
    }

    public struct User: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user account.
        public let arn: String?
        /// The identifier of the user account in the directory used for identity management.
        public let directoryUserId: String?
        /// The identifier of the hierarchy group for the user.
        public let hierarchyGroupId: String?
        /// The identifier of the user account.
        public let id: String?
        /// Information about the user identity.
        public let identityInfo: UserIdentityInfo?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// Information about the phone configuration for the user.
        public let phoneConfig: UserPhoneConfig?
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String?
        /// The identifiers of the security profiles for the user.
        public let securityProfileIds: [String]?
        /// The tags.
        public let tags: [String: String]?
        /// The user name assigned to the user account.
        public let username: String?

        @inlinable
        public init(arn: String? = nil, directoryUserId: String? = nil, hierarchyGroupId: String? = nil, id: String? = nil, identityInfo: UserIdentityInfo? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, phoneConfig: UserPhoneConfig? = nil, routingProfileId: String? = nil, securityProfileIds: [String]? = nil, tags: [String: String]? = nil, username: String? = nil) {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case id = "Id"
            case identityInfo = "IdentityInfo"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct UserData: AWSDecodableShape {
        ///  A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots.
        public let activeSlotsByChannel: [Channel: Int]?
        /// A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots.
        public let availableSlotsByChannel: [Channel: Int]?
        /// A list of contact reference information.
        public let contacts: [AgentContactReference]?
        /// Contains information about the levels of a hierarchy group assigned to a user.
        public let hierarchyPath: HierarchyPathReference?
        /// A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from MediaConcurrency of the RoutingProfile assigned to the agent.
        public let maxSlotsByChannel: [Channel: Int]?
        /// The Next status of the agent.
        public let nextStatus: String?
        /// Information about the routing profile that is assigned to the user.
        public let routingProfile: RoutingProfileReference?
        /// The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.
        public let status: AgentStatusReference?
        /// Information about the user for the data that is returned. It contains the resourceId and ARN of the user.
        public let user: UserReference?

        @inlinable
        public init(activeSlotsByChannel: [Channel: Int]? = nil, availableSlotsByChannel: [Channel: Int]? = nil, contacts: [AgentContactReference]? = nil, hierarchyPath: HierarchyPathReference? = nil, maxSlotsByChannel: [Channel: Int]? = nil, nextStatus: String? = nil, routingProfile: RoutingProfileReference? = nil, status: AgentStatusReference? = nil, user: UserReference? = nil) {
            self.activeSlotsByChannel = activeSlotsByChannel
            self.availableSlotsByChannel = availableSlotsByChannel
            self.contacts = contacts
            self.hierarchyPath = hierarchyPath
            self.maxSlotsByChannel = maxSlotsByChannel
            self.nextStatus = nextStatus
            self.routingProfile = routingProfile
            self.status = status
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case activeSlotsByChannel = "ActiveSlotsByChannel"
            case availableSlotsByChannel = "AvailableSlotsByChannel"
            case contacts = "Contacts"
            case hierarchyPath = "HierarchyPath"
            case maxSlotsByChannel = "MaxSlotsByChannel"
            case nextStatus = "NextStatus"
            case routingProfile = "RoutingProfile"
            case status = "Status"
            case user = "User"
        }
    }

    public struct UserDataFilters: AWSEncodableShape {
        /// A list of up to 100 agent IDs or ARNs.
        public let agents: [String]?
        /// A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states.
        public let contactFilter: ContactFilter?
        /// A list of up to 100 queues or ARNs.
        public let queues: [String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public let routingProfiles: [String]?
        /// A UserHierarchyGroup ID or ARN.
        public let userHierarchyGroups: [String]?

        @inlinable
        public init(agents: [String]? = nil, contactFilter: ContactFilter? = nil, queues: [String]? = nil, routingProfiles: [String]? = nil, userHierarchyGroups: [String]? = nil) {
            self.agents = agents
            self.contactFilter = contactFilter
            self.queues = queues
            self.routingProfiles = routingProfiles
            self.userHierarchyGroups = userHierarchyGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.agents, name: "agents", parent: name, max: 100)
            try self.validate(self.agents, name: "agents", parent: name, min: 1)
            try self.contactFilter?.validate(name: "\(name).contactFilter")
            try self.validate(self.queues, name: "queues", parent: name, max: 100)
            try self.validate(self.queues, name: "queues", parent: name, min: 1)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, max: 100)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, min: 1)
            try self.validate(self.userHierarchyGroups, name: "userHierarchyGroups", parent: name, max: 1)
            try self.validate(self.userHierarchyGroups, name: "userHierarchyGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agents = "Agents"
            case contactFilter = "ContactFilter"
            case queues = "Queues"
            case routingProfiles = "RoutingProfiles"
            case userHierarchyGroups = "UserHierarchyGroups"
        }
    }

    public struct UserHierarchyGroupSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [UserHierarchyGroupSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [UserHierarchyGroupSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.  The currently supported values for FieldName are name, parentId, levelId, and resourceID.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [UserHierarchyGroupSearchCriteria]? = nil, orConditions: [UserHierarchyGroupSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct UserHierarchyGroupSearchFilter: AWSEncodableShape {
        /// An object that can be used to specify Tag conditions inside the SearchFilter. This accepts an OR or AND (List of List) input where:   The top level list specifies conditions that need to be applied with OR operator.   The inner list specifies conditions that need to be applied with AND operator.
        public let attributeFilter: ControlPlaneAttributeFilter?

        @inlinable
        public init(attributeFilter: ControlPlaneAttributeFilter? = nil) {
            self.attributeFilter = attributeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "AttributeFilter"
        }
    }

    public struct UserIdentityInfo: AWSEncodableShape & AWSDecodableShape {
        /// The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        public let email: String?
        /// The first name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        public let firstName: String?
        /// The last name. This is required if you are using Amazon Connect or SAML for identity management. Inputs must be in Unicode Normalization Form C (NFC). Text containing characters in a non-NFC form (for example, decomposed characters or combining marks) are not accepted.
        public let lastName: String?
        /// The user's mobile number.
        public let mobile: String?
        /// The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address. Pattern: (?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}
        public let secondaryEmail: String?

        @inlinable
        public init(email: String? = nil, firstName: String? = nil, lastName: String? = nil, mobile: String? = nil, secondaryEmail: String? = nil) {
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.mobile = mobile
            self.secondaryEmail = secondaryEmail
        }

        public func validate(name: String) throws {
            try self.validate(self.firstName, name: "firstName", parent: name, max: 255)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 300)
            try self.validate(self.mobile, name: "mobile", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case email = "Email"
            case firstName = "FirstName"
            case lastName = "LastName"
            case mobile = "Mobile"
            case secondaryEmail = "SecondaryEmail"
        }
    }

    public struct UserIdentityInfoLite: AWSDecodableShape {
        /// The user's first name.
        public let firstName: String?
        /// The user's last name.
        public let lastName: String?

        @inlinable
        public init(firstName: String? = nil, lastName: String? = nil) {
            self.firstName = firstName
            self.lastName = lastName
        }

        private enum CodingKeys: String, CodingKey {
            case firstName = "FirstName"
            case lastName = "LastName"
        }
    }

    public struct UserInfo: AWSEncodableShape {
        /// The user identifier for the contact.
        public let userId: String?

        @inlinable
        public init(userId: String? = nil) {
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case userId = "UserId"
        }
    }

    public struct UserPhoneConfig: AWSEncodableShape & AWSDecodableShape {
        /// The After Call Work (ACW) timeout setting, in seconds. This parameter has a minimum value of 0 and a maximum value of 2,000,000 seconds (24 days). Enter 0 if you don't want to allocate a specific amount of ACW time. It essentially means an indefinite amount of time. When the conversation ends, ACW starts; the agent must choose Close contact to end ACW.   When returned by a SearchUsers call, AfterContactWorkTimeLimit is returned in milliseconds.
        public let afterContactWorkTimeLimit: Int?
        /// The Auto accept setting.
        public let autoAccept: Bool?
        /// The phone number for the user's desk phone.
        public let deskPhoneNumber: String?
        /// The phone type.
        public let phoneType: PhoneType

        @inlinable
        public init(afterContactWorkTimeLimit: Int? = nil, autoAccept: Bool? = nil, deskPhoneNumber: String? = nil, phoneType: PhoneType) {
            self.afterContactWorkTimeLimit = afterContactWorkTimeLimit
            self.autoAccept = autoAccept
            self.deskPhoneNumber = deskPhoneNumber
            self.phoneType = phoneType
        }

        public func validate(name: String) throws {
            try self.validate(self.afterContactWorkTimeLimit, name: "afterContactWorkTimeLimit", parent: name, min: 0)
            try self.validate(self.deskPhoneNumber, name: "deskPhoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case afterContactWorkTimeLimit = "AfterContactWorkTimeLimit"
            case autoAccept = "AutoAccept"
            case deskPhoneNumber = "DeskPhoneNumber"
            case phoneType = "PhoneType"
        }
    }

    public struct UserProficiency: AWSEncodableShape & AWSDecodableShape {
        /// The name of user's proficiency. You must use name of predefined attribute present in the Amazon Connect instance.
        public let attributeName: String
        /// The value of user's proficiency. You must use value of predefined attribute present in the Amazon Connect instance.
        public let attributeValue: String
        /// The level of the proficiency. The valid values are 1, 2, 3, 4 and 5.
        public let level: Float

        @inlinable
        public init(attributeName: String, attributeValue: String, level: Float) {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
            self.level = level
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 64)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeValue, name: "attributeValue", parent: name, max: 64)
            try self.validate(self.attributeValue, name: "attributeValue", parent: name, min: 1)
            try self.validate(self.level, name: "level", parent: name, max: 5.0)
            try self.validate(self.level, name: "level", parent: name, min: 1.0)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeValue = "AttributeValue"
            case level = "Level"
        }
    }

    public struct UserProficiencyDisassociate: AWSEncodableShape {
        /// The name of user's proficiency.
        public let attributeName: String
        /// The value of user's proficiency.
        public let attributeValue: String

        @inlinable
        public init(attributeName: String, attributeValue: String) {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 64)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeValue, name: "attributeValue", parent: name, max: 64)
            try self.validate(self.attributeValue, name: "attributeValue", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeValue = "AttributeValue"
        }
    }

    public struct UserQuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the user.
        public let userId: String

        @inlinable
        public init(contactFlowId: String, userId: String) {
            self.contactFlowId = contactFlowId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case userId = "UserId"
        }
    }

    public struct UserReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the user.
        public let arn: String?
        /// The unique identifier for the user.
        public let id: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct UserSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a hierarchy group condition.
        public let hierarchyGroupCondition: HierarchyGroupCondition?
        /// A leaf node condition which can be used to specify a List condition to search users with attributes included in Lists like Proficiencies.
        public let listCondition: ListCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition. The currently supported values for FieldName are Username, FirstName, LastName, RoutingProfileId, SecurityProfileId, ResourceId.
        public let stringCondition: StringCondition?

        @inlinable
        public init(andConditions: [UserSearchCriteria]? = nil, hierarchyGroupCondition: HierarchyGroupCondition? = nil, listCondition: ListCondition? = nil, orConditions: [UserSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.listCondition = listCondition
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case hierarchyGroupCondition = "HierarchyGroupCondition"
            case listCondition = "ListCondition"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct UserSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?
        /// An object that can be used to specify Tag conditions or Hierarchy Group conditions inside the SearchFilter. This accepts an OR of AND (List of List) input where:   The top level list specifies conditions that need to be applied with OR operator.   The inner list specifies conditions that need to be applied with AND operator.    Only one field can be populated. This object cant be used along with TagFilter. Request can either contain TagFilter or UserAttributeFilter if SearchFilter is specified, combination of both is not supported and such request will throw AccessDeniedException.
        public let userAttributeFilter: ControlPlaneUserAttributeFilter?

        @inlinable
        public init(tagFilter: ControlPlaneTagFilter? = nil, userAttributeFilter: ControlPlaneUserAttributeFilter? = nil) {
            self.tagFilter = tagFilter
            self.userAttributeFilter = userAttributeFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
            case userAttributeFilter = "UserAttributeFilter"
        }
    }

    public struct UserSearchSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user.
        public let arn: String?
        /// The directory identifier of the user.
        public let directoryUserId: String?
        /// The identifier of the user's hierarchy group.
        public let hierarchyGroupId: String?
        /// The identifier of the user's summary.
        public let id: String?
        /// The user's first name and last name.
        public let identityInfo: UserIdentityInfoLite?
        public let phoneConfig: UserPhoneConfig?
        /// The identifier of the user's routing profile.
        public let routingProfileId: String?
        /// The identifiers of the user's security profiles.
        public let securityProfileIds: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The name of the user.
        public let username: String?

        @inlinable
        public init(arn: String? = nil, directoryUserId: String? = nil, hierarchyGroupId: String? = nil, id: String? = nil, identityInfo: UserIdentityInfoLite? = nil, phoneConfig: UserPhoneConfig? = nil, routingProfileId: String? = nil, securityProfileIds: [String]? = nil, tags: [String: String]? = nil, username: String? = nil) {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case id = "Id"
            case identityInfo = "IdentityInfo"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct UserSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user account.
        public let arn: String?
        /// The identifier of the user account.
        public let id: String?
        /// The Amazon Web Services Region where this resource was last modified.
        public let lastModifiedRegion: String?
        /// The timestamp when this resource was last modified.
        public let lastModifiedTime: Date?
        /// The Amazon Connect user name of the user account.
        public let username: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, lastModifiedRegion: String? = nil, lastModifiedTime: Date? = nil, username: String? = nil) {
            self.arn = arn
            self.id = id
            self.lastModifiedRegion = lastModifiedRegion
            self.lastModifiedTime = lastModifiedTime
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case lastModifiedRegion = "LastModifiedRegion"
            case lastModifiedTime = "LastModifiedTime"
            case username = "Username"
        }
    }

    public struct View: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the view.
        public let arn: String?
        /// View content containing all content necessary to render a view except for runtime input data.
        public let content: ViewContent?
        /// The timestamp of when the view was created.
        public let createdTime: Date?
        /// The description of the view.
        public let description: String?
        /// The identifier of the view.
        public let id: String?
        /// Latest timestamp of the UpdateViewContent or CreateViewVersion operations.
        public let lastModifiedTime: Date?
        /// The name of the view.
        public let name: String?
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public let status: ViewStatus?
        /// The tags associated with the view resource (not specific to view version).
        public let tags: [String: String]?
        /// The type of the view - CUSTOMER_MANAGED.
        public let type: ViewType?
        /// Current version of the view.
        public let version: Int?
        /// The description of the version.
        public let versionDescription: String?
        /// Indicates the checksum value of the latest published view content.
        public let viewContentSha256: String?

        @inlinable
        public init(arn: String? = nil, content: ViewContent? = nil, createdTime: Date? = nil, description: String? = nil, id: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, status: ViewStatus? = nil, tags: [String: String]? = nil, type: ViewType? = nil, version: Int? = nil, versionDescription: String? = nil, viewContentSha256: String? = nil) {
            self.arn = arn
            self.content = content
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
            self.tags = tags
            self.type = type
            self.version = version
            self.versionDescription = versionDescription
            self.viewContentSha256 = viewContentSha256
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case createdTime = "CreatedTime"
            case description = "Description"
            case id = "Id"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
            case type = "Type"
            case version = "Version"
            case versionDescription = "VersionDescription"
            case viewContentSha256 = "ViewContentSha256"
        }
    }

    public struct ViewContent: AWSDecodableShape {
        /// A list of possible actions from the view.
        public let actions: [String]?
        /// The data schema matching data that the view template must be provided to render.
        public let inputSchema: String?
        /// The view template representing the structure of the view.
        public let template: String?

        @inlinable
        public init(actions: [String]? = nil, inputSchema: String? = nil, template: String? = nil) {
            self.actions = actions
            self.inputSchema = inputSchema
            self.template = template
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case inputSchema = "InputSchema"
            case template = "Template"
        }
    }

    public struct ViewInputContent: AWSEncodableShape {
        /// A list of possible actions from the view.
        public let actions: [String]?
        /// The view template representing the structure of the view.
        public let template: String?

        @inlinable
        public init(actions: [String]? = nil, template: String? = nil) {
            self.actions = actions
            self.template = template
        }

        public func validate(name: String) throws {
            try self.actions?.forEach {
                try validate($0, name: "actions[]", parent: name, max: 255)
                try validate($0, name: "actions[]", parent: name, min: 1)
                try validate($0, name: "actions[]", parent: name, pattern: "^([\\p{L}\\p{N}_.:\\/=+\\-@()']+[\\p{L}\\p{Z}\\p{N}_.:\\/=+\\-@()']*)$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case template = "Template"
        }
    }

    public struct ViewSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the view.
        public let arn: String?
        /// The description of the view.
        public let description: String?
        /// The identifier of the view.
        public let id: String?
        /// The name of the view.
        public let name: String?
        /// Indicates the view status as either SAVED or PUBLISHED. The PUBLISHED status will initiate validation on the content.
        public let status: ViewStatus?
        /// The type of the view.
        public let type: ViewType?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, status: ViewStatus? = nil, type: ViewType? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case status = "Status"
            case type = "Type"
        }
    }

    public struct ViewVersionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the view version.
        public let arn: String?
        /// The description of the view version.
        public let description: String?
        /// The identifier of the view version.
        public let id: String?
        /// The name of the view version.
        public let name: String?
        /// The type of the view version.
        public let type: ViewType?
        /// The sequentially incremented version of the view version.
        public let version: Int?
        /// The description of the view version.
        public let versionDescription: String?

        @inlinable
        public init(arn: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, type: ViewType? = nil, version: Int? = nil, versionDescription: String? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.name = name
            self.type = type
            self.version = version
            self.versionDescription = versionDescription
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case type = "Type"
            case version = "Version"
            case versionDescription = "VersionDescription"
        }
    }

    public struct Vocabulary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let arn: String
        /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. For more information, see Create a custom vocabulary using a table.
        public let content: String?
        /// The reason why the custom vocabulary was not created.
        public let failureReason: String?
        /// The identifier of the custom vocabulary.
        public let id: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The timestamp when the custom vocabulary was last modified.
        public let lastModifiedTime: Date
        /// A unique name of the custom vocabulary.
        public let name: String
        /// The current state of the custom vocabulary.
        public let state: VocabularyState
        /// The tags used to organize, track, or control access for this resource. For example, { "Tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        @inlinable
        public init(arn: String, content: String? = nil, failureReason: String? = nil, id: String, languageCode: VocabularyLanguageCode, lastModifiedTime: Date, name: String, state: VocabularyState, tags: [String: String]? = nil) {
            self.arn = arn
            self.content = content
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case failureReason = "FailureReason"
            case id = "Id"
            case languageCode = "LanguageCode"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct VocabularySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let arn: String
        /// The reason why the custom vocabulary was not created.
        public let failureReason: String?
        /// The identifier of the custom vocabulary.
        public let id: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The timestamp when the custom vocabulary was last modified.
        public let lastModifiedTime: Date
        /// A unique name of the custom vocabulary.
        public let name: String
        /// The current state of the custom vocabulary.
        public let state: VocabularyState

        @inlinable
        public init(arn: String, failureReason: String? = nil, id: String, languageCode: VocabularyLanguageCode, lastModifiedTime: Date, name: String, state: VocabularyState) {
            self.arn = arn
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case failureReason = "FailureReason"
            case id = "Id"
            case languageCode = "LanguageCode"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case state = "State"
        }
    }

    public struct VoiceRecordingConfiguration: AWSEncodableShape {
        /// Identifies which IVR track is being recorded. One and only one of the track configurations should be presented in the request.
        public let ivrRecordingTrack: IvrRecordingTrack?
        /// Identifies which track is being recorded.
        public let voiceRecordingTrack: VoiceRecordingTrack?

        @inlinable
        public init(ivrRecordingTrack: IvrRecordingTrack? = nil, voiceRecordingTrack: VoiceRecordingTrack? = nil) {
            self.ivrRecordingTrack = ivrRecordingTrack
            self.voiceRecordingTrack = voiceRecordingTrack
        }

        private enum CodingKeys: String, CodingKey {
            case ivrRecordingTrack = "IvrRecordingTrack"
            case voiceRecordingTrack = "VoiceRecordingTrack"
        }
    }

    public struct WisdomInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Wisdom session.
        public let sessionArn: String?

        @inlinable
        public init(sessionArn: String? = nil) {
            self.sessionArn = sessionArn
        }

        private enum CodingKeys: String, CodingKey {
            case sessionArn = "SessionArn"
        }
    }

    public struct EvaluationFormNumericQuestionAutomation: AWSEncodableShape & AWSDecodableShape {
        /// The property value of the automation.
        public let propertyValue: NumericQuestionPropertyValueAutomation?

        @inlinable
        public init(propertyValue: NumericQuestionPropertyValueAutomation? = nil) {
            self.propertyValue = propertyValue
        }

        private enum CodingKeys: String, CodingKey {
            case propertyValue = "PropertyValue"
        }
    }

    public struct EvaluationFormSingleSelectQuestionAutomationOption: AWSEncodableShape & AWSDecodableShape {
        /// The automation option based on a rule category for the single select question.
        public let ruleCategory: SingleSelectQuestionRuleCategoryAutomation?

        @inlinable
        public init(ruleCategory: SingleSelectQuestionRuleCategoryAutomation? = nil) {
            self.ruleCategory = ruleCategory
        }

        public func validate(name: String) throws {
            try self.ruleCategory?.validate(name: "\(name).ruleCategory")
        }

        private enum CodingKeys: String, CodingKey {
            case ruleCategory = "RuleCategory"
        }
    }

    public struct InvalidRequestExceptionReason: AWSDecodableShape {
        /// Reason why the StartAttachedFiledUpload request was invalid.
        public let attachedFileInvalidRequestExceptionReason: AttachedFileInvalidRequestExceptionReason?

        @inlinable
        public init(attachedFileInvalidRequestExceptionReason: AttachedFileInvalidRequestExceptionReason? = nil) {
            self.attachedFileInvalidRequestExceptionReason = attachedFileInvalidRequestExceptionReason
        }

        private enum CodingKeys: String, CodingKey {
            case attachedFileInvalidRequestExceptionReason = "AttachedFileInvalidRequestExceptionReason"
        }
    }

    public struct PredefinedAttributeValues: AWSEncodableShape & AWSDecodableShape {
        /// Predefined attribute values of type string list.
        public let stringList: [String]?

        @inlinable
        public init(stringList: [String]? = nil) {
            self.stringList = stringList
        }

        public func validate(name: String) throws {
            try self.stringList?.forEach {
                try validate($0, name: "stringList[]", parent: name, max: 64)
                try validate($0, name: "stringList[]", parent: name, min: 1)
            }
            try self.validate(self.stringList, name: "stringList", parent: name, max: 128)
            try self.validate(self.stringList, name: "stringList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case stringList = "StringList"
        }
    }

    public struct RealTimeContactAnalysisTimeData: AWSDecodableShape {
        /// Time represented in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var absoluteTime: Date?

        @inlinable
        public init(absoluteTime: Date? = nil) {
            self.absoluteTime = absoluteTime
        }

        private enum CodingKeys: String, CodingKey {
            case absoluteTime = "AbsoluteTime"
        }
    }

    public struct ServiceQuotaExceededExceptionReason: AWSDecodableShape {
        /// Total file size of all files or total number of files exceeds the service quota
        public let attachedFileServiceQuotaExceededExceptionReason: AttachedFileServiceQuotaExceededExceptionReason?

        @inlinable
        public init(attachedFileServiceQuotaExceededExceptionReason: AttachedFileServiceQuotaExceededExceptionReason? = nil) {
            self.attachedFileServiceQuotaExceededExceptionReason = attachedFileServiceQuotaExceededExceptionReason
        }

        private enum CodingKeys: String, CodingKey {
            case attachedFileServiceQuotaExceededExceptionReason = "AttachedFileServiceQuotaExceededExceptionReason"
        }
    }

    public struct UpdateParticipantRoleConfigChannelInfo: AWSEncodableShape {
        /// Configuration information for the chat participant role.
        public let chat: ChatParticipantRoleConfig?

        @inlinable
        public init(chat: ChatParticipantRoleConfig? = nil) {
            self.chat = chat
        }

        public func validate(name: String) throws {
            try self.chat?.validate(name: "\(name).chat")
        }

        private enum CodingKeys: String, CodingKey {
            case chat = "Chat"
        }
    }
}

// MARK: - Errors

/// Error enum for Connect
public struct ConnectErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conditionalOperationFailedException = "ConditionalOperationFailedException"
        case conflictException = "ConflictException"
        case contactFlowNotPublishedException = "ContactFlowNotPublishedException"
        case contactNotFoundException = "ContactNotFoundException"
        case destinationNotAllowedException = "DestinationNotAllowedException"
        case duplicateResourceException = "DuplicateResourceException"
        case idempotencyException = "IdempotencyException"
        case internalServiceException = "InternalServiceException"
        case invalidContactFlowException = "InvalidContactFlowException"
        case invalidContactFlowModuleException = "InvalidContactFlowModuleException"
        case invalidParameterException = "InvalidParameterException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case maximumResultReturnedException = "MaximumResultReturnedException"
        case outboundContactNotPermittedException = "OutboundContactNotPermittedException"
        case outputTypeNotFoundException = "OutputTypeNotFoundException"
        case propertyValidationException = "PropertyValidationException"
        case resourceConflictException = "ResourceConflictException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceNotReadyException = "ResourceNotReadyException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case tooManyRequestsException = "TooManyRequestsException"
        case userNotFoundException = "UserNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Connect
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// Request processing failed because dependent condition failed.
    public static var conditionalOperationFailedException: Self { .init(.conditionalOperationFailedException) }
    /// Operation cannot be performed at this time as there is a conflict with another operation or contact state.
    public static var conflictException: Self { .init(.conflictException) }
    /// The flow has not been published.
    public static var contactFlowNotPublishedException: Self { .init(.contactFlowNotPublishedException) }
    /// The contact with the specified ID is not active or does not exist. Applies to Voice calls only, not to Chat or Task contacts.
    public static var contactNotFoundException: Self { .init(.contactNotFoundException) }
    /// Outbound calls to the destination number are not allowed.
    public static var destinationNotAllowedException: Self { .init(.destinationNotAllowedException) }
    /// A resource with the specified name already exists.
    public static var duplicateResourceException: Self { .init(.duplicateResourceException) }
    /// An entity with the same name already exists.
    public static var idempotencyException: Self { .init(.idempotencyException) }
    /// Request processing failed because of an error or failure with the service.
    public static var internalServiceException: Self { .init(.internalServiceException) }
    /// The flow is not valid.
    public static var invalidContactFlowException: Self { .init(.invalidContactFlowException) }
    /// The problems with the module. Please fix before trying again.
    public static var invalidContactFlowModuleException: Self { .init(.invalidContactFlowModuleException) }
    /// One or more of the specified parameters are not valid.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The request is not valid.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The allowed limit for the resource has been exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// Maximum number (1000) of tags have been returned with current request. Consider changing request parameters to get more tags.
    public static var maximumResultReturnedException: Self { .init(.maximumResultReturnedException) }
    /// The contact is not permitted.
    public static var outboundContactNotPermittedException: Self { .init(.outboundContactNotPermittedException) }
    /// Thrown for analyzed content when requested OutputType was not enabled for a given contact. For example, if an OutputType.Raw was requested for a contact that had `RedactedOnly` Redaction policy set in the flow.
    public static var outputTypeNotFoundException: Self { .init(.outputTypeNotFoundException) }
    /// The property is not valid.
    public static var propertyValidationException: Self { .init(.propertyValidationException) }
    /// A resource already has that name.
    public static var resourceConflictException: Self { .init(.resourceConflictException) }
    /// That resource is already in use. Please try another.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The resource is not ready.
    public static var resourceNotReadyException: Self { .init(.resourceNotReadyException) }
    /// The service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The throttling limit has been exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// Displayed when rate-related API limits are exceeded.
    public static var tooManyRequestsException: Self { .init(.tooManyRequestsException) }
    /// No user with the specified credentials was found in the Amazon Connect instance.
    public static var userNotFoundException: Self { .init(.userNotFoundException) }
}

extension ConnectErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "InvalidContactFlowException": Connect.InvalidContactFlowException.self,
        "InvalidContactFlowModuleException": Connect.InvalidContactFlowModuleException.self,
        "InvalidRequestException": Connect.InvalidRequestException.self,
        "PropertyValidationException": Connect.PropertyValidationException.self,
        "ResourceInUseException": Connect.ResourceInUseException.self,
        "ServiceQuotaExceededException": Connect.ServiceQuotaExceededException.self
    ]
}

extension ConnectErrorType: Equatable {
    public static func == (lhs: ConnectErrorType, rhs: ConnectErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConnectErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
