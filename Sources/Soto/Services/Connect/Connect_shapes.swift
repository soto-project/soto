//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Connect {
    // MARK: Enums

    public enum ActionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case assignContactCategory = "ASSIGN_CONTACT_CATEGORY"
        case createTask = "CREATE_TASK"
        case generateEventbridgeEvent = "GENERATE_EVENTBRIDGE_EVENT"
        case sendNotification = "SEND_NOTIFICATION"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatusState: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AgentStatusType: String, CustomStringConvertible, Codable, _SotoSendable {
        case custom = "CUSTOM"
        case offline = "OFFLINE"
        case routable = "ROUTABLE"
        public var description: String { return self.rawValue }
    }

    public enum Channel: String, CustomStringConvertible, Codable, _SotoSendable {
        case chat = "CHAT"
        case task = "TASK"
        case voice = "VOICE"
        public var description: String { return self.rawValue }
    }

    public enum Comparison: String, CustomStringConvertible, Codable, _SotoSendable {
        case lt = "LT"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowModuleState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowModuleStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case published = "PUBLISHED"
        case saved = "SAVED"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case archived = "ARCHIVED"
        public var description: String { return self.rawValue }
    }

    public enum ContactFlowType: String, CustomStringConvertible, Codable, _SotoSendable {
        case agentHold = "AGENT_HOLD"
        case agentTransfer = "AGENT_TRANSFER"
        case agentWhisper = "AGENT_WHISPER"
        case contactFlow = "CONTACT_FLOW"
        case customerHold = "CUSTOMER_HOLD"
        case customerQueue = "CUSTOMER_QUEUE"
        case customerWhisper = "CUSTOMER_WHISPER"
        case outboundWhisper = "OUTBOUND_WHISPER"
        case queueTransfer = "QUEUE_TRANSFER"
        public var description: String { return self.rawValue }
    }

    public enum ContactInitiationMethod: String, CustomStringConvertible, Codable, _SotoSendable {
        case api = "API"
        case callback = "CALLBACK"
        case inbound = "INBOUND"
        case outbound = "OUTBOUND"
        case queueTransfer = "QUEUE_TRANSFER"
        case transfer = "TRANSFER"
        public var description: String { return self.rawValue }
    }

    public enum ContactState: String, CustomStringConvertible, Codable, _SotoSendable {
        case connected = "CONNECTED"
        case connectedOnhold = "CONNECTED_ONHOLD"
        case connecting = "CONNECTING"
        case ended = "ENDED"
        case error = "ERROR"
        case incoming = "INCOMING"
        case missed = "MISSED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum CurrentMetricName: String, CustomStringConvertible, Codable, _SotoSendable {
        case agentsAfterContactWork = "AGENTS_AFTER_CONTACT_WORK"
        case agentsAvailable = "AGENTS_AVAILABLE"
        case agentsError = "AGENTS_ERROR"
        case agentsNonProductive = "AGENTS_NON_PRODUCTIVE"
        case agentsOnCall = "AGENTS_ON_CALL"
        case agentsOnContact = "AGENTS_ON_CONTACT"
        case agentsOnline = "AGENTS_ONLINE"
        case agentsStaffed = "AGENTS_STAFFED"
        case contactsInQueue = "CONTACTS_IN_QUEUE"
        case contactsScheduled = "CONTACTS_SCHEDULED"
        case oldestContactAge = "OLDEST_CONTACT_AGE"
        case slotsActive = "SLOTS_ACTIVE"
        case slotsAvailable = "SLOTS_AVAILABLE"
        public var description: String { return self.rawValue }
    }

    public enum DirectoryType: String, CustomStringConvertible, Codable, _SotoSendable {
        case connectManaged = "CONNECT_MANAGED"
        case existingDirectory = "EXISTING_DIRECTORY"
        case saml = "SAML"
        public var description: String { return self.rawValue }
    }

    public enum EncryptionType: String, CustomStringConvertible, Codable, _SotoSendable {
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum EventSourceName: String, CustomStringConvertible, Codable, _SotoSendable {
        case onPostCallAnalysisAvailable = "OnPostCallAnalysisAvailable"
        case onPostChatAnalysisAvailable = "OnPostChatAnalysisAvailable"
        case onRealTimeCallAnalysisAvailable = "OnRealTimeCallAnalysisAvailable"
        case onSalesforceCaseCreate = "OnSalesforceCaseCreate"
        case onZendeskTicketCreate = "OnZendeskTicketCreate"
        case onZendeskTicketStatusUpdate = "OnZendeskTicketStatusUpdate"
        public var description: String { return self.rawValue }
    }

    public enum Grouping: String, CustomStringConvertible, Codable, _SotoSendable {
        case channel = "CHANNEL"
        case queue = "QUEUE"
        case routingProfile = "ROUTING_PROFILE"
        public var description: String { return self.rawValue }
    }

    public enum HierarchyGroupMatchType: String, CustomStringConvertible, Codable, _SotoSendable {
        case exact = "EXACT"
        case withChildGroups = "WITH_CHILD_GROUPS"
        public var description: String { return self.rawValue }
    }

    public enum HistoricalMetricName: String, CustomStringConvertible, Codable, _SotoSendable {
        case abandonTime = "ABANDON_TIME"
        case afterContactWorkTime = "AFTER_CONTACT_WORK_TIME"
        case apiContactsHandled = "API_CONTACTS_HANDLED"
        case callbackContactsHandled = "CALLBACK_CONTACTS_HANDLED"
        case contactsAbandoned = "CONTACTS_ABANDONED"
        case contactsAgentHungUpFirst = "CONTACTS_AGENT_HUNG_UP_FIRST"
        case contactsConsulted = "CONTACTS_CONSULTED"
        case contactsHandled = "CONTACTS_HANDLED"
        case contactsHandledIncoming = "CONTACTS_HANDLED_INCOMING"
        case contactsHandledOutbound = "CONTACTS_HANDLED_OUTBOUND"
        case contactsHoldAbandons = "CONTACTS_HOLD_ABANDONS"
        case contactsMissed = "CONTACTS_MISSED"
        case contactsQueued = "CONTACTS_QUEUED"
        case contactsTransferredIn = "CONTACTS_TRANSFERRED_IN"
        case contactsTransferredInFromQueue = "CONTACTS_TRANSFERRED_IN_FROM_QUEUE"
        case contactsTransferredOut = "CONTACTS_TRANSFERRED_OUT"
        case contactsTransferredOutFromQueue = "CONTACTS_TRANSFERRED_OUT_FROM_QUEUE"
        case handleTime = "HANDLE_TIME"
        case holdTime = "HOLD_TIME"
        case interactionAndHoldTime = "INTERACTION_AND_HOLD_TIME"
        case interactionTime = "INTERACTION_TIME"
        case occupancy = "OCCUPANCY"
        case queueAnswerTime = "QUEUE_ANSWER_TIME"
        case queuedTime = "QUEUED_TIME"
        case serviceLevel = "SERVICE_LEVEL"
        public var description: String { return self.rawValue }
    }

    public enum HoursOfOperationDays: String, CustomStringConvertible, Codable, _SotoSendable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum InstanceAttributeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case autoResolveBestVoices = "AUTO_RESOLVE_BEST_VOICES"
        case contactLens = "CONTACT_LENS"
        case contactflowLogs = "CONTACTFLOW_LOGS"
        case earlyMedia = "EARLY_MEDIA"
        case enhancedContactMonitoring = "ENHANCED_CONTACT_MONITORING"
        case highVolumeOutbound = "HIGH_VOLUME_OUTBOUND"
        case inboundCalls = "INBOUND_CALLS"
        case multiPartyConference = "MULTI_PARTY_CONFERENCE"
        case outboundCalls = "OUTBOUND_CALLS"
        case useCustomTtsVoices = "USE_CUSTOM_TTS_VOICES"
        public var description: String { return self.rawValue }
    }

    public enum InstanceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum InstanceStorageResourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case agentEvents = "AGENT_EVENTS"
        case callRecordings = "CALL_RECORDINGS"
        case chatTranscripts = "CHAT_TRANSCRIPTS"
        case contactTraceRecords = "CONTACT_TRACE_RECORDS"
        case mediaStreams = "MEDIA_STREAMS"
        case realTimeContactAnalysisSegments = "REAL_TIME_CONTACT_ANALYSIS_SEGMENTS"
        case scheduledReports = "SCHEDULED_REPORTS"
        public var description: String { return self.rawValue }
    }

    public enum IntegrationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case casesDomain = "CASES_DOMAIN"
        case event = "EVENT"
        case pinpointApp = "PINPOINT_APP"
        case voiceId = "VOICE_ID"
        case wisdomAssistant = "WISDOM_ASSISTANT"
        case wisdomKnowledgeBase = "WISDOM_KNOWLEDGE_BASE"
        public var description: String { return self.rawValue }
    }

    public enum LexVersion: String, CustomStringConvertible, Codable, _SotoSendable {
        case v1 = "V1"
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    public enum MonitorCapability: String, CustomStringConvertible, Codable, _SotoSendable {
        case barge = "BARGE"
        case silentMonitor = "SILENT_MONITOR"
        public var description: String { return self.rawValue }
    }

    public enum NotificationContentType: String, CustomStringConvertible, Codable, _SotoSendable {
        case plainText = "PLAIN_TEXT"
        public var description: String { return self.rawValue }
    }

    public enum NotificationDeliveryType: String, CustomStringConvertible, Codable, _SotoSendable {
        case email = "EMAIL"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTimerAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case unset = "Unset"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTimerType: String, CustomStringConvertible, Codable, _SotoSendable {
        case disconnectNoncustomer = "DISCONNECT_NONCUSTOMER"
        case idle = "IDLE"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberCountryCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case `as` = "AS"
        case `do` = "DO"
        case `in` = "IN"
        case `is` = "IS"
        case ad = "AD"
        case ae = "AE"
        case af = "AF"
        case ag = "AG"
        case ai = "AI"
        case al = "AL"
        case am = "AM"
        case an = "AN"
        case ao = "AO"
        case aq = "AQ"
        case ar = "AR"
        case at = "AT"
        case au = "AU"
        case aw = "AW"
        case az = "AZ"
        case ba = "BA"
        case bb = "BB"
        case bd = "BD"
        case be = "BE"
        case bf = "BF"
        case bg = "BG"
        case bh = "BH"
        case bi = "BI"
        case bj = "BJ"
        case bl = "BL"
        case bm = "BM"
        case bn = "BN"
        case bo = "BO"
        case br = "BR"
        case bs = "BS"
        case bt = "BT"
        case bw = "BW"
        case by = "BY"
        case bz = "BZ"
        case ca = "CA"
        case cc = "CC"
        case cd = "CD"
        case cf = "CF"
        case cg = "CG"
        case ch = "CH"
        case ci = "CI"
        case ck = "CK"
        case cl = "CL"
        case cm = "CM"
        case cn = "CN"
        case co = "CO"
        case cr = "CR"
        case cu = "CU"
        case cv = "CV"
        case cw = "CW"
        case cx = "CX"
        case cy = "CY"
        case cz = "CZ"
        case de = "DE"
        case dj = "DJ"
        case dk = "DK"
        case dm = "DM"
        case dz = "DZ"
        case ec = "EC"
        case ee = "EE"
        case eg = "EG"
        case eh = "EH"
        case er = "ER"
        case es = "ES"
        case et = "ET"
        case fi = "FI"
        case fj = "FJ"
        case fk = "FK"
        case fm = "FM"
        case fo = "FO"
        case fr = "FR"
        case ga = "GA"
        case gb = "GB"
        case gd = "GD"
        case ge = "GE"
        case gg = "GG"
        case gh = "GH"
        case gi = "GI"
        case gl = "GL"
        case gm = "GM"
        case gn = "GN"
        case gq = "GQ"
        case gr = "GR"
        case gt = "GT"
        case gu = "GU"
        case gw = "GW"
        case gy = "GY"
        case hk = "HK"
        case hn = "HN"
        case hr = "HR"
        case ht = "HT"
        case hu = "HU"
        case id = "ID"
        case ie = "IE"
        case il = "IL"
        case im = "IM"
        case io = "IO"
        case iq = "IQ"
        case ir = "IR"
        case it = "IT"
        case je = "JE"
        case jm = "JM"
        case jo = "JO"
        case jp = "JP"
        case ke = "KE"
        case kg = "KG"
        case kh = "KH"
        case ki = "KI"
        case km = "KM"
        case kn = "KN"
        case kp = "KP"
        case kr = "KR"
        case kw = "KW"
        case ky = "KY"
        case kz = "KZ"
        case la = "LA"
        case lb = "LB"
        case lc = "LC"
        case li = "LI"
        case lk = "LK"
        case lr = "LR"
        case ls = "LS"
        case lt = "LT"
        case lu = "LU"
        case lv = "LV"
        case ly = "LY"
        case ma = "MA"
        case mc = "MC"
        case md = "MD"
        case me = "ME"
        case mf = "MF"
        case mg = "MG"
        case mh = "MH"
        case mk = "MK"
        case ml = "ML"
        case mm = "MM"
        case mn = "MN"
        case mo = "MO"
        case mp = "MP"
        case mr = "MR"
        case ms = "MS"
        case mt = "MT"
        case mu = "MU"
        case mv = "MV"
        case mw = "MW"
        case mx = "MX"
        case my = "MY"
        case mz = "MZ"
        case na = "NA"
        case nc = "NC"
        case ne = "NE"
        case ng = "NG"
        case ni = "NI"
        case nl = "NL"
        case no = "NO"
        case np = "NP"
        case nr = "NR"
        case nu = "NU"
        case nz = "NZ"
        case om = "OM"
        case pa = "PA"
        case pe = "PE"
        case pf = "PF"
        case pg = "PG"
        case ph = "PH"
        case pk = "PK"
        case pl = "PL"
        case pm = "PM"
        case pn = "PN"
        case pr = "PR"
        case pt = "PT"
        case pw = "PW"
        case py = "PY"
        case qa = "QA"
        case re = "RE"
        case ro = "RO"
        case rs = "RS"
        case ru = "RU"
        case rw = "RW"
        case sa = "SA"
        case sb = "SB"
        case sc = "SC"
        case sd = "SD"
        case se = "SE"
        case sg = "SG"
        case sh = "SH"
        case si = "SI"
        case sj = "SJ"
        case sk = "SK"
        case sl = "SL"
        case sm = "SM"
        case sn = "SN"
        case so = "SO"
        case sr = "SR"
        case st = "ST"
        case sv = "SV"
        case sx = "SX"
        case sy = "SY"
        case sz = "SZ"
        case tc = "TC"
        case td = "TD"
        case tg = "TG"
        case th = "TH"
        case tj = "TJ"
        case tk = "TK"
        case tl = "TL"
        case tm = "TM"
        case tn = "TN"
        case to = "TO"
        case tr = "TR"
        case tt = "TT"
        case tv = "TV"
        case tw = "TW"
        case tz = "TZ"
        case ua = "UA"
        case ug = "UG"
        case us = "US"
        case uy = "UY"
        case uz = "UZ"
        case va = "VA"
        case vc = "VC"
        case ve = "VE"
        case vg = "VG"
        case vi = "VI"
        case vn = "VN"
        case vu = "VU"
        case wf = "WF"
        case ws = "WS"
        case ye = "YE"
        case yt = "YT"
        case za = "ZA"
        case zm = "ZM"
        case zw = "ZW"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberType: String, CustomStringConvertible, Codable, _SotoSendable {
        case did = "DID"
        case tollFree = "TOLL_FREE"
        public var description: String { return self.rawValue }
    }

    public enum PhoneNumberWorkflowStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case claimed = "CLAIMED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum PhoneType: String, CustomStringConvertible, Codable, _SotoSendable {
        case deskPhone = "DESK_PHONE"
        case softPhone = "SOFT_PHONE"
        public var description: String { return self.rawValue }
    }

    public enum QueueStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum QueueType: String, CustomStringConvertible, Codable, _SotoSendable {
        case agent = "AGENT"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum QuickConnectType: String, CustomStringConvertible, Codable, _SotoSendable {
        case phoneNumber = "PHONE_NUMBER"
        case queue = "QUEUE"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case approved = "APPROVED"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum ReferenceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case attachment = "ATTACHMENT"
        case date = "DATE"
        case email = "EMAIL"
        case number = "NUMBER"
        case string = "STRING"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum RulePublishStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case draft = "DRAFT"
        case published = "PUBLISHED"
        public var description: String { return self.rawValue }
    }

    public enum SearchableQueueType: String, CustomStringConvertible, Codable, _SotoSendable {
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum SortOrder: String, CustomStringConvertible, Codable, _SotoSendable {
        case ascending = "ASCENDING"
        case descending = "DESCENDING"
        public var description: String { return self.rawValue }
    }

    public enum SourceType: String, CustomStringConvertible, Codable, _SotoSendable {
        case salesforce = "SALESFORCE"
        case zendesk = "ZENDESK"
        public var description: String { return self.rawValue }
    }

    public enum Statistic: String, CustomStringConvertible, Codable, _SotoSendable {
        case avg = "AVG"
        case max = "MAX"
        case sum = "SUM"
        public var description: String { return self.rawValue }
    }

    public enum StorageType: String, CustomStringConvertible, Codable, _SotoSendable {
        case kinesisFirehose = "KINESIS_FIREHOSE"
        case kinesisStream = "KINESIS_STREAM"
        case kinesisVideoStream = "KINESIS_VIDEO_STREAM"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum StringComparisonType: String, CustomStringConvertible, Codable, _SotoSendable {
        case contains = "CONTAINS"
        case exact = "EXACT"
        case startsWith = "STARTS_WITH"
        public var description: String { return self.rawValue }
    }

    public enum TaskTemplateFieldType: String, CustomStringConvertible, Codable, _SotoSendable {
        case boolean = "BOOLEAN"
        case dateTime = "DATE_TIME"
        case description = "DESCRIPTION"
        case email = "EMAIL"
        case name = "NAME"
        case number = "NUMBER"
        case quickConnect = "QUICK_CONNECT"
        case scheduledTime = "SCHEDULED_TIME"
        case singleSelect = "SINGLE_SELECT"
        case text = "TEXT"
        case textArea = "TEXT_AREA"
        case url = "URL"
        public var description: String { return self.rawValue }
    }

    public enum TaskTemplateStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case inactive = "INACTIVE"
        public var description: String { return self.rawValue }
    }

    public enum TimerEligibleParticipantRoles: String, CustomStringConvertible, Codable, _SotoSendable {
        case agent = "AGENT"
        case customer = "CUSTOMER"
        public var description: String { return self.rawValue }
    }

    public enum TrafficDistributionGroupStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case deletionFailed = "DELETION_FAILED"
        case pendingDeletion = "PENDING_DELETION"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TrafficType: String, CustomStringConvertible, Codable, _SotoSendable {
        case campaign = "CAMPAIGN"
        case general = "GENERAL"
        public var description: String { return self.rawValue }
    }

    public enum Unit: String, CustomStringConvertible, Codable, _SotoSendable {
        case count = "COUNT"
        case percent = "PERCENT"
        case seconds = "SECONDS"
        public var description: String { return self.rawValue }
    }

    public enum UseCaseType: String, CustomStringConvertible, Codable, _SotoSendable {
        case connectCampaigns = "CONNECT_CAMPAIGNS"
        case rulesEvaluation = "RULES_EVALUATION"
        public var description: String { return self.rawValue }
    }

    public enum VocabularyLanguageCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case arAe = "ar-AE"
        case deCh = "de-CH"
        case deDe = "de-DE"
        case enAb = "en-AB"
        case enAu = "en-AU"
        case enGb = "en-GB"
        case enIe = "en-IE"
        case enIn = "en-IN"
        case enNz = "en-NZ"
        case enUs = "en-US"
        case enWl = "en-WL"
        case enZa = "en-ZA"
        case esEs = "es-ES"
        case esUs = "es-US"
        case frCa = "fr-CA"
        case frFr = "fr-FR"
        case hiIn = "hi-IN"
        case itIt = "it-IT"
        case jaJp = "ja-JP"
        case koKr = "ko-KR"
        case ptBr = "pt-BR"
        case ptPt = "pt-PT"
        case zhCn = "zh-CN"
        public var description: String { return self.rawValue }
    }

    public enum VocabularyState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case creationFailed = "CREATION_FAILED"
        case creationInProgress = "CREATION_IN_PROGRESS"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum VoiceRecordingTrack: String, CustomStringConvertible, Codable, _SotoSendable {
        case all = "ALL"
        case fromAgent = "FROM_AGENT"
        case toAgent = "TO_AGENT"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantTimerValue: AWSEncodableShape, _SotoSendable {
        /// The timer action. Currently only one value is allowed: Unset. It deletes a timer.
        case participantTimerAction(ParticipantTimerAction)
        /// The duration of a timer, in minutes.
        case participantTimerDurationInMinutes(Int)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .participantTimerAction(let value):
                try container.encode(value, forKey: .participantTimerAction)
            case .participantTimerDurationInMinutes(let value):
                try container.encode(value, forKey: .participantTimerDurationInMinutes)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .participantTimerDurationInMinutes(let value):
                try self.validate(value, name: "participantTimerDurationInMinutes", parent: name, max: 480)
                try self.validate(value, name: "participantTimerDurationInMinutes", parent: name, min: 2)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case participantTimerAction = "ParticipantTimerAction"
            case participantTimerDurationInMinutes = "ParticipantTimerDurationInMinutes"
        }
    }

    public enum ReferenceSummary: AWSDecodableShape, _SotoSendable {
        /// Information about the reference when the referenceType is ATTACHMENT. Otherwise, null.
        case attachment(AttachmentReference)
        /// Information about a reference when the referenceType is DATE. Otherwise, null.
        case date(DateReference)
        /// Information about a reference when the referenceType is EMAIL. Otherwise, null.
        case email(EmailReference)
        /// Information about a reference when the referenceType is NUMBER. Otherwise, null.
        case number(NumberReference)
        /// Information about a reference when the referenceType is STRING. Otherwise, null.
        case string(StringReference)
        /// Information about the reference when the referenceType is URL. Otherwise, null.
        case url(UrlReference)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .attachment:
                let value = try container.decode(AttachmentReference.self, forKey: .attachment)
                self = .attachment(value)
            case .date:
                let value = try container.decode(DateReference.self, forKey: .date)
                self = .date(value)
            case .email:
                let value = try container.decode(EmailReference.self, forKey: .email)
                self = .email(value)
            case .number:
                let value = try container.decode(NumberReference.self, forKey: .number)
                self = .number(value)
            case .string:
                let value = try container.decode(StringReference.self, forKey: .string)
                self = .string(value)
            case .url:
                let value = try container.decode(UrlReference.self, forKey: .url)
                self = .url(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "Attachment"
            case date = "Date"
            case email = "Email"
            case number = "Number"
            case string = "String"
            case url = "Url"
        }
    }

    // MARK: Shapes

    public struct ActionSummary: AWSDecodableShape {
        /// The action type.
        public let actionType: ActionType

        public init(actionType: ActionType) {
            self.actionType = actionType
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "ActionType"
        }
    }

    public struct AgentContactReference: AWSDecodableShape {
        /// The state of the contact.
        public let agentContactState: ContactState?
        /// The channel of the contact.
        public let channel: Channel?
        /// The time at which the contact was connected to an agent.
        public let connectedToAgentTimestamp: Date?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?
        /// How the contact was initiated.
        public let initiationMethod: ContactInitiationMethod?
        public let queue: QueueReference?
        /// The epoch timestamp when the contact state started.
        public let stateStartTimestamp: Date?

        public init(agentContactState: ContactState? = nil, channel: Channel? = nil, connectedToAgentTimestamp: Date? = nil, contactId: String? = nil, initiationMethod: ContactInitiationMethod? = nil, queue: QueueReference? = nil, stateStartTimestamp: Date? = nil) {
            self.agentContactState = agentContactState
            self.channel = channel
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.contactId = contactId
            self.initiationMethod = initiationMethod
            self.queue = queue
            self.stateStartTimestamp = stateStartTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case agentContactState = "AgentContactState"
            case channel = "Channel"
            case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
            case contactId = "ContactId"
            case initiationMethod = "InitiationMethod"
            case queue = "Queue"
            case stateStartTimestamp = "StateStartTimestamp"
        }
    }

    public struct AgentInfo: AWSDecodableShape {
        /// The timestamp when the contact was connected to the agent.
        public let connectedToAgentTimestamp: Date?
        /// The identifier of the agent who accepted the contact.
        public let id: String?

        public init(connectedToAgentTimestamp: Date? = nil, id: String? = nil) {
            self.connectedToAgentTimestamp = connectedToAgentTimestamp
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case connectedToAgentTimestamp = "ConnectedToAgentTimestamp"
            case id = "Id"
        }
    }

    public struct AgentStatus: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent status.
        public let agentStatusARN: String?
        /// The identifier of the agent status.
        public let agentStatusId: String?
        /// The description of the agent status.
        public let description: String?
        /// The display order of the agent status.
        public let displayOrder: Int?
        /// The name of the agent status.
        public let name: String?
        /// The state of the agent status.
        public let state: AgentStatusState?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of agent status.
        public let type: AgentStatusType?

        public init(agentStatusARN: String? = nil, agentStatusId: String? = nil, description: String? = nil, displayOrder: Int? = nil, name: String? = nil, state: AgentStatusState? = nil, tags: [String: String]? = nil, type: AgentStatusType? = nil) {
            self.agentStatusARN = agentStatusARN
            self.agentStatusId = agentStatusId
            self.description = description
            self.displayOrder = displayOrder
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusARN = "AgentStatusARN"
            case agentStatusId = "AgentStatusId"
            case description = "Description"
            case displayOrder = "DisplayOrder"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct AgentStatusReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent's status.
        public let statusArn: String?
        /// The name of the agent status.
        public let statusName: String?
        /// The start timestamp of the agent's status.
        public let statusStartTimestamp: Date?

        public init(statusArn: String? = nil, statusName: String? = nil, statusStartTimestamp: Date? = nil) {
            self.statusArn = statusArn
            self.statusName = statusName
            self.statusStartTimestamp = statusStartTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case statusArn = "StatusArn"
            case statusName = "StatusName"
            case statusStartTimestamp = "StatusStartTimestamp"
        }
    }

    public struct AgentStatusSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the agent status.
        public let arn: String?
        /// The identifier for an agent status.
        public let id: String?
        /// The name of the agent status.
        public let name: String?
        /// The type of the agent status.
        public let type: AgentStatusType?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, type: AgentStatusType? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case type = "Type"
        }
    }

    public struct AnswerMachineDetectionConfig: AWSEncodableShape {
        /// Wait for the answering machine prompt.
        public let awaitAnswerMachinePrompt: Bool?
        /// The flag to indicate if answer machine detection analysis needs to be performed for a voice call. If set to true, TrafficType must be set as CAMPAIGN.
        public let enableAnswerMachineDetection: Bool?

        public init(awaitAnswerMachinePrompt: Bool? = nil, enableAnswerMachineDetection: Bool? = nil) {
            self.awaitAnswerMachinePrompt = awaitAnswerMachinePrompt
            self.enableAnswerMachineDetection = enableAnswerMachineDetection
        }

        private enum CodingKeys: String, CodingKey {
            case awaitAnswerMachinePrompt = "AwaitAnswerMachinePrompt"
            case enableAnswerMachineDetection = "EnableAnswerMachineDetection"
        }
    }

    public struct AssignContactCategoryActionDefinition: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct AssociateApprovedOriginRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The domain to add to your allow list.
        public let origin: String

        public init(instanceId: String, origin: String) {
            self.instanceId = instanceId
            self.origin = origin
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.origin, name: "origin", parent: name, max: 267)
        }

        private enum CodingKeys: String, CodingKey {
            case origin = "Origin"
        }
    }

    public struct AssociateBotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        public let lexBot: LexBot?
        /// The Amazon Lex V2 bot to associate with the instance.
        public let lexV2Bot: LexV2Bot?

        public init(instanceId: String, lexBot: LexBot? = nil, lexV2Bot: LexV2Bot? = nil) {
            self.instanceId = instanceId
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.lexBot?.validate(name: "\(name).lexBot")
            try self.lexV2Bot?.validate(name: "\(name).lexV2Bot")
        }

        private enum CodingKeys: String, CodingKey {
            case lexBot = "LexBot"
            case lexV2Bot = "LexV2Bot"
        }
    }

    public struct AssociateDefaultVocabularyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "languageCode", location: .uri("LanguageCode"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The identifier of the custom vocabulary. If this is empty, the default is set to none.
        public let vocabularyId: String?

        public init(instanceId: String, languageCode: VocabularyLanguageCode, vocabularyId: String? = nil) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.vocabularyId = vocabularyId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, max: 500)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vocabularyId = "VocabularyId"
        }
    }

    public struct AssociateDefaultVocabularyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct AssociateInstanceStorageConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType
        /// A valid storage type.
        public let storageConfig: InstanceStorageConfig

        public init(instanceId: String, resourceType: InstanceStorageResourceType, storageConfig: InstanceStorageConfig) {
            self.instanceId = instanceId
            self.resourceType = resourceType
            self.storageConfig = storageConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.storageConfig.validate(name: "\(name).storageConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceType = "ResourceType"
            case storageConfig = "StorageConfig"
        }
    }

    public struct AssociateInstanceStorageConfigResponse: AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
        }
    }

    public struct AssociateLambdaFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The Amazon Resource Name (ARN) for the Lambda function being associated. Maximum number of characters allowed is 140.
        public let functionArn: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(functionArn: String, instanceId: String) {
            self.functionArn = functionArn
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.functionArn, name: "functionArn", parent: name, max: 140)
            try self.validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "FunctionArn"
        }
    }

    public struct AssociateLexBotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The Amazon Lex bot to associate with the instance.
        public let lexBot: LexBot

        public init(instanceId: String, lexBot: LexBot) {
            self.instanceId = instanceId
            self.lexBot = lexBot
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.lexBot.validate(name: "\(name).lexBot")
        }

        private enum CodingKeys: String, CodingKey {
            case lexBot = "LexBot"
        }
    }

    public struct AssociatePhoneNumberContactFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "phoneNumberId", location: .uri("PhoneNumberId"))
        ]

        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        public init(contactFlowId: String, instanceId: String, phoneNumberId: String) {
            self.contactFlowId = contactFlowId
            self.instanceId = instanceId
            self.phoneNumberId = phoneNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case instanceId = "InstanceId"
        }
    }

    public struct AssociateQueueQuickConnectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String
        /// The quick connects to associate with this queue.
        public let quickConnectIds: [String]

        public init(instanceId: String, queueId: String, quickConnectIds: [String]) {
            self.instanceId = instanceId
            self.queueId = queueId
            self.quickConnectIds = quickConnectIds
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, max: 50)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectIds = "QuickConnectIds"
        }
    }

    public struct AssociateRoutingProfileQueuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The queues to associate with this routing profile.
        public let queueConfigs: [RoutingProfileQueueConfig]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(instanceId: String, queueConfigs: [RoutingProfileQueueConfig], routingProfileId: String) {
            self.instanceId = instanceId
            self.queueConfigs = queueConfigs
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.queueConfigs.forEach {
                try $0.validate(name: "\(name).queueConfigs[]")
            }
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, max: 10)
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queueConfigs = "QueueConfigs"
        }
    }

    public struct AssociateSecurityKeyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A valid security key in PEM format.
        public let key: String

        public init(instanceId: String, key: String) {
            self.instanceId = instanceId
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
        }
    }

    public struct AssociateSecurityKeyResponse: AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?

        public init(associationId: String? = nil) {
            self.associationId = associationId
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
        }
    }

    public struct AttachmentReference: AWSDecodableShape {
        /// Identifier of the attachment reference.
        public let name: String?
        /// Status of the attachment reference type.
        public let status: ReferenceStatus?
        /// The location path of the attachment reference.
        public let value: String?

        public init(name: String? = nil, status: ReferenceStatus? = nil, value: String? = nil) {
            self.name = name
            self.status = status
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case status = "Status"
            case value = "Value"
        }
    }

    public struct Attribute: AWSDecodableShape {
        /// The type of attribute.
        public let attributeType: InstanceAttributeType?
        /// The value of the attribute.
        public let value: String?

        public init(attributeType: InstanceAttributeType? = nil, value: String? = nil) {
            self.attributeType = attributeType
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case attributeType = "AttributeType"
            case value = "Value"
        }
    }

    public struct AvailableNumberSummary: AWSDecodableShape {
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?

        public init(phoneNumber: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberType: PhoneNumberType? = nil) {
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumber = "PhoneNumber"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberType = "PhoneNumberType"
        }
    }

    public struct ChatMessage: AWSEncodableShape {
        /// The content of the chat message.    For text/plain and text/markdown, the Length Constraints are Minimum of 1, Maximum of 1024.    For application/json, the Length Constraints are Minimum of 1, Maximum of 12000.
        public let content: String
        /// The type of the content. Supported types are text/plain, text/markdown, and application/json.
        public let contentType: String

        public init(content: String, contentType: String) {
            self.content = content
            self.contentType = contentType
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 16384)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 100)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
        }
    }

    public struct ChatParticipantRoleConfig: AWSEncodableShape {
        /// A list of participant timers. You can specify any unique combination of role and timer type. Duplicate entries error out the request with a 400.
        public let participantTimerConfigList: [ParticipantTimerConfiguration]

        public init(participantTimerConfigList: [ParticipantTimerConfiguration]) {
            self.participantTimerConfigList = participantTimerConfigList
        }

        public func validate(name: String) throws {
            try self.participantTimerConfigList.forEach {
                try $0.validate(name: "\(name).participantTimerConfigList[]")
            }
            try self.validate(self.participantTimerConfigList, name: "participantTimerConfigList", parent: name, max: 6)
            try self.validate(self.participantTimerConfigList, name: "participantTimerConfigList", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case participantTimerConfigList = "ParticipantTimerConfigList"
        }
    }

    public struct ChatStreamingConfiguration: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon Resource Name (ARN) of the streaming endpoint that is used to publish real-time message streaming for chat conversations.
        public let streamingEndpointArn: String

        public init(streamingEndpointArn: String) {
            self.streamingEndpointArn = streamingEndpointArn
        }

        public func validate(name: String) throws {
            try self.validate(self.streamingEndpointArn, name: "streamingEndpointArn", parent: name, max: 350)
            try self.validate(self.streamingEndpointArn, name: "streamingEndpointArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case streamingEndpointArn = "StreamingEndpointArn"
        }
    }

    public struct ClaimPhoneNumberRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. Pattern: ^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$
        public let clientToken: String?
        /// The phone number you want to claim. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String
        /// The description of the phone number.
        public let phoneNumberDescription: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.
        public let targetArn: String

        public init(clientToken: String? = ClaimPhoneNumberRequest.idempotencyToken(), phoneNumber: String, phoneNumberDescription: String? = nil, tags: [String: String]? = nil, targetArn: String) {
            self.clientToken = clientToken
            self.phoneNumber = phoneNumber
            self.phoneNumberDescription = phoneNumberDescription
            self.tags = tags
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, max: 500)
            try self.validate(self.phoneNumberDescription, name: "phoneNumberDescription", parent: name, pattern: "^[\\W\\S_]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case phoneNumber = "PhoneNumber"
            case phoneNumberDescription = "PhoneNumberDescription"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct ClaimPhoneNumberResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?

        public init(phoneNumberArn: String? = nil, phoneNumberId: String? = nil) {
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct ClaimedPhoneNumberSummary: AWSDecodableShape {
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The description of the phone number.
        public let phoneNumberDescription: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?
        /// The status of the phone number.    CLAIMED means the previous ClaimedPhoneNumber or UpdatePhoneNumber operation succeeded.    IN_PROGRESS means a ClaimedPhoneNumber or UpdatePhoneNumber operation is still in progress and has not yet completed. You can call DescribePhoneNumber at a later time to verify if the previous operation has completed.    FAILED indicates that the previous ClaimedPhoneNumber or UpdatePhoneNumber operation has failed. It will include a message indicating the failure reason. A common reason for a failure may be that the TargetArn value you are claiming or updating a phone number to has reached its limit of total claimed numbers. If you received a FAILED status from a ClaimPhoneNumber API call, you have one day to retry claiming the phone number before the number is released back to the inventory for other customers to claim.    You will not be billed for the phone number during the 1-day period if number claiming fails.
        public let phoneNumberStatus: PhoneNumberStatus?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.
        public let targetArn: String?

        public init(phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberDescription: String? = nil, phoneNumberId: String? = nil, phoneNumberStatus: PhoneNumberStatus? = nil, phoneNumberType: PhoneNumberType? = nil, tags: [String: String]? = nil, targetArn: String? = nil) {
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberDescription = phoneNumberDescription
            self.phoneNumberId = phoneNumberId
            self.phoneNumberStatus = phoneNumberStatus
            self.phoneNumberType = phoneNumberType
            self.tags = tags
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberDescription = "PhoneNumberDescription"
            case phoneNumberId = "PhoneNumberId"
            case phoneNumberStatus = "PhoneNumberStatus"
            case phoneNumberType = "PhoneNumberType"
            case tags = "Tags"
            case targetArn = "TargetArn"
        }
    }

    public struct Contact: AWSDecodableShape {
        /// Information about the agent who accepted the contact.
        public let agentInfo: AgentInfo?
        /// The Amazon Resource Name (ARN) for the contact.
        public let arn: String?
        /// How the contact reached your contact center.
        public let channel: Channel?
        /// The description of the contact.
        public let description: String?
        /// The timestamp when the customer endpoint disconnected from Amazon Connect.
        public let disconnectTimestamp: Date?
        /// The identifier for the contact.
        public let id: String?
        /// If this contact is related to other contacts, this is the ID of the initial contact.
        public let initialContactId: String?
        /// Indicates how the contact was initiated.
        public let initiationMethod: ContactInitiationMethod?
        /// The date and time this contact was initiated, in UTC time. For INBOUND, this is when the contact arrived. For OUTBOUND, this is when the agent began dialing. For CALLBACK, this is when the callback contact was created. For TRANSFER and QUEUE_TRANSFER, this is when the transfer was initiated. For API, this is when the request arrived.
        public let initiationTimestamp: Date?
        /// The timestamp when contact was last updated.
        public let lastUpdateTimestamp: Date?
        /// The name of the contact.
        public let name: String?
        /// If this contact is not the first contact, this is the ID of the previous contact.
        public let previousContactId: String?
        /// If this contact was queued, this contains information about the queue.
        public let queueInfo: QueueInfo?
        /// The timestamp, in Unix epoch time format, at which to start running the inbound flow.
        public let scheduledTimestamp: Date?

        public init(agentInfo: AgentInfo? = nil, arn: String? = nil, channel: Channel? = nil, description: String? = nil, disconnectTimestamp: Date? = nil, id: String? = nil, initialContactId: String? = nil, initiationMethod: ContactInitiationMethod? = nil, initiationTimestamp: Date? = nil, lastUpdateTimestamp: Date? = nil, name: String? = nil, previousContactId: String? = nil, queueInfo: QueueInfo? = nil, scheduledTimestamp: Date? = nil) {
            self.agentInfo = agentInfo
            self.arn = arn
            self.channel = channel
            self.description = description
            self.disconnectTimestamp = disconnectTimestamp
            self.id = id
            self.initialContactId = initialContactId
            self.initiationMethod = initiationMethod
            self.initiationTimestamp = initiationTimestamp
            self.lastUpdateTimestamp = lastUpdateTimestamp
            self.name = name
            self.previousContactId = previousContactId
            self.queueInfo = queueInfo
            self.scheduledTimestamp = scheduledTimestamp
        }

        private enum CodingKeys: String, CodingKey {
            case agentInfo = "AgentInfo"
            case arn = "Arn"
            case channel = "Channel"
            case description = "Description"
            case disconnectTimestamp = "DisconnectTimestamp"
            case id = "Id"
            case initialContactId = "InitialContactId"
            case initiationMethod = "InitiationMethod"
            case initiationTimestamp = "InitiationTimestamp"
            case lastUpdateTimestamp = "LastUpdateTimestamp"
            case name = "Name"
            case previousContactId = "PreviousContactId"
            case queueInfo = "QueueInfo"
            case scheduledTimestamp = "ScheduledTimestamp"
        }
    }

    public struct ContactFilter: AWSEncodableShape {
        /// A list of up to 9 contact states.
        public let contactStates: [ContactState]?

        public init(contactStates: [ContactState]? = nil) {
            self.contactStates = contactStates
        }

        public func validate(name: String) throws {
            try self.validate(self.contactStates, name: "contactStates", parent: name, max: 9)
        }

        private enum CodingKeys: String, CodingKey {
            case contactStates = "ContactStates"
        }
    }

    public struct ContactFlow: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String?
        /// The content of the flow.
        public let content: String?
        /// The description of the flow.
        public let description: String?
        /// The identifier of the flow.
        public let id: String?
        /// The name of the flow.
        public let name: String?
        /// The type of flow.
        public let state: ContactFlowState?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of the flow. For descriptions of the available types, see Choose a flow type in the Amazon Connect Administrator Guide.
        public let type: ContactFlowType?

        public init(arn: String? = nil, content: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, state: ContactFlowState? = nil, tags: [String: String]? = nil, type: ContactFlowType? = nil) {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct ContactFlowModule: AWSDecodableShape {
        /// The Amazon Resource Name (ARN).
        public let arn: String?
        /// The content of the flow module.
        public let content: String?
        /// The description of the flow module.
        public let description: String?
        /// The identifier of the flow module.
        public let id: String?
        /// The name of the flow module.
        public let name: String?
        /// The type of flow module.
        public let state: ContactFlowModuleState?
        /// The status of the flow module.
        public let status: ContactFlowModuleStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String? = nil, content: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, state: ContactFlowModuleState? = nil, status: ContactFlowModuleStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.content = content
            self.description = description
            self.id = id
            self.name = name
            self.state = state
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case description = "Description"
            case id = "Id"
            case name = "Name"
            case state = "State"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct ContactFlowModuleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow module.
        public let arn: String?
        /// The identifier of the flow module.
        public let id: String?
        /// The name of the flow module.
        public let name: String?
        /// The type of flow module.
        public let state: ContactFlowModuleState?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, state: ContactFlowModuleState? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case state = "State"
        }
    }

    public struct ContactFlowSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let arn: String?
        /// The type of flow.
        public let contactFlowState: ContactFlowState?
        /// The type of flow.
        public let contactFlowType: ContactFlowType?
        /// The identifier of the flow.
        public let id: String?
        /// The name of the flow.
        public let name: String?

        public init(arn: String? = nil, contactFlowState: ContactFlowState? = nil, contactFlowType: ContactFlowType? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.contactFlowState = contactFlowState
            self.contactFlowType = contactFlowType
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case contactFlowState = "ContactFlowState"
            case contactFlowType = "ContactFlowType"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct ControlPlaneTagFilter: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [TagCondition]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [[TagCondition]]?
        /// A leaf node condition which can be used to specify a tag condition.
        public let tagCondition: TagCondition?

        public init(andConditions: [TagCondition]? = nil, orConditions: [[TagCondition]]? = nil, tagCondition: TagCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.tagCondition = tagCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case tagCondition = "TagCondition"
        }
    }

    public struct CreateAgentStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The description of the status.
        public let description: String?
        /// The display order of the status.
        public let displayOrder: Int?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the status.
        public let name: String
        /// The state of the status.
        public let state: AgentStatusState
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(description: String? = nil, displayOrder: Int? = nil, instanceId: String, name: String, state: AgentStatusState, tags: [String: String]? = nil) {
            self.description = description
            self.displayOrder = displayOrder
            self.instanceId = instanceId
            self.name = name
            self.state = state
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, max: 50)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayOrder = "DisplayOrder"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct CreateAgentStatusResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the agent status.
        public let agentStatusARN: String?
        /// The identifier of the agent status.
        public let agentStatusId: String?

        public init(agentStatusARN: String? = nil, agentStatusId: String? = nil) {
            self.agentStatusARN = agentStatusARN
            self.agentStatusId = agentStatusId
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusARN = "AgentStatusARN"
            case agentStatusId = "AgentStatusId"
        }
    }

    public struct CreateContactFlowModuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The content of the flow module.
        public let content: String
        /// The description of the flow module.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the flow module.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateContactFlowModuleRequest.idempotencyToken(), content: String, description: String? = nil, instanceId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.content = content
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.content, name: "content", parent: name, max: 256_000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case content = "Content"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateContactFlowModuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow module.
        public let arn: String?
        /// The identifier of the flow module.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateContactFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The content of the flow.
        public let content: String
        /// The description of the flow.
        public let description: String?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The name of the flow.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of the flow. For descriptions of the available types, see Choose a flow type in the Amazon Connect Administrator Guide.
        public let type: ContactFlowType

        public init(content: String, description: String? = nil, instanceId: String, name: String, tags: [String: String]? = nil, type: ContactFlowType) {
            self.content = content
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
            case type = "Type"
        }
    }

    public struct CreateContactFlowResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the flow.
        public let contactFlowArn: String?
        /// The identifier of the flow.
        public let contactFlowId: String?

        public init(contactFlowArn: String? = nil, contactFlowId: String? = nil) {
            self.contactFlowArn = contactFlowArn
            self.contactFlowId = contactFlowId
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowArn = "ContactFlowArn"
            case contactFlowId = "ContactFlowId"
        }
    }

    public struct CreateHoursOfOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// Configuration information for the hours of operation: day, start time, and end time.
        public let config: [HoursOfOperationConfig]
        /// The description of the hours of operation.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the hours of operation.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The time zone of the hours of operation.
        public let timeZone: String

        public init(config: [HoursOfOperationConfig], description: String? = nil, instanceId: String, name: String, tags: [String: String]? = nil, timeZone: String) {
            self.config = config
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.tags = tags
            self.timeZone = timeZone
        }

        public func validate(name: String) throws {
            try self.config.forEach {
                try $0.validate(name: "\(name).config[]")
            }
            try self.validate(self.config, name: "config", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case name = "Name"
            case tags = "Tags"
            case timeZone = "TimeZone"
        }
    }

    public struct CreateHoursOfOperationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public let hoursOfOperationArn: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String?

        public init(hoursOfOperationArn: String? = nil, hoursOfOperationId: String? = nil) {
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationArn = "HoursOfOperationArn"
            case hoursOfOperationId = "HoursOfOperationId"
        }
    }

    public struct CreateInstanceRequest: AWSEncodableShape {
        /// The idempotency token.
        public let clientToken: String?
        /// The identifier for the directory.
        public let directoryId: String?
        /// The type of identity management for your Amazon Connect users.
        public let identityManagementType: DirectoryType
        /// Your contact center handles incoming contacts.
        public let inboundCallsEnabled: Bool
        /// The name for your instance.
        public let instanceAlias: String?
        /// Your contact center allows outbound calls.
        public let outboundCallsEnabled: Bool

        public init(clientToken: String? = nil, directoryId: String? = nil, identityManagementType: DirectoryType, inboundCallsEnabled: Bool, instanceAlias: String? = nil, outboundCallsEnabled: Bool) {
            self.clientToken = clientToken
            self.directoryId = directoryId
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAlias = instanceAlias
            self.outboundCallsEnabled = outboundCallsEnabled
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.directoryId, name: "directoryId", parent: name, max: 12)
            try self.validate(self.directoryId, name: "directoryId", parent: name, min: 12)
            try self.validate(self.directoryId, name: "directoryId", parent: name, pattern: "^d-[0-9a-f]{10}$")
            try self.validate(self.instanceAlias, name: "instanceAlias", parent: name, max: 62)
            try self.validate(self.instanceAlias, name: "instanceAlias", parent: name, min: 1)
            try self.validate(self.instanceAlias, name: "instanceAlias", parent: name, pattern: "^(?!d-)([\\da-zA-Z]+)([-]*[\\da-zA-Z])*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case directoryId = "DirectoryId"
            case identityManagementType = "IdentityManagementType"
            case inboundCallsEnabled = "InboundCallsEnabled"
            case instanceAlias = "InstanceAlias"
            case outboundCallsEnabled = "OutboundCallsEnabled"
        }
    }

    public struct CreateInstanceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the instance.
        public let arn: String?
        /// The identifier for the instance.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateIntegrationAssociationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The Amazon Resource Name (ARN) of the integration.  When integrating with Amazon Pinpoint, the Amazon Connect and Amazon Pinpoint instances must be in the same account.
        public let integrationArn: String
        /// The type of information to be ingested.
        public let integrationType: IntegrationType
        /// The name of the external application. This field is only required for the EVENT integration type.
        public let sourceApplicationName: String?
        /// The URL for the external application. This field is only required for the EVENT integration type.
        public let sourceApplicationUrl: String?
        /// The type of the data source. This field is only required for the EVENT integration type.
        public let sourceType: SourceType?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(instanceId: String, integrationArn: String, integrationType: IntegrationType, sourceApplicationName: String? = nil, sourceApplicationUrl: String? = nil, sourceType: SourceType? = nil, tags: [String: String]? = nil) {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationType = integrationType
            self.sourceApplicationName = sourceApplicationName
            self.sourceApplicationUrl = sourceApplicationUrl
            self.sourceType = sourceType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.sourceApplicationName, name: "sourceApplicationName", parent: name, max: 100)
            try self.validate(self.sourceApplicationName, name: "sourceApplicationName", parent: name, min: 1)
            try self.validate(self.sourceApplicationName, name: "sourceApplicationName", parent: name, pattern: "^[a-zA-Z0-9_ -]+$")
            try self.validate(self.sourceApplicationUrl, name: "sourceApplicationUrl", parent: name, max: 2000)
            try self.validate(self.sourceApplicationUrl, name: "sourceApplicationUrl", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case integrationArn = "IntegrationArn"
            case integrationType = "IntegrationType"
            case sourceApplicationName = "SourceApplicationName"
            case sourceApplicationUrl = "SourceApplicationUrl"
            case sourceType = "SourceType"
            case tags = "Tags"
        }
    }

    public struct CreateIntegrationAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the association.
        public let integrationAssociationArn: String?
        /// The identifier for the integration association.
        public let integrationAssociationId: String?

        public init(integrationAssociationArn: String? = nil, integrationAssociationId: String? = nil) {
            self.integrationAssociationArn = integrationAssociationArn
            self.integrationAssociationId = integrationAssociationId
        }

        private enum CodingKeys: String, CodingKey {
            case integrationAssociationArn = "IntegrationAssociationArn"
            case integrationAssociationId = "IntegrationAssociationId"
        }
    }

    public struct CreateQueueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The description of the queue.
        public let description: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public let maxContacts: Int?
        /// The name of the queue.
        public let name: String
        /// The outbound caller ID name, number, and outbound whisper flow.
        public let outboundCallerConfig: OutboundCallerConfig?
        /// The quick connects available to agents who are working the queue.
        public let quickConnectIds: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(description: String? = nil, hoursOfOperationId: String, instanceId: String, maxContacts: Int? = nil, name: String, outboundCallerConfig: OutboundCallerConfig? = nil, quickConnectIds: [String]? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.maxContacts = maxContacts
            self.name = name
            self.outboundCallerConfig = outboundCallerConfig
            self.quickConnectIds = quickConnectIds
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxContacts, name: "maxContacts", parent: name, min: 0)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.outboundCallerConfig?.validate(name: "\(name).outboundCallerConfig")
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, max: 50)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case hoursOfOperationId = "HoursOfOperationId"
            case maxContacts = "MaxContacts"
            case name = "Name"
            case outboundCallerConfig = "OutboundCallerConfig"
            case quickConnectIds = "QuickConnectIds"
            case tags = "Tags"
        }
    }

    public struct CreateQueueResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the queue.
        public let queueArn: String?
        /// The identifier for the queue.
        public let queueId: String?

        public init(queueArn: String? = nil, queueId: String? = nil) {
            self.queueArn = queueArn
            self.queueId = queueId
        }

        private enum CodingKeys: String, CodingKey {
            case queueArn = "QueueArn"
            case queueId = "QueueId"
        }
    }

    public struct CreateQuickConnectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The description of the quick connect.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the quick connect.
        public let name: String
        /// Configuration settings for the quick connect.
        public let quickConnectConfig: QuickConnectConfig
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(description: String? = nil, instanceId: String, name: String, quickConnectConfig: QuickConnectConfig, tags: [String: String]? = nil) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.quickConnectConfig = quickConnectConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.quickConnectConfig.validate(name: "\(name).quickConnectConfig")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case quickConnectConfig = "QuickConnectConfig"
            case tags = "Tags"
        }
    }

    public struct CreateQuickConnectResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the quick connect.
        public let quickConnectARN: String?
        /// The identifier for the quick connect.
        public let quickConnectId: String?

        public init(quickConnectARN: String? = nil, quickConnectId: String? = nil) {
            self.quickConnectARN = quickConnectARN
            self.quickConnectId = quickConnectId
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectARN = "QuickConnectARN"
            case quickConnectId = "QuickConnectId"
        }
    }

    public struct CreateRoutingProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The default outbound queue for the routing profile.
        public let defaultOutboundQueueId: String
        /// Description of the routing profile. Must not be more than 250 characters.
        public let description: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The channels that agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public let mediaConcurrencies: [MediaConcurrency]
        /// The name of the routing profile. Must not be more than 127 characters.
        public let name: String
        /// The inbound queues associated with the routing profile. If no queue is added, the agent can make only outbound calls.
        public let queueConfigs: [RoutingProfileQueueConfig]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(defaultOutboundQueueId: String, description: String, instanceId: String, mediaConcurrencies: [MediaConcurrency], name: String, queueConfigs: [RoutingProfileQueueConfig]? = nil, tags: [String: String]? = nil) {
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.description = description
            self.instanceId = instanceId
            self.mediaConcurrencies = mediaConcurrencies
            self.name = name
            self.queueConfigs = queueConfigs
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.mediaConcurrencies.forEach {
                try $0.validate(name: "\(name).mediaConcurrencies[]")
            }
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.queueConfigs?.forEach {
                try $0.validate(name: "\(name).queueConfigs[]")
            }
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, max: 10)
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultOutboundQueueId = "DefaultOutboundQueueId"
            case description = "Description"
            case mediaConcurrencies = "MediaConcurrencies"
            case name = "Name"
            case queueConfigs = "QueueConfigs"
            case tags = "Tags"
        }
    }

    public struct CreateRoutingProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let routingProfileArn: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String?

        public init(routingProfileArn: String? = nil, routingProfileId: String? = nil) {
            self.routingProfileArn = routingProfileArn
            self.routingProfileId = routingProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case routingProfileArn = "RoutingProfileArn"
            case routingProfileId = "RoutingProfileId"
        }
    }

    public struct CreateRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// A list of actions to be run when the rule is triggered.
        public let actions: [RuleAction]
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The conditions of the rule.
        public let function: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A unique name for the rule.
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// The event source to trigger the rule.
        public let triggerEventSource: RuleTriggerEventSource

        public init(actions: [RuleAction], clientToken: String? = CreateRuleRequest.idempotencyToken(), function: String, instanceId: String, name: String, publishStatus: RulePublishStatus, triggerEventSource: RuleTriggerEventSource) {
            self.actions = actions
            self.clientToken = clientToken
            self.function = function
            self.instanceId = instanceId
            self.name = name
            self.publishStatus = publishStatus
            self.triggerEventSource = triggerEventSource
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.triggerEventSource.validate(name: "\(name).triggerEventSource")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case clientToken = "ClientToken"
            case function = "Function"
            case name = "Name"
            case publishStatus = "PublishStatus"
            case triggerEventSource = "TriggerEventSource"
        }
    }

    public struct CreateRuleResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rule.
        public let ruleArn: String
        /// A unique identifier for the rule.
        public let ruleId: String

        public init(ruleArn: String, ruleId: String) {
            self.ruleArn = ruleArn
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case ruleArn = "RuleArn"
            case ruleId = "RuleId"
        }
    }

    public struct CreateSecurityProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlTags: [String: String]?
        /// The description of the security profile.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// Permissions assigned to the security profile. For a list of valid permissions, see List of security profile permissions.
        public let permissions: [String]?
        /// The name of the security profile.
        public let securityProfileName: String
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect. Following are acceptable ResourceNames: User | SecurityProfile | Queue |  RoutingProfile
        public let tagRestrictedResources: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(allowedAccessControlTags: [String: String]? = nil, description: String? = nil, instanceId: String, permissions: [String]? = nil, securityProfileName: String, tagRestrictedResources: [String]? = nil, tags: [String: String]? = nil) {
            self.allowedAccessControlTags = allowedAccessControlTags
            self.description = description
            self.instanceId = instanceId
            self.permissions = permissions
            self.securityProfileName = securityProfileName
            self.tagRestrictedResources = tagRestrictedResources
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allowedAccessControlTags?.forEach {
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, max: 128)
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, min: 1)
                try validate($0.value, name: "allowedAccessControlTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.allowedAccessControlTags, name: "allowedAccessControlTags", parent: name, max: 2)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, max: 128)
                try validate($0, name: "permissions[]", parent: name, min: 1)
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 500)
            try self.validate(self.securityProfileName, name: "securityProfileName", parent: name, max: 127)
            try self.validate(self.securityProfileName, name: "securityProfileName", parent: name, min: 1)
            try self.validate(self.securityProfileName, name: "securityProfileName", parent: name, pattern: "^[ a-zA-Z0-9_@-]+$")
            try self.tagRestrictedResources?.forEach {
                try validate($0, name: "tagRestrictedResources[]", parent: name, max: 128)
                try validate($0, name: "tagRestrictedResources[]", parent: name, min: 1)
            }
            try self.validate(self.tagRestrictedResources, name: "tagRestrictedResources", parent: name, max: 10)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAccessControlTags = "AllowedAccessControlTags"
            case description = "Description"
            case permissions = "Permissions"
            case securityProfileName = "SecurityProfileName"
            case tagRestrictedResources = "TagRestrictedResources"
            case tags = "Tags"
        }
    }

    public struct CreateSecurityProfileResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the security profile.
        public let securityProfileArn: String?
        /// The identifier for the security profle.
        public let securityProfileId: String?

        public init(securityProfileArn: String? = nil, securityProfileId: String? = nil) {
            self.securityProfileArn = securityProfileArn
            self.securityProfileId = securityProfileId
        }

        private enum CodingKeys: String, CodingKey {
            case securityProfileArn = "SecurityProfileArn"
            case securityProfileId = "SecurityProfileId"
        }
    }

    public struct CreateTaskTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the task template.
        public let name: String
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        public init(clientToken: String? = CreateTaskTemplateRequest.idempotencyToken(), constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField], instanceId: String, name: String, status: TaskTemplateStatus? = nil) {
            self.clientToken = clientToken
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.instanceId = instanceId
            self.name = name
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.constraints?.validate(name: "\(name).constraints")
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.defaults?.validate(name: "\(name).defaults")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.fields.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct CreateTaskTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the task template resource.
        public let arn: String
        /// The identifier of the task template resource.
        public let id: String

        public init(arn: String, id: String) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateTrafficDistributionGroupRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A description for the traffic distribution group.
        public let description: String?
        /// The identifier of the Amazon Connect instance that has been replicated. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name for the traffic distribution group.
        public let name: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateTrafficDistributionGroupRequest.idempotencyToken(), description: String? = nil, instanceId: String, name: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^(^[\\S].*[\\S]$)|(^[\\S]$)$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(^[\\S].*[\\S]$)|(^[\\S]$)$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case instanceId = "InstanceId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct CreateTrafficDistributionGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct CreateUseCaseRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "integrationAssociationId", location: .uri("IntegrationAssociationId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
        public let useCaseType: UseCaseType

        public init(instanceId: String, integrationAssociationId: String, tags: [String: String]? = nil, useCaseType: UseCaseType) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
            self.tags = tags
            self.useCaseType = useCaseType
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case useCaseType = "UseCaseType"
        }
    }

    public struct CreateUseCaseResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the use case.
        public let useCaseArn: String?
        /// The identifier of the use case.
        public let useCaseId: String?

        public init(useCaseArn: String? = nil, useCaseId: String? = nil) {
            self.useCaseArn = useCaseArn
            self.useCaseId = useCaseId
        }

        private enum CodingKeys: String, CodingKey {
            case useCaseArn = "UseCaseArn"
            case useCaseId = "UseCaseId"
        }
    }

    public struct CreateUserHierarchyGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the user hierarchy group. Must not be more than 100 characters.
        public let name: String
        /// The identifier for the parent hierarchy group. The user hierarchy is created at level one if the parent group ID is null.
        public let parentGroupId: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(instanceId: String, name: String, parentGroupId: String? = nil, tags: [String: String]? = nil) {
            self.instanceId = instanceId
            self.name = name
            self.parentGroupId = parentGroupId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case parentGroupId = "ParentGroupId"
            case tags = "Tags"
        }
    }

    public struct CreateUserHierarchyGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let hierarchyGroupArn: String?
        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String?

        public init(hierarchyGroupArn: String? = nil, hierarchyGroupId: String? = nil) {
            self.hierarchyGroupArn = hierarchyGroupArn
            self.hierarchyGroupId = hierarchyGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupArn = "HierarchyGroupArn"
            case hierarchyGroupId = "HierarchyGroupId"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the user account in the directory used for identity management. If Amazon Connect cannot access the directory, you can specify this identifier to authenticate users. If you include the identifier, we assume that Amazon Connect cannot access the directory. Otherwise, the identity information is used to authenticate users from your directory. This parameter is required if you are using an existing directory for identity management in Amazon Connect when Amazon Connect cannot access your directory to authenticate users. If you are using SAML for identity management and include this parameter, an error is returned.
        public let directoryUserId: String?
        /// The identifier of the hierarchy group for the user.
        public let hierarchyGroupId: String?
        /// The information about the identity of the user.
        public let identityInfo: UserIdentityInfo?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The password for the user account. A password is required if you are using Amazon Connect for identity management. Otherwise, it is an error to include a password.
        public let password: String?
        /// The phone settings for the user.
        public let phoneConfig: UserPhoneConfig
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String
        /// The identifier of the security profile for the user.
        public let securityProfileIds: [String]
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The user name for the account. For instances not using SAML for identity management, the user name can include up to 20 characters. If you are using SAML for identity management, the user name can include up to 64 characters from [a-zA-Z0-9_-.\@]+.
        public let username: String

        public init(directoryUserId: String? = nil, hierarchyGroupId: String? = nil, identityInfo: UserIdentityInfo? = nil, instanceId: String, password: String? = nil, phoneConfig: UserPhoneConfig, routingProfileId: String, securityProfileIds: [String], tags: [String: String]? = nil, username: String) {
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.identityInfo = identityInfo
            self.instanceId = instanceId
            self.password = password
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }

        public func validate(name: String) throws {
            try self.identityInfo?.validate(name: "\(name).identityInfo")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.password, name: "password", parent: name, pattern: "^/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d\\S]{8,64}$/$")
            try self.phoneConfig.validate(name: "\(name).phoneConfig")
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, max: 10)
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.username, name: "username", parent: name, max: 100)
            try self.validate(self.username, name: "username", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case identityInfo = "IdentityInfo"
            case password = "Password"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user account.
        public let userArn: String?
        /// The identifier of the user account.
        public let userId: String?

        public init(userArn: String? = nil, userId: String? = nil) {
            self.userArn = userArn
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userArn = "UserArn"
            case userId = "UserId"
        }
    }

    public struct CreateVocabularyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. If a create request is received more than once with same client token, subsequent requests return the previous response without creating a vocabulary again.
        public let clientToken: String?
        /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. The size limit is 50KB. For more information, see Create a custom vocabulary using a table.
        public let content: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// A unique name of the custom vocabulary.
        public let vocabularyName: String

        public init(clientToken: String? = CreateVocabularyRequest.idempotencyToken(), content: String, instanceId: String, languageCode: VocabularyLanguageCode, tags: [String: String]? = nil, vocabularyName: String) {
            self.clientToken = clientToken
            self.content = content
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.tags = tags
            self.vocabularyName = vocabularyName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.content, name: "content", parent: name, max: 60000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, max: 140)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, min: 1)
            try self.validate(self.vocabularyName, name: "vocabularyName", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case content = "Content"
            case languageCode = "LanguageCode"
            case tags = "Tags"
            case vocabularyName = "VocabularyName"
        }
    }

    public struct CreateVocabularyResponse: AWSDecodableShape {
        /// The current state of the custom vocabulary.
        public let state: VocabularyState
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let vocabularyArn: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        public init(state: VocabularyState, vocabularyArn: String, vocabularyId: String) {
            self.state = state
            self.vocabularyArn = vocabularyArn
            self.vocabularyId = vocabularyId
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case vocabularyArn = "VocabularyArn"
            case vocabularyId = "VocabularyId"
        }
    }

    public struct Credentials: AWSDecodableShape {
        /// An access token generated for a federated user to access Amazon Connect.
        public let accessToken: String?
        /// A token generated with an expiration time for the session a user is logged in to Amazon Connect.
        public let accessTokenExpiration: Date?
        /// Renews a token generated for a user to access the Amazon Connect instance.
        public let refreshToken: String?
        /// Renews the expiration timer for a generated token.
        public let refreshTokenExpiration: Date?

        public init(accessToken: String? = nil, accessTokenExpiration: Date? = nil, refreshToken: String? = nil, refreshTokenExpiration: Date? = nil) {
            self.accessToken = accessToken
            self.accessTokenExpiration = accessTokenExpiration
            self.refreshToken = refreshToken
            self.refreshTokenExpiration = refreshTokenExpiration
        }

        private enum CodingKeys: String, CodingKey {
            case accessToken = "AccessToken"
            case accessTokenExpiration = "AccessTokenExpiration"
            case refreshToken = "RefreshToken"
            case refreshTokenExpiration = "RefreshTokenExpiration"
        }
    }

    public struct CurrentMetric: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric.
        public let name: CurrentMetricName?
        /// The unit for the metric.
        public let unit: Unit?

        public init(name: CurrentMetricName? = nil, unit: Unit? = nil) {
            self.name = name
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case unit = "Unit"
        }
    }

    public struct CurrentMetricData: AWSDecodableShape {
        /// Information about the metric.
        public let metric: CurrentMetric?
        /// The value of the metric.
        public let value: Double?

        public init(metric: CurrentMetric? = nil, value: Double? = nil) {
            self.metric = metric
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case value = "Value"
        }
    }

    public struct CurrentMetricResult: AWSDecodableShape {
        /// The set of metrics.
        public let collections: [CurrentMetricData]?
        /// The dimensions for the metrics.
        public let dimensions: Dimensions?

        public init(collections: [CurrentMetricData]? = nil, dimensions: Dimensions? = nil) {
            self.collections = collections
            self.dimensions = dimensions
        }

        private enum CodingKeys: String, CodingKey {
            case collections = "Collections"
            case dimensions = "Dimensions"
        }
    }

    public struct CurrentMetricSortCriteria: AWSEncodableShape {
        public let sortByMetric: CurrentMetricName?
        /// The way to sort.
        public let sortOrder: SortOrder?

        public init(sortByMetric: CurrentMetricName? = nil, sortOrder: SortOrder? = nil) {
            self.sortByMetric = sortByMetric
            self.sortOrder = sortOrder
        }

        private enum CodingKeys: String, CodingKey {
            case sortByMetric = "SortByMetric"
            case sortOrder = "SortOrder"
        }
    }

    public struct DateReference: AWSDecodableShape {
        /// Identifier of the date reference.
        public let name: String?
        /// A valid date.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct DefaultVocabulary: AWSDecodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String
        /// A unique name of the custom vocabulary.
        public let vocabularyName: String

        public init(instanceId: String, languageCode: VocabularyLanguageCode, vocabularyId: String, vocabularyName: String) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.vocabularyId = vocabularyId
            self.vocabularyName = vocabularyName
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case languageCode = "LanguageCode"
            case vocabularyId = "VocabularyId"
            case vocabularyName = "VocabularyName"
        }
    }

    public struct DeleteContactFlowModuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowModuleId", location: .uri("ContactFlowModuleId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactFlowModuleId: String, instanceId: String) {
            self.contactFlowModuleId = contactFlowModuleId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteContactFlowModuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteContactFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowId", location: .uri("ContactFlowId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactFlowId: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteHoursOfOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hoursOfOperationId", location: .uri("HoursOfOperationId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(hoursOfOperationId: String, instanceId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteInstanceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIntegrationAssociationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "integrationAssociationId", location: .uri("IntegrationAssociationId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String

        public init(instanceId: String, integrationAssociationId: String) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteQuickConnectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "quickConnectId", location: .uri("QuickConnectId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the quick connect.
        public let quickConnectId: String

        public init(instanceId: String, quickConnectId: String) {
            self.instanceId = instanceId
            self.quickConnectId = quickConnectId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "ruleId", location: .uri("RuleId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A unique identifier for the rule.
        public let ruleId: String

        public init(instanceId: String, ruleId: String) {
            self.instanceId = instanceId
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 256)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteSecurityProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "securityProfileId", location: .uri("SecurityProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the security profle.
        public let securityProfileId: String

        public init(instanceId: String, securityProfileId: String) {
            self.instanceId = instanceId
            self.securityProfileId = securityProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTaskTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "taskTemplateId", location: .uri("TaskTemplateId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A unique identifier for the task template.
        public let taskTemplateId: String

        public init(instanceId: String, taskTemplateId: String) {
            self.instanceId = instanceId
            self.taskTemplateId = taskTemplateId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTaskTemplateResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteTrafficDistributionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trafficDistributionGroupId", location: .uri("TrafficDistributionGroupId"))
        ]

        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let trafficDistributionGroupId: String

        public init(trafficDistributionGroupId: String) {
            self.trafficDistributionGroupId = trafficDistributionGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.trafficDistributionGroupId, name: "trafficDistributionGroupId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTrafficDistributionGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUseCaseRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "integrationAssociationId", location: .uri("IntegrationAssociationId")),
            AWSMemberEncoding(label: "useCaseId", location: .uri("UseCaseId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String
        /// The identifier for the use case.
        public let useCaseId: String

        public init(instanceId: String, integrationAssociationId: String, useCaseId: String) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
            self.useCaseId = useCaseId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
            try self.validate(self.useCaseId, name: "useCaseId", parent: name, max: 200)
            try self.validate(self.useCaseId, name: "useCaseId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserHierarchyGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hierarchyGroupId", location: .uri("HierarchyGroupId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(hierarchyGroupId: String, instanceId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user.
        public let userId: String

        public init(instanceId: String, userId: String) {
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVocabularyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "vocabularyId", location: .uri("VocabularyId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        public init(instanceId: String, vocabularyId: String) {
            self.instanceId = instanceId
            self.vocabularyId = vocabularyId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, max: 500)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteVocabularyResponse: AWSDecodableShape {
        /// The current state of the custom vocabulary.
        public let state: VocabularyState
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let vocabularyArn: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        public init(state: VocabularyState, vocabularyArn: String, vocabularyId: String) {
            self.state = state
            self.vocabularyArn = vocabularyArn
            self.vocabularyId = vocabularyId
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case vocabularyArn = "VocabularyArn"
            case vocabularyId = "VocabularyId"
        }
    }

    public struct DescribeAgentStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "agentStatusId", location: .uri("AgentStatusId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier for the agent status.
        public let agentStatusId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(agentStatusId: String, instanceId: String) {
            self.agentStatusId = agentStatusId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeAgentStatusResponse: AWSDecodableShape {
        /// The agent status.
        public let agentStatus: AgentStatus?

        public init(agentStatus: AgentStatus? = nil) {
            self.agentStatus = agentStatus
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatus = "AgentStatus"
        }
    }

    public struct DescribeContactFlowModuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowModuleId", location: .uri("ContactFlowModuleId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactFlowModuleId: String, instanceId: String) {
            self.contactFlowModuleId = contactFlowModuleId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactFlowModuleResponse: AWSDecodableShape {
        /// Information about the flow module.
        public let contactFlowModule: ContactFlowModule?

        public init(contactFlowModule: ContactFlowModule? = nil) {
            self.contactFlowModule = contactFlowModule
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowModule = "ContactFlowModule"
        }
    }

    public struct DescribeContactFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowId", location: .uri("ContactFlowId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(contactFlowId: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactFlowResponse: AWSDecodableShape {
        /// Information about the flow.
        public let contactFlow: ContactFlow?

        public init(contactFlow: ContactFlow? = nil) {
            self.contactFlow = contactFlow
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlow = "ContactFlow"
        }
    }

    public struct DescribeContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri("ContactId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactId: String, instanceId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeContactResponse: AWSDecodableShape {
        /// Information about the contact.
        public let contact: Contact?

        public init(contact: Contact? = nil) {
            self.contact = contact
        }

        private enum CodingKeys: String, CodingKey {
            case contact = "Contact"
        }
    }

    public struct DescribeHoursOfOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hoursOfOperationId", location: .uri("HoursOfOperationId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(hoursOfOperationId: String, instanceId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeHoursOfOperationResponse: AWSDecodableShape {
        /// The hours of operation.
        public let hoursOfOperation: HoursOfOperation?

        public init(hoursOfOperation: HoursOfOperation? = nil) {
            self.hoursOfOperation = hoursOfOperation
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperation = "HoursOfOperation"
        }
    }

    public struct DescribeInstanceAttributeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "attributeType", location: .uri("AttributeType")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The type of attribute.
        public let attributeType: InstanceAttributeType
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(attributeType: InstanceAttributeType, instanceId: String) {
            self.attributeType = attributeType
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceAttributeResponse: AWSDecodableShape {
        /// The type of attribute.
        public let attribute: Attribute?

        public init(attribute: Attribute? = nil) {
            self.attribute = attribute
        }

        private enum CodingKeys: String, CodingKey {
            case attribute = "Attribute"
        }
    }

    public struct DescribeInstanceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceResponse: AWSDecodableShape {
        /// The name of the instance.
        public let instance: Instance?

        public init(instance: Instance? = nil) {
            self.instance = instance
        }

        private enum CodingKeys: String, CodingKey {
            case instance = "Instance"
        }
    }

    public struct DescribeInstanceStorageConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "associationId", location: .uri("AssociationId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "resourceType", location: .querystring("resourceType"))
        ]

        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType

        public init(associationId: String, instanceId: String, resourceType: InstanceStorageResourceType) {
            self.associationId = associationId
            self.instanceId = instanceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeInstanceStorageConfigResponse: AWSDecodableShape {
        /// A valid storage type.
        public let storageConfig: InstanceStorageConfig?

        public init(storageConfig: InstanceStorageConfig? = nil) {
            self.storageConfig = storageConfig
        }

        private enum CodingKeys: String, CodingKey {
            case storageConfig = "StorageConfig"
        }
    }

    public struct DescribePhoneNumberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "phoneNumberId", location: .uri("PhoneNumberId"))
        ]

        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        public init(phoneNumberId: String) {
            self.phoneNumberId = phoneNumberId
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribePhoneNumberResponse: AWSDecodableShape {
        /// Information about a phone number that's been claimed to your Amazon Connect instance or traffic distribution group.
        public let claimedPhoneNumberSummary: ClaimedPhoneNumberSummary?

        public init(claimedPhoneNumberSummary: ClaimedPhoneNumberSummary? = nil) {
            self.claimedPhoneNumberSummary = claimedPhoneNumberSummary
        }

        private enum CodingKeys: String, CodingKey {
            case claimedPhoneNumberSummary = "ClaimedPhoneNumberSummary"
        }
    }

    public struct DescribeQueueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String

        public init(instanceId: String, queueId: String) {
            self.instanceId = instanceId
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeQueueResponse: AWSDecodableShape {
        /// The name of the queue.
        public let queue: Queue?

        public init(queue: Queue? = nil) {
            self.queue = queue
        }

        private enum CodingKeys: String, CodingKey {
            case queue = "Queue"
        }
    }

    public struct DescribeQuickConnectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "quickConnectId", location: .uri("QuickConnectId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the quick connect.
        public let quickConnectId: String

        public init(instanceId: String, quickConnectId: String) {
            self.instanceId = instanceId
            self.quickConnectId = quickConnectId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeQuickConnectResponse: AWSDecodableShape {
        /// Information about the quick connect.
        public let quickConnect: QuickConnect?

        public init(quickConnect: QuickConnect? = nil) {
            self.quickConnect = quickConnect
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnect = "QuickConnect"
        }
    }

    public struct DescribeRoutingProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(instanceId: String, routingProfileId: String) {
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRoutingProfileResponse: AWSDecodableShape {
        /// The routing profile.
        public let routingProfile: RoutingProfile?

        public init(routingProfile: RoutingProfile? = nil) {
            self.routingProfile = routingProfile
        }

        private enum CodingKeys: String, CodingKey {
            case routingProfile = "RoutingProfile"
        }
    }

    public struct DescribeRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "ruleId", location: .uri("RuleId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A unique identifier for the rule.
        public let ruleId: String

        public init(instanceId: String, ruleId: String) {
            self.instanceId = instanceId
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 256)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeRuleResponse: AWSDecodableShape {
        /// Information about the rule.
        public let rule: Rule

        public init(rule: Rule) {
            self.rule = rule
        }

        private enum CodingKeys: String, CodingKey {
            case rule = "Rule"
        }
    }

    public struct DescribeSecurityProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "securityProfileId", location: .uri("SecurityProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the security profle.
        public let securityProfileId: String

        public init(instanceId: String, securityProfileId: String) {
            self.instanceId = instanceId
            self.securityProfileId = securityProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeSecurityProfileResponse: AWSDecodableShape {
        /// The security profile.
        public let securityProfile: SecurityProfile?

        public init(securityProfile: SecurityProfile? = nil) {
            self.securityProfile = securityProfile
        }

        private enum CodingKeys: String, CodingKey {
            case securityProfile = "SecurityProfile"
        }
    }

    public struct DescribeTrafficDistributionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "trafficDistributionGroupId", location: .uri("TrafficDistributionGroupId"))
        ]

        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let trafficDistributionGroupId: String

        public init(trafficDistributionGroupId: String) {
            self.trafficDistributionGroupId = trafficDistributionGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.trafficDistributionGroupId, name: "trafficDistributionGroupId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeTrafficDistributionGroupResponse: AWSDecodableShape {
        /// Information about the traffic distribution group.
        public let trafficDistributionGroup: TrafficDistributionGroup?

        public init(trafficDistributionGroup: TrafficDistributionGroup? = nil) {
            self.trafficDistributionGroup = trafficDistributionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case trafficDistributionGroup = "TrafficDistributionGroup"
        }
    }

    public struct DescribeUserHierarchyGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hierarchyGroupId", location: .uri("HierarchyGroupId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(hierarchyGroupId: String, instanceId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserHierarchyGroupResponse: AWSDecodableShape {
        /// Information about the hierarchy group.
        public let hierarchyGroup: HierarchyGroup?

        public init(hierarchyGroup: HierarchyGroup? = nil) {
            self.hierarchyGroup = hierarchyGroup
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroup = "HierarchyGroup"
        }
    }

    public struct DescribeUserHierarchyStructureRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserHierarchyStructureResponse: AWSDecodableShape {
        /// Information about the hierarchy structure.
        public let hierarchyStructure: HierarchyStructure?

        public init(hierarchyStructure: HierarchyStructure? = nil) {
            self.hierarchyStructure = hierarchyStructure
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyStructure = "HierarchyStructure"
        }
    }

    public struct DescribeUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, userId: String) {
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeUserResponse: AWSDecodableShape {
        /// Information about the user account and configuration settings.
        public let user: User?

        public init(user: User? = nil) {
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case user = "User"
        }
    }

    public struct DescribeVocabularyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "vocabularyId", location: .uri("VocabularyId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the custom vocabulary.
        public let vocabularyId: String

        public init(instanceId: String, vocabularyId: String) {
            self.instanceId = instanceId
            self.vocabularyId = vocabularyId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, max: 500)
            try self.validate(self.vocabularyId, name: "vocabularyId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeVocabularyResponse: AWSDecodableShape {
        /// A list of specific words that you want Contact Lens for Amazon Connect to recognize in your audio input. They are generally domain-specific words and phrases, words that Contact Lens is not recognizing, or proper nouns.
        public let vocabulary: Vocabulary

        public init(vocabulary: Vocabulary) {
            self.vocabulary = vocabulary
        }

        private enum CodingKeys: String, CodingKey {
            case vocabulary = "Vocabulary"
        }
    }

    public struct Dimensions: AWSDecodableShape {
        /// The channel used for grouping and filters.
        public let channel: Channel?
        /// Information about the queue for which metrics are returned.
        public let queue: QueueReference?
        public let routingProfile: RoutingProfileReference?

        public init(channel: Channel? = nil, queue: QueueReference? = nil, routingProfile: RoutingProfileReference? = nil) {
            self.channel = channel
            self.queue = queue
            self.routingProfile = routingProfile
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case queue = "Queue"
            case routingProfile = "RoutingProfile"
        }
    }

    public struct DisassociateApprovedOriginRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "origin", location: .querystring("origin"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The domain URL of the integrated application.
        public let origin: String

        public init(instanceId: String, origin: String) {
            self.instanceId = instanceId
            self.origin = origin
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.origin, name: "origin", parent: name, max: 267)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateBotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        public let lexBot: LexBot?
        /// The Amazon Lex V2 bot to disassociate from the instance.
        public let lexV2Bot: LexV2Bot?

        public init(instanceId: String, lexBot: LexBot? = nil, lexV2Bot: LexV2Bot? = nil) {
            self.instanceId = instanceId
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.lexBot?.validate(name: "\(name).lexBot")
            try self.lexV2Bot?.validate(name: "\(name).lexV2Bot")
        }

        private enum CodingKeys: String, CodingKey {
            case lexBot = "LexBot"
            case lexV2Bot = "LexV2Bot"
        }
    }

    public struct DisassociateInstanceStorageConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "associationId", location: .uri("AssociationId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "resourceType", location: .querystring("resourceType"))
        ]

        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType

        public init(associationId: String, instanceId: String, resourceType: InstanceStorageResourceType) {
            self.associationId = associationId
            self.instanceId = instanceId
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateLambdaFunctionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "functionArn", location: .querystring("functionArn")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The Amazon Resource Name (ARN) of the Lambda function being disassociated.
        public let functionArn: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance..
        public let instanceId: String

        public init(functionArn: String, instanceId: String) {
            self.functionArn = functionArn
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.functionArn, name: "functionArn", parent: name, max: 140)
            try self.validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateLexBotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "botName", location: .querystring("botName")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "lexRegion", location: .querystring("lexRegion"))
        ]

        /// The name of the Amazon Lex bot. Maximum character limit of 50.
        public let botName: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The Amazon Web Services Region in which the Amazon Lex bot has been created.
        public let lexRegion: String

        public init(botName: String, instanceId: String, lexRegion: String) {
            self.botName = botName
            self.instanceId = instanceId
            self.lexRegion = lexRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.botName, name: "botName", parent: name, max: 50)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.lexRegion, name: "lexRegion", parent: name, max: 60)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociatePhoneNumberContactFlowRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .querystring("instanceId")),
            AWSMemberEncoding(label: "phoneNumberId", location: .uri("PhoneNumberId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        public init(instanceId: String, phoneNumberId: String) {
            self.instanceId = instanceId
            self.phoneNumberId = phoneNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateQueueQuickConnectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String
        /// The quick connects to disassociate from the queue.
        public let quickConnectIds: [String]

        public init(instanceId: String, queueId: String, quickConnectIds: [String]) {
            self.instanceId = instanceId
            self.queueId = queueId
            self.quickConnectIds = quickConnectIds
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, max: 50)
            try self.validate(self.quickConnectIds, name: "quickConnectIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectIds = "QuickConnectIds"
        }
    }

    public struct DisassociateRoutingProfileQueuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The queues to disassociate from this routing profile.
        public let queueReferences: [RoutingProfileQueueReference]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(instanceId: String, queueReferences: [RoutingProfileQueueReference], routingProfileId: String) {
            self.instanceId = instanceId
            self.queueReferences = queueReferences
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queueReferences = "QueueReferences"
        }
    }

    public struct DisassociateSecurityKeyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "associationId", location: .uri("AssociationId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(associationId: String, instanceId: String) {
            self.associationId = associationId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DismissUserContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(contactId: String, instanceId: String, userId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct DismissUserContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Distribution: AWSEncodableShape & AWSDecodableShape {
        /// The percentage of the traffic that is distributed, in increments of 10.
        public let percentage: Int
        /// The Amazon Web Services Region where the traffic is distributed.
        public let region: String

        public init(percentage: Int, region: String) {
            self.percentage = percentage
            self.region = region
        }

        public func validate(name: String) throws {
            try self.validate(self.percentage, name: "percentage", parent: name, max: 100)
            try self.validate(self.percentage, name: "percentage", parent: name, min: 0)
            try self.validate(self.region, name: "region", parent: name, max: 31)
            try self.validate(self.region, name: "region", parent: name, min: 8)
            try self.validate(self.region, name: "region", parent: name, pattern: "^[a-z]{2}(-[a-z]+){1,2}(-[0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case percentage = "Percentage"
            case region = "Region"
        }
    }

    public struct EmailReference: AWSDecodableShape {
        /// Identifier of the email reference.
        public let name: String?
        /// A valid email address.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct EncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        /// The type of encryption.
        public let encryptionType: EncryptionType
        /// The full ARN of the encryption key.   Be sure to provide the full ARN of the encryption key, not just the ID.
        public let keyId: String

        public init(encryptionType: EncryptionType, keyId: String) {
            self.encryptionType = encryptionType
            self.keyId = keyId
        }

        public func validate(name: String) throws {
            try self.validate(self.keyId, name: "keyId", parent: name, max: 128)
            try self.validate(self.keyId, name: "keyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionType = "EncryptionType"
            case keyId = "KeyId"
        }
    }

    public struct EventBridgeActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The name.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct Filters: AWSEncodableShape {
        /// The channel to use to filter the metrics.
        public let channels: [Channel]?
        /// The queues to use to filter the metrics. You should specify at least one queue, and can specify up to 100 queues per request. The GetCurrentMetricsData API in particular requires a queue when you include a Filter in your request.
        public let queues: [String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public let routingProfiles: [String]?

        public init(channels: [Channel]? = nil, queues: [String]? = nil, routingProfiles: [String]? = nil) {
            self.channels = channels
            self.queues = queues
            self.routingProfiles = routingProfiles
        }

        public func validate(name: String) throws {
            try self.validate(self.channels, name: "channels", parent: name, max: 3)
            try self.validate(self.queues, name: "queues", parent: name, max: 100)
            try self.validate(self.queues, name: "queues", parent: name, min: 1)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, max: 100)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channels = "Channels"
            case queues = "Queues"
            case routingProfiles = "RoutingProfiles"
        }
    }

    public struct GetContactAttributesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "initialContactId", location: .uri("InitialContactId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the initial contact.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(initialContactId: String, instanceId: String) {
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetContactAttributesResponse: AWSDecodableShape {
        /// Information about the attributes.
        public let attributes: [String: String]?

        public init(attributes: [String: String]? = nil) {
            self.attributes = attributes
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
        }
    }

    public struct GetCurrentMetricDataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The metrics to retrieve. Specify the name and unit for each metric. The following metrics are available. For a description of all the metrics, see Real-time Metrics Definitions in the Amazon Connect Administrator Guide.  AGENTS_AFTER_CONTACT_WORK  Unit: COUNT Name in real-time metrics report: ACW   AGENTS_AVAILABLE  Unit: COUNT Name in real-time metrics report: Available   AGENTS_ERROR  Unit: COUNT Name in real-time metrics report: Error   AGENTS_NON_PRODUCTIVE  Unit: COUNT Name in real-time metrics report: NPT (Non-Productive Time)   AGENTS_ON_CALL  Unit: COUNT Name in real-time metrics report: On contact   AGENTS_ON_CONTACT  Unit: COUNT Name in real-time metrics report: On contact   AGENTS_ONLINE  Unit: COUNT Name in real-time metrics report: Online   AGENTS_STAFFED  Unit: COUNT Name in real-time metrics report: Staffed   CONTACTS_IN_QUEUE  Unit: COUNT Name in real-time metrics report: In queue   CONTACTS_SCHEDULED  Unit: COUNT Name in real-time metrics report: Scheduled   OLDEST_CONTACT_AGE  Unit: SECONDS When you use groupings, Unit says SECONDS and the Value is returned in SECONDS.  When you do not use groupings, Unit says SECONDS but the Value is returned in MILLISECONDS. For example, if you get a response like this:  { "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" }, "Value": 24113.0 } The actual OLDEST_CONTACT_AGE is 24 seconds. Name in real-time metrics report: Oldest   SLOTS_ACTIVE  Unit: COUNT Name in real-time metrics report: Active   SLOTS_AVAILABLE  Unit: COUNT Name in real-time metrics report: Availability
        public let currentMetrics: [CurrentMetric]
        /// The filters to apply to returned metrics. You can filter up to the following limits:   Queues: 100   Routing profiles: 100   Channels: 3 (VOICE, CHAT, and TASK channels are supported.)   Metric data is retrieved only for the resources associated with the queues or routing profiles, and by any channels included in the filter. (You cannot filter by both queue AND routing profile.) You can include both resource IDs and resource ARNs in the same request.  Currently tagging is only supported on the resources that are passed in the filter.
        public let filters: Filters
        /// The grouping applied to the metrics returned. For example, when grouped by QUEUE, the metrics returned apply to each queue rather than aggregated for all queues.    If you group by CHANNEL, you should include a Channels filter. VOICE, CHAT, and TASK channels are supported.   If you group by ROUTING_PROFILE, you must include either a queue or routing profile filter. In addition, a routing profile filter is  required for metrics CONTACTS_SCHEDULED, CONTACTS_IN_QUEUE, and  OLDEST_CONTACT_AGE.   If no Grouping is included in the request, a summary of metrics is returned.
        public let groupings: [Grouping]?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?
        /// The way to sort the resulting response based on metrics. You can enter one sort criteria. By default resources are sorted based on AGENTS_ONLINE, DESCENDING. The metric collection is sorted based on the input metrics. Note the following:   Sorting on SLOTS_ACTIVE and SLOTS_AVAILABLE is not supported.
        public let sortCriteria: [CurrentMetricSortCriteria]?

        public init(currentMetrics: [CurrentMetric], filters: Filters, groupings: [Grouping]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, sortCriteria: [CurrentMetricSortCriteria]? = nil) {
            self.currentMetrics = currentMetrics
            self.filters = filters
            self.groupings = groupings
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.sortCriteria = sortCriteria
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.groupings, name: "groupings", parent: name, max: 2)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.sortCriteria, name: "sortCriteria", parent: name, max: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case currentMetrics = "CurrentMetrics"
            case filters = "Filters"
            case groupings = "Groupings"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case sortCriteria = "SortCriteria"
        }
    }

    public struct GetCurrentMetricDataResponse: AWSDecodableShape {
        /// The total count of the result, regardless of the current page size.
        public let approximateTotalCount: Int64?
        /// The time at which the metrics were retrieved and cached for pagination.
        public let dataSnapshotTime: Date?
        /// Information about the real-time metrics.
        public let metricResults: [CurrentMetricResult]?
        /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?

        public init(approximateTotalCount: Int64? = nil, dataSnapshotTime: Date? = nil, metricResults: [CurrentMetricResult]? = nil, nextToken: String? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.dataSnapshotTime = dataSnapshotTime
            self.metricResults = metricResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case dataSnapshotTime = "DataSnapshotTime"
            case metricResults = "MetricResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCurrentUserDataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The filters to apply to returned user data. You can filter up to the following limits:   Queues: 100   Routing profiles: 100   Agents: 100   Contact states: 9   User hierarchy groups: 1   The user data is retrieved for only the specified values/resources in the filter. A maximum of one filter can be passed from queues, routing profiles, agents, and user hierarchy groups.  Currently tagging is only supported on the resources that are passed in the filter.
        public let filters: UserDataFilters
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(filters: UserDataFilters, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetCurrentUserDataResponse: AWSDecodableShape {
        /// The total count of the result, regardless of the current page size.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A list of the user data that is returned.
        public let userDataList: [UserData]?

        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, userDataList: [UserData]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.userDataList = userDataList
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case userDataList = "UserDataList"
        }
    }

    public struct GetFederationTokenRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(instanceId: String) {
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetFederationTokenResponse: AWSDecodableShape {
        /// The credentials to use for federation.
        public let credentials: Credentials?
        /// The URL to sign into the user's instance.
        public let signInUrl: String?
        /// The Amazon Resource Name (ARN) of the user.
        public let userArn: String?
        /// The identifier for the user.
        public let userId: String?

        public init(credentials: Credentials? = nil, signInUrl: String? = nil, userArn: String? = nil, userId: String? = nil) {
            self.credentials = credentials
            self.signInUrl = signInUrl
            self.userArn = userArn
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case credentials = "Credentials"
            case signInUrl = "SignInUrl"
            case userArn = "UserArn"
            case userId = "UserId"
        }
    }

    public struct GetMetricDataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The timestamp, in UNIX Epoch time format, at which to end the reporting interval for the retrieval of historical metrics data. The time must be specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and must be later than the start time timestamp. The time range between the start and end time must be less than 24 hours.
        public let endTime: Date
        /// The queues, up to 100, or channels, to use to filter the metrics returned. Metric data is retrieved only for the resources associated with the queues or channels included in the filter. You can include both queue IDs and queue ARNs in the same request. VOICE, CHAT, and TASK channels are supported.  To filter by Queues, enter the queue ID/ARN, not the name of the queue.
        public let filters: Filters
        /// The grouping applied to the metrics returned. For example, when results are grouped by queue, the metrics returned are grouped by queue. The values returned apply to the metrics for each queue rather than aggregated for all queues. If no grouping is specified, a summary of metrics for all queues is returned.
        public let groupings: [Grouping]?
        /// The metrics to retrieve. Specify the name, unit, and statistic for each metric. The following historical metrics are available. For a description of each metric, see Historical Metrics Definitions in the Amazon Connect Administrator Guide.  This API does not support a contacts incoming metric (there's no CONTACTS_INCOMING metric missing from the documented list).    ABANDON_TIME  Unit: SECONDS Statistic: AVG  AFTER_CONTACT_WORK_TIME  Unit: SECONDS Statistic: AVG  API_CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CALLBACK_CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CONTACTS_ABANDONED  Unit: COUNT Statistic: SUM  CONTACTS_AGENT_HUNG_UP_FIRST  Unit: COUNT Statistic: SUM  CONTACTS_CONSULTED  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED_INCOMING  Unit: COUNT Statistic: SUM  CONTACTS_HANDLED_OUTBOUND  Unit: COUNT Statistic: SUM  CONTACTS_HOLD_ABANDONS  Unit: COUNT Statistic: SUM  CONTACTS_MISSED  Unit: COUNT Statistic: SUM  CONTACTS_QUEUED  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_IN  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_IN_FROM_QUEUE  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_OUT  Unit: COUNT Statistic: SUM  CONTACTS_TRANSFERRED_OUT_FROM_QUEUE  Unit: COUNT Statistic: SUM  HANDLE_TIME  Unit: SECONDS Statistic: AVG  HOLD_TIME  Unit: SECONDS Statistic: AVG  INTERACTION_AND_HOLD_TIME  Unit: SECONDS Statistic: AVG  INTERACTION_TIME  Unit: SECONDS Statistic: AVG  OCCUPANCY  Unit: PERCENT Statistic: AVG  QUEUE_ANSWER_TIME  Unit: SECONDS Statistic: AVG  QUEUED_TIME  Unit: SECONDS Statistic: MAX  SERVICE_LEVEL  You can include up to 20 SERVICE_LEVEL metrics in a request. Unit: PERCENT Statistic: AVG Threshold: For ThresholdValue, enter any whole number from 1 to 604800 (inclusive), in seconds. For Comparison, you must enter LT (for "Less than").
        public let historicalMetrics: [HistoricalMetric]
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The timestamp, in UNIX Epoch time format, at which to start the reporting interval for the retrieval of historical metrics data. The time must be specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15. The start time cannot be earlier than 24 hours before the time of the request. Historical metrics are available only for 24 hours.
        public let startTime: Date

        public init(endTime: Date, filters: Filters, groupings: [Grouping]? = nil, historicalMetrics: [HistoricalMetric], instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date) {
            self.endTime = endTime
            self.filters = filters
            self.groupings = groupings
            self.historicalMetrics = historicalMetrics
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.filters.validate(name: "\(name).filters")
            try self.validate(self.groupings, name: "groupings", parent: name, max: 2)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case endTime = "EndTime"
            case filters = "Filters"
            case groupings = "Groupings"
            case historicalMetrics = "HistoricalMetrics"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case startTime = "StartTime"
        }
    }

    public struct GetMetricDataResponse: AWSDecodableShape {
        /// Information about the historical metrics. If no grouping is specified, a summary of metric data is returned.
        public let metricResults: [HistoricalMetricResult]?
        /// If there are additional results, this is the token for the next set of results. The token expires after 5 minutes from the time it is created. Subsequent requests that use the token must use the same request parameters as the request that generated the token.
        public let nextToken: String?

        public init(metricResults: [HistoricalMetricResult]? = nil, nextToken: String? = nil) {
            self.metricResults = metricResults
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case metricResults = "MetricResults"
            case nextToken = "NextToken"
        }
    }

    public struct GetTaskTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "snapshotVersion", location: .querystring("snapshotVersion")),
            AWSMemberEncoding(label: "taskTemplateId", location: .uri("TaskTemplateId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The system generated version of a task template that is associated with a task, when the task is created.
        public let snapshotVersion: String?
        /// A unique identifier for the task template.
        public let taskTemplateId: String

        public init(instanceId: String, snapshotVersion: String? = nil, taskTemplateId: String) {
            self.instanceId = instanceId
            self.snapshotVersion = snapshotVersion
            self.taskTemplateId = taskTemplateId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTaskTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN).
        public let arn: String
        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The timestamp when the task template was created.
        public let createdTime: Date?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]?
        /// A unique identifier for the task template.
        public let id: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?
        /// The timestamp when the task template was last modified.
        public let lastModifiedTime: Date?
        /// The name of the task template.
        public let name: String
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String, constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, createdTime: Date? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField]? = nil, id: String, instanceId: String? = nil, lastModifiedTime: Date? = nil, name: String, status: TaskTemplateStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.createdTime = createdTime
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.id = id
            self.instanceId = instanceId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case createdTime = "CreatedTime"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case id = "Id"
            case instanceId = "InstanceId"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct GetTrafficDistributionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("Id"))
        ]

        /// The identifier of the traffic distribution group.
        public let id: String

        public init(id: String) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTrafficDistributionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String?
        /// The distribution of traffic between the instance and its replicas.
        public let telephonyConfig: TelephonyConfig?

        public init(arn: String? = nil, id: String? = nil, telephonyConfig: TelephonyConfig? = nil) {
            self.arn = arn
            self.id = id
            self.telephonyConfig = telephonyConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case telephonyConfig = "TelephonyConfig"
        }
    }

    public struct HierarchyGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let arn: String?
        /// Information about the levels in the hierarchy group.
        public let hierarchyPath: HierarchyPath?
        /// The identifier of the hierarchy group.
        public let id: String?
        /// The identifier of the level in the hierarchy group.
        public let levelId: String?
        /// The name of the hierarchy group.
        public let name: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String? = nil, hierarchyPath: HierarchyPath? = nil, id: String? = nil, levelId: String? = nil, name: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.hierarchyPath = hierarchyPath
            self.id = id
            self.levelId = levelId
            self.name = name
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case hierarchyPath = "HierarchyPath"
            case id = "Id"
            case levelId = "LevelId"
            case name = "Name"
            case tags = "Tags"
        }
    }

    public struct HierarchyGroupCondition: AWSEncodableShape {
        /// The type of hierarchy group match.
        public let hierarchyGroupMatchType: HierarchyGroupMatchType?
        /// The value in the hierarchy group condition.
        public let value: String?

        public init(hierarchyGroupMatchType: HierarchyGroupMatchType? = nil, value: String? = nil) {
            self.hierarchyGroupMatchType = hierarchyGroupMatchType
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupMatchType = "HierarchyGroupMatchType"
            case value = "Value"
        }
    }

    public struct HierarchyGroupSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy group.
        public let arn: String?
        /// The identifier of the hierarchy group.
        public let id: String?
        /// The name of the hierarchy group.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct HierarchyGroupSummaryReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the hierarchy group.
        public let arn: String?
        /// The unique identifier for the hierarchy group.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct HierarchyLevel: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hierarchy level.
        public let arn: String?
        /// The identifier of the hierarchy level.
        public let id: String?
        /// The name of the hierarchy level.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct HierarchyLevelUpdate: AWSEncodableShape {
        /// The name of the user hierarchy level. Must not be more than 50 characters.
        public let name: String

        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct HierarchyPath: AWSDecodableShape {
        /// Information about level five.
        public let levelFive: HierarchyGroupSummary?
        /// Information about level four.
        public let levelFour: HierarchyGroupSummary?
        /// Information about level one.
        public let levelOne: HierarchyGroupSummary?
        /// Information about level three.
        public let levelThree: HierarchyGroupSummary?
        /// Information about level two.
        public let levelTwo: HierarchyGroupSummary?

        public init(levelFive: HierarchyGroupSummary? = nil, levelFour: HierarchyGroupSummary? = nil, levelOne: HierarchyGroupSummary? = nil, levelThree: HierarchyGroupSummary? = nil, levelTwo: HierarchyGroupSummary? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HierarchyPathReference: AWSDecodableShape {
        /// Information about level five.
        public let levelFive: HierarchyGroupSummaryReference?
        /// Information about level four.
        public let levelFour: HierarchyGroupSummaryReference?
        /// Information about level one.
        public let levelOne: HierarchyGroupSummaryReference?
        /// Information about level three.
        public let levelThree: HierarchyGroupSummaryReference?
        /// Information about level two.
        public let levelTwo: HierarchyGroupSummaryReference?

        public init(levelFive: HierarchyGroupSummaryReference? = nil, levelFour: HierarchyGroupSummaryReference? = nil, levelOne: HierarchyGroupSummaryReference? = nil, levelThree: HierarchyGroupSummaryReference? = nil, levelTwo: HierarchyGroupSummaryReference? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HierarchyStructure: AWSDecodableShape {
        /// Information about level five.
        public let levelFive: HierarchyLevel?
        /// Information about level four.
        public let levelFour: HierarchyLevel?
        /// Information about level one.
        public let levelOne: HierarchyLevel?
        /// Information about level three.
        public let levelThree: HierarchyLevel?
        /// Information about level two.
        public let levelTwo: HierarchyLevel?

        public init(levelFive: HierarchyLevel? = nil, levelFour: HierarchyLevel? = nil, levelOne: HierarchyLevel? = nil, levelThree: HierarchyLevel? = nil, levelTwo: HierarchyLevel? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HierarchyStructureUpdate: AWSEncodableShape {
        /// The update for level five.
        public let levelFive: HierarchyLevelUpdate?
        /// The update for level four.
        public let levelFour: HierarchyLevelUpdate?
        /// The update for level one.
        public let levelOne: HierarchyLevelUpdate?
        /// The update for level three.
        public let levelThree: HierarchyLevelUpdate?
        /// The update for level two.
        public let levelTwo: HierarchyLevelUpdate?

        public init(levelFive: HierarchyLevelUpdate? = nil, levelFour: HierarchyLevelUpdate? = nil, levelOne: HierarchyLevelUpdate? = nil, levelThree: HierarchyLevelUpdate? = nil, levelTwo: HierarchyLevelUpdate? = nil) {
            self.levelFive = levelFive
            self.levelFour = levelFour
            self.levelOne = levelOne
            self.levelThree = levelThree
            self.levelTwo = levelTwo
        }

        private enum CodingKeys: String, CodingKey {
            case levelFive = "LevelFive"
            case levelFour = "LevelFour"
            case levelOne = "LevelOne"
            case levelThree = "LevelThree"
            case levelTwo = "LevelTwo"
        }
    }

    public struct HistoricalMetric: AWSEncodableShape & AWSDecodableShape {
        /// The name of the metric.
        public let name: HistoricalMetricName?
        /// The statistic for the metric.
        public let statistic: Statistic?
        /// The threshold for the metric, used with service level metrics.
        public let threshold: Threshold?
        /// The unit for the metric.
        public let unit: Unit?

        public init(name: HistoricalMetricName? = nil, statistic: Statistic? = nil, threshold: Threshold? = nil, unit: Unit? = nil) {
            self.name = name
            self.statistic = statistic
            self.threshold = threshold
            self.unit = unit
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case statistic = "Statistic"
            case threshold = "Threshold"
            case unit = "Unit"
        }
    }

    public struct HistoricalMetricData: AWSDecodableShape {
        /// Information about the metric.
        public let metric: HistoricalMetric?
        /// The value of the metric.
        public let value: Double?

        public init(metric: HistoricalMetric? = nil, value: Double? = nil) {
            self.metric = metric
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case metric = "Metric"
            case value = "Value"
        }
    }

    public struct HistoricalMetricResult: AWSDecodableShape {
        /// The set of metrics.
        public let collections: [HistoricalMetricData]?
        /// The dimension for the metrics.
        public let dimensions: Dimensions?

        public init(collections: [HistoricalMetricData]? = nil, dimensions: Dimensions? = nil) {
            self.collections = collections
            self.dimensions = dimensions
        }

        private enum CodingKeys: String, CodingKey {
            case collections = "Collections"
            case dimensions = "Dimensions"
        }
    }

    public struct HoursOfOperation: AWSDecodableShape {
        /// Configuration information for the hours of operation.
        public let config: [HoursOfOperationConfig]?
        /// The description for the hours of operation.
        public let description: String?
        /// The Amazon Resource Name (ARN) for the hours of operation.
        public let hoursOfOperationArn: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String?
        /// The name for the hours of operation.
        public let name: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The time zone for the hours of operation.
        public let timeZone: String?

        public init(config: [HoursOfOperationConfig]? = nil, description: String? = nil, hoursOfOperationArn: String? = nil, hoursOfOperationId: String? = nil, name: String? = nil, tags: [String: String]? = nil, timeZone: String? = nil) {
            self.config = config
            self.description = description
            self.hoursOfOperationArn = hoursOfOperationArn
            self.hoursOfOperationId = hoursOfOperationId
            self.name = name
            self.tags = tags
            self.timeZone = timeZone
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case hoursOfOperationArn = "HoursOfOperationArn"
            case hoursOfOperationId = "HoursOfOperationId"
            case name = "Name"
            case tags = "Tags"
            case timeZone = "TimeZone"
        }
    }

    public struct HoursOfOperationConfig: AWSEncodableShape & AWSDecodableShape {
        /// The day that the hours of operation applies to.
        public let day: HoursOfOperationDays
        /// The end time that your contact center closes.
        public let endTime: HoursOfOperationTimeSlice
        /// The start time that your contact center opens.
        public let startTime: HoursOfOperationTimeSlice

        public init(day: HoursOfOperationDays, endTime: HoursOfOperationTimeSlice, startTime: HoursOfOperationTimeSlice) {
            self.day = day
            self.endTime = endTime
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.endTime.validate(name: "\(name).endTime")
            try self.startTime.validate(name: "\(name).startTime")
        }

        private enum CodingKeys: String, CodingKey {
            case day = "Day"
            case endTime = "EndTime"
            case startTime = "StartTime"
        }
    }

    public struct HoursOfOperationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the hours of operation.
        public let arn: String?
        /// The identifier of the hours of operation.
        public let id: String?
        /// The name of the hours of operation.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct HoursOfOperationTimeSlice: AWSEncodableShape & AWSDecodableShape {
        /// The hours.
        public let hours: Int
        /// The minutes.
        public let minutes: Int

        public init(hours: Int, minutes: Int) {
            self.hours = hours
            self.minutes = minutes
        }

        public func validate(name: String) throws {
            try self.validate(self.hours, name: "hours", parent: name, max: 23)
            try self.validate(self.hours, name: "hours", parent: name, min: 0)
            try self.validate(self.minutes, name: "minutes", parent: name, max: 59)
            try self.validate(self.minutes, name: "minutes", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case hours = "Hours"
            case minutes = "Minutes"
        }
    }

    public struct Instance: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the instance.
        public let arn: String?
        /// When the instance was created.
        public let createdTime: Date?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let id: String?
        /// The identity management type.
        public let identityManagementType: DirectoryType?
        /// Whether inbound calls are enabled.
        public let inboundCallsEnabled: Bool?
        /// The alias of instance.
        public let instanceAlias: String?
        /// The state of the instance.
        public let instanceStatus: InstanceStatus?
        /// Whether outbound calls are enabled.
        public let outboundCallsEnabled: Bool?
        /// The service role of the instance.
        public let serviceRole: String?
        /// Relevant details why the instance was not successfully created.
        public let statusReason: InstanceStatusReason?

        public init(arn: String? = nil, createdTime: Date? = nil, id: String? = nil, identityManagementType: DirectoryType? = nil, inboundCallsEnabled: Bool? = nil, instanceAlias: String? = nil, instanceStatus: InstanceStatus? = nil, outboundCallsEnabled: Bool? = nil, serviceRole: String? = nil, statusReason: InstanceStatusReason? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
            self.statusReason = statusReason
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case id = "Id"
            case identityManagementType = "IdentityManagementType"
            case inboundCallsEnabled = "InboundCallsEnabled"
            case instanceAlias = "InstanceAlias"
            case instanceStatus = "InstanceStatus"
            case outboundCallsEnabled = "OutboundCallsEnabled"
            case serviceRole = "ServiceRole"
            case statusReason = "StatusReason"
        }
    }

    public struct InstanceStatusReason: AWSDecodableShape {
        /// The message.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct InstanceStorageConfig: AWSEncodableShape & AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?
        /// The configuration of the Kinesis Firehose delivery stream.
        public let kinesisFirehoseConfig: KinesisFirehoseConfig?
        /// The configuration of the Kinesis data stream.
        public let kinesisStreamConfig: KinesisStreamConfig?
        /// The configuration of the Kinesis video stream.
        public let kinesisVideoStreamConfig: KinesisVideoStreamConfig?
        /// The S3 bucket configuration.
        public let s3Config: S3Config?
        /// A valid storage type.
        public let storageType: StorageType

        public init(associationId: String? = nil, kinesisFirehoseConfig: KinesisFirehoseConfig? = nil, kinesisStreamConfig: KinesisStreamConfig? = nil, kinesisVideoStreamConfig: KinesisVideoStreamConfig? = nil, s3Config: S3Config? = nil, storageType: StorageType) {
            self.associationId = associationId
            self.kinesisFirehoseConfig = kinesisFirehoseConfig
            self.kinesisStreamConfig = kinesisStreamConfig
            self.kinesisVideoStreamConfig = kinesisVideoStreamConfig
            self.s3Config = s3Config
            self.storageType = storageType
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.kinesisVideoStreamConfig?.validate(name: "\(name).kinesisVideoStreamConfig")
            try self.s3Config?.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case kinesisFirehoseConfig = "KinesisFirehoseConfig"
            case kinesisStreamConfig = "KinesisStreamConfig"
            case kinesisVideoStreamConfig = "KinesisVideoStreamConfig"
            case s3Config = "S3Config"
            case storageType = "StorageType"
        }
    }

    public struct InstanceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the instance.
        public let arn: String?
        /// When the instance was created.
        public let createdTime: Date?
        /// The identifier of the instance.
        public let id: String?
        /// The identity management type of the instance.
        public let identityManagementType: DirectoryType?
        /// Whether inbound calls are enabled.
        public let inboundCallsEnabled: Bool?
        /// The alias of the instance.
        public let instanceAlias: String?
        /// The state of the instance.
        public let instanceStatus: InstanceStatus?
        /// Whether outbound calls are enabled.
        public let outboundCallsEnabled: Bool?
        /// The service role of the instance.
        public let serviceRole: String?

        public init(arn: String? = nil, createdTime: Date? = nil, id: String? = nil, identityManagementType: DirectoryType? = nil, inboundCallsEnabled: Bool? = nil, instanceAlias: String? = nil, instanceStatus: InstanceStatus? = nil, outboundCallsEnabled: Bool? = nil, serviceRole: String? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.identityManagementType = identityManagementType
            self.inboundCallsEnabled = inboundCallsEnabled
            self.instanceAlias = instanceAlias
            self.instanceStatus = instanceStatus
            self.outboundCallsEnabled = outboundCallsEnabled
            self.serviceRole = serviceRole
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case id = "Id"
            case identityManagementType = "IdentityManagementType"
            case inboundCallsEnabled = "InboundCallsEnabled"
            case instanceAlias = "InstanceAlias"
            case instanceStatus = "InstanceStatus"
            case outboundCallsEnabled = "OutboundCallsEnabled"
            case serviceRole = "ServiceRole"
        }
    }

    public struct IntegrationAssociationSummary: AWSDecodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?
        /// The Amazon Resource Name (ARN) for the AppIntegration.
        public let integrationArn: String?
        /// The Amazon Resource Name (ARN) for the AppIntegration association.
        public let integrationAssociationArn: String?
        /// The identifier for the AppIntegration association.
        public let integrationAssociationId: String?
        /// The integration type.
        public let integrationType: IntegrationType?
        /// The user-provided, friendly name for the external application.
        public let sourceApplicationName: String?
        /// The URL for the external application.
        public let sourceApplicationUrl: String?
        /// The name of the source.
        public let sourceType: SourceType?

        public init(instanceId: String? = nil, integrationArn: String? = nil, integrationAssociationArn: String? = nil, integrationAssociationId: String? = nil, integrationType: IntegrationType? = nil, sourceApplicationName: String? = nil, sourceApplicationUrl: String? = nil, sourceType: SourceType? = nil) {
            self.instanceId = instanceId
            self.integrationArn = integrationArn
            self.integrationAssociationArn = integrationAssociationArn
            self.integrationAssociationId = integrationAssociationId
            self.integrationType = integrationType
            self.sourceApplicationName = sourceApplicationName
            self.sourceApplicationUrl = sourceApplicationUrl
            self.sourceType = sourceType
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case integrationArn = "IntegrationArn"
            case integrationAssociationArn = "IntegrationAssociationArn"
            case integrationAssociationId = "IntegrationAssociationId"
            case integrationType = "IntegrationType"
            case sourceApplicationName = "SourceApplicationName"
            case sourceApplicationUrl = "SourceApplicationUrl"
            case sourceType = "SourceType"
        }
    }

    public struct InvisibleFieldInfo: AWSEncodableShape & AWSDecodableShape {
        /// Identifier of the invisible field.
        public let id: TaskTemplateFieldIdentifier?

        public init(id: TaskTemplateFieldIdentifier? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct KinesisFirehoseConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        public let firehoseArn: String

        public init(firehoseArn: String) {
            self.firehoseArn = firehoseArn
        }

        private enum CodingKeys: String, CodingKey {
            case firehoseArn = "FirehoseArn"
        }
    }

    public struct KinesisStreamConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the data stream.
        public let streamArn: String

        public init(streamArn: String) {
            self.streamArn = streamArn
        }

        private enum CodingKeys: String, CodingKey {
            case streamArn = "StreamArn"
        }
    }

    public struct KinesisVideoStreamConfig: AWSEncodableShape & AWSDecodableShape {
        /// The encryption configuration.
        public let encryptionConfig: EncryptionConfig
        /// The prefix of the video stream.
        public let prefix: String
        /// The number of hours data is retained in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data.
        public let retentionPeriodHours: Int

        public init(encryptionConfig: EncryptionConfig, prefix: String, retentionPeriodHours: Int) {
            self.encryptionConfig = encryptionConfig
            self.prefix = prefix
            self.retentionPeriodHours = retentionPeriodHours
        }

        public func validate(name: String) throws {
            try self.encryptionConfig.validate(name: "\(name).encryptionConfig")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 128)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
            try self.validate(self.retentionPeriodHours, name: "retentionPeriodHours", parent: name, max: 87600)
            try self.validate(self.retentionPeriodHours, name: "retentionPeriodHours", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case encryptionConfig = "EncryptionConfig"
            case prefix = "Prefix"
            case retentionPeriodHours = "RetentionPeriodHours"
        }
    }

    public struct LexBot: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Web Services Region where the Amazon Lex bot was created.
        public let lexRegion: String?
        /// The name of the Amazon Lex bot.
        public let name: String?

        public init(lexRegion: String? = nil, name: String? = nil) {
            self.lexRegion = lexRegion
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.lexRegion, name: "lexRegion", parent: name, max: 60)
            try self.validate(self.name, name: "name", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case lexRegion = "LexRegion"
            case name = "Name"
        }
    }

    public struct LexBotConfig: AWSDecodableShape {
        public let lexBot: LexBot?
        /// Configuration information of an Amazon Lex V2 bot.
        public let lexV2Bot: LexV2Bot?

        public init(lexBot: LexBot? = nil, lexV2Bot: LexV2Bot? = nil) {
            self.lexBot = lexBot
            self.lexV2Bot = lexV2Bot
        }

        private enum CodingKeys: String, CodingKey {
            case lexBot = "LexBot"
            case lexV2Bot = "LexV2Bot"
        }
    }

    public struct LexV2Bot: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.
        public let aliasArn: String?

        public init(aliasArn: String? = nil) {
            self.aliasArn = aliasArn
        }

        public func validate(name: String) throws {
            try self.validate(self.aliasArn, name: "aliasArn", parent: name, max: 100)
            try self.validate(self.aliasArn, name: "aliasArn", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case aliasArn = "AliasArn"
        }
    }

    public struct ListAgentStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "agentStatusTypes", location: .querystring("AgentStatusTypes")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// Available agent status types.
        public let agentStatusTypes: [AgentStatusType]?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(agentStatusTypes: [AgentStatusType]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.agentStatusTypes = agentStatusTypes
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.agentStatusTypes, name: "agentStatusTypes", parent: name, max: 3)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAgentStatusResponse: AWSDecodableShape {
        /// A summary of agent statuses.
        public let agentStatusSummaryList: [AgentStatusSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(agentStatusSummaryList: [AgentStatusSummary]? = nil, nextToken: String? = nil) {
            self.agentStatusSummaryList = agentStatusSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusSummaryList = "AgentStatusSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListApprovedOriginsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApprovedOriginsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The approved origins.
        public let origins: [String]?

        public init(nextToken: String? = nil, origins: [String]? = nil) {
            self.nextToken = nextToken
            self.origins = origins
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case origins = "Origins"
        }
    }

    public struct ListBotsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "lexVersion", location: .querystring("lexVersion")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The version of Amazon Lex or Amazon Lex V2.
        public let lexVersion: LexVersion
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, lexVersion: LexVersion, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.lexVersion = lexVersion
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListBotsResponse: AWSDecodableShape {
        /// The names and Amazon Web Services Regions of the Amazon Lex or Amazon Lex V2 bots associated with the specified instance.
        public let lexBots: [LexBotConfig]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(lexBots: [LexBotConfig]? = nil, nextToken: String? = nil) {
            self.lexBots = lexBots
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lexBots = "LexBots"
            case nextToken = "NextToken"
        }
    }

    public struct ListContactFlowModulesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowModuleState", location: .querystring("state")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The state of the flow module.
        public let contactFlowModuleState: ContactFlowModuleState?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(contactFlowModuleState: ContactFlowModuleState? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactFlowModuleState = contactFlowModuleState
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactFlowModulesResponse: AWSDecodableShape {
        /// Information about the flow module.
        public let contactFlowModulesSummaryList: [ContactFlowModuleSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(contactFlowModulesSummaryList: [ContactFlowModuleSummary]? = nil, nextToken: String? = nil) {
            self.contactFlowModulesSummaryList = contactFlowModulesSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowModulesSummaryList = "ContactFlowModulesSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListContactFlowsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowTypes", location: .querystring("contactFlowTypes")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The type of flow.
        public let contactFlowTypes: [ContactFlowType]?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(contactFlowTypes: [ContactFlowType]? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.contactFlowTypes = contactFlowTypes
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowTypes, name: "contactFlowTypes", parent: name, max: 10)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactFlowsResponse: AWSDecodableShape {
        /// Information about the flows.
        public let contactFlowSummaryList: [ContactFlowSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(contactFlowSummaryList: [ContactFlowSummary]? = nil, nextToken: String? = nil) {
            self.contactFlowSummaryList = contactFlowSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowSummaryList = "ContactFlowSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListContactReferencesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri("ContactId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "referenceTypes", location: .querystring("referenceTypes"))
        ]

        /// The identifier of the initial contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.  This is not expected to be set, because the value returned in the previous response is always null.
        public let nextToken: String?
        /// The type of reference.
        public let referenceTypes: [ReferenceType]

        public init(contactId: String, instanceId: String, nextToken: String? = nil, referenceTypes: [ReferenceType]) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.nextToken = nextToken
            self.referenceTypes = referenceTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.referenceTypes, name: "referenceTypes", parent: name, max: 6)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListContactReferencesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.  This is always returned as null in the response.
        public let nextToken: String?
        /// Information about the flows.
        public let referenceSummaryList: [ReferenceSummary]?

        public init(nextToken: String? = nil, referenceSummaryList: [ReferenceSummary]? = nil) {
            self.nextToken = nextToken
            self.referenceSummaryList = referenceSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case referenceSummaryList = "ReferenceSummaryList"
        }
    }

    public struct ListDefaultVocabulariesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, languageCode: VocabularyLanguageCode? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131_070)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "LanguageCode"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDefaultVocabulariesResponse: AWSDecodableShape {
        /// A list of default vocabularies.
        public let defaultVocabularyList: [DefaultVocabulary]
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(defaultVocabularyList: [DefaultVocabulary], nextToken: String? = nil) {
            self.defaultVocabularyList = defaultVocabularyList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case defaultVocabularyList = "DefaultVocabularyList"
            case nextToken = "NextToken"
        }
    }

    public struct ListHoursOfOperationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListHoursOfOperationsResponse: AWSDecodableShape {
        /// Information about the hours of operation.
        public let hoursOfOperationSummaryList: [HoursOfOperationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(hoursOfOperationSummaryList: [HoursOfOperationSummary]? = nil, nextToken: String? = nil) {
            self.hoursOfOperationSummaryList = hoursOfOperationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationSummaryList = "HoursOfOperationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListInstanceAttributesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 7)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstanceAttributesResponse: AWSDecodableShape {
        /// The attribute types.
        public let attributes: [Attribute]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(attributes: [Attribute]? = nil, nextToken: String? = nil) {
            self.attributes = attributes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case nextToken = "NextToken"
        }
    }

    public struct ListInstanceStorageConfigsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "resourceType", location: .querystring("resourceType"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, resourceType: InstanceStorageResourceType) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceType = resourceType
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstanceStorageConfigsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A valid storage type.
        public let storageConfigs: [InstanceStorageConfig]?

        public init(nextToken: String? = nil, storageConfigs: [InstanceStorageConfig]? = nil) {
            self.nextToken = nextToken
            self.storageConfigs = storageConfigs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case storageConfigs = "StorageConfigs"
        }
    }

    public struct ListInstancesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListInstancesResponse: AWSDecodableShape {
        /// Information about the instances.
        public let instanceSummaryList: [InstanceSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(instanceSummaryList: [InstanceSummary]? = nil, nextToken: String? = nil) {
            self.instanceSummaryList = instanceSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case instanceSummaryList = "InstanceSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListIntegrationAssociationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "integrationType", location: .querystring("integrationType")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The integration type.
        public let integrationType: IntegrationType?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, integrationType: IntegrationType? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.integrationType = integrationType
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIntegrationAssociationsResponse: AWSDecodableShape {
        /// The associations.
        public let integrationAssociationSummaryList: [IntegrationAssociationSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(integrationAssociationSummaryList: [IntegrationAssociationSummary]? = nil, nextToken: String? = nil) {
            self.integrationAssociationSummaryList = integrationAssociationSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case integrationAssociationSummaryList = "IntegrationAssociationSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListLambdaFunctionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLambdaFunctionsResponse: AWSDecodableShape {
        /// The Lambdafunction ARNs associated with the specified instance.
        public let lambdaFunctions: [String]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(lambdaFunctions: [String]? = nil, nextToken: String? = nil) {
            self.lambdaFunctions = lambdaFunctions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaFunctions = "LambdaFunctions"
            case nextToken = "NextToken"
        }
    }

    public struct ListLexBotsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. If no value is specified, the default is 10.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 25)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListLexBotsResponse: AWSDecodableShape {
        /// The names and Amazon Web Services Regions of the Amazon Lex bots associated with the specified instance.
        public let lexBots: [LexBot]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(lexBots: [LexBot]? = nil, nextToken: String? = nil) {
            self.lexBots = lexBots
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case lexBots = "LexBots"
            case nextToken = "NextToken"
        }
    }

    public struct ListPhoneNumbersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "phoneNumberCountryCodes", location: .querystring("phoneNumberCountryCodes")),
            AWSMemberEncoding(label: "phoneNumberTypes", location: .querystring("phoneNumberTypes"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The ISO country code.
        public let phoneNumberCountryCodes: [PhoneNumberCountryCode]?
        /// The type of phone number.
        public let phoneNumberTypes: [PhoneNumberType]?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, phoneNumberCountryCodes: [PhoneNumberCountryCode]? = nil, phoneNumberTypes: [PhoneNumberType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberCountryCodes = phoneNumberCountryCodes
            self.phoneNumberTypes = phoneNumberTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.phoneNumberCountryCodes, name: "phoneNumberCountryCodes", parent: name, max: 10)
            try self.validate(self.phoneNumberTypes, name: "phoneNumberTypes", parent: name, max: 2)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPhoneNumbersResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the phone numbers.
        public let phoneNumberSummaryList: [PhoneNumberSummary]?

        public init(nextToken: String? = nil, phoneNumberSummaryList: [PhoneNumberSummary]? = nil) {
            self.nextToken = nextToken
            self.phoneNumberSummaryList = phoneNumberSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case phoneNumberSummaryList = "PhoneNumberSummaryList"
        }
    }

    public struct ListPhoneNumbersSummary: AWSDecodableShape {
        /// The phone number. Phone numbers are formatted [+] [country code] [subscriber number including area code].
        public let phoneNumber: String?
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.
        public let targetArn: String?

        public init(phoneNumber: String? = nil, phoneNumberArn: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberId: String? = nil, phoneNumberType: PhoneNumberType? = nil, targetArn: String? = nil) {
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberId = phoneNumberId
            self.phoneNumberType = phoneNumberType
            self.targetArn = targetArn
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumber = "PhoneNumber"
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberId = "PhoneNumberId"
            case phoneNumberType = "PhoneNumberType"
            case targetArn = "TargetArn"
        }
    }

    public struct ListPhoneNumbersV2Request: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The ISO country code.
        public let phoneNumberCountryCodes: [PhoneNumberCountryCode]?
        /// The prefix of the phone number. If provided, it must contain + as part of the country code.
        public let phoneNumberPrefix: String?
        /// The type of phone number.
        public let phoneNumberTypes: [PhoneNumberType]?
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to. If TargetArn input is not provided, this API lists numbers claimed to all the Amazon Connect instances belonging to your account in the same Amazon Web Services Region as the request.
        public let targetArn: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, phoneNumberCountryCodes: [PhoneNumberCountryCode]? = nil, phoneNumberPrefix: String? = nil, phoneNumberTypes: [PhoneNumberType]? = nil, targetArn: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberCountryCodes = phoneNumberCountryCodes
            self.phoneNumberPrefix = phoneNumberPrefix
            self.phoneNumberTypes = phoneNumberTypes
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100_000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.phoneNumberCountryCodes, name: "phoneNumberCountryCodes", parent: name, max: 10)
            try self.validate(self.phoneNumberPrefix, name: "phoneNumberPrefix", parent: name, pattern: "^\\\\+?[0-9]{1,11}$")
            try self.validate(self.phoneNumberTypes, name: "phoneNumberTypes", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case phoneNumberCountryCodes = "PhoneNumberCountryCodes"
            case phoneNumberPrefix = "PhoneNumberPrefix"
            case phoneNumberTypes = "PhoneNumberTypes"
            case targetArn = "TargetArn"
        }
    }

    public struct ListPhoneNumbersV2Response: AWSDecodableShape {
        /// Information about phone numbers that have been claimed to your Amazon Connect instances or traffic distribution groups.
        public let listPhoneNumbersSummaryList: [ListPhoneNumbersSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(listPhoneNumbersSummaryList: [ListPhoneNumbersSummary]? = nil, nextToken: String? = nil) {
            self.listPhoneNumbersSummaryList = listPhoneNumbersSummaryList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case listPhoneNumbersSummaryList = "ListPhoneNumbersSummaryList"
            case nextToken = "NextToken"
        }
    }

    public struct ListPromptsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPromptsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the prompts.
        public let promptSummaryList: [PromptSummary]?

        public init(nextToken: String? = nil, promptSummaryList: [PromptSummary]? = nil) {
            self.nextToken = nextToken
            self.promptSummaryList = promptSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case promptSummaryList = "PromptSummaryList"
        }
    }

    public struct ListQueueQuickConnectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier for the queue.
        public let queueId: String

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, queueId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueueQuickConnectsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the quick connects.
        public let quickConnectSummaryList: [QuickConnectSummary]?

        public init(nextToken: String? = nil, quickConnectSummaryList: [QuickConnectSummary]? = nil) {
            self.nextToken = nextToken
            self.quickConnectSummaryList = quickConnectSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case quickConnectSummaryList = "QuickConnectSummaryList"
        }
    }

    public struct ListQueuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "queueTypes", location: .querystring("queueTypes"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of queue.
        public let queueTypes: [QueueType]?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, queueTypes: [QueueType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queueTypes = queueTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.queueTypes, name: "queueTypes", parent: name, max: 2)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQueuesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the queues.
        public let queueSummaryList: [QueueSummary]?

        public init(nextToken: String? = nil, queueSummaryList: [QueueSummary]? = nil) {
            self.nextToken = nextToken
            self.queueSummaryList = queueSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case queueSummaryList = "QueueSummaryList"
        }
    }

    public struct ListQuickConnectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "quickConnectTypes", location: .querystring("QuickConnectTypes"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public let quickConnectTypes: [QuickConnectType]?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, quickConnectTypes: [QuickConnectType]? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.quickConnectTypes = quickConnectTypes
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.quickConnectTypes, name: "quickConnectTypes", parent: name, max: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListQuickConnectsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the quick connects.
        public let quickConnectSummaryList: [QuickConnectSummary]?

        public init(nextToken: String? = nil, quickConnectSummaryList: [QuickConnectSummary]? = nil) {
            self.nextToken = nextToken
            self.quickConnectSummaryList = quickConnectSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case quickConnectSummaryList = "QuickConnectSummaryList"
        }
    }

    public struct ListRoutingProfileQueuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, routingProfileId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutingProfileQueuesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the routing profiles.
        public let routingProfileQueueConfigSummaryList: [RoutingProfileQueueConfigSummary]?

        public init(nextToken: String? = nil, routingProfileQueueConfigSummaryList: [RoutingProfileQueueConfigSummary]? = nil) {
            self.nextToken = nextToken
            self.routingProfileQueueConfigSummaryList = routingProfileQueueConfigSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case routingProfileQueueConfigSummaryList = "RoutingProfileQueueConfigSummaryList"
        }
    }

    public struct ListRoutingProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRoutingProfilesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the routing profiles.
        public let routingProfileSummaryList: [RoutingProfileSummary]?

        public init(nextToken: String? = nil, routingProfileSummaryList: [RoutingProfileSummary]? = nil) {
            self.nextToken = nextToken
            self.routingProfileSummaryList = routingProfileSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case routingProfileSummaryList = "RoutingProfileSummaryList"
        }
    }

    public struct ListRulesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "eventSourceName", location: .querystring("eventSourceName")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "publishStatus", location: .querystring("publishStatus"))
        ]

        /// The name of the event source.
        public let eventSourceName: EventSourceName?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus?

        public init(eventSourceName: EventSourceName? = nil, instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, publishStatus: RulePublishStatus? = nil) {
            self.eventSourceName = eventSourceName
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.publishStatus = publishStatus
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 200)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRulesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Summary information about a rule.
        public let ruleSummaryList: [RuleSummary]

        public init(nextToken: String? = nil, ruleSummaryList: [RuleSummary]) {
            self.nextToken = nextToken
            self.ruleSummaryList = ruleSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case ruleSummaryList = "RuleSummaryList"
        }
    }

    public struct ListSecurityKeysRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 2)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityKeysResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The security keys.
        public let securityKeys: [SecurityKey]?

        public init(nextToken: String? = nil, securityKeys: [SecurityKey]? = nil) {
            self.nextToken = nextToken
            self.securityKeys = securityKeys
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityKeys = "SecurityKeys"
        }
    }

    public struct ListSecurityProfilePermissionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "securityProfileId", location: .uri("SecurityProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The identifier for the security profle.
        public let securityProfileId: String

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, securityProfileId: String) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.securityProfileId = securityProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityProfilePermissionsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The permissions granted to the security profile. For a complete list of valid permissions, see List of security profile permissions.
        public let permissions: [String]?

        public init(nextToken: String? = nil, permissions: [String]? = nil) {
            self.nextToken = nextToken
            self.permissions = permissions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case permissions = "Permissions"
        }
    }

    public struct ListSecurityProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSecurityProfilesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the security profiles.
        public let securityProfileSummaryList: [SecurityProfileSummary]?

        public init(nextToken: String? = nil, securityProfileSummaryList: [SecurityProfileSummary]? = nil) {
            self.nextToken = nextToken
            self.securityProfileSummaryList = securityProfileSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case securityProfileSummaryList = "SecurityProfileSummaryList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct ListTaskTemplatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "name", location: .querystring("name")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "status", location: .querystring("status"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.  It is not expected that you set this.
        public let maxResults: Int?
        /// The name of the task template.
        public let name: String?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.  It is not expected that you set this because the value returned in the previous response is always null.
        public let nextToken: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        public init(instanceId: String, maxResults: Int? = nil, name: String? = nil, nextToken: String? = nil, status: TaskTemplateStatus? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.name = name
            self.nextToken = nextToken
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTaskTemplatesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.  This is always returned as a null in the response.
        public let nextToken: String?
        /// Provides details about a list of task templates belonging to an instance.
        public let taskTemplates: [TaskTemplateMetadata]?

        public init(nextToken: String? = nil, taskTemplates: [TaskTemplateMetadata]? = nil) {
            self.nextToken = nextToken
            self.taskTemplates = taskTemplates
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case taskTemplates = "TaskTemplates"
        }
    }

    public struct ListTrafficDistributionGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .querystring("instanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTrafficDistributionGroupsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// A list of traffic distribution groups.
        public let trafficDistributionGroupSummaryList: [TrafficDistributionGroupSummary]?

        public init(nextToken: String? = nil, trafficDistributionGroupSummaryList: [TrafficDistributionGroupSummary]? = nil) {
            self.nextToken = nextToken
            self.trafficDistributionGroupSummaryList = trafficDistributionGroupSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case trafficDistributionGroupSummaryList = "TrafficDistributionGroupSummaryList"
        }
    }

    public struct ListUseCasesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "integrationAssociationId", location: .uri("IntegrationAssociationId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the integration association.
        public let integrationAssociationId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, integrationAssociationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.integrationAssociationId = integrationAssociationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUseCasesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The use cases.
        public let useCaseSummaryList: [UseCase]?

        public init(nextToken: String? = nil, useCaseSummaryList: [UseCase]? = nil) {
            self.nextToken = nextToken
            self.useCaseSummaryList = useCaseSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case useCaseSummaryList = "UseCaseSummaryList"
        }
    }

    public struct ListUserHierarchyGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUserHierarchyGroupsResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the hierarchy groups.
        public let userHierarchyGroupSummaryList: [HierarchyGroupSummary]?

        public init(nextToken: String? = nil, userHierarchyGroupSummaryList: [HierarchyGroupSummary]? = nil) {
            self.nextToken = nextToken
            self.userHierarchyGroupSummaryList = userHierarchyGroupSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userHierarchyGroupSummaryList = "UserHierarchyGroupSummaryList"
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page. The default MaxResult size is 100.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the users.
        public let userSummaryList: [UserSummary]?

        public init(nextToken: String? = nil, userSummaryList: [UserSummary]? = nil) {
            self.nextToken = nextToken
            self.userSummaryList = userSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case userSummaryList = "UserSummaryList"
        }
    }

    public struct MediaConcurrency: AWSEncodableShape & AWSDecodableShape {
        /// The channels that agents can handle in the Contact Control Panel (CCP).
        public let channel: Channel
        /// The number of contacts an agent can have on a channel simultaneously. Valid Range for VOICE: Minimum value of 1. Maximum value of 1. Valid Range for CHAT: Minimum value of 1. Maximum value of 10. Valid Range for TASK: Minimum value of 1. Maximum value of 10.
        public let concurrency: Int

        public init(channel: Channel, concurrency: Int) {
            self.channel = channel
            self.concurrency = concurrency
        }

        public func validate(name: String) throws {
            try self.validate(self.concurrency, name: "concurrency", parent: name, max: 10)
            try self.validate(self.concurrency, name: "concurrency", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case concurrency = "Concurrency"
        }
    }

    public struct MonitorContactRequest: AWSEncodableShape {
        /// Specify which monitoring actions the user is allowed to take. For example, whether the user is allowed to escalate from silent monitoring to barge.
        public let allowedMonitorCapabilities: [MonitorCapability]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(allowedMonitorCapabilities: [MonitorCapability]? = nil, clientToken: String? = MonitorContactRequest.idempotencyToken(), contactId: String, instanceId: String, userId: String) {
            self.allowedMonitorCapabilities = allowedMonitorCapabilities
            self.clientToken = clientToken
            self.contactId = contactId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.allowedMonitorCapabilities, name: "allowedMonitorCapabilities", parent: name, max: 2)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedMonitorCapabilities = "AllowedMonitorCapabilities"
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case userId = "UserId"
        }
    }

    public struct MonitorContactResponse: AWSDecodableShape {
        /// The ARN of the contact.
        public let contactArn: String?
        /// The identifier of the contact.
        public let contactId: String?

        public init(contactArn: String? = nil, contactId: String? = nil) {
            self.contactArn = contactArn
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case contactId = "ContactId"
        }
    }

    public struct NotificationRecipientType: AWSEncodableShape & AWSDecodableShape {
        /// A list of user IDs.
        public let userIds: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect users with the specified tags will be notified.
        public let userTags: [String: String]?

        public init(userIds: [String]? = nil, userTags: [String: String]? = nil) {
            self.userIds = userIds
            self.userTags = userTags
        }

        private enum CodingKeys: String, CodingKey {
            case userIds = "UserIds"
            case userTags = "UserTags"
        }
    }

    public struct NumberReference: AWSDecodableShape {
        /// Identifier of the number reference.
        public let name: String?
        /// A valid number.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct OutboundCallerConfig: AWSEncodableShape & AWSDecodableShape {
        /// The caller ID name.
        public let outboundCallerIdName: String?
        /// The caller ID number.
        public let outboundCallerIdNumberId: String?
        /// The outbound whisper flow to be used during an outbound call.
        public let outboundFlowId: String?

        public init(outboundCallerIdName: String? = nil, outboundCallerIdNumberId: String? = nil, outboundFlowId: String? = nil) {
            self.outboundCallerIdName = outboundCallerIdName
            self.outboundCallerIdNumberId = outboundCallerIdNumberId
            self.outboundFlowId = outboundFlowId
        }

        public func validate(name: String) throws {
            try self.validate(self.outboundCallerIdName, name: "outboundCallerIdName", parent: name, max: 255)
            try self.validate(self.outboundCallerIdName, name: "outboundCallerIdName", parent: name, min: 1)
            try self.validate(self.outboundFlowId, name: "outboundFlowId", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case outboundCallerIdName = "OutboundCallerIdName"
            case outboundCallerIdNumberId = "OutboundCallerIdNumberId"
            case outboundFlowId = "OutboundFlowId"
        }
    }

    public struct ParticipantDetails: AWSEncodableShape {
        /// Display name of the participant.
        public let displayName: String

        public init(displayName: String) {
            self.displayName = displayName
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 256)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
        }
    }

    public struct ParticipantTimerConfiguration: AWSEncodableShape {
        /// The role of the participant in the chat conversation.
        public let participantRole: TimerEligibleParticipantRoles
        /// The type of timer. IDLE indicates the timer applies for considering a human chat participant as idle.  DISCONNECT_NONCUSTOMER indicates the timer applies to automatically disconnecting a chat participant due to idleness.
        public let timerType: ParticipantTimerType
        /// The value of the timer. Either the timer action (Unset to delete the timer), or the duration of the timer in minutes. Only one value can be set.
        public let timerValue: ParticipantTimerValue

        public init(participantRole: TimerEligibleParticipantRoles, timerType: ParticipantTimerType, timerValue: ParticipantTimerValue) {
            self.participantRole = participantRole
            self.timerType = timerType
            self.timerValue = timerValue
        }

        public func validate(name: String) throws {
            try self.timerValue.validate(name: "\(name).timerValue")
        }

        private enum CodingKeys: String, CodingKey {
            case participantRole = "ParticipantRole"
            case timerType = "TimerType"
            case timerValue = "TimerValue"
        }
    }

    public struct PhoneNumberQuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The phone number in E.164 format.
        public let phoneNumber: String

        public init(phoneNumber: String) {
            self.phoneNumber = phoneNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumber = "PhoneNumber"
        }
    }

    public struct PhoneNumberStatus: AWSDecodableShape {
        /// The status message.
        public let message: String?
        /// The status.
        public let status: PhoneNumberWorkflowStatus?

        public init(message: String? = nil, status: PhoneNumberWorkflowStatus? = nil) {
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case status = "Status"
        }
    }

    public struct PhoneNumberSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the phone number.
        public let arn: String?
        /// The identifier of the phone number.
        public let id: String?
        /// The phone number.
        public let phoneNumber: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType?

        public init(arn: String? = nil, id: String? = nil, phoneNumber: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode? = nil, phoneNumberType: PhoneNumberType? = nil) {
            self.arn = arn
            self.id = id
            self.phoneNumber = phoneNumber
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberType = phoneNumberType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case phoneNumber = "PhoneNumber"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberType = "PhoneNumberType"
        }
    }

    public struct PromptSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the prompt.
        public let arn: String?
        /// The identifier of the prompt.
        public let id: String?
        /// The name of the prompt.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct PutUserStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the agent status.
        public let agentStatusId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user.
        public let userId: String

        public init(agentStatusId: String, instanceId: String, userId: String) {
            self.agentStatusId = agentStatusId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agentStatusId = "AgentStatusId"
        }
    }

    public struct PutUserStatusResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Queue: AWSDecodableShape {
        /// The description of the queue.
        public let description: String?
        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String?
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public let maxContacts: Int?
        /// The name of the queue.
        public let name: String?
        /// The outbound caller ID name, number, and outbound whisper flow.
        public let outboundCallerConfig: OutboundCallerConfig?
        /// The Amazon Resource Name (ARN) for the queue.
        public let queueArn: String?
        /// The identifier for the queue.
        public let queueId: String?
        /// The status of the queue.
        public let status: QueueStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(description: String? = nil, hoursOfOperationId: String? = nil, maxContacts: Int? = nil, name: String? = nil, outboundCallerConfig: OutboundCallerConfig? = nil, queueArn: String? = nil, queueId: String? = nil, status: QueueStatus? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.maxContacts = maxContacts
            self.name = name
            self.outboundCallerConfig = outboundCallerConfig
            self.queueArn = queueArn
            self.queueId = queueId
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case hoursOfOperationId = "HoursOfOperationId"
            case maxContacts = "MaxContacts"
            case name = "Name"
            case outboundCallerConfig = "OutboundCallerConfig"
            case queueArn = "QueueArn"
            case queueId = "QueueId"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct QueueInfo: AWSDecodableShape {
        /// The timestamp when the contact was added to the queue.
        public let enqueueTimestamp: Date?
        /// The unique identifier for the queue.
        public let id: String?

        public init(enqueueTimestamp: Date? = nil, id: String? = nil) {
            self.enqueueTimestamp = enqueueTimestamp
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case enqueueTimestamp = "EnqueueTimestamp"
            case id = "Id"
        }
    }

    public struct QueueQuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier for the queue.
        public let queueId: String

        public init(contactFlowId: String, queueId: String) {
            self.contactFlowId = contactFlowId
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case queueId = "QueueId"
        }
    }

    public struct QueueReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the queue.
        public let arn: String?
        /// The identifier of the queue.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct QueueSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [QueueSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [QueueSearchCriteria]?
        /// The type of queue.
        public let queueTypeCondition: SearchableQueueType?
        public let stringCondition: StringCondition?

        public init(andConditions: [QueueSearchCriteria]? = nil, orConditions: [QueueSearchCriteria]? = nil, queueTypeCondition: SearchableQueueType? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.queueTypeCondition = queueTypeCondition
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case queueTypeCondition = "QueueTypeCondition"
            case stringCondition = "StringCondition"
        }
    }

    public struct QueueSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct QueueSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the queue.
        public let arn: String?
        /// The identifier of the queue.
        public let id: String?
        /// The name of the queue.
        public let name: String?
        /// The type of queue.
        public let queueType: QueueType?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, queueType: QueueType? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.queueType = queueType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case queueType = "QueueType"
        }
    }

    public struct QuickConnect: AWSDecodableShape {
        /// The description.
        public let description: String?
        /// The name of the quick connect.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the quick connect.
        public let quickConnectARN: String?
        /// Contains information about the quick connect.
        public let quickConnectConfig: QuickConnectConfig?
        /// The identifier for the quick connect.
        public let quickConnectId: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String? = nil, quickConnectARN: String? = nil, quickConnectConfig: QuickConnectConfig? = nil, quickConnectId: String? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.quickConnectARN = quickConnectARN
            self.quickConnectConfig = quickConnectConfig
            self.quickConnectId = quickConnectId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case quickConnectARN = "QuickConnectARN"
            case quickConnectConfig = "QuickConnectConfig"
            case quickConnectId = "QuickConnectId"
            case tags = "Tags"
        }
    }

    public struct QuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The phone configuration. This is required only if QuickConnectType is PHONE_NUMBER.
        public let phoneConfig: PhoneNumberQuickConnectConfig?
        /// The queue configuration. This is required only if QuickConnectType is QUEUE.
        public let queueConfig: QueueQuickConnectConfig?
        /// The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public let quickConnectType: QuickConnectType
        /// The user configuration. This is required only if QuickConnectType is USER.
        public let userConfig: UserQuickConnectConfig?

        public init(phoneConfig: PhoneNumberQuickConnectConfig? = nil, queueConfig: QueueQuickConnectConfig? = nil, quickConnectType: QuickConnectType, userConfig: UserQuickConnectConfig? = nil) {
            self.phoneConfig = phoneConfig
            self.queueConfig = queueConfig
            self.quickConnectType = quickConnectType
            self.userConfig = userConfig
        }

        public func validate(name: String) throws {
            try self.phoneConfig?.validate(name: "\(name).phoneConfig")
            try self.queueConfig?.validate(name: "\(name).queueConfig")
            try self.userConfig?.validate(name: "\(name).userConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneConfig = "PhoneConfig"
            case queueConfig = "QueueConfig"
            case quickConnectType = "QuickConnectType"
            case userConfig = "UserConfig"
        }
    }

    public struct QuickConnectSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the quick connect.
        public let arn: String?
        /// The identifier for the quick connect.
        public let id: String?
        /// The name of the quick connect.
        public let name: String?
        /// The type of quick connect. In the Amazon Connect console, when you create a quick connect, you are prompted to assign one of the following types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
        public let quickConnectType: QuickConnectType?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, quickConnectType: QuickConnectType? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.quickConnectType = quickConnectType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
            case quickConnectType = "QuickConnectType"
        }
    }

    public struct ReadOnlyFieldInfo: AWSEncodableShape & AWSDecodableShape {
        /// Identifier of the read-only field.
        public let id: TaskTemplateFieldIdentifier?

        public init(id: TaskTemplateFieldIdentifier? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct Reference: AWSEncodableShape & AWSDecodableShape {
        /// The type of the reference. DATE must be of type Epoch timestamp.
        public let type: ReferenceType
        /// A valid value for the reference. For example, for a URL reference, a formatted URL that is displayed to an agent in the Contact Control Panel (CCP).
        public let value: String

        public init(type: ReferenceType, value: String) {
            self.type = type
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.value, name: "value", parent: name, max: 4096)
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case value = "Value"
        }
    }

    public struct ReleasePhoneNumberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "phoneNumberId", location: .uri("PhoneNumberId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String

        public init(clientToken: String? = ReleasePhoneNumberRequest.idempotencyToken(), phoneNumberId: String) {
            self.clientToken = clientToken
            self.phoneNumberId = phoneNumberId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ReplicateInstanceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance. You can provide the InstanceId, or the entire ARN.
        public let instanceId: String
        /// The alias for the replicated instance. The ReplicaAlias must be unique.
        public let replicaAlias: String
        /// The Amazon Web Services Region where to replicate the Amazon Connect instance.
        public let replicaRegion: String

        public init(clientToken: String? = ReplicateInstanceRequest.idempotencyToken(), instanceId: String, replicaAlias: String, replicaRegion: String) {
            self.clientToken = clientToken
            self.instanceId = instanceId
            self.replicaAlias = replicaAlias
            self.replicaRegion = replicaRegion
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z]+-[0-9]{1}:[0-9]{1,20}:instance/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.replicaAlias, name: "replicaAlias", parent: name, max: 62)
            try self.validate(self.replicaAlias, name: "replicaAlias", parent: name, min: 1)
            try self.validate(self.replicaAlias, name: "replicaAlias", parent: name, pattern: "^(?!d-)([\\da-zA-Z]+)([-]*[\\da-zA-Z])*$")
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, max: 31)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, min: 8)
            try self.validate(self.replicaRegion, name: "replicaRegion", parent: name, pattern: "^[a-z]{2}(-[a-z]+){1,2}(-[0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case replicaAlias = "ReplicaAlias"
            case replicaRegion = "ReplicaRegion"
        }
    }

    public struct ReplicateInstanceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the replicated instance.
        public let arn: String?
        /// The identifier of the replicated instance. You can find the instanceId in the ARN of the instance. The replicated instance has the same identifier as the instance it was replicated from.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct RequiredFieldInfo: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier for the field.
        public let id: TaskTemplateFieldIdentifier?

        public init(id: TaskTemplateFieldIdentifier? = nil) {
            self.id = id
        }

        public func validate(name: String) throws {
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
        }
    }

    public struct ResumeContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactId: String, initialContactId: String, instanceId: String) {
            self.contactId = contactId
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct ResumeContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RoutingProfile: AWSDecodableShape {
        /// The identifier of the default outbound queue for this routing profile.
        public let defaultOutboundQueueId: String?
        /// The description of the routing profile.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public let mediaConcurrencies: [MediaConcurrency]?
        /// The name of the routing profile.
        public let name: String?
        /// The number of associated queues in routing profile.
        public let numberOfAssociatedQueues: Int64?
        /// The number of associated users in routing profile.
        public let numberOfAssociatedUsers: Int64?
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let routingProfileArn: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(defaultOutboundQueueId: String? = nil, description: String? = nil, instanceId: String? = nil, mediaConcurrencies: [MediaConcurrency]? = nil, name: String? = nil, numberOfAssociatedQueues: Int64? = nil, numberOfAssociatedUsers: Int64? = nil, routingProfileArn: String? = nil, routingProfileId: String? = nil, tags: [String: String]? = nil) {
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.description = description
            self.instanceId = instanceId
            self.mediaConcurrencies = mediaConcurrencies
            self.name = name
            self.numberOfAssociatedQueues = numberOfAssociatedQueues
            self.numberOfAssociatedUsers = numberOfAssociatedUsers
            self.routingProfileArn = routingProfileArn
            self.routingProfileId = routingProfileId
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case defaultOutboundQueueId = "DefaultOutboundQueueId"
            case description = "Description"
            case instanceId = "InstanceId"
            case mediaConcurrencies = "MediaConcurrencies"
            case name = "Name"
            case numberOfAssociatedQueues = "NumberOfAssociatedQueues"
            case numberOfAssociatedUsers = "NumberOfAssociatedUsers"
            case routingProfileArn = "RoutingProfileArn"
            case routingProfileId = "RoutingProfileId"
            case tags = "Tags"
        }
    }

    public struct RoutingProfileQueueConfig: AWSEncodableShape {
        /// The delay, in seconds, a contact should be in the queue before they are routed to an available agent. For more information, see Queues: priority and delay in the Amazon Connect Administrator Guide.
        public let delay: Int
        /// The order in which contacts are to be handled for the queue. For more information, see Queues: priority and delay.
        public let priority: Int
        /// Contains information about a queue resource.
        public let queueReference: RoutingProfileQueueReference

        public init(delay: Int, priority: Int, queueReference: RoutingProfileQueueReference) {
            self.delay = delay
            self.priority = priority
            self.queueReference = queueReference
        }

        public func validate(name: String) throws {
            try self.validate(self.delay, name: "delay", parent: name, max: 9999)
            try self.validate(self.delay, name: "delay", parent: name, min: 0)
            try self.validate(self.priority, name: "priority", parent: name, max: 99)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case delay = "Delay"
            case priority = "Priority"
            case queueReference = "QueueReference"
        }
    }

    public struct RoutingProfileQueueConfigSummary: AWSDecodableShape {
        /// The channels this queue supports.
        public let channel: Channel
        /// The delay, in seconds, that a contact should be in the queue before they are routed to an available agent. For more information, see Queues: priority and delay in the Amazon Connect Administrator Guide.
        public let delay: Int
        /// The order in which contacts are to be handled for the queue. For more information, see Queues: priority and delay.
        public let priority: Int
        /// The Amazon Resource Name (ARN) of the queue.
        public let queueArn: String
        /// The identifier for the queue.
        public let queueId: String
        /// The name of the queue.
        public let queueName: String

        public init(channel: Channel, delay: Int, priority: Int, queueArn: String, queueId: String, queueName: String) {
            self.channel = channel
            self.delay = delay
            self.priority = priority
            self.queueArn = queueArn
            self.queueId = queueId
            self.queueName = queueName
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case delay = "Delay"
            case priority = "Priority"
            case queueArn = "QueueArn"
            case queueId = "QueueId"
            case queueName = "QueueName"
        }
    }

    public struct RoutingProfileQueueReference: AWSEncodableShape {
        /// The channels agents can handle in the Contact Control Panel (CCP) for this routing profile.
        public let channel: Channel
        /// The identifier for the queue.
        public let queueId: String

        public init(channel: Channel, queueId: String) {
            self.channel = channel
            self.queueId = queueId
        }

        private enum CodingKeys: String, CodingKey {
            case channel = "Channel"
            case queueId = "QueueId"
        }
    }

    public struct RoutingProfileReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let arn: String?
        /// The identifier of the routing profile.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct RoutingProfileSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [RoutingProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [RoutingProfileSearchCriteria]?
        public let stringCondition: StringCondition?

        public init(andConditions: [RoutingProfileSearchCriteria]? = nil, orConditions: [RoutingProfileSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct RoutingProfileSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct RoutingProfileSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the routing profile.
        public let arn: String?
        /// The identifier of the routing profile.
        public let id: String?
        /// The name of the routing profile.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct Rule: AWSDecodableShape {
        /// A list of actions to be run when the rule is triggered.
        public let actions: [RuleAction]
        /// The timestamp for when the rule was created.
        public let createdTime: Date
        /// The conditions of the rule.
        public let function: String
        /// The Amazon Resource Name (ARN) of the user who last updated the rule.
        public let lastUpdatedBy: String
        /// The timestamp for the when the rule was last updated.
        public let lastUpdatedTime: Date
        /// The name of the rule.
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// The Amazon Resource Name (ARN) of the rule.
        public let ruleArn: String
        /// A unique identifier for the rule.
        public let ruleId: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The event source to trigger the rule.
        public let triggerEventSource: RuleTriggerEventSource

        public init(actions: [RuleAction], createdTime: Date, function: String, lastUpdatedBy: String, lastUpdatedTime: Date, name: String, publishStatus: RulePublishStatus, ruleArn: String, ruleId: String, tags: [String: String]? = nil, triggerEventSource: RuleTriggerEventSource) {
            self.actions = actions
            self.createdTime = createdTime
            self.function = function
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
            self.tags = tags
            self.triggerEventSource = triggerEventSource
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case createdTime = "CreatedTime"
            case function = "Function"
            case lastUpdatedBy = "LastUpdatedBy"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case publishStatus = "PublishStatus"
            case ruleArn = "RuleArn"
            case ruleId = "RuleId"
            case tags = "Tags"
            case triggerEventSource = "TriggerEventSource"
        }
    }

    public struct RuleAction: AWSEncodableShape & AWSDecodableShape {
        /// The type of action that creates a rule.
        public let actionType: ActionType
        /// Information about the contact category action.
        public let assignContactCategoryAction: AssignContactCategoryActionDefinition?
        /// Information about the EventBridge action.
        public let eventBridgeAction: EventBridgeActionDefinition?
        /// Information about the send notification action.
        public let sendNotificationAction: SendNotificationActionDefinition?
        /// Information about the task action. This field is required if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public let taskAction: TaskActionDefinition?

        public init(actionType: ActionType, assignContactCategoryAction: AssignContactCategoryActionDefinition? = nil, eventBridgeAction: EventBridgeActionDefinition? = nil, sendNotificationAction: SendNotificationActionDefinition? = nil, taskAction: TaskActionDefinition? = nil) {
            self.actionType = actionType
            self.assignContactCategoryAction = assignContactCategoryAction
            self.eventBridgeAction = eventBridgeAction
            self.sendNotificationAction = sendNotificationAction
            self.taskAction = taskAction
        }

        public func validate(name: String) throws {
            try self.eventBridgeAction?.validate(name: "\(name).eventBridgeAction")
            try self.sendNotificationAction?.validate(name: "\(name).sendNotificationAction")
            try self.taskAction?.validate(name: "\(name).taskAction")
        }

        private enum CodingKeys: String, CodingKey {
            case actionType = "ActionType"
            case assignContactCategoryAction = "AssignContactCategoryAction"
            case eventBridgeAction = "EventBridgeAction"
            case sendNotificationAction = "SendNotificationAction"
            case taskAction = "TaskAction"
        }
    }

    public struct RuleSummary: AWSDecodableShape {
        /// A list of ActionTypes associated with a rule.
        public let actionSummaries: [ActionSummary]
        /// The timestamp for when the rule was created.
        public let createdTime: Date
        /// The name of the event source.
        public let eventSourceName: EventSourceName
        /// The timestamp for when the rule was last updated.
        public let lastUpdatedTime: Date
        /// The name of the rule.
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// The Amazon Resource Name (ARN) of the rule.
        public let ruleArn: String
        /// A unique identifier for the rule.
        public let ruleId: String

        public init(actionSummaries: [ActionSummary], createdTime: Date, eventSourceName: EventSourceName, lastUpdatedTime: Date, name: String, publishStatus: RulePublishStatus, ruleArn: String, ruleId: String) {
            self.actionSummaries = actionSummaries
            self.createdTime = createdTime
            self.eventSourceName = eventSourceName
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.publishStatus = publishStatus
            self.ruleArn = ruleArn
            self.ruleId = ruleId
        }

        private enum CodingKeys: String, CodingKey {
            case actionSummaries = "ActionSummaries"
            case createdTime = "CreatedTime"
            case eventSourceName = "EventSourceName"
            case lastUpdatedTime = "LastUpdatedTime"
            case name = "Name"
            case publishStatus = "PublishStatus"
            case ruleArn = "RuleArn"
            case ruleId = "RuleId"
        }
    }

    public struct RuleTriggerEventSource: AWSEncodableShape & AWSDecodableShape {
        /// The name of the event source.
        public let eventSourceName: EventSourceName
        /// The identifier for the integration association.
        public let integrationAssociationId: String?

        public init(eventSourceName: EventSourceName, integrationAssociationId: String? = nil) {
            self.eventSourceName = eventSourceName
            self.integrationAssociationId = integrationAssociationId
        }

        public func validate(name: String) throws {
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, max: 200)
            try self.validate(self.integrationAssociationId, name: "integrationAssociationId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventSourceName = "EventSourceName"
            case integrationAssociationId = "IntegrationAssociationId"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The S3 bucket name.
        public let bucketName: String
        /// The S3 bucket prefix.
        public let bucketPrefix: String
        /// The Amazon S3 encryption configuration.
        public let encryptionConfig: EncryptionConfig?

        public init(bucketName: String, bucketPrefix: String, encryptionConfig: EncryptionConfig? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.encryptionConfig = encryptionConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 128)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 1)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 128)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, min: 1)
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case bucketPrefix = "BucketPrefix"
            case encryptionConfig = "EncryptionConfig"
        }
    }

    public struct SearchAvailablePhoneNumbersRequest: AWSEncodableShape {
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The ISO country code.
        public let phoneNumberCountryCode: PhoneNumberCountryCode
        /// The prefix of the phone number. If provided, it must contain + as part of the country code.
        public let phoneNumberPrefix: String?
        /// The type of phone number.
        public let phoneNumberType: PhoneNumberType
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.
        public let targetArn: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, phoneNumberCountryCode: PhoneNumberCountryCode, phoneNumberPrefix: String? = nil, phoneNumberType: PhoneNumberType, targetArn: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.phoneNumberCountryCode = phoneNumberCountryCode
            self.phoneNumberPrefix = phoneNumberPrefix
            self.phoneNumberType = phoneNumberType
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 100_000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.phoneNumberPrefix, name: "phoneNumberPrefix", parent: name, pattern: "^\\\\+?[0-9]{1,11}$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case phoneNumberCountryCode = "PhoneNumberCountryCode"
            case phoneNumberPrefix = "PhoneNumberPrefix"
            case phoneNumberType = "PhoneNumberType"
            case targetArn = "TargetArn"
        }
    }

    public struct SearchAvailablePhoneNumbersResponse: AWSDecodableShape {
        /// A list of available phone numbers that you can claim to your Amazon Connect instance or traffic distribution group.
        public let availableNumbersList: [AvailableNumberSummary]?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?

        public init(availableNumbersList: [AvailableNumberSummary]? = nil, nextToken: String? = nil) {
            self.availableNumbersList = availableNumbersList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case availableNumbersList = "AvailableNumbersList"
            case nextToken = "NextToken"
        }
    }

    public struct SearchQueuesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return queues.  The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
        public let searchCriteria: QueueSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: QueueSearchFilter?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: QueueSearchCriteria? = nil, searchFilter: QueueSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchQueuesResponse: AWSDecodableShape {
        /// The total number of queues which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the queues.
        public let queues: [Queue]?

        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, queues: [Queue]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.queues = queues
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case queues = "Queues"
        }
    }

    public struct SearchRoutingProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return routing profiles.  The name and description fields support "contains" queries with a minimum of 2 characters and a maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.
        public let searchCriteria: RoutingProfileSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: RoutingProfileSearchFilter?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: RoutingProfileSearchCriteria? = nil, searchFilter: RoutingProfileSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchRoutingProfilesResponse: AWSDecodableShape {
        /// The total number of routing profiles which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the routing profiles.
        public let routingProfiles: [RoutingProfile]?

        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, routingProfiles: [RoutingProfile]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.routingProfiles = routingProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case routingProfiles = "RoutingProfiles"
        }
    }

    public struct SearchSecurityProfilesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The search criteria to be used to return security profiles.   The name field support "contains" queries with a minimum of 2 characters and maximum of 25 characters. Any queries with character lengths outside of this range will throw invalid results.   The currently supported value for FieldName: name
        public let searchCriteria: SecurityProfileSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: SecurityProfilesSearchFilter?

        public init(instanceId: String, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: SecurityProfileSearchCriteria? = nil, searchFilter: SecurityProfilesSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchSecurityProfilesResponse: AWSDecodableShape {
        /// The total number of security profiles which matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the security profiles.
        public let securityProfiles: [SecurityProfileSearchSummary]?

        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, securityProfiles: [SecurityProfileSearchSummary]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.securityProfiles = securityProfiles
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case securityProfiles = "SecurityProfiles"
        }
    }

    public struct SearchUsersRequest: AWSEncodableShape {
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        public let searchCriteria: UserSearchCriteria?
        /// Filters to be applied to search results.
        public let searchFilter: UserSearchFilter?

        public init(instanceId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, searchCriteria: UserSearchCriteria? = nil, searchFilter: UserSearchFilter? = nil) {
            self.instanceId = instanceId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchCriteria = searchCriteria
            self.searchFilter = searchFilter
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case instanceId = "InstanceId"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case searchCriteria = "SearchCriteria"
            case searchFilter = "SearchFilter"
        }
    }

    public struct SearchUsersResponse: AWSDecodableShape {
        /// The total number of users who matched your search query.
        public let approximateTotalCount: Int64?
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// Information about the users.
        public let users: [UserSearchSummary]?

        public init(approximateTotalCount: Int64? = nil, nextToken: String? = nil, users: [UserSearchSummary]? = nil) {
            self.approximateTotalCount = approximateTotalCount
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case approximateTotalCount = "ApproximateTotalCount"
            case nextToken = "NextToken"
            case users = "Users"
        }
    }

    public struct SearchVocabulariesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode?
        /// The maximum number of results to return per page.
        public let maxResults: Int?
        /// The starting pattern of the name of the vocabulary.
        public let nameStartsWith: String?
        /// The token for the next set of results. Use the value returned in the previous
        /// response in the next request to retrieve the next set of results.
        public let nextToken: String?
        /// The current state of the custom vocabulary.
        public let state: VocabularyState?

        public init(instanceId: String, languageCode: VocabularyLanguageCode? = nil, maxResults: Int? = nil, nameStartsWith: String? = nil, nextToken: String? = nil, state: VocabularyState? = nil) {
            self.instanceId = instanceId
            self.languageCode = languageCode
            self.maxResults = maxResults
            self.nameStartsWith = nameStartsWith
            self.nextToken = nextToken
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nameStartsWith, name: "nameStartsWith", parent: name, max: 140)
            try self.validate(self.nameStartsWith, name: "nameStartsWith", parent: name, min: 1)
            try self.validate(self.nameStartsWith, name: "nameStartsWith", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 131_070)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case languageCode = "LanguageCode"
            case maxResults = "MaxResults"
            case nameStartsWith = "NameStartsWith"
            case nextToken = "NextToken"
            case state = "State"
        }
    }

    public struct SearchVocabulariesResponse: AWSDecodableShape {
        /// If there are additional results, this is the token for the next set of results.
        public let nextToken: String?
        /// The list of the available custom vocabularies.
        public let vocabularySummaryList: [VocabularySummary]?

        public init(nextToken: String? = nil, vocabularySummaryList: [VocabularySummary]? = nil) {
            self.nextToken = nextToken
            self.vocabularySummaryList = vocabularySummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case vocabularySummaryList = "VocabularySummaryList"
        }
    }

    public struct SecurityKey: AWSDecodableShape {
        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String?
        /// When the security key was created.
        public let creationTime: Date?
        /// The key of the security key.
        public let key: String?

        public init(associationId: String? = nil, creationTime: Date? = nil, key: String? = nil) {
            self.associationId = associationId
            self.creationTime = creationTime
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case associationId = "AssociationId"
            case creationTime = "CreationTime"
            case key = "Key"
        }
    }

    public struct SecurityProfile: AWSDecodableShape {
        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlTags: [String: String]?
        /// The Amazon Resource Name (ARN) for the secruity profile.
        public let arn: String?
        /// The description of the security profile.
        public let description: String?
        /// The identifier for the security profile.
        public let id: String?
        /// The organization resource identifier for the security profile.
        public let organizationResourceId: String?
        /// The name for the security profile.
        public let securityProfileName: String?
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
        public let tagRestrictedResources: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(allowedAccessControlTags: [String: String]? = nil, arn: String? = nil, description: String? = nil, id: String? = nil, organizationResourceId: String? = nil, securityProfileName: String? = nil, tagRestrictedResources: [String]? = nil, tags: [String: String]? = nil) {
            self.allowedAccessControlTags = allowedAccessControlTags
            self.arn = arn
            self.description = description
            self.id = id
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tagRestrictedResources = tagRestrictedResources
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAccessControlTags = "AllowedAccessControlTags"
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case organizationResourceId = "OrganizationResourceId"
            case securityProfileName = "SecurityProfileName"
            case tagRestrictedResources = "TagRestrictedResources"
            case tags = "Tags"
        }
    }

    public struct SecurityProfileSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [SecurityProfileSearchCriteria]?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [SecurityProfileSearchCriteria]?
        public let stringCondition: StringCondition?

        public init(andConditions: [SecurityProfileSearchCriteria]? = nil, orConditions: [SecurityProfileSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct SecurityProfileSearchSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the security profile.
        public let arn: String?
        /// The description of the security profile.
        public let description: String?
        /// The identifier of the security profile.
        public let id: String?
        /// The organization resource identifier.
        public let organizationResourceId: String?
        /// The name of the security profile.
        public let securityProfileName: String?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, id: String? = nil, organizationResourceId: String? = nil, securityProfileName: String? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.organizationResourceId = organizationResourceId
            self.securityProfileName = securityProfileName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case organizationResourceId = "OrganizationResourceId"
            case securityProfileName = "SecurityProfileName"
            case tags = "Tags"
        }
    }

    public struct SecurityProfileSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the security profile.
        public let arn: String?
        /// The identifier of the security profile.
        public let id: String?
        /// The name of the security profile.
        public let name: String?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case name = "Name"
        }
    }

    public struct SecurityProfilesSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct SendNotificationActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Notification content. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let content: String
        /// Content type format.
        public let contentType: NotificationContentType
        /// Notification delivery method.
        public let deliveryMethod: NotificationDeliveryType
        /// Notification recipient.
        public let recipient: NotificationRecipientType
        /// The subject of the email if the delivery method is EMAIL. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let subject: String?

        public init(content: String, contentType: NotificationContentType, deliveryMethod: NotificationDeliveryType, recipient: NotificationRecipientType, subject: String? = nil) {
            self.content = content
            self.contentType = contentType
            self.deliveryMethod = deliveryMethod
            self.recipient = recipient
            self.subject = subject
        }

        public func validate(name: String) throws {
            try self.validate(self.content, name: "content", parent: name, max: 1024)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.subject, name: "subject", parent: name, max: 200)
            try self.validate(self.subject, name: "subject", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
            case contentType = "ContentType"
            case deliveryMethod = "DeliveryMethod"
            case recipient = "Recipient"
            case subject = "Subject"
        }
    }

    public struct StartChatContactRequest: AWSEncodableShape {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes. They can be accessed in flows just like any other contact attributes.  There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// The total duration of the newly started chat session. If not specified, the chat session duration defaults to 25 hour. The minumum configurable time is 60 minutes. The maximum configurable time is 10,080 minutes (7 days).
        public let chatDurationInMinutes: Int?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the flow for initiating the chat. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String
        /// The initial message to be sent to the newly created chat.
        public let initialMessage: ChatMessage?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// Information identifying the participant.
        public let participantDetails: ParticipantDetails
        /// The supported chat message content types. Content types must always contain text/plain. You can then put any other supported type in the list. For example, all the following lists are valid because they contain text/plain: [text/plain, text/markdown, application/json], [text/markdown, text/plain], [text/plain, application/json].
        public let supportedMessagingContentTypes: [String]?

        public init(attributes: [String: String]? = nil, chatDurationInMinutes: Int? = nil, clientToken: String? = StartChatContactRequest.idempotencyToken(), contactFlowId: String, initialMessage: ChatMessage? = nil, instanceId: String, participantDetails: ParticipantDetails, supportedMessagingContentTypes: [String]? = nil) {
            self.attributes = attributes
            self.chatDurationInMinutes = chatDurationInMinutes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.initialMessage = initialMessage
            self.instanceId = instanceId
            self.participantDetails = participantDetails
            self.supportedMessagingContentTypes = supportedMessagingContentTypes
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.chatDurationInMinutes, name: "chatDurationInMinutes", parent: name, max: 10080)
            try self.validate(self.chatDurationInMinutes, name: "chatDurationInMinutes", parent: name, min: 60)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.initialMessage?.validate(name: "\(name).initialMessage")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.participantDetails.validate(name: "\(name).participantDetails")
            try self.supportedMessagingContentTypes?.forEach {
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, max: 100)
                try validate($0, name: "supportedMessagingContentTypes[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case chatDurationInMinutes = "ChatDurationInMinutes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case initialMessage = "InitialMessage"
            case instanceId = "InstanceId"
            case participantDetails = "ParticipantDetails"
            case supportedMessagingContentTypes = "SupportedMessagingContentTypes"
        }
    }

    public struct StartChatContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?
        /// The identifier for a chat participant. The participantId for a chat participant is the same throughout the chat lifecycle.
        public let participantId: String?
        /// The token used by the chat participant to call CreateParticipantConnection. The participant token is valid for the lifetime of a chat participant.
        public let participantToken: String?

        public init(contactId: String? = nil, participantId: String? = nil, participantToken: String? = nil) {
            self.contactId = contactId
            self.participantId = participantId
            self.participantToken = participantToken
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case participantId = "ParticipantId"
            case participantToken = "ParticipantToken"
        }
    }

    public struct StartContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The person being recorded.
        public let voiceRecordingConfiguration: VoiceRecordingConfiguration

        public init(contactId: String, initialContactId: String, instanceId: String, voiceRecordingConfiguration: VoiceRecordingConfiguration) {
            self.contactId = contactId
            self.initialContactId = initialContactId
            self.instanceId = instanceId
            self.voiceRecordingConfiguration = voiceRecordingConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
            case voiceRecordingConfiguration = "VoiceRecordingConfiguration"
        }
    }

    public struct StartContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StartContactStreamingRequest: AWSEncodableShape {
        /// The streaming configuration, such as the Amazon SNS streaming endpoint.
        public let chatStreamingConfiguration: ChatStreamingConfiguration
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(chatStreamingConfiguration: ChatStreamingConfiguration, clientToken: String = StartContactStreamingRequest.idempotencyToken(), contactId: String, instanceId: String) {
            self.chatStreamingConfiguration = chatStreamingConfiguration
            self.clientToken = clientToken
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.chatStreamingConfiguration.validate(name: "\(name).chatStreamingConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case chatStreamingConfiguration = "ChatStreamingConfiguration"
            case clientToken = "ClientToken"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct StartContactStreamingResponse: AWSDecodableShape {
        /// The identifier of the streaming configuration enabled.
        public let streamingId: String

        public init(streamingId: String) {
            self.streamingId = streamingId
        }

        private enum CodingKeys: String, CodingKey {
            case streamingId = "StreamingId"
        }
    }

    public struct StartOutboundVoiceContactRequest: AWSEncodableShape {
        /// Configuration of the answering machine detection for this outbound call.
        public let answerMachineDetectionConfig: AnswerMachineDetectionConfig?
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// The campaign identifier of the outbound communication.
        public let campaignId: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs. The token is valid for 7 days after creation. If a contact is already started, the contact ID is returned.
        public let clientToken: String?
        /// The identifier of the flow for the outbound call. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String
        /// The phone number of the customer, in E.164 format.
        public let destinationPhoneNumber: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The queue for the call. If you specify a queue, the phone displayed for caller ID is the phone number specified in the queue. If you do not specify a queue, the queue defined in the flow is used. If you do not specify a queue, you must specify a source phone number.
        public let queueId: String?
        /// The phone number associated with the Amazon Connect instance, in E.164 format. If you do not specify a source phone number, you must specify a queue.
        public let sourcePhoneNumber: String?
        /// Denotes the class of traffic. Calls with different traffic types are handled differently by Amazon Connect. The default value is GENERAL. Use CAMPAIGN if EnableAnswerMachineDetection is set to true. For all other cases, use GENERAL.
        public let trafficType: TrafficType?

        public init(answerMachineDetectionConfig: AnswerMachineDetectionConfig? = nil, attributes: [String: String]? = nil, campaignId: String? = nil, clientToken: String? = StartOutboundVoiceContactRequest.idempotencyToken(), contactFlowId: String, destinationPhoneNumber: String, instanceId: String, queueId: String? = nil, sourcePhoneNumber: String? = nil, trafficType: TrafficType? = nil) {
            self.answerMachineDetectionConfig = answerMachineDetectionConfig
            self.attributes = attributes
            self.campaignId = campaignId
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.destinationPhoneNumber = destinationPhoneNumber
            self.instanceId = instanceId
            self.queueId = queueId
            self.sourcePhoneNumber = sourcePhoneNumber
            self.trafficType = trafficType
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.campaignId, name: "campaignId", parent: name, max: 100)
            try self.validate(self.campaignId, name: "campaignId", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.destinationPhoneNumber, name: "destinationPhoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.sourcePhoneNumber, name: "sourcePhoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case answerMachineDetectionConfig = "AnswerMachineDetectionConfig"
            case attributes = "Attributes"
            case campaignId = "CampaignId"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case destinationPhoneNumber = "DestinationPhoneNumber"
            case instanceId = "InstanceId"
            case queueId = "QueueId"
            case sourcePhoneNumber = "SourcePhoneNumber"
            case trafficType = "TrafficType"
        }
    }

    public struct StartOutboundVoiceContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?

        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct StartTaskContactRequest: AWSEncodableShape {
        /// A custom key-value pair using an attribute map. The attributes are standard Amazon Connect attributes, and can be accessed in flows just like any other contact attributes. There can be up to 32,768 UTF-8 bytes across all key-value pairs per contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the flow for initiating the tasks. To see the ContactFlowId in the Amazon Connect console user interface, on the navigation menu go to Routing, Contact Flows. Choose the flow. On the flow page, under the name of the flow, choose Show additional flow information. The ContactFlowId is the last part of the ARN, shown here in bold:  arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/846ec553-a005-41c0-8341-xxxxxxxxxxxx
        public let contactFlowId: String?
        /// A description of the task that is shown to an agent in the Contact Control Panel (CCP).
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of a task that is shown to an agent in the Contact Control Panel (CCP).
        public let name: String
        /// The identifier of the previous chat, voice, or task contact.
        public let previousContactId: String?
        /// The identifier for the quick connect.
        public let quickConnectId: String?
        /// A formatted URL that is shown to an agent in the Contact Control Panel (CCP).
        public let references: [String: Reference]?
        /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
        public let scheduledTime: Date?
        /// A unique identifier for the task template.
        public let taskTemplateId: String?

        public init(attributes: [String: String]? = nil, clientToken: String? = StartTaskContactRequest.idempotencyToken(), contactFlowId: String? = nil, description: String? = nil, instanceId: String, name: String, previousContactId: String? = nil, quickConnectId: String? = nil, references: [String: Reference]? = nil, scheduledTime: Date? = nil, taskTemplateId: String? = nil) {
            self.attributes = attributes
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.previousContactId = previousContactId
            self.quickConnectId = quickConnectId
            self.references = references
            self.scheduledTime = scheduledTime
            self.taskTemplateId = taskTemplateId
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 512)
            try self.validate(self.previousContactId, name: "previousContactId", parent: name, max: 256)
            try self.validate(self.previousContactId, name: "previousContactId", parent: name, min: 1)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case description = "Description"
            case instanceId = "InstanceId"
            case name = "Name"
            case previousContactId = "PreviousContactId"
            case quickConnectId = "QuickConnectId"
            case references = "References"
            case scheduledTime = "ScheduledTime"
            case taskTemplateId = "TaskTemplateId"
        }
    }

    public struct StartTaskContactResponse: AWSDecodableShape {
        /// The identifier of this contact within the Amazon Connect instance.
        public let contactId: String?

        public init(contactId: String? = nil) {
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
        }
    }

    public struct StopContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactId: String, initialContactId: String, instanceId: String) {
            self.contactId = contactId
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct StopContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopContactRequest: AWSEncodableShape {
        /// The ID of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactId: String, instanceId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct StopContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StopContactStreamingRequest: AWSEncodableShape {
        /// The identifier of the contact. This is the identifier of the contact that is associated with the first interaction with the contact center.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the streaming configuration enabled.
        public let streamingId: String

        public init(contactId: String, instanceId: String, streamingId: String) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.streamingId = streamingId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.streamingId, name: "streamingId", parent: name, max: 100)
            try self.validate(self.streamingId, name: "streamingId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case streamingId = "StreamingId"
        }
    }

    public struct StopContactStreamingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StringCondition: AWSEncodableShape {
        /// The type of comparison to be made when evaluating the string condition.
        public let comparisonType: StringComparisonType?
        /// The name of the field in the string condition.
        public let fieldName: String?
        /// The value of the string.
        public let value: String?

        public init(comparisonType: StringComparisonType? = nil, fieldName: String? = nil, value: String? = nil) {
            self.comparisonType = comparisonType
            self.fieldName = fieldName
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case comparisonType = "ComparisonType"
            case fieldName = "FieldName"
            case value = "Value"
        }
    }

    public struct StringReference: AWSDecodableShape {
        /// Identifier of the string reference.
        public let name: String?
        /// A valid string.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct SuspendContactRecordingRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactId: String, initialContactId: String, instanceId: String) {
            self.contactId = contactId
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct SuspendContactRecordingResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TagCondition: AWSEncodableShape {
        /// The tag key in the tag condition.
        public let tagKey: String?
        /// The tag value in the tag condition.
        public let tagValue: String?

        public init(tagKey: String? = nil, tagValue: String? = nil) {
            self.tagKey = tagKey
            self.tagValue = tagValue
        }

        private enum CodingKeys: String, CodingKey {
            case tagKey = "TagKey"
            case tagValue = "TagValue"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TaskActionDefinition: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The description. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let description: String?
        /// The name. Supports variable injection. For more information, see
        /// JSONPath reference
        /// in the Amazon Connect Administrators Guide.
        public let name: String
        /// Information about the reference when the referenceType is URL. Otherwise, null. (Supports variable injection in the Value field.)
        public let references: [String: Reference]?

        public init(contactFlowId: String, description: String? = nil, name: String, references: [String: Reference]? = nil) {
            self.contactFlowId = contactFlowId
            self.description = description
            self.name = name
            self.references = references
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.name, name: "name", parent: name, max: 512)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case description = "Description"
            case name = "Name"
            case references = "References"
        }
    }

    public struct TaskTemplateConstraints: AWSEncodableShape & AWSDecodableShape {
        /// Lists the fields that are invisible to agents.
        public let invisibleFields: [InvisibleFieldInfo]?
        /// Lists the fields that are read-only to agents, and cannot be edited.
        public let readOnlyFields: [ReadOnlyFieldInfo]?
        /// Lists the fields that are required to be filled by agents.
        public let requiredFields: [RequiredFieldInfo]?

        public init(invisibleFields: [InvisibleFieldInfo]? = nil, readOnlyFields: [ReadOnlyFieldInfo]? = nil, requiredFields: [RequiredFieldInfo]? = nil) {
            self.invisibleFields = invisibleFields
            self.readOnlyFields = readOnlyFields
            self.requiredFields = requiredFields
        }

        public func validate(name: String) throws {
            try self.invisibleFields?.forEach {
                try $0.validate(name: "\(name).invisibleFields[]")
            }
            try self.readOnlyFields?.forEach {
                try $0.validate(name: "\(name).readOnlyFields[]")
            }
            try self.requiredFields?.forEach {
                try $0.validate(name: "\(name).requiredFields[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case invisibleFields = "InvisibleFields"
            case readOnlyFields = "ReadOnlyFields"
            case requiredFields = "RequiredFields"
        }
    }

    public struct TaskTemplateDefaultFieldValue: AWSEncodableShape & AWSDecodableShape {
        /// Default value for the field.
        public let defaultValue: String?
        /// Identifier of a field.
        public let id: TaskTemplateFieldIdentifier?

        public init(defaultValue: String? = nil, id: TaskTemplateFieldIdentifier? = nil) {
            self.defaultValue = defaultValue
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.defaultValue, name: "defaultValue", parent: name, max: 4096)
            try self.id?.validate(name: "\(name).id")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultValue = "DefaultValue"
            case id = "Id"
        }
    }

    public struct TaskTemplateDefaults: AWSEncodableShape & AWSDecodableShape {
        /// Default value for the field.
        public let defaultFieldValues: [TaskTemplateDefaultFieldValue]?

        public init(defaultFieldValues: [TaskTemplateDefaultFieldValue]? = nil) {
            self.defaultFieldValues = defaultFieldValues
        }

        public func validate(name: String) throws {
            try self.defaultFieldValues?.forEach {
                try $0.validate(name: "\(name).defaultFieldValues[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case defaultFieldValues = "DefaultFieldValues"
        }
    }

    public struct TaskTemplateField: AWSEncodableShape & AWSDecodableShape {
        /// The description of the field.
        public let description: String?
        /// The unique identifier for the field.
        public let id: TaskTemplateFieldIdentifier
        /// A list of options for a single select field.
        public let singleSelectOptions: [String]?
        /// Indicates the type of field.
        public let type: TaskTemplateFieldType?

        public init(description: String? = nil, id: TaskTemplateFieldIdentifier, singleSelectOptions: [String]? = nil, type: TaskTemplateFieldType? = nil) {
            self.description = description
            self.id = id
            self.singleSelectOptions = singleSelectOptions
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.id.validate(name: "\(name).id")
            try self.singleSelectOptions?.forEach {
                try validate($0, name: "singleSelectOptions[]", parent: name, max: 100)
                try validate($0, name: "singleSelectOptions[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case id = "Id"
            case singleSelectOptions = "SingleSelectOptions"
            case type = "Type"
        }
    }

    public struct TaskTemplateFieldIdentifier: AWSEncodableShape & AWSDecodableShape {
        /// The name of the task template field.
        public let name: String?

        public init(name: String? = nil) {
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct TaskTemplateMetadata: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the task template.
        public let arn: String?
        /// The timestamp when the task template was created.
        public let createdTime: Date?
        /// The description of the task template.
        public let description: String?
        /// A unique identifier for the task template.
        public let id: String?
        /// The timestamp when the task template was last modified.
        public let lastModifiedTime: Date?
        /// The name of the task template.
        public let name: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        public init(arn: String? = nil, createdTime: Date? = nil, description: String? = nil, id: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, status: TaskTemplateStatus? = nil) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case createdTime = "CreatedTime"
            case description = "Description"
            case id = "Id"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct TelephonyConfig: AWSEncodableShape & AWSDecodableShape {
        /// Information about traffic distributions.
        public let distributions: [Distribution]

        public init(distributions: [Distribution]) {
            self.distributions = distributions
        }

        public func validate(name: String) throws {
            try self.distributions.forEach {
                try $0.validate(name: "\(name).distributions[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case distributions = "Distributions"
        }
    }

    public struct Threshold: AWSEncodableShape & AWSDecodableShape {
        /// The type of comparison. Only "less than" (LT) comparisons are supported.
        public let comparison: Comparison?
        /// The threshold value to compare.
        public let thresholdValue: Double?

        public init(comparison: Comparison? = nil, thresholdValue: Double? = nil) {
            self.comparison = comparison
            self.thresholdValue = thresholdValue
        }

        private enum CodingKeys: String, CodingKey {
            case comparison = "Comparison"
            case thresholdValue = "ThresholdValue"
        }
    }

    public struct TrafficDistributionGroup: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The description of the traffic distribution group.
        public let description: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String?
        /// The Amazon Resource Name (ARN).
        public let instanceArn: String?
        /// The name of the traffic distribution group.
        public let name: String?
        /// The status of the traffic distribution group.    CREATION_IN_PROGRESS means the previous CreateTrafficDistributionGroup operation is still in progress and has not yet completed.    ACTIVE means the previous CreateTrafficDistributionGroup operation has succeeded.    CREATION_FAILED indicates that the previous CreateTrafficDistributionGroup operation has failed.    PENDING_DELETION means the previous DeleteTrafficDistributionGroup operation is still in progress and has not yet completed.    DELETION_FAILED means the previous DeleteTrafficDistributionGroup operation has failed.    UPDATE_IN_PROGRESS means the previous UpdateTrafficDistributionGroup operation is still in progress and has not yet completed.
        public let status: TrafficDistributionGroupStatus?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String? = nil, description: String? = nil, id: String? = nil, instanceArn: String? = nil, name: String? = nil, status: TrafficDistributionGroupStatus? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.description = description
            self.id = id
            self.instanceArn = instanceArn
            self.name = name
            self.status = status
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case description = "Description"
            case id = "Id"
            case instanceArn = "InstanceArn"
            case name = "Name"
            case status = "Status"
            case tags = "Tags"
        }
    }

    public struct TrafficDistributionGroupSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let arn: String?
        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the traffic distribution group.
        public let instanceArn: String?
        /// The name of the traffic distribution group.
        public let name: String?
        /// The status of the traffic distribution group.     CREATION_IN_PROGRESS means the previous CreateTrafficDistributionGroup operation is still in progress and has not yet completed.    ACTIVE means the previous CreateTrafficDistributionGroup operation has succeeded.    CREATION_FAILED indicates that the previous CreateTrafficDistributionGroup operation has failed.    PENDING_DELETION means the previous DeleteTrafficDistributionGroup operation is still in progress and has not yet completed.    DELETION_FAILED means the previous DeleteTrafficDistributionGroup operation has failed.    UPDATE_IN_PROGRESS means the previous UpdateTrafficDistributionGroup operation is still in progress and has not yet completed.
        public let status: TrafficDistributionGroupStatus?

        public init(arn: String? = nil, id: String? = nil, instanceArn: String? = nil, name: String? = nil, status: TrafficDistributionGroupStatus? = nil) {
            self.arn = arn
            self.id = id
            self.instanceArn = instanceArn
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case instanceArn = "InstanceArn"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct TransferContactRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String?
        /// The identifier for the user.
        public let userId: String?

        public init(clientToken: String? = TransferContactRequest.idempotencyToken(), contactFlowId: String, contactId: String, instanceId: String, queueId: String? = nil, userId: String? = nil) {
            self.clientToken = clientToken
            self.contactFlowId = contactFlowId
            self.contactId = contactId
            self.instanceId = instanceId
            self.queueId = queueId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 256)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case contactFlowId = "ContactFlowId"
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case queueId = "QueueId"
            case userId = "UserId"
        }
    }

    public struct TransferContactResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the contact.
        public let contactArn: String?
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String?

        public init(contactArn: String? = nil, contactId: String? = nil) {
            self.contactArn = contactArn
            self.contactId = contactId
        }

        private enum CodingKeys: String, CodingKey {
            case contactArn = "ContactArn"
            case contactId = "ContactId"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateAgentStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "agentStatusId", location: .uri("AgentStatusId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the agent status.
        public let agentStatusId: String
        /// The description of the agent status.
        public let description: String?
        /// The display order of the agent status.
        public let displayOrder: Int?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the agent status.
        public let name: String?
        /// A number indicating the reset order of the agent status.
        public let resetOrderNumber: Bool?
        /// The state of the agent status.
        public let state: AgentStatusState?

        public init(agentStatusId: String, description: String? = nil, displayOrder: Int? = nil, instanceId: String, name: String? = nil, resetOrderNumber: Bool? = nil, state: AgentStatusState? = nil) {
            self.agentStatusId = agentStatusId
            self.description = description
            self.displayOrder = displayOrder
            self.instanceId = instanceId
            self.name = name
            self.resetOrderNumber = resetOrderNumber
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, max: 50)
            try self.validate(self.displayOrder, name: "displayOrder", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayOrder = "DisplayOrder"
            case name = "Name"
            case resetOrderNumber = "ResetOrderNumber"
            case state = "State"
        }
    }

    public struct UpdateContactAttributesRequest: AWSEncodableShape {
        /// The Amazon Connect attributes. These attributes can be accessed in flows just like any other contact attributes. You can have up to 32,768 UTF-8 bytes across all attributes for a contact. Attribute keys can include only alphanumeric, dash, and underscore characters.
        public let attributes: [String: String]
        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with the contact center.
        public let initialContactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(attributes: [String: String], initialContactId: String, instanceId: String) {
            self.attributes = attributes
            self.initialContactId = initialContactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.attributes.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 32767)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 32767)
            }
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, max: 256)
            try self.validate(self.initialContactId, name: "initialContactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case initialContactId = "InitialContactId"
            case instanceId = "InstanceId"
        }
    }

    public struct UpdateContactAttributesResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactFlowContentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowId", location: .uri("ContactFlowId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow.
        public let contactFlowId: String
        /// The JSON string that represents flow's content. For an example, see Example contact flow in Amazon Connect Flow language.
        public let content: String
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String

        public init(contactFlowId: String, content: String, instanceId: String) {
            self.contactFlowId = contactFlowId
            self.content = content
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct UpdateContactFlowMetadataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowId", location: .uri("ContactFlowId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow.
        public let contactFlowId: String
        /// The state of flow.
        public let contactFlowState: ContactFlowState?
        /// The description of the flow.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the flow.
        public let name: String?

        public init(contactFlowId: String, contactFlowState: ContactFlowState? = nil, description: String? = nil, instanceId: String, name: String? = nil) {
            self.contactFlowId = contactFlowId
            self.contactFlowState = contactFlowState
            self.description = description
            self.instanceId = instanceId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowState = "ContactFlowState"
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateContactFlowModuleContentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowModuleId", location: .uri("ContactFlowModuleId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The content of the flow module.
        public let content: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(contactFlowModuleId: String, content: String, instanceId: String) {
            self.contactFlowModuleId = contactFlowModuleId
            self.content = content
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.content, name: "content", parent: name, max: 256_000)
            try self.validate(self.content, name: "content", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case content = "Content"
        }
    }

    public struct UpdateContactFlowModuleContentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactFlowModuleMetadataRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowModuleId", location: .uri("ContactFlowModuleId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow module.
        public let contactFlowModuleId: String
        /// The description of the flow module.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the flow module.
        public let name: String?
        /// The state of flow module.
        public let state: ContactFlowModuleState?

        public init(contactFlowModuleId: String, description: String? = nil, instanceId: String, name: String? = nil, state: ContactFlowModuleState? = nil) {
            self.contactFlowModuleId = contactFlowModuleId
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.state = state
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, max: 256)
            try self.validate(self.contactFlowModuleId, name: "contactFlowModuleId", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 500)
            try self.validate(self.description, name: "description", parent: name, pattern: "\\S")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case state = "State"
        }
    }

    public struct UpdateContactFlowModuleMetadataResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactFlowNameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactFlowId", location: .uri("ContactFlowId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the flow.
        public let contactFlowId: String
        /// The description of the flow.
        public let description: String?
        /// The identifier of the Amazon Connect instance.
        public let instanceId: String
        /// The name of the flow.
        public let name: String?

        public init(contactFlowId: String, description: String? = nil, instanceId: String, name: String? = nil) {
            self.contactFlowId = contactFlowId
            self.description = description
            self.instanceId = instanceId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateContactRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri("ContactId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the contact. This is the identifier of the contact associated with the first interaction with your contact center.
        public let contactId: String
        /// The description of the contact.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the contact.
        public let name: String?
        /// Well-formed data on contact, shown to agents on Contact Control Panel (CCP).
        public let references: [String: Reference]?

        public init(contactId: String, description: String? = nil, instanceId: String, name: String? = nil, references: [String: Reference]? = nil) {
            self.contactId = contactId
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.references = references
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 4096)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 512)
            try self.references?.forEach {
                try validate($0.key, name: "references.key", parent: name, max: 4096)
                try validate($0.key, name: "references.key", parent: name, min: 1)
                try $0.value.validate(name: "\(name).references[\"\($0.key)\"]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case references = "References"
        }
    }

    public struct UpdateContactResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateContactScheduleRequest: AWSEncodableShape {
        /// The identifier of the contact.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The timestamp, in Unix Epoch seconds format, at which to start running the inbound flow. The scheduled time cannot be in the past. It must be within up to 6 days in future.
        public let scheduledTime: Date

        public init(contactId: String, instanceId: String, scheduledTime: Date) {
            self.contactId = contactId
            self.instanceId = instanceId
            self.scheduledTime = scheduledTime
        }

        public func validate(name: String) throws {
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contactId = "ContactId"
            case instanceId = "InstanceId"
            case scheduledTime = "ScheduledTime"
        }
    }

    public struct UpdateContactScheduleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateHoursOfOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hoursOfOperationId", location: .uri("HoursOfOperationId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// Configuration information of the hours of operation.
        public let config: [HoursOfOperationConfig]?
        /// The description of the hours of operation.
        public let description: String?
        /// The identifier of the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the hours of operation.
        public let name: String?
        /// The time zone of the hours of operation.
        public let timeZone: String?

        public init(config: [HoursOfOperationConfig]? = nil, description: String? = nil, hoursOfOperationId: String, instanceId: String, name: String? = nil, timeZone: String? = nil) {
            self.config = config
            self.description = description
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.name = name
            self.timeZone = timeZone
        }

        public func validate(name: String) throws {
            try self.config?.forEach {
                try $0.validate(name: "\(name).config[]")
            }
            try self.validate(self.config, name: "config", parent: name, max: 100)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case config = "Config"
            case description = "Description"
            case name = "Name"
            case timeZone = "TimeZone"
        }
    }

    public struct UpdateInstanceAttributeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "attributeType", location: .uri("AttributeType")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The type of attribute.  Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access this feature, contact Amazon Web Services Support for allowlisting.
        public let attributeType: InstanceAttributeType
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The value for the attribute. Maximum character limit is 100.
        public let value: String

        public init(attributeType: InstanceAttributeType, instanceId: String, value: String) {
            self.attributeType = attributeType
            self.instanceId = instanceId
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 100)
            try self.validate(self.value, name: "value", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case value = "Value"
        }
    }

    public struct UpdateInstanceStorageConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "associationId", location: .uri("AssociationId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "resourceType", location: .querystring("resourceType"))
        ]

        /// The existing association identifier that uniquely identifies the resource type and storage config for the given instance ID.
        public let associationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// A valid resource type.
        public let resourceType: InstanceStorageResourceType
        public let storageConfig: InstanceStorageConfig

        public init(associationId: String, instanceId: String, resourceType: InstanceStorageResourceType, storageConfig: InstanceStorageConfig) {
            self.associationId = associationId
            self.instanceId = instanceId
            self.resourceType = resourceType
            self.storageConfig = storageConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.associationId, name: "associationId", parent: name, max: 100)
            try self.validate(self.associationId, name: "associationId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.storageConfig.validate(name: "\(name).storageConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case storageConfig = "StorageConfig"
        }
    }

    public struct UpdateParticipantRoleConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "contactId", location: .uri("ContactId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The Amazon Connect channel you want to configure.
        public let channelConfiguration: UpdateParticipantRoleConfigChannelInfo
        /// The identifier of the contact in this instance of Amazon Connect.
        public let contactId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(channelConfiguration: UpdateParticipantRoleConfigChannelInfo, contactId: String, instanceId: String) {
            self.channelConfiguration = channelConfiguration
            self.contactId = contactId
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.channelConfiguration.validate(name: "\(name).channelConfiguration")
            try self.validate(self.contactId, name: "contactId", parent: name, max: 256)
            try self.validate(self.contactId, name: "contactId", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case channelConfiguration = "ChannelConfiguration"
        }
    }

    public struct UpdateParticipantRoleConfigResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePhoneNumberRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "phoneNumberId", location: .uri("PhoneNumberId"))
        ]

        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see Making retries safe with idempotent APIs.
        public let clientToken: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String
        /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic distribution groups that phone numbers are claimed to.
        public let targetArn: String

        public init(clientToken: String? = UpdatePhoneNumberRequest.idempotencyToken(), phoneNumberId: String, targetArn: String) {
            self.clientToken = clientToken
            self.phoneNumberId = phoneNumberId
            self.targetArn = targetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case targetArn = "TargetArn"
        }
    }

    public struct UpdatePhoneNumberResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the phone number.
        public let phoneNumberArn: String?
        /// A unique identifier for the phone number.
        public let phoneNumberId: String?

        public init(phoneNumberArn: String? = nil, phoneNumberId: String? = nil) {
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
        }

        private enum CodingKeys: String, CodingKey {
            case phoneNumberArn = "PhoneNumberArn"
            case phoneNumberId = "PhoneNumberId"
        }
    }

    public struct UpdateQueueHoursOfOperationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier for the hours of operation.
        public let hoursOfOperationId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String

        public init(hoursOfOperationId: String, instanceId: String, queueId: String) {
            self.hoursOfOperationId = hoursOfOperationId
            self.instanceId = instanceId
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hoursOfOperationId = "HoursOfOperationId"
        }
    }

    public struct UpdateQueueMaxContactsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The maximum number of contacts that can be in the queue before it is considered full.
        public let maxContacts: Int?
        /// The identifier for the queue.
        public let queueId: String

        public init(instanceId: String, maxContacts: Int? = nil, queueId: String) {
            self.instanceId = instanceId
            self.maxContacts = maxContacts
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.maxContacts, name: "maxContacts", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case maxContacts = "MaxContacts"
        }
    }

    public struct UpdateQueueNameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The description of the queue.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the queue.
        public let name: String?
        /// The identifier for the queue.
        public let queueId: String

        public init(description: String? = nil, instanceId: String, name: String? = nil, queueId: String) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateQueueOutboundCallerConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The outbound caller ID name, number, and outbound whisper flow.
        public let outboundCallerConfig: OutboundCallerConfig
        /// The identifier for the queue.
        public let queueId: String

        public init(instanceId: String, outboundCallerConfig: OutboundCallerConfig, queueId: String) {
            self.instanceId = instanceId
            self.outboundCallerConfig = outboundCallerConfig
            self.queueId = queueId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.outboundCallerConfig.validate(name: "\(name).outboundCallerConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case outboundCallerConfig = "OutboundCallerConfig"
        }
    }

    public struct UpdateQueueStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "queueId", location: .uri("QueueId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier for the queue.
        public let queueId: String
        /// The status of the queue.
        public let status: QueueStatus

        public init(instanceId: String, queueId: String, status: QueueStatus) {
            self.instanceId = instanceId
            self.queueId = queueId
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct UpdateQuickConnectConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "quickConnectId", location: .uri("QuickConnectId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// Information about the configuration settings for the quick connect.
        public let quickConnectConfig: QuickConnectConfig
        /// The identifier for the quick connect.
        public let quickConnectId: String

        public init(instanceId: String, quickConnectConfig: QuickConnectConfig, quickConnectId: String) {
            self.instanceId = instanceId
            self.quickConnectConfig = quickConnectConfig
            self.quickConnectId = quickConnectId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.quickConnectConfig.validate(name: "\(name).quickConnectConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case quickConnectConfig = "QuickConnectConfig"
        }
    }

    public struct UpdateQuickConnectNameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "quickConnectId", location: .uri("QuickConnectId"))
        ]

        /// The description of the quick connect.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the quick connect.
        public let name: String?
        /// The identifier for the quick connect.
        public let quickConnectId: String

        public init(description: String? = nil, instanceId: String, name: String? = nil, quickConnectId: String) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.quickConnectId = quickConnectId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateRoutingProfileConcurrencyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The channels that agents can handle in the Contact Control Panel (CCP).
        public let mediaConcurrencies: [MediaConcurrency]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(instanceId: String, mediaConcurrencies: [MediaConcurrency], routingProfileId: String) {
            self.instanceId = instanceId
            self.mediaConcurrencies = mediaConcurrencies
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.mediaConcurrencies.forEach {
                try $0.validate(name: "\(name).mediaConcurrencies[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case mediaConcurrencies = "MediaConcurrencies"
        }
    }

    public struct UpdateRoutingProfileDefaultOutboundQueueRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The identifier for the default outbound queue.
        public let defaultOutboundQueueId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(defaultOutboundQueueId: String, instanceId: String, routingProfileId: String) {
            self.defaultOutboundQueueId = defaultOutboundQueueId
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case defaultOutboundQueueId = "DefaultOutboundQueueId"
        }
    }

    public struct UpdateRoutingProfileNameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The description of the routing profile. Must not be more than 250 characters.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the routing profile. Must not be more than 127 characters.
        public let name: String?
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(description: String? = nil, instanceId: String, name: String? = nil, routingProfileId: String) {
            self.description = description
            self.instanceId = instanceId
            self.name = name
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 127)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
        }
    }

    public struct UpdateRoutingProfileQueuesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "routingProfileId", location: .uri("RoutingProfileId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The queues to be updated for this routing profile. Queues must first be associated to the routing profile. You can do this using AssociateRoutingProfileQueues.
        public let queueConfigs: [RoutingProfileQueueConfig]
        /// The identifier of the routing profile.
        public let routingProfileId: String

        public init(instanceId: String, queueConfigs: [RoutingProfileQueueConfig], routingProfileId: String) {
            self.instanceId = instanceId
            self.queueConfigs = queueConfigs
            self.routingProfileId = routingProfileId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.queueConfigs.forEach {
                try $0.validate(name: "\(name).queueConfigs[]")
            }
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, max: 10)
            try self.validate(self.queueConfigs, name: "queueConfigs", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case queueConfigs = "QueueConfigs"
        }
    }

    public struct UpdateRuleRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "ruleId", location: .uri("RuleId"))
        ]

        /// A list of actions to be run when the rule is triggered.
        public let actions: [RuleAction]
        /// The conditions of the rule.
        public let function: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the rule. You can change the name only if TriggerEventSource is one of the following values: OnZendeskTicketCreate | OnZendeskTicketStatusUpdate | OnSalesforceCaseCreate
        public let name: String
        /// The publish status of the rule.
        public let publishStatus: RulePublishStatus
        /// A unique identifier for the rule.
        public let ruleId: String

        public init(actions: [RuleAction], function: String, instanceId: String, name: String, publishStatus: RulePublishStatus, ruleId: String) {
            self.actions = actions
            self.function = function
            self.instanceId = instanceId
            self.name = name
            self.publishStatus = publishStatus
            self.ruleId = ruleId
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try $0.validate(name: "\(name).actions[]")
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[0-9a-zA-Z._-]+$")
            try self.validate(self.ruleId, name: "ruleId", parent: name, max: 256)
            try self.validate(self.ruleId, name: "ruleId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case function = "Function"
            case name = "Name"
            case publishStatus = "PublishStatus"
        }
    }

    public struct UpdateSecurityProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "securityProfileId", location: .uri("SecurityProfileId"))
        ]

        /// The list of tags that a security profile uses to restrict access to resources in Amazon Connect.
        public let allowedAccessControlTags: [String: String]?
        /// The description of the security profile.
        public let description: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The permissions granted to a security profile. For a list of valid permissions, see List of security profile permissions.
        public let permissions: [String]?
        /// The identifier for the security profle.
        public let securityProfileId: String
        /// The list of resources that a security profile applies tag restrictions to in Amazon Connect.
        public let tagRestrictedResources: [String]?

        public init(allowedAccessControlTags: [String: String]? = nil, description: String? = nil, instanceId: String, permissions: [String]? = nil, securityProfileId: String, tagRestrictedResources: [String]? = nil) {
            self.allowedAccessControlTags = allowedAccessControlTags
            self.description = description
            self.instanceId = instanceId
            self.permissions = permissions
            self.securityProfileId = securityProfileId
            self.tagRestrictedResources = tagRestrictedResources
        }

        public func validate(name: String) throws {
            try self.allowedAccessControlTags?.forEach {
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, max: 128)
                try validate($0.key, name: "allowedAccessControlTags.key", parent: name, min: 1)
                try validate($0.value, name: "allowedAccessControlTags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.allowedAccessControlTags, name: "allowedAccessControlTags", parent: name, max: 2)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.permissions?.forEach {
                try validate($0, name: "permissions[]", parent: name, max: 128)
                try validate($0, name: "permissions[]", parent: name, min: 1)
            }
            try self.validate(self.permissions, name: "permissions", parent: name, max: 500)
            try self.tagRestrictedResources?.forEach {
                try validate($0, name: "tagRestrictedResources[]", parent: name, max: 128)
                try validate($0, name: "tagRestrictedResources[]", parent: name, min: 1)
            }
            try self.validate(self.tagRestrictedResources, name: "tagRestrictedResources", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case allowedAccessControlTags = "AllowedAccessControlTags"
            case description = "Description"
            case permissions = "Permissions"
            case tagRestrictedResources = "TagRestrictedResources"
        }
    }

    public struct UpdateTaskTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "taskTemplateId", location: .uri("TaskTemplateId"))
        ]

        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the task template.
        public let name: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?
        /// A unique identifier for the task template.
        public let taskTemplateId: String

        public init(constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField]? = nil, instanceId: String, name: String? = nil, status: TaskTemplateStatus? = nil, taskTemplateId: String) {
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.instanceId = instanceId
            self.name = name
            self.status = status
            self.taskTemplateId = taskTemplateId
        }

        public func validate(name: String) throws {
            try self.constraints?.validate(name: "\(name).constraints")
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
            try self.defaults?.validate(name: "\(name).defaults")
            try self.validate(self.description, name: "description", parent: name, max: 255)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.fields?.forEach {
                try $0.validate(name: "\(name).fields[]")
            }
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, max: 500)
            try self.validate(self.taskTemplateId, name: "taskTemplateId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct UpdateTaskTemplateResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the task template resource.
        public let arn: String?
        /// Constraints that are applicable to the fields listed.
        public let constraints: TaskTemplateConstraints?
        /// The identifier of the flow that runs by default when a task is created by referencing this template.
        public let contactFlowId: String?
        /// The timestamp when the task template was created.
        public let createdTime: Date?
        /// The default values for fields when a task is created by referencing this template.
        public let defaults: TaskTemplateDefaults?
        /// The description of the task template.
        public let description: String?
        /// Fields that are part of the template.
        public let fields: [TaskTemplateField]?
        /// The identifier of the task template resource.
        public let id: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String?
        /// The timestamp when the task template was last modified.
        public let lastModifiedTime: Date?
        /// The name of the task template.
        public let name: String?
        /// Marks a template as ACTIVE or INACTIVE for a task to refer to it.
        /// Tasks can only be created from ACTIVE templates.
        /// If a template is marked as INACTIVE, then a task that refers to this template cannot be created.
        public let status: TaskTemplateStatus?

        public init(arn: String? = nil, constraints: TaskTemplateConstraints? = nil, contactFlowId: String? = nil, createdTime: Date? = nil, defaults: TaskTemplateDefaults? = nil, description: String? = nil, fields: [TaskTemplateField]? = nil, id: String? = nil, instanceId: String? = nil, lastModifiedTime: Date? = nil, name: String? = nil, status: TaskTemplateStatus? = nil) {
            self.arn = arn
            self.constraints = constraints
            self.contactFlowId = contactFlowId
            self.createdTime = createdTime
            self.defaults = defaults
            self.description = description
            self.fields = fields
            self.id = id
            self.instanceId = instanceId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case constraints = "Constraints"
            case contactFlowId = "ContactFlowId"
            case createdTime = "CreatedTime"
            case defaults = "Defaults"
            case description = "Description"
            case fields = "Fields"
            case id = "Id"
            case instanceId = "InstanceId"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case status = "Status"
        }
    }

    public struct UpdateTrafficDistributionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "id", location: .uri("Id"))
        ]

        /// The identifier of the traffic distribution group.
        /// This can be the ID or the ARN if the API is being called in the Region where the traffic distribution group was created.
        /// The ARN must be provided if the call is from the replicated Region.
        public let id: String
        /// The distribution of traffic between the instance and its replica(s).
        public let telephonyConfig: TelephonyConfig?

        public init(id: String, telephonyConfig: TelephonyConfig? = nil) {
            self.id = id
            self.telephonyConfig = telephonyConfig
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, pattern: "^(arn:(aws|aws-us-gov):connect:[a-z]{2}-[a-z-]+-[0-9]{1}:[0-9]{1,20}:traffic-distribution-group/)?[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.telephonyConfig?.validate(name: "\(name).telephonyConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case telephonyConfig = "TelephonyConfig"
        }
    }

    public struct UpdateTrafficDistributionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateUserHierarchyGroupNameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "hierarchyGroupId", location: .uri("HierarchyGroupId")),
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The name of the hierarchy group. Must not be more than 100 characters.
        public let name: String

        public init(hierarchyGroupId: String, instanceId: String, name: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct UpdateUserHierarchyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the hierarchy group.
        public let hierarchyGroupId: String?
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(hierarchyGroupId: String? = nil, instanceId: String, userId: String) {
            self.hierarchyGroupId = hierarchyGroupId
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyGroupId = "HierarchyGroupId"
        }
    }

    public struct UpdateUserHierarchyStructureRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId"))
        ]

        /// The hierarchy levels to update.
        public let hierarchyStructure: HierarchyStructureUpdate
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String

        public init(hierarchyStructure: HierarchyStructureUpdate, instanceId: String) {
            self.hierarchyStructure = hierarchyStructure
            self.instanceId = instanceId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case hierarchyStructure = "HierarchyStructure"
        }
    }

    public struct UpdateUserIdentityInfoRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identity information for the user.
        public let identityInfo: UserIdentityInfo
        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the user account.
        public let userId: String

        public init(identityInfo: UserIdentityInfo, instanceId: String, userId: String) {
            self.identityInfo = identityInfo
            self.instanceId = instanceId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.identityInfo.validate(name: "\(name).identityInfo")
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case identityInfo = "IdentityInfo"
        }
    }

    public struct UpdateUserPhoneConfigRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// Information about phone configuration settings for the user.
        public let phoneConfig: UserPhoneConfig
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, phoneConfig: UserPhoneConfig, userId: String) {
            self.instanceId = instanceId
            self.phoneConfig = phoneConfig
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.phoneConfig.validate(name: "\(name).phoneConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case phoneConfig = "PhoneConfig"
        }
    }

    public struct UpdateUserRoutingProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, routingProfileId: String, userId: String) {
            self.instanceId = instanceId
            self.routingProfileId = routingProfileId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case routingProfileId = "RoutingProfileId"
        }
    }

    public struct UpdateUserSecurityProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "instanceId", location: .uri("InstanceId")),
            AWSMemberEncoding(label: "userId", location: .uri("UserId"))
        ]

        /// The identifier of the Amazon Connect instance. You can find the instanceId in the ARN of the instance.
        public let instanceId: String
        /// The identifiers of the security profiles for the user.
        public let securityProfileIds: [String]
        /// The identifier of the user account.
        public let userId: String

        public init(instanceId: String, securityProfileIds: [String], userId: String) {
            self.instanceId = instanceId
            self.securityProfileIds = securityProfileIds
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.instanceId, name: "instanceId", parent: name, max: 100)
            try self.validate(self.instanceId, name: "instanceId", parent: name, min: 1)
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, max: 10)
            try self.validate(self.securityProfileIds, name: "securityProfileIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case securityProfileIds = "SecurityProfileIds"
        }
    }

    public struct UrlReference: AWSDecodableShape {
        /// Identifier of the URL reference.
        public let name: String?
        /// A valid URL.
        public let value: String?

        public init(name: String? = nil, value: String? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct UseCase: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the use case.
        public let useCaseArn: String?
        /// The identifier for the use case.
        public let useCaseId: String?
        /// The type of use case to associate to the integration association. Each integration association can have only one of each use case type.
        public let useCaseType: UseCaseType?

        public init(useCaseArn: String? = nil, useCaseId: String? = nil, useCaseType: UseCaseType? = nil) {
            self.useCaseArn = useCaseArn
            self.useCaseId = useCaseId
            self.useCaseType = useCaseType
        }

        private enum CodingKeys: String, CodingKey {
            case useCaseArn = "UseCaseArn"
            case useCaseId = "UseCaseId"
            case useCaseType = "UseCaseType"
        }
    }

    public struct User: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user account.
        public let arn: String?
        /// The identifier of the user account in the directory used for identity management.
        public let directoryUserId: String?
        /// The identifier of the hierarchy group for the user.
        public let hierarchyGroupId: String?
        /// The identifier of the user account.
        public let id: String?
        /// Information about the user identity.
        public let identityInfo: UserIdentityInfo?
        /// Information about the phone configuration for the user.
        public let phoneConfig: UserPhoneConfig?
        /// The identifier of the routing profile for the user.
        public let routingProfileId: String?
        /// The identifiers of the security profiles for the user.
        public let securityProfileIds: [String]?
        /// The tags.
        public let tags: [String: String]?
        /// The user name assigned to the user account.
        public let username: String?

        public init(arn: String? = nil, directoryUserId: String? = nil, hierarchyGroupId: String? = nil, id: String? = nil, identityInfo: UserIdentityInfo? = nil, phoneConfig: UserPhoneConfig? = nil, routingProfileId: String? = nil, securityProfileIds: [String]? = nil, tags: [String: String]? = nil, username: String? = nil) {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case id = "Id"
            case identityInfo = "IdentityInfo"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct UserData: AWSDecodableShape {
        ///  A map of active slots by channel. The key is a channel name. The value is an integer: the number of active slots.
        public let activeSlotsByChannel: [Channel: Int]?
        /// A map of available slots by channel. The key is a channel name. The value is an integer: the available number of slots.
        public let availableSlotsByChannel: [Channel: Int]?
        /// A list of contact reference information.
        public let contacts: [AgentContactReference]?
        /// Contains information about the levels of a hierarchy group assigned to a user.
        public let hierarchyPath: HierarchyPathReference?
        /// A map of maximum slots by channel. The key is a channel name. The value is an integer: the maximum number of slots. This is calculated from MediaConcurrency of the RoutingProfile assigned to the agent.
        public let maxSlotsByChannel: [Channel: Int]?
        /// The Next status of the agent.
        public let nextStatus: String?
        /// Information about the routing profile that is assigned to the user.
        public let routingProfile: RoutingProfileReference?
        /// The status of the agent that they manually set in their Contact Control Panel (CCP), or that the supervisor manually changes in the real-time metrics report.
        public let status: AgentStatusReference?
        /// Information about the user for the data that is returned. It contains the resourceId and ARN of the user.
        public let user: UserReference?

        public init(activeSlotsByChannel: [Channel: Int]? = nil, availableSlotsByChannel: [Channel: Int]? = nil, contacts: [AgentContactReference]? = nil, hierarchyPath: HierarchyPathReference? = nil, maxSlotsByChannel: [Channel: Int]? = nil, nextStatus: String? = nil, routingProfile: RoutingProfileReference? = nil, status: AgentStatusReference? = nil, user: UserReference? = nil) {
            self.activeSlotsByChannel = activeSlotsByChannel
            self.availableSlotsByChannel = availableSlotsByChannel
            self.contacts = contacts
            self.hierarchyPath = hierarchyPath
            self.maxSlotsByChannel = maxSlotsByChannel
            self.nextStatus = nextStatus
            self.routingProfile = routingProfile
            self.status = status
            self.user = user
        }

        private enum CodingKeys: String, CodingKey {
            case activeSlotsByChannel = "ActiveSlotsByChannel"
            case availableSlotsByChannel = "AvailableSlotsByChannel"
            case contacts = "Contacts"
            case hierarchyPath = "HierarchyPath"
            case maxSlotsByChannel = "MaxSlotsByChannel"
            case nextStatus = "NextStatus"
            case routingProfile = "RoutingProfile"
            case status = "Status"
            case user = "User"
        }
    }

    public struct UserDataFilters: AWSEncodableShape {
        /// A list of up to 100 agent IDs or ARNs.
        public let agents: [String]?
        /// A filter for the user data based on the contact information that is associated to the user. It contains a list of contact states.
        public let contactFilter: ContactFilter?
        /// A list of up to 100 queues or ARNs.
        public let queues: [String]?
        /// A list of up to 100 routing profile IDs or ARNs.
        public let routingProfiles: [String]?
        /// A UserHierarchyGroup ID or ARN.
        public let userHierarchyGroups: [String]?

        public init(agents: [String]? = nil, contactFilter: ContactFilter? = nil, queues: [String]? = nil, routingProfiles: [String]? = nil, userHierarchyGroups: [String]? = nil) {
            self.agents = agents
            self.contactFilter = contactFilter
            self.queues = queues
            self.routingProfiles = routingProfiles
            self.userHierarchyGroups = userHierarchyGroups
        }

        public func validate(name: String) throws {
            try self.validate(self.agents, name: "agents", parent: name, max: 100)
            try self.validate(self.agents, name: "agents", parent: name, min: 1)
            try self.contactFilter?.validate(name: "\(name).contactFilter")
            try self.validate(self.queues, name: "queues", parent: name, max: 100)
            try self.validate(self.queues, name: "queues", parent: name, min: 1)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, max: 100)
            try self.validate(self.routingProfiles, name: "routingProfiles", parent: name, min: 1)
            try self.validate(self.userHierarchyGroups, name: "userHierarchyGroups", parent: name, max: 1)
            try self.validate(self.userHierarchyGroups, name: "userHierarchyGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case agents = "Agents"
            case contactFilter = "ContactFilter"
            case queues = "Queues"
            case routingProfiles = "RoutingProfiles"
            case userHierarchyGroups = "UserHierarchyGroups"
        }
    }

    public struct UserIdentityInfo: AWSEncodableShape & AWSDecodableShape {
        /// The email address. If you are using SAML for identity management and include this parameter, an error is returned.
        public let email: String?
        /// The first name. This is required if you are using Amazon Connect or SAML for identity management.
        public let firstName: String?
        /// The last name. This is required if you are using Amazon Connect or SAML for identity management.
        public let lastName: String?
        /// The user's mobile number.
        public let mobile: String?
        /// The user's secondary email address. If you provide a secondary email, the user receives email notifications - other than password reset notifications - to this email address instead of to their primary email address. Pattern: (?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}
        public let secondaryEmail: String?

        public init(email: String? = nil, firstName: String? = nil, lastName: String? = nil, mobile: String? = nil, secondaryEmail: String? = nil) {
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.mobile = mobile
            self.secondaryEmail = secondaryEmail
        }

        public func validate(name: String) throws {
            try self.validate(self.firstName, name: "firstName", parent: name, max: 100)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, max: 100)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.mobile, name: "mobile", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case email = "Email"
            case firstName = "FirstName"
            case lastName = "LastName"
            case mobile = "Mobile"
            case secondaryEmail = "SecondaryEmail"
        }
    }

    public struct UserIdentityInfoLite: AWSDecodableShape {
        /// The user's first name.
        public let firstName: String?
        /// The user's last name.
        public let lastName: String?

        public init(firstName: String? = nil, lastName: String? = nil) {
            self.firstName = firstName
            self.lastName = lastName
        }

        private enum CodingKeys: String, CodingKey {
            case firstName = "FirstName"
            case lastName = "LastName"
        }
    }

    public struct UserPhoneConfig: AWSEncodableShape & AWSDecodableShape {
        /// The After Call Work (ACW) timeout setting, in seconds.  When returned by a SearchUsers call, AfterContactWorkTimeLimit is returned in milliseconds.
        public let afterContactWorkTimeLimit: Int?
        /// The Auto accept setting.
        public let autoAccept: Bool?
        /// The phone number for the user's desk phone.
        public let deskPhoneNumber: String?
        /// The phone type.
        public let phoneType: PhoneType

        public init(afterContactWorkTimeLimit: Int? = nil, autoAccept: Bool? = nil, deskPhoneNumber: String? = nil, phoneType: PhoneType) {
            self.afterContactWorkTimeLimit = afterContactWorkTimeLimit
            self.autoAccept = autoAccept
            self.deskPhoneNumber = deskPhoneNumber
            self.phoneType = phoneType
        }

        public func validate(name: String) throws {
            try self.validate(self.afterContactWorkTimeLimit, name: "afterContactWorkTimeLimit", parent: name, min: 0)
            try self.validate(self.deskPhoneNumber, name: "deskPhoneNumber", parent: name, pattern: "^\\\\+[1-9]\\\\d{1,14}$")
        }

        private enum CodingKeys: String, CodingKey {
            case afterContactWorkTimeLimit = "AfterContactWorkTimeLimit"
            case autoAccept = "AutoAccept"
            case deskPhoneNumber = "DeskPhoneNumber"
            case phoneType = "PhoneType"
        }
    }

    public struct UserQuickConnectConfig: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the flow.
        public let contactFlowId: String
        /// The identifier of the user.
        public let userId: String

        public init(contactFlowId: String, userId: String) {
            self.contactFlowId = contactFlowId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.contactFlowId, name: "contactFlowId", parent: name, max: 500)
        }

        private enum CodingKeys: String, CodingKey {
            case contactFlowId = "ContactFlowId"
            case userId = "UserId"
        }
    }

    public struct UserReference: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the user.
        public let arn: String?
        /// The unique identifier for the user.
        public let id: String?

        public init(arn: String? = nil, id: String? = nil) {
            self.arn = arn
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
        }
    }

    public struct UserSearchCriteria: AWSEncodableShape {
        /// A list of conditions which would be applied together with an AND condition.
        public let andConditions: [UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a hierarchy group condition.
        public let hierarchyGroupCondition: HierarchyGroupCondition?
        /// A list of conditions which would be applied together with an OR condition.
        public let orConditions: [UserSearchCriteria]?
        /// A leaf node condition which can be used to specify a string condition.
        public let stringCondition: StringCondition?

        public init(andConditions: [UserSearchCriteria]? = nil, hierarchyGroupCondition: HierarchyGroupCondition? = nil, orConditions: [UserSearchCriteria]? = nil, stringCondition: StringCondition? = nil) {
            self.andConditions = andConditions
            self.hierarchyGroupCondition = hierarchyGroupCondition
            self.orConditions = orConditions
            self.stringCondition = stringCondition
        }

        private enum CodingKeys: String, CodingKey {
            case andConditions = "AndConditions"
            case hierarchyGroupCondition = "HierarchyGroupCondition"
            case orConditions = "OrConditions"
            case stringCondition = "StringCondition"
        }
    }

    public struct UserSearchFilter: AWSEncodableShape {
        public let tagFilter: ControlPlaneTagFilter?

        public init(tagFilter: ControlPlaneTagFilter? = nil) {
            self.tagFilter = tagFilter
        }

        private enum CodingKeys: String, CodingKey {
            case tagFilter = "TagFilter"
        }
    }

    public struct UserSearchSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user.
        public let arn: String?
        /// The directory identifier of the user.
        public let directoryUserId: String?
        /// The identifier of the user's hierarchy group.
        public let hierarchyGroupId: String?
        /// The identifier of the user's summary.
        public let id: String?
        /// The user's first name and last name.
        public let identityInfo: UserIdentityInfoLite?
        public let phoneConfig: UserPhoneConfig?
        /// The identifier of the user's routing profile.
        public let routingProfileId: String?
        /// The identifiers of the user's security profiles.
        public let securityProfileIds: [String]?
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?
        /// The name of the user.
        public let username: String?

        public init(arn: String? = nil, directoryUserId: String? = nil, hierarchyGroupId: String? = nil, id: String? = nil, identityInfo: UserIdentityInfoLite? = nil, phoneConfig: UserPhoneConfig? = nil, routingProfileId: String? = nil, securityProfileIds: [String]? = nil, tags: [String: String]? = nil, username: String? = nil) {
            self.arn = arn
            self.directoryUserId = directoryUserId
            self.hierarchyGroupId = hierarchyGroupId
            self.id = id
            self.identityInfo = identityInfo
            self.phoneConfig = phoneConfig
            self.routingProfileId = routingProfileId
            self.securityProfileIds = securityProfileIds
            self.tags = tags
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case directoryUserId = "DirectoryUserId"
            case hierarchyGroupId = "HierarchyGroupId"
            case id = "Id"
            case identityInfo = "IdentityInfo"
            case phoneConfig = "PhoneConfig"
            case routingProfileId = "RoutingProfileId"
            case securityProfileIds = "SecurityProfileIds"
            case tags = "Tags"
            case username = "Username"
        }
    }

    public struct UserSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the user account.
        public let arn: String?
        /// The identifier of the user account.
        public let id: String?
        /// The Amazon Connect user name of the user account.
        public let username: String?

        public init(arn: String? = nil, id: String? = nil, username: String? = nil) {
            self.arn = arn
            self.id = id
            self.username = username
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case id = "Id"
            case username = "Username"
        }
    }

    public struct Vocabulary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let arn: String
        /// The content of the custom vocabulary in plain-text format with a table of values. Each row in the table represents a word or a phrase, described with Phrase, IPA, SoundsLike, and DisplayAs fields. Separate the fields with TAB characters. For more information, see Create a custom vocabulary using a table.
        public let content: String?
        /// The reason why the custom vocabulary was not created.
        public let failureReason: String?
        /// The identifier of the custom vocabulary.
        public let id: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The timestamp when the custom vocabulary was last modified.
        public let lastModifiedTime: Date
        /// A unique name of the custom vocabulary.
        public let name: String
        /// The current state of the custom vocabulary.
        public let state: VocabularyState
        /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
        public let tags: [String: String]?

        public init(arn: String, content: String? = nil, failureReason: String? = nil, id: String, languageCode: VocabularyLanguageCode, lastModifiedTime: Date, name: String, state: VocabularyState, tags: [String: String]? = nil) {
            self.arn = arn
            self.content = content
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case content = "Content"
            case failureReason = "FailureReason"
            case id = "Id"
            case languageCode = "LanguageCode"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct VocabularySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the custom vocabulary.
        public let arn: String
        /// The reason why the custom vocabulary was not created.
        public let failureReason: String?
        /// The identifier of the custom vocabulary.
        public let id: String
        /// The language code of the vocabulary entries. For a list of languages and their corresponding language codes, see
        /// What is Amazon Transcribe?
        public let languageCode: VocabularyLanguageCode
        /// The timestamp when the custom vocabulary was last modified.
        public let lastModifiedTime: Date
        /// A unique name of the custom vocabulary.
        public let name: String
        /// The current state of the custom vocabulary.
        public let state: VocabularyState

        public init(arn: String, failureReason: String? = nil, id: String, languageCode: VocabularyLanguageCode, lastModifiedTime: Date, name: String, state: VocabularyState) {
            self.arn = arn
            self.failureReason = failureReason
            self.id = id
            self.languageCode = languageCode
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case failureReason = "FailureReason"
            case id = "Id"
            case languageCode = "LanguageCode"
            case lastModifiedTime = "LastModifiedTime"
            case name = "Name"
            case state = "State"
        }
    }

    public struct VoiceRecordingConfiguration: AWSEncodableShape {
        /// Identifies which track is being recorded.
        public let voiceRecordingTrack: VoiceRecordingTrack?

        public init(voiceRecordingTrack: VoiceRecordingTrack? = nil) {
            self.voiceRecordingTrack = voiceRecordingTrack
        }

        private enum CodingKeys: String, CodingKey {
            case voiceRecordingTrack = "VoiceRecordingTrack"
        }
    }

    public struct UpdateParticipantRoleConfigChannelInfo: AWSEncodableShape {
        /// Configuration information for the chat participant role.
        public let chat: ChatParticipantRoleConfig?

        public init(chat: ChatParticipantRoleConfig? = nil) {
            self.chat = chat
        }

        public func validate(name: String) throws {
            try self.chat?.validate(name: "\(name).chat")
        }

        private enum CodingKeys: String, CodingKey {
            case chat = "Chat"
        }
    }
}

// MARK: - Errors

/// Error enum for Connect
public struct ConnectErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case contactFlowNotPublishedException = "ContactFlowNotPublishedException"
        case contactNotFoundException = "ContactNotFoundException"
        case destinationNotAllowedException = "DestinationNotAllowedException"
        case duplicateResourceException = "DuplicateResourceException"
        case idempotencyException = "IdempotencyException"
        case internalServiceException = "InternalServiceException"
        case invalidContactFlowException = "InvalidContactFlowException"
        case invalidContactFlowModuleException = "InvalidContactFlowModuleException"
        case invalidParameterException = "InvalidParameterException"
        case invalidRequestException = "InvalidRequestException"
        case limitExceededException = "LimitExceededException"
        case outboundContactNotPermittedException = "OutboundContactNotPermittedException"
        case propertyValidationException = "PropertyValidationException"
        case resourceConflictException = "ResourceConflictException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case resourceNotReadyException = "ResourceNotReadyException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case userNotFoundException = "UserNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Connect
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient permissions to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The flow has not been published.
    public static var contactFlowNotPublishedException: Self { .init(.contactFlowNotPublishedException) }
    /// The contact with the specified ID is not active or does not exist. Applies to Voice calls only, not to Chat, Task, or Voice Callback.
    public static var contactNotFoundException: Self { .init(.contactNotFoundException) }
    /// Outbound calls to the destination number are not allowed.
    public static var destinationNotAllowedException: Self { .init(.destinationNotAllowedException) }
    /// A resource with the specified name already exists.
    public static var duplicateResourceException: Self { .init(.duplicateResourceException) }
    /// An entity with the same name already exists.
    public static var idempotencyException: Self { .init(.idempotencyException) }
    /// Request processing failed because of an error or failure with the service.
    public static var internalServiceException: Self { .init(.internalServiceException) }
    /// The flow is not valid.
    public static var invalidContactFlowException: Self { .init(.invalidContactFlowException) }
    /// The problems with the module. Please fix before trying again.
    public static var invalidContactFlowModuleException: Self { .init(.invalidContactFlowModuleException) }
    /// One or more of the specified parameters are not valid.
    public static var invalidParameterException: Self { .init(.invalidParameterException) }
    /// The request is not valid.
    public static var invalidRequestException: Self { .init(.invalidRequestException) }
    /// The allowed limit for the resource has been exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// The contact is not permitted.
    public static var outboundContactNotPermittedException: Self { .init(.outboundContactNotPermittedException) }
    /// The property is not valid.
    public static var propertyValidationException: Self { .init(.propertyValidationException) }
    /// A resource already has that name.
    public static var resourceConflictException: Self { .init(.resourceConflictException) }
    /// That resource is already in use. Please try another.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// The specified resource was not found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The resource is not ready.
    public static var resourceNotReadyException: Self { .init(.resourceNotReadyException) }
    /// The service quota has been exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The throttling limit has been exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// No user with the specified credentials was found in the Amazon Connect instance.
    public static var userNotFoundException: Self { .init(.userNotFoundException) }
}

extension ConnectErrorType: Equatable {
    public static func == (lhs: ConnectErrorType, rhs: ConnectErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ConnectErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
