//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension PartnerCentralAccount {
    // MARK: Enums

    public enum AccessDeniedExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accessDenied = "ACCESS_DENIED"
        case incompatibleBenefitAwsPartnerState = "INCOMPATIBLE_BENEFIT_AWS_PARTNER_STATE"
        public var description: String { return self.rawValue }
    }

    public enum AccessType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allowAll = "ALLOW_ALL"
        case allowByDefaultDenySome = "ALLOW_BY_DEFAULT_DENY_SOME"
        case denyAll = "DENY_ALL"
        public var description: String { return self.rawValue }
    }

    public enum BusinessValidationCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case incompatibleConnectionInvitationRequest = "INCOMPATIBLE_CONNECTION_INVITATION_REQUEST"
        case incompatibleDomain = "INCOMPATIBLE_DOMAIN"
        case incompatibleIdentityVerificationStatus = "INCOMPATIBLE_IDENTITY_VERIFICATION_STATUS"
        case incompatibleKnowYourBusinessStatus = "INCOMPATIBLE_KNOW_YOUR_BUSINESS_STATUS"
        case incompatibleLegalName = "INCOMPATIBLE_LEGAL_NAME"
        case invalidAccountLinkingStatus = "INVALID_ACCOUNT_LINKING_STATUS"
        case invalidAccountState = "INVALID_ACCOUNT_STATE"
        public var description: String { return self.rawValue }
    }

    public enum ConflictExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountAlreadyVerified = "ACCOUNT_ALREADY_VERIFIED"
        case conflictClientToken = "CONFLICT_CLIENT_TOKEN"
        case duplicateConnection = "DUPLICATE_CONNECTION"
        case duplicateConnectionInvitation = "DUPLICATE_CONNECTION_INVITATION"
        case duplicatePartner = "DUPLICATE_PARTNER"
        case incompatibleConnectionInvitationReceiver = "INCOMPATIBLE_CONNECTION_INVITATION_RECEIVER"
        case incompatibleConnectionInvitationState = "INCOMPATIBLE_CONNECTION_INVITATION_STATE"
        case incompatibleConnectionPreferencesRevision = "INCOMPATIBLE_CONNECTION_PREFERENCES_REVISION"
        case incompatibleConnectionState = "INCOMPATIBLE_CONNECTION_STATE"
        case incompatiblePartnerProfileTaskState = "INCOMPATIBLE_PARTNER_PROFILE_TASK_STATE"
        case incompatibleProfileState = "INCOMPATIBLE_PROFILE_STATE"
        case verificationAlreadyInProgress = "VERIFICATION_ALREADY_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case opportunityCollaboration = "OPPORTUNITY_COLLABORATION"
        case subsidiary = "SUBSIDIARY"
        public var description: String { return self.rawValue }
    }

    public enum ConnectionTypeStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case canceled = "CANCELED"
        public var description: String { return self.rawValue }
    }

    public enum FieldValidationCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case actionNotPermitted = "ACTION_NOT_PERMITTED"
        case duplicateValue = "DUPLICATE_VALUE"
        case invalidEnumValue = "INVALID_ENUM_VALUE"
        case invalidStringFormat = "INVALID_STRING_FORMAT"
        case invalidValue = "INVALID_VALUE"
        case requiredFieldMissing = "REQUIRED_FIELD_MISSING"
        case tooManyValues = "TOO_MANY_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum IndustrySegment: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case agricultureMining = "AGRICULTURE_MINING"
        case biotechnology = "BIOTECHNOLOGY"
        case businessConsumerServices = "BUSINESS_CONSUMER_SERVICES"
        case businessServ = "BUSINESS_SERV"
        case communications = "COMMUNICATIONS"
        case computerHardware = "COMPUTER_HARDWARE"
        case computerSoftware = "COMPUTER_SOFTWARE"
        case computersElectronics = "COMPUTERS_ELECTRONICS"
        case consumerGoods = "CONSUMER_GOODS"
        case consumerRelated = "CONSUMER_RELATED"
        case education = "EDUCATION"
        case energyUtilities = "ENERGY_UTILITIES"
        case financialServices = "FINANCIAL_SERVICES"
        case gaming = "GAMING"
        case government = "GOVERNMENT"
        case governmentEducationPublicServices = "GOVERNMENT_EDUCATION_PUBLIC_SERVICES"
        case healthcare = "HEALTHCARE"
        case healthcarePharmaceuticalsBiotech = "HEALTHCARE_PHARMACEUTICALS_BIOTECH"
        case industrialEnergy = "INDUSTRIAL_ENERGY"
        case internetSpecific = "INTERNET_SPECIFIC"
        case lifeSciences = "LIFE_SCIENCES"
        case manufacturing = "MANUFACTURING"
        case mediaEntertainment = "MEDIA_ENTERTAINMENT"
        case mediaEntertainmentLeisure = "MEDIA_ENTERTAINMENT_LEISURE"
        case medicalHealth = "MEDICAL_HEALTH"
        case nonProfitOrganization = "NON_PROFIT_ORGANIZATION"
        case other = "OTHER"
        case professionalServices = "PROFESSIONAL_SERVICES"
        case realEstateConstruction = "REAL_ESTATE_CONSTRUCTION"
        case retail = "RETAIL"
        case retailWholesaleDistribution = "RETAIL_WHOLESALE_DISTRIBUTION"
        case semiconductorElectr = "SEMICONDUCTOR_ELECTR"
        case softwareInternet = "SOFTWARE_INTERNET"
        case telecommunications = "TELECOMMUNICATIONS"
        case transportationLogistics = "TRANSPORTATION_LOGISTICS"
        case travelHospitality = "TRAVEL_HOSPITALITY"
        case wholesaleDistribution = "WHOLESALE_DISTRIBUTION"
        public var description: String { return self.rawValue }
    }

    public enum InvitationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accepted = "ACCEPTED"
        case canceled = "CANCELED"
        case expired = "EXPIRED"
        case pending = "PENDING"
        case rejected = "REJECTED"
        public var description: String { return self.rawValue }
    }

    public enum ParticipantType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case receiver = "RECEIVER"
        case sender = "SENDER"
        public var description: String { return self.rawValue }
    }

    public enum PrimarySolutionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case communicationServices = "COMMUNICATION_SERVICES"
        case consultingServices = "CONSULTING_SERVICES"
        case hardwareProducts = "HARDWARE_PRODUCTS"
        case managedServices = "MANAGED_SERVICES"
        case professionalServices = "PROFESSIONAL_SERVICES"
        case softwareProducts = "SOFTWARE_PRODUCTS"
        case trainingServices = "TRAINING_SERVICES"
        case valueAddedResaleAwsServices = "VALUE_ADDED_RESALE_AWS_SERVICES"
        public var description: String { return self.rawValue }
    }

    public enum ProfileTaskStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case canceled = "CANCELED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum ProfileValidationErrorReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case duplicateProfile = "DUPLICATE_PROFILE"
        case invalidContent = "INVALID_CONTENT"
        case invalidLogo = "INVALID_LOGO"
        case invalidLogoFile = "INVALID_LOGO_FILE"
        case invalidLogoSize = "INVALID_LOGO_SIZE"
        case invalidLogoUrl = "INVALID_LOGO_URL"
        case invalidWebsiteUrl = "INVALID_WEBSITE_URL"
        public var description: String { return self.rawValue }
    }

    public enum ProfileVisibility: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `private` = "PRIVATE"
        case `public` = "PUBLIC"
        public var description: String { return self.rawValue }
    }

    public enum ResourceNotFoundExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case connectionInvitationNotFound = "CONNECTION_INVITATION_NOT_FOUND"
        case connectionNotFound = "CONNECTION_NOT_FOUND"
        case partnerDomainNotFound = "PARTNER_DOMAIN_NOT_FOUND"
        case partnerNotFound = "PARTNER_NOT_FOUND"
        case partnerProfileNotFound = "PARTNER_PROFILE_NOT_FOUND"
        case partnerProfileTaskNotFound = "PARTNER_PROFILE_TASK_NOT_FOUND"
        case receiverProfileNotFound = "RECEIVER_PROFILE_NOT_FOUND"
        case senderProfileNotFound = "SENDER_PROFILE_NOT_FOUND"
        case verificationNotFound = "VERIFICATION_NOT_FOUND"
        public var description: String { return self.rawValue }
    }

    public enum ServiceQuotaExceededExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case limitExceededNumberOfDomain = "LIMIT_EXCEEDED_NUMBER_OF_DOMAIN"
        case limitExceededNumberOfEmail = "LIMIT_EXCEEDED_NUMBER_OF_EMAIL"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessValidationFailed = "BUSINESS_VALIDATION_FAILED"
        case requestValidationFailed = "REQUEST_VALIDATION_FAILED"
        public var description: String { return self.rawValue }
    }

    public enum VerificationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pendingCustomerAction = "PENDING_CUSTOMER_ACTION"
        case rejected = "REJECTED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum VerificationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case businessVerification = "BUSINESS_VERIFICATION"
        case registrantVerification = "REGISTRANT_VERIFICATION"
        public var description: String { return self.rawValue }
    }

    public enum Participant: AWSDecodableShape, Sendable {
        /// The AWS account information for the participant.
        case account(AccountSummary)
        /// The partner profile information for the participant.
        case partnerProfile(PartnerProfileSummary)
        /// The seller profile information for the participant.
        case sellerProfile(SellerProfileSummary)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .account:
                let value = try container.decode(AccountSummary.self, forKey: .account)
                self = .account(value)
            case .partnerProfile:
                let value = try container.decode(PartnerProfileSummary.self, forKey: .partnerProfile)
                self = .partnerProfile(value)
            case .sellerProfile:
                let value = try container.decode(SellerProfileSummary.self, forKey: .sellerProfile)
                self = .sellerProfile(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case account = "Account"
            case partnerProfile = "PartnerProfile"
            case sellerProfile = "SellerProfile"
        }
    }

    public enum ValidationError: AWSDecodableShape, Sendable {
        /// Details about a business rule validation error, if applicable.
        case businessValidationError(BusinessValidationError)
        /// Details about a field-level validation error, if applicable.
        case fieldValidationError(FieldValidationError)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .businessValidationError:
                let value = try container.decode(BusinessValidationError.self, forKey: .businessValidationError)
                self = .businessValidationError(value)
            case .fieldValidationError:
                let value = try container.decode(FieldValidationError.self, forKey: .fieldValidationError)
                self = .fieldValidationError(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case businessValidationError = "BusinessValidationError"
            case fieldValidationError = "FieldValidationError"
        }
    }

    public enum VerificationDetails: AWSEncodableShape, Sendable {
        /// The business verification details to be used when starting a business verification process.
        case businessVerificationDetails(BusinessVerificationDetails)
        /// The registrant verification details to be used when starting an individual identity verification process.
        case registrantVerificationDetails(RegistrantVerificationDetails)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .businessVerificationDetails(let value):
                try container.encode(value, forKey: .businessVerificationDetails)
            case .registrantVerificationDetails(let value):
                try container.encode(value, forKey: .registrantVerificationDetails)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .businessVerificationDetails(let value):
                try value.validate(name: "\(name).businessVerificationDetails")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case businessVerificationDetails = "BusinessVerificationDetails"
            case registrantVerificationDetails = "RegistrantVerificationDetails"
        }
    }

    public enum VerificationResponseDetails: AWSDecodableShape, Sendable {
        /// The response details from a business verification process, including verification results and any additional business information discovered.
        case businessVerificationResponse(BusinessVerificationResponse)
        /// The response details from a registrant verification process, including verification results and any additional steps required for identity confirmation.
        case registrantVerificationResponse(RegistrantVerificationResponse)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .businessVerificationResponse:
                let value = try container.decode(BusinessVerificationResponse.self, forKey: .businessVerificationResponse)
                self = .businessVerificationResponse(value)
            case .registrantVerificationResponse:
                let value = try container.decode(RegistrantVerificationResponse.self, forKey: .registrantVerificationResponse)
                self = .registrantVerificationResponse(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case businessVerificationResponse = "BusinessVerificationResponse"
            case registrantVerificationResponse = "RegistrantVerificationResponse"
        }
    }

    // MARK: Shapes

    public struct AcceptConnectionInvitationRequest: AWSEncodableShape {
        /// The catalog identifier where the connection invitation exists.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String
        /// The unique identifier of the connection invitation to accept.
        public let identifier: String

        @inlinable
        public init(catalog: String, clientToken: String = AcceptConnectionInvitationRequest.idempotencyToken(), identifier: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^pacinv-[A-Za-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
        }
    }

    public struct AcceptConnectionInvitationResponse: AWSDecodableShape {
        /// The details of the accepted connection between the two partners.
        public let connection: Connection

        @inlinable
        public init(connection: Connection) {
            self.connection = connection
        }

        private enum CodingKeys: String, CodingKey {
            case connection = "Connection"
        }
    }

    public struct AccessDeniedException: AWSErrorShape {
        public let message: String
        /// The specific reason for the access denial.
        public let reason: AccessDeniedExceptionReason

        @inlinable
        public init(message: String, reason: AccessDeniedExceptionReason) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct AccountSummary: AWSDecodableShape {
        /// The name associated with the AWS account.
        public let name: String

        @inlinable
        public init(name: String) {
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
        }
    }

    public struct AllianceLeadContact: AWSEncodableShape & AWSDecodableShape {
        /// The business title or role of the alliance lead contact person.
        public let businessTitle: String
        /// The email address of the alliance lead contact person.
        public let email: String
        /// The first name of the alliance lead contact person.
        public let firstName: String
        /// The last name of the alliance lead contact person.
        public let lastName: String

        @inlinable
        public init(businessTitle: String, email: String, firstName: String, lastName: String) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
        }

        public func validate(name: String) throws {
            try self.validate(self.businessTitle, name: "businessTitle", parent: name, max: 80)
            try self.validate(self.businessTitle, name: "businessTitle", parent: name, min: 1)
            try self.validate(self.businessTitle, name: "businessTitle", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.email, name: "email", parent: name, max: 320)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 80)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 80)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case businessTitle = "BusinessTitle"
            case email = "Email"
            case firstName = "FirstName"
            case lastName = "LastName"
        }
    }

    public struct AssociateAwsTrainingCertificationEmailDomainRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The email address used to verify domain ownership for AWS training and certification association.
        public let email: String
        /// The verification code sent to the email address to confirm domain ownership.
        public let emailVerificationCode: String
        /// The unique identifier of the partner account.
        public let identifier: String

        @inlinable
        public init(catalog: String, clientToken: String? = AssociateAwsTrainingCertificationEmailDomainRequest.idempotencyToken(), email: String, emailVerificationCode: String, identifier: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.email = email
            self.emailVerificationCode = emailVerificationCode
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.email, name: "email", parent: name, max: 320)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, max: 6)
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, min: 6)
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case email = "Email"
            case emailVerificationCode = "EmailVerificationCode"
            case identifier = "Identifier"
        }
    }

    public struct AssociateAwsTrainingCertificationEmailDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct BusinessValidationError: AWSDecodableShape {
        /// A code identifying the specific business validation error.
        public let code: BusinessValidationCode
        /// A description of the business validation error.
        public let message: String

        @inlinable
        public init(code: BusinessValidationCode, message: String) {
            self.code = code
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
        }
    }

    public struct BusinessVerificationDetails: AWSEncodableShape & AWSDecodableShape {
        /// The ISO 3166-1 alpha-2 country code where the business is legally registered and operates.
        public let countryCode: String
        /// The specific legal jurisdiction or state where the business was incorporated or registered, providing additional location context beyond the country code.
        public let jurisdictionOfIncorporation: String?
        /// The official legal name of the business as registered with the appropriate government authorities.
        public let legalName: String
        /// The unique business registration identifier assigned by the government or regulatory authority, such as a company registration number or tax identification number.
        public let registrationId: String

        @inlinable
        public init(countryCode: String, jurisdictionOfIncorporation: String? = nil, legalName: String, registrationId: String) {
            self.countryCode = countryCode
            self.jurisdictionOfIncorporation = jurisdictionOfIncorporation
            self.legalName = legalName
            self.registrationId = registrationId
        }

        public func validate(name: String) throws {
            try self.validate(self.countryCode, name: "countryCode", parent: name, max: 2)
            try self.validate(self.countryCode, name: "countryCode", parent: name, min: 2)
            try self.validate(self.countryCode, name: "countryCode", parent: name, pattern: "^[A-Z]{2}$")
            try self.validate(self.jurisdictionOfIncorporation, name: "jurisdictionOfIncorporation", parent: name, max: 2)
            try self.validate(self.jurisdictionOfIncorporation, name: "jurisdictionOfIncorporation", parent: name, min: 2)
            try self.validate(self.jurisdictionOfIncorporation, name: "jurisdictionOfIncorporation", parent: name, pattern: "^[A-Z0-9]{2}$")
            try self.validate(self.legalName, name: "legalName", parent: name, max: 80)
            try self.validate(self.legalName, name: "legalName", parent: name, min: 1)
            try self.validate(self.legalName, name: "legalName", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.registrationId, name: "registrationId", parent: name, max: 80)
            try self.validate(self.registrationId, name: "registrationId", parent: name, min: 1)
            try self.validate(self.registrationId, name: "registrationId", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case countryCode = "CountryCode"
            case jurisdictionOfIncorporation = "JurisdictionOfIncorporation"
            case legalName = "LegalName"
            case registrationId = "RegistrationId"
        }
    }

    public struct BusinessVerificationResponse: AWSDecodableShape {
        /// The business verification details that were processed and verified, potentially including additional information discovered during the verification process.
        public let businessVerificationDetails: BusinessVerificationDetails

        @inlinable
        public init(businessVerificationDetails: BusinessVerificationDetails) {
            self.businessVerificationDetails = businessVerificationDetails
        }

        private enum CodingKeys: String, CodingKey {
            case businessVerificationDetails = "BusinessVerificationDetails"
        }
    }

    public struct CancelConnectionInvitationRequest: AWSEncodableShape {
        /// The catalog identifier where the connection invitation exists.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String
        /// The unique identifier of the connection invitation to cancel.
        public let identifier: String

        @inlinable
        public init(catalog: String, clientToken: String = CancelConnectionInvitationRequest.idempotencyToken(), identifier: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^pacinv-[A-Za-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
        }
    }

    public struct CancelConnectionInvitationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the canceled connection invitation.
        public let arn: String
        /// The catalog identifier where the connection invitation was canceled.
        public let catalog: String
        /// The identifier of the connection associated with the canceled invitation.
        public let connectionId: String?
        /// The type of connection that was being invited for.
        public let connectionType: ConnectionType
        /// The timestamp when the connection invitation was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the connection invitation would have expired if not canceled.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The unique identifier of the canceled connection invitation.
        public let id: String
        /// The message that was included with the original connection invitation.
        public let invitationMessage: String
        /// The email address of the person who sent the connection invitation.
        public let inviterEmail: String
        /// The name of the person who sent the connection invitation.
        public let inviterName: String
        /// The identifier of the other participant who was invited to connect.
        public let otherParticipantIdentifier: String
        /// The type of participant (inviter or invitee) in the connection invitation.
        public let participantType: ParticipantType
        /// The current status of the connection invitation (canceled).
        public let status: InvitationStatus
        /// The timestamp when the connection invitation was last updated (canceled).
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionId: String? = nil, connectionType: ConnectionType, createdAt: Date, expiresAt: Date? = nil, id: String, invitationMessage: String, inviterEmail: String, inviterName: String, otherParticipantIdentifier: String, participantType: ParticipantType, status: InvitationStatus, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.invitationMessage = invitationMessage
            self.inviterEmail = inviterEmail
            self.inviterName = inviterName
            self.otherParticipantIdentifier = otherParticipantIdentifier
            self.participantType = participantType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionId = "ConnectionId"
            case connectionType = "ConnectionType"
            case createdAt = "CreatedAt"
            case expiresAt = "ExpiresAt"
            case id = "Id"
            case invitationMessage = "InvitationMessage"
            case inviterEmail = "InviterEmail"
            case inviterName = "InviterName"
            case otherParticipantIdentifier = "OtherParticipantIdentifier"
            case participantType = "ParticipantType"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CancelConnectionRequest: AWSEncodableShape {
        /// The catalog identifier where the connection exists.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String
        /// The type of connection to cancel (e.g., reseller, distributor, technology partner).
        public let connectionType: ConnectionType
        /// The unique identifier of the connection to cancel.
        public let identifier: String
        /// The reason for canceling the connection, providing context for the termination.
        public let reason: String

        @inlinable
        public init(catalog: String, clientToken: String = CancelConnectionRequest.idempotencyToken(), connectionType: ConnectionType, identifier: String, reason: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.connectionType = connectionType
            self.identifier = identifier
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^pac-[A-Za-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case connectionType = "ConnectionType"
            case identifier = "Identifier"
            case reason = "Reason"
        }
    }

    public struct CancelConnectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the canceled connection.
        public let arn: String
        /// The catalog identifier where the connection was canceled.
        public let catalog: String
        /// The list of connection types that were active before cancellation.
        public let connectionTypes: [ConnectionType: ConnectionTypeDetail]
        /// The unique identifier of the canceled connection.
        public let id: String
        /// The AWS account ID of the other participant in the canceled connection.
        public let otherParticipantAccountId: String
        /// The timestamp when the connection was last updated (canceled).
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionTypes: [ConnectionType: ConnectionTypeDetail], id: String, otherParticipantAccountId: String, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionTypes = connectionTypes
            self.id = id
            self.otherParticipantAccountId = otherParticipantAccountId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionTypes = "ConnectionTypes"
            case id = "Id"
            case otherParticipantAccountId = "OtherParticipantAccountId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CancelProfileUpdateTaskRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the partner account.
        public let identifier: String
        /// The unique identifier of the profile update task to cancel.
        public let taskId: String

        @inlinable
        public init(catalog: String, clientToken: String? = CancelProfileUpdateTaskRequest.idempotencyToken(), identifier: String, taskId: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
            self.taskId = taskId
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
            try self.validate(self.taskId, name: "taskId", parent: name, max: 80)
            try self.validate(self.taskId, name: "taskId", parent: name, min: 1)
            try self.validate(self.taskId, name: "taskId", parent: name, pattern: "^pprofiletask-[A-Za-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
            case taskId = "TaskId"
        }
    }

    public struct CancelProfileUpdateTaskResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the canceled profile update task.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The timestamp when the profile update task was ended (canceled).
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// A list of error details if any errors occurred during the profile update task.
        public let errorDetailList: [ErrorDetail]?
        /// The unique identifier of the partner account.
        public let id: String
        /// The timestamp when the profile update task was started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// The current status of the profile update task (canceled).
        public let status: ProfileTaskStatus
        /// The details of the profile update task that was canceled.
        public let taskDetails: TaskDetails
        /// The unique identifier of the canceled profile update task.
        public let taskId: String

        @inlinable
        public init(arn: String, catalog: String, endedAt: Date? = nil, errorDetailList: [ErrorDetail]? = nil, id: String, startedAt: Date, status: ProfileTaskStatus, taskDetails: TaskDetails, taskId: String) {
            self.arn = arn
            self.catalog = catalog
            self.endedAt = endedAt
            self.errorDetailList = errorDetailList
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.taskDetails = taskDetails
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case endedAt = "EndedAt"
            case errorDetailList = "ErrorDetailList"
            case id = "Id"
            case startedAt = "StartedAt"
            case status = "Status"
            case taskDetails = "TaskDetails"
            case taskId = "TaskId"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The specific reason for the conflict.
        public let reason: ConflictExceptionReason

        @inlinable
        public init(message: String, reason: ConflictExceptionReason) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct Connection: AWSDecodableShape {
        /// The AWS Resource Name (ARN) of the connection.
        public let arn: String
        /// The catalog identifier that the connection belongs to.
        public let catalog: String
        /// The type of connection.
        public let connectionTypes: [ConnectionType: ConnectionTypeDetail]
        /// The unique identifier of the connection.
        public let id: String
        /// The AWS account ID of the other participant in the connection.
        public let otherParticipantAccountId: String
        /// The timestamp when the connection was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionTypes: [ConnectionType: ConnectionTypeDetail], id: String, otherParticipantAccountId: String, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionTypes = connectionTypes
            self.id = id
            self.otherParticipantAccountId = otherParticipantAccountId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionTypes = "ConnectionTypes"
            case id = "Id"
            case otherParticipantAccountId = "OtherParticipantAccountId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ConnectionInvitationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connection invitation.
        public let arn: String
        /// The catalog identifier where the connection invitation exists.
        public let catalog: String
        /// The identifier of the connection associated with this invitation.
        public let connectionId: String?
        /// The type of connection being requested in the invitation.
        public let connectionType: ConnectionType
        /// The timestamp when the connection invitation was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the connection invitation will expire.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The unique identifier of the connection invitation.
        public let id: String
        /// The identifier of the other participant in the connection invitation.
        public let otherParticipantIdentifier: String
        /// The type of participant (inviter or invitee) in the connection invitation.
        public let participantType: ParticipantType
        /// The current status of the connection invitation.
        public let status: InvitationStatus
        /// The timestamp when the connection invitation was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionId: String? = nil, connectionType: ConnectionType, createdAt: Date, expiresAt: Date? = nil, id: String, otherParticipantIdentifier: String, participantType: ParticipantType, status: InvitationStatus, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.otherParticipantIdentifier = otherParticipantIdentifier
            self.participantType = participantType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionId = "ConnectionId"
            case connectionType = "ConnectionType"
            case createdAt = "CreatedAt"
            case expiresAt = "ExpiresAt"
            case id = "Id"
            case otherParticipantIdentifier = "OtherParticipantIdentifier"
            case participantType = "ParticipantType"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ConnectionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connection.
        public let arn: String
        /// The catalog identifier where the connection exists.
        public let catalog: String
        /// A map of connection types and their summary information for this connection.
        public let connectionTypes: [ConnectionType: ConnectionTypeSummary]
        /// The unique identifier of the connection.
        public let id: String
        /// The AWS account ID of the other participant in the connection.
        public let otherParticipantAccountId: String
        /// The timestamp when the connection was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionTypes: [ConnectionType: ConnectionTypeSummary], id: String, otherParticipantAccountId: String, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionTypes = connectionTypes
            self.id = id
            self.otherParticipantAccountId = otherParticipantAccountId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionTypes = "ConnectionTypes"
            case id = "Id"
            case otherParticipantAccountId = "OtherParticipantAccountId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ConnectionTypeDetail: AWSDecodableShape {
        /// The timestamp when this connection type was cancelled, if applicable.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var canceledAt: Date?
        /// The AWS account ID of the participant who cancelled this connection type.
        public let canceledBy: String?
        /// The timestamp when this connection type was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The email address of the person who initiated this connection type.
        public let inviterEmail: String
        /// The name of the person who initiated this connection type.
        public let inviterName: String
        /// Information about the other participant in this connection type.
        public let otherParticipant: Participant
        /// The current status of this connection type.
        public let status: ConnectionTypeStatus

        @inlinable
        public init(canceledAt: Date? = nil, canceledBy: String? = nil, createdAt: Date, inviterEmail: String, inviterName: String, otherParticipant: Participant, status: ConnectionTypeStatus) {
            self.canceledAt = canceledAt
            self.canceledBy = canceledBy
            self.createdAt = createdAt
            self.inviterEmail = inviterEmail
            self.inviterName = inviterName
            self.otherParticipant = otherParticipant
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case canceledAt = "CanceledAt"
            case canceledBy = "CanceledBy"
            case createdAt = "CreatedAt"
            case inviterEmail = "InviterEmail"
            case inviterName = "InviterName"
            case otherParticipant = "OtherParticipant"
            case status = "Status"
        }
    }

    public struct ConnectionTypeSummary: AWSDecodableShape {
        /// Information about the other participant in this connection type.
        public let otherParticipant: Participant
        /// The current status of this connection type (active, canceled, etc.).
        public let status: ConnectionTypeStatus

        @inlinable
        public init(otherParticipant: Participant, status: ConnectionTypeStatus) {
            self.otherParticipant = otherParticipant
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case otherParticipant = "OtherParticipant"
            case status = "Status"
        }
    }

    public struct CreateConnectionInvitationRequest: AWSEncodableShape {
        /// The catalog identifier where the connection invitation will be created.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String
        /// The type of connection being requested (e.g., reseller, distributor, technology partner).
        public let connectionType: ConnectionType
        /// The email address of the person to send the connection invitation to.
        public let email: String
        /// A custom message to include with the connection invitation.
        public let message: String
        /// The name of the person sending the connection invitation.
        public let name: String
        /// The identifier of the organization or partner to invite for connection.
        public let receiverIdentifier: String

        @inlinable
        public init(catalog: String, clientToken: String = CreateConnectionInvitationRequest.idempotencyToken(), connectionType: ConnectionType, email: String, message: String, name: String, receiverIdentifier: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.connectionType = connectionType
            self.email = email
            self.message = message
            self.name = name
            self.receiverIdentifier = receiverIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.email, name: "email", parent: name, max: 320)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
            try self.validate(self.message, name: "message", parent: name, max: 80)
            try self.validate(self.message, name: "message", parent: name, min: 1)
            try self.validate(self.message, name: "message", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.name, name: "name", parent: name, max: 80)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.receiverIdentifier, name: "receiverIdentifier", parent: name, max: 100)
            try self.validate(self.receiverIdentifier, name: "receiverIdentifier", parent: name, min: 1)
            try self.validate(self.receiverIdentifier, name: "receiverIdentifier", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case connectionType = "ConnectionType"
            case email = "Email"
            case message = "Message"
            case name = "Name"
            case receiverIdentifier = "ReceiverIdentifier"
        }
    }

    public struct CreateConnectionInvitationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created connection invitation.
        public let arn: String
        /// The catalog identifier where the connection invitation was created.
        public let catalog: String
        /// The identifier of the connection associated with this invitation.
        public let connectionId: String?
        /// The type of connection being requested in the invitation.
        public let connectionType: ConnectionType
        /// The timestamp when the connection invitation was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the connection invitation will expire if not responded to.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The unique identifier of the created connection invitation.
        public let id: String
        /// The custom message included with the connection invitation.
        public let invitationMessage: String
        /// The email address of the person who sent the connection invitation.
        public let inviterEmail: String
        /// The name of the person who sent the connection invitation.
        public let inviterName: String
        /// The identifier of the organization or partner being invited.
        public let otherParticipantIdentifier: String
        /// The type of participant (inviter or invitee) in the connection invitation.
        public let participantType: ParticipantType
        /// The current status of the connection invitation (pending, accepted, rejected, etc.).
        public let status: InvitationStatus
        /// The timestamp when the connection invitation was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionId: String? = nil, connectionType: ConnectionType, createdAt: Date, expiresAt: Date? = nil, id: String, invitationMessage: String, inviterEmail: String, inviterName: String, otherParticipantIdentifier: String, participantType: ParticipantType, status: InvitationStatus, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.invitationMessage = invitationMessage
            self.inviterEmail = inviterEmail
            self.inviterName = inviterName
            self.otherParticipantIdentifier = otherParticipantIdentifier
            self.participantType = participantType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionId = "ConnectionId"
            case connectionType = "ConnectionType"
            case createdAt = "CreatedAt"
            case expiresAt = "ExpiresAt"
            case id = "Id"
            case invitationMessage = "InvitationMessage"
            case inviterEmail = "InviterEmail"
            case inviterName = "InviterName"
            case otherParticipantIdentifier = "OtherParticipantIdentifier"
            case participantType = "ParticipantType"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct CreatePartnerRequest: AWSEncodableShape {
        /// The primary contact person for alliance and partnership matters.
        public let allianceLeadContact: AllianceLeadContact
        /// The catalog identifier where the partner account will be created.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The verification code sent to the alliance lead contact's email to confirm account creation.
        public let emailVerificationCode: String
        /// The legal name of the organization becoming a partner.
        public let legalName: String
        /// The primary type of solution or service the partner provides (e.g., consulting, software, managed services).
        public let primarySolutionType: PrimarySolutionType
        /// A list of tags to associate with the partner account for organization and billing purposes.
        public let tags: [Tag]?

        @inlinable
        public init(allianceLeadContact: AllianceLeadContact, catalog: String, clientToken: String? = CreatePartnerRequest.idempotencyToken(), emailVerificationCode: String, legalName: String, primarySolutionType: PrimarySolutionType, tags: [Tag]? = nil) {
            self.allianceLeadContact = allianceLeadContact
            self.catalog = catalog
            self.clientToken = clientToken
            self.emailVerificationCode = emailVerificationCode
            self.legalName = legalName
            self.primarySolutionType = primarySolutionType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.allianceLeadContact.validate(name: "\(name).allianceLeadContact")
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, max: 6)
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, min: 6)
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.legalName, name: "legalName", parent: name, max: 80)
            try self.validate(self.legalName, name: "legalName", parent: name, min: 1)
            try self.validate(self.legalName, name: "legalName", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case allianceLeadContact = "AllianceLeadContact"
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case emailVerificationCode = "EmailVerificationCode"
            case legalName = "LegalName"
            case primarySolutionType = "PrimarySolutionType"
            case tags = "Tags"
        }
    }

    public struct CreatePartnerResponse: AWSDecodableShape {
        /// The alliance lead contact information for the partner account.
        public let allianceLeadContact: AllianceLeadContact
        /// The Amazon Resource Name (ARN) of the created partner account.
        public let arn: String
        /// The list of verified email domains associated with AWS training and certification credentials for the partner organization.
        public let awsTrainingCertificationEmailDomains: [PartnerDomain]?
        /// The catalog identifier where the partner account was created.
        public let catalog: String
        /// The timestamp when the partner account was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the created partner account.
        public let id: String
        /// The legal name of the partner organization.
        public let legalName: String
        /// The partner profile information including display name, description, and other public details.
        public let profile: PartnerProfile

        @inlinable
        public init(allianceLeadContact: AllianceLeadContact, arn: String, awsTrainingCertificationEmailDomains: [PartnerDomain]? = nil, catalog: String, createdAt: Date, id: String, legalName: String, profile: PartnerProfile) {
            self.allianceLeadContact = allianceLeadContact
            self.arn = arn
            self.awsTrainingCertificationEmailDomains = awsTrainingCertificationEmailDomains
            self.catalog = catalog
            self.createdAt = createdAt
            self.id = id
            self.legalName = legalName
            self.profile = profile
        }

        private enum CodingKeys: String, CodingKey {
            case allianceLeadContact = "AllianceLeadContact"
            case arn = "Arn"
            case awsTrainingCertificationEmailDomains = "AwsTrainingCertificationEmailDomains"
            case catalog = "Catalog"
            case createdAt = "CreatedAt"
            case id = "Id"
            case legalName = "LegalName"
            case profile = "Profile"
        }
    }

    public struct DisassociateAwsTrainingCertificationEmailDomainRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The domain name to disassociate from AWS training and certification.
        public let domainName: String
        /// The unique identifier of the partner account.
        public let identifier: String

        @inlinable
        public init(catalog: String, clientToken: String? = DisassociateAwsTrainingCertificationEmailDomainRequest.idempotencyToken(), domainName: String, identifier: String) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.domainName = domainName
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.domainName, name: "domainName", parent: name, max: 253)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case domainName = "DomainName"
            case identifier = "Identifier"
        }
    }

    public struct DisassociateAwsTrainingCertificationEmailDomainResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// The locale or language code for the error message.
        public let locale: String
        /// A human-readable description of the error.
        public let message: String
        /// A machine-readable code or reason for the error.
        public let reason: ProfileValidationErrorReason

        @inlinable
        public init(locale: String, message: String, reason: ProfileValidationErrorReason) {
            self.locale = locale
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "Locale"
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct FieldValidationError: AWSDecodableShape {
        /// A code identifying the specific field validation error.
        public let code: FieldValidationCode
        /// A description of the field validation error.
        public let message: String
        /// The name of the field that failed validation.
        public let name: String

        @inlinable
        public init(code: FieldValidationCode, message: String, name: String) {
            self.code = code
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case code = "Code"
            case message = "Message"
            case name = "Name"
        }
    }

    public struct GetAllianceLeadContactRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetAllianceLeadContactResponse: AWSDecodableShape {
        /// The alliance lead contact information including name, email, and business title.
        public let allianceLeadContact: AllianceLeadContact
        /// The Amazon Resource Name (ARN) of the partner account.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let id: String

        @inlinable
        public init(allianceLeadContact: AllianceLeadContact, arn: String, catalog: String, id: String) {
            self.allianceLeadContact = allianceLeadContact
            self.arn = arn
            self.catalog = catalog
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case allianceLeadContact = "AllianceLeadContact"
            case arn = "Arn"
            case catalog = "Catalog"
            case id = "Id"
        }
    }

    public struct GetConnectionInvitationRequest: AWSEncodableShape {
        /// The catalog identifier where the connection invitation exists.
        public let catalog: String
        /// The unique identifier of the connection invitation to retrieve.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^pacinv-[A-Za-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetConnectionInvitationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connection invitation.
        public let arn: String
        /// The catalog identifier where the connection invitation exists.
        public let catalog: String
        /// The identifier of the connection associated with this invitation.
        public let connectionId: String?
        /// The type of connection being requested in the invitation.
        public let connectionType: ConnectionType
        /// The timestamp when the connection invitation was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the connection invitation will expire.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The unique identifier of the connection invitation.
        public let id: String
        /// The custom message included with the connection invitation.
        public let invitationMessage: String
        /// The email address of the person who sent the connection invitation.
        public let inviterEmail: String
        /// The name of the person who sent the connection invitation.
        public let inviterName: String
        /// The identifier of the other participant in the connection invitation.
        public let otherParticipantIdentifier: String
        /// The type of participant (inviter or invitee) in the connection invitation.
        public let participantType: ParticipantType
        /// The current status of the connection invitation.
        public let status: InvitationStatus
        /// The timestamp when the connection invitation was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionId: String? = nil, connectionType: ConnectionType, createdAt: Date, expiresAt: Date? = nil, id: String, invitationMessage: String, inviterEmail: String, inviterName: String, otherParticipantIdentifier: String, participantType: ParticipantType, status: InvitationStatus, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.invitationMessage = invitationMessage
            self.inviterEmail = inviterEmail
            self.inviterName = inviterName
            self.otherParticipantIdentifier = otherParticipantIdentifier
            self.participantType = participantType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionId = "ConnectionId"
            case connectionType = "ConnectionType"
            case createdAt = "CreatedAt"
            case expiresAt = "ExpiresAt"
            case id = "Id"
            case invitationMessage = "InvitationMessage"
            case inviterEmail = "InviterEmail"
            case inviterName = "InviterName"
            case otherParticipantIdentifier = "OtherParticipantIdentifier"
            case participantType = "ParticipantType"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetConnectionPreferencesRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String

        @inlinable
        public init(catalog: String) {
            self.catalog = catalog
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
        }
    }

    public struct GetConnectionPreferencesResponse: AWSDecodableShape {
        /// The access type setting for connections (e.g., open, restricted, invitation-only).
        public let accessType: AccessType
        /// The Amazon Resource Name (ARN) of the connection preferences.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// A list of participant IDs that are excluded from connection requests or interactions.
        public let excludedParticipantIds: [String]?
        /// The revision number of the connection preferences for optimistic locking.
        public let revision: Int64
        /// The timestamp when the connection preferences were last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(accessType: AccessType, arn: String, catalog: String, excludedParticipantIds: [String]? = nil, revision: Int64, updatedAt: Date) {
            self.accessType = accessType
            self.arn = arn
            self.catalog = catalog
            self.excludedParticipantIds = excludedParticipantIds
            self.revision = revision
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accessType = "AccessType"
            case arn = "Arn"
            case catalog = "Catalog"
            case excludedParticipantIds = "ExcludedParticipantIds"
            case revision = "Revision"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetConnectionRequest: AWSEncodableShape {
        /// The catalog identifier where the connection exists.
        public let catalog: String
        /// The unique identifier of the connection to retrieve.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^pac-[A-Za-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetConnectionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the connection.
        public let arn: String
        /// The catalog identifier where the connection exists.
        public let catalog: String
        /// The list of connection types active between the partners.
        public let connectionTypes: [ConnectionType: ConnectionTypeDetail]
        /// The unique identifier of the connection.
        public let id: String
        /// The AWS account ID of the other participant in the connection.
        public let otherParticipantAccountId: String
        /// The timestamp when the connection was last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionTypes: [ConnectionType: ConnectionTypeDetail], id: String, otherParticipantAccountId: String, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionTypes = connectionTypes
            self.id = id
            self.otherParticipantAccountId = otherParticipantAccountId
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionTypes = "ConnectionTypes"
            case id = "Id"
            case otherParticipantAccountId = "OtherParticipantAccountId"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct GetPartnerRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account to retrieve.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetPartnerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the partner account.
        public let arn: String
        /// The list of verified email domains associated with AWS training and certification credentials for the partner organization.
        public let awsTrainingCertificationEmailDomains: [PartnerDomain]?
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The timestamp when the partner account was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the partner account.
        public let id: String
        /// The legal name of the partner organization.
        public let legalName: String
        /// The partner profile information including display name, description, and other public details.
        public let profile: PartnerProfile

        @inlinable
        public init(arn: String, awsTrainingCertificationEmailDomains: [PartnerDomain]? = nil, catalog: String, createdAt: Date, id: String, legalName: String, profile: PartnerProfile) {
            self.arn = arn
            self.awsTrainingCertificationEmailDomains = awsTrainingCertificationEmailDomains
            self.catalog = catalog
            self.createdAt = createdAt
            self.id = id
            self.legalName = legalName
            self.profile = profile
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case awsTrainingCertificationEmailDomains = "AwsTrainingCertificationEmailDomains"
            case catalog = "Catalog"
            case createdAt = "CreatedAt"
            case id = "Id"
            case legalName = "LegalName"
            case profile = "Profile"
        }
    }

    public struct GetProfileUpdateTaskRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetProfileUpdateTaskResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the profile update task.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The timestamp when the profile update task was completed or failed.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// A list of error details if any errors occurred during the profile update task.
        public let errorDetailList: [ErrorDetail]?
        /// The unique identifier of the partner account.
        public let id: String
        /// The timestamp when the profile update task was started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// The current status of the profile update task (in progress, completed, failed, etc.).
        public let status: ProfileTaskStatus
        /// The details of the profile update task including what changes are being made.
        public let taskDetails: TaskDetails
        /// The unique identifier of the profile update task.
        public let taskId: String

        @inlinable
        public init(arn: String, catalog: String, endedAt: Date? = nil, errorDetailList: [ErrorDetail]? = nil, id: String, startedAt: Date, status: ProfileTaskStatus, taskDetails: TaskDetails, taskId: String) {
            self.arn = arn
            self.catalog = catalog
            self.endedAt = endedAt
            self.errorDetailList = errorDetailList
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.taskDetails = taskDetails
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case endedAt = "EndedAt"
            case errorDetailList = "ErrorDetailList"
            case id = "Id"
            case startedAt = "StartedAt"
            case status = "Status"
            case taskDetails = "TaskDetails"
            case taskId = "TaskId"
        }
    }

    public struct GetProfileVisibilityRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let identifier: String

        @inlinable
        public init(catalog: String, identifier: String) {
            self.catalog = catalog
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
        }
    }

    public struct GetProfileVisibilityResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the partner account.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let id: String
        /// The unique identifier of the partner profile.
        public let profileId: String
        /// The visibility setting for the partner profile (public, private, restricted, etc.).
        public let visibility: ProfileVisibility

        @inlinable
        public init(arn: String, catalog: String, id: String, profileId: String, visibility: ProfileVisibility) {
            self.arn = arn
            self.catalog = catalog
            self.id = id
            self.profileId = profileId
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case id = "Id"
            case profileId = "ProfileId"
            case visibility = "Visibility"
        }
    }

    public struct GetVerificationRequest: AWSEncodableShape {
        /// The type of verification to retrieve information for. Valid values include business verification for company registration details and registrant verification for individual identity confirmation.
        public let verificationType: VerificationType

        @inlinable
        public init(verificationType: VerificationType) {
            self.verificationType = verificationType
        }

        private enum CodingKeys: String, CodingKey {
            case verificationType = "VerificationType"
        }
    }

    public struct GetVerificationResponse: AWSDecodableShape {
        /// The timestamp when the verification process was completed. This field is null if the verification is still in progress.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedAt: Date?
        /// The timestamp when the verification process was initiated.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Detailed response information specific to the type of verification performed, including any verification-specific data or results.
        public let verificationResponseDetails: VerificationResponseDetails
        /// The current status of the verification process. Possible values include pending, in-progress, completed, failed, or expired.
        public let verificationStatus: VerificationStatus
        /// Additional information explaining the current verification status, particularly useful when the status indicates a failure or requires additional action.
        public let verificationStatusReason: String?
        /// The type of verification that was requested and processed.
        public let verificationType: VerificationType

        @inlinable
        public init(completedAt: Date? = nil, startedAt: Date, verificationResponseDetails: VerificationResponseDetails, verificationStatus: VerificationStatus, verificationStatusReason: String? = nil, verificationType: VerificationType) {
            self.completedAt = completedAt
            self.startedAt = startedAt
            self.verificationResponseDetails = verificationResponseDetails
            self.verificationStatus = verificationStatus
            self.verificationStatusReason = verificationStatusReason
            self.verificationType = verificationType
        }

        private enum CodingKeys: String, CodingKey {
            case completedAt = "CompletedAt"
            case startedAt = "StartedAt"
            case verificationResponseDetails = "VerificationResponseDetails"
            case verificationStatus = "VerificationStatus"
            case verificationStatusReason = "VerificationStatusReason"
            case verificationType = "VerificationType"
        }
    }

    public struct ListConnectionInvitationsRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// Filter results by connection type (e.g., reseller, distributor, technology partner).
        public let connectionType: ConnectionType?
        /// The maximum number of connection invitations to return in a single response.
        public let maxResults: Int?
        /// The token for retrieving the next page of results in paginated responses.
        public let nextToken: String?
        /// Filter results by specific participant identifiers.
        public let otherParticipantIdentifiers: [String]?
        /// Filter results by participant type (inviter or invitee).
        public let participantType: ParticipantType?
        /// Filter results by invitation status (pending, accepted, rejected, canceled, expired).
        public let status: InvitationStatus?

        @inlinable
        public init(catalog: String, connectionType: ConnectionType? = nil, maxResults: Int? = nil, nextToken: String? = nil, otherParticipantIdentifiers: [String]? = nil, participantType: ParticipantType? = nil, status: InvitationStatus? = nil) {
            self.catalog = catalog
            self.connectionType = connectionType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.otherParticipantIdentifiers = otherParticipantIdentifiers
            self.participantType = participantType
            self.status = status
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
            try self.otherParticipantIdentifiers?.forEach {
                try validate($0, name: "otherParticipantIdentifiers[]", parent: name, max: 100)
                try validate($0, name: "otherParticipantIdentifiers[]", parent: name, min: 1)
                try validate($0, name: "otherParticipantIdentifiers[]", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case connectionType = "ConnectionType"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case otherParticipantIdentifiers = "OtherParticipantIdentifiers"
            case participantType = "ParticipantType"
            case status = "Status"
        }
    }

    public struct ListConnectionInvitationsResponse: AWSDecodableShape {
        /// A list of connection invitation summaries matching the specified criteria.
        public let connectionInvitationSummaries: [ConnectionInvitationSummary]
        /// The token for retrieving the next page of results if more results are available.
        public let nextToken: String?

        @inlinable
        public init(connectionInvitationSummaries: [ConnectionInvitationSummary], nextToken: String? = nil) {
            self.connectionInvitationSummaries = connectionInvitationSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectionInvitationSummaries = "ConnectionInvitationSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListConnectionsRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// Filter results by connection type (e.g., reseller, distributor, technology partner).
        public let connectionType: String?
        /// The maximum number of connections to return in a single response.
        public let maxResults: Int?
        /// The token for retrieving the next page of results in paginated responses.
        public let nextToken: String?
        /// Filter results by specific participant identifiers.
        public let otherParticipantIdentifiers: [String]?

        @inlinable
        public init(catalog: String, connectionType: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, otherParticipantIdentifiers: [String]? = nil) {
            self.catalog = catalog
            self.connectionType = connectionType
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.otherParticipantIdentifiers = otherParticipantIdentifiers
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.connectionType, name: "connectionType", parent: name, max: 200)
            try self.validate(self.connectionType, name: "connectionType", parent: name, min: 1)
            try self.validate(self.connectionType, name: "connectionType", parent: name, pattern: "^[a-zA-Z_-]+(:[a-zA-Z]+)?$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
            try self.otherParticipantIdentifiers?.forEach {
                try validate($0, name: "otherParticipantIdentifiers[]", parent: name, max: 100)
                try validate($0, name: "otherParticipantIdentifiers[]", parent: name, min: 1)
                try validate($0, name: "otherParticipantIdentifiers[]", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case connectionType = "ConnectionType"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
            case otherParticipantIdentifiers = "OtherParticipantIdentifiers"
        }
    }

    public struct ListConnectionsResponse: AWSDecodableShape {
        /// A list of connection summaries matching the specified criteria.
        public let connectionSummaries: [ConnectionSummary]
        /// The token for retrieving the next page of results if more results are available.
        public let nextToken: String?

        @inlinable
        public init(connectionSummaries: [ConnectionSummary], nextToken: String? = nil) {
            self.connectionSummaries = connectionSummaries
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case connectionSummaries = "ConnectionSummaries"
            case nextToken = "NextToken"
        }
    }

    public struct ListPartnersRequest: AWSEncodableShape {
        /// The catalog identifier to list partners from.
        public let catalog: String
        /// The token for retrieving the next page of results in paginated responses.
        public let nextToken: String?

        @inlinable
        public init(catalog: String, nextToken: String? = nil) {
            self.catalog = catalog
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[\\S]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case nextToken = "NextToken"
        }
    }

    public struct ListPartnersResponse: AWSDecodableShape {
        /// The token for retrieving the next page of results if more results are available.
        public let nextToken: String?
        /// A list of partner summaries including basic information about each partner account.
        public let partnerSummaryList: [PartnerSummary]

        @inlinable
        public init(nextToken: String? = nil, partnerSummaryList: [PartnerSummary]) {
            self.nextToken = nextToken
            self.partnerSummaryList = partnerSummaryList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case partnerSummaryList = "PartnerSummaryList"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to list tags for.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:[A-Za-z0-9._:/-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource that the tags are associated with.
        public let resourceArn: String
        /// A list of tags associated with the specified resource.
        public let tags: [Tag]?

        @inlinable
        public init(resourceArn: String, tags: [Tag]? = nil) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct LocalizedContent: AWSEncodableShape & AWSDecodableShape {
        /// The localized description of the partner's business and services.
        public let description: String
        /// The localized display name for the partner.
        public let displayName: String
        /// The locale or language code for the localized content.
        public let locale: String
        /// The URL to the partner's logo image for this locale.
        public let logoUrl: String
        /// The localized website URL for the partner.
        public let websiteUrl: String

        @inlinable
        public init(description: String, displayName: String, locale: String, logoUrl: String, websiteUrl: String) {
            self.description = description
            self.displayName = displayName
            self.locale = locale
            self.logoUrl = logoUrl
            self.websiteUrl = websiteUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 80)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 80)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^[a-z]{2}-[A-Z]{2}$")
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, max: 256)
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, min: 1)
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, pattern: "^(https|HTTPS):\\/\\/[^\\/\\s]+(\\/\\S*)?$")
            try self.validate(self.websiteUrl, name: "websiteUrl", parent: name, max: 256)
            try self.validate(self.websiteUrl, name: "websiteUrl", parent: name, min: 1)
            try self.validate(self.websiteUrl, name: "websiteUrl", parent: name, pattern: "^(https|HTTPS):\\/\\/[^\\/\\s]+(\\/\\S*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case locale = "Locale"
            case logoUrl = "LogoUrl"
            case websiteUrl = "WebsiteUrl"
        }
    }

    public struct PartnerDomain: AWSDecodableShape {
        /// The domain name that has been verified for the partner account.
        public let domainName: String
        /// The timestamp when the domain was registered and verified for the partner account.
        @CustomCoding<ISO8601DateCoder>
        public var registeredAt: Date

        @inlinable
        public init(domainName: String, registeredAt: Date) {
            self.domainName = domainName
            self.registeredAt = registeredAt
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "DomainName"
            case registeredAt = "RegisteredAt"
        }
    }

    public struct PartnerProfile: AWSDecodableShape {
        /// A description of the partner's business, services, and capabilities.
        public let description: String
        /// The public display name for the partner organization.
        public let displayName: String
        /// The industry segments or verticals that the partner serves.
        public let industrySegments: [IndustrySegment]
        /// A list of localized content versions for different languages and regions.
        public let localizedContents: [LocalizedContent]?
        /// The URL to the partner's logo image.
        public let logoUrl: String
        /// The primary type of solution or service the partner provides.
        public let primarySolutionType: PrimarySolutionType
        /// The unique identifier of the partner profile.
        public let profileId: String?
        /// The source locale used for automatic translation of profile content.
        public let translationSourceLocale: String
        /// The partner's primary website URL.
        public let websiteUrl: String

        @inlinable
        public init(description: String, displayName: String, industrySegments: [IndustrySegment], localizedContents: [LocalizedContent]? = nil, logoUrl: String, primarySolutionType: PrimarySolutionType, profileId: String? = nil, translationSourceLocale: String, websiteUrl: String) {
            self.description = description
            self.displayName = displayName
            self.industrySegments = industrySegments
            self.localizedContents = localizedContents
            self.logoUrl = logoUrl
            self.primarySolutionType = primarySolutionType
            self.profileId = profileId
            self.translationSourceLocale = translationSourceLocale
            self.websiteUrl = websiteUrl
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case industrySegments = "IndustrySegments"
            case localizedContents = "LocalizedContents"
            case logoUrl = "LogoUrl"
            case primarySolutionType = "PrimarySolutionType"
            case profileId = "ProfileId"
            case translationSourceLocale = "TranslationSourceLocale"
            case websiteUrl = "WebsiteUrl"
        }
    }

    public struct PartnerProfileSummary: AWSDecodableShape {
        /// The unique identifier of the partner profile.
        public let id: String
        /// The display name of the partner.
        public let name: String

        @inlinable
        public init(id: String, name: String) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
        }
    }

    public struct PartnerSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the partner account.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The timestamp when the partner account was created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The unique identifier of the partner account.
        public let id: String
        /// The legal name of the partner organization.
        public let legalName: String

        @inlinable
        public init(arn: String, catalog: String, createdAt: Date, id: String, legalName: String) {
            self.arn = arn
            self.catalog = catalog
            self.createdAt = createdAt
            self.id = id
            self.legalName = legalName
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case createdAt = "CreatedAt"
            case id = "Id"
            case legalName = "LegalName"
        }
    }

    public struct PutAllianceLeadContactRequest: AWSEncodableShape {
        /// The alliance lead contact information to set for the partner account.
        public let allianceLeadContact: AllianceLeadContact
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The verification code sent to the alliance lead contact's email to confirm the update.
        public let emailVerificationCode: String?
        /// The unique identifier of the partner account.
        public let identifier: String

        @inlinable
        public init(allianceLeadContact: AllianceLeadContact, catalog: String, emailVerificationCode: String? = nil, identifier: String) {
            self.allianceLeadContact = allianceLeadContact
            self.catalog = catalog
            self.emailVerificationCode = emailVerificationCode
            self.identifier = identifier
        }

        public func validate(name: String) throws {
            try self.allianceLeadContact.validate(name: "\(name).allianceLeadContact")
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, max: 6)
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, min: 6)
            try self.validate(self.emailVerificationCode, name: "emailVerificationCode", parent: name, pattern: "^[0-9]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case allianceLeadContact = "AllianceLeadContact"
            case catalog = "Catalog"
            case emailVerificationCode = "EmailVerificationCode"
            case identifier = "Identifier"
        }
    }

    public struct PutAllianceLeadContactResponse: AWSDecodableShape {
        /// The updated alliance lead contact information.
        public let allianceLeadContact: AllianceLeadContact
        /// The Amazon Resource Name (ARN) of the partner account.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let id: String

        @inlinable
        public init(allianceLeadContact: AllianceLeadContact, arn: String, catalog: String, id: String) {
            self.allianceLeadContact = allianceLeadContact
            self.arn = arn
            self.catalog = catalog
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case allianceLeadContact = "AllianceLeadContact"
            case arn = "Arn"
            case catalog = "Catalog"
            case id = "Id"
        }
    }

    public struct PutProfileVisibilityRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let identifier: String
        /// The visibility setting to apply to the partner profile.
        public let visibility: ProfileVisibility

        @inlinable
        public init(catalog: String, identifier: String, visibility: ProfileVisibility) {
            self.catalog = catalog
            self.identifier = identifier
            self.visibility = visibility
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case identifier = "Identifier"
            case visibility = "Visibility"
        }
    }

    public struct PutProfileVisibilityResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the partner account.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The unique identifier of the partner account.
        public let id: String
        /// The unique identifier of the partner profile.
        public let profileId: String
        /// The updated visibility setting for the partner profile.
        public let visibility: ProfileVisibility

        @inlinable
        public init(arn: String, catalog: String, id: String, profileId: String, visibility: ProfileVisibility) {
            self.arn = arn
            self.catalog = catalog
            self.id = id
            self.profileId = profileId
            self.visibility = visibility
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case id = "Id"
            case profileId = "ProfileId"
            case visibility = "Visibility"
        }
    }

    public struct RegistrantVerificationDetails: AWSEncodableShape {
        public init() {}
    }

    public struct RegistrantVerificationResponse: AWSDecodableShape {
        /// A secure URL where the registrant can complete additional verification steps, such as document upload or identity confirmation through a third-party verification service.
        public let completionUrl: String
        /// The timestamp when the completion URL expires and is no longer valid for accessing the verification workflow.
        @CustomCoding<ISO8601DateCoder>
        public var completionUrlExpiresAt: Date

        @inlinable
        public init(completionUrl: String, completionUrlExpiresAt: Date) {
            self.completionUrl = completionUrl
            self.completionUrlExpiresAt = completionUrlExpiresAt
        }

        private enum CodingKeys: String, CodingKey {
            case completionUrl = "CompletionUrl"
            case completionUrlExpiresAt = "CompletionUrlExpiresAt"
        }
    }

    public struct RejectConnectionInvitationRequest: AWSEncodableShape {
        /// The catalog identifier where the connection invitation exists.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String
        /// The unique identifier of the connection invitation to reject.
        public let identifier: String
        /// The reason for rejecting the connection invitation.
        public let reason: String?

        @inlinable
        public init(catalog: String, clientToken: String = RejectConnectionInvitationRequest.idempotencyToken(), identifier: String, reason: String? = nil) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
            self.reason = reason
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^pacinv-[A-Za-z0-9]{13}$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
            case reason = "Reason"
        }
    }

    public struct RejectConnectionInvitationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rejected connection invitation.
        public let arn: String
        /// The catalog identifier where the connection invitation was rejected.
        public let catalog: String
        /// The identifier of the connection associated with the rejected invitation.
        public let connectionId: String?
        /// The type of connection that was being invited for.
        public let connectionType: ConnectionType
        /// The timestamp when the connection invitation was originally created.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The timestamp when the connection invitation would have expired.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expiresAt: Date?
        /// The unique identifier of the rejected connection invitation.
        public let id: String
        /// The message that was included with the original connection invitation.
        public let invitationMessage: String
        /// The email address of the person who sent the connection invitation.
        public let inviterEmail: String
        /// The name of the person who sent the connection invitation.
        public let inviterName: String
        /// The identifier of the other participant who sent the invitation.
        public let otherParticipantIdentifier: String
        /// The type of participant (inviter or invitee) in the connection invitation.
        public let participantType: ParticipantType
        /// The current status of the connection invitation (rejected).
        public let status: InvitationStatus
        /// The timestamp when the connection invitation was last updated (rejected).
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(arn: String, catalog: String, connectionId: String? = nil, connectionType: ConnectionType, createdAt: Date, expiresAt: Date? = nil, id: String, invitationMessage: String, inviterEmail: String, inviterName: String, otherParticipantIdentifier: String, participantType: ParticipantType, status: InvitationStatus, updatedAt: Date) {
            self.arn = arn
            self.catalog = catalog
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.invitationMessage = invitationMessage
            self.inviterEmail = inviterEmail
            self.inviterName = inviterName
            self.otherParticipantIdentifier = otherParticipantIdentifier
            self.participantType = participantType
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case connectionId = "ConnectionId"
            case connectionType = "ConnectionType"
            case createdAt = "CreatedAt"
            case expiresAt = "ExpiresAt"
            case id = "Id"
            case invitationMessage = "InvitationMessage"
            case inviterEmail = "InviterEmail"
            case inviterName = "InviterName"
            case otherParticipantIdentifier = "OtherParticipantIdentifier"
            case participantType = "ParticipantType"
            case status = "Status"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The specific reason why the resource was not found.
        public let reason: ResourceNotFoundExceptionReason

        @inlinable
        public init(message: String, reason: ResourceNotFoundExceptionReason) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct SellerProfileSummary: AWSDecodableShape {
        /// The unique identifier of the seller profile.
        public let id: String
        /// The display name of the seller.
        public let name: String

        @inlinable
        public init(id: String, name: String) {
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case id = "Id"
            case name = "Name"
        }
    }

    public struct SendEmailVerificationCodeRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The email address to send the verification code to.
        public let email: String

        @inlinable
        public init(catalog: String, email: String) {
            self.catalog = catalog
            self.email = email
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.email, name: "email", parent: name, max: 320)
            try self.validate(self.email, name: "email", parent: name, min: 1)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case email = "Email"
        }
    }

    public struct SendEmailVerificationCodeResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The specific reason for the service quota being exceeded.
        public let reason: ServiceQuotaExceededExceptionReason

        @inlinable
        public init(message: String, reason: ServiceQuotaExceededExceptionReason) {
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case reason = "Reason"
        }
    }

    public struct StartProfileUpdateTaskRequest: AWSEncodableShape {
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
        public let clientToken: String?
        /// The unique identifier of the partner account.
        public let identifier: String
        /// The details of the profile updates to be performed.
        public let taskDetails: TaskDetails

        @inlinable
        public init(catalog: String, clientToken: String? = StartProfileUpdateTaskRequest.idempotencyToken(), identifier: String, taskDetails: TaskDetails) {
            self.catalog = catalog
            self.clientToken = clientToken
            self.identifier = identifier
            self.taskDetails = taskDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.validate(self.identifier, name: "identifier", parent: name, max: 200)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, pattern: "^(partner-[A-Za-z0-9]{13}|arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:catalog/[A-Za-z-_]+/partner/partner-[A-Za-z0-9]{13})$")
            try self.taskDetails.validate(name: "\(name).taskDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case catalog = "Catalog"
            case clientToken = "ClientToken"
            case identifier = "Identifier"
            case taskDetails = "TaskDetails"
        }
    }

    public struct StartProfileUpdateTaskResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the started profile update task.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The timestamp when the profile update task ended (null for in-progress tasks).
        @OptionalCustomCoding<ISO8601DateCoder>
        public var endedAt: Date?
        /// A list of error details if any errors occurred during the profile update task.
        public let errorDetailList: [ErrorDetail]?
        /// The unique identifier of the partner account.
        public let id: String
        /// The timestamp when the profile update task was started.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// The current status of the profile update task (in progress).
        public let status: ProfileTaskStatus
        /// The details of the profile update task that was started.
        public let taskDetails: TaskDetails
        /// The unique identifier of the started profile update task.
        public let taskId: String

        @inlinable
        public init(arn: String, catalog: String, endedAt: Date? = nil, errorDetailList: [ErrorDetail]? = nil, id: String, startedAt: Date, status: ProfileTaskStatus, taskDetails: TaskDetails, taskId: String) {
            self.arn = arn
            self.catalog = catalog
            self.endedAt = endedAt
            self.errorDetailList = errorDetailList
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.taskDetails = taskDetails
            self.taskId = taskId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case catalog = "Catalog"
            case endedAt = "EndedAt"
            case errorDetailList = "ErrorDetailList"
            case id = "Id"
            case startedAt = "StartedAt"
            case status = "Status"
            case taskDetails = "TaskDetails"
            case taskId = "TaskId"
        }
    }

    public struct StartVerificationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This prevents duplicate verification processes from being started accidentally.
        public let clientToken: String?
        /// The specific details required for the verification process, including business information for business verification or personal information for registrant verification.
        public let verificationDetails: VerificationDetails?

        @inlinable
        public init(clientToken: String? = StartVerificationRequest.idempotencyToken(), verificationDetails: VerificationDetails? = nil) {
            self.clientToken = clientToken
            self.verificationDetails = verificationDetails
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "^[A-Za-z0-9-_]+$")
            try self.verificationDetails?.validate(name: "\(name).verificationDetails")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case verificationDetails = "VerificationDetails"
        }
    }

    public struct StartVerificationResponse: AWSDecodableShape {
        /// The timestamp when the verification process was completed. This field is typically null for newly started verifications unless they complete immediately.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var completedAt: Date?
        /// The timestamp when the verification process was successfully initiated.
        @CustomCoding<ISO8601DateCoder>
        public var startedAt: Date
        /// Initial response details specific to the type of verification started, which may include next steps or additional requirements.
        public let verificationResponseDetails: VerificationResponseDetails
        /// The initial status of the verification process after it has been started. Typically this will be pending or in-progress.
        public let verificationStatus: VerificationStatus
        /// Additional information about the initial verification status, including any immediate feedback about the submitted verification details.
        public let verificationStatusReason: String?
        /// The type of verification that was started based on the provided verification details.
        public let verificationType: VerificationType

        @inlinable
        public init(completedAt: Date? = nil, startedAt: Date, verificationResponseDetails: VerificationResponseDetails, verificationStatus: VerificationStatus, verificationStatusReason: String? = nil, verificationType: VerificationType) {
            self.completedAt = completedAt
            self.startedAt = startedAt
            self.verificationResponseDetails = verificationResponseDetails
            self.verificationStatus = verificationStatus
            self.verificationStatusReason = verificationStatusReason
            self.verificationType = verificationType
        }

        private enum CodingKeys: String, CodingKey {
            case completedAt = "CompletedAt"
            case startedAt = "StartedAt"
            case verificationResponseDetails = "VerificationResponseDetails"
            case verificationStatus = "VerificationStatus"
            case verificationStatusReason = "VerificationStatusReason"
            case verificationType = "VerificationType"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// The key name of the tag. Tag keys are case-sensitive.
        public let key: String
        /// The value associated with the tag key. Tag values are case-sensitive.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to tag.
        public let resourceArn: String
        /// A list of tags to add or update for the specified resource.
        public let tags: [Tag]

        @inlinable
        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:[A-Za-z0-9._:/-]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TaskDetails: AWSEncodableShape & AWSDecodableShape {
        /// The updated description for the partner profile.
        public let description: String
        /// The updated display name for the partner profile.
        public let displayName: String
        /// The updated industry segments for the partner profile.
        public let industrySegments: [IndustrySegment]
        /// The updated localized content for the partner profile.
        public let localizedContents: [LocalizedContent]?
        /// The updated logo URL for the partner profile.
        public let logoUrl: String
        /// The updated primary solution type for the partner profile.
        public let primarySolutionType: PrimarySolutionType
        /// The updated translation source locale for the partner profile.
        public let translationSourceLocale: String
        /// The updated website URL for the partner profile.
        public let websiteUrl: String

        @inlinable
        public init(description: String, displayName: String, industrySegments: [IndustrySegment], localizedContents: [LocalizedContent]? = nil, logoUrl: String, primarySolutionType: PrimarySolutionType, translationSourceLocale: String, websiteUrl: String) {
            self.description = description
            self.displayName = displayName
            self.industrySegments = industrySegments
            self.localizedContents = localizedContents
            self.logoUrl = logoUrl
            self.primarySolutionType = primarySolutionType
            self.translationSourceLocale = translationSourceLocale
            self.websiteUrl = websiteUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 80)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 80)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[\\u0020-\\u007E\\u00A0-\\uD7FF\\uE000-\\uFFFD]+$")
            try self.validate(self.industrySegments, name: "industrySegments", parent: name, max: 3)
            try self.validate(self.industrySegments, name: "industrySegments", parent: name, min: 1)
            try self.localizedContents?.forEach {
                try $0.validate(name: "\(name).localizedContents[]")
            }
            try self.validate(self.localizedContents, name: "localizedContents", parent: name, max: 20)
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, max: 256)
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, min: 1)
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, pattern: "^(https|HTTPS):\\/\\/[^\\/\\s]+(\\/\\S*)?$")
            try self.validate(self.translationSourceLocale, name: "translationSourceLocale", parent: name, pattern: "^[a-z]{2}-[A-Z]{2}$")
            try self.validate(self.websiteUrl, name: "websiteUrl", parent: name, max: 256)
            try self.validate(self.websiteUrl, name: "websiteUrl", parent: name, min: 1)
            try self.validate(self.websiteUrl, name: "websiteUrl", parent: name, pattern: "^(https|HTTPS):\\/\\/[^\\/\\s]+(\\/\\S*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case displayName = "DisplayName"
            case industrySegments = "IndustrySegments"
            case localizedContents = "LocalizedContents"
            case logoUrl = "LogoUrl"
            case primarySolutionType = "PrimarySolutionType"
            case translationSourceLocale = "TranslationSourceLocale"
            case websiteUrl = "WebsiteUrl"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The quota code associated with the throttling error.
        public let quotaCode: String?
        /// The service code associated with the throttling error.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case quotaCode = "QuotaCode"
            case serviceCode = "ServiceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource to remove tags from.
        public let resourceArn: String
        /// A list of tag keys to remove from the specified resource.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 1)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z-]+:partnercentral:[a-z0-9-]+:[0-9]{12}:[A-Za-z0-9._:/-]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateConnectionPreferencesRequest: AWSEncodableShape {
        /// The access type setting for connections (e.g., open, restricted, invitation-only).
        public let accessType: AccessType
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// The updated list of participant identifiers to exclude from connections.
        public let excludedParticipantIdentifiers: [String]?
        /// The revision number of the connection preferences for optimistic locking.
        public let revision: Int64

        @inlinable
        public init(accessType: AccessType, catalog: String, excludedParticipantIdentifiers: [String]? = nil, revision: Int64) {
            self.accessType = accessType
            self.catalog = catalog
            self.excludedParticipantIdentifiers = excludedParticipantIdentifiers
            self.revision = revision
        }

        public func validate(name: String) throws {
            try self.validate(self.catalog, name: "catalog", parent: name, max: 64)
            try self.validate(self.catalog, name: "catalog", parent: name, min: 1)
            try self.validate(self.catalog, name: "catalog", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            try self.excludedParticipantIdentifiers?.forEach {
                try validate($0, name: "excludedParticipantIdentifiers[]", parent: name, max: 100)
                try validate($0, name: "excludedParticipantIdentifiers[]", parent: name, min: 1)
                try validate($0, name: "excludedParticipantIdentifiers[]", parent: name, pattern: "^[a-zA-Z0-9-]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessType = "AccessType"
            case catalog = "Catalog"
            case excludedParticipantIdentifiers = "ExcludedParticipantIdentifiers"
            case revision = "Revision"
        }
    }

    public struct UpdateConnectionPreferencesResponse: AWSDecodableShape {
        /// The updated access type setting for connections.
        public let accessType: AccessType
        /// The Amazon Resource Name (ARN) of the updated connection preferences.
        public let arn: String
        /// The catalog identifier for the partner account.
        public let catalog: String
        /// A list of participant IDs that are excluded from connection requests or interactions.
        public let excludedParticipantIds: [String]?
        /// The updated revision number of the connection preferences.
        public let revision: Int64
        /// The timestamp when the connection preferences were last updated.
        @CustomCoding<ISO8601DateCoder>
        public var updatedAt: Date

        @inlinable
        public init(accessType: AccessType, arn: String, catalog: String, excludedParticipantIds: [String]? = nil, revision: Int64, updatedAt: Date) {
            self.accessType = accessType
            self.arn = arn
            self.catalog = catalog
            self.excludedParticipantIds = excludedParticipantIds
            self.revision = revision
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case accessType = "AccessType"
            case arn = "Arn"
            case catalog = "Catalog"
            case excludedParticipantIds = "ExcludedParticipantIds"
            case revision = "Revision"
            case updatedAt = "UpdatedAt"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// A list of detailed validation errors that occurred during request processing.
        public let errorDetails: [ValidationError]?
        public let message: String
        /// The reason for the validation failure.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(errorDetails: [ValidationError]? = nil, message: String, reason: ValidationExceptionReason) {
            self.errorDetails = errorDetails
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetails = "ErrorDetails"
            case message = "Message"
            case reason = "Reason"
        }
    }
}

// MARK: - Errors

/// Error enum for PartnerCentralAccount
public struct PartnerCentralAccountErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize PartnerCentralAccount
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The request was denied due to insufficient permissions. The caller does not have the required permissions to perform this operation.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request could not be completed due to a conflict with the current state of the resource. This typically occurs when trying to create a resource that already exists or modify a resource that has been changed by another process.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred while processing the request. This is typically a temporary condition and the request may be retried.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The specified resource could not be found. This may occur when referencing a resource that does not exist or has been deleted.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was rejected because it would exceed a service quota or limit. This may occur when trying to create more resources than allowed by the service limits.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was throttled due to too many requests being sent in a short period of time. The client should implement exponential backoff and retry the request.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The request failed validation. One or more input parameters are invalid, missing, or do not meet the required format or constraints.
    public static var validationException: Self { .init(.validationException) }
}

extension PartnerCentralAccountErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "AccessDeniedException": PartnerCentralAccount.AccessDeniedException.self,
        "ConflictException": PartnerCentralAccount.ConflictException.self,
        "ResourceNotFoundException": PartnerCentralAccount.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": PartnerCentralAccount.ServiceQuotaExceededException.self,
        "ThrottlingException": PartnerCentralAccount.ThrottlingException.self,
        "ValidationException": PartnerCentralAccount.ValidationException.self
    ]
}

extension PartnerCentralAccountErrorType: Equatable {
    public static func == (lhs: PartnerCentralAccountErrorType, rhs: PartnerCentralAccountErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension PartnerCentralAccountErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
