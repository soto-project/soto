//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension VPCLattice {
    // MARK: Enums

    public enum AuthPolicyState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIam = "AWS_IAM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum HealthCheckProtocolVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1 = "HTTP1"
        /// Indicates use of HTTP/2 to send requests to target
        case http2 = "HTTP2"
        public var description: String { return self.rawValue }
    }

    public enum IpAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates IPv4 address type
        case ipv4 = "IPV4"
        /// Indicates IPv6 address type
        case ipv6 = "IPV6"
        public var description: String { return self.rawValue }
    }

    public enum LambdaEventStructureVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// This is the default lambda event structure version
        case v1 = "V1"
        /// Indicates use of lambda event structure version 2
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    public enum ListenerProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates HTTP protocol
        case http = "HTTP"
        /// Indicates HTTPS protocol
        case https = "HTTPS"
        /// Indicates TLS_PASSTHROUGH protocol
        case tlsPassthrough = "TLS_PASSTHROUGH"
        public var description: String { return self.rawValue }
    }

    public enum ProtocolType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Resource Configuration protocol type TCP
        case tcp = "TCP"
        public var description: String { return self.rawValue }
    }

    public enum ResourceConfigurationIpAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Dualstack ip address type for dns type resource configs
        case dualstack = "DUALSTACK"
        /// Ipv4 ip address type for dns type resource configs
        case ipv4 = "IPV4"
        /// IPv6 ip address type for dns type resource configs
        case ipv6 = "IPV6"
        public var description: String { return self.rawValue }
    }

    public enum ResourceConfigurationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Resource Configuration is active.
        case active = "ACTIVE"
        /// Resource Configuration creation failed
        case createFailed = "CREATE_FAILED"
        /// Resource Configuration creation in progress.
        case createInProgress = "CREATE_IN_PROGRESS"
        /// Resource Configuration deletion failed.
        case deleteFailed = "DELETE_FAILED"
        /// Resource Configuration deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        /// Resource Configuration update failed
        case updateFailed = "UPDATE_FAILED"
        /// Resource Configuration update in progress.
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ResourceConfigurationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Resource Configuration of type ARN
        case arn = "ARN"
        /// Resource Configuration of type CHILD
        case child = "CHILD"
        /// Resource Configuration of type GROUP
        case group = "GROUP"
        /// Resource Configuration of type SINGLE
        case single = "SINGLE"
        public var description: String { return self.rawValue }
    }

    public enum ResourceGatewayIpAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Dualstack ip address type for resource gateway
        case dualstack = "DUALSTACK"
        /// Ipv4 ip address type for resource gateway
        case ipv4 = "IPV4"
        /// IPv6 ip address type for resource gateway
        case ipv6 = "IPV6"
        public var description: String { return self.rawValue }
    }

    public enum ResourceGatewayStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Resource Gateway is active.
        case active = "ACTIVE"
        /// Resource Gateway creation failed
        case createFailed = "CREATE_FAILED"
        /// Resource Gateway creation in progress.
        case createInProgress = "CREATE_IN_PROGRESS"
        /// Resource Gateway deletion failed.
        case deleteFailed = "DELETE_FAILED"
        /// Resource Gateway deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        /// Reosurce Gateway update failed
        case updateFailed = "UPDATE_FAILED"
        /// Resource Gateway update in progress.
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNetworkLogType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates logs for Lattice resource configurations.
        case resource = "RESOURCE"
        /// Indicates logs for Lattice services.
        case service = "SERVICE"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNetworkResourceAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ServiceNetwork and Service association is active
        case active = "ACTIVE"
        /// ServiceNetwork and Service association creation failed.
        case createFailed = "CREATE_FAILED"
        /// ServiceNetwork and Service association creation in progress
        case createInProgress = "CREATE_IN_PROGRESS"
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed = "DELETE_FAILED"
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        /// ServiceNetwork and Service association is partial
        case partial = "PARTIAL"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNetworkServiceAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ServiceNetwork and Service association is active
        case active = "ACTIVE"
        /// ServiceNetwork and Service association creation failed.
        case createFailed = "CREATE_FAILED"
        /// ServiceNetwork and Service association creation in progress
        case createInProgress = "CREATE_IN_PROGRESS"
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed = "DELETE_FAILED"
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNetworkVpcAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ServiceNetwork and Vpc association is active
        case active = "ACTIVE"
        /// ServiceNetwork and Vpc association creation failed.
        case createFailed = "CREATE_FAILED"
        /// ServiceNetwork and Vpc association creation in progress
        case createInProgress = "CREATE_IN_PROGRESS"
        /// ServiceNetwork and Vpc association deletion failed
        case deleteFailed = "DELETE_FAILED"
        /// ServiceNetwork and Vpc association deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        /// ServiceNetwork and Vpc association update failed
        case updateFailed = "UPDATE_FAILED"
        /// ServiceNetwork and Vpc association update in progress
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Service is active.
        case active = "ACTIVE"
        /// Service creation failed
        case createFailed = "CREATE_FAILED"
        /// Service creation in progress.
        case createInProgress = "CREATE_IN_PROGRESS"
        /// Service deletion failed.
        case deleteFailed = "DELETE_FAILED"
        /// Service deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates HTTP protocol
        case http = "HTTP"
        /// Indicates HTTPS protocol
        case https = "HTTPS"
        /// Indicates TCP protocol
        case tcp = "TCP"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupProtocolVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates use of gRPC to send requests to target
        case grpc = "GRPC"
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1 = "HTTP1"
        /// Indicates use of HTTP/2 to send requests to target
        case http2 = "HTTP2"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// TargetGroup is active
        case active = "ACTIVE"
        /// TargetGroup creation failed.
        case createFailed = "CREATE_FAILED"
        /// TargetGroup creation in progress
        case createInProgress = "CREATE_IN_PROGRESS"
        /// TargetGroup deletion failed
        case deleteFailed = "DELETE_FAILED"
        /// TargetGroup deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates target in this target group is an ALB
        case alb = "ALB"
        /// Indicates targets in this target group are EC2 instances
        case instance = "INSTANCE"
        /// Indicates targets in this target group are IP
        case ip = "IP"
        /// Indicates targets in this target group are Lambda
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum TargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The target is deregistering and connection draining is in process.
        case draining = "DRAINING"
        /// The target is healthy.
        case healthy = "HEALTHY"
        /// The initial health check is in progress.
        case initial = "INITIAL"
        /// Health checks are disabled.
        case unavailable = "UNAVAILABLE"
        /// The target failed the health check.
        case unhealthy = "UNHEALTHY"
        /// The target group is not used in a listener rule.
        case unused = "UNUSED"
        public var description: String { return self.rawValue }
    }

    public enum ValidationExceptionReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case cannotParse = "cannotParse"
        case fieldValidationFailed = "fieldValidationFailed"
        case other = "other"
        case unknownOperation = "unknownOperation"
        public var description: String { return self.rawValue }
    }

    public enum HeaderMatchType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A contains type match.
        case contains(String)
        /// An exact type match.
        case exact(String)
        /// A prefix type match. Matches the value with the prefix.
        case prefix(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contains:
                let value = try container.decode(String.self, forKey: .contains)
                self = .contains(value)
            case .exact:
                let value = try container.decode(String.self, forKey: .exact)
                self = .exact(value)
            case .prefix:
                let value = try container.decode(String.self, forKey: .prefix)
                self = .prefix(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .contains(let value):
                try container.encode(value, forKey: .contains)
            case .exact(let value):
                try container.encode(value, forKey: .exact)
            case .prefix(let value):
                try container.encode(value, forKey: .prefix)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contains(let value):
                try self.validate(value, name: "contains", parent: name, max: 200)
                try self.validate(value, name: "contains", parent: name, min: 1)
            case .exact(let value):
                try self.validate(value, name: "exact", parent: name, max: 200)
                try self.validate(value, name: "exact", parent: name, min: 1)
            case .prefix(let value):
                try self.validate(value, name: "prefix", parent: name, max: 200)
                try self.validate(value, name: "prefix", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contains = "contains"
            case exact = "exact"
            case prefix = "prefix"
        }
    }

    public enum PathMatchType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An exact match of the path.
        case exact(String)
        /// A prefix match of the path.
        case prefix(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .exact:
                let value = try container.decode(String.self, forKey: .exact)
                self = .exact(value)
            case .prefix:
                let value = try container.decode(String.self, forKey: .prefix)
                self = .prefix(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .exact(let value):
                try container.encode(value, forKey: .exact)
            case .prefix(let value):
                try container.encode(value, forKey: .prefix)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .exact(let value):
                try self.validate(value, name: "exact", parent: name, max: 200)
                try self.validate(value, name: "exact", parent: name, min: 1)
                try self.validate(value, name: "exact", parent: name, pattern: "^/[a-zA-Z0-9@:%_+.~#?&/=-]*$")
            case .prefix(let value):
                try self.validate(value, name: "prefix", parent: name, max: 200)
                try self.validate(value, name: "prefix", parent: name, min: 1)
                try self.validate(value, name: "prefix", parent: name, pattern: "^/[a-zA-Z0-9@:%_+.~#?&/=-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
        }
    }

    public enum ResourceConfigurationDefinition: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        case arnResource(ArnResource)
        /// The DNS name of the resource.
        case dnsResource(DnsResource)
        /// The IP resource.
        case ipResource(IpResource)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .arnResource:
                let value = try container.decode(ArnResource.self, forKey: .arnResource)
                self = .arnResource(value)
            case .dnsResource:
                let value = try container.decode(DnsResource.self, forKey: .dnsResource)
                self = .dnsResource(value)
            case .ipResource:
                let value = try container.decode(IpResource.self, forKey: .ipResource)
                self = .ipResource(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .arnResource(let value):
                try container.encode(value, forKey: .arnResource)
            case .dnsResource(let value):
                try container.encode(value, forKey: .dnsResource)
            case .ipResource(let value):
                try container.encode(value, forKey: .ipResource)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .arnResource(let value):
                try value.validate(name: "\(name).arnResource")
            case .dnsResource(let value):
                try value.validate(name: "\(name).dnsResource")
            case .ipResource(let value):
                try value.validate(name: "\(name).ipResource")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case arnResource = "arnResource"
            case dnsResource = "dnsResource"
            case ipResource = "ipResource"
        }
    }

    public enum RuleAction: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The fixed response action. The rule returns a custom HTTP response.
        case fixedResponse(FixedResponseAction)
        /// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        case forward(ForwardAction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fixedResponse:
                let value = try container.decode(FixedResponseAction.self, forKey: .fixedResponse)
                self = .fixedResponse(value)
            case .forward:
                let value = try container.decode(ForwardAction.self, forKey: .forward)
                self = .forward(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fixedResponse(let value):
                try container.encode(value, forKey: .fixedResponse)
            case .forward(let value):
                try container.encode(value, forKey: .forward)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .fixedResponse(let value):
                try value.validate(name: "\(name).fixedResponse")
            case .forward(let value):
                try value.validate(name: "\(name).forward")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fixedResponse = "fixedResponse"
            case forward = "forward"
        }
    }

    // MARK: Shapes

    public struct AccessLogSubscriptionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription
        public let arn: String
        /// The date and time that the access log subscription was created, in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The date and time that the access log subscription was last updated, in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The Amazon Resource Name (ARN) of the service or service network.
        public let resourceArn: String
        /// The ID of the service or service network.
        public let resourceId: String
        /// Log type of the service network.
        public let serviceNetworkLogType: ServiceNetworkLogType?

        @inlinable
        public init(arn: String, createdAt: Date, destinationArn: String, id: String, lastUpdatedAt: Date, resourceArn: String, resourceId: String, serviceNetworkLogType: ServiceNetworkLogType? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.serviceNetworkLogType = serviceNetworkLogType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case destinationArn = "destinationArn"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case serviceNetworkLogType = "serviceNetworkLogType"
        }
    }

    public struct ArnResource: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let arn: String?

        @inlinable
        public init(arn: String? = nil) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 2048)
            try self.validate(self.arn, name: "arn", parent: name, min: 20)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:[a-z0-9][-.a-z0-9]{0,62}:([a-z0-9][-.a-z0-9]{0,62})?:\\d{12}?:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
        }
    }

    public struct BatchUpdateRuleRequest: AWSEncodableShape {
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The rules for the specified listener.
        public let rules: [RuleUpdate]
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(listenerIdentifier: String, rules: [RuleUpdate], serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.rules = rules
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            try container.encode(self.rules, forKey: .rules)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 5)
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
        }
    }

    public struct BatchUpdateRuleResponse: AWSDecodableShape {
        /// The rules that were successfully updated.
        public let successful: [RuleUpdateSuccess]?
        /// The rules that the operation couldn't update.
        public let unsuccessful: [RuleUpdateFailure]?

        @inlinable
        public init(successful: [RuleUpdateSuccess]? = nil, unsuccessful: [RuleUpdateFailure]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        private enum CodingKeys: String, CodingKey {
            case successful = "successful"
            case unsuccessful = "unsuccessful"
        }
    }

    public struct ConflictException: AWSErrorShape {
        public let message: String
        /// The resource ID.
        public let resourceId: String
        /// The resource type.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CreateAccessLogSubscriptionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the destination. The supported destination types are CloudWatch Log groups, Kinesis Data Firehose delivery streams, and Amazon S3 buckets.
        public let destinationArn: String
        /// The ID or ARN of the service network or service.
        public let resourceIdentifier: String
        /// The type of log that monitors your Amazon VPC Lattice service networks.
        public let serviceNetworkLogType: ServiceNetworkLogType?
        /// The tags for the access log subscription.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateAccessLogSubscriptionRequest.idempotencyToken(), destinationArn: String, resourceIdentifier: String, serviceNetworkLogType: ServiceNetworkLogType? = nil, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.destinationArn = destinationArn
            self.resourceIdentifier = resourceIdentifier
            self.serviceNetworkLogType = serviceNetworkLogType
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, min: 20)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc)|(rcfg))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(resourceconfiguration/rcfg)|(service/svc))-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case destinationArn = "destinationArn"
            case resourceIdentifier = "resourceIdentifier"
            case serviceNetworkLogType = "serviceNetworkLogType"
            case tags = "tags"
        }
    }

    public struct CreateAccessLogSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the log destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The Amazon Resource Name (ARN) of the service network or service.
        public let resourceArn: String
        /// The ID of the service network or service.
        public let resourceId: String
        /// The type of log that monitors your Amazon VPC Lattice service networks.
        public let serviceNetworkLogType: ServiceNetworkLogType?

        @inlinable
        public init(arn: String, destinationArn: String, id: String, resourceArn: String, resourceId: String, serviceNetworkLogType: ServiceNetworkLogType? = nil) {
            self.arn = arn
            self.destinationArn = destinationArn
            self.id = id
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.serviceNetworkLogType = serviceNetworkLogType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinationArn = "destinationArn"
            case id = "id"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case serviceNetworkLogType = "serviceNetworkLogType"
        }
    }

    public struct CreateListenerRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The action for the default rule. Each listener has a default rule. The default rule is used if no other rules match.
        public let defaultAction: RuleAction
        /// The name of the listener. A listener name must be unique within a service. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The listener port. You can specify a value from 1 to 65535. For HTTP, the default is 80. For HTTPS, the default is 443.
        public let port: Int?
        /// The listener protocol.
        public let `protocol`: ListenerProtocol
        /// The ID or ARN of the service.
        public let serviceIdentifier: String
        /// The tags for the listener.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateListenerRequest.idempotencyToken(), defaultAction: RuleAction, name: String, port: Int? = nil, protocol: ListenerProtocol, serviceIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.defaultAction = defaultAction
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceIdentifier = serviceIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.defaultAction, forKey: .defaultAction)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.port, forKey: .port)
            try container.encode(self.`protocol`, forKey: .`protocol`)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.defaultAction.validate(name: "\(name).defaultAction")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!listener-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case defaultAction = "defaultAction"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case tags = "tags"
        }
    }

    public struct CreateListenerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The action for the default rule.
        public let defaultAction: RuleAction?
        /// The ID of the listener.
        public let id: String?
        /// The name of the listener.
        public let name: String?
        /// The port number of the listener.
        public let port: Int?
        /// The protocol of the listener.
        public let `protocol`: ListenerProtocol?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?

        @inlinable
        public init(arn: String? = nil, defaultAction: RuleAction? = nil, id: String? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil, serviceArn: String? = nil, serviceId: String? = nil) {
            self.arn = arn
            self.defaultAction = defaultAction
            self.id = id
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArn = serviceArn
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case defaultAction = "defaultAction"
            case id = "id"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
        }
    }

    public struct CreateResourceConfigurationRequest: AWSEncodableShape {
        /// (SINGLE, GROUP, ARN) Specifies whether the resource configuration can be associated with  a sharable service network. The default is false.
        public let allowAssociationToShareableServiceNetwork: Bool?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The name of the resource configuration. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// (SINGLE, GROUP, CHILD) The TCP port ranges that a consumer can use to access a resource configuration  (for example: 1-65535). You can separate port ranges using commas (for example: 1,2,22-30).
        public let portRanges: [String]?
        /// (SINGLE, GROUP) The protocol accepted by the resource configuration.
        public let `protocol`: ProtocolType?
        /// (SINGLE, CHILD, ARN) The resource configuration.
        public let resourceConfigurationDefinition: ResourceConfigurationDefinition?
        /// (CHILD) The ID or ARN of the parent resource configuration (type is GROUP).  This is used to associate a child resource configuration with a group resource configuration.
        public let resourceConfigurationGroupIdentifier: String?
        /// (SINGLE, GROUP, ARN) The ID or ARN of the resource gateway used to connect to the resource configuration. For a child resource configuration, this value is inherited from the parent resource configuration.
        public let resourceGatewayIdentifier: String?
        /// The tags for the resource configuration.
        public let tags: [String: String]?
        /// The type of resource configuration.    SINGLE - A single resource.    GROUP - A group of resources. You must create a group resource configuration before you create a child resource configuration.    CHILD - A single resource that is part of a group resource configuration.    ARN - An Amazon Web Services resource.
        public let type: ResourceConfigurationType

        @inlinable
        public init(allowAssociationToShareableServiceNetwork: Bool? = nil, clientToken: String? = CreateResourceConfigurationRequest.idempotencyToken(), name: String, portRanges: [String]? = nil, protocol: ProtocolType? = nil, resourceConfigurationDefinition: ResourceConfigurationDefinition? = nil, resourceConfigurationGroupIdentifier: String? = nil, resourceGatewayIdentifier: String? = nil, tags: [String: String]? = nil, type: ResourceConfigurationType) {
            self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
            self.clientToken = clientToken
            self.name = name
            self.portRanges = portRanges
            self.`protocol` = `protocol`
            self.resourceConfigurationDefinition = resourceConfigurationDefinition
            self.resourceConfigurationGroupIdentifier = resourceConfigurationGroupIdentifier
            self.resourceGatewayIdentifier = resourceGatewayIdentifier
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!rcfg-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.portRanges?.forEach {
                try validate($0, name: "portRanges[]", parent: name, max: 11)
                try validate($0, name: "portRanges[]", parent: name, min: 1)
                try validate($0, name: "portRanges[]", parent: name, pattern: "^((\\d{1,5}\\-\\d{1,5})|(\\d+))$")
            }
            try self.resourceConfigurationDefinition?.validate(name: "\(name).resourceConfigurationDefinition")
            try self.validate(self.resourceConfigurationGroupIdentifier, name: "resourceConfigurationGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationGroupIdentifier, name: "resourceConfigurationGroupIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationGroupIdentifier, name: "resourceConfigurationGroupIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, min: 17)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, pattern: "^((rgw-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourcegateway/rgw-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case allowAssociationToShareableServiceNetwork = "allowAssociationToShareableServiceNetwork"
            case clientToken = "clientToken"
            case name = "name"
            case portRanges = "portRanges"
            case `protocol` = "protocol"
            case resourceConfigurationDefinition = "resourceConfigurationDefinition"
            case resourceConfigurationGroupIdentifier = "resourceConfigurationGroupIdentifier"
            case resourceGatewayIdentifier = "resourceGatewayIdentifier"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateResourceConfigurationResponse: AWSDecodableShape {
        /// Specifies whether the resource configuration can be associated with a sharable service network.
        public let allowAssociationToShareableServiceNetwork: Bool?
        /// The Amazon Resource Name (ARN) of the resource configuration.
        public let arn: String?
        /// The date and time that the resource configuration was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The reason that the request failed.
        public let failureReason: String?
        /// The ID of the resource configuration.
        public let id: String?
        /// The name of the resource configuration.
        public let name: String?
        /// The port range.
        public let portRanges: [String]?
        /// The protocol.
        public let `protocol`: ProtocolType?
        /// The resource configuration.
        public let resourceConfigurationDefinition: ResourceConfigurationDefinition?
        /// The ID of the parent resource configuration (type is GROUP).
        public let resourceConfigurationGroupId: String?
        /// The ID of the resource gateway associated with the resource configuration.
        public let resourceGatewayId: String?
        /// The current status of the resource configuration.
        public let status: ResourceConfigurationStatus?
        /// The type of resource configuration.
        public let type: ResourceConfigurationType?

        @inlinable
        public init(allowAssociationToShareableServiceNetwork: Bool? = nil, arn: String? = nil, createdAt: Date? = nil, failureReason: String? = nil, id: String? = nil, name: String? = nil, portRanges: [String]? = nil, protocol: ProtocolType? = nil, resourceConfigurationDefinition: ResourceConfigurationDefinition? = nil, resourceConfigurationGroupId: String? = nil, resourceGatewayId: String? = nil, status: ResourceConfigurationStatus? = nil, type: ResourceConfigurationType? = nil) {
            self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
            self.arn = arn
            self.createdAt = createdAt
            self.failureReason = failureReason
            self.id = id
            self.name = name
            self.portRanges = portRanges
            self.`protocol` = `protocol`
            self.resourceConfigurationDefinition = resourceConfigurationDefinition
            self.resourceConfigurationGroupId = resourceConfigurationGroupId
            self.resourceGatewayId = resourceGatewayId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowAssociationToShareableServiceNetwork = "allowAssociationToShareableServiceNetwork"
            case arn = "arn"
            case createdAt = "createdAt"
            case failureReason = "failureReason"
            case id = "id"
            case name = "name"
            case portRanges = "portRanges"
            case `protocol` = "protocol"
            case resourceConfigurationDefinition = "resourceConfigurationDefinition"
            case resourceConfigurationGroupId = "resourceConfigurationGroupId"
            case resourceGatewayId = "resourceGatewayId"
            case status = "status"
            case type = "type"
        }
    }

    public struct CreateResourceGatewayRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The type of IP address used by the resource gateway.
        public let ipAddressType: ResourceGatewayIpAddressType?
        /// The name of the resource gateway.
        public let name: String
        /// The IDs of the security groups to apply to the resource gateway. The security groups must be in the same VPC.
        public let securityGroupIds: [String]?
        /// The IDs of the VPC subnets in which to create the resource gateway.
        public let subnetIds: [String]
        /// The tags for the resource gateway.
        public let tags: [String: String]?
        /// The ID of the VPC for the resource gateway.
        public let vpcIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateResourceGatewayRequest.idempotencyToken(), ipAddressType: ResourceGatewayIpAddressType? = nil, name: String, securityGroupIds: [String]? = nil, subnetIds: [String], tags: [String: String]? = nil, vpcIdentifier: String) {
            self.clientToken = clientToken
            self.ipAddressType = ipAddressType
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.tags = tags
            self.vpcIdentifier = vpcIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!rgw-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 5)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-(([0-9a-z]{8})|([0-9a-z]{17}))$")
            }
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 200)
                try validate($0, name: "subnetIds[]", parent: name, min: 5)
            }
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
            case tags = "tags"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct CreateResourceGatewayResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public let arn: String?
        /// The ID of the resource gateway.
        public let id: String?
        /// The type of IP address for the resource gateway.
        public let ipAddressType: ResourceGatewayIpAddressType?
        /// The name of the resource gateway.
        public let name: String?
        /// The IDs of the security groups for the resource gateway.
        public let securityGroupIds: [String]?
        /// The status of the resource gateway.
        public let status: ResourceGatewayStatus?
        /// The IDs of the resource gateway subnets.
        public let subnetIds: [String]?
        /// The ID of the VPC.
        public let vpcIdentifier: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, ipAddressType: ResourceGatewayIpAddressType? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: ResourceGatewayStatus? = nil, subnetIds: [String]? = nil, vpcIdentifier: String? = nil) {
            self.arn = arn
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcIdentifier = vpcIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct CreateRuleRequest: AWSEncodableShape {
        /// The action for the default rule.
        public let action: RuleAction
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The rule match.
        public let match: RuleMatch
        /// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
        public let priority: Int
        /// The ID or ARN of the service.
        public let serviceIdentifier: String
        /// The tags for the rule.
        public let tags: [String: String]?

        @inlinable
        public init(action: RuleAction, clientToken: String? = CreateRuleRequest.idempotencyToken(), listenerIdentifier: String, match: RuleMatch, name: String, priority: Int, serviceIdentifier: String, tags: [String: String]? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.listenerIdentifier = listenerIdentifier
            self.match = match
            self.name = name
            self.priority = priority
            self.serviceIdentifier = serviceIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            try container.encode(self.match, forKey: .match)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.priority, forKey: .priority)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.match.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!rule-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case match = "match"
            case name = "name"
            case priority = "priority"
            case tags = "tags"
        }
    }

    public struct CreateRuleResponse: AWSDecodableShape {
        /// The rule action.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the rule.
        public let arn: String?
        /// The ID of the rule.
        public let id: String?
        /// The rule match. The RuleMatch must be an HttpMatch. This means that the rule should be an exact match on HTTP constraints which are made up of the HTTP method, path, and header.
        public let match: RuleMatch?
        /// The name of the rule.
        public let name: String?
        /// The priority assigned to the rule. The lower the priority number the higher the priority.
        public let priority: Int?

        @inlinable
        public init(action: RuleAction? = nil, arn: String? = nil, id: String? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.id = id
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case id = "id"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct CreateServiceNetworkRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The name of the service network. The name must be unique to the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// Specify if the service network should be enabled for sharing.
        public let sharingConfig: SharingConfig?
        /// The tags for the service network.
        public let tags: [String: String]?

        @inlinable
        public init(authType: AuthType? = nil, clientToken: String? = CreateServiceNetworkRequest.idempotencyToken(), name: String, sharingConfig: SharingConfig? = nil, tags: [String: String]? = nil) {
            self.authType = authType
            self.clientToken = clientToken
            self.name = name
            self.sharingConfig = sharingConfig
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case clientToken = "clientToken"
            case name = "name"
            case sharingConfig = "sharingConfig"
            case tags = "tags"
        }
    }

    public struct CreateServiceNetworkResourceAssociationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The ID of the resource configuration to associate with the service network.
        public let resourceConfigurationIdentifier: String
        /// The ID of the service network to associate with the resource configuration.
        public let serviceNetworkIdentifier: String
        /// The tags for the association.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateServiceNetworkResourceAssociationRequest.idempotencyToken(), resourceConfigurationIdentifier: String, serviceNetworkIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case resourceConfigurationIdentifier = "resourceConfigurationIdentifier"
            case serviceNetworkIdentifier = "serviceNetworkIdentifier"
            case tags = "tags"
        }
    }

    public struct CreateServiceNetworkResourceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The ID of the account that created the association.
        public let createdBy: String?
        /// The ID of the association.
        public let id: String?
        /// The status of the association.
        public let status: ServiceNetworkResourceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdBy: String? = nil, id: String? = nil, status: ServiceNetworkResourceAssociationStatus? = nil) {
            self.arn = arn
            self.createdBy = createdBy
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case id = "id"
            case status = "status"
        }
    }

    public struct CreateServiceNetworkResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The ID of the service network.
        public let id: String?
        /// The name of the service network.
        public let name: String?
        /// Specifies if the service network is enabled for sharing.
        public let sharingConfig: SharingConfig?

        @inlinable
        public init(arn: String? = nil, authType: AuthType? = nil, id: String? = nil, name: String? = nil, sharingConfig: SharingConfig? = nil) {
            self.arn = arn
            self.authType = authType
            self.id = id
            self.name = name
            self.sharingConfig = sharingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case id = "id"
            case name = "name"
            case sharingConfig = "sharingConfig"
        }
    }

    public struct CreateServiceNetworkServiceAssociationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The ID or ARN of the service.
        public let serviceIdentifier: String
        /// The ID or ARN of the service network. You must use an ARN if the resources are in different accounts.
        public let serviceNetworkIdentifier: String
        /// The tags for the association.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = CreateServiceNetworkServiceAssociationRequest.idempotencyToken(), serviceIdentifier: String, serviceNetworkIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.serviceIdentifier = serviceIdentifier
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case serviceIdentifier = "serviceIdentifier"
            case serviceNetworkIdentifier = "serviceNetworkIdentifier"
            case tags = "tags"
        }
    }

    public struct CreateServiceNetworkServiceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The account that created the association.
        public let createdBy: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The ID of the association.
        public let id: String?
        /// The association status.
        public let status: ServiceNetworkServiceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdBy: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case status = "status"
        }
    }

    public struct CreateServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The IDs of the security groups. Security groups aren't added by default. You can add a security group to apply network level controls to control which resources in a VPC are allowed to access the service network and its services. For more information, see Control traffic to resources using security groups in the Amazon VPC User Guide.
        public let securityGroupIds: [String]?
        /// The ID or ARN of the service network. You must use an ARN if the resources are in different accounts.
        public let serviceNetworkIdentifier: String
        /// The tags for the association.
        public let tags: [String: String]?
        /// The ID of the VPC.
        public let vpcIdentifier: String

        @inlinable
        public init(clientToken: String? = CreateServiceNetworkVpcAssociationRequest.idempotencyToken(), securityGroupIds: [String]? = nil, serviceNetworkIdentifier: String, tags: [String: String]? = nil, vpcIdentifier: String) {
            self.clientToken = clientToken
            self.securityGroupIds = securityGroupIds
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
            self.tags = tags
            self.vpcIdentifier = vpcIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 5)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-(([0-9a-z]{8})|([0-9a-z]{17}))$")
            }
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case securityGroupIds = "securityGroupIds"
            case serviceNetworkIdentifier = "serviceNetworkIdentifier"
            case tags = "tags"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct CreateServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The account that created the association.
        public let createdBy: String?
        /// The ID of the association.
        public let id: String?
        /// The IDs of the security groups.
        public let securityGroupIds: [String]?
        /// The association status.
        public let status: ServiceNetworkVpcAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdBy: String? = nil, id: String? = nil, securityGroupIds: [String]? = nil, status: ServiceNetworkVpcAssociationStatus? = nil) {
            self.arn = arn
            self.createdBy = createdBy
            self.id = id
            self.securityGroupIds = securityGroupIds
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case id = "id"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
        }
    }

    public struct CreateServiceRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The name of the service. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The tags for the service.
        public let tags: [String: String]?

        @inlinable
        public init(authType: AuthType? = nil, certificateArn: String? = nil, clientToken: String? = CreateServiceRequest.idempotencyToken(), customDomainName: String? = nil, name: String, tags: [String: String]? = nil) {
            self.authType = authType
            self.certificateArn = certificateArn
            self.clientToken = clientToken
            self.customDomainName = customDomainName
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, max: 2048)
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "^(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:certificate/[0-9a-z-]+)?$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 255)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!svc-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case certificateArn = "certificateArn"
            case clientToken = "clientToken"
            case customDomainName = "customDomainName"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The public DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The ID of the service.
        public let id: String?
        /// The name of the service.
        public let name: String?
        /// The status. If the status is CREATE_FAILED, you must delete and recreate the service.
        public let status: ServiceStatus?

        @inlinable
        public init(arn: String? = nil, authType: AuthType? = nil, certificateArn: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.authType = authType
            self.certificateArn = certificateArn
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case certificateArn = "certificateArn"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateTargetGroupRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The target group configuration.
        public let config: TargetGroupConfig?
        /// The name of the target group. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The tags for the target group.
        public let tags: [String: String]?
        /// The type of target group.
        public let type: TargetGroupType

        @inlinable
        public init(clientToken: String? = CreateTargetGroupRequest.idempotencyToken(), config: TargetGroupConfig? = nil, name: String, tags: [String: String]? = nil, type: TargetGroupType) {
            self.clientToken = clientToken
            self.config = config
            self.name = name
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.config?.validate(name: "\(name).config")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!tg-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case config = "config"
            case name = "name"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The target group configuration.
        public let config: TargetGroupConfig?
        /// The ID of the target group.
        public let id: String?
        /// The name of the target group.
        public let name: String?
        /// The status. You can retry the operation if the status is CREATE_FAILED. However, if you retry it while the status is CREATE_IN_PROGRESS, there is no change in the status.
        public let status: TargetGroupStatus?
        /// The type of target group.
        public let type: TargetGroupType?

        @inlinable
        public init(arn: String? = nil, config: TargetGroupConfig? = nil, id: String? = nil, name: String? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil) {
            self.arn = arn
            self.config = config
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case config = "config"
            case id = "id"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct DeleteAccessLogSubscriptionRequest: AWSEncodableShape {
        /// The ID or ARN of the access log subscription.
        public let accessLogSubscriptionIdentifier: String

        @inlinable
        public init(accessLogSubscriptionIdentifier: String) {
            self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessLogSubscriptionIdentifier, key: "accessLogSubscriptionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, max: 2048)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, min: 17)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, pattern: "^((als-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:accesslogsubscription/als-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessLogSubscriptionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAuthPolicyRequest: AWSEncodableShape {
        /// The ID or ARN of the resource.
        public let resourceIdentifier: String

        @inlinable
        public init(resourceIdentifier: String) {
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc)|(rcfg))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(resourceconfiguration/rcfg)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAuthPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteListenerRequest: AWSEncodableShape {
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(listenerIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteListenerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourceConfigurationRequest: AWSEncodableShape {
        /// The ID or ARN of the resource configuration.
        public let resourceConfigurationIdentifier: String

        @inlinable
        public init(resourceConfigurationIdentifier: String) {
            self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceConfigurationIdentifier, key: "resourceConfigurationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourceConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourceEndpointAssociationRequest: AWSEncodableShape {
        /// The ID or ARN of the association.
        public let resourceEndpointAssociationIdentifier: String

        @inlinable
        public init(resourceEndpointAssociationIdentifier: String) {
            self.resourceEndpointAssociationIdentifier = resourceEndpointAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceEndpointAssociationIdentifier, key: "resourceEndpointAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceEndpointAssociationIdentifier, name: "resourceEndpointAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceEndpointAssociationIdentifier, name: "resourceEndpointAssociationIdentifier", parent: name, min: 21)
            try self.validate(self.resourceEndpointAssociationIdentifier, name: "resourceEndpointAssociationIdentifier", parent: name, pattern: "^((rea-[0-9a-f]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceendpointassociation/rea-[0-9a-f]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourceEndpointAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The ID of the association.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the resource configuration associated with the VPC endpoint of type resource.
        public let resourceConfigurationArn: String?
        /// The ID of the resource configuration.
        public let resourceConfigurationId: String?
        /// The ID of the resource VPC endpoint that is associated with the resource configuration.
        public let vpcEndpointId: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, resourceConfigurationArn: String? = nil, resourceConfigurationId: String? = nil, vpcEndpointId: String? = nil) {
            self.arn = arn
            self.id = id
            self.resourceConfigurationArn = resourceConfigurationArn
            self.resourceConfigurationId = resourceConfigurationId
            self.vpcEndpointId = vpcEndpointId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case resourceConfigurationArn = "resourceConfigurationArn"
            case resourceConfigurationId = "resourceConfigurationId"
            case vpcEndpointId = "vpcEndpointId"
        }
    }

    public struct DeleteResourceGatewayRequest: AWSEncodableShape {
        /// The ID or ARN of the resource gateway.
        public let resourceGatewayIdentifier: String

        @inlinable
        public init(resourceGatewayIdentifier: String) {
            self.resourceGatewayIdentifier = resourceGatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceGatewayIdentifier, key: "resourceGatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, min: 17)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, pattern: "^((rgw-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourcegateway/rgw-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourceGatewayResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public let arn: String?
        /// The ID of the resource gateway.
        public let id: String?
        /// The name of the resource gateway.
        public let name: String?
        /// The status of the resource gateway.
        public let status: ResourceGatewayStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil, status: ResourceGatewayStatus? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc)|(resourceconfiguration/rcfg))-[0-9a-z]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRuleRequest: AWSEncodableShape {
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The ID or ARN of the rule.
        public let ruleIdentifier: String
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(listenerIdentifier: String, ruleIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.ruleIdentifier = ruleIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.ruleIdentifier, key: "ruleIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServiceNetworkRequest: AWSEncodableShape {
        /// The ID or ARN of the service network.
        public let serviceNetworkIdentifier: String

        @inlinable
        public init(serviceNetworkIdentifier: String) {
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceNetworkResourceAssociationRequest: AWSEncodableShape {
        /// The ID of the association.
        public let serviceNetworkResourceAssociationIdentifier: String

        @inlinable
        public init(serviceNetworkResourceAssociationIdentifier: String) {
            self.serviceNetworkResourceAssociationIdentifier = serviceNetworkResourceAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkResourceAssociationIdentifier, key: "serviceNetworkResourceAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkResourceAssociationIdentifier, name: "serviceNetworkResourceAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkResourceAssociationIdentifier, name: "serviceNetworkResourceAssociationIdentifier", parent: name, min: 22)
            try self.validate(self.serviceNetworkResourceAssociationIdentifier, name: "serviceNetworkResourceAssociationIdentifier", parent: name, pattern: "^((snra-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkresourceassociation/snra-[0-9a-f]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceNetworkResourceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The ID of the association.
        public let id: String?
        /// The status of the association.
        public let status: ServiceNetworkResourceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: ServiceNetworkResourceAssociationStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeleteServiceNetworkResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServiceNetworkServiceAssociationRequest: AWSEncodableShape {
        /// The ID or ARN of the association.
        public let serviceNetworkServiceAssociationIdentifier: String

        @inlinable
        public init(serviceNetworkServiceAssociationIdentifier: String) {
            self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkServiceAssociationIdentifier, key: "serviceNetworkServiceAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, pattern: "^((snsa-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkserviceassociation/snsa-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceNetworkServiceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The ID of the association.
        public let id: String?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
        public let status: ServiceNetworkServiceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeleteServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// The ID or ARN of the association.
        public let serviceNetworkVpcAssociationIdentifier: String

        @inlinable
        public init(serviceNetworkVpcAssociationIdentifier: String) {
            self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkVpcAssociationIdentifier, key: "serviceNetworkVpcAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, pattern: "^((snva-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkvpcassociation/snva-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The ID of the association.
        public let id: String?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
        public let status: ServiceNetworkVpcAssociationStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: ServiceNetworkVpcAssociationStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeleteServiceRequest: AWSEncodableShape {
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(serviceIdentifier: String) {
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The ID of the service.
        public let id: String?
        /// The name of the service.
        public let name: String?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
        public let status: ServiceStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteTargetGroupRequest: AWSEncodableShape {
        /// The ID or ARN of the target group.
        public let targetGroupIdentifier: String

        @inlinable
        public init(targetGroupIdentifier: String) {
            self.targetGroupIdentifier = targetGroupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The ID of the target group.
        public let id: String?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
        public let status: TargetGroupStatus?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, status: TargetGroupStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeregisterTargetsRequest: AWSEncodableShape {
        /// The ID or ARN of the target group.
        public let targetGroupIdentifier: String
        /// The targets to deregister.
        public let targets: [Target]

        @inlinable
        public init(targetGroupIdentifier: String, targets: [Target]) {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.targets = targets
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
            try container.encode(self.targets, forKey: .targets)
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.targets.forEach {
                try $0.validate(name: "\(name).targets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct DeregisterTargetsResponse: AWSDecodableShape {
        /// The targets that were successfully deregistered.
        public let successful: [Target]?
        /// The targets that the operation couldn't deregister.
        public let unsuccessful: [TargetFailure]?

        @inlinable
        public init(successful: [Target]? = nil, unsuccessful: [TargetFailure]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        private enum CodingKeys: String, CodingKey {
            case successful = "successful"
            case unsuccessful = "unsuccessful"
        }
    }

    public struct DnsEntry: AWSDecodableShape {
        /// The domain name of the service.
        public let domainName: String?
        /// The ID of the hosted zone.
        public let hostedZoneId: String?

        @inlinable
        public init(domainName: String? = nil, hostedZoneId: String? = nil) {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case hostedZoneId = "hostedZoneId"
        }
    }

    public struct DnsResource: AWSEncodableShape & AWSDecodableShape {
        /// The domain name of the resource.
        public let domainName: String?
        /// The type of IP address.
        public let ipAddressType: ResourceConfigurationIpAddressType?

        @inlinable
        public init(domainName: String? = nil, ipAddressType: ResourceConfigurationIpAddressType? = nil) {
            self.domainName = domainName
            self.ipAddressType = ipAddressType
        }

        public func validate(name: String) throws {
            try self.validate(self.domainName, name: "domainName", parent: name, max: 255)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case ipAddressType = "ipAddressType"
        }
    }

    public struct FixedResponseAction: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP response code.
        public let statusCode: Int

        @inlinable
        public init(statusCode: Int) {
            self.statusCode = statusCode
        }

        public func validate(name: String) throws {
            try self.validate(self.statusCode, name: "statusCode", parent: name, max: 599)
            try self.validate(self.statusCode, name: "statusCode", parent: name, min: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
        }
    }

    public struct ForwardAction: AWSEncodableShape & AWSDecodableShape {
        /// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic. The default value is 1. This means that if only one target group is provided, there is no need to set the weight; 100% of the traffic goes to that target group.
        public let targetGroups: [WeightedTargetGroup]

        @inlinable
        public init(targetGroups: [WeightedTargetGroup]) {
            self.targetGroups = targetGroups
        }

        public func validate(name: String) throws {
            try self.targetGroups.forEach {
                try $0.validate(name: "\(name).targetGroups[]")
            }
            try self.validate(self.targetGroups, name: "targetGroups", parent: name, max: 10)
            try self.validate(self.targetGroups, name: "targetGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetGroups = "targetGroups"
        }
    }

    public struct GetAccessLogSubscriptionRequest: AWSEncodableShape {
        /// The ID or ARN of the access log subscription.
        public let accessLogSubscriptionIdentifier: String

        @inlinable
        public init(accessLogSubscriptionIdentifier: String) {
            self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessLogSubscriptionIdentifier, key: "accessLogSubscriptionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, max: 2048)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, min: 17)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, pattern: "^((als-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:accesslogsubscription/als-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessLogSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let arn: String
        /// The date and time that the access log subscription was created, in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the access log destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The date and time that the access log subscription was last updated, in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The Amazon Resource Name (ARN) of the service network or service.
        public let resourceArn: String
        /// The ID of the service network or service.
        public let resourceId: String
        /// The log type for the service network.
        public let serviceNetworkLogType: ServiceNetworkLogType?

        @inlinable
        public init(arn: String, createdAt: Date, destinationArn: String, id: String, lastUpdatedAt: Date, resourceArn: String, resourceId: String, serviceNetworkLogType: ServiceNetworkLogType? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.serviceNetworkLogType = serviceNetworkLogType
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case destinationArn = "destinationArn"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
            case serviceNetworkLogType = "serviceNetworkLogType"
        }
    }

    public struct GetAuthPolicyRequest: AWSEncodableShape {
        /// The ID or ARN of the service network or service.
        public let resourceIdentifier: String

        @inlinable
        public init(resourceIdentifier: String) {
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc)|(rcfg))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(resourceconfiguration/rcfg)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAuthPolicyResponse: AWSDecodableShape {
        /// The date and time that the auth policy was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The date and time that the auth policy was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The auth policy.
        public let policy: String?
        /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the auth type is NONE, then any auth policy that you provide remains inactive. For more information, see Create a service network in the Amazon VPC Lattice User Guide.
        public let state: AuthPolicyState?

        @inlinable
        public init(createdAt: Date? = nil, lastUpdatedAt: Date? = nil, policy: String? = nil, state: AuthPolicyState? = nil) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.policy = policy
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case policy = "policy"
            case state = "state"
        }
    }

    public struct GetListenerRequest: AWSEncodableShape {
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(listenerIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetListenerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The date and time that the listener was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The actions for the default listener rule.
        public let defaultAction: RuleAction?
        /// The ID of the listener.
        public let id: String?
        /// The date and time that the listener was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the listener.
        public let name: String?
        /// The listener port.
        public let port: Int?
        /// The listener protocol.
        public let `protocol`: ListenerProtocol?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, defaultAction: RuleAction? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil, serviceArn: String? = nil, serviceId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultAction = defaultAction
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArn = serviceArn
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case defaultAction = "defaultAction"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
        }
    }

    public struct GetResourceConfigurationRequest: AWSEncodableShape {
        /// The ID of the resource configuration.
        public let resourceConfigurationIdentifier: String

        @inlinable
        public init(resourceConfigurationIdentifier: String) {
            self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceConfigurationIdentifier, key: "resourceConfigurationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceConfigurationResponse: AWSDecodableShape {
        /// Specifies whether the resource configuration is associated with a sharable service network.
        public let allowAssociationToShareableServiceNetwork: Bool?
        /// Indicates whether the resource configuration was created and is managed by Amazon.
        public let amazonManaged: Bool?
        /// The Amazon Resource Name (ARN) of the resource configuration.
        public let arn: String?
        /// The date and time that the resource configuration was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The custom domain name of the resource configuration.
        public let customDomainName: String?
        /// The reason the create-resource-configuration request failed.
        public let failureReason: String?
        /// The ID of the resource configuration.
        public let id: String?
        /// The most recent date and time that the resource configuration was updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the resource configuration.
        public let name: String?
        /// The TCP port ranges that a consumer can use to access a resource configuration. You can separate port ranges with a comma. Example: 1-65535 or 1,2,22-30
        public let portRanges: [String]?
        /// The TCP protocol accepted by the specified resource configuration.
        public let `protocol`: ProtocolType?
        /// The resource configuration.
        public let resourceConfigurationDefinition: ResourceConfigurationDefinition?
        /// The ID of the group resource configuration.
        public let resourceConfigurationGroupId: String?
        /// The ID of the resource gateway used to connect to the resource configuration in a given VPC. You can specify the resource gateway identifier only for resource configurations with type SINGLE, GROUP, or ARN.
        public let resourceGatewayId: String?
        /// The status of the resource configuration.
        public let status: ResourceConfigurationStatus?
        /// The type of resource configuration.    SINGLE - A single resource.    GROUP - A group of resources.    CHILD - A single resource that is part of a group resource configuration.    ARN - An Amazon Web Services resource.
        public let type: ResourceConfigurationType?

        @inlinable
        public init(allowAssociationToShareableServiceNetwork: Bool? = nil, amazonManaged: Bool? = nil, arn: String? = nil, createdAt: Date? = nil, customDomainName: String? = nil, failureReason: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, portRanges: [String]? = nil, protocol: ProtocolType? = nil, resourceConfigurationDefinition: ResourceConfigurationDefinition? = nil, resourceConfigurationGroupId: String? = nil, resourceGatewayId: String? = nil, status: ResourceConfigurationStatus? = nil, type: ResourceConfigurationType? = nil) {
            self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
            self.amazonManaged = amazonManaged
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.failureReason = failureReason
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.portRanges = portRanges
            self.`protocol` = `protocol`
            self.resourceConfigurationDefinition = resourceConfigurationDefinition
            self.resourceConfigurationGroupId = resourceConfigurationGroupId
            self.resourceGatewayId = resourceGatewayId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowAssociationToShareableServiceNetwork = "allowAssociationToShareableServiceNetwork"
            case amazonManaged = "amazonManaged"
            case arn = "arn"
            case createdAt = "createdAt"
            case customDomainName = "customDomainName"
            case failureReason = "failureReason"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case portRanges = "portRanges"
            case `protocol` = "protocol"
            case resourceConfigurationDefinition = "resourceConfigurationDefinition"
            case resourceConfigurationGroupId = "resourceConfigurationGroupId"
            case resourceGatewayId = "resourceGatewayId"
            case status = "status"
            case type = "type"
        }
    }

    public struct GetResourceGatewayRequest: AWSEncodableShape {
        /// The ID of the resource gateway.
        public let resourceGatewayIdentifier: String

        @inlinable
        public init(resourceGatewayIdentifier: String) {
            self.resourceGatewayIdentifier = resourceGatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceGatewayIdentifier, key: "resourceGatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, min: 17)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, pattern: "^((rgw-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourcegateway/rgw-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourceGatewayResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public let arn: String?
        /// The date and time that the resource gateway was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the resource gateway.
        public let id: String?
        /// The type of IP address for the resource gateway.
        public let ipAddressType: ResourceGatewayIpAddressType?
        /// The date and time that the resource gateway was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the resource gateway.
        public let name: String?
        /// The security group IDs associated with the resource gateway.
        public let securityGroupIds: [String]?
        /// The status for the resource gateway.
        public let status: ResourceGatewayStatus?
        /// The IDs of the VPC subnets for resource gateway.
        public let subnetIds: [String]?
        /// The ID of the VPC for the resource gateway.
        public let vpcId: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, ipAddressType: ResourceGatewayIpAddressType? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: ResourceGatewayStatus? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the service network or service.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc)|(resourceconfiguration/rcfg))-[0-9a-z]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// An IAM policy.
        public let policy: String?

        @inlinable
        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct GetRuleRequest: AWSEncodableShape {
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The ID or ARN of the listener rule.
        public let ruleIdentifier: String
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(listenerIdentifier: String, ruleIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.ruleIdentifier = ruleIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.ruleIdentifier, key: "ruleIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRuleResponse: AWSDecodableShape {
        /// The action for the default rule.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The date and time that the listener rule was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the listener.
        public let id: String?
        /// Indicates whether this is the default rule.
        public let isDefault: Bool?
        /// The date and time that the listener rule was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The rule match.
        public let match: RuleMatch?
        /// The name of the listener.
        public let name: String?
        /// The priority level for the specified rule.
        public let priority: Int?

        @inlinable
        public init(action: RuleAction? = nil, arn: String? = nil, createdAt: Date? = nil, id: String? = nil, isDefault: Bool? = nil, lastUpdatedAt: Date? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case isDefault = "isDefault"
            case lastUpdatedAt = "lastUpdatedAt"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct GetServiceNetworkRequest: AWSEncodableShape {
        /// The ID or ARN of the service network.
        public let serviceNetworkIdentifier: String

        @inlinable
        public init(serviceNetworkIdentifier: String) {
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceNetworkResourceAssociationRequest: AWSEncodableShape {
        /// The ID of the association.
        public let serviceNetworkResourceAssociationIdentifier: String

        @inlinable
        public init(serviceNetworkResourceAssociationIdentifier: String) {
            self.serviceNetworkResourceAssociationIdentifier = serviceNetworkResourceAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkResourceAssociationIdentifier, key: "serviceNetworkResourceAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkResourceAssociationIdentifier, name: "serviceNetworkResourceAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkResourceAssociationIdentifier, name: "serviceNetworkResourceAssociationIdentifier", parent: name, min: 22)
            try self.validate(self.serviceNetworkResourceAssociationIdentifier, name: "serviceNetworkResourceAssociationIdentifier", parent: name, pattern: "^((snra-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkresourceassociation/snra-[0-9a-f]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceNetworkResourceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The DNS entry for the service.
        public let dnsEntry: DnsEntry?
        /// The failure code.
        public let failureCode: String?
        /// The reason the association request failed.
        public let failureReason: String?
        /// The ID of the association.
        public let id: String?
        /// Indicates whether the association is managed by Amazon.
        public let isManagedAssociation: Bool?
        /// The most recent date and time that the association was updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The private DNS entry for the service.
        public let privateDnsEntry: DnsEntry?
        /// The Amazon Resource Name (ARN) of the association.
        public let resourceConfigurationArn: String?
        /// The ID of the resource configuration that is associated with the service network.
        public let resourceConfigurationId: String?
        /// The name of the resource configuration that is associated with the service network.
        public let resourceConfigurationName: String?
        /// The Amazon Resource Name (ARN) of the service network that is associated with the resource configuration.
        public let serviceNetworkArn: String?
        /// The ID of the service network that is associated with the resource configuration.
        public let serviceNetworkId: String?
        /// The name of the service network that is associated with the resource configuration.
        public let serviceNetworkName: String?
        /// The status of the association.
        public let status: ServiceNetworkResourceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, dnsEntry: DnsEntry? = nil, failureCode: String? = nil, failureReason: String? = nil, id: String? = nil, isManagedAssociation: Bool? = nil, lastUpdatedAt: Date? = nil, privateDnsEntry: DnsEntry? = nil, resourceConfigurationArn: String? = nil, resourceConfigurationId: String? = nil, resourceConfigurationName: String? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkResourceAssociationStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dnsEntry = dnsEntry
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.id = id
            self.isManagedAssociation = isManagedAssociation
            self.lastUpdatedAt = lastUpdatedAt
            self.privateDnsEntry = privateDnsEntry
            self.resourceConfigurationArn = resourceConfigurationArn
            self.resourceConfigurationId = resourceConfigurationId
            self.resourceConfigurationName = resourceConfigurationName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case dnsEntry = "dnsEntry"
            case failureCode = "failureCode"
            case failureReason = "failureReason"
            case id = "id"
            case isManagedAssociation = "isManagedAssociation"
            case lastUpdatedAt = "lastUpdatedAt"
            case privateDnsEntry = "privateDnsEntry"
            case resourceConfigurationArn = "resourceConfigurationArn"
            case resourceConfigurationId = "resourceConfigurationId"
            case resourceConfigurationName = "resourceConfigurationName"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
        }
    }

    public struct GetServiceNetworkResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The date and time that the service network was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the service network.
        public let id: String?
        /// The date and time of the last update, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service network.
        public let name: String?
        /// The number of services associated with the service network.
        public let numberOfAssociatedServices: Int64?
        /// The number of VPCs associated with the service network.
        public let numberOfAssociatedVPCs: Int64?
        /// Specifies if the service network is enabled for sharing.
        public let sharingConfig: SharingConfig?

        @inlinable
        public init(arn: String? = nil, authType: AuthType? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, numberOfAssociatedServices: Int64? = nil, numberOfAssociatedVPCs: Int64? = nil, sharingConfig: SharingConfig? = nil) {
            self.arn = arn
            self.authType = authType
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
            self.sharingConfig = sharingConfig
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case numberOfAssociatedServices = "numberOfAssociatedServices"
            case numberOfAssociatedVPCs = "numberOfAssociatedVPCs"
            case sharingConfig = "sharingConfig"
        }
    }

    public struct GetServiceNetworkServiceAssociationRequest: AWSEncodableShape {
        /// The ID or ARN of the association.
        public let serviceNetworkServiceAssociationIdentifier: String

        @inlinable
        public init(serviceNetworkServiceAssociationIdentifier: String) {
            self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkServiceAssociationIdentifier, key: "serviceNetworkServiceAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, pattern: "^((snsa-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkserviceassociation/snsa-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceNetworkServiceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the service network and service association.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?
        /// The name of the service.
        public let serviceName: String?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status of the association.
        public let status: ServiceNetworkServiceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, serviceArn: String? = nil, serviceId: String? = nil, serviceName: String? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
            case serviceName = "serviceName"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
        }
    }

    public struct GetServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// The ID or ARN of the association.
        public let serviceNetworkVpcAssociationIdentifier: String

        @inlinable
        public init(serviceNetworkVpcAssociationIdentifier: String) {
            self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkVpcAssociationIdentifier, key: "serviceNetworkVpcAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, pattern: "^((snva-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkvpcassociation/snva-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the association.
        public let id: String?
        /// The date and time that the association was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The IDs of the security groups.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status of the association.
        public let status: ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, securityGroupIds: [String]? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkVpcAssociationStatus? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.securityGroupIds = securityGroupIds
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case securityGroupIds = "securityGroupIds"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
            case vpcId = "vpcId"
        }
    }

    public struct GetServiceRequest: AWSEncodableShape {
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(serviceIdentifier: String) {
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The date and time that the service was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the service.
        public let id: String?
        /// The date and time that the service was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service.
        public let name: String?
        /// The status of the service.
        public let status: ServiceStatus?

        @inlinable
        public init(arn: String? = nil, authType: AuthType? = nil, certificateArn: String? = nil, createdAt: Date? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.authType = authType
            self.certificateArn = certificateArn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case certificateArn = "certificateArn"
            case createdAt = "createdAt"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetTargetGroupRequest: AWSEncodableShape {
        /// The ID or ARN of the target group.
        public let targetGroupIdentifier: String

        @inlinable
        public init(targetGroupIdentifier: String) {
            self.targetGroupIdentifier = targetGroupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The target group configuration.
        public let config: TargetGroupConfig?
        /// The date and time that the target group was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the target group.
        public let id: String?
        /// The date and time that the target group was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the target group.
        public let name: String?
        /// The Amazon Resource Names (ARNs) of the service.
        public let serviceArns: [String]?
        /// The status.
        public let status: TargetGroupStatus?
        /// The target group type.
        public let type: TargetGroupType?

        @inlinable
        public init(arn: String? = nil, config: TargetGroupConfig? = nil, createdAt: Date? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, serviceArns: [String]? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil) {
            self.arn = arn
            self.config = config
            self.createdAt = createdAt
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case config = "config"
            case createdAt = "createdAt"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case serviceArns = "serviceArns"
            case status = "status"
            case type = "type"
        }
    }

    public struct HeaderMatch: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the match is case sensitive.
        public let caseSensitive: Bool?
        /// The header match type.
        public let match: HeaderMatchType
        /// The name of the header.
        public let name: String

        @inlinable
        public init(caseSensitive: Bool? = nil, match: HeaderMatchType, name: String) {
            self.caseSensitive = caseSensitive
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case caseSensitive = "caseSensitive"
            case match = "match"
            case name = "name"
        }
    }

    public struct HealthCheckConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether health checking is enabled.
        public let enabled: Bool?
        /// The approximate amount of time, in seconds, between health checks of an individual target. The range is 5300 seconds. The default is 30 seconds.
        public let healthCheckIntervalSeconds: Int?
        /// The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1120 seconds. The default is 5 seconds.
        public let healthCheckTimeoutSeconds: Int?
        /// The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 210. The default is 5.
        public let healthyThresholdCount: Int?
        /// The codes to use when checking for a successful response from a target.
        public let matcher: Matcher?
        /// The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is /. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        public let path: String?
        /// The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        public let port: Int?
        /// The protocol used when performing health checks on targets. The possible protocols are HTTP and HTTPS. The default is HTTP.
        public let `protocol`: TargetGroupProtocol?
        /// The protocol version used when performing health checks on targets. The possible protocol versions are HTTP1 and HTTP2.
        public let protocolVersion: HealthCheckProtocolVersion?
        /// The number of consecutive failed health checks required before considering a target unhealthy. The range is 210. The default is 2.
        public let unhealthyThresholdCount: Int?

        @inlinable
        public init(enabled: Bool? = nil, healthCheckIntervalSeconds: Int? = nil, healthCheckTimeoutSeconds: Int? = nil, healthyThresholdCount: Int? = nil, matcher: Matcher? = nil, path: String? = nil, port: Int? = nil, protocol: TargetGroupProtocol? = nil, protocolVersion: HealthCheckProtocolVersion? = nil, unhealthyThresholdCount: Int? = nil) {
            self.enabled = enabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.matcher = matcher
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.unhealthyThresholdCount = unhealthyThresholdCount
        }

        public func validate(name: String) throws {
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, max: 300)
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, min: 0)
            try self.validate(self.healthCheckTimeoutSeconds, name: "healthCheckTimeoutSeconds", parent: name, max: 120)
            try self.validate(self.healthCheckTimeoutSeconds, name: "healthCheckTimeoutSeconds", parent: name, min: 0)
            try self.validate(self.healthyThresholdCount, name: "healthyThresholdCount", parent: name, max: 10)
            try self.validate(self.healthyThresholdCount, name: "healthyThresholdCount", parent: name, min: 0)
            try self.matcher?.validate(name: "\(name).matcher")
            try self.validate(self.path, name: "path", parent: name, max: 2048)
            try self.validate(self.path, name: "path", parent: name, pattern: "(^/[a-zA-Z0-9@:%_+.~#?&/=-]*$|(^$))")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 0)
            try self.validate(self.unhealthyThresholdCount, name: "unhealthyThresholdCount", parent: name, max: 10)
            try self.validate(self.unhealthyThresholdCount, name: "unhealthyThresholdCount", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case healthCheckIntervalSeconds = "healthCheckIntervalSeconds"
            case healthCheckTimeoutSeconds = "healthCheckTimeoutSeconds"
            case healthyThresholdCount = "healthyThresholdCount"
            case matcher = "matcher"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case protocolVersion = "protocolVersion"
            case unhealthyThresholdCount = "unhealthyThresholdCount"
        }
    }

    public struct HttpMatch: AWSEncodableShape & AWSDecodableShape {
        /// The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        public let headerMatches: [HeaderMatch]?
        /// The HTTP method type.
        public let method: String?
        /// The path match.
        public let pathMatch: PathMatch?

        @inlinable
        public init(headerMatches: [HeaderMatch]? = nil, method: String? = nil, pathMatch: PathMatch? = nil) {
            self.headerMatches = headerMatches
            self.method = method
            self.pathMatch = pathMatch
        }

        public func validate(name: String) throws {
            try self.headerMatches?.forEach {
                try $0.validate(name: "\(name).headerMatches[]")
            }
            try self.validate(self.headerMatches, name: "headerMatches", parent: name, max: 5)
            try self.validate(self.headerMatches, name: "headerMatches", parent: name, min: 1)
            try self.validate(self.method, name: "method", parent: name, max: 16)
            try self.pathMatch?.validate(name: "\(name).pathMatch")
        }

        private enum CodingKeys: String, CodingKey {
            case headerMatches = "headerMatches"
            case method = "method"
            case pathMatch = "pathMatch"
        }
    }

    public struct InternalServerException: AWSErrorShape {
        public let message: String
        /// The number of seconds to wait before retrying.
        public let retryAfterSeconds: Int?

        @inlinable
        public init(message: String, retryAfterSeconds: Int? = nil) {
            self.message = message
            self.retryAfterSeconds = retryAfterSeconds
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }

    public struct IpResource: AWSEncodableShape & AWSDecodableShape {
        /// The IP address of the IP resource.
        public let ipAddress: String?

        @inlinable
        public init(ipAddress: String? = nil) {
            self.ipAddress = ipAddress
        }

        public func validate(name: String) throws {
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, max: 39)
            try self.validate(self.ipAddress, name: "ipAddress", parent: name, min: 4)
        }

        private enum CodingKeys: String, CodingKey {
            case ipAddress = "ipAddress"
        }
    }

    public struct ListAccessLogSubscriptionsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or ARN of the service network or service.
        public let resourceIdentifier: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc)|(rcfg))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(resourceconfiguration/rcfg)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessLogSubscriptionsResponse: AWSDecodableShape {
        /// Information about the access log subscriptions.
        public let items: [AccessLogSubscriptionSummary]
        /// A pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [AccessLogSubscriptionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListListenersRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListListenersResponse: AWSDecodableShape {
        /// Information about the listeners.
        public let items: [ListenerSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ListenerSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListResourceConfigurationsRequest: AWSEncodableShape {
        /// The maximum page size.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID of the group resource configuration.
        public let resourceConfigurationGroupIdentifier: String?
        /// The ID of the resource gateway for the resource configuration.
        public let resourceGatewayIdentifier: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceConfigurationGroupIdentifier: String? = nil, resourceGatewayIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceConfigurationGroupIdentifier = resourceConfigurationGroupIdentifier
            self.resourceGatewayIdentifier = resourceGatewayIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceConfigurationGroupIdentifier, key: "resourceConfigurationGroupIdentifier")
            request.encodeQuery(self.resourceGatewayIdentifier, key: "resourceGatewayIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.resourceConfigurationGroupIdentifier, name: "resourceConfigurationGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationGroupIdentifier, name: "resourceConfigurationGroupIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationGroupIdentifier, name: "resourceConfigurationGroupIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, min: 17)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, pattern: "^((rgw-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourcegateway/rgw-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResourceConfigurationsResponse: AWSDecodableShape {
        /// Information about the resource configurations.
        public let items: [ResourceConfigurationSummary]?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ResourceConfigurationSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListResourceEndpointAssociationsRequest: AWSEncodableShape {
        /// The maximum page size.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID for the resource configuration associated with the VPC endpoint.
        public let resourceConfigurationIdentifier: String
        /// The ID of the association.
        public let resourceEndpointAssociationIdentifier: String?
        /// The ID of the VPC endpoint in the association.
        public let vpcEndpointId: String?
        /// The owner of the VPC endpoint in the association.
        public let vpcEndpointOwner: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceConfigurationIdentifier: String, resourceEndpointAssociationIdentifier: String? = nil, vpcEndpointId: String? = nil, vpcEndpointOwner: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
            self.resourceEndpointAssociationIdentifier = resourceEndpointAssociationIdentifier
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwner = vpcEndpointOwner
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceConfigurationIdentifier, key: "resourceConfigurationIdentifier")
            request.encodeQuery(self.resourceEndpointAssociationIdentifier, key: "resourceEndpointAssociationIdentifier")
            request.encodeQuery(self.vpcEndpointId, key: "vpcEndpointId")
            request.encodeQuery(self.vpcEndpointOwner, key: "vpcEndpointOwner")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
            try self.validate(self.resourceEndpointAssociationIdentifier, name: "resourceEndpointAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceEndpointAssociationIdentifier, name: "resourceEndpointAssociationIdentifier", parent: name, min: 21)
            try self.validate(self.resourceEndpointAssociationIdentifier, name: "resourceEndpointAssociationIdentifier", parent: name, pattern: "^((rea-[0-9a-f]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceendpointassociation/rea-[0-9a-f]{17}))$")
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, max: 22)
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, min: 22)
            try self.validate(self.vpcEndpointId, name: "vpcEndpointId", parent: name, pattern: "^vpce-[0-9a-f]{17}$")
            try self.validate(self.vpcEndpointOwner, name: "vpcEndpointOwner", parent: name, max: 12)
            try self.validate(self.vpcEndpointOwner, name: "vpcEndpointOwner", parent: name, min: 12)
            try self.validate(self.vpcEndpointOwner, name: "vpcEndpointOwner", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResourceEndpointAssociationsResponse: AWSDecodableShape {
        /// Information about the VPC endpoint associations.
        public let items: [ResourceEndpointAssociationSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ResourceEndpointAssociationSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListResourceGatewaysRequest: AWSEncodableShape {
        /// The maximum page size.
        public let maxResults: Int?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListResourceGatewaysResponse: AWSDecodableShape {
        /// Information about the resource gateways.
        public let items: [ResourceGatewaySummary]?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ResourceGatewaySummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRulesRequest: AWSEncodableShape {
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(listenerIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRulesResponse: AWSDecodableShape {
        /// Information about the rules.
        public let items: [RuleSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [RuleSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworkResourceAssociationsRequest: AWSEncodableShape {
        /// The maximum page size.
        public let maxResults: Int?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?
        /// The ID of the resource configurationk.
        public let resourceConfigurationIdentifier: String?
        /// The ID of the service network.
        public let serviceNetworkIdentifier: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceConfigurationIdentifier: String? = nil, serviceNetworkIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceConfigurationIdentifier, key: "resourceConfigurationIdentifier")
            request.encodeQuery(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworkResourceAssociationsResponse: AWSDecodableShape {
        /// Information about the associations.
        public let items: [ServiceNetworkResourceAssociationSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ServiceNetworkResourceAssociationSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworkServiceAssociationsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or ARN of the service.
        public let serviceIdentifier: String?
        /// The ID or ARN of the service network.
        public let serviceNetworkIdentifier: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceIdentifier: String? = nil, serviceNetworkIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceIdentifier = serviceIdentifier
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.serviceIdentifier, key: "serviceIdentifier")
            request.encodeQuery(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworkServiceAssociationsResponse: AWSDecodableShape {
        /// Information about the associations.
        public let items: [ServiceNetworkServiceAssociationSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ServiceNetworkServiceAssociationSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworkVpcAssociationsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or ARN of the service network.
        public let serviceNetworkIdentifier: String?
        /// The ID or ARN of the VPC.
        public let vpcIdentifier: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceNetworkIdentifier: String? = nil, vpcIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
            self.vpcIdentifier = vpcIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
            request.encodeQuery(self.vpcIdentifier, key: "vpcIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworkVpcAssociationsResponse: AWSDecodableShape {
        /// Information about the associations.
        public let items: [ServiceNetworkVpcAssociationSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ServiceNetworkVpcAssociationSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworkVpcEndpointAssociationsRequest: AWSEncodableShape {
        /// The maximum page size.
        public let maxResults: Int?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?
        /// The ID of the service network associated with the VPC endpoint.
        public let serviceNetworkIdentifier: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceNetworkIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworkVpcEndpointAssociationsResponse: AWSDecodableShape {
        /// Information about the association between the VPC endpoint and service network.
        public let items: [ServiceNetworkEndpointAssociation]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ServiceNetworkEndpointAssociation], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworksRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworksResponse: AWSDecodableShape {
        /// Information about the service networks.
        public let items: [ServiceNetworkSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ServiceNetworkSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServicesRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServicesResponse: AWSDecodableShape {
        /// Information about the services.
        public let items: [ServiceSummary]?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [ServiceSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:vpc-lattice:([a-z0-9][-.a-z0-9]{0,62})?:\\d{12}?:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// Information about the tags.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTargetGroupsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The target group type.
        public let targetGroupType: TargetGroupType?
        /// The ID or ARN of the VPC.
        public let vpcIdentifier: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, targetGroupType: TargetGroupType? = nil, vpcIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetGroupType = targetGroupType
            self.vpcIdentifier = vpcIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.targetGroupType, key: "targetGroupType")
            request.encodeQuery(self.vpcIdentifier, key: "vpcIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTargetGroupsResponse: AWSDecodableShape {
        /// Information about the target groups.
        public let items: [TargetGroupSummary]?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [TargetGroupSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTargetsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or ARN of the target group.
        public let targetGroupIdentifier: String
        /// The targets.
        public let targets: [Target]?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, targetGroupIdentifier: String, targets: [Target]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetGroupIdentifier = targetGroupIdentifier
            self.targets = targets
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
            try container.encodeIfPresent(self.targets, forKey: .targets)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.targets?.forEach {
                try $0.validate(name: "\(name).targets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct ListTargetsResponse: AWSDecodableShape {
        /// Information about the targets.
        public let items: [TargetSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        @inlinable
        public init(items: [TargetSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListenerSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The date and time that the listener was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the listener.
        public let id: String?
        /// The date and time that the listener was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the listener.
        public let name: String?
        /// The listener port.
        public let port: Int?
        /// The listener protocol.
        public let `protocol`: ListenerProtocol?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct PathMatch: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the match is case sensitive.
        public let caseSensitive: Bool?
        /// The type of path match.
        public let match: PathMatchType

        @inlinable
        public init(caseSensitive: Bool? = nil, match: PathMatchType) {
            self.caseSensitive = caseSensitive
            self.match = match
        }

        public func validate(name: String) throws {
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case caseSensitive = "caseSensitive"
            case match = "match"
        }
    }

    public struct PutAuthPolicyRequest: AWSEncodableShape {
        /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
        public let policy: String
        /// The ID or ARN of the service network or service for which the policy is created.
        public let resourceIdentifier: String

        @inlinable
        public init(policy: String, resourceIdentifier: String) {
            self.policy = policy
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policy, forKey: .policy)
            request.encodePath(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 10000)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc)|(rcfg))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(resourceconfiguration/rcfg)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct PutAuthPolicyResponse: AWSDecodableShape {
        /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
        public let policy: String?
        /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the Auth type is NONE, then, any auth policy that you provide remains inactive. For more information, see Create a service network in the Amazon VPC Lattice User Guide.
        public let state: AuthPolicyState?

        @inlinable
        public init(policy: String? = nil, state: AuthPolicyState? = nil) {
            self.policy = policy
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case state = "state"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// An IAM policy. The policy string in JSON must not contain newlines or blank lines.
        public let policy: String
        /// The ID or ARN of the service network or service for which the policy is created.
        public let resourceArn: String

        @inlinable
        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policy, forKey: .policy)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 10000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "^.*\\S.*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc)|(resourceconfiguration/rcfg))-[0-9a-z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RegisterTargetsRequest: AWSEncodableShape {
        /// The ID or ARN of the target group.
        public let targetGroupIdentifier: String
        /// The targets.
        public let targets: [Target]

        @inlinable
        public init(targetGroupIdentifier: String, targets: [Target]) {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.targets = targets
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
            try container.encode(self.targets, forKey: .targets)
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.targets.forEach {
                try $0.validate(name: "\(name).targets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct RegisterTargetsResponse: AWSDecodableShape {
        /// The targets that were successfully registered.
        public let successful: [Target]?
        /// The targets that were not registered.
        public let unsuccessful: [TargetFailure]?

        @inlinable
        public init(successful: [Target]? = nil, unsuccessful: [TargetFailure]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        private enum CodingKeys: String, CodingKey {
            case successful = "successful"
            case unsuccessful = "unsuccessful"
        }
    }

    public struct ResourceConfigurationSummary: AWSDecodableShape {
        /// Indicates whether the resource configuration was created and is managed by Amazon.
        public let amazonManaged: Bool?
        /// The Amazon Resource Name (ARN) of the resource configuration.
        public let arn: String?
        /// The date and time that the resource configuration was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the resource configuration.
        public let id: String?
        /// The most recent date and time that the resource configuration was updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the resource configuration.
        public let name: String?
        /// The ID of the group resource configuration.
        public let resourceConfigurationGroupId: String?
        /// The ID of the resource gateway.
        public let resourceGatewayId: String?
        /// The status of the resource configuration.
        public let status: ResourceConfigurationStatus?
        /// The type of resource configuration.    SINGLE - A single resource.    GROUP - A group of resources.    CHILD - A single resource that is part of a group resource configuration.    ARN - An Amazon Web Services resource.
        public let type: ResourceConfigurationType?

        @inlinable
        public init(amazonManaged: Bool? = nil, arn: String? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, resourceConfigurationGroupId: String? = nil, resourceGatewayId: String? = nil, status: ResourceConfigurationStatus? = nil, type: ResourceConfigurationType? = nil) {
            self.amazonManaged = amazonManaged
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.resourceConfigurationGroupId = resourceConfigurationGroupId
            self.resourceGatewayId = resourceGatewayId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case amazonManaged = "amazonManaged"
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case resourceConfigurationGroupId = "resourceConfigurationGroupId"
            case resourceGatewayId = "resourceGatewayId"
            case status = "status"
            case type = "type"
        }
    }

    public struct ResourceEndpointAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the VPC endpoint association.
        public let arn: String?
        /// The date and time that the VPC endpoint association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The ID of the VPC endpoint association.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the resource configuration.
        public let resourceConfigurationArn: String?
        /// The ID of the resource configuration.
        public let resourceConfigurationId: String?
        /// The name of the resource configuration.
        public let resourceConfigurationName: String?
        /// The ID of the VPC endpoint.
        public let vpcEndpointId: String?
        /// The owner of the VPC endpoint.
        public let vpcEndpointOwner: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, id: String? = nil, resourceConfigurationArn: String? = nil, resourceConfigurationId: String? = nil, resourceConfigurationName: String? = nil, vpcEndpointId: String? = nil, vpcEndpointOwner: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.resourceConfigurationArn = resourceConfigurationArn
            self.resourceConfigurationId = resourceConfigurationId
            self.resourceConfigurationName = resourceConfigurationName
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwner = vpcEndpointOwner
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case id = "id"
            case resourceConfigurationArn = "resourceConfigurationArn"
            case resourceConfigurationId = "resourceConfigurationId"
            case resourceConfigurationName = "resourceConfigurationName"
            case vpcEndpointId = "vpcEndpointId"
            case vpcEndpointOwner = "vpcEndpointOwner"
        }
    }

    public struct ResourceGatewaySummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public let arn: String?
        /// The date and time that the VPC endpoint association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the resource gateway.
        public let id: String?
        /// The type of IP address used by the resource gateway.
        public let ipAddressType: ResourceGatewayIpAddressType?
        /// The most recent date and time that the resource gateway was updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the resource gateway.
        public let name: String?
        /// The IDs of the security groups applied to the resource gateway.
        public let securityGroupIds: [String]?
        /// The name of the resource gateway.
        public let status: ResourceGatewayStatus?
        /// The IDs of the VPC subnets for the resource gateway.
        public let subnetIds: [String]?
        /// The ID of the VPC for the resource gateway.
        public let vpcIdentifier: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, ipAddressType: ResourceGatewayIpAddressType? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: ResourceGatewayStatus? = nil, subnetIds: [String]? = nil, vpcIdentifier: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcIdentifier = vpcIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        public let message: String
        /// The resource ID.
        public let resourceId: String
        /// The resource type.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct RuleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rule.
        public let arn: String?
        /// The date and time that the listener rule was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the rule.
        public let id: String?
        /// Indicates whether this is the default listener rule.
        public let isDefault: Bool?
        /// The date and time that the listener rule was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the rule.
        public let name: String?
        /// The priority of the rule.
        public let priority: Int?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, isDefault: Bool? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, priority: Int? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case isDefault = "isDefault"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct RuleUpdate: AWSEncodableShape {
        /// The rule action.
        public let action: RuleAction?
        /// The rule match.
        public let match: RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public let priority: Int?
        /// The ID or ARN of the rule.
        public let ruleIdentifier: String

        @inlinable
        public init(action: RuleAction? = nil, match: RuleMatch? = nil, priority: Int? = nil, ruleIdentifier: String) {
            self.action = action
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case priority = "priority"
            case ruleIdentifier = "ruleIdentifier"
        }
    }

    public struct RuleUpdateFailure: AWSDecodableShape {
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID or ARN of the rule.
        public let ruleIdentifier: String?

        @inlinable
        public init(failureCode: String? = nil, failureMessage: String? = nil, ruleIdentifier: String? = nil) {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.ruleIdentifier = ruleIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case ruleIdentifier = "ruleIdentifier"
        }
    }

    public struct RuleUpdateSuccess: AWSDecodableShape {
        /// The action for the rule.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The ID of the listener.
        public let id: String?
        /// Indicates whether this is the default rule.
        public let isDefault: Bool?
        /// The rule match.
        public let match: RuleMatch?
        /// The name of the listener.
        public let name: String?
        /// The rule priority.
        public let priority: Int?

        @inlinable
        public init(action: RuleAction? = nil, arn: String? = nil, id: String? = nil, isDefault: Bool? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case id = "id"
            case isDefault = "isDefault"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct ServiceNetworkEndpointAssociation: AWSDecodableShape {
        /// The date and time that the association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the association.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The state of the association.
        public let state: String?
        /// The ID of the VPC endpoint associated with the service network.
        public let vpcEndpointId: String?
        /// The owner of the VPC endpoint associated with the service network.
        public let vpcEndpointOwnerId: String?
        /// The ID of the VPC for the association.
        public let vpcId: String?

        @inlinable
        public init(createdAt: Date? = nil, id: String? = nil, serviceNetworkArn: String? = nil, state: String? = nil, vpcEndpointId: String? = nil, vpcEndpointOwnerId: String? = nil, vpcId: String? = nil) {
            self.createdAt = createdAt
            self.id = id
            self.serviceNetworkArn = serviceNetworkArn
            self.state = state
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwnerId = vpcEndpointOwnerId
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case id = "id"
            case serviceNetworkArn = "serviceNetworkArn"
            case state = "state"
            case vpcEndpointId = "vpcEndpointId"
            case vpcEndpointOwnerId = "vpcEndpointOwnerId"
            case vpcId = "vpcId"
        }
    }

    public struct ServiceNetworkResourceAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The DNS entry for the service.
        public let dnsEntry: DnsEntry?
        /// The failure code.
        public let failureCode: String?
        /// The ID of the association between the service network and resource configuration.
        public let id: String?
        /// Specifies whether the association is managed by Amazon.
        public let isManagedAssociation: Bool?
        /// The private DNS entry for the service.
        public let privateDnsEntry: DnsEntry?
        /// The Amazon Resource Name (ARN) of the association.
        public let resourceConfigurationArn: String?
        /// The ID of the resource configuration associated with the service network.
        public let resourceConfigurationId: String?
        /// The name of the resource configuration associated with the service network.
        public let resourceConfigurationName: String?
        /// The Amazon Resource Name (ARN) of the service network associated with the resource configuration.
        public let serviceNetworkArn: String?
        /// The ID of the service network associated with the resource configuration.
        public let serviceNetworkId: String?
        /// The name of the service network associated with the resource configuration.
        public let serviceNetworkName: String?
        /// The status of the service network associated with the resource configuration.
        public let status: ServiceNetworkResourceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, dnsEntry: DnsEntry? = nil, failureCode: String? = nil, id: String? = nil, isManagedAssociation: Bool? = nil, privateDnsEntry: DnsEntry? = nil, resourceConfigurationArn: String? = nil, resourceConfigurationId: String? = nil, resourceConfigurationName: String? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkResourceAssociationStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dnsEntry = dnsEntry
            self.failureCode = failureCode
            self.id = id
            self.isManagedAssociation = isManagedAssociation
            self.privateDnsEntry = privateDnsEntry
            self.resourceConfigurationArn = resourceConfigurationArn
            self.resourceConfigurationId = resourceConfigurationId
            self.resourceConfigurationName = resourceConfigurationName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case dnsEntry = "dnsEntry"
            case failureCode = "failureCode"
            case id = "id"
            case isManagedAssociation = "isManagedAssociation"
            case privateDnsEntry = "privateDnsEntry"
            case resourceConfigurationArn = "resourceConfigurationArn"
            case resourceConfigurationId = "resourceConfigurationId"
            case resourceConfigurationName = "resourceConfigurationName"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
        }
    }

    public struct ServiceNetworkServiceAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS information.
        public let dnsEntry: DnsEntry?
        /// The ID of the association.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?
        /// The name of the service.
        public let serviceName: String?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status. If the deletion fails, try to delete again.
        public let status: ServiceNetworkServiceAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, serviceArn: String? = nil, serviceId: String? = nil, serviceName: String? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
            case serviceName = "serviceName"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
        }
    }

    public struct ServiceNetworkSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The date and time that the service network was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the service network.
        public let id: String?
        /// The date and time that the service network was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service network.
        public let name: String?
        /// The number of resource configurations associated with a service network.
        public let numberOfAssociatedResourceConfigurations: Int64?
        /// The number of services associated with the service network.
        public let numberOfAssociatedServices: Int64?
        /// The number of VPCs associated with the service network.
        public let numberOfAssociatedVPCs: Int64?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, numberOfAssociatedResourceConfigurations: Int64? = nil, numberOfAssociatedServices: Int64? = nil, numberOfAssociatedVPCs: Int64? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedResourceConfigurations = numberOfAssociatedResourceConfigurations
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case numberOfAssociatedResourceConfigurations = "numberOfAssociatedResourceConfigurations"
            case numberOfAssociatedServices = "numberOfAssociatedServices"
            case numberOfAssociatedVPCs = "numberOfAssociatedVPCs"
        }
    }

    public struct ServiceNetworkVpcAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The ID of the association.
        public let id: String?
        /// The date and time that the association was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status.
        public let status: ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public let vpcId: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkVpcAssociationStatus? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
            case vpcId = "vpcId"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        public let message: String
        /// The ID of the service quota that was exceeded.
        public let quotaCode: String
        /// The resource ID.
        public let resourceId: String?
        /// The resource type.
        public let resourceType: String
        /// The service code.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String? = nil, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct ServiceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The date and time that the service was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS information.
        public let dnsEntry: DnsEntry?
        /// The ID of the service.
        public let id: String?
        /// The date and time that the service was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service.
        public let name: String?
        /// The status.
        public let status: ServiceStatus?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct SharingConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies if the service network is enabled for sharing.
        public let enabled: Bool?

        @inlinable
        public init(enabled: Bool? = nil) {
            self.enabled = enabled
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags for the resource.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:vpc-lattice:([a-z0-9][-.a-z0-9]{0,62})?:\\d{12}?:[^/].{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Target: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target group type is ALB, this is the ARN of an Application Load Balancer.
        public let id: String
        /// The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
        public let port: Int?

        @inlinable
        public init(id: String, port: Int? = nil) {
            self.id = id
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case port = "port"
        }
    }

    public struct TargetFailure: AWSDecodableShape {
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target group type is ALB, this is the ARN of an Application Load Balancer.
        public let id: String?
        /// The port on which the target is listening. This parameter doesn't apply if the target is a Lambda function.
        public let port: Int?

        @inlinable
        public init(failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, port: Int? = nil) {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case port = "port"
        }
    }

    public struct TargetGroupConfig: AWSEncodableShape & AWSDecodableShape {
        /// The health check configuration. Not supported if the target group type is LAMBDA or ALB.
        public let healthCheck: HealthCheckConfig?
        /// The type of IP address used for the target group. Supported only if the target group type is IP. The default is IPV4.
        public let ipAddressType: IpAddressType?
        /// The version of the event structure that your Lambda function receives. Supported only if the target group type is LAMBDA. The default is V1.
        public let lambdaEventStructureVersion: LambdaEventStructureVersion?
        /// The port on which the targets are listening. For HTTP, the default is 80. For HTTPS, the default is 443. Not supported if the target group type is LAMBDA.
        public let port: Int?
        /// The protocol to use for routing traffic to the targets. The default is the protocol of the target group. Not supported if the target group type is LAMBDA.
        public let `protocol`: TargetGroupProtocol?
        /// The protocol version. The default is HTTP1. Not supported if the target group type is LAMBDA.
        public let protocolVersion: TargetGroupProtocolVersion?
        /// The ID of the VPC. Not supported if the target group type is LAMBDA.
        public let vpcIdentifier: String?

        @inlinable
        public init(healthCheck: HealthCheckConfig? = nil, ipAddressType: IpAddressType? = nil, lambdaEventStructureVersion: LambdaEventStructureVersion? = nil, port: Int? = nil, protocol: TargetGroupProtocol? = nil, protocolVersion: TargetGroupProtocolVersion? = nil, vpcIdentifier: String? = nil) {
            self.healthCheck = healthCheck
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.vpcIdentifier = vpcIdentifier
        }

        public func validate(name: String) throws {
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
            case ipAddressType = "ipAddressType"
            case lambdaEventStructureVersion = "lambdaEventStructureVersion"
            case port = "port"
            case `protocol` = "protocol"
            case protocolVersion = "protocolVersion"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct TargetGroupSummary: AWSDecodableShape {
        /// The ARN (Amazon Resource Name) of the target group.
        public let arn: String?
        /// The date and time that the target group was created, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the target group.
        public let id: String?
        /// The type of IP address used for the target group. The possible values are IPV4 and IPV6. This is an optional parameter. If not specified, the default is IPV4.
        public let ipAddressType: IpAddressType?
        /// The version of the event structure that your Lambda function receives. Supported only if the target group type is LAMBDA.
        public let lambdaEventStructureVersion: LambdaEventStructureVersion?
        /// The date and time that the target group was last updated, in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the target group.
        public let name: String?
        /// The port of the target group.
        public let port: Int?
        /// The protocol of the target group.
        public let `protocol`: TargetGroupProtocol?
        /// The Amazon Resource Names (ARNs) of the service.
        public let serviceArns: [String]?
        /// The status.
        public let status: TargetGroupStatus?
        /// The target group type.
        public let type: TargetGroupType?
        /// The ID of the VPC of the target group.
        public let vpcIdentifier: String?

        @inlinable
        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, ipAddressType: IpAddressType? = nil, lambdaEventStructureVersion: LambdaEventStructureVersion? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, port: Int? = nil, protocol: TargetGroupProtocol? = nil, serviceArns: [String]? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil, vpcIdentifier: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
            self.vpcIdentifier = vpcIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case lambdaEventStructureVersion = "lambdaEventStructureVersion"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArns = "serviceArns"
            case status = "status"
            case type = "type"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct TargetSummary: AWSDecodableShape {
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target type is ALB, this is the ARN of an Application Load Balancer.
        public let id: String?
        /// The port on which the target is listening.
        public let port: Int?
        /// The code for why the target status is what it is.
        public let reasonCode: String?
        /// The status of the target.    DRAINING: The target is being deregistered. No new connections are sent to this target while current connections are being drained. The default draining time is 5 minutes.    UNAVAILABLE: Health checks are unavailable for the target group.    HEALTHY: The target is healthy.    UNHEALTHY: The target is unhealthy.    INITIAL: Initial health checks on the target are being performed.    UNUSED: Target group is not used in a service.
        public let status: TargetStatus?

        @inlinable
        public init(id: String? = nil, port: Int? = nil, reasonCode: String? = nil, status: TargetStatus? = nil) {
            self.id = id
            self.port = port
            self.reasonCode = reasonCode
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case port = "port"
            case reasonCode = "reasonCode"
            case status = "status"
        }
    }

    public struct ThrottlingException: AWSErrorShape {
        public let message: String
        /// The ID of the service quota that was exceeded.
        public let quotaCode: String?
        /// The number of seconds to wait before retrying.
        public let retryAfterSeconds: Int?
        /// The service code.
        public let serviceCode: String?

        @inlinable
        public init(message: String, quotaCode: String? = nil, retryAfterSeconds: Int? = nil, serviceCode: String? = nil) {
            self.message = message
            self.quotaCode = quotaCode
            self.retryAfterSeconds = retryAfterSeconds
            self.serviceCode = serviceCode
        }

        public init(from decoder: Decoder) throws {
            let response = decoder.userInfo[.awsResponse]! as! ResponseDecodingContainer
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try container.decode(String.self, forKey: .message)
            self.quotaCode = try container.decodeIfPresent(String.self, forKey: .quotaCode)
            self.retryAfterSeconds = try response.decodeHeaderIfPresent(Int.self, key: "Retry-After")
            self.serviceCode = try container.decodeIfPresent(String.self, forKey: .serviceCode)
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case serviceCode = "serviceCode"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys of the tags to remove.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:vpc-lattice:([a-z0-9][-.a-z0-9]{0,62})?:\\d{12}?:[^/].{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessLogSubscriptionRequest: AWSEncodableShape {
        /// The ID or ARN of the access log subscription.
        public let accessLogSubscriptionIdentifier: String
        /// The Amazon Resource Name (ARN) of the access log destination.
        public let destinationArn: String

        @inlinable
        public init(accessLogSubscriptionIdentifier: String, destinationArn: String) {
            self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
            self.destinationArn = destinationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessLogSubscriptionIdentifier, key: "accessLogSubscriptionIdentifier")
            try container.encode(self.destinationArn, forKey: .destinationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, max: 2048)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, min: 17)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, pattern: "^((als-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:accesslogsubscription/als-[0-9a-z]{17}))$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, min: 20)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "destinationArn"
        }
    }

    public struct UpdateAccessLogSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the access log destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let resourceArn: String
        /// The ID of the resource.
        public let resourceId: String

        @inlinable
        public init(arn: String, destinationArn: String, id: String, resourceArn: String, resourceId: String) {
            self.arn = arn
            self.destinationArn = destinationArn
            self.id = id
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinationArn = "destinationArn"
            case id = "id"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct UpdateListenerRequest: AWSEncodableShape {
        /// The action for the default rule.
        public let defaultAction: RuleAction
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(defaultAction: RuleAction, listenerIdentifier: String, serviceIdentifier: String) {
            self.defaultAction = defaultAction
            self.listenerIdentifier = listenerIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.defaultAction, forKey: .defaultAction)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.defaultAction.validate(name: "\(name).defaultAction")
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "defaultAction"
        }
    }

    public struct UpdateListenerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The action for the default rule.
        public let defaultAction: RuleAction?
        /// The ID of the listener.
        public let id: String?
        /// The name of the listener.
        public let name: String?
        /// The listener port.
        public let port: Int?
        /// The protocol of the listener.
        public let `protocol`: ListenerProtocol?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?

        @inlinable
        public init(arn: String? = nil, defaultAction: RuleAction? = nil, id: String? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil, serviceArn: String? = nil, serviceId: String? = nil) {
            self.arn = arn
            self.defaultAction = defaultAction
            self.id = id
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArn = serviceArn
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case defaultAction = "defaultAction"
            case id = "id"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
        }
    }

    public struct UpdateResourceConfigurationRequest: AWSEncodableShape {
        /// Indicates whether to add the resource configuration to service networks that are shared with other accounts.
        public let allowAssociationToShareableServiceNetwork: Bool?
        /// The TCP port ranges that a consumer can use to access a resource configuration. You can separate port ranges with a comma. Example: 1-65535 or 1,2,22-30
        public let portRanges: [String]?
        /// The resource configuration.
        public let resourceConfigurationDefinition: ResourceConfigurationDefinition?
        /// The ID of the resource configuration.
        public let resourceConfigurationIdentifier: String

        @inlinable
        public init(allowAssociationToShareableServiceNetwork: Bool? = nil, portRanges: [String]? = nil, resourceConfigurationDefinition: ResourceConfigurationDefinition? = nil, resourceConfigurationIdentifier: String) {
            self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
            self.portRanges = portRanges
            self.resourceConfigurationDefinition = resourceConfigurationDefinition
            self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.allowAssociationToShareableServiceNetwork, forKey: .allowAssociationToShareableServiceNetwork)
            try container.encodeIfPresent(self.portRanges, forKey: .portRanges)
            try container.encodeIfPresent(self.resourceConfigurationDefinition, forKey: .resourceConfigurationDefinition)
            request.encodePath(self.resourceConfigurationIdentifier, key: "resourceConfigurationIdentifier")
        }

        public func validate(name: String) throws {
            try self.portRanges?.forEach {
                try validate($0, name: "portRanges[]", parent: name, max: 11)
                try validate($0, name: "portRanges[]", parent: name, min: 1)
                try validate($0, name: "portRanges[]", parent: name, pattern: "^((\\d{1,5}\\-\\d{1,5})|(\\d+))$")
            }
            try self.resourceConfigurationDefinition?.validate(name: "\(name).resourceConfigurationDefinition")
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, min: 20)
            try self.validate(self.resourceConfigurationIdentifier, name: "resourceConfigurationIdentifier", parent: name, pattern: "^((rcfg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourceconfiguration/rcfg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowAssociationToShareableServiceNetwork = "allowAssociationToShareableServiceNetwork"
            case portRanges = "portRanges"
            case resourceConfigurationDefinition = "resourceConfigurationDefinition"
        }
    }

    public struct UpdateResourceConfigurationResponse: AWSDecodableShape {
        /// Indicates whether to add the resource configuration to service networks that are shared with other accounts.
        public let allowAssociationToShareableServiceNetwork: Bool?
        /// The Amazon Resource Name (ARN) of the resource configuration.
        public let arn: String?
        /// The ID of the resource configuration.
        public let id: String?
        /// The name of the resource configuration.
        public let name: String?
        /// The TCP port ranges that a consumer can use to access a resource configuration. You can separate port ranges with a comma. Example: 1-65535 or 1,2,22-30
        public let portRanges: [String]?
        /// The TCP protocol accepted by the specified resource configuration.
        public let `protocol`: ProtocolType?
        /// The resource configuration.
        public let resourceConfigurationDefinition: ResourceConfigurationDefinition?
        /// The ID of the group resource configuration.
        public let resourceConfigurationGroupId: String?
        /// The ID of the resource gateway associated with the resource configuration.
        public let resourceGatewayId: String?
        /// The status of the resource configuration.
        public let status: ResourceConfigurationStatus?
        /// The type of resource configuration.    SINGLE - A single resource.    GROUP - A group of resources.    CHILD - A single resource that is part of a group resource configuration.    ARN - An Amazon Web Services resource.
        public let type: ResourceConfigurationType?

        @inlinable
        public init(allowAssociationToShareableServiceNetwork: Bool? = nil, arn: String? = nil, id: String? = nil, name: String? = nil, portRanges: [String]? = nil, protocol: ProtocolType? = nil, resourceConfigurationDefinition: ResourceConfigurationDefinition? = nil, resourceConfigurationGroupId: String? = nil, resourceGatewayId: String? = nil, status: ResourceConfigurationStatus? = nil, type: ResourceConfigurationType? = nil) {
            self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
            self.arn = arn
            self.id = id
            self.name = name
            self.portRanges = portRanges
            self.`protocol` = `protocol`
            self.resourceConfigurationDefinition = resourceConfigurationDefinition
            self.resourceConfigurationGroupId = resourceConfigurationGroupId
            self.resourceGatewayId = resourceGatewayId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case allowAssociationToShareableServiceNetwork = "allowAssociationToShareableServiceNetwork"
            case arn = "arn"
            case id = "id"
            case name = "name"
            case portRanges = "portRanges"
            case `protocol` = "protocol"
            case resourceConfigurationDefinition = "resourceConfigurationDefinition"
            case resourceConfigurationGroupId = "resourceConfigurationGroupId"
            case resourceGatewayId = "resourceGatewayId"
            case status = "status"
            case type = "type"
        }
    }

    public struct UpdateResourceGatewayRequest: AWSEncodableShape {
        /// The ID or ARN of the resource gateway.
        public let resourceGatewayIdentifier: String
        /// The IDs of the security groups associated with the resource gateway.
        public let securityGroupIds: [String]?

        @inlinable
        public init(resourceGatewayIdentifier: String, securityGroupIds: [String]? = nil) {
            self.resourceGatewayIdentifier = resourceGatewayIdentifier
            self.securityGroupIds = securityGroupIds
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceGatewayIdentifier, key: "resourceGatewayIdentifier")
            try container.encodeIfPresent(self.securityGroupIds, forKey: .securityGroupIds)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, max: 2048)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, min: 17)
            try self.validate(self.resourceGatewayIdentifier, name: "resourceGatewayIdentifier", parent: name, pattern: "^((rgw-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:resourcegateway/rgw-[0-9a-z]{17}))$")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 5)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-(([0-9a-z]{8})|([0-9a-z]{17}))$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
        }
    }

    public struct UpdateResourceGatewayResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public let arn: String?
        /// The ID of the resource gateway.
        public let id: String?
        /// The type of IP address used by the resource gateway.
        public let ipAddressType: IpAddressType?
        /// The name of the resource gateway.
        public let name: String?
        /// The IDs of the security groups associated with the resource gateway.
        public let securityGroupIds: [String]?
        /// The status of the resource gateway.
        public let status: ResourceGatewayStatus?
        /// The IDs of the VPC subnets for the resource gateway.
        public let subnetIds: [String]?
        /// The ID of the VPC for the resource gateway.
        public let vpcId: String?

        @inlinable
        public init(arn: String? = nil, id: String? = nil, ipAddressType: IpAddressType? = nil, name: String? = nil, securityGroupIds: [String]? = nil, status: ResourceGatewayStatus? = nil, subnetIds: [String]? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case name = "name"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
            case subnetIds = "subnetIds"
            case vpcId = "vpcId"
        }
    }

    public struct UpdateRuleRequest: AWSEncodableShape {
        /// Information about the action for the specified listener rule.
        public let action: RuleAction?
        /// The ID or ARN of the listener.
        public let listenerIdentifier: String
        /// The rule match.
        public let match: RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public let priority: Int?
        /// The ID or ARN of the rule.
        public let ruleIdentifier: String
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(action: RuleAction? = nil, listenerIdentifier: String, match: RuleMatch? = nil, priority: Int? = nil, ruleIdentifier: String, serviceIdentifier: String) {
            self.action = action
            self.listenerIdentifier = listenerIdentifier
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.action, forKey: .action)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            try container.encodeIfPresent(self.match, forKey: .match)
            try container.encodeIfPresent(self.priority, forKey: .priority)
            request.encodePath(self.ruleIdentifier, key: "ruleIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case priority = "priority"
        }
    }

    public struct UpdateRuleResponse: AWSDecodableShape {
        /// Information about the action for the specified listener rule.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The ID of the listener.
        public let id: String?
        /// Indicates whether this is the default rule.
        public let isDefault: Bool?
        /// The rule match.
        public let match: RuleMatch?
        /// The name of the listener.
        public let name: String?
        /// The rule priority.
        public let priority: Int?

        @inlinable
        public init(action: RuleAction? = nil, arn: String? = nil, id: String? = nil, isDefault: Bool? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case id = "id"
            case isDefault = "isDefault"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct UpdateServiceNetworkRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType
        /// The ID or ARN of the service network.
        public let serviceNetworkIdentifier: String

        @inlinable
        public init(authType: AuthType, serviceNetworkIdentifier: String) {
            self.authType = authType
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.authType, forKey: .authType)
            request.encodePath(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
        }
    }

    public struct UpdateServiceNetworkResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The ID of the service network.
        public let id: String?
        /// The name of the service network.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, authType: AuthType? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.authType = authType
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case id = "id"
            case name = "name"
        }
    }

    public struct UpdateServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// The IDs of the security groups.
        public let securityGroupIds: [String]
        /// The ID or ARN of the association.
        public let serviceNetworkVpcAssociationIdentifier: String

        @inlinable
        public init(securityGroupIds: [String], serviceNetworkVpcAssociationIdentifier: String) {
            self.securityGroupIds = securityGroupIds
            self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.securityGroupIds, forKey: .securityGroupIds)
            request.encodePath(self.serviceNetworkVpcAssociationIdentifier, key: "serviceNetworkVpcAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 5)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-(([0-9a-z]{8})|([0-9a-z]{17}))$")
            }
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, pattern: "^((snva-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkvpcassociation/snva-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
        }
    }

    public struct UpdateServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The account that created the association.
        public let createdBy: String?
        /// The ID of the association.
        public let id: String?
        /// The IDs of the security groups.
        public let securityGroupIds: [String]?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
        public let status: ServiceNetworkVpcAssociationStatus?

        @inlinable
        public init(arn: String? = nil, createdBy: String? = nil, id: String? = nil, securityGroupIds: [String]? = nil, status: ServiceNetworkVpcAssociationStatus? = nil) {
            self.arn = arn
            self.createdBy = createdBy
            self.id = id
            self.securityGroupIds = securityGroupIds
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case id = "id"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
        }
    }

    public struct UpdateServiceRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The ID or ARN of the service.
        public let serviceIdentifier: String

        @inlinable
        public init(authType: AuthType? = nil, certificateArn: String? = nil, serviceIdentifier: String) {
            self.authType = authType
            self.certificateArn = certificateArn
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authType, forKey: .authType)
            try container.encodeIfPresent(self.certificateArn, forKey: .certificateArn)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, max: 2048)
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "^(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:certificate/[0-9a-z-]+)?$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case certificateArn = "certificateArn"
        }
    }

    public struct UpdateServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The ID of the service.
        public let id: String?
        /// The name of the service.
        public let name: String?

        @inlinable
        public init(arn: String? = nil, authType: AuthType? = nil, certificateArn: String? = nil, customDomainName: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.authType = authType
            self.certificateArn = certificateArn
            self.customDomainName = customDomainName
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case certificateArn = "certificateArn"
            case customDomainName = "customDomainName"
            case id = "id"
            case name = "name"
        }
    }

    public struct UpdateTargetGroupRequest: AWSEncodableShape {
        /// The health check configuration.
        public let healthCheck: HealthCheckConfig
        /// The ID or ARN of the target group.
        public let targetGroupIdentifier: String

        @inlinable
        public init(healthCheck: HealthCheckConfig, targetGroupIdentifier: String) {
            self.healthCheck = healthCheck
            self.targetGroupIdentifier = targetGroupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.healthCheck, forKey: .healthCheck)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
        }

        public func validate(name: String) throws {
            try self.healthCheck.validate(name: "\(name).healthCheck")
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
        }
    }

    public struct UpdateTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The target group configuration.
        public let config: TargetGroupConfig?
        /// The ID of the target group.
        public let id: String?
        /// The name of the target group.
        public let name: String?
        /// The status.
        public let status: TargetGroupStatus?
        /// The target group type.
        public let type: TargetGroupType?

        @inlinable
        public init(arn: String? = nil, config: TargetGroupConfig? = nil, id: String? = nil, name: String? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil) {
            self.arn = arn
            self.config = config
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case config = "config"
            case id = "id"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct ValidationException: AWSErrorShape {
        /// The fields that failed validation.
        public let fieldList: [ValidationExceptionField]?
        public let message: String
        /// The reason.
        public let reason: ValidationExceptionReason

        @inlinable
        public init(fieldList: [ValidationExceptionField]? = nil, message: String, reason: ValidationExceptionReason) {
            self.fieldList = fieldList
            self.message = message
            self.reason = reason
        }

        private enum CodingKeys: String, CodingKey {
            case fieldList = "fieldList"
            case message = "message"
            case reason = "reason"
        }
    }

    public struct ValidationExceptionField: AWSDecodableShape {
        /// Additional information about why the validation failed.
        public let message: String
        /// The name of the validation exception.
        public let name: String

        @inlinable
        public init(message: String, name: String) {
            self.message = message
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case name = "name"
        }
    }

    public struct WeightedTargetGroup: AWSEncodableShape & AWSDecodableShape {
        /// The ID or ARN of the target group.
        public let targetGroupIdentifier: String
        /// Only required if you specify multiple target groups for a forward action. The weight determines how requests are distributed to the target group. For example, if you specify two target groups, each with a weight of 10, each target group receives half the requests. If you specify two target groups, one with a weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. If there's only one target group specified, then the default value is 100.
        public let weight: Int?

        @inlinable
        public init(targetGroupIdentifier: String, weight: Int? = nil) {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.validate(self.weight, name: "weight", parent: name, max: 999)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case targetGroupIdentifier = "targetGroupIdentifier"
            case weight = "weight"
        }
    }

    public struct Matcher: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP code to use when checking for a successful response from a target.
        public let httpCode: String?

        @inlinable
        public init(httpCode: String? = nil) {
            self.httpCode = httpCode
        }

        public func validate(name: String) throws {
            try self.validate(self.httpCode, name: "httpCode", parent: name, max: 2000)
            try self.validate(self.httpCode, name: "httpCode", parent: name, pattern: "(^[0-9-,]+$|(^$))")
        }

        private enum CodingKeys: String, CodingKey {
            case httpCode = "httpCode"
        }
    }

    public struct RuleMatch: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP criteria that a rule must match.
        public let httpMatch: HttpMatch?

        @inlinable
        public init(httpMatch: HttpMatch? = nil) {
            self.httpMatch = httpMatch
        }

        public func validate(name: String) throws {
            try self.httpMatch?.validate(name: "\(name).httpMatch")
        }

        private enum CodingKeys: String, CodingKey {
            case httpMatch = "httpMatch"
        }
    }
}

// MARK: - Errors

/// Error enum for VPCLattice
public struct VPCLatticeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize VPCLattice
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The user does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request conflicts with the current state of the resource. Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource that does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The limit on the number of requests per second was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input does not satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension VPCLatticeErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": VPCLattice.ConflictException.self,
        "InternalServerException": VPCLattice.InternalServerException.self,
        "ResourceNotFoundException": VPCLattice.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": VPCLattice.ServiceQuotaExceededException.self,
        "ThrottlingException": VPCLattice.ThrottlingException.self,
        "ValidationException": VPCLattice.ValidationException.self
    ]
}

extension VPCLatticeErrorType: Equatable {
    public static func == (lhs: VPCLatticeErrorType, rhs: VPCLatticeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension VPCLatticeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
