//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension VPCLattice {
    // MARK: Enums

    public enum AuthPolicyState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case inactive = "Inactive"
        public var description: String { return self.rawValue }
    }

    public enum AuthType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIam = "AWS_IAM"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum HealthCheckProtocolVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1 = "HTTP1"
        /// Indicates use of HTTP/2 to send requests to target
        case http2 = "HTTP2"
        public var description: String { return self.rawValue }
    }

    public enum IpAddressType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates IPv4 address type
        case ipv4 = "IPV4"
        /// Indicates IPv6 address type
        case ipv6 = "IPV6"
        public var description: String { return self.rawValue }
    }

    public enum LambdaEventStructureVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// This is the default lambda event structure version
        case v1 = "V1"
        /// Indicates use of lambda event structure version 2
        case v2 = "V2"
        public var description: String { return self.rawValue }
    }

    public enum ListenerProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates HTTP protocol
        case http = "HTTP"
        /// Indicates HTTPS protocol
        case https = "HTTPS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNetworkServiceAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ServiceNetwork and Service association is active
        case active = "ACTIVE"
        /// ServiceNetwork and Service association creation failed.
        case createFailed = "CREATE_FAILED"
        /// ServiceNetwork and Service association creation in progress
        case createInProgress = "CREATE_IN_PROGRESS"
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed = "DELETE_FAILED"
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNetworkVpcAssociationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// ServiceNetwork and Vpc association is active
        case active = "ACTIVE"
        /// ServiceNetwork and Vpc association creation failed.
        case createFailed = "CREATE_FAILED"
        /// ServiceNetwork and Vpc association creation in progress
        case createInProgress = "CREATE_IN_PROGRESS"
        /// ServiceNetwork and Vpc association deletion failed
        case deleteFailed = "DELETE_FAILED"
        /// ServiceNetwork and Vpc association deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        /// ServiceNetwork and Vpc association update failed
        case updateFailed = "UPDATE_FAILED"
        /// ServiceNetwork and Vpc association update in progress
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum ServiceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Service is active.
        case active = "ACTIVE"
        /// Service creation failed
        case createFailed = "CREATE_FAILED"
        /// Service creation in progress.
        case createInProgress = "CREATE_IN_PROGRESS"
        /// Service deletion failed.
        case deleteFailed = "DELETE_FAILED"
        /// Service deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupProtocol: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates HTTP protocol
        case http = "HTTP"
        /// Indicates HTTPS protocol
        case https = "HTTPS"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupProtocolVersion: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates use of gRPC to send requests to target
        case grpc = "GRPC"
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1 = "HTTP1"
        /// Indicates use of HTTP/2 to send requests to target
        case http2 = "HTTP2"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// TargetGroup is active
        case active = "ACTIVE"
        /// TargetGroup creation failed.
        case createFailed = "CREATE_FAILED"
        /// TargetGroup creation in progress
        case createInProgress = "CREATE_IN_PROGRESS"
        /// TargetGroup deletion failed
        case deleteFailed = "DELETE_FAILED"
        /// TargetGroup deletion in progress
        case deleteInProgress = "DELETE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum TargetGroupType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// Indicates target in this target group is an ALB
        case alb = "ALB"
        /// Indicates targets in this target group are EC2 instances
        case instance = "INSTANCE"
        /// Indicates targets in this target group are IP
        case ip = "IP"
        /// Indicates targets in this target group are Lambda
        case lambda = "LAMBDA"
        public var description: String { return self.rawValue }
    }

    public enum TargetStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        /// The target is deregistering and connection draining is in process.
        case draining = "DRAINING"
        /// The target is healthy.
        case healthy = "HEALTHY"
        /// The initial health check is in progress.
        case initial = "INITIAL"
        /// Health checks are disabled.
        case unavailable = "UNAVAILABLE"
        /// The target failed the health check.
        case unhealthy = "UNHEALTHY"
        /// The target group is not used in a listener rule.
        case unused = "UNUSED"
        public var description: String { return self.rawValue }
    }

    public enum HeaderMatchType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Specifies a contains type match.
        case contains(String)
        /// Specifies an exact type match.
        case exact(String)
        /// Specifies a prefix type match. Matches the value with the prefix.
        case prefix(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contains:
                let value = try container.decode(String.self, forKey: .contains)
                self = .contains(value)
            case .exact:
                let value = try container.decode(String.self, forKey: .exact)
                self = .exact(value)
            case .prefix:
                let value = try container.decode(String.self, forKey: .prefix)
                self = .prefix(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .contains(let value):
                try container.encode(value, forKey: .contains)
            case .exact(let value):
                try container.encode(value, forKey: .exact)
            case .prefix(let value):
                try container.encode(value, forKey: .prefix)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contains(let value):
                try self.validate(value, name: "contains", parent: name, max: 200)
                try self.validate(value, name: "contains", parent: name, min: 1)
            case .exact(let value):
                try self.validate(value, name: "exact", parent: name, max: 200)
                try self.validate(value, name: "exact", parent: name, min: 1)
            case .prefix(let value):
                try self.validate(value, name: "prefix", parent: name, max: 200)
                try self.validate(value, name: "prefix", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contains = "contains"
            case exact = "exact"
            case prefix = "prefix"
        }
    }

    public enum PathMatchType: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// An exact match of the path.
        case exact(String)
        /// A prefix match of the path.
        case prefix(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .exact:
                let value = try container.decode(String.self, forKey: .exact)
                self = .exact(value)
            case .prefix:
                let value = try container.decode(String.self, forKey: .prefix)
                self = .prefix(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .exact(let value):
                try container.encode(value, forKey: .exact)
            case .prefix(let value):
                try container.encode(value, forKey: .prefix)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .exact(let value):
                try self.validate(value, name: "exact", parent: name, max: 200)
                try self.validate(value, name: "exact", parent: name, min: 1)
                try self.validate(value, name: "exact", parent: name, pattern: "^/[a-zA-Z0-9@:%_+.~#?&/=-]*$")
            case .prefix(let value):
                try self.validate(value, name: "prefix", parent: name, max: 200)
                try self.validate(value, name: "prefix", parent: name, min: 1)
                try self.validate(value, name: "prefix", parent: name, pattern: "^/[a-zA-Z0-9@:%_+.~#?&/=-]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case exact = "exact"
            case prefix = "prefix"
        }
    }

    public enum RuleAction: AWSEncodableShape & AWSDecodableShape, Sendable {
        ///  Describes the rule action that returns a custom HTTP response.
        case fixedResponse(FixedResponseAction)
        /// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        case forward(ForwardAction)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .fixedResponse:
                let value = try container.decode(FixedResponseAction.self, forKey: .fixedResponse)
                self = .fixedResponse(value)
            case .forward:
                let value = try container.decode(ForwardAction.self, forKey: .forward)
                self = .forward(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .fixedResponse(let value):
                try container.encode(value, forKey: .fixedResponse)
            case .forward(let value):
                try container.encode(value, forKey: .forward)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .fixedResponse(let value):
                try value.validate(name: "\(name).fixedResponse")
            case .forward(let value):
                try value.validate(name: "\(name).forward")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case fixedResponse = "fixedResponse"
            case forward = "forward"
        }
    }

    // MARK: Shapes

    public struct AccessLogSubscriptionSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription
        public let arn: String
        /// The date and time that the access log subscription was created, specified in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The Amazon Resource Name (ARN) of the service or service network.
        public let resourceArn: String
        /// The ID of the service or service network.
        public let resourceId: String

        public init(arn: String, createdAt: Date, destinationArn: String, id: String, lastUpdatedAt: Date, resourceArn: String, resourceId: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case destinationArn = "destinationArn"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct BatchUpdateRuleRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The rules for the specified listener.
        public let rules: [RuleUpdate]
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(listenerIdentifier: String, rules: [RuleUpdate], serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.rules = rules
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            try container.encode(self.rules, forKey: .rules)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 5)
            try self.validate(self.rules, name: "rules", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "rules"
        }
    }

    public struct BatchUpdateRuleResponse: AWSDecodableShape {
        /// The rules that were successfully updated.
        public let successful: [RuleUpdateSuccess]?
        /// The rules that the operation couldn't update.
        public let unsuccessful: [RuleUpdateFailure]?

        public init(successful: [RuleUpdateSuccess]? = nil, unsuccessful: [RuleUpdateFailure]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        private enum CodingKeys: String, CodingKey {
            case successful = "successful"
            case unsuccessful = "unsuccessful"
        }
    }

    public struct CreateAccessLogSubscriptionRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The Amazon Resource Name (ARN) of the destination. The supported destination types are CloudWatch Log groups, Kinesis Data Firehose delivery streams, and Amazon S3 buckets.
        public let destinationArn: String
        /// The ID or Amazon Resource Name (ARN) of the service network or service.
        public let resourceIdentifier: String
        /// The tags for the access log subscription.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateAccessLogSubscriptionRequest.idempotencyToken(), destinationArn: String, resourceIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.destinationArn = destinationArn
            self.resourceIdentifier = resourceIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, min: 20)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case destinationArn = "destinationArn"
            case resourceIdentifier = "resourceIdentifier"
            case tags = "tags"
        }
    }

    public struct CreateAccessLogSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the log destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The Amazon Resource Name (ARN) of the service network or service.
        public let resourceArn: String
        /// The ID of the service network or service.
        public let resourceId: String

        public init(arn: String, destinationArn: String, id: String, resourceArn: String, resourceId: String) {
            self.arn = arn
            self.destinationArn = destinationArn
            self.id = id
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinationArn = "destinationArn"
            case id = "id"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct CreateListenerRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The action for the default rule. Each listener has a default rule. Each rule consists of a priority, one or more actions, and one or more conditions. The default rule is the rule that's used if no other rules match. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
        public let defaultAction: RuleAction
        /// The name of the listener. A listener name must be unique within a service. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The listener port. You can specify a value from 1 to 65535. For HTTP, the default is 80. For HTTPS, the default is 443.
        public let port: Int?
        /// The listener protocol HTTP or HTTPS.
        public let `protocol`: ListenerProtocol
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String
        /// The tags for the listener.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateListenerRequest.idempotencyToken(), defaultAction: RuleAction, name: String, port: Int? = nil, protocol: ListenerProtocol, serviceIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.defaultAction = defaultAction
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceIdentifier = serviceIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.defaultAction, forKey: .defaultAction)
            try container.encode(self.name, forKey: .name)
            try container.encodeIfPresent(self.port, forKey: .port)
            try container.encode(self.`protocol`, forKey: .`protocol`)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.defaultAction.validate(name: "\(name).defaultAction")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!listener-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case defaultAction = "defaultAction"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case tags = "tags"
        }
    }

    public struct CreateListenerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The action for the default rule.
        public let defaultAction: RuleAction?
        /// The ID of the listener.
        public let id: String?
        /// The name of the listener.
        public let name: String?
        /// The port number of the listener.
        public let port: Int?
        /// The protocol of the listener.
        public let `protocol`: ListenerProtocol?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?

        public init(arn: String? = nil, defaultAction: RuleAction? = nil, id: String? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil, serviceArn: String? = nil, serviceId: String? = nil) {
            self.arn = arn
            self.defaultAction = defaultAction
            self.id = id
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArn = serviceArn
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case defaultAction = "defaultAction"
            case id = "id"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
        }
    }

    public struct CreateRuleRequest: AWSEncodableShape {
        /// The action for the default rule.
        public let action: RuleAction
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The rule match.
        public let match: RuleMatch
        /// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
        public let priority: Int
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String
        /// The tags for the rule.
        public let tags: [String: String]?

        public init(action: RuleAction, clientToken: String? = CreateRuleRequest.idempotencyToken(), listenerIdentifier: String, match: RuleMatch, name: String, priority: Int, serviceIdentifier: String, tags: [String: String]? = nil) {
            self.action = action
            self.clientToken = clientToken
            self.listenerIdentifier = listenerIdentifier
            self.match = match
            self.name = name
            self.priority = priority
            self.serviceIdentifier = serviceIdentifier
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            try container.encode(self.match, forKey: .match)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.priority, forKey: .priority)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.action.validate(name: "\(name).action")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.match.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!rule-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case clientToken = "clientToken"
            case match = "match"
            case name = "name"
            case priority = "priority"
            case tags = "tags"
        }
    }

    public struct CreateRuleResponse: AWSDecodableShape {
        /// The rule action. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the rule.
        public let arn: String?
        /// The ID of the rule.
        public let id: String?
        /// The rule match. The RuleMatch must be an HttpMatch. This means that the rule should be an exact match on HTTP constraints which are made up of the HTTP method, path, and header.
        public let match: RuleMatch?
        /// The name of the rule.
        public let name: String?
        /// The priority assigned to the rule. The lower the priority number the higher the priority.
        public let priority: Int?

        public init(action: RuleAction? = nil, arn: String? = nil, id: String? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.id = id
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case id = "id"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct CreateServiceNetworkRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The name of the service network. The name must be unique to the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The tags for the service network.
        public let tags: [String: String]?

        public init(authType: AuthType? = nil, clientToken: String? = CreateServiceNetworkRequest.idempotencyToken(), name: String, tags: [String: String]? = nil) {
            self.authType = authType
            self.clientToken = clientToken
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case clientToken = "clientToken"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateServiceNetworkResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The ID of the service network.
        public let id: String?
        /// The name of the service network.
        public let name: String?

        public init(arn: String? = nil, authType: AuthType? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.authType = authType
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case id = "id"
            case name = "name"
        }
    }

    public struct CreateServiceNetworkServiceAssociationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN if the resources specified in the operation are in different accounts.
        public let serviceNetworkIdentifier: String
        /// The tags for the association.
        public let tags: [String: String]?

        public init(clientToken: String? = CreateServiceNetworkServiceAssociationRequest.idempotencyToken(), serviceIdentifier: String, serviceNetworkIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.serviceIdentifier = serviceIdentifier
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case serviceIdentifier = "serviceIdentifier"
            case serviceNetworkIdentifier = "serviceNetworkIdentifier"
            case tags = "tags"
        }
    }

    public struct CreateServiceNetworkServiceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The account that created the association.
        public let createdBy: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The ID of the association.
        public let id: String?
        /// The operation's status.
        public let status: ServiceNetworkServiceAssociationStatus?

        public init(arn: String? = nil, createdBy: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case status = "status"
        }
    }

    public struct CreateServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The IDs of the security groups. Security groups aren't added by default. You can add a security group to apply network level controls to control which resources in a VPC are allowed to access the service network and its services. For more information, see Control traffic to resources using security groups in the Amazon VPC User Guide.
        public let securityGroupIds: [String]?
        /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN when the resources specified in the operation are in different accounts.
        public let serviceNetworkIdentifier: String
        /// The tags for the association.
        public let tags: [String: String]?
        /// The ID of the VPC.
        public let vpcIdentifier: String

        public init(clientToken: String? = CreateServiceNetworkVpcAssociationRequest.idempotencyToken(), securityGroupIds: [String]? = nil, serviceNetworkIdentifier: String, tags: [String: String]? = nil, vpcIdentifier: String) {
            self.clientToken = clientToken
            self.securityGroupIds = securityGroupIds
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
            self.tags = tags
            self.vpcIdentifier = vpcIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.securityGroupIds?.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 5)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-(([0-9a-z]{8})|([0-9a-z]{17}))$")
            }
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case securityGroupIds = "securityGroupIds"
            case serviceNetworkIdentifier = "serviceNetworkIdentifier"
            case tags = "tags"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct CreateServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The account that created the association.
        public let createdBy: String?
        /// The ID of the association.
        public let id: String?
        /// The IDs of the security groups.
        public let securityGroupIds: [String]?
        /// The operation's status.
        public let status: ServiceNetworkVpcAssociationStatus?

        public init(arn: String? = nil, createdBy: String? = nil, id: String? = nil, securityGroupIds: [String]? = nil, status: ServiceNetworkVpcAssociationStatus? = nil) {
            self.arn = arn
            self.createdBy = createdBy
            self.id = id
            self.securityGroupIds = securityGroupIds
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case id = "id"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
        }
    }

    public struct CreateServiceRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The name of the service. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The tags for the service.
        public let tags: [String: String]?

        public init(authType: AuthType? = nil, certificateArn: String? = nil, clientToken: String? = CreateServiceRequest.idempotencyToken(), customDomainName: String? = nil, name: String, tags: [String: String]? = nil) {
            self.authType = authType
            self.certificateArn = certificateArn
            self.clientToken = clientToken
            self.customDomainName = customDomainName
            self.name = name
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, max: 2048)
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "^(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:certificate/[0-9a-z-]+)?$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, max: 255)
            try self.validate(self.customDomainName, name: "customDomainName", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, max: 40)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!svc-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case certificateArn = "certificateArn"
            case clientToken = "clientToken"
            case customDomainName = "customDomainName"
            case name = "name"
            case tags = "tags"
        }
    }

    public struct CreateServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The public DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The ID of the service.
        public let id: String?
        /// The name of the service.
        public let name: String?
        /// The status. If the status is CREATE_FAILED, you will have to delete and recreate the service.
        public let status: ServiceStatus?

        public init(arn: String? = nil, authType: AuthType? = nil, certificateArn: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.authType = authType
            self.certificateArn = certificateArn
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case certificateArn = "certificateArn"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct CreateTargetGroupRequest: AWSEncodableShape {
        /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
        public let clientToken: String?
        /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
        public let config: TargetGroupConfig?
        /// The name of the target group. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a  hyphen as the first or last character, or immediately after another hyphen.
        public let name: String
        /// The tags for the target group.
        public let tags: [String: String]?
        /// The type of target group.
        public let type: TargetGroupType

        public init(clientToken: String? = CreateTargetGroupRequest.idempotencyToken(), config: TargetGroupConfig? = nil, name: String, tags: [String: String]? = nil, type: TargetGroupType) {
            self.clientToken = clientToken
            self.config = config
            self.name = name
            self.tags = tags
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 64)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "[!-~]+")
            try self.config?.validate(name: "\(name).config")
            try self.validate(self.name, name: "name", parent: name, max: 128)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^(?!tg-)(?![-])(?!.*[-]$)(?!.*[-]{2})[a-z0-9-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case config = "config"
            case name = "name"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
        public let config: TargetGroupConfig?
        /// The ID of the target group.
        public let id: String?
        /// The name of the target group.
        public let name: String?
        /// The operation's status. You can retry the operation if the status is CREATE_FAILED. However, if you retry it while the status is CREATE_IN_PROGRESS, there is no change in the status.
        public let status: TargetGroupStatus?
        /// The type of target group.
        public let type: TargetGroupType?

        public init(arn: String? = nil, config: TargetGroupConfig? = nil, id: String? = nil, name: String? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil) {
            self.arn = arn
            self.config = config
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case config = "config"
            case id = "id"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct DeleteAccessLogSubscriptionRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the access log subscription.
        public let accessLogSubscriptionIdentifier: String

        public init(accessLogSubscriptionIdentifier: String) {
            self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessLogSubscriptionIdentifier, key: "accessLogSubscriptionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, max: 2048)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, min: 17)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, pattern: "^((als-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:accesslogsubscription/als-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessLogSubscriptionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAuthPolicyRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the resource.
        public let resourceIdentifier: String

        public init(resourceIdentifier: String) {
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAuthPolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteListenerRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(listenerIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteListenerResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteResourcePolicyRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRuleRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public let ruleIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(listenerIdentifier: String, ruleIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.ruleIdentifier = ruleIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.ruleIdentifier, key: "ruleIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRuleResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServiceNetworkRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) or ID of the service network.
        public let serviceNetworkIdentifier: String

        public init(serviceNetworkIdentifier: String) {
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceNetworkResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteServiceNetworkServiceAssociationRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the association.
        public let serviceNetworkServiceAssociationIdentifier: String

        public init(serviceNetworkServiceAssociationIdentifier: String) {
            self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkServiceAssociationIdentifier, key: "serviceNetworkServiceAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, pattern: "^((snsa-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkserviceassociation/snsa-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceNetworkServiceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The ID of the association.
        public let id: String?
        /// The operation's status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
        public let status: ServiceNetworkServiceAssociationStatus?

        public init(arn: String? = nil, id: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeleteServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the association.
        public let serviceNetworkVpcAssociationIdentifier: String

        public init(serviceNetworkVpcAssociationIdentifier: String) {
            self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkVpcAssociationIdentifier, key: "serviceNetworkVpcAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, pattern: "^((snva-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkvpcassociation/snva-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The ID of the association.
        public let id: String?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
        public let status: ServiceNetworkVpcAssociationStatus?

        public init(arn: String? = nil, id: String? = nil, status: ServiceNetworkVpcAssociationStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeleteServiceRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(serviceIdentifier: String) {
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The ID of the service.
        public let id: String?
        /// The name of the service.
        public let name: String?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
        public let status: ServiceStatus?

        public init(arn: String? = nil, id: String? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.id = id
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case name = "name"
            case status = "status"
        }
    }

    public struct DeleteTargetGroupRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        public let targetGroupIdentifier: String

        public init(targetGroupIdentifier: String) {
            self.targetGroupIdentifier = targetGroupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The ID of the target group.
        public let id: String?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
        public let status: TargetGroupStatus?

        public init(arn: String? = nil, id: String? = nil, status: TargetGroupStatus? = nil) {
            self.arn = arn
            self.id = id
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case id = "id"
            case status = "status"
        }
    }

    public struct DeregisterTargetsRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        public let targetGroupIdentifier: String
        /// The targets to deregister.
        public let targets: [Target]

        public init(targetGroupIdentifier: String, targets: [Target]) {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.targets = targets
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
            try container.encode(self.targets, forKey: .targets)
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.targets.forEach {
                try $0.validate(name: "\(name).targets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct DeregisterTargetsResponse: AWSDecodableShape {
        /// The targets that were successfully deregistered.
        public let successful: [Target]?
        /// The targets that the operation couldn't deregister.
        public let unsuccessful: [TargetFailure]?

        public init(successful: [Target]? = nil, unsuccessful: [TargetFailure]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        private enum CodingKeys: String, CodingKey {
            case successful = "successful"
            case unsuccessful = "unsuccessful"
        }
    }

    public struct DnsEntry: AWSDecodableShape {
        /// The domain name of the service.
        public let domainName: String?
        /// The ID of the hosted zone.
        public let hostedZoneId: String?

        public init(domainName: String? = nil, hostedZoneId: String? = nil) {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }

        private enum CodingKeys: String, CodingKey {
            case domainName = "domainName"
            case hostedZoneId = "hostedZoneId"
        }
    }

    public struct FixedResponseAction: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP response code.
        public let statusCode: Int

        public init(statusCode: Int) {
            self.statusCode = statusCode
        }

        public func validate(name: String) throws {
            try self.validate(self.statusCode, name: "statusCode", parent: name, max: 599)
            try self.validate(self.statusCode, name: "statusCode", parent: name, min: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode = "statusCode"
        }
    }

    public struct ForwardAction: AWSEncodableShape & AWSDecodableShape {
        /// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic. The default value is 1. This means that if only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
        public let targetGroups: [WeightedTargetGroup]

        public init(targetGroups: [WeightedTargetGroup]) {
            self.targetGroups = targetGroups
        }

        public func validate(name: String) throws {
            try self.targetGroups.forEach {
                try $0.validate(name: "\(name).targetGroups[]")
            }
            try self.validate(self.targetGroups, name: "targetGroups", parent: name, max: 2)
            try self.validate(self.targetGroups, name: "targetGroups", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case targetGroups = "targetGroups"
        }
    }

    public struct GetAccessLogSubscriptionRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the access log subscription.
        public let accessLogSubscriptionIdentifier: String

        public init(accessLogSubscriptionIdentifier: String) {
            self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessLogSubscriptionIdentifier, key: "accessLogSubscriptionIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, max: 2048)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, min: 17)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, pattern: "^((als-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:accesslogsubscription/als-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessLogSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let arn: String
        /// The date and time that the access log subscription was created, specified in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var createdAt: Date
        /// The Amazon Resource Name (ARN) of the access log destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
        @CustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date
        /// The Amazon Resource Name (ARN) of the service network or service.
        public let resourceArn: String
        /// The ID of the service network or service.
        public let resourceId: String

        public init(arn: String, createdAt: Date, destinationArn: String, id: String, lastUpdatedAt: Date, resourceArn: String, resourceId: String) {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case destinationArn = "destinationArn"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct GetAuthPolicyRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the service network or service.
        public let resourceIdentifier: String

        public init(resourceIdentifier: String) {
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAuthPolicyResponse: AWSDecodableShape {
        /// The date and time that the auth policy was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The date and time that the auth policy was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The auth policy.
        public let policy: String?
        /// The state of the auth policy. The auth policy is only active when the auth type is set to Amazon Web Services_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the auth type is NONE, then any auth policy you provide will remain inactive. For more information, see Create a service network in the Amazon VPC Lattice User Guide.
        public let state: AuthPolicyState?

        public init(createdAt: Date? = nil, lastUpdatedAt: Date? = nil, policy: String? = nil, state: AuthPolicyState? = nil) {
            self.createdAt = createdAt
            self.lastUpdatedAt = lastUpdatedAt
            self.policy = policy
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case lastUpdatedAt = "lastUpdatedAt"
            case policy = "policy"
            case state = "state"
        }
    }

    public struct GetListenerRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(listenerIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetListenerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The date and time that the listener was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The actions for the default listener rule.
        public let defaultAction: RuleAction?
        /// The ID of the listener.
        public let id: String?
        /// The date and time that the listener was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the listener.
        public let name: String?
        /// The listener port.
        public let port: Int?
        /// The listener protocol.
        public let `protocol`: ListenerProtocol?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?

        public init(arn: String? = nil, createdAt: Date? = nil, defaultAction: RuleAction? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil, serviceArn: String? = nil, serviceId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultAction = defaultAction
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArn = serviceArn
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case defaultAction = "defaultAction"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
        }
    }

    public struct GetResourcePolicyRequest: AWSEncodableShape {
        /// An IAM policy.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetResourcePolicyResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network or service.
        public let policy: String?

        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct GetRuleRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the listener rule.
        public let ruleIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(listenerIdentifier: String, ruleIdentifier: String, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.ruleIdentifier = ruleIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.ruleIdentifier, key: "ruleIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRuleResponse: AWSDecodableShape {
        /// The action for the default rule.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The date and time that the listener rule was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the listener.
        public let id: String?
        /// Indicates whether this is the default rule.
        public let isDefault: Bool?
        /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The rule match.
        public let match: RuleMatch?
        /// The name of the listener.
        public let name: String?
        /// The priority level for the specified rule.
        public let priority: Int?

        public init(action: RuleAction? = nil, arn: String? = nil, createdAt: Date? = nil, id: String? = nil, isDefault: Bool? = nil, lastUpdatedAt: Date? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case isDefault = "isDefault"
            case lastUpdatedAt = "lastUpdatedAt"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct GetServiceNetworkRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkIdentifier: String

        public init(serviceNetworkIdentifier: String) {
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceNetworkResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The date and time that the service network was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the service network.
        public let id: String?
        /// The date and time of the last update, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service network.
        public let name: String?
        /// The number of services associated with the service network.
        public let numberOfAssociatedServices: Int64?
        /// The number of VPCs associated with the service network.
        public let numberOfAssociatedVPCs: Int64?

        public init(arn: String? = nil, authType: AuthType? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, numberOfAssociatedServices: Int64? = nil, numberOfAssociatedVPCs: Int64? = nil) {
            self.arn = arn
            self.authType = authType
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case numberOfAssociatedServices = "numberOfAssociatedServices"
            case numberOfAssociatedVPCs = "numberOfAssociatedVPCs"
        }
    }

    public struct GetServiceNetworkServiceAssociationRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the association.
        public let serviceNetworkServiceAssociationIdentifier: String

        public init(serviceNetworkServiceAssociationIdentifier: String) {
            self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkServiceAssociationIdentifier, key: "serviceNetworkServiceAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkServiceAssociationIdentifier, name: "serviceNetworkServiceAssociationIdentifier", parent: name, pattern: "^((snsa-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkserviceassociation/snsa-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceNetworkServiceAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the service network and service association.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?
        /// The name of the service.
        public let serviceName: String?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status of the association.
        public let status: ServiceNetworkServiceAssociationStatus?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, serviceArn: String? = nil, serviceId: String? = nil, serviceName: String? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
            case serviceName = "serviceName"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
        }
    }

    public struct GetServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the association.
        public let serviceNetworkVpcAssociationIdentifier: String

        public init(serviceNetworkVpcAssociationIdentifier: String) {
            self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceNetworkVpcAssociationIdentifier, key: "serviceNetworkVpcAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, pattern: "^((snva-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkvpcassociation/snva-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the specified association between the service network and the VPC.
        public let id: String?
        /// The date and time that the association was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The IDs of the security groups.
        public let securityGroupIds: [String]?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status of the association.
        public let status: ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, securityGroupIds: [String]? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkVpcAssociationStatus? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.securityGroupIds = securityGroupIds
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case securityGroupIds = "securityGroupIds"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
            case vpcId = "vpcId"
        }
    }

    public struct GetServiceRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(serviceIdentifier: String) {
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The date and time that the service was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The DNS name of the service.
        public let dnsEntry: DnsEntry?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the service.
        public let id: String?
        /// The date and time that the service was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service.
        public let name: String?
        /// The status of the service.
        public let status: ServiceStatus?

        public init(arn: String? = nil, authType: AuthType? = nil, certificateArn: String? = nil, createdAt: Date? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.authType = authType
            self.certificateArn = certificateArn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case certificateArn = "certificateArn"
            case createdAt = "createdAt"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct GetTargetGroupRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        public let targetGroupIdentifier: String

        public init(targetGroupIdentifier: String) {
            self.targetGroupIdentifier = targetGroupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The target group configuration.
        public let config: TargetGroupConfig?
        /// The date and time that the target group was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the target group.
        public let id: String?
        /// The date and time that the target group was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the target group.
        public let name: String?
        /// The Amazon Resource Names (ARNs) of the service.
        public let serviceArns: [String]?
        /// The status.
        public let status: TargetGroupStatus?
        /// The target group type.
        public let type: TargetGroupType?

        public init(arn: String? = nil, config: TargetGroupConfig? = nil, createdAt: Date? = nil, failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, serviceArns: [String]? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil) {
            self.arn = arn
            self.config = config
            self.createdAt = createdAt
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case config = "config"
            case createdAt = "createdAt"
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case serviceArns = "serviceArns"
            case status = "status"
            case type = "type"
        }
    }

    public struct HeaderMatch: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public let caseSensitive: Bool?
        /// The header match type.
        public let match: HeaderMatchType
        /// The name of the header.
        public let name: String

        public init(caseSensitive: Bool? = nil, match: HeaderMatchType, name: String) {
            self.caseSensitive = caseSensitive
            self.match = match
            self.name = name
        }

        public func validate(name: String) throws {
            try self.match.validate(name: "\(name).match")
            try self.validate(self.name, name: "name", parent: name, max: 100)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case caseSensitive = "caseSensitive"
            case match = "match"
            case name = "name"
        }
    }

    public struct HealthCheckConfig: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether health checking is enabled.
        public let enabled: Bool?
        /// The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
        public let healthCheckIntervalSeconds: Int?
        /// The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
        public let healthCheckTimeoutSeconds: Int?
        /// The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
        public let healthyThresholdCount: Int?
        /// The codes to use when checking for a successful response from a target. These are called Success codes in the console.
        public let matcher: Matcher?
        /// The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is /. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        public let path: String?
        /// The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        public let port: Int?
        /// The protocol used when performing health checks on targets. The possible protocols are HTTP and HTTPS. The default is HTTP.
        public let `protocol`: TargetGroupProtocol?
        /// The protocol version used when performing health checks on targets. The possible protocol versions are HTTP1 and HTTP2.
        public let protocolVersion: HealthCheckProtocolVersion?
        /// The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
        public let unhealthyThresholdCount: Int?

        public init(enabled: Bool? = nil, healthCheckIntervalSeconds: Int? = nil, healthCheckTimeoutSeconds: Int? = nil, healthyThresholdCount: Int? = nil, matcher: Matcher? = nil, path: String? = nil, port: Int? = nil, protocol: TargetGroupProtocol? = nil, protocolVersion: HealthCheckProtocolVersion? = nil, unhealthyThresholdCount: Int? = nil) {
            self.enabled = enabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.matcher = matcher
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.unhealthyThresholdCount = unhealthyThresholdCount
        }

        public func validate(name: String) throws {
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, max: 300)
            try self.validate(self.healthCheckIntervalSeconds, name: "healthCheckIntervalSeconds", parent: name, min: 0)
            try self.validate(self.healthCheckTimeoutSeconds, name: "healthCheckTimeoutSeconds", parent: name, max: 120)
            try self.validate(self.healthCheckTimeoutSeconds, name: "healthCheckTimeoutSeconds", parent: name, min: 0)
            try self.validate(self.healthyThresholdCount, name: "healthyThresholdCount", parent: name, max: 10)
            try self.validate(self.healthyThresholdCount, name: "healthyThresholdCount", parent: name, min: 0)
            try self.matcher?.validate(name: "\(name).matcher")
            try self.validate(self.path, name: "path", parent: name, max: 2048)
            try self.validate(self.path, name: "path", parent: name, pattern: "(^/[a-zA-Z0-9@:%_+.~#?&/=-]*$|(^$))")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 0)
            try self.validate(self.unhealthyThresholdCount, name: "unhealthyThresholdCount", parent: name, max: 10)
            try self.validate(self.unhealthyThresholdCount, name: "unhealthyThresholdCount", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case enabled = "enabled"
            case healthCheckIntervalSeconds = "healthCheckIntervalSeconds"
            case healthCheckTimeoutSeconds = "healthCheckTimeoutSeconds"
            case healthyThresholdCount = "healthyThresholdCount"
            case matcher = "matcher"
            case path = "path"
            case port = "port"
            case `protocol` = "protocol"
            case protocolVersion = "protocolVersion"
            case unhealthyThresholdCount = "unhealthyThresholdCount"
        }
    }

    public struct HttpMatch: AWSEncodableShape & AWSDecodableShape {
        /// The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        public let headerMatches: [HeaderMatch]?
        /// The HTTP method type.
        public let method: String?
        /// The path match.
        public let pathMatch: PathMatch?

        public init(headerMatches: [HeaderMatch]? = nil, method: String? = nil, pathMatch: PathMatch? = nil) {
            self.headerMatches = headerMatches
            self.method = method
            self.pathMatch = pathMatch
        }

        public func validate(name: String) throws {
            try self.headerMatches?.forEach {
                try $0.validate(name: "\(name).headerMatches[]")
            }
            try self.validate(self.headerMatches, name: "headerMatches", parent: name, max: 5)
            try self.validate(self.headerMatches, name: "headerMatches", parent: name, min: 1)
            try self.validate(self.method, name: "method", parent: name, max: 16)
            try self.pathMatch?.validate(name: "\(name).pathMatch")
        }

        private enum CodingKeys: String, CodingKey {
            case headerMatches = "headerMatches"
            case method = "method"
            case pathMatch = "pathMatch"
        }
    }

    public struct ListAccessLogSubscriptionsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or Amazon Resource Name (ARN) of the service network or service.
        public let resourceIdentifier: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, resourceIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessLogSubscriptionsResponse: AWSDecodableShape {
        /// The access log subscriptions.
        public let items: [AccessLogSubscriptionSummary]
        /// A pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [AccessLogSubscriptionSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListListenersRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListListenersResponse: AWSDecodableShape {
        /// Information about the listeners.
        public let items: [ListenerSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [ListenerSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListRulesRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(listenerIdentifier: String, maxResults: Int? = nil, nextToken: String? = nil, serviceIdentifier: String) {
            self.listenerIdentifier = listenerIdentifier
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRulesResponse: AWSDecodableShape {
        /// Information about the rules.
        public let items: [RuleSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [RuleSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworkServiceAssociationsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String?
        /// The ID or Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkIdentifier: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceIdentifier: String? = nil, serviceNetworkIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceIdentifier = serviceIdentifier
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.serviceIdentifier, key: "serviceIdentifier")
            request.encodeQuery(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworkServiceAssociationsResponse: AWSDecodableShape {
        /// Information about the associations.
        public let items: [ServiceNetworkServiceAssociationSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [ServiceNetworkServiceAssociationSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworkVpcAssociationsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkIdentifier: String?
        /// The ID or Amazon Resource Name (ARN) of the VPC.
        public let vpcIdentifier: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, serviceNetworkIdentifier: String? = nil, vpcIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
            self.vpcIdentifier = vpcIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
            request.encodeQuery(self.vpcIdentifier, key: "vpcIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworkVpcAssociationsResponse: AWSDecodableShape {
        /// Information about the associations.
        public let items: [ServiceNetworkVpcAssociationSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [ServiceNetworkVpcAssociationSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServiceNetworksRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServiceNetworksResponse: AWSDecodableShape {
        /// Information about the service networks.
        public let items: [ServiceNetworkSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [ServiceNetworkSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListServicesRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListServicesResponse: AWSDecodableShape {
        /// The services.
        public let items: [ServiceSummary]?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [ServiceSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:vpc-lattice:([a-z0-9][-.a-z0-9]{0,62})?:\\d{12}?:[^/].{0,1023}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListTargetGroupsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The target group type.
        public let targetGroupType: TargetGroupType?
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let vpcIdentifier: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil, targetGroupType: TargetGroupType? = nil, vpcIdentifier: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetGroupType = targetGroupType
            self.vpcIdentifier = vpcIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.targetGroupType, key: "targetGroupType")
            request.encodeQuery(self.vpcIdentifier, key: "vpcIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTargetGroupsResponse: AWSDecodableShape {
        /// Information about the target groups.
        public let items: [TargetGroupSummary]?
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [TargetGroupSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListTargetsRequest: AWSEncodableShape {
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// A pagination token for the next page of results.
        public let nextToken: String?
        /// The ID or Amazon Resource Name (ARN) of the target group.
        public let targetGroupIdentifier: String
        /// The targets to list.
        public let targets: [Target]?

        public init(maxResults: Int? = nil, nextToken: String? = nil, targetGroupIdentifier: String, targets: [Target]? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.targetGroupIdentifier = targetGroupIdentifier
            self.targets = targets
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
            try container.encodeIfPresent(self.targets, forKey: .targets)
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 2048)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.targets?.forEach {
                try $0.validate(name: "\(name).targets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct ListTargetsResponse: AWSDecodableShape {
        /// Information about the targets.
        public let items: [TargetSummary]
        /// If there are additional results, a pagination token for the next page of results.
        public let nextToken: String?

        public init(items: [TargetSummary], nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListenerSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The date and time that the listener was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the listener.
        public let id: String?
        /// The date and time that the listener was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the listener.
        public let name: String?
        /// The listener port.
        public let port: Int?
        /// The listener protocol.
        public let `protocol`: ListenerProtocol?

        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
        }
    }

    public struct PathMatch: AWSEncodableShape & AWSDecodableShape {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public let caseSensitive: Bool?
        /// The type of path match.
        public let match: PathMatchType

        public init(caseSensitive: Bool? = nil, match: PathMatchType) {
            self.caseSensitive = caseSensitive
            self.match = match
        }

        public func validate(name: String) throws {
            try self.match.validate(name: "\(name).match")
        }

        private enum CodingKeys: String, CodingKey {
            case caseSensitive = "caseSensitive"
            case match = "match"
        }
    }

    public struct PutAuthPolicyRequest: AWSEncodableShape {
        /// The auth policy.
        public let policy: String
        /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
        public let resourceIdentifier: String

        public init(policy: String, resourceIdentifier: String) {
            self.policy = policy
            self.resourceIdentifier = resourceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policy, forKey: .policy)
            request.encodePath(self.resourceIdentifier, key: "resourceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 10000)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, max: 200)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, min: 17)
            try self.validate(self.resourceIdentifier, name: "resourceIdentifier", parent: name, pattern: "^((((sn)|(svc))-[0-9a-z]{17})|(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct PutAuthPolicyResponse: AWSDecodableShape {
        /// The auth policy.
        public let policy: String?
        /// The state of the auth policy. The auth policy is only active when the auth type is set to Amazon Web Services_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the Auth type is NONE, then, any auth policy you provide will remain inactive. For more information, see Create a service network in the Amazon VPC Lattice User Guide.
        public let state: AuthPolicyState?

        public init(policy: String? = nil, state: AuthPolicyState? = nil) {
            self.policy = policy
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
            case state = "state"
        }
    }

    public struct PutResourcePolicyRequest: AWSEncodableShape {
        /// An IAM policy.
        public let policy: String
        /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
        public let resourceArn: String

        public init(policy: String, resourceArn: String) {
            self.policy = policy
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.policy, forKey: .policy)
            request.encodePath(self.resourceArn, key: "resourceArn")
        }

        public func validate(name: String) throws {
            try self.validate(self.policy, name: "policy", parent: name, max: 10000)
            try self.validate(self.policy, name: "policy", parent: name, min: 1)
            try self.validate(self.policy, name: "policy", parent: name, pattern: "^.*\\S.*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 200)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:((servicenetwork/sn)|(service/svc))-[0-9a-z]{17}$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct PutResourcePolicyResponse: AWSDecodableShape {
        public init() {}
    }

    public struct RegisterTargetsRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        public let targetGroupIdentifier: String
        /// The targets.
        public let targets: [Target]

        public init(targetGroupIdentifier: String, targets: [Target]) {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.targets = targets
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
            try container.encode(self.targets, forKey: .targets)
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.targets.forEach {
                try $0.validate(name: "\(name).targets[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case targets = "targets"
        }
    }

    public struct RegisterTargetsResponse: AWSDecodableShape {
        /// The targets that were successfully registered.
        public let successful: [Target]?
        /// The targets that were not registered.
        public let unsuccessful: [TargetFailure]?

        public init(successful: [Target]? = nil, unsuccessful: [TargetFailure]? = nil) {
            self.successful = successful
            self.unsuccessful = unsuccessful
        }

        private enum CodingKeys: String, CodingKey {
            case successful = "successful"
            case unsuccessful = "unsuccessful"
        }
    }

    public struct RuleSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the rule.
        public let arn: String?
        /// The date and time that the listener rule was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the rule.
        public let id: String?
        /// Indicates whether this is the default rule. Listener rules are created when you create a listener. Each listener has a default rule for checking connection requests.
        public let isDefault: Bool?
        /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the rule.
        public let name: String?
        ///  The priority of the rule.
        public let priority: Int?

        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, isDefault: Bool? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, priority: Int? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case isDefault = "isDefault"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct RuleUpdate: AWSEncodableShape {
        /// The rule action.
        public let action: RuleAction?
        /// The rule match.
        public let match: RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public let priority: Int?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public let ruleIdentifier: String

        public init(action: RuleAction? = nil, match: RuleMatch? = nil, priority: Int? = nil, ruleIdentifier: String) {
            self.action = action
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case priority = "priority"
            case ruleIdentifier = "ruleIdentifier"
        }
    }

    public struct RuleUpdateFailure: AWSDecodableShape {
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public let ruleIdentifier: String?

        public init(failureCode: String? = nil, failureMessage: String? = nil, ruleIdentifier: String? = nil) {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.ruleIdentifier = ruleIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case ruleIdentifier = "ruleIdentifier"
        }
    }

    public struct RuleUpdateSuccess: AWSDecodableShape {
        /// The action for the default rule.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The ID of the listener.
        public let id: String?
        /// Indicates whether this is the default rule.
        public let isDefault: Bool?
        /// The rule match.
        public let match: RuleMatch?
        /// The name of the listener.
        public let name: String?
        /// The rule priority.
        public let priority: Int?

        public init(action: RuleAction? = nil, arn: String? = nil, id: String? = nil, isDefault: Bool? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case id = "id"
            case isDefault = "isDefault"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct ServiceNetworkServiceAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        ///  The custom domain name of the service.
        public let customDomainName: String?
        /// DNS information about the service.
        public let dnsEntry: DnsEntry?
        /// The ID of the association.
        public let id: String?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?
        /// The name of the service.
        public let serviceName: String?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status. If the deletion fails, try to delete again.
        public let status: ServiceNetworkServiceAssociationStatus?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, serviceArn: String? = nil, serviceId: String? = nil, serviceName: String? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkServiceAssociationStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
            case serviceName = "serviceName"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
        }
    }

    public struct ServiceNetworkSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The date and time that the service network was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the service network.
        public let id: String?
        /// The date and time that the service network was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service network.
        public let name: String?
        /// The number of services associated with the service network.
        public let numberOfAssociatedServices: Int64?
        /// The number of VPCs associated with the service network.
        public let numberOfAssociatedVPCs: Int64?

        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, numberOfAssociatedServices: Int64? = nil, numberOfAssociatedVPCs: Int64? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case numberOfAssociatedServices = "numberOfAssociatedServices"
            case numberOfAssociatedVPCs = "numberOfAssociatedVPCs"
        }
    }

    public struct ServiceNetworkVpcAssociationSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The account that created the association.
        public let createdBy: String?
        /// The ID of the association.
        public let id: String?
        /// The date and time that the association was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkArn: String?
        /// The ID of the service network.
        public let serviceNetworkId: String?
        /// The name of the service network.
        public let serviceNetworkName: String?
        /// The status.
        public let status: ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public let vpcId: String?

        public init(arn: String? = nil, createdAt: Date? = nil, createdBy: String? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, serviceNetworkArn: String? = nil, serviceNetworkId: String? = nil, serviceNetworkName: String? = nil, status: ServiceNetworkVpcAssociationStatus? = nil, vpcId: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case createdBy = "createdBy"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case serviceNetworkArn = "serviceNetworkArn"
            case serviceNetworkId = "serviceNetworkId"
            case serviceNetworkName = "serviceNetworkName"
            case status = "status"
            case vpcId = "vpcId"
        }
    }

    public struct ServiceSummary: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The date and time that the service was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        ///  The custom domain name of the service.
        public let customDomainName: String?
        /// DNS information about the service.
        public let dnsEntry: DnsEntry?
        /// The ID of the service.
        public let id: String?
        /// The date and time that the service was last updated. The format is ISO-8601.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the service.
        public let name: String?
        /// The status.
        public let status: ServiceStatus?

        public init(arn: String? = nil, createdAt: Date? = nil, customDomainName: String? = nil, dnsEntry: DnsEntry? = nil, id: String? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, status: ServiceStatus? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case customDomainName = "customDomainName"
            case dnsEntry = "dnsEntry"
            case id = "id"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case status = "status"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tags for the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:vpc-lattice:([a-z0-9][-.a-z0-9]{0,62})?:\\d{12}?:[^/].{0,1023}$")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Target: AWSEncodableShape & AWSDecodableShape {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public let id: String
        /// The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
        public let port: Int?

        public init(id: String, port: Int? = nil) {
            self.id = id
            self.port = port
        }

        public func validate(name: String) throws {
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case port = "port"
        }
    }

    public struct TargetFailure: AWSDecodableShape {
        /// The failure code.
        public let failureCode: String?
        /// The failure message.
        public let failureMessage: String?
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public let id: String?
        /// The port on which the target is listening. This parameter doesn't apply if the target is a Lambda function.
        public let port: Int?

        public init(failureCode: String? = nil, failureMessage: String? = nil, id: String? = nil, port: Int? = nil) {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.port = port
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "failureCode"
            case failureMessage = "failureMessage"
            case id = "id"
            case port = "port"
        }
    }

    public struct TargetGroupConfig: AWSEncodableShape & AWSDecodableShape {
        /// The health check configuration.
        public let healthCheck: HealthCheckConfig?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public let ipAddressType: IpAddressType?
        /// Lambda event structure version
        public let lambdaEventStructureVersion: LambdaEventStructureVersion?
        /// The port on which the targets are listening. For HTTP, the default is 80. For HTTPS, the default is 443
        public let port: Int?
        /// The protocol to use for routing traffic to the targets. Default is the protocol of a target group.
        public let `protocol`: TargetGroupProtocol?
        /// The protocol version. Default value is HTTP1.
        public let protocolVersion: TargetGroupProtocolVersion?
        /// The ID of the VPC.
        public let vpcIdentifier: String?

        public init(healthCheck: HealthCheckConfig? = nil, ipAddressType: IpAddressType? = nil, lambdaEventStructureVersion: LambdaEventStructureVersion? = nil, port: Int? = nil, protocol: TargetGroupProtocol? = nil, protocolVersion: TargetGroupProtocolVersion? = nil, vpcIdentifier: String? = nil) {
            self.healthCheck = healthCheck
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.vpcIdentifier = vpcIdentifier
        }

        public func validate(name: String) throws {
            try self.healthCheck?.validate(name: "\(name).healthCheck")
            try self.validate(self.port, name: "port", parent: name, max: 65535)
            try self.validate(self.port, name: "port", parent: name, min: 1)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, max: 50)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, min: 5)
            try self.validate(self.vpcIdentifier, name: "vpcIdentifier", parent: name, pattern: "^vpc-(([0-9a-z]{8})|([0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
            case ipAddressType = "ipAddressType"
            case lambdaEventStructureVersion = "lambdaEventStructureVersion"
            case port = "port"
            case `protocol` = "protocol"
            case protocolVersion = "protocolVersion"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct TargetGroupSummary: AWSDecodableShape {
        /// The ARN (Amazon Resource Name) of the target group.
        public let arn: String?
        /// The date and time that the target group was created, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var createdAt: Date?
        /// The ID of the target group.
        public let id: String?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public let ipAddressType: IpAddressType?
        /// Lambda event structure version
        public let lambdaEventStructureVersion: LambdaEventStructureVersion?
        /// The date and time that the target group was last updated, specified in ISO-8601 format.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdatedAt: Date?
        /// The name of the target group.
        public let name: String?
        /// The port of the target group.
        public let port: Int?
        /// The protocol of the target group.
        public let `protocol`: TargetGroupProtocol?
        /// The list of Amazon Resource Names (ARNs) of the service.
        public let serviceArns: [String]?
        /// The status.
        public let status: TargetGroupStatus?
        /// The target group type.
        public let type: TargetGroupType?
        /// The ID of the VPC of the target group.
        public let vpcIdentifier: String?

        public init(arn: String? = nil, createdAt: Date? = nil, id: String? = nil, ipAddressType: IpAddressType? = nil, lambdaEventStructureVersion: LambdaEventStructureVersion? = nil, lastUpdatedAt: Date? = nil, name: String? = nil, port: Int? = nil, protocol: TargetGroupProtocol? = nil, serviceArns: [String]? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil, vpcIdentifier: String? = nil) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
            self.vpcIdentifier = vpcIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdAt = "createdAt"
            case id = "id"
            case ipAddressType = "ipAddressType"
            case lambdaEventStructureVersion = "lambdaEventStructureVersion"
            case lastUpdatedAt = "lastUpdatedAt"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArns = "serviceArns"
            case status = "status"
            case type = "type"
            case vpcIdentifier = "vpcIdentifier"
        }
    }

    public struct TargetSummary: AWSDecodableShape {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public let id: String?
        /// The port on which the target is listening.
        public let port: Int?
        /// The code for why the target status is what it is.
        public let reasonCode: String?
        /// The status of the target.    Draining: The target is being deregistered. No new connections will be sent to this target while current connections are being drained. Default draining time is 5 minutes.    Unavailable: Health checks are unavailable for the target group.    Healthy: The target is healthy.     Unhealthy: The target is unhealthy.    Initial: Initial health checks on the target are being performed.    Unused: Target group is not used in a service.
        public let status: TargetStatus?

        public init(id: String? = nil, port: Int? = nil, reasonCode: String? = nil, status: TargetStatus? = nil) {
            self.id = id
            self.port = port
            self.reasonCode = reasonCode
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case id = "id"
            case port = "port"
            case reasonCode = "reasonCode"
            case status = "status"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the resource.
        public let resourceArn: String
        /// The tag keys of the tags to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "resourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 1224)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9][-.a-z0-9]{0,62}:vpc-lattice:([a-z0-9][-.a-z0-9]{0,62})?:\\d{12}?:[^/].{0,1023}$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAccessLogSubscriptionRequest: AWSEncodableShape {
        /// The ID or Amazon Resource Name (ARN) of the access log subscription.
        public let accessLogSubscriptionIdentifier: String
        /// The Amazon Resource Name (ARN) of the access log destination.
        public let destinationArn: String

        public init(accessLogSubscriptionIdentifier: String, destinationArn: String) {
            self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
            self.destinationArn = destinationArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.accessLogSubscriptionIdentifier, key: "accessLogSubscriptionIdentifier")
            try container.encode(self.destinationArn, forKey: .destinationArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, max: 2048)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, min: 17)
            try self.validate(self.accessLogSubscriptionIdentifier, name: "accessLogSubscriptionIdentifier", parent: name, pattern: "^((als-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:accesslogsubscription/als-[0-9a-z]{17}))$")
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, max: 2048)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, min: 20)
            try self.validate(self.destinationArn, name: "destinationArn", parent: name, pattern: "^arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:([^/].*)?$")
        }

        private enum CodingKeys: String, CodingKey {
            case destinationArn = "destinationArn"
        }
    }

    public struct UpdateAccessLogSubscriptionResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let arn: String
        /// The Amazon Resource Name (ARN) of the access log destination.
        public let destinationArn: String
        /// The ID of the access log subscription.
        public let id: String
        /// The Amazon Resource Name (ARN) of the access log subscription.
        public let resourceArn: String
        /// The ID of the resource.
        public let resourceId: String

        public init(arn: String, destinationArn: String, id: String, resourceArn: String, resourceId: String) {
            self.arn = arn
            self.destinationArn = destinationArn
            self.id = id
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case destinationArn = "destinationArn"
            case id = "id"
            case resourceArn = "resourceArn"
            case resourceId = "resourceId"
        }
    }

    public struct UpdateListenerRequest: AWSEncodableShape {
        /// The action for the default rule.
        public let defaultAction: RuleAction
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(defaultAction: RuleAction, listenerIdentifier: String, serviceIdentifier: String) {
            self.defaultAction = defaultAction
            self.listenerIdentifier = listenerIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.defaultAction, forKey: .defaultAction)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.defaultAction.validate(name: "\(name).defaultAction")
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case defaultAction = "defaultAction"
        }
    }

    public struct UpdateListenerResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The action for the default rule.
        public let defaultAction: RuleAction?
        /// The ID of the listener.
        public let id: String?
        /// The name of the listener.
        public let name: String?
        /// The listener port.
        public let port: Int?
        /// The protocol of the listener.
        public let `protocol`: ListenerProtocol?
        /// The Amazon Resource Name (ARN) of the service.
        public let serviceArn: String?
        /// The ID of the service.
        public let serviceId: String?

        public init(arn: String? = nil, defaultAction: RuleAction? = nil, id: String? = nil, name: String? = nil, port: Int? = nil, protocol: ListenerProtocol? = nil, serviceArn: String? = nil, serviceId: String? = nil) {
            self.arn = arn
            self.defaultAction = defaultAction
            self.id = id
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArn = serviceArn
            self.serviceId = serviceId
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case defaultAction = "defaultAction"
            case id = "id"
            case name = "name"
            case port = "port"
            case `protocol` = "protocol"
            case serviceArn = "serviceArn"
            case serviceId = "serviceId"
        }
    }

    public struct UpdateRuleRequest: AWSEncodableShape {
        /// Information about the action for the specified listener rule.
        public let action: RuleAction?
        /// The ID or Amazon Resource Name (ARN) of the listener.
        public let listenerIdentifier: String
        /// The rule match.
        public let match: RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public let priority: Int?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public let ruleIdentifier: String
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(action: RuleAction? = nil, listenerIdentifier: String, match: RuleMatch? = nil, priority: Int? = nil, ruleIdentifier: String, serviceIdentifier: String) {
            self.action = action
            self.listenerIdentifier = listenerIdentifier
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.action, forKey: .action)
            request.encodePath(self.listenerIdentifier, key: "listenerIdentifier")
            try container.encodeIfPresent(self.match, forKey: .match)
            try container.encodeIfPresent(self.priority, forKey: .priority)
            request.encodePath(self.ruleIdentifier, key: "ruleIdentifier")
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, max: 2048)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, min: 20)
            try self.validate(self.listenerIdentifier, name: "listenerIdentifier", parent: name, pattern: "^((listener-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}$))$")
            try self.match?.validate(name: "\(name).match")
            try self.validate(self.priority, name: "priority", parent: name, max: 100)
            try self.validate(self.priority, name: "priority", parent: name, min: 1)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, max: 2048)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, min: 20)
            try self.validate(self.ruleIdentifier, name: "ruleIdentifier", parent: name, pattern: "^((rule-[0-9a-z]{17})|(^arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}/listener/listener-[0-9a-z]{17}/rule/rule-[0-9a-z]{17}$))$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case match = "match"
            case priority = "priority"
        }
    }

    public struct UpdateRuleResponse: AWSDecodableShape {
        /// Information about the action for the specified listener rule.
        public let action: RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public let arn: String?
        /// The ID of the listener.
        public let id: String?
        /// Indicates whether this is the default rule.
        public let isDefault: Bool?
        /// The rule match.
        public let match: RuleMatch?
        /// The name of the listener.
        public let name: String?
        /// The rule priority.
        public let priority: Int?

        public init(action: RuleAction? = nil, arn: String? = nil, id: String? = nil, isDefault: Bool? = nil, match: RuleMatch? = nil, name: String? = nil, priority: Int? = nil) {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case arn = "arn"
            case id = "id"
            case isDefault = "isDefault"
            case match = "match"
            case name = "name"
            case priority = "priority"
        }
    }

    public struct UpdateServiceNetworkRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType
        /// The ID or Amazon Resource Name (ARN) of the service network.
        public let serviceNetworkIdentifier: String

        public init(authType: AuthType, serviceNetworkIdentifier: String) {
            self.authType = authType
            self.serviceNetworkIdentifier = serviceNetworkIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.authType, forKey: .authType)
            request.encodePath(self.serviceNetworkIdentifier, key: "serviceNetworkIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, min: 3)
            try self.validate(self.serviceNetworkIdentifier, name: "serviceNetworkIdentifier", parent: name, pattern: "^((sn-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetwork/sn-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
        }
    }

    public struct UpdateServiceNetworkResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service network.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The ID of the service network.
        public let id: String?
        /// The name of the service network.
        public let name: String?

        public init(arn: String? = nil, authType: AuthType? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.authType = authType
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case id = "id"
            case name = "name"
        }
    }

    public struct UpdateServiceNetworkVpcAssociationRequest: AWSEncodableShape {
        /// The IDs of the security groups. Once you add a security group, it cannot be removed.
        public let securityGroupIds: [String]
        /// The ID or Amazon Resource Name (ARN) of the association.
        public let serviceNetworkVpcAssociationIdentifier: String

        public init(securityGroupIds: [String], serviceNetworkVpcAssociationIdentifier: String) {
            self.securityGroupIds = securityGroupIds
            self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.securityGroupIds, forKey: .securityGroupIds)
            request.encodePath(self.serviceNetworkVpcAssociationIdentifier, key: "serviceNetworkVpcAssociationIdentifier")
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 5)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^sg-(([0-9a-z]{8})|([0-9a-z]{17}))$")
            }
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, min: 17)
            try self.validate(self.serviceNetworkVpcAssociationIdentifier, name: "serviceNetworkVpcAssociationIdentifier", parent: name, pattern: "^((snva-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:servicenetworkvpcassociation/snva-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
        }
    }

    public struct UpdateServiceNetworkVpcAssociationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the association.
        public let arn: String?
        /// The account that created the association.
        public let createdBy: String?
        /// The ID of the association.
        public let id: String?
        /// The IDs of the security groups.
        public let securityGroupIds: [String]?
        /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
        public let status: ServiceNetworkVpcAssociationStatus?

        public init(arn: String? = nil, createdBy: String? = nil, id: String? = nil, securityGroupIds: [String]? = nil, status: ServiceNetworkVpcAssociationStatus? = nil) {
            self.arn = arn
            self.createdBy = createdBy
            self.id = id
            self.securityGroupIds = securityGroupIds
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case createdBy = "createdBy"
            case id = "id"
            case securityGroupIds = "securityGroupIds"
            case status = "status"
        }
    }

    public struct UpdateServiceRequest: AWSEncodableShape {
        /// The type of IAM policy.    NONE: The resource does not use an IAM policy. This is the default.    AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The ID or Amazon Resource Name (ARN) of the service.
        public let serviceIdentifier: String

        public init(authType: AuthType? = nil, certificateArn: String? = nil, serviceIdentifier: String) {
            self.authType = authType
            self.certificateArn = certificateArn
            self.serviceIdentifier = serviceIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.authType, forKey: .authType)
            try container.encodeIfPresent(self.certificateArn, forKey: .certificateArn)
            request.encodePath(self.serviceIdentifier, key: "serviceIdentifier")
        }

        public func validate(name: String) throws {
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, max: 2048)
            try self.validate(self.certificateArn, name: "certificateArn", parent: name, pattern: "^(arn(:[a-z0-9]+([.-][a-z0-9]+)*){2}(:([a-z0-9]+([.-][a-z0-9]+)*)?){2}:certificate/[0-9a-z-]+)?$")
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, max: 2048)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, min: 17)
            try self.validate(self.serviceIdentifier, name: "serviceIdentifier", parent: name, pattern: "^((svc-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:service/svc-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case authType = "authType"
            case certificateArn = "certificateArn"
        }
    }

    public struct UpdateServiceResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the service.
        public let arn: String?
        /// The type of IAM policy.
        public let authType: AuthType?
        /// The Amazon Resource Name (ARN) of the certificate.
        public let certificateArn: String?
        /// The custom domain name of the service.
        public let customDomainName: String?
        /// The ID of the service.
        public let id: String?
        /// The name of the service.
        public let name: String?

        public init(arn: String? = nil, authType: AuthType? = nil, certificateArn: String? = nil, customDomainName: String? = nil, id: String? = nil, name: String? = nil) {
            self.arn = arn
            self.authType = authType
            self.certificateArn = certificateArn
            self.customDomainName = customDomainName
            self.id = id
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case authType = "authType"
            case certificateArn = "certificateArn"
            case customDomainName = "customDomainName"
            case id = "id"
            case name = "name"
        }
    }

    public struct UpdateTargetGroupRequest: AWSEncodableShape {
        /// The health check configuration.
        public let healthCheck: HealthCheckConfig
        /// The ID or Amazon Resource Name (ARN) of the target group.
        public let targetGroupIdentifier: String

        public init(healthCheck: HealthCheckConfig, targetGroupIdentifier: String) {
            self.healthCheck = healthCheck
            self.targetGroupIdentifier = targetGroupIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.healthCheck, forKey: .healthCheck)
            request.encodePath(self.targetGroupIdentifier, key: "targetGroupIdentifier")
        }

        public func validate(name: String) throws {
            try self.healthCheck.validate(name: "\(name).healthCheck")
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
        }

        private enum CodingKeys: String, CodingKey {
            case healthCheck = "healthCheck"
        }
    }

    public struct UpdateTargetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the target group.
        public let arn: String?
        /// The target group configuration.
        public let config: TargetGroupConfig?
        /// The ID of the target group.
        public let id: String?
        /// The name of the target group.
        public let name: String?
        /// The status.
        public let status: TargetGroupStatus?
        /// The target group type.
        public let type: TargetGroupType?

        public init(arn: String? = nil, config: TargetGroupConfig? = nil, id: String? = nil, name: String? = nil, status: TargetGroupStatus? = nil, type: TargetGroupType? = nil) {
            self.arn = arn
            self.config = config
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case config = "config"
            case id = "id"
            case name = "name"
            case status = "status"
            case type = "type"
        }
    }

    public struct WeightedTargetGroup: AWSEncodableShape & AWSDecodableShape {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        public let targetGroupIdentifier: String
        /// Only required if you specify multiple target groups for a forward action. The "weight" determines how requests are distributed to the target group. For example, if you specify two target groups, each with a weight of 10, each target group receives half the requests. If you specify two target groups, one with a weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. If there's only one target group specified, then the default value is 100.
        public let weight: Int?

        public init(targetGroupIdentifier: String, weight: Int? = nil) {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.weight = weight
        }

        public func validate(name: String) throws {
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, max: 2048)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, min: 17)
            try self.validate(self.targetGroupIdentifier, name: "targetGroupIdentifier", parent: name, pattern: "^((tg-[0-9a-z]{17})|(arn:[a-z0-9\\-]+:vpc-lattice:[a-zA-Z0-9\\-]+:\\d{12}:targetgroup/tg-[0-9a-z]{17}))$")
            try self.validate(self.weight, name: "weight", parent: name, max: 999)
            try self.validate(self.weight, name: "weight", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case targetGroupIdentifier = "targetGroupIdentifier"
            case weight = "weight"
        }
    }

    public struct Matcher: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP code to use when checking for a successful response from a target.
        public let httpCode: String?

        public init(httpCode: String? = nil) {
            self.httpCode = httpCode
        }

        public func validate(name: String) throws {
            try self.validate(self.httpCode, name: "httpCode", parent: name, max: 2000)
            try self.validate(self.httpCode, name: "httpCode", parent: name, pattern: "(^[0-9-,]+$|(^$))")
        }

        private enum CodingKeys: String, CodingKey {
            case httpCode = "httpCode"
        }
    }

    public struct RuleMatch: AWSEncodableShape & AWSDecodableShape {
        /// The HTTP criteria that a rule must match.
        public let httpMatch: HttpMatch?

        public init(httpMatch: HttpMatch? = nil) {
            self.httpMatch = httpMatch
        }

        public func validate(name: String) throws {
            try self.httpMatch?.validate(name: "\(name).httpMatch")
        }

        private enum CodingKeys: String, CodingKey {
            case httpMatch = "httpMatch"
        }
    }
}

// MARK: - Errors

/// Error enum for VPCLattice
public struct VPCLatticeErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize VPCLattice
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// The user does not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request conflicts with the current state of the resource. Updating or deleting a resource can cause an inconsistent state.
    public static var conflictException: Self { .init(.conflictException) }
    /// An unexpected error occurred while processing the request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The request references a resource that does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would cause a service quota to be exceeded.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The limit on the number of requests per second was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input does not satisfy the constraints specified by an Amazon Web Services service.
    public static var validationException: Self { .init(.validationException) }
}

extension VPCLatticeErrorType: Equatable {
    public static func == (lhs: VPCLatticeErrorType, rhs: VPCLatticeErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension VPCLatticeErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
