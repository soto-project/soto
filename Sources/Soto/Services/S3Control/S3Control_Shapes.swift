//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension S3Control {
    // MARK: Enums

    public enum BucketCannedACL: String, CustomStringConvertible, Codable {
        case authenticatedRead = "authenticated-read"
        case `private`
        case publicRead = "public-read"
        case publicReadWrite = "public-read-write"
        public var description: String { return self.rawValue }
    }

    public struct BucketLocationConstraint: RawRepresentable, Equatable, Codable {
        public var rawValue: String

        public init(rawValue: String) {
            self.rawValue = rawValue
        }

        public static var apNortheast1: Self { .init(rawValue: "ap-northeast-1") }
        public static var apSouth1: Self { .init(rawValue: "ap-south-1") }
        public static var apSoutheast1: Self { .init(rawValue: "ap-southeast-1") }
        public static var apSoutheast2: Self { .init(rawValue: "ap-southeast-2") }
        public static var cnNorth1: Self { .init(rawValue: "cn-north-1") }
        public static var eu: Self { .init(rawValue: "EU") }
        public static var euCentral1: Self { .init(rawValue: "eu-central-1") }
        public static var euWest1: Self { .init(rawValue: "eu-west-1") }
        public static var saEast1: Self { .init(rawValue: "sa-east-1") }
        public static var usWest1: Self { .init(rawValue: "us-west-1") }
        public static var usWest2: Self { .init(rawValue: "us-west-2") }
    }

    public enum ExpirationStatus: String, CustomStringConvertible, Codable {
        case disabled = "Disabled"
        case enabled = "Enabled"
        public var description: String { return self.rawValue }
    }

    public enum Format: String, CustomStringConvertible, Codable {
        case csv = "CSV"
        case parquet = "Parquet"
        public var description: String { return self.rawValue }
    }

    public enum JobManifestFieldName: String, CustomStringConvertible, Codable {
        case bucket = "Bucket"
        case ignore = "Ignore"
        case key = "Key"
        case versionid = "VersionId"
        public var description: String { return self.rawValue }
    }

    public enum JobManifestFormat: String, CustomStringConvertible, Codable {
        case s3batchoperationsCsv20180820 = "S3BatchOperations_CSV_20180820"
        case s3inventoryreportCsv20161130 = "S3InventoryReport_CSV_20161130"
        public var description: String { return self.rawValue }
    }

    public enum JobReportFormat: String, CustomStringConvertible, Codable {
        case reportCsv20180820 = "Report_CSV_20180820"
        public var description: String { return self.rawValue }
    }

    public enum JobReportScope: String, CustomStringConvertible, Codable {
        case alltasks = "AllTasks"
        case failedtasksonly = "FailedTasksOnly"
        public var description: String { return self.rawValue }
    }

    public enum JobStatus: String, CustomStringConvertible, Codable {
        case active = "Active"
        case cancelled = "Cancelled"
        case cancelling = "Cancelling"
        case complete = "Complete"
        case completing = "Completing"
        case failed = "Failed"
        case failing = "Failing"
        case new = "New"
        case paused = "Paused"
        case pausing = "Pausing"
        case preparing = "Preparing"
        case ready = "Ready"
        case suspended = "Suspended"
        public var description: String { return self.rawValue }
    }

    public enum NetworkOrigin: String, CustomStringConvertible, Codable {
        case internet = "Internet"
        case vpc = "VPC"
        public var description: String { return self.rawValue }
    }

    public enum ObjectLambdaAllowedFeature: String, CustomStringConvertible, Codable {
        case getobjectPartnumber = "GetObject-PartNumber"
        case getobjectRange = "GetObject-Range"
        public var description: String { return self.rawValue }
    }

    public enum ObjectLambdaTransformationConfigurationAction: String, CustomStringConvertible, Codable {
        case getobject = "GetObject"
        public var description: String { return self.rawValue }
    }

    public enum OperationName: String, CustomStringConvertible, Codable {
        case lambdainvoke = "LambdaInvoke"
        case s3deleteobjecttagging = "S3DeleteObjectTagging"
        case s3initiaterestoreobject = "S3InitiateRestoreObject"
        case s3putobjectacl = "S3PutObjectAcl"
        case s3putobjectcopy = "S3PutObjectCopy"
        case s3putobjectlegalhold = "S3PutObjectLegalHold"
        case s3putobjectretention = "S3PutObjectRetention"
        case s3putobjecttagging = "S3PutObjectTagging"
        public var description: String { return self.rawValue }
    }

    public enum OutputSchemaVersion: String, CustomStringConvertible, Codable {
        case v1 = "V_1"
        public var description: String { return self.rawValue }
    }

    public enum RequestedJobStatus: String, CustomStringConvertible, Codable {
        case cancelled = "Cancelled"
        case ready = "Ready"
        public var description: String { return self.rawValue }
    }

    public enum S3CannedAccessControlList: String, CustomStringConvertible, Codable {
        case authenticatedRead = "authenticated-read"
        case awsExecRead = "aws-exec-read"
        case bucketOwnerFullControl = "bucket-owner-full-control"
        case bucketOwnerRead = "bucket-owner-read"
        case `private`
        case publicRead = "public-read"
        case publicReadWrite = "public-read-write"
        public var description: String { return self.rawValue }
    }

    public enum S3GlacierJobTier: String, CustomStringConvertible, Codable {
        case bulk = "BULK"
        case standard = "STANDARD"
        public var description: String { return self.rawValue }
    }

    public enum S3GranteeTypeIdentifier: String, CustomStringConvertible, Codable {
        case emailaddress = "emailAddress"
        case id
        case uri
        public var description: String { return self.rawValue }
    }

    public enum S3MetadataDirective: String, CustomStringConvertible, Codable {
        case copy = "COPY"
        case replace = "REPLACE"
        public var description: String { return self.rawValue }
    }

    public enum S3ObjectLockLegalHoldStatus: String, CustomStringConvertible, Codable {
        case off = "OFF"
        case on = "ON"
        public var description: String { return self.rawValue }
    }

    public enum S3ObjectLockMode: String, CustomStringConvertible, Codable {
        case compliance = "COMPLIANCE"
        case governance = "GOVERNANCE"
        public var description: String { return self.rawValue }
    }

    public enum S3ObjectLockRetentionMode: String, CustomStringConvertible, Codable {
        case compliance = "COMPLIANCE"
        case governance = "GOVERNANCE"
        public var description: String { return self.rawValue }
    }

    public enum S3Permission: String, CustomStringConvertible, Codable {
        case fullControl = "FULL_CONTROL"
        case read = "READ"
        case readAcp = "READ_ACP"
        case write = "WRITE"
        case writeAcp = "WRITE_ACP"
        public var description: String { return self.rawValue }
    }

    public enum S3SSEAlgorithm: String, CustomStringConvertible, Codable {
        case aes256 = "AES256"
        case kms = "KMS"
        public var description: String { return self.rawValue }
    }

    public enum S3StorageClass: String, CustomStringConvertible, Codable {
        case deepArchive = "DEEP_ARCHIVE"
        case glacier = "GLACIER"
        case intelligentTiering = "INTELLIGENT_TIERING"
        case onezoneIa = "ONEZONE_IA"
        case standard = "STANDARD"
        case standardIa = "STANDARD_IA"
        public var description: String { return self.rawValue }
    }

    public enum TransitionStorageClass: String, CustomStringConvertible, Codable {
        case deepArchive = "DEEP_ARCHIVE"
        case glacier = "GLACIER"
        case intelligentTiering = "INTELLIGENT_TIERING"
        case onezoneIa = "ONEZONE_IA"
        case standardIa = "STANDARD_IA"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AbortIncompleteMultipartUpload: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload to the Outposts bucket.
        public let daysAfterInitiation: Int?

        public init(daysAfterInitiation: Int? = nil) {
            self.daysAfterInitiation = daysAfterInitiation
        }

        private enum CodingKeys: String, CodingKey {
            case daysAfterInitiation = "DaysAfterInitiation"
        }
    }

    public struct AccessPoint: AWSDecodableShape {
        /// The ARN for the access point.
        public let accessPointArn: String?
        /// The name or alias of the access point.
        public let alias: String?
        /// The name of the bucket associated with this access point.
        public let bucket: String
        /// The name of this access point.
        public let name: String
        /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies.
        public let networkOrigin: NetworkOrigin
        /// The virtual private cloud (VPC) configuration for this access point, if one exists.  This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
        public let vpcConfiguration: VpcConfiguration?

        public init(accessPointArn: String? = nil, alias: String? = nil, bucket: String, name: String, networkOrigin: NetworkOrigin, vpcConfiguration: VpcConfiguration? = nil) {
            self.accessPointArn = accessPointArn
            self.alias = alias
            self.bucket = bucket
            self.name = name
            self.networkOrigin = networkOrigin
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointArn = "AccessPointArn"
            case alias = "Alias"
            case bucket = "Bucket"
            case name = "Name"
            case networkOrigin = "NetworkOrigin"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct AccountLevel: AWSEncodableShape & AWSDecodableShape {
        /// A container for the S3 Storage Lens activity metrics.
        public let activityMetrics: ActivityMetrics?
        /// A container for the S3 Storage Lens bucket-level configuration.
        public let bucketLevel: BucketLevel

        public init(activityMetrics: ActivityMetrics? = nil, bucketLevel: BucketLevel) {
            self.activityMetrics = activityMetrics
            self.bucketLevel = bucketLevel
        }

        public func validate(name: String) throws {
            try self.bucketLevel.validate(name: "\(name).bucketLevel")
        }

        private enum CodingKeys: String, CodingKey {
            case activityMetrics = "ActivityMetrics"
            case bucketLevel = "BucketLevel"
        }
    }

    public struct ActivityMetrics: AWSEncodableShape & AWSDecodableShape {
        /// A container for whether the activity metrics are enabled.
        public let isEnabled: Bool?

        public init(isEnabled: Bool? = nil) {
            self.isEnabled = isEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "IsEnabled"
        }
    }

    public struct AwsLambdaTransformation: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Lambda function.
        public let functionArn: String
        /// Additional JSON that provides supplemental data to the Lambda function used to transform objects.
        public let functionPayload: String?

        public init(functionArn: String, functionPayload: String? = nil) {
            self.functionArn = functionArn
            self.functionPayload = functionPayload
        }

        public func validate(name: String) throws {
            try self.validate(self.functionArn, name: "functionArn", parent: name, max: 1024)
            try self.validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try self.validate(self.functionArn, name: "functionArn", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "FunctionArn"
            case functionPayload = "FunctionPayload"
        }
    }

    public struct BucketLevel: AWSEncodableShape & AWSDecodableShape {
        /// A container for the bucket-level activity metrics for Amazon S3 Storage Lens
        public let activityMetrics: ActivityMetrics?
        /// A container for the bucket-level prefix-level metrics for S3 Storage Lens
        public let prefixLevel: PrefixLevel?

        public init(activityMetrics: ActivityMetrics? = nil, prefixLevel: PrefixLevel? = nil) {
            self.activityMetrics = activityMetrics
            self.prefixLevel = prefixLevel
        }

        public func validate(name: String) throws {
            try self.prefixLevel?.validate(name: "\(name).prefixLevel")
        }

        private enum CodingKeys: String, CodingKey {
            case activityMetrics = "ActivityMetrics"
            case prefixLevel = "PrefixLevel"
        }
    }

    public struct CreateAccessPointForObjectLambdaRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for owner of the specified Object Lambda Access Point.
        public let accountId: String
        /// Object Lambda Access Point configuration as a JSON document.
        public let configuration: ObjectLambdaConfiguration
        /// The name you want to assign to this Object Lambda Access Point.
        public let name: String

        public init(accountId: String, configuration: ObjectLambdaConfiguration, name: String) {
            self.accountId = accountId
            self.configuration = configuration
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct CreateAccessPointForObjectLambdaResult: AWSDecodableShape {
        /// Specifies the ARN for the Object Lambda Access Point.
        public let objectLambdaAccessPointArn: String?

        public init(objectLambdaAccessPointArn: String? = nil) {
            self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
        }
    }

    public struct CreateAccessPointRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the owner of the bucket for which you want to create an access point.
        public let accountId: String
        /// The name of the bucket that you want to associate this access point with. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String
        /// The name you want to assign to this access point.
        public let name: String
        ///  The PublicAccessBlock configuration that you want to apply to the access point.
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
        /// If you include this field, Amazon S3 restricts access to this access point to requests from the specified virtual private cloud (VPC).  This is required for creating an access point for Amazon S3 on Outposts buckets.
        public let vpcConfiguration: VpcConfiguration?

        public init(accountId: String, bucket: String, name: String, publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.accountId = accountId
            self.bucket = bucket
            self.name = name
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.vpcConfiguration = vpcConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct CreateAccessPointResult: AWSDecodableShape {
        /// The ARN of the access point.  This is only supported by Amazon S3 on Outposts.
        public let accessPointArn: String?
        /// The name or alias of the access point.
        public let alias: String?

        public init(accessPointArn: String? = nil, alias: String? = nil) {
            self.accessPointArn = accessPointArn
            self.alias = alias
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointArn = "AccessPointArn"
            case alias = "Alias"
        }
    }

    public struct CreateBucketConfiguration: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"

        /// Specifies the Region where the bucket will be created. If you are creating a bucket on the US East (N. Virginia) Region (us-east-1), you do not need to specify the location.   This is not supported by Amazon S3 on Outposts buckets.
        public let locationConstraint: BucketLocationConstraint?

        public init(locationConstraint: BucketLocationConstraint? = nil) {
            self.locationConstraint = locationConstraint
        }

        private enum CodingKeys: String, CodingKey {
            case locationConstraint = "LocationConstraint"
        }
    }

    public struct CreateBucketRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "createBucketConfiguration"
        public static var _encoding = [
            AWSMemberEncoding(label: "acl", location: .header(locationName: "x-amz-acl")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "createBucketConfiguration", location: .body(locationName: "CreateBucketConfiguration")),
            AWSMemberEncoding(label: "grantFullControl", location: .header(locationName: "x-amz-grant-full-control")),
            AWSMemberEncoding(label: "grantRead", location: .header(locationName: "x-amz-grant-read")),
            AWSMemberEncoding(label: "grantReadACP", location: .header(locationName: "x-amz-grant-read-acp")),
            AWSMemberEncoding(label: "grantWrite", location: .header(locationName: "x-amz-grant-write")),
            AWSMemberEncoding(label: "grantWriteACP", location: .header(locationName: "x-amz-grant-write-acp")),
            AWSMemberEncoding(label: "objectLockEnabledForBucket", location: .header(locationName: "x-amz-bucket-object-lock-enabled")),
            AWSMemberEncoding(label: "outpostId", location: .header(locationName: "x-amz-outpost-id"))
        ]

        /// The canned ACL to apply to the bucket.  This is not supported by Amazon S3 on Outposts buckets.
        public let acl: BucketCannedACL?
        /// The name of the bucket.
        public let bucket: String
        /// The configuration information for the bucket.  This is not supported by Amazon S3 on Outposts buckets.
        public let createBucketConfiguration: CreateBucketConfiguration?
        /// Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.  This is not supported by Amazon S3 on Outposts buckets.
        public let grantFullControl: String?
        /// Allows grantee to list the objects in the bucket.  This is not supported by Amazon S3 on Outposts buckets.
        public let grantRead: String?
        /// Allows grantee to read the bucket ACL.  This is not supported by Amazon S3 on Outposts buckets.
        public let grantReadACP: String?
        /// Allows grantee to create, overwrite, and delete any object in the bucket.  This is not supported by Amazon S3 on Outposts buckets.
        public let grantWrite: String?
        /// Allows grantee to write the ACL for the applicable bucket.  This is not supported by Amazon S3 on Outposts buckets.
        public let grantWriteACP: String?
        /// Specifies whether you want S3 Object Lock to be enabled for the new bucket.  This is not supported by Amazon S3 on Outposts buckets.
        public let objectLockEnabledForBucket: Bool?
        /// The ID of the Outposts where the bucket is being created.  This is required by Amazon S3 on Outposts buckets.
        public let outpostId: String?

        public init(acl: BucketCannedACL? = nil, bucket: String, createBucketConfiguration: CreateBucketConfiguration? = nil, grantFullControl: String? = nil, grantRead: String? = nil, grantReadACP: String? = nil, grantWrite: String? = nil, grantWriteACP: String? = nil, objectLockEnabledForBucket: Bool? = nil, outpostId: String? = nil) {
            self.acl = acl
            self.bucket = bucket
            self.createBucketConfiguration = createBucketConfiguration
            self.grantFullControl = grantFullControl
            self.grantRead = grantRead
            self.grantReadACP = grantReadACP
            self.grantWrite = grantWrite
            self.grantWriteACP = grantWriteACP
            self.objectLockEnabledForBucket = objectLockEnabledForBucket
            self.outpostId = outpostId
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.outpostId, name: "outpostId", parent: name, max: 64)
            try self.validate(self.outpostId, name: "outpostId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case createBucketConfiguration = "CreateBucketConfiguration"
        }
    }

    public struct CreateBucketResult: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "location", location: .header(locationName: "Location"))
        ]

        /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucketArn: String?
        /// The location of the bucket.
        public let location: String?

        public init(bucketArn: String? = nil, location: String? = nil) {
            self.bucketArn = bucketArn
            self.location = location
        }

        private enum CodingKeys: String, CodingKey {
            case bucketArn = "BucketArn"
            case location = "Location"
        }
    }

    public struct CreateJobRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId"))
        ]

        /// The account ID that creates the job.
        public let accountId: String
        /// An idempotency token to ensure that you don't accidentally submit the same request twice. You can use any string up to the maximum length.
        public let clientRequestToken: String
        /// Indicates whether confirmation is required before Amazon S3 runs the job. Confirmation is only required for jobs created through the Amazon S3 console.
        public let confirmationRequired: Bool?
        /// A description for this job. You can use any string within the permitted length. Descriptions don't need to be unique and can be used for multiple jobs.
        public let description: String?
        /// Configuration parameters for the manifest.
        public let manifest: JobManifest
        /// The action that you want this job to perform on every object listed in the manifest. For more information about the available actions, see Operations in the Amazon S3 User Guide.
        public let operation: JobOperation
        /// The numerical priority for this job. Higher numbers indicate higher priority.
        public let priority: Int
        /// Configuration parameters for the optional job-completion report.
        public let report: JobReport
        /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role that Batch Operations will use to run this job's action on every object in the manifest.
        public let roleArn: String
        /// A set of tags to associate with the S3 Batch Operations job. This is an optional parameter.
        @OptionalCustomCoding<StandardArrayCoder>
        public var tags: [S3Tag]?

        public init(accountId: String, clientRequestToken: String = CreateJobRequest.idempotencyToken(), confirmationRequired: Bool? = nil, description: String? = nil, manifest: JobManifest, operation: JobOperation, priority: Int, report: JobReport, roleArn: String, tags: [S3Tag]? = nil) {
            self.accountId = accountId
            self.clientRequestToken = clientRequestToken
            self.confirmationRequired = confirmationRequired
            self.description = description
            self.manifest = manifest
            self.operation = operation
            self.priority = priority
            self.report = report
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, max: 64)
            try self.validate(self.clientRequestToken, name: "clientRequestToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 256)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.manifest.validate(name: "\(name).manifest")
            try self.operation.validate(name: "\(name).operation")
            try self.validate(self.priority, name: "priority", parent: name, max: 2_147_483_647)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
            try self.report.validate(name: "\(name).report")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 1)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "arn:[^:]+:iam::\\d{12}:role/.*")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientRequestToken = "ClientRequestToken"
            case confirmationRequired = "ConfirmationRequired"
            case description = "Description"
            case manifest = "Manifest"
            case operation = "Operation"
            case priority = "Priority"
            case report = "Report"
            case roleArn = "RoleArn"
            case tags = "Tags"
        }
    }

    public struct CreateJobResult: AWSDecodableShape {
        /// The ID for this job. Amazon S3 generates this ID automatically and returns it after a successful Create Job request.
        public let jobId: String?

        public init(jobId: String? = nil) {
            self.jobId = jobId
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
        }
    }

    public struct DeleteAccessPointForObjectLambdaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The name of the access point you want to delete.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPointPolicyForObjectLambdaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The name of the Object Lambda Access Point you want to delete the policy for.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPointPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose policy you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/accesspoint/&lt;my-accesspoint-name&gt;. For example, to access the access point reports-ap through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAccessPointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point you want to delete. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/accesspoint/&lt;my-accesspoint-name&gt;. For example, to access the access point reports-ap through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBucketLifecycleConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID of the lifecycle configuration to delete.
        public let accountId: String
        /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBucketPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBucketRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID that owns the Outposts bucket.
        public let accountId: String
        /// Specifies the bucket being deleted. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteBucketTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID of the Outposts bucket tag set to be removed.
        public let accountId: String
        /// The bucket ARN that has the tag set to be removed. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteJobTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        /// The account ID associated with the S3 Batch Operations job.
        public let accountId: String
        /// The ID for the S3 Batch Operations job whose tags you want to delete.
        public let jobId: String

        public init(accountId: String, jobId: String) {
            self.accountId = accountId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 5)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteJobTaggingResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePublicAccessBlockRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId"))
        ]

        /// The account ID for the account whose PublicAccessBlock configuration you want to remove.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStorageLensConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "storagelensid"))
        ]

        /// The account ID of the requester.
        public let accountId: String
        /// The ID of the S3 Storage Lens configuration.
        public let configId: String

        public init(accountId: String, configId: String) {
            self.accountId = accountId
            self.configId = configId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.configId, name: "configId", parent: name, max: 64)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "[a-zA-Z0-9\\-\\_\\.]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStorageLensConfigurationTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "storagelensid"))
        ]

        /// The account ID of the requester.
        public let accountId: String
        /// The ID of the S3 Storage Lens configuration.
        public let configId: String

        public init(accountId: String, configId: String) {
            self.accountId = accountId
            self.configId = configId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.configId, name: "configId", parent: name, max: 64)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "[a-zA-Z0-9\\-\\_\\.]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStorageLensConfigurationTaggingResult: AWSDecodableShape {
        public init() {}
    }

    public struct DescribeJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        /// The account ID associated with the S3 Batch Operations job.
        public let accountId: String
        /// The ID for the job whose information you want to retrieve.
        public let jobId: String

        public init(accountId: String, jobId: String) {
            self.accountId = accountId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 5)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DescribeJobResult: AWSDecodableShape {
        /// Contains the configuration parameters and status for the job specified in the Describe Job request.
        public let job: JobDescriptor?

        public init(job: JobDescriptor? = nil) {
            self.job = job
        }

        private enum CodingKeys: String, CodingKey {
            case job = "Job"
        }
    }

    public struct Exclude: AWSEncodableShape & AWSDecodableShape {
        public struct _BucketsEncoding: ArrayCoderProperties { public static let member = "Arn" }
        public struct _RegionsEncoding: ArrayCoderProperties { public static let member = "Region" }

        /// A container for the S3 Storage Lens bucket excludes.
        @OptionalCustomCoding<ArrayCoder<_BucketsEncoding, String>>
        public var buckets: [String]?
        /// A container for the S3 Storage Lens Region excludes.
        @OptionalCustomCoding<ArrayCoder<_RegionsEncoding, String>>
        public var regions: [String]?

        public init(buckets: [String]? = nil, regions: [String]? = nil) {
            self.buckets = buckets
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.buckets?.forEach {
                try validate($0, name: "buckets[]", parent: name, max: 128)
                try validate($0, name: "buckets[]", parent: name, min: 1)
                try validate($0, name: "buckets[]", parent: name, pattern: "arn:[^:]+:s3:.*")
            }
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, max: 30)
                try validate($0, name: "regions[]", parent: name, min: 5)
                try validate($0, name: "regions[]", parent: name, pattern: "[a-z0-9\\-]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case buckets = "Buckets"
            case regions = "Regions"
        }
    }

    public struct GetAccessPointConfigurationForObjectLambdaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The name of the Object Lambda Access Point you want to return the configuration for.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointConfigurationForObjectLambdaResult: AWSDecodableShape {
        /// Object Lambda Access Point configuration document.
        public let configuration: ObjectLambdaConfiguration?

        public init(configuration: ObjectLambdaConfiguration? = nil) {
            self.configuration = configuration
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct GetAccessPointForObjectLambdaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The name of the Object Lambda Access Point.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointForObjectLambdaResult: AWSDecodableShape {
        /// The date and time when the specified Object Lambda Access Point was created.
        public let creationDate: Date?
        /// The name of the Object Lambda Access Point.
        public let name: String?
        /// Configuration to block all public access. This setting is turned on and can not be edited.
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

        public init(creationDate: Date? = nil, name: String? = nil, publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil) {
            self.creationDate = creationDate
            self.name = name
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case creationDate = "CreationDate"
            case name = "Name"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        }
    }

    public struct GetAccessPointPolicyForObjectLambdaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The name of the Object Lambda Access Point.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointPolicyForObjectLambdaResult: AWSDecodableShape {
        /// Object Lambda Access Point resource policy document.
        public let policy: String?

        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct GetAccessPointPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose policy you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/accesspoint/&lt;my-accesspoint-name&gt;. For example, to access the access point reports-ap through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointPolicyResult: AWSDecodableShape {
        /// The access point policy associated with the specified access point.
        public let policy: String?

        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct GetAccessPointPolicyStatusForObjectLambdaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The name of the Object Lambda Access Point.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointPolicyStatusForObjectLambdaResult: AWSDecodableShape {
        public let policyStatus: PolicyStatus?

        public init(policyStatus: PolicyStatus? = nil) {
            self.policyStatus = policyStatus
        }

        private enum CodingKeys: String, CodingKey {
            case policyStatus = "PolicyStatus"
        }
    }

    public struct GetAccessPointPolicyStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose policy status you want to retrieve.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointPolicyStatusResult: AWSDecodableShape {
        /// Indicates the current policy status of the specified access point.
        public let policyStatus: PolicyStatus?

        public init(policyStatus: PolicyStatus? = nil) {
            self.policyStatus = policyStatus
        }

        private enum CodingKeys: String, CodingKey {
            case policyStatus = "PolicyStatus"
        }
    }

    public struct GetAccessPointRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified access point.
        public let accountId: String
        /// The name of the access point whose configuration information you want to retrieve. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/accesspoint/&lt;my-accesspoint-name&gt;. For example, to access the access point reports-ap through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
        public let name: String

        public init(accountId: String, name: String) {
            self.accountId = accountId
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetAccessPointResult: AWSDecodableShape {
        /// The ARN of the access point.
        public let accessPointArn: String?
        /// The name or alias of the access point.
        public let alias: String?
        /// The name of the bucket associated with the specified access point.
        public let bucket: String?
        /// The date and time when the specified access point was created.
        public let creationDate: Date?
        /// The VPC endpoint for the access point.
        @OptionalCustomCoding<StandardDictionaryCoder>
        public var endpoints: [String: String]?
        /// The name of the specified access point.
        public let name: String?
        /// Indicates whether this access point allows access from the public internet. If VpcConfiguration is specified for this access point, then NetworkOrigin is VPC, and the access point doesn't allow access from the public internet. Otherwise, NetworkOrigin is Internet, and the access point allows access from the public internet, subject to the access point and bucket access policies. This will always be true for an Amazon S3 on Outposts access point
        public let networkOrigin: NetworkOrigin?
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?
        /// Contains the virtual private cloud (VPC) configuration for the specified access point.  This element is empty if this access point is an Amazon S3 on Outposts access point that is used by other Amazon Web Services.
        public let vpcConfiguration: VpcConfiguration?

        public init(accessPointArn: String? = nil, alias: String? = nil, bucket: String? = nil, creationDate: Date? = nil, endpoints: [String: String]? = nil, name: String? = nil, networkOrigin: NetworkOrigin? = nil, publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil, vpcConfiguration: VpcConfiguration? = nil) {
            self.accessPointArn = accessPointArn
            self.alias = alias
            self.bucket = bucket
            self.creationDate = creationDate
            self.endpoints = endpoints
            self.name = name
            self.networkOrigin = networkOrigin
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointArn = "AccessPointArn"
            case alias = "Alias"
            case bucket = "Bucket"
            case creationDate = "CreationDate"
            case endpoints = "Endpoints"
            case name = "Name"
            case networkOrigin = "NetworkOrigin"
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
            case vpcConfiguration = "VpcConfiguration"
        }
    }

    public struct GetBucketLifecycleConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBucketLifecycleConfigurationResult: AWSDecodableShape {
        public struct _RulesEncoding: ArrayCoderProperties { public static let member = "Rule" }

        /// Container for the lifecycle rule of the Outposts bucket.
        @OptionalCustomCoding<ArrayCoder<_RulesEncoding, LifecycleRule>>
        public var rules: [LifecycleRule]?

        public init(rules: [LifecycleRule]? = nil) {
            self.rules = rules
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct GetBucketPolicyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBucketPolicyResult: AWSDecodableShape {
        /// The policy of the Outposts bucket.
        public let policy: String?

        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct GetBucketRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBucketResult: AWSDecodableShape {
        /// The Outposts bucket requested.
        public let bucket: String?
        /// The creation date of the Outposts bucket.
        public let creationDate: Date?
        public let publicAccessBlockEnabled: Bool?

        public init(bucket: String? = nil, creationDate: Date? = nil, publicAccessBlockEnabled: Bool? = nil) {
            self.bucket = bucket
            self.creationDate = creationDate
            self.publicAccessBlockEnabled = publicAccessBlockEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case creationDate = "CreationDate"
            case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
        }
    }

    public struct GetBucketTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String

        public init(accountId: String, bucket: String) {
            self.accountId = accountId
            self.bucket = bucket
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetBucketTaggingResult: AWSDecodableShape {
        /// The tags set of the Outposts bucket.
        @CustomCoding<StandardArrayCoder>
        public var tagSet: [S3Tag]

        public init(tagSet: [S3Tag]) {
            self.tagSet = tagSet
        }

        private enum CodingKeys: String, CodingKey {
            case tagSet = "TagSet"
        }
    }

    public struct GetJobTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        /// The account ID associated with the S3 Batch Operations job.
        public let accountId: String
        /// The ID for the S3 Batch Operations job whose tags you want to retrieve.
        public let jobId: String

        public init(accountId: String, jobId: String) {
            self.accountId = accountId
            self.jobId = jobId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 5)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetJobTaggingResult: AWSDecodableShape {
        /// The set of tags associated with the S3 Batch Operations job.
        @OptionalCustomCoding<StandardArrayCoder>
        public var tags: [S3Tag]?

        public init(tags: [S3Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct GetPublicAccessBlockOutput: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "publicAccessBlockConfiguration"
        public static var _encoding = [
            AWSMemberEncoding(label: "publicAccessBlockConfiguration", location: .body(locationName: "PublicAccessBlockConfiguration"))
        ]

        /// The PublicAccessBlock configuration currently in effect for this account.
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration?

        public init(publicAccessBlockConfiguration: PublicAccessBlockConfiguration? = nil) {
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        }
    }

    public struct GetPublicAccessBlockRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId"))
        ]

        /// The account ID for the account whose PublicAccessBlock configuration you want to retrieve.
        public let accountId: String

        public init(accountId: String) {
            self.accountId = accountId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStorageLensConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "storagelensid"))
        ]

        /// The account ID of the requester.
        public let accountId: String
        /// The ID of the Amazon S3 Storage Lens configuration.
        public let configId: String

        public init(accountId: String, configId: String) {
            self.accountId = accountId
            self.configId = configId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.configId, name: "configId", parent: name, max: 64)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "[a-zA-Z0-9\\-\\_\\.]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStorageLensConfigurationResult: AWSDecodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "storageLensConfiguration"
        public static var _encoding = [
            AWSMemberEncoding(label: "storageLensConfiguration", location: .body(locationName: "StorageLensConfiguration"))
        ]

        /// The S3 Storage Lens configuration requested.
        public let storageLensConfiguration: StorageLensConfiguration?

        public init(storageLensConfiguration: StorageLensConfiguration? = nil) {
            self.storageLensConfiguration = storageLensConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case storageLensConfiguration = "StorageLensConfiguration"
        }
    }

    public struct GetStorageLensConfigurationTaggingRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "storagelensid"))
        ]

        /// The account ID of the requester.
        public let accountId: String
        /// The ID of the Amazon S3 Storage Lens configuration.
        public let configId: String

        public init(accountId: String, configId: String) {
            self.accountId = accountId
            self.configId = configId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.configId, name: "configId", parent: name, max: 64)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "[a-zA-Z0-9\\-\\_\\.]+")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStorageLensConfigurationTaggingResult: AWSDecodableShape {
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The tags of S3 Storage Lens configuration requested.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, StorageLensTag>>
        public var tags: [StorageLensTag]?

        public init(tags: [StorageLensTag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Include: AWSEncodableShape & AWSDecodableShape {
        public struct _BucketsEncoding: ArrayCoderProperties { public static let member = "Arn" }
        public struct _RegionsEncoding: ArrayCoderProperties { public static let member = "Region" }

        /// A container for the S3 Storage Lens bucket includes.
        @OptionalCustomCoding<ArrayCoder<_BucketsEncoding, String>>
        public var buckets: [String]?
        /// A container for the S3 Storage Lens Region includes.
        @OptionalCustomCoding<ArrayCoder<_RegionsEncoding, String>>
        public var regions: [String]?

        public init(buckets: [String]? = nil, regions: [String]? = nil) {
            self.buckets = buckets
            self.regions = regions
        }

        public func validate(name: String) throws {
            try self.buckets?.forEach {
                try validate($0, name: "buckets[]", parent: name, max: 128)
                try validate($0, name: "buckets[]", parent: name, min: 1)
                try validate($0, name: "buckets[]", parent: name, pattern: "arn:[^:]+:s3:.*")
            }
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, max: 30)
                try validate($0, name: "regions[]", parent: name, min: 5)
                try validate($0, name: "regions[]", parent: name, pattern: "[a-z0-9\\-]+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case buckets = "Buckets"
            case regions = "Regions"
        }
    }

    public struct JobDescriptor: AWSDecodableShape {
        /// Indicates whether confirmation is required before Amazon S3 begins running the specified job. Confirmation is required only for jobs created through the Amazon S3 console.
        public let confirmationRequired: Bool?
        /// A timestamp indicating when this job was created.
        public let creationTime: Date?
        /// The description for this job, if one was provided in this job's Create Job request.
        public let description: String?
        /// If the specified job failed, this field contains information describing the failure.
        @OptionalCustomCoding<StandardArrayCoder>
        public var failureReasons: [JobFailure]?
        /// The Amazon Resource Name (ARN) for this job.
        public let jobArn: String?
        /// The ID for the specified job.
        public let jobId: String?
        /// The configuration information for the specified job's manifest object.
        public let manifest: JobManifest?
        /// The operation that the specified job is configured to run on the objects listed in the manifest.
        public let operation: JobOperation?
        /// The priority of the specified job.
        public let priority: Int?
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public let progressSummary: JobProgressSummary?
        /// Contains the configuration information for the job-completion report if you requested one in the Create Job request.
        public let report: JobReport?
        /// The Amazon Resource Name (ARN) for the Identity and Access Management (IAM) role assigned to run the tasks for this job.
        public let roleArn: String?
        /// The current status of the specified job.
        public let status: JobStatus?
        /// The reason for updating the job.
        public let statusUpdateReason: String?
        /// The reason why the specified job was suspended. A job is only suspended if you create it through the Amazon S3 console. When you create the job, it enters the Suspended state to await confirmation before running. After you confirm the job, it automatically exits the Suspended state.
        public let suspendedCause: String?
        /// The timestamp when this job was suspended, if it has been suspended.
        public let suspendedDate: Date?
        /// A timestamp indicating when this job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public let terminationDate: Date?

        public init(confirmationRequired: Bool? = nil, creationTime: Date? = nil, description: String? = nil, failureReasons: [JobFailure]? = nil, jobArn: String? = nil, jobId: String? = nil, manifest: JobManifest? = nil, operation: JobOperation? = nil, priority: Int? = nil, progressSummary: JobProgressSummary? = nil, report: JobReport? = nil, roleArn: String? = nil, status: JobStatus? = nil, statusUpdateReason: String? = nil, suspendedCause: String? = nil, suspendedDate: Date? = nil, terminationDate: Date? = nil) {
            self.confirmationRequired = confirmationRequired
            self.creationTime = creationTime
            self.description = description
            self.failureReasons = failureReasons
            self.jobArn = jobArn
            self.jobId = jobId
            self.manifest = manifest
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.report = report
            self.roleArn = roleArn
            self.status = status
            self.statusUpdateReason = statusUpdateReason
            self.suspendedCause = suspendedCause
            self.suspendedDate = suspendedDate
            self.terminationDate = terminationDate
        }

        private enum CodingKeys: String, CodingKey {
            case confirmationRequired = "ConfirmationRequired"
            case creationTime = "CreationTime"
            case description = "Description"
            case failureReasons = "FailureReasons"
            case jobArn = "JobArn"
            case jobId = "JobId"
            case manifest = "Manifest"
            case operation = "Operation"
            case priority = "Priority"
            case progressSummary = "ProgressSummary"
            case report = "Report"
            case roleArn = "RoleArn"
            case status = "Status"
            case statusUpdateReason = "StatusUpdateReason"
            case suspendedCause = "SuspendedCause"
            case suspendedDate = "SuspendedDate"
            case terminationDate = "TerminationDate"
        }
    }

    public struct JobFailure: AWSDecodableShape {
        /// The failure code, if any, for the specified job.
        public let failureCode: String?
        /// The failure reason, if any, for the specified job.
        public let failureReason: String?

        public init(failureCode: String? = nil, failureReason: String? = nil) {
            self.failureCode = failureCode
            self.failureReason = failureReason
        }

        private enum CodingKeys: String, CodingKey {
            case failureCode = "FailureCode"
            case failureReason = "FailureReason"
        }
    }

    public struct JobListDescriptor: AWSDecodableShape {
        /// A timestamp indicating when the specified job was created.
        public let creationTime: Date?
        /// The user-specified description that was included in the specified job's Create Job request.
        public let description: String?
        /// The ID for the specified job.
        public let jobId: String?
        /// The operation that the specified job is configured to run on every object listed in the manifest.
        public let operation: OperationName?
        /// The current priority for the specified job.
        public let priority: Int?
        /// Describes the total number of tasks that the specified job has run, the number of tasks that succeeded, and the number of tasks that failed.
        public let progressSummary: JobProgressSummary?
        /// The specified job's current status.
        public let status: JobStatus?
        /// A timestamp indicating when the specified job terminated. A job's termination date is the date and time when it succeeded, failed, or was canceled.
        public let terminationDate: Date?

        public init(creationTime: Date? = nil, description: String? = nil, jobId: String? = nil, operation: OperationName? = nil, priority: Int? = nil, progressSummary: JobProgressSummary? = nil, status: JobStatus? = nil, terminationDate: Date? = nil) {
            self.creationTime = creationTime
            self.description = description
            self.jobId = jobId
            self.operation = operation
            self.priority = priority
            self.progressSummary = progressSummary
            self.status = status
            self.terminationDate = terminationDate
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case description = "Description"
            case jobId = "JobId"
            case operation = "Operation"
            case priority = "Priority"
            case progressSummary = "ProgressSummary"
            case status = "Status"
            case terminationDate = "TerminationDate"
        }
    }

    public struct JobManifest: AWSEncodableShape & AWSDecodableShape {
        /// Contains the information required to locate the specified job's manifest.
        public let location: JobManifestLocation
        /// Describes the format of the specified job's manifest. If the manifest is in CSV format, also describes the columns contained within the manifest.
        public let spec: JobManifestSpec

        public init(location: JobManifestLocation, spec: JobManifestSpec) {
            self.location = location
            self.spec = spec
        }

        public func validate(name: String) throws {
            try self.location.validate(name: "\(name).location")
        }

        private enum CodingKeys: String, CodingKey {
            case location = "Location"
            case spec = "Spec"
        }
    }

    public struct JobManifestLocation: AWSEncodableShape & AWSDecodableShape {
        /// The ETag for the specified manifest object.
        public let eTag: String
        /// The Amazon Resource Name (ARN) for a manifest object.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see  XML related object key constraints.
        public let objectArn: String
        /// The optional version ID to identify a specific version of the manifest object.
        public let objectVersionId: String?

        public init(eTag: String, objectArn: String, objectVersionId: String? = nil) {
            self.eTag = eTag
            self.objectArn = objectArn
            self.objectVersionId = objectVersionId
        }

        public func validate(name: String) throws {
            try self.validate(self.eTag, name: "eTag", parent: name, max: 1024)
            try self.validate(self.eTag, name: "eTag", parent: name, min: 1)
            try self.validate(self.objectArn, name: "objectArn", parent: name, max: 2000)
            try self.validate(self.objectArn, name: "objectArn", parent: name, min: 1)
            try self.validate(self.objectArn, name: "objectArn", parent: name, pattern: "arn:[^:]+:s3:.*")
            try self.validate(self.objectVersionId, name: "objectVersionId", parent: name, max: 2000)
            try self.validate(self.objectVersionId, name: "objectVersionId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eTag = "ETag"
            case objectArn = "ObjectArn"
            case objectVersionId = "ObjectVersionId"
        }
    }

    public struct JobManifestSpec: AWSEncodableShape & AWSDecodableShape {
        /// If the specified manifest object is in the S3BatchOperations_CSV_20180820 format, this element describes which columns contain the required data.
        @OptionalCustomCoding<StandardArrayCoder>
        public var fields: [JobManifestFieldName]?
        /// Indicates which of the available formats the specified manifest uses.
        public let format: JobManifestFormat

        public init(fields: [JobManifestFieldName]? = nil, format: JobManifestFormat) {
            self.fields = fields
            self.format = format
        }

        private enum CodingKeys: String, CodingKey {
            case fields = "Fields"
            case format = "Format"
        }
    }

    public struct JobOperation: AWSEncodableShape & AWSDecodableShape {
        /// Directs the specified job to invoke an Lambda function on every object in the manifest.
        public let lambdaInvoke: LambdaInvokeOperation?
        /// Directs the specified job to execute a DELETE Object tagging call on every object in the manifest.
        public let s3DeleteObjectTagging: S3DeleteObjectTaggingOperation?
        /// Directs the specified job to initiate restore requests for every archived object in the manifest.
        public let s3InitiateRestoreObject: S3InitiateRestoreObjectOperation?
        /// Directs the specified job to run a PUT Object acl call on every object in the manifest.
        public let s3PutObjectAcl: S3SetObjectAclOperation?
        /// Directs the specified job to run a PUT Copy object call on every object in the manifest.
        public let s3PutObjectCopy: S3CopyObjectOperation?
        public let s3PutObjectLegalHold: S3SetObjectLegalHoldOperation?
        public let s3PutObjectRetention: S3SetObjectRetentionOperation?
        /// Directs the specified job to run a PUT Object tagging call on every object in the manifest.
        public let s3PutObjectTagging: S3SetObjectTaggingOperation?

        public init(lambdaInvoke: LambdaInvokeOperation? = nil, s3DeleteObjectTagging: S3DeleteObjectTaggingOperation? = nil, s3InitiateRestoreObject: S3InitiateRestoreObjectOperation? = nil, s3PutObjectAcl: S3SetObjectAclOperation? = nil, s3PutObjectCopy: S3CopyObjectOperation? = nil, s3PutObjectLegalHold: S3SetObjectLegalHoldOperation? = nil, s3PutObjectRetention: S3SetObjectRetentionOperation? = nil, s3PutObjectTagging: S3SetObjectTaggingOperation? = nil) {
            self.lambdaInvoke = lambdaInvoke
            self.s3DeleteObjectTagging = s3DeleteObjectTagging
            self.s3InitiateRestoreObject = s3InitiateRestoreObject
            self.s3PutObjectAcl = s3PutObjectAcl
            self.s3PutObjectCopy = s3PutObjectCopy
            self.s3PutObjectLegalHold = s3PutObjectLegalHold
            self.s3PutObjectRetention = s3PutObjectRetention
            self.s3PutObjectTagging = s3PutObjectTagging
        }

        public func validate(name: String) throws {
            try self.lambdaInvoke?.validate(name: "\(name).lambdaInvoke")
            try self.s3InitiateRestoreObject?.validate(name: "\(name).s3InitiateRestoreObject")
            try self.s3PutObjectAcl?.validate(name: "\(name).s3PutObjectAcl")
            try self.s3PutObjectCopy?.validate(name: "\(name).s3PutObjectCopy")
            try self.s3PutObjectTagging?.validate(name: "\(name).s3PutObjectTagging")
        }

        private enum CodingKeys: String, CodingKey {
            case lambdaInvoke = "LambdaInvoke"
            case s3DeleteObjectTagging = "S3DeleteObjectTagging"
            case s3InitiateRestoreObject = "S3InitiateRestoreObject"
            case s3PutObjectAcl = "S3PutObjectAcl"
            case s3PutObjectCopy = "S3PutObjectCopy"
            case s3PutObjectLegalHold = "S3PutObjectLegalHold"
            case s3PutObjectRetention = "S3PutObjectRetention"
            case s3PutObjectTagging = "S3PutObjectTagging"
        }
    }

    public struct JobProgressSummary: AWSDecodableShape {
        public let numberOfTasksFailed: Int64?
        public let numberOfTasksSucceeded: Int64?
        public let totalNumberOfTasks: Int64?

        public init(numberOfTasksFailed: Int64? = nil, numberOfTasksSucceeded: Int64? = nil, totalNumberOfTasks: Int64? = nil) {
            self.numberOfTasksFailed = numberOfTasksFailed
            self.numberOfTasksSucceeded = numberOfTasksSucceeded
            self.totalNumberOfTasks = totalNumberOfTasks
        }

        private enum CodingKeys: String, CodingKey {
            case numberOfTasksFailed = "NumberOfTasksFailed"
            case numberOfTasksSucceeded = "NumberOfTasksSucceeded"
            case totalNumberOfTasks = "TotalNumberOfTasks"
        }
    }

    public struct JobReport: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the bucket where specified job-completion report will be stored.
        public let bucket: String?
        /// Indicates whether the specified job will generate a job-completion report.
        public let enabled: Bool
        /// The format of the specified job-completion report.
        public let format: JobReportFormat?
        /// An optional prefix to describe where in the specified bucket the job-completion report will be stored. Amazon S3 stores the job-completion report at &lt;prefix&gt;/job-&lt;job-id&gt;/report.json.
        public let prefix: String?
        /// Indicates whether the job-completion report will include details of all tasks or only failed tasks.
        public let reportScope: JobReportScope?

        public init(bucket: String? = nil, enabled: Bool, format: JobReportFormat? = nil, prefix: String? = nil, reportScope: JobReportScope? = nil) {
            self.bucket = bucket
            self.enabled = enabled
            self.format = format
            self.prefix = prefix
            self.reportScope = reportScope
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 128)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 1)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "arn:[^:]+:s3:.*")
            try self.validate(self.prefix, name: "prefix", parent: name, max: 512)
            try self.validate(self.prefix, name: "prefix", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case enabled = "Enabled"
            case format = "Format"
            case prefix = "Prefix"
            case reportScope = "ReportScope"
        }
    }

    public struct LambdaInvokeOperation: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) for the Lambda function that the specified job will invoke on every object in the manifest.
        public let functionArn: String?

        public init(functionArn: String? = nil) {
            self.functionArn = functionArn
        }

        public func validate(name: String) throws {
            try self.validate(self.functionArn, name: "functionArn", parent: name, max: 1024)
            try self.validate(self.functionArn, name: "functionArn", parent: name, min: 1)
            try self.validate(self.functionArn, name: "functionArn", parent: name, pattern: "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?")
        }

        private enum CodingKeys: String, CodingKey {
            case functionArn = "FunctionArn"
        }
    }

    public struct LifecycleConfiguration: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public struct _RulesEncoding: ArrayCoderProperties { public static let member = "Rule" }

        /// A lifecycle rule for individual objects in an Outposts bucket.
        @OptionalCustomCoding<ArrayCoder<_RulesEncoding, LifecycleRule>>
        public var rules: [LifecycleRule]?

        public init(rules: [LifecycleRule]? = nil) {
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.rules?.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case rules = "Rules"
        }
    }

    public struct LifecycleExpiration: AWSEncodableShape & AWSDecodableShape {
        /// Indicates at what date the object is to be deleted. Should be in GMT ISO 8601 format.
        public let date: Date?
        /// Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.
        public let days: Int?
        /// Indicates whether Amazon S3 will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired. If set to false, the policy takes no action. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
        public let expiredObjectDeleteMarker: Bool?

        public init(date: Date? = nil, days: Int? = nil, expiredObjectDeleteMarker: Bool? = nil) {
            self.date = date
            self.days = days
            self.expiredObjectDeleteMarker = expiredObjectDeleteMarker
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case days = "Days"
            case expiredObjectDeleteMarker = "ExpiredObjectDeleteMarker"
        }
    }

    public struct LifecycleRule: AWSEncodableShape & AWSDecodableShape {
        public struct _NoncurrentVersionTransitionsEncoding: ArrayCoderProperties { public static let member = "NoncurrentVersionTransition" }
        public struct _TransitionsEncoding: ArrayCoderProperties { public static let member = "Transition" }

        /// Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 waits before permanently removing all parts of the upload. For more information, see  Aborting Incomplete Multipart Uploads Using a Bucket Lifecycle Policy in the Amazon S3 User Guide.
        public let abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload?
        /// Specifies the expiration for the lifecycle of the object in the form of date, days and, whether the object has a delete marker.
        public let expiration: LifecycleExpiration?
        /// The container for the filter of lifecycle rule.
        public let filter: LifecycleRuleFilter?
        /// Unique identifier for the rule. The value cannot be longer than 255 characters.
        public let id: String?
        /// The noncurrent version expiration of the lifecycle rule.  This is not supported by Amazon S3 on Outposts buckets.
        public let noncurrentVersionExpiration: NoncurrentVersionExpiration?
        ///  Specifies the transition rule for the lifecycle rule that describes when noncurrent objects transition to a specific storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to a specific storage class at a set period in the object's lifetime.   This is not supported by Amazon S3 on Outposts buckets.
        @OptionalCustomCoding<ArrayCoder<_NoncurrentVersionTransitionsEncoding, NoncurrentVersionTransition>>
        public var noncurrentVersionTransitions: [NoncurrentVersionTransition]?
        /// If 'Enabled', the rule is currently being applied. If 'Disabled', the rule is not currently being applied.
        public let status: ExpirationStatus
        /// Specifies when an Amazon S3 object transitions to a specified storage class.  This is not supported by Amazon S3 on Outposts buckets.
        @OptionalCustomCoding<ArrayCoder<_TransitionsEncoding, Transition>>
        public var transitions: [Transition]?

        public init(abortIncompleteMultipartUpload: AbortIncompleteMultipartUpload? = nil, expiration: LifecycleExpiration? = nil, filter: LifecycleRuleFilter? = nil, id: String? = nil, noncurrentVersionExpiration: NoncurrentVersionExpiration? = nil, noncurrentVersionTransitions: [NoncurrentVersionTransition]? = nil, status: ExpirationStatus, transitions: [Transition]? = nil) {
            self.abortIncompleteMultipartUpload = abortIncompleteMultipartUpload
            self.expiration = expiration
            self.filter = filter
            self.id = id
            self.noncurrentVersionExpiration = noncurrentVersionExpiration
            self.noncurrentVersionTransitions = noncurrentVersionTransitions
            self.status = status
            self.transitions = transitions
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
        }

        private enum CodingKeys: String, CodingKey {
            case abortIncompleteMultipartUpload = "AbortIncompleteMultipartUpload"
            case expiration = "Expiration"
            case filter = "Filter"
            case id = "ID"
            case noncurrentVersionExpiration = "NoncurrentVersionExpiration"
            case noncurrentVersionTransitions = "NoncurrentVersionTransitions"
            case status = "Status"
            case transitions = "Transitions"
        }
    }

    public struct LifecycleRuleAndOperator: AWSEncodableShape & AWSDecodableShape {
        /// Prefix identifying one or more objects to which the rule applies.
        public let prefix: String?
        /// All of these tags must exist in the object's tag set in order for the rule to apply.
        @OptionalCustomCoding<StandardArrayCoder>
        public var tags: [S3Tag]?

        public init(prefix: String? = nil, tags: [S3Tag]? = nil) {
            self.prefix = prefix
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case prefix = "Prefix"
            case tags = "Tags"
        }
    }

    public struct LifecycleRuleFilter: AWSEncodableShape & AWSDecodableShape {
        /// The container for the AND condition for the lifecycle rule.
        public let and: LifecycleRuleAndOperator?
        /// Prefix identifying one or more objects to which the rule applies.  Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests. For more information, see  XML related object key constraints.
        public let prefix: String?
        public let tag: S3Tag?

        public init(and: LifecycleRuleAndOperator? = nil, prefix: String? = nil, tag: S3Tag? = nil) {
            self.and = and
            self.prefix = prefix
            self.tag = tag
        }

        public func validate(name: String) throws {
            try self.and?.validate(name: "\(name).and")
            try self.tag?.validate(name: "\(name).tag")
        }

        private enum CodingKeys: String, CodingKey {
            case and = "And"
            case prefix = "Prefix"
            case tag = "Tag"
        }
    }

    public struct ListAccessPointsForObjectLambdaRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The maximum number of access points that you want to include in the list. If there are more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
        public let maxResults: Int?
        /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
        public let nextToken: String?

        public init(accountId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPointsForObjectLambdaResult: AWSDecodableShape {
        public struct _ObjectLambdaAccessPointListEncoding: ArrayCoderProperties { public static let member = "ObjectLambdaAccessPoint" }

        /// If the list has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
        public let nextToken: String?
        /// Returns list of Object Lambda Access Points.
        @OptionalCustomCoding<ArrayCoder<_ObjectLambdaAccessPointListEncoding, ObjectLambdaAccessPoint>>
        public var objectLambdaAccessPointList: [ObjectLambdaAccessPoint]?

        public init(nextToken: String? = nil, objectLambdaAccessPointList: [ObjectLambdaAccessPoint]? = nil) {
            self.nextToken = nextToken
            self.objectLambdaAccessPointList = objectLambdaAccessPointList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case objectLambdaAccessPointList = "ObjectLambdaAccessPointList"
        }
    }

    public struct ListAccessPointsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .querystring(locationName: "bucket")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The account ID for owner of the bucket whose access points you want to list.
        public let accountId: String
        /// The name of the bucket whose associated access points you want to list. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String?
        /// The maximum number of access points that you want to include in the list. If the specified bucket has more than this number of access points, then the response will include a continuation token in the NextToken field that you can use to retrieve the next page of access points.
        public let maxResults: Int?
        /// A continuation token. If a previous call to ListAccessPoints returned a continuation token in the NextToken field, then providing that value here causes Amazon S3 to retrieve the next page of results.
        public let nextToken: String?

        public init(accountId: String, bucket: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.bucket = bucket
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAccessPointsResult: AWSDecodableShape {
        public struct _AccessPointListEncoding: ArrayCoderProperties { public static let member = "AccessPoint" }

        /// Contains identification and configuration information for one or more access points associated with the specified bucket.
        @OptionalCustomCoding<ArrayCoder<_AccessPointListEncoding, AccessPoint>>
        public var accessPointList: [AccessPoint]?
        /// If the specified bucket has more access points than can be returned in one call to this API, this field contains a continuation token that you can provide in subsequent calls to this API to retrieve additional access points.
        public let nextToken: String?

        public init(accessPointList: [AccessPoint]? = nil, nextToken: String? = nil) {
            self.accessPointList = accessPointList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessPointList = "AccessPointList"
            case nextToken = "NextToken"
        }
    }

    public struct ListJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "jobStatuses", location: .querystring(locationName: "jobStatuses")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The account ID associated with the S3 Batch Operations job.
        public let accountId: String
        /// The List Jobs request returns jobs that match the statuses listed in this element.
        public let jobStatuses: [JobStatus]?
        /// The maximum number of jobs that Amazon S3 will include in the List Jobs response. If there are more jobs than this number, the response will include a pagination token in the NextToken field to enable you to retrieve the next page of results.
        public let maxResults: Int?
        /// A pagination token to request the next page of results. Use the token that Amazon S3 returned in the NextToken element of the ListJobsResult from the previous List Jobs request.
        public let nextToken: String?

        public init(accountId: String, jobStatuses: [JobStatus]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.accountId = accountId
            self.jobStatuses = jobStatuses
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[A-Za-z0-9\\+\\:\\/\\=\\?\\#-_]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListJobsResult: AWSDecodableShape {
        /// The list of current jobs and jobs that have ended within the last 30 days.
        @OptionalCustomCoding<StandardArrayCoder>
        public var jobs: [JobListDescriptor]?
        /// If the List Jobs request produced more than the maximum number of results, you can pass this value into a subsequent List Jobs request in order to retrieve the next page of results.
        public let nextToken: String?

        public init(jobs: [JobListDescriptor]? = nil, nextToken: String? = nil) {
            self.jobs = jobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case jobs = "Jobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListRegionalBucketsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken")),
            AWSMemberEncoding(label: "outpostId", location: .header(locationName: "x-amz-outpost-id"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        public let maxResults: Int?
        public let nextToken: String?
        /// The ID of the Outposts.  This is required by Amazon S3 on Outposts buckets.
        public let outpostId: String?

        public init(accountId: String, maxResults: Int? = nil, nextToken: String? = nil, outpostId: String? = nil) {
            self.accountId = accountId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.outpostId = outpostId
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 1000)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 0)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.outpostId, name: "outpostId", parent: name, max: 64)
            try self.validate(self.outpostId, name: "outpostId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRegionalBucketsResult: AWSDecodableShape {
        public struct _RegionalBucketListEncoding: ArrayCoderProperties { public static let member = "RegionalBucket" }

        ///  NextToken is sent when isTruncated is true, which means there are more buckets that can be listed. The next list requests to Amazon S3 can be continued with this NextToken. NextToken is obfuscated and is not a real key.
        public let nextToken: String?
        @OptionalCustomCoding<ArrayCoder<_RegionalBucketListEncoding, RegionalBucket>>
        public var regionalBucketList: [RegionalBucket]?

        public init(nextToken: String? = nil, regionalBucketList: [RegionalBucket]? = nil) {
            self.nextToken = nextToken
            self.regionalBucketList = regionalBucketList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case regionalBucketList = "RegionalBucketList"
        }
    }

    public struct ListStorageLensConfigurationEntry: AWSDecodableShape {
        /// A container for the S3 Storage Lens home Region. Your metrics data is stored and retained in your designated S3 Storage Lens home Region.
        public let homeRegion: String
        /// A container for the S3 Storage Lens configuration ID.
        public let id: String
        /// A container for whether the S3 Storage Lens configuration is enabled. This property is required.
        public let isEnabled: Bool?
        /// The ARN of the S3 Storage Lens configuration. This property is read-only.
        public let storageLensArn: String

        public init(homeRegion: String, id: String, isEnabled: Bool? = nil, storageLensArn: String) {
            self.homeRegion = homeRegion
            self.id = id
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }

        private enum CodingKeys: String, CodingKey {
            case homeRegion = "HomeRegion"
            case id = "Id"
            case isEnabled = "IsEnabled"
            case storageLensArn = "StorageLensArn"
        }
    }

    public struct ListStorageLensConfigurationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "nextToken"))
        ]

        /// The account ID of the requester.
        public let accountId: String
        /// A pagination token to request the next page of results.
        public let nextToken: String?

        public init(accountId: String, nextToken: String? = nil) {
            self.accountId = accountId
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStorageLensConfigurationsResult: AWSDecodableShape {
        /// If the request produced more than the maximum number of S3 Storage Lens configuration results, you can pass this value into a subsequent request to retrieve the next page of results.
        public let nextToken: String?
        /// A list of S3 Storage Lens configurations.
        public let storageLensConfigurationList: [ListStorageLensConfigurationEntry]?

        public init(nextToken: String? = nil, storageLensConfigurationList: [ListStorageLensConfigurationEntry]? = nil) {
            self.nextToken = nextToken
            self.storageLensConfigurationList = storageLensConfigurationList
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case storageLensConfigurationList = "StorageLensConfiguration"
        }
    }

    public struct NoncurrentVersionExpiration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see How Amazon S3 Calculates When an Object Became Noncurrent in the Amazon S3 User Guide.
        public let noncurrentDays: Int?

        public init(noncurrentDays: Int? = nil) {
            self.noncurrentDays = noncurrentDays
        }

        private enum CodingKeys: String, CodingKey {
            case noncurrentDays = "NoncurrentDays"
        }
    }

    public struct NoncurrentVersionTransition: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action. For information about the noncurrent days calculations, see  How Amazon S3 Calculates How Long an Object Has Been Noncurrent in the Amazon S3 User Guide.
        public let noncurrentDays: Int?
        /// The class of storage used to store the object.
        public let storageClass: TransitionStorageClass?

        public init(noncurrentDays: Int? = nil, storageClass: TransitionStorageClass? = nil) {
            self.noncurrentDays = noncurrentDays
            self.storageClass = storageClass
        }

        private enum CodingKeys: String, CodingKey {
            case noncurrentDays = "NoncurrentDays"
            case storageClass = "StorageClass"
        }
    }

    public struct ObjectLambdaAccessPoint: AWSDecodableShape {
        /// The name of the Object Lambda Access Point.
        public let name: String
        /// Specifies the ARN for the Object Lambda Access Point.
        public let objectLambdaAccessPointArn: String?

        public init(name: String, objectLambdaAccessPointArn: String? = nil) {
            self.name = name
            self.objectLambdaAccessPointArn = objectLambdaAccessPointArn
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case objectLambdaAccessPointArn = "ObjectLambdaAccessPointArn"
        }
    }

    public struct ObjectLambdaConfiguration: AWSEncodableShape & AWSDecodableShape {
        public struct _AllowedFeaturesEncoding: ArrayCoderProperties { public static let member = "AllowedFeature" }
        public struct _TransformationConfigurationsEncoding: ArrayCoderProperties { public static let member = "TransformationConfiguration" }

        /// A container for allowed features. Valid inputs are GetObject-Range and GetObject-PartNumber.
        @OptionalCustomCoding<ArrayCoder<_AllowedFeaturesEncoding, ObjectLambdaAllowedFeature>>
        public var allowedFeatures: [ObjectLambdaAllowedFeature]?
        /// A container for whether the CloudWatch metrics configuration is enabled.
        public let cloudWatchMetricsEnabled: Bool?
        /// Standard access point associated with the Object Lambda Access Point.
        public let supportingAccessPoint: String
        /// A container for transformation configurations for an Object Lambda Access Point.
        @CustomCoding<ArrayCoder<_TransformationConfigurationsEncoding, ObjectLambdaTransformationConfiguration>>
        public var transformationConfigurations: [ObjectLambdaTransformationConfiguration]

        public init(allowedFeatures: [ObjectLambdaAllowedFeature]? = nil, cloudWatchMetricsEnabled: Bool? = nil, supportingAccessPoint: String, transformationConfigurations: [ObjectLambdaTransformationConfiguration]) {
            self.allowedFeatures = allowedFeatures
            self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
            self.supportingAccessPoint = supportingAccessPoint
            self.transformationConfigurations = transformationConfigurations
        }

        public func validate(name: String) throws {
            try self.validate(self.supportingAccessPoint, name: "supportingAccessPoint", parent: name, max: 2048)
            try self.validate(self.supportingAccessPoint, name: "supportingAccessPoint", parent: name, min: 1)
            try self.validate(self.supportingAccessPoint, name: "supportingAccessPoint", parent: name, pattern: "arn:[^:]+:s3:[^:]*:\\d{12}:accesspoint/.*")
            try self.transformationConfigurations.forEach {
                try $0.validate(name: "\(name).transformationConfigurations[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case allowedFeatures = "AllowedFeatures"
            case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
            case supportingAccessPoint = "SupportingAccessPoint"
            case transformationConfigurations = "TransformationConfigurations"
        }
    }

    public struct ObjectLambdaContentTransformation: AWSEncodableShape & AWSDecodableShape {
        /// A container for an Lambda function.
        public let awsLambda: AwsLambdaTransformation?

        public init(awsLambda: AwsLambdaTransformation? = nil) {
            self.awsLambda = awsLambda
        }

        public func validate(name: String) throws {
            try self.awsLambda?.validate(name: "\(name).awsLambda")
        }

        private enum CodingKeys: String, CodingKey {
            case awsLambda = "AwsLambda"
        }
    }

    public struct ObjectLambdaTransformationConfiguration: AWSEncodableShape & AWSDecodableShape {
        public struct _ActionsEncoding: ArrayCoderProperties { public static let member = "Action" }

        /// A container for the action of an Object Lambda Access Point configuration. Valid input is GetObject.
        @CustomCoding<ArrayCoder<_ActionsEncoding, ObjectLambdaTransformationConfigurationAction>>
        public var actions: [ObjectLambdaTransformationConfigurationAction]
        /// A container for the content transformation of an Object Lambda Access Point configuration.
        public let contentTransformation: ObjectLambdaContentTransformation

        public init(actions: [ObjectLambdaTransformationConfigurationAction], contentTransformation: ObjectLambdaContentTransformation) {
            self.actions = actions
            self.contentTransformation = contentTransformation
        }

        public func validate(name: String) throws {
            try self.contentTransformation.validate(name: "\(name).contentTransformation")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "Actions"
            case contentTransformation = "ContentTransformation"
        }
    }

    public struct PolicyStatus: AWSDecodableShape {
        public let isPublic: Bool?

        public init(isPublic: Bool? = nil) {
            self.isPublic = isPublic
        }

        private enum CodingKeys: String, CodingKey {
            case isPublic = "IsPublic"
        }
    }

    public struct PrefixLevel: AWSEncodableShape & AWSDecodableShape {
        /// A container for the prefix-level storage metrics for S3 Storage Lens.
        public let storageMetrics: PrefixLevelStorageMetrics

        public init(storageMetrics: PrefixLevelStorageMetrics) {
            self.storageMetrics = storageMetrics
        }

        public func validate(name: String) throws {
            try self.storageMetrics.validate(name: "\(name).storageMetrics")
        }

        private enum CodingKeys: String, CodingKey {
            case storageMetrics = "StorageMetrics"
        }
    }

    public struct PrefixLevelStorageMetrics: AWSEncodableShape & AWSDecodableShape {
        /// A container for whether prefix-level storage metrics are enabled.
        public let isEnabled: Bool?
        public let selectionCriteria: SelectionCriteria?

        public init(isEnabled: Bool? = nil, selectionCriteria: SelectionCriteria? = nil) {
            self.isEnabled = isEnabled
            self.selectionCriteria = selectionCriteria
        }

        public func validate(name: String) throws {
            try self.selectionCriteria?.validate(name: "\(name).selectionCriteria")
        }

        private enum CodingKeys: String, CodingKey {
            case isEnabled = "IsEnabled"
            case selectionCriteria = "SelectionCriteria"
        }
    }

    public struct PublicAccessBlockConfiguration: AWSEncodableShape & AWSDecodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"

        /// Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:   PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.   PUT Object calls fail if the request includes a public ACL.   PUT Bucket calls fail if the request includes a public ACL.   Enabling this setting doesn't affect existing policies or ACLs. This is not supported for Amazon S3 on Outposts.
        public let blockPublicAcls: Bool?
        /// Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.  Enabling this setting doesn't affect existing bucket policies. This is not supported for Amazon S3 on Outposts.
        public let blockPublicPolicy: Bool?
        /// Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain.  Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set. This is not supported for Amazon S3 on Outposts.
        public let ignorePublicAcls: Bool?
        /// Specifies whether Amazon S3 should restrict public bucket policies for buckets in this account. Setting this element to TRUE restricts access to buckets with public policies to only Amazon Web Service principals and authorized users within this account. Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked. This is not supported for Amazon S3 on Outposts.
        public let restrictPublicBuckets: Bool?

        public init(blockPublicAcls: Bool? = nil, blockPublicPolicy: Bool? = nil, ignorePublicAcls: Bool? = nil, restrictPublicBuckets: Bool? = nil) {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }

        private enum CodingKeys: String, CodingKey {
            case blockPublicAcls = "BlockPublicAcls"
            case blockPublicPolicy = "BlockPublicPolicy"
            case ignorePublicAcls = "IgnorePublicAcls"
            case restrictPublicBuckets = "RestrictPublicBuckets"
        }
    }

    public struct PutAccessPointConfigurationForObjectLambdaRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// Object Lambda Access Point configuration document.
        public let configuration: ObjectLambdaConfiguration
        /// The name of the Object Lambda Access Point.
        public let name: String

        public init(accountId: String, configuration: ObjectLambdaConfiguration, name: String) {
            self.accountId = accountId
            self.configuration = configuration
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
        }
    }

    public struct PutAccessPointPolicyForObjectLambdaRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for the account that owns the specified Object Lambda Access Point.
        public let accountId: String
        /// The name of the Object Lambda Access Point.
        public let name: String
        /// Object Lambda Access Point resource policy document.
        public let policy: String

        public init(accountId: String, name: String, policy: String) {
            self.accountId = accountId
            self.name = name
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 45)
            try self.validate(self.name, name: "name", parent: name, min: 3)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-z0-9]([a-z0-9\\-]*[a-z0-9])?$")
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutAccessPointPolicyRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "name", location: .uri(locationName: "name"))
        ]

        /// The account ID for owner of the bucket associated with the specified access point.
        public let accountId: String
        /// The name of the access point that you want to associate with the specified policy. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the access point accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/accesspoint/&lt;my-accesspoint-name&gt;. For example, to access the access point reports-ap through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap. The value must be URL encoded.
        public let name: String
        /// The policy that you want to apply to the specified access point. For more information about access point policies, see Managing data access with Amazon S3 access points in the Amazon S3 User Guide.
        public let policy: String

        public init(accountId: String, name: String, policy: String) {
            self.accountId = accountId
            self.name = name
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutBucketLifecycleConfigurationRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "lifecycleConfiguration"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "lifecycleConfiguration", location: .body(locationName: "LifecycleConfiguration"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// The name of the bucket for which to set the configuration.
        public let bucket: String
        /// Container for lifecycle rules. You can add as many as 1,000 rules.
        public let lifecycleConfiguration: LifecycleConfiguration?

        public init(accountId: String, bucket: String, lifecycleConfiguration: LifecycleConfiguration? = nil) {
            self.accountId = accountId
            self.bucket = bucket
            self.lifecycleConfiguration = lifecycleConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.lifecycleConfiguration?.validate(name: "\(name).lifecycleConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case lifecycleConfiguration = "LifecycleConfiguration"
        }
    }

    public struct PutBucketPolicyRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "confirmRemoveSelfBucketAccess", location: .header(locationName: "x-amz-confirm-remove-self-bucket-access"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// Specifies the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String
        /// Set this parameter to true to confirm that you want to remove your permissions to change this bucket policy in the future.  This is not supported by Amazon S3 on Outposts buckets.
        public let confirmRemoveSelfBucketAccess: Bool?
        /// The bucket policy as a JSON document.
        public let policy: String

        public init(accountId: String, bucket: String, confirmRemoveSelfBucketAccess: Bool? = nil, policy: String) {
            self.accountId = accountId
            self.bucket = bucket
            self.confirmRemoveSelfBucketAccess = confirmRemoveSelfBucketAccess
            self.policy = policy
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "Policy"
        }
    }

    public struct PutBucketTaggingRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "tagging"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "bucket", location: .uri(locationName: "name")),
            AWSMemberEncoding(label: "tagging", location: .body(locationName: "Tagging"))
        ]

        /// The account ID of the Outposts bucket.
        public let accountId: String
        /// The Amazon Resource Name (ARN) of the bucket. For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well. For using this parameter with S3 on Outposts with the Amazon Web Services SDK and CLI, you must specify the ARN of the bucket accessed in the format arn:aws:s3-outposts:&lt;Region&gt;:&lt;account-id&gt;:outpost/&lt;outpost-id&gt;/bucket/&lt;my-bucket-name&gt;. For example, to access the bucket reports through outpost my-outpost owned by account 123456789012 in Region us-west-2, use the URL encoding of arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports. The value must be URL encoded.
        public let bucket: String
        public let tagging: Tagging

        public init(accountId: String, bucket: String, tagging: Tagging) {
            self.accountId = accountId
            self.bucket = bucket
            self.tagging = tagging
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.bucket, name: "bucket", parent: name, max: 255)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 3)
            try self.tagging.validate(name: "\(name).tagging")
        }

        private enum CodingKeys: String, CodingKey {
            case tagging = "Tagging"
        }
    }

    public struct PutJobTaggingRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id"))
        ]

        /// The account ID associated with the S3 Batch Operations job.
        public let accountId: String
        /// The ID for the S3 Batch Operations job whose tags you want to replace.
        public let jobId: String
        /// The set of tags to associate with the S3 Batch Operations job.
        @CustomCoding<StandardArrayCoder>
        public var tags: [S3Tag]

        public init(accountId: String, jobId: String, tags: [S3Tag]) {
            self.accountId = accountId
            self.jobId = jobId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 5)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct PutJobTaggingResult: AWSDecodableShape {
        public init() {}
    }

    public struct PutPublicAccessBlockRequest: AWSEncodableShape & AWSShapeWithPayload {
        /// The key for the payload
        public static let _payloadPath: String = "publicAccessBlockConfiguration"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "publicAccessBlockConfiguration", location: .body(locationName: "PublicAccessBlockConfiguration"))
        ]

        /// The account ID for the account whose PublicAccessBlock configuration you want to set.
        public let accountId: String
        /// The PublicAccessBlock configuration that you want to apply to the specified account.
        public let publicAccessBlockConfiguration: PublicAccessBlockConfiguration

        public init(accountId: String, publicAccessBlockConfiguration: PublicAccessBlockConfiguration) {
            self.accountId = accountId
            self.publicAccessBlockConfiguration = publicAccessBlockConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        }
    }

    public struct PutStorageLensConfigurationRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "storagelensid"))
        ]
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The account ID of the requester.
        public let accountId: String
        /// The ID of the S3 Storage Lens configuration.
        public let configId: String
        /// The S3 Storage Lens configuration.
        public let storageLensConfiguration: StorageLensConfiguration
        /// The tag set of the S3 Storage Lens configuration.  You can set up to a maximum of 50 tags.
        @OptionalCustomCoding<ArrayCoder<_TagsEncoding, StorageLensTag>>
        public var tags: [StorageLensTag]?

        public init(accountId: String, configId: String, storageLensConfiguration: StorageLensConfiguration, tags: [StorageLensTag]? = nil) {
            self.accountId = accountId
            self.configId = configId
            self.storageLensConfiguration = storageLensConfiguration
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.configId, name: "configId", parent: name, max: 64)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "[a-zA-Z0-9\\-\\_\\.]+")
            try self.storageLensConfiguration.validate(name: "\(name).storageLensConfiguration")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case storageLensConfiguration = "StorageLensConfiguration"
            case tags = "Tags"
        }
    }

    public struct PutStorageLensConfigurationTaggingRequest: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "configId", location: .uri(locationName: "storagelensid"))
        ]
        public struct _TagsEncoding: ArrayCoderProperties { public static let member = "Tag" }

        /// The account ID of the requester.
        public let accountId: String
        /// The ID of the S3 Storage Lens configuration.
        public let configId: String
        /// The tag set of the S3 Storage Lens configuration.  You can set up to a maximum of 50 tags.
        @CustomCoding<ArrayCoder<_TagsEncoding, StorageLensTag>>
        public var tags: [StorageLensTag]

        public init(accountId: String, configId: String, tags: [StorageLensTag]) {
            self.accountId = accountId
            self.configId = configId
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.configId, name: "configId", parent: name, max: 64)
            try self.validate(self.configId, name: "configId", parent: name, min: 1)
            try self.validate(self.configId, name: "configId", parent: name, pattern: "[a-zA-Z0-9\\-\\_\\.]+")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct PutStorageLensConfigurationTaggingResult: AWSDecodableShape {
        public init() {}
    }

    public struct RegionalBucket: AWSDecodableShape {
        public let bucket: String
        /// The Amazon Resource Name (ARN) for the regional bucket.
        public let bucketArn: String?
        /// The creation date of the regional bucket
        public let creationDate: Date
        /// The Outposts ID of the regional bucket.
        public let outpostId: String?
        public let publicAccessBlockEnabled: Bool

        public init(bucket: String, bucketArn: String? = nil, creationDate: Date, outpostId: String? = nil, publicAccessBlockEnabled: Bool) {
            self.bucket = bucket
            self.bucketArn = bucketArn
            self.creationDate = creationDate
            self.outpostId = outpostId
            self.publicAccessBlockEnabled = publicAccessBlockEnabled
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "Bucket"
            case bucketArn = "BucketArn"
            case creationDate = "CreationDate"
            case outpostId = "OutpostId"
            case publicAccessBlockEnabled = "PublicAccessBlockEnabled"
        }
    }

    public struct S3AccessControlList: AWSEncodableShape & AWSDecodableShape {
        @OptionalCustomCoding<StandardArrayCoder>
        public var grants: [S3Grant]?
        public let owner: S3ObjectOwner

        public init(grants: [S3Grant]? = nil, owner: S3ObjectOwner) {
            self.grants = grants
            self.owner = owner
        }

        public func validate(name: String) throws {
            try self.grants?.forEach {
                try $0.validate(name: "\(name).grants[]")
            }
            try self.owner.validate(name: "\(name).owner")
        }

        private enum CodingKeys: String, CodingKey {
            case grants = "Grants"
            case owner = "Owner"
        }
    }

    public struct S3AccessControlPolicy: AWSEncodableShape & AWSDecodableShape {
        public let accessControlList: S3AccessControlList?
        public let cannedAccessControlList: S3CannedAccessControlList?

        public init(accessControlList: S3AccessControlList? = nil, cannedAccessControlList: S3CannedAccessControlList? = nil) {
            self.accessControlList = accessControlList
            self.cannedAccessControlList = cannedAccessControlList
        }

        public func validate(name: String) throws {
            try self.accessControlList?.validate(name: "\(name).accessControlList")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlList = "AccessControlList"
            case cannedAccessControlList = "CannedAccessControlList"
        }
    }

    public struct S3BucketDestination: AWSEncodableShape & AWSDecodableShape {
        /// The account ID of the owner of the S3 Storage Lens metrics export bucket.
        public let accountId: String
        /// The Amazon Resource Name (ARN) of the bucket. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:bucket/your-destination-bucket-name
        public let arn: String
        /// The container for the type encryption of the metrics exports in this bucket.
        public let encryption: StorageLensDataExportEncryption?
        public let format: Format
        /// The schema version of the export file.
        public let outputSchemaVersion: OutputSchemaVersion
        /// The prefix of the destination bucket where the metrics export will be delivered.
        public let prefix: String?

        public init(accountId: String, arn: String, encryption: StorageLensDataExportEncryption? = nil, format: Format, outputSchemaVersion: OutputSchemaVersion, prefix: String? = nil) {
            self.accountId = accountId
            self.arn = arn
            self.encryption = encryption
            self.format = format
            self.outputSchemaVersion = outputSchemaVersion
            self.prefix = prefix
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.arn, name: "arn", parent: name, max: 128)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "arn:[^:]+:s3:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "AccountId"
            case arn = "Arn"
            case encryption = "Encryption"
            case format = "Format"
            case outputSchemaVersion = "OutputSchemaVersion"
            case prefix = "Prefix"
        }
    }

    public struct S3CopyObjectOperation: AWSEncodableShape & AWSDecodableShape {
        @OptionalCustomCoding<StandardArrayCoder>
        public var accessControlGrants: [S3Grant]?
        /// Specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side encryption using Amazon Web Services KMS (SSE-KMS). Setting this header to true causes Amazon S3 to use an S3 Bucket Key for object encryption with SSE-KMS. Specifying this header with an object action doesn’t affect bucket-level settings for S3 Bucket Key.
        public let bucketKeyEnabled: Bool?
        public let cannedAccessControlList: S3CannedAccessControlList?
        public let metadataDirective: S3MetadataDirective?
        public let modifiedSinceConstraint: Date?
        public let newObjectMetadata: S3ObjectMetadata?
        @OptionalCustomCoding<StandardArrayCoder>
        public var newObjectTagging: [S3Tag]?
        /// The legal hold status to be applied to all objects in the Batch Operations job.
        public let objectLockLegalHoldStatus: S3ObjectLockLegalHoldStatus?
        /// The retention mode to be applied to all objects in the Batch Operations job.
        public let objectLockMode: S3ObjectLockMode?
        /// The date when the applied object retention configuration expires on all objects in the Batch Operations job.
        public let objectLockRetainUntilDate: Date?
        /// Specifies an optional metadata property for website redirects, x-amz-website-redirect-location. Allows webpage redirects if the object is accessed through a website endpoint.
        public let redirectLocation: String?
        public let requesterPays: Bool?
        public let sSEAwsKmsKeyId: String?
        public let storageClass: S3StorageClass?
        /// Specifies the folder prefix into which you would like the objects to be copied. For example, to copy objects into a folder named "Folder1" in the destination bucket, set the TargetKeyPrefix to "Folder1/".
        public let targetKeyPrefix: String?
        /// Specifies the destination bucket ARN for the batch copy operation. For example, to copy objects to a bucket named "destinationBucket", set the TargetResource to "arn:aws:s3:::destinationBucket".
        public let targetResource: String?
        public let unModifiedSinceConstraint: Date?

        public init(accessControlGrants: [S3Grant]? = nil, bucketKeyEnabled: Bool? = nil, cannedAccessControlList: S3CannedAccessControlList? = nil, metadataDirective: S3MetadataDirective? = nil, modifiedSinceConstraint: Date? = nil, newObjectMetadata: S3ObjectMetadata? = nil, newObjectTagging: [S3Tag]? = nil, objectLockLegalHoldStatus: S3ObjectLockLegalHoldStatus? = nil, objectLockMode: S3ObjectLockMode? = nil, objectLockRetainUntilDate: Date? = nil, redirectLocation: String? = nil, requesterPays: Bool? = nil, sSEAwsKmsKeyId: String? = nil, storageClass: S3StorageClass? = nil, targetKeyPrefix: String? = nil, targetResource: String? = nil, unModifiedSinceConstraint: Date? = nil) {
            self.accessControlGrants = accessControlGrants
            self.bucketKeyEnabled = bucketKeyEnabled
            self.cannedAccessControlList = cannedAccessControlList
            self.metadataDirective = metadataDirective
            self.modifiedSinceConstraint = modifiedSinceConstraint
            self.newObjectMetadata = newObjectMetadata
            self.newObjectTagging = newObjectTagging
            self.objectLockLegalHoldStatus = objectLockLegalHoldStatus
            self.objectLockMode = objectLockMode
            self.objectLockRetainUntilDate = objectLockRetainUntilDate
            self.redirectLocation = redirectLocation
            self.requesterPays = requesterPays
            self.sSEAwsKmsKeyId = sSEAwsKmsKeyId
            self.storageClass = storageClass
            self.targetKeyPrefix = targetKeyPrefix
            self.targetResource = targetResource
            self.unModifiedSinceConstraint = unModifiedSinceConstraint
        }

        public func validate(name: String) throws {
            try self.accessControlGrants?.forEach {
                try $0.validate(name: "\(name).accessControlGrants[]")
            }
            try self.newObjectMetadata?.validate(name: "\(name).newObjectMetadata")
            try self.newObjectTagging?.forEach {
                try $0.validate(name: "\(name).newObjectTagging[]")
            }
            try self.validate(self.redirectLocation, name: "redirectLocation", parent: name, max: 2048)
            try self.validate(self.redirectLocation, name: "redirectLocation", parent: name, min: 1)
            try self.validate(self.sSEAwsKmsKeyId, name: "sSEAwsKmsKeyId", parent: name, max: 2000)
            try self.validate(self.sSEAwsKmsKeyId, name: "sSEAwsKmsKeyId", parent: name, min: 1)
            try self.validate(self.targetKeyPrefix, name: "targetKeyPrefix", parent: name, max: 1024)
            try self.validate(self.targetKeyPrefix, name: "targetKeyPrefix", parent: name, min: 1)
            try self.validate(self.targetResource, name: "targetResource", parent: name, max: 128)
            try self.validate(self.targetResource, name: "targetResource", parent: name, min: 1)
            try self.validate(self.targetResource, name: "targetResource", parent: name, pattern: "arn:[^:]+:s3:.*")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlGrants = "AccessControlGrants"
            case bucketKeyEnabled = "BucketKeyEnabled"
            case cannedAccessControlList = "CannedAccessControlList"
            case metadataDirective = "MetadataDirective"
            case modifiedSinceConstraint = "ModifiedSinceConstraint"
            case newObjectMetadata = "NewObjectMetadata"
            case newObjectTagging = "NewObjectTagging"
            case objectLockLegalHoldStatus = "ObjectLockLegalHoldStatus"
            case objectLockMode = "ObjectLockMode"
            case objectLockRetainUntilDate = "ObjectLockRetainUntilDate"
            case redirectLocation = "RedirectLocation"
            case requesterPays = "RequesterPays"
            case sSEAwsKmsKeyId = "SSEAwsKmsKeyId"
            case storageClass = "StorageClass"
            case targetKeyPrefix = "TargetKeyPrefix"
            case targetResource = "TargetResource"
            case unModifiedSinceConstraint = "UnModifiedSinceConstraint"
        }
    }

    public struct S3DeleteObjectTaggingOperation: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct S3Grant: AWSEncodableShape & AWSDecodableShape {
        public let grantee: S3Grantee?
        public let permission: S3Permission?

        public init(grantee: S3Grantee? = nil, permission: S3Permission? = nil) {
            self.grantee = grantee
            self.permission = permission
        }

        public func validate(name: String) throws {
            try self.grantee?.validate(name: "\(name).grantee")
        }

        private enum CodingKeys: String, CodingKey {
            case grantee = "Grantee"
            case permission = "Permission"
        }
    }

    public struct S3Grantee: AWSEncodableShape & AWSDecodableShape {
        public let displayName: String?
        public let identifier: String?
        public let typeIdentifier: S3GranteeTypeIdentifier?

        public init(displayName: String? = nil, identifier: String? = nil, typeIdentifier: S3GranteeTypeIdentifier? = nil) {
            self.displayName = displayName
            self.identifier = identifier
            self.typeIdentifier = typeIdentifier
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1024)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.identifier, name: "identifier", parent: name, max: 1024)
            try self.validate(self.identifier, name: "identifier", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case identifier = "Identifier"
            case typeIdentifier = "TypeIdentifier"
        }
    }

    public struct S3InitiateRestoreObjectOperation: AWSEncodableShape & AWSDecodableShape {
        /// This argument specifies how long the S3 Glacier or S3 Glacier Deep Archive object remains available in Amazon S3. S3 Initiate Restore Object jobs that target S3 Glacier and S3 Glacier Deep Archive objects require ExpirationInDays set to 1 or greater. Conversely, do not set ExpirationInDays when creating S3 Initiate Restore Object jobs that target S3 Intelligent-Tiering Archive Access and Deep Archive Access tier objects. Objects in S3 Intelligent-Tiering archive access tiers are not subject to restore expiry, so specifying ExpirationInDays results in restore request failure. S3 Batch Operations jobs can operate either on S3 Glacier and S3 Glacier Deep Archive storage class objects or on S3 Intelligent-Tiering Archive Access and Deep Archive Access storage tier objects, but not both types in the same job. If you need to restore objects of both types you must create separate Batch Operations jobs.
        public let expirationInDays: Int?
        /// S3 Batch Operations supports STANDARD and BULK retrieval tiers, but not the EXPEDITED retrieval tier.
        public let glacierJobTier: S3GlacierJobTier?

        public init(expirationInDays: Int? = nil, glacierJobTier: S3GlacierJobTier? = nil) {
            self.expirationInDays = expirationInDays
            self.glacierJobTier = glacierJobTier
        }

        public func validate(name: String) throws {
            try self.validate(self.expirationInDays, name: "expirationInDays", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case expirationInDays = "ExpirationInDays"
            case glacierJobTier = "GlacierJobTier"
        }
    }

    public struct S3ObjectLockLegalHold: AWSEncodableShape & AWSDecodableShape {
        /// The Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        public let status: S3ObjectLockLegalHoldStatus

        public init(status: S3ObjectLockLegalHoldStatus) {
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case status = "Status"
        }
    }

    public struct S3ObjectMetadata: AWSEncodableShape & AWSDecodableShape {
        public let cacheControl: String?
        public let contentDisposition: String?
        public let contentEncoding: String?
        public let contentLanguage: String?
        public let contentLength: Int64?
        public let contentMD5: String?
        public let contentType: String?
        public let httpExpiresDate: Date?
        public let requesterCharged: Bool?
        public let sSEAlgorithm: S3SSEAlgorithm?
        @OptionalCustomCoding<StandardDictionaryCoder>
        public var userMetadata: [String: String]?

        public init(cacheControl: String? = nil, contentDisposition: String? = nil, contentEncoding: String? = nil, contentLanguage: String? = nil, contentLength: Int64? = nil, contentMD5: String? = nil, contentType: String? = nil, httpExpiresDate: Date? = nil, requesterCharged: Bool? = nil, sSEAlgorithm: S3SSEAlgorithm? = nil, userMetadata: [String: String]? = nil) {
            self.cacheControl = cacheControl
            self.contentDisposition = contentDisposition
            self.contentEncoding = contentEncoding
            self.contentLanguage = contentLanguage
            self.contentLength = contentLength
            self.contentMD5 = contentMD5
            self.contentType = contentType
            self.httpExpiresDate = httpExpiresDate
            self.requesterCharged = requesterCharged
            self.sSEAlgorithm = sSEAlgorithm
            self.userMetadata = userMetadata
        }

        public func validate(name: String) throws {
            try self.validate(self.cacheControl, name: "cacheControl", parent: name, max: 1024)
            try self.validate(self.cacheControl, name: "cacheControl", parent: name, min: 1)
            try self.validate(self.contentDisposition, name: "contentDisposition", parent: name, max: 1024)
            try self.validate(self.contentDisposition, name: "contentDisposition", parent: name, min: 1)
            try self.validate(self.contentEncoding, name: "contentEncoding", parent: name, max: 1024)
            try self.validate(self.contentEncoding, name: "contentEncoding", parent: name, min: 1)
            try self.validate(self.contentLanguage, name: "contentLanguage", parent: name, max: 1024)
            try self.validate(self.contentLanguage, name: "contentLanguage", parent: name, min: 1)
            try self.validate(self.contentLength, name: "contentLength", parent: name, min: 0)
            try self.validate(self.contentMD5, name: "contentMD5", parent: name, max: 1024)
            try self.validate(self.contentMD5, name: "contentMD5", parent: name, min: 1)
            try self.validate(self.contentType, name: "contentType", parent: name, max: 1024)
            try self.validate(self.contentType, name: "contentType", parent: name, min: 1)
            try self.userMetadata?.forEach {
                try validate($0.key, name: "userMetadata.key", parent: name, max: 1024)
                try validate($0.key, name: "userMetadata.key", parent: name, min: 1)
                try validate($0.value, name: "userMetadata[\"\($0.key)\"]", parent: name, max: 1024)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case cacheControl = "CacheControl"
            case contentDisposition = "ContentDisposition"
            case contentEncoding = "ContentEncoding"
            case contentLanguage = "ContentLanguage"
            case contentLength = "ContentLength"
            case contentMD5 = "ContentMD5"
            case contentType = "ContentType"
            case httpExpiresDate = "HttpExpiresDate"
            case requesterCharged = "RequesterCharged"
            case sSEAlgorithm = "SSEAlgorithm"
            case userMetadata = "UserMetadata"
        }
    }

    public struct S3ObjectOwner: AWSEncodableShape & AWSDecodableShape {
        public let displayName: String?
        public let id: String?

        public init(displayName: String? = nil, id: String? = nil) {
            self.displayName = displayName
            self.id = id
        }

        public func validate(name: String) throws {
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1024)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, max: 1024)
            try self.validate(self.id, name: "id", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case displayName = "DisplayName"
            case id = "ID"
        }
    }

    public struct S3Retention: AWSEncodableShape & AWSDecodableShape {
        /// The Object Lock retention mode to be applied to all objects in the Batch Operations job.
        public let mode: S3ObjectLockRetentionMode?
        /// The date when the applied Object Lock retention will expire on all objects set by the Batch Operations job.
        public let retainUntilDate: Date?

        public init(mode: S3ObjectLockRetentionMode? = nil, retainUntilDate: Date? = nil) {
            self.mode = mode
            self.retainUntilDate = retainUntilDate
        }

        private enum CodingKeys: String, CodingKey {
            case mode = "Mode"
            case retainUntilDate = "RetainUntilDate"
        }
    }

    public struct S3SetObjectAclOperation: AWSEncodableShape & AWSDecodableShape {
        public let accessControlPolicy: S3AccessControlPolicy?

        public init(accessControlPolicy: S3AccessControlPolicy? = nil) {
            self.accessControlPolicy = accessControlPolicy
        }

        public func validate(name: String) throws {
            try self.accessControlPolicy?.validate(name: "\(name).accessControlPolicy")
        }

        private enum CodingKeys: String, CodingKey {
            case accessControlPolicy = "AccessControlPolicy"
        }
    }

    public struct S3SetObjectLegalHoldOperation: AWSEncodableShape & AWSDecodableShape {
        /// Contains the Object Lock legal hold status to be applied to all objects in the Batch Operations job.
        public let legalHold: S3ObjectLockLegalHold

        public init(legalHold: S3ObjectLockLegalHold) {
            self.legalHold = legalHold
        }

        private enum CodingKeys: String, CodingKey {
            case legalHold = "LegalHold"
        }
    }

    public struct S3SetObjectRetentionOperation: AWSEncodableShape & AWSDecodableShape {
        /// Indicates if the action should be applied to objects in the Batch Operations job even if they have Object Lock  GOVERNANCE type in place.
        public let bypassGovernanceRetention: Bool?
        /// Contains the Object Lock retention mode to be applied to all objects in the Batch Operations job. For more information, see Using S3 Object Lock retention with S3 Batch Operations in the Amazon S3 User Guide.
        public let retention: S3Retention

        public init(bypassGovernanceRetention: Bool? = nil, retention: S3Retention) {
            self.bypassGovernanceRetention = bypassGovernanceRetention
            self.retention = retention
        }

        private enum CodingKeys: String, CodingKey {
            case bypassGovernanceRetention = "BypassGovernanceRetention"
            case retention = "Retention"
        }
    }

    public struct S3SetObjectTaggingOperation: AWSEncodableShape & AWSDecodableShape {
        @OptionalCustomCoding<StandardArrayCoder>
        public var tagSet: [S3Tag]?

        public init(tagSet: [S3Tag]? = nil) {
            self.tagSet = tagSet
        }

        public func validate(name: String) throws {
            try self.tagSet?.forEach {
                try $0.validate(name: "\(name).tagSet[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tagSet = "TagSet"
        }
    }

    public struct S3Tag: AWSEncodableShape & AWSDecodableShape {
        public let key: String
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct SSEKMS: AWSEncodableShape & AWSDecodableShape {
        /// A container for the ARN of the SSE-KMS encryption. This property is read-only and follows the following format:  arn:aws:kms:us-east-1:example-account-id:key/example-9a73-4afc-8d29-8f5900cef44e
        public let keyId: String

        public init(keyId: String) {
            self.keyId = keyId
        }

        private enum CodingKeys: String, CodingKey {
            case keyId = "KeyId"
        }
    }

    public struct SSES3: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct SelectionCriteria: AWSEncodableShape & AWSDecodableShape {
        /// A container for the delimiter of the selection criteria being used.
        public let delimiter: String?
        /// The max depth of the selection criteria
        public let maxDepth: Int?
        /// The minimum number of storage bytes percentage whose metrics will be selected.  You must choose a value greater than or equal to 1.0.
        public let minStorageBytesPercentage: Double?

        public init(delimiter: String? = nil, maxDepth: Int? = nil, minStorageBytesPercentage: Double? = nil) {
            self.delimiter = delimiter
            self.maxDepth = maxDepth
            self.minStorageBytesPercentage = minStorageBytesPercentage
        }

        public func validate(name: String) throws {
            try self.validate(self.delimiter, name: "delimiter", parent: name, max: 1)
            try self.validate(self.maxDepth, name: "maxDepth", parent: name, max: 10)
            try self.validate(self.maxDepth, name: "maxDepth", parent: name, min: 1)
            try self.validate(self.minStorageBytesPercentage, name: "minStorageBytesPercentage", parent: name, max: 100)
            try self.validate(self.minStorageBytesPercentage, name: "minStorageBytesPercentage", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case delimiter = "Delimiter"
            case maxDepth = "MaxDepth"
            case minStorageBytesPercentage = "MinStorageBytesPercentage"
        }
    }

    public struct StorageLensAwsOrg: AWSEncodableShape & AWSDecodableShape {
        /// A container for the Amazon Resource Name (ARN) of the Amazon Web Services organization. This property is read-only and follows the following format:  arn:aws:organizations:us-east-1:example-account-id:organization/o-ex2l495dck
        public let arn: String

        public init(arn: String) {
            self.arn = arn
        }

        public func validate(name: String) throws {
            try self.validate(self.arn, name: "arn", parent: name, max: 1024)
            try self.validate(self.arn, name: "arn", parent: name, min: 1)
            try self.validate(self.arn, name: "arn", parent: name, pattern: "arn:[a-z\\-]+:organizations::\\d{12}:organization\\/o-[a-z0-9]{10,32}")
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
        }
    }

    public struct StorageLensConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A container for all the account-level configurations of your S3 Storage Lens configuration.
        public let accountLevel: AccountLevel
        /// A container for the Amazon Web Services organization for this S3 Storage Lens configuration.
        public let awsOrg: StorageLensAwsOrg?
        /// A container to specify the properties of your S3 Storage Lens metrics export including, the destination, schema and format.
        public let dataExport: StorageLensDataExport?
        /// A container for what is excluded in this configuration. This container can only be valid if there is no Include container submitted, and it's not empty.
        public let exclude: Exclude?
        /// A container for the Amazon S3 Storage Lens configuration ID.
        public let id: String
        /// A container for what is included in this configuration. This container can only be valid if there is no Exclude container submitted, and it's not empty.
        public let include: Include?
        /// A container for whether the S3 Storage Lens configuration is enabled.
        public let isEnabled: Bool
        /// The Amazon Resource Name (ARN) of the S3 Storage Lens configuration. This property is read-only and follows the following format:  arn:aws:s3:us-east-1:example-account-id:storage-lens/your-dashboard-name
        public let storageLensArn: String?

        public init(accountLevel: AccountLevel, awsOrg: StorageLensAwsOrg? = nil, dataExport: StorageLensDataExport? = nil, exclude: Exclude? = nil, id: String, include: Include? = nil, isEnabled: Bool, storageLensArn: String? = nil) {
            self.accountLevel = accountLevel
            self.awsOrg = awsOrg
            self.dataExport = dataExport
            self.exclude = exclude
            self.id = id
            self.include = include
            self.isEnabled = isEnabled
            self.storageLensArn = storageLensArn
        }

        public func validate(name: String) throws {
            try self.accountLevel.validate(name: "\(name).accountLevel")
            try self.awsOrg?.validate(name: "\(name).awsOrg")
            try self.dataExport?.validate(name: "\(name).dataExport")
            try self.exclude?.validate(name: "\(name).exclude")
            try self.validate(self.id, name: "id", parent: name, max: 64)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "[a-zA-Z0-9\\-\\_\\.]+")
            try self.include?.validate(name: "\(name).include")
            try self.validate(self.storageLensArn, name: "storageLensArn", parent: name, max: 1024)
            try self.validate(self.storageLensArn, name: "storageLensArn", parent: name, min: 1)
            try self.validate(self.storageLensArn, name: "storageLensArn", parent: name, pattern: "arn:[a-z\\-]+:s3:[a-z0-9\\-]+:\\d{12}:storage\\-lens\\/.*")
        }

        private enum CodingKeys: String, CodingKey {
            case accountLevel = "AccountLevel"
            case awsOrg = "AwsOrg"
            case dataExport = "DataExport"
            case exclude = "Exclude"
            case id = "Id"
            case include = "Include"
            case isEnabled = "IsEnabled"
            case storageLensArn = "StorageLensArn"
        }
    }

    public struct StorageLensDataExport: AWSEncodableShape & AWSDecodableShape {
        /// A container for the bucket where the S3 Storage Lens metrics export will be located.  This bucket must be located in the same Region as the storage lens configuration.
        public let s3BucketDestination: S3BucketDestination

        public init(s3BucketDestination: S3BucketDestination) {
            self.s3BucketDestination = s3BucketDestination
        }

        public func validate(name: String) throws {
            try self.s3BucketDestination.validate(name: "\(name).s3BucketDestination")
        }

        private enum CodingKeys: String, CodingKey {
            case s3BucketDestination = "S3BucketDestination"
        }
    }

    public struct StorageLensDataExportEncryption: AWSEncodableShape & AWSDecodableShape {
        public let ssekms: SSEKMS?
        public let sses3: SSES3?

        public init(ssekms: SSEKMS? = nil, sses3: SSES3? = nil) {
            self.ssekms = ssekms
            self.sses3 = sses3
        }

        private enum CodingKeys: String, CodingKey {
            case ssekms = "SSE-KMS"
            case sses3 = "SSE-S3"
        }
    }

    public struct StorageLensTag: AWSEncodableShape & AWSDecodableShape {
        public let key: String
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 1024)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct Tagging: AWSEncodableShape {
        public static let _xmlNamespace: String? = "http://awss3control.amazonaws.com/doc/2018-08-20/"

        /// A collection for a set of tags.
        @CustomCoding<StandardArrayCoder>
        public var tagSet: [S3Tag]

        public init(tagSet: [S3Tag]) {
            self.tagSet = tagSet
        }

        public func validate(name: String) throws {
            try self.tagSet.forEach {
                try $0.validate(name: "\(name).tagSet[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tagSet = "TagSet"
        }
    }

    public struct Transition: AWSEncodableShape & AWSDecodableShape {
        /// Indicates when objects are transitioned to the specified storage class. The date value must be in ISO 8601 format. The time is always midnight UTC.
        public let date: Date?
        /// Indicates the number of days after creation when objects are transitioned to the specified storage class. The value must be a positive integer.
        public let days: Int?
        /// The storage class to which you want the object to transition.
        public let storageClass: TransitionStorageClass?

        public init(date: Date? = nil, days: Int? = nil, storageClass: TransitionStorageClass? = nil) {
            self.date = date
            self.days = days
            self.storageClass = storageClass
        }

        private enum CodingKeys: String, CodingKey {
            case date = "Date"
            case days = "Days"
            case storageClass = "StorageClass"
        }
    }

    public struct UpdateJobPriorityRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id")),
            AWSMemberEncoding(label: "priority", location: .querystring(locationName: "priority"))
        ]

        /// The account ID associated with the S3 Batch Operations job.
        public let accountId: String
        /// The ID for the job whose priority you want to update.
        public let jobId: String
        /// The priority you want to assign to this job.
        public let priority: Int

        public init(accountId: String, jobId: String, priority: Int) {
            self.accountId = accountId
            self.jobId = jobId
            self.priority = priority
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 5)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
            try self.validate(self.priority, name: "priority", parent: name, max: 2_147_483_647)
            try self.validate(self.priority, name: "priority", parent: name, min: 0)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateJobPriorityResult: AWSDecodableShape {
        /// The ID for the job whose priority Amazon S3 updated.
        public let jobId: String
        /// The new priority assigned to the specified job.
        public let priority: Int

        public init(jobId: String, priority: Int) {
            self.jobId = jobId
            self.priority = priority
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case priority = "Priority"
        }
    }

    public struct UpdateJobStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "accountId", location: .header(locationName: "x-amz-account-id")),
            AWSMemberEncoding(label: "accountId", location: .uri(locationName: "AccountId")),
            AWSMemberEncoding(label: "jobId", location: .uri(locationName: "id")),
            AWSMemberEncoding(label: "requestedJobStatus", location: .querystring(locationName: "requestedJobStatus")),
            AWSMemberEncoding(label: "statusUpdateReason", location: .querystring(locationName: "statusUpdateReason"))
        ]

        /// The account ID associated with the S3 Batch Operations job.
        public let accountId: String
        /// The ID of the job whose status you want to update.
        public let jobId: String
        /// The status that you want to move the specified job to.
        public let requestedJobStatus: RequestedJobStatus
        /// A description of the reason why you want to change the specified job's status. This field can be any string up to the maximum length.
        public let statusUpdateReason: String?

        public init(accountId: String, jobId: String, requestedJobStatus: RequestedJobStatus, statusUpdateReason: String? = nil) {
            self.accountId = accountId
            self.jobId = jobId
            self.requestedJobStatus = requestedJobStatus
            self.statusUpdateReason = statusUpdateReason
        }

        public func validate(name: String) throws {
            try self.validate(self.accountId, name: "accountId", parent: name, max: 64)
            try self.validate(self.accountId, name: "accountId", parent: name, pattern: "^\\d{12}$")
            try self.validate(self.jobId, name: "jobId", parent: name, max: 36)
            try self.validate(self.jobId, name: "jobId", parent: name, min: 5)
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "[a-zA-Z0-9\\-\\_]+")
            try self.validate(self.statusUpdateReason, name: "statusUpdateReason", parent: name, max: 256)
            try self.validate(self.statusUpdateReason, name: "statusUpdateReason", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UpdateJobStatusResult: AWSDecodableShape {
        /// The ID for the job whose status was updated.
        public let jobId: String?
        /// The current status for the specified job.
        public let status: JobStatus?
        /// The reason that the specified job's status was updated.
        public let statusUpdateReason: String?

        public init(jobId: String? = nil, status: JobStatus? = nil, statusUpdateReason: String? = nil) {
            self.jobId = jobId
            self.status = status
            self.statusUpdateReason = statusUpdateReason
        }

        private enum CodingKeys: String, CodingKey {
            case jobId = "JobId"
            case status = "Status"
            case statusUpdateReason = "StatusUpdateReason"
        }
    }

    public struct VpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        public let vpcId: String

        public init(vpcId: String) {
            self.vpcId = vpcId
        }

        public func validate(name: String) throws {
            try self.validate(self.vpcId, name: "vpcId", parent: name, max: 1024)
            try self.validate(self.vpcId, name: "vpcId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case vpcId = "VpcId"
        }
    }
}
