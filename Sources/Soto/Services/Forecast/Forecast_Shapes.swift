//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension Forecast {
    // MARK: Enums

    public enum AttributeType: String, CustomStringConvertible, Codable {
        case float
        case geolocation
        case integer
        case string
        case timestamp
        public var description: String { return self.rawValue }
    }

    public enum AutoMLOverrideStrategy: String, CustomStringConvertible, Codable {
        case latencyoptimized = "LatencyOptimized"
        public var description: String { return self.rawValue }
    }

    public enum DatasetType: String, CustomStringConvertible, Codable {
        case itemMetadata = "ITEM_METADATA"
        case relatedTimeSeries = "RELATED_TIME_SERIES"
        case targetTimeSeries = "TARGET_TIME_SERIES"
        public var description: String { return self.rawValue }
    }

    public enum Domain: String, CustomStringConvertible, Codable {
        case custom = "CUSTOM"
        case ec2Capacity = "EC2_CAPACITY"
        case inventoryPlanning = "INVENTORY_PLANNING"
        case metrics = "METRICS"
        case retail = "RETAIL"
        case webTraffic = "WEB_TRAFFIC"
        case workForce = "WORK_FORCE"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationType: String, CustomStringConvertible, Codable {
        case computed = "COMPUTED"
        case summary = "SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum FeaturizationMethodName: String, CustomStringConvertible, Codable {
        case filling
        public var description: String { return self.rawValue }
    }

    public enum FilterConditionString: String, CustomStringConvertible, Codable {
        case `is` = "IS"
        case isNot = "IS_NOT"
        public var description: String { return self.rawValue }
    }

    public enum ScalingType: String, CustomStringConvertible, Codable {
        case auto = "Auto"
        case linear = "Linear"
        case logarithmic = "Logarithmic"
        case reverselogarithmic = "ReverseLogarithmic"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct CategoricalParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The name of the categorical hyperparameter to tune.
        public let name: String
        /// A list of the tunable categories for the hyperparameter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ContinuousParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum tunable value of the hyperparameter.
        public let maxValue: Double
        /// The minimum tunable value of the hyperparameter.
        public let minValue: Double
        /// The name of the hyperparameter to tune.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:  Auto  Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0.  ReverseLogarithmic  hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0    For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:
        public let scalingType: ScalingType?

        public init(maxValue: Double, minValue: Double, name: String, scalingType: ScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct CreateDatasetGroupRequest: AWSEncodableShape {
        /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset group.
        public let datasetArns: [String]?
        /// A name for the dataset group.
        public let datasetGroupName: String
        /// The domain associated with the dataset group. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the CreateDataset operation must match. The Domain and DatasetType that you choose determine the fields that must be present in training data that you import to a dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires that item_id, timestamp, and demand fields are present in your data. For more information, see howitworks-datasets-groups.
        public let domain: Domain
        /// The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?

        public init(datasetArns: [String]? = nil, datasetGroupName: String, domain: Domain, tags: [Tag]? = nil) {
            self.datasetArns = datasetArns
            self.datasetGroupName = datasetGroupName
            self.domain = domain
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.datasetArns?.forEach {
                try validate($0, name: "datasetArns[]", parent: name, max: 256)
                try validate($0, name: "datasetArns[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            }
            try self.validate(self.datasetGroupName, name: "datasetGroupName", parent: name, max: 63)
            try self.validate(self.datasetGroupName, name: "datasetGroupName", parent: name, min: 1)
            try self.validate(self.datasetGroupName, name: "datasetGroupName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArns = "DatasetArns"
            case datasetGroupName = "DatasetGroupName"
            case domain = "Domain"
            case tags = "Tags"
        }
    }

    public struct CreateDatasetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?

        public init(datasetGroupArn: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct CreateDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data to.
        public let datasetArn: String
        /// The name for the dataset import job. We recommend including the current timestamp in the name, for example, 20190721DatasetImport. This can help you avoid getting a ResourceAlreadyExistsException exception.
        public let datasetImportJobName: String
        /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource must include an AWS Key Management Service (KMS) key and the IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must match those specified in the EncryptionConfig parameter of the CreateDataset operation.
        public let dataSource: DataSource
        /// The format of the geolocation attribute. The geolocation attribute can be formatted in one of two ways:    LAT_LONG - the latitude and longitude in decimal format (Example: 47.61_-122.33).    CC_POSTALCODE (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).
        public let geolocationFormat: String?
        /// The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?
        /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported   "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D   "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D   If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd HH:mm:ss".
        public let timestampFormat: String?
        /// A single time zone for every item in your dataset. This option is ideal for datasets with all timestamps within a single time zone, or if all timestamps are normalized to a single time zone.  Refer to the Joda-Time API for a complete list of valid time zone names.
        public let timeZone: String?
        /// Automatically derive time zone information from the geolocation attribute. This option is ideal for datasets that contain timestamps in multiple time zones and those timestamps are expressed in local time.
        public let useGeolocationForTimeZone: Bool?

        public init(datasetArn: String, datasetImportJobName: String, dataSource: DataSource, geolocationFormat: String? = nil, tags: [Tag]? = nil, timestampFormat: String? = nil, timeZone: String? = nil, useGeolocationForTimeZone: Bool? = nil) {
            self.datasetArn = datasetArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSource = dataSource
            self.geolocationFormat = geolocationFormat
            self.tags = tags
            self.timestampFormat = timestampFormat
            self.timeZone = timeZone
            self.useGeolocationForTimeZone = useGeolocationForTimeZone
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.validate(self.datasetImportJobName, name: "datasetImportJobName", parent: name, max: 63)
            try self.validate(self.datasetImportJobName, name: "datasetImportJobName", parent: name, min: 1)
            try self.validate(self.datasetImportJobName, name: "datasetImportJobName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.geolocationFormat, name: "geolocationFormat", parent: name, max: 256)
            try self.validate(self.geolocationFormat, name: "geolocationFormat", parent: name, pattern: "^[a-zA-Z0-9_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.timestampFormat, name: "timestampFormat", parent: name, max: 256)
            try self.validate(self.timestampFormat, name: "timestampFormat", parent: name, pattern: "^[a-zA-Z0-9\\-\\:\\.\\,\\'\\s]+$")
            try self.validate(self.timeZone, name: "timeZone", parent: name, max: 256)
            try self.validate(self.timeZone, name: "timeZone", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\-\\_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSource = "DataSource"
            case geolocationFormat = "GeolocationFormat"
            case tags = "Tags"
            case timestampFormat = "TimestampFormat"
            case timeZone = "TimeZone"
            case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
        }
    }

    public struct CreateDatasetImportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?

        public init(datasetImportJobArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// The frequency of data collection. This parameter is required for RELATED_TIME_SERIES datasets. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "D" indicates every day and "15min" indicates every 15 minutes.
        public let dataFrequency: String?
        /// A name for the dataset.
        public let datasetName: String
        /// The dataset type. Valid values depend on the chosen Domain.
        public let datasetType: DatasetType
        /// The domain associated with the dataset. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the CreateDatasetGroup operation must match. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see howitworks-datasets-groups.
        public let domain: Domain
        /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// The schema for the dataset. The schema attributes and their order must match the fields in your data. The dataset Domain and DatasetType that you choose determine the minimum required fields in your training data. For information about the required fields for a specific dataset domain and type, see howitworks-domains-ds-types.
        public let schema: Schema
        /// The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?

        public init(dataFrequency: String? = nil, datasetName: String, datasetType: DatasetType, domain: Domain, encryptionConfig: EncryptionConfig? = nil, schema: Schema, tags: [Tag]? = nil) {
            self.dataFrequency = dataFrequency
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.encryptionConfig = encryptionConfig
            self.schema = schema
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.dataFrequency, name: "dataFrequency", parent: name, pattern: "^Y|M|W|D|H|30min|15min|10min|5min|1min$")
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 63)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.datasetName, name: "datasetName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
            try self.schema.validate(name: "\(name).schema")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case dataFrequency = "DataFrequency"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case encryptionConfig = "EncryptionConfig"
            case schema = "Schema"
            case tags = "Tags"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct CreateForecastExportJobRequest: AWSEncodableShape {
        /// The location where you want to save the forecast and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an AWS Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
        public let destination: DataDestination
        /// The Amazon Resource Name (ARN) of the forecast that you want to export.
        public let forecastArn: String
        /// The name for the forecast export job.
        public let forecastExportJobName: String
        /// The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?

        public init(destination: DataDestination, forecastArn: String, forecastExportJobName: String, tags: [Tag]? = nil) {
            self.destination = destination
            self.forecastArn = forecastArn
            self.forecastExportJobName = forecastExportJobName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, max: 256)
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.validate(self.forecastExportJobName, name: "forecastExportJobName", parent: name, max: 63)
            try self.validate(self.forecastExportJobName, name: "forecastExportJobName", parent: name, min: 1)
            try self.validate(self.forecastExportJobName, name: "forecastExportJobName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case forecastArn = "ForecastArn"
            case forecastExportJobName = "ForecastExportJobName"
            case tags = "Tags"
        }
    }

    public struct CreateForecastExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the export job.
        public let forecastExportJobArn: String?

        public init(forecastExportJobArn: String? = nil) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct CreateForecastRequest: AWSEncodableShape {
        /// A name for the forecast.
        public let forecastName: String
        /// The quantiles at which probabilistic forecasts are generated. You can currently specify up to 5 quantiles per forecast. Accepted values include 0.01 to 0.99 (increments of .01 only) and mean. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial). The default value is ["0.1", "0.5", "0.9"].
        public let forecastTypes: [String]?
        /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
        public let predictorArn: String
        /// The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?

        public init(forecastName: String, forecastTypes: [String]? = nil, predictorArn: String, tags: [Tag]? = nil) {
            self.forecastName = forecastName
            self.forecastTypes = forecastTypes
            self.predictorArn = predictorArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastName, name: "forecastName", parent: name, max: 63)
            try self.validate(self.forecastName, name: "forecastName", parent: name, min: 1)
            try self.validate(self.forecastName, name: "forecastName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.forecastTypes?.forEach {
                try validate($0, name: "forecastTypes[]", parent: name, pattern: "^(^0?\\.\\d\\d?$|^mean$)$")
            }
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, max: 20)
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, min: 1)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case forecastName = "ForecastName"
            case forecastTypes = "ForecastTypes"
            case predictorArn = "PredictorArn"
            case tags = "Tags"
        }
    }

    public struct CreateForecastResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the forecast.
        public let forecastArn: String?

        public init(forecastArn: String? = nil) {
            self.forecastArn = forecastArn
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct CreatePredictorBacktestExportJobRequest: AWSEncodableShape {
        public let destination: DataDestination
        /// The Amazon Resource Name (ARN) of the predictor that you want to export.
        public let predictorArn: String
        /// The name for the backtest export job.
        public let predictorBacktestExportJobName: String
        /// Optional metadata to help you categorize and organize your backtests. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:   For each resource, each tag key must be unique and each tag key must have one value.   Maximum number of tags per resource: 50.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.    Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
        public let tags: [Tag]?

        public init(destination: DataDestination, predictorArn: String, predictorBacktestExportJobName: String, tags: [Tag]? = nil) {
            self.destination = destination
            self.predictorArn = predictorArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.validate(self.predictorBacktestExportJobName, name: "predictorBacktestExportJobName", parent: name, max: 63)
            try self.validate(self.predictorBacktestExportJobName, name: "predictorBacktestExportJobName", parent: name, min: 1)
            try self.validate(self.predictorBacktestExportJobName, name: "predictorBacktestExportJobName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case predictorArn = "PredictorArn"
            case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
            case tags = "Tags"
        }
    }

    public struct CreatePredictorBacktestExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the predictor backtest export job that you want to export.
        public let predictorBacktestExportJobArn: String?

        public init(predictorBacktestExportJobArn: String? = nil) {
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        }
    }

    public struct CreatePredictorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if PerformAutoML is not set to true.  Supported algorithms:     arn:aws:forecast:::algorithm/ARIMA     arn:aws:forecast:::algorithm/CNN-QR     arn:aws:forecast:::algorithm/Deep_AR_Plus     arn:aws:forecast:::algorithm/ETS     arn:aws:forecast:::algorithm/NPTS     arn:aws:forecast:::algorithm/Prophet
        public let algorithmArn: String?
        /// Used to overide the default AutoML strategy, which is to optimize predictor accuracy. To apply an AutoML strategy that minimizes training time, use LatencyOptimized. This parameter is only valid for predictors trained using AutoML.
        public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
        /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
        public let evaluationParameters: EvaluationParameters?
        /// The featurization configuration.
        public let featurizationConfig: FeaturizationConfig
        /// Specifies the number of time-steps that the model is trained to predict. The forecast horizon is also called the prediction length. For example, if you configure a dataset for daily data collection (using the DataFrequency parameter of the CreateDataset operation) and set the forecast horizon to 10, the model returns predictions for 10 days. The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length.
        public let forecastHorizon: Int
        /// Specifies the forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify  the mean forecast with mean.  The default value is ["0.10", "0.50", "0.9"].
        public let forecastTypes: [String]?
        /// Provides hyperparameter override values for the algorithm. If you don't provide this parameter, Amazon Forecast uses default values. The individual algorithms specify which hyperparameters support hyperparameter optimization (HPO). For more information, see aws-forecast-choosing-recipes. If you included the HPOConfig object, you must set PerformHPO to true.
        public let hPOConfig: HyperParameterTuningJobConfig?
        /// Describes the dataset group that contains the data to use to train the predictor.
        public let inputDataConfig: InputDataConfig
        /// Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it provides and chooses the best algorithm and configuration for your training dataset. The default value is false. In this case, you are required to specify an algorithm. Set PerformAutoML to true to have Amazon Forecast perform AutoML. This is a good option if you aren't sure which algorithm is suitable for your training data. In this case, PerformHPO must be false.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter values for your training data. The process of performing HPO is known as running a hyperparameter tuning job. The default value is false. In this case, Amazon Forecast uses default hyperparameter values from the chosen algorithm. To override the default values, set PerformHPO to true and, optionally, supply the HyperParameterTuningJobConfig object. The tuning job specifies a metric to optimize, which hyperparameters participate in tuning, and the valid range for each tunable hyperparameter. In this case, you are required to specify an algorithm and PerformAutoML must be false. The following algorithms support HPO:   DeepAR+   CNN-QR
        public let performHPO: Bool?
        /// A name for the predictor.
        public let predictorName: String
        /// The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?
        /// The hyperparameters to override for model training. The hyperparameters that you can override are listed in the individual algorithms. For the list of supported algorithms, see aws-forecast-choosing-recipes.
        public let trainingParameters: [String: String]?

        public init(algorithmArn: String? = nil, autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil, encryptionConfig: EncryptionConfig? = nil, evaluationParameters: EvaluationParameters? = nil, featurizationConfig: FeaturizationConfig, forecastHorizon: Int, forecastTypes: [String]? = nil, hPOConfig: HyperParameterTuningJobConfig? = nil, inputDataConfig: InputDataConfig, performAutoML: Bool? = nil, performHPO: Bool? = nil, predictorName: String, tags: [Tag]? = nil, trainingParameters: [String: String]? = nil) {
            self.algorithmArn = algorithmArn
            self.autoMLOverrideStrategy = autoMLOverrideStrategy
            self.encryptionConfig = encryptionConfig
            self.evaluationParameters = evaluationParameters
            self.featurizationConfig = featurizationConfig
            self.forecastHorizon = forecastHorizon
            self.forecastTypes = forecastTypes
            self.hPOConfig = hPOConfig
            self.inputDataConfig = inputDataConfig
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.predictorName = predictorName
            self.tags = tags
            self.trainingParameters = trainingParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, max: 256)
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
            try self.featurizationConfig.validate(name: "\(name).featurizationConfig")
            try self.forecastTypes?.forEach {
                try validate($0, name: "forecastTypes[]", parent: name, pattern: "^(^0?\\.\\d\\d?$|^mean$)$")
            }
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, max: 20)
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, min: 1)
            try self.hPOConfig?.validate(name: "\(name).hPOConfig")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.predictorName, name: "predictorName", parent: name, max: 63)
            try self.validate(self.predictorName, name: "predictorName", parent: name, min: 1)
            try self.validate(self.predictorName, name: "predictorName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.trainingParameters?.forEach {
                try validate($0.key, name: "trainingParameters.key", parent: name, max: 256)
                try validate($0.key, name: "trainingParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\\]+$")
                try validate($0.value, name: "trainingParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "trainingParameters[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\"\\\\\\s]+$")
            }
            try self.validate(self.trainingParameters, name: "trainingParameters", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
            case encryptionConfig = "EncryptionConfig"
            case evaluationParameters = "EvaluationParameters"
            case featurizationConfig = "FeaturizationConfig"
            case forecastHorizon = "ForecastHorizon"
            case forecastTypes = "ForecastTypes"
            case hPOConfig = "HPOConfig"
            case inputDataConfig = "InputDataConfig"
            case performAutoML = "PerformAutoML"
            case performHPO = "PerformHPO"
            case predictorName = "PredictorName"
            case tags = "Tags"
            case trainingParameters = "TrainingParameters"
        }
    }

    public struct CreatePredictorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the predictor.
        public let predictorArn: String?

        public init(predictorArn: String? = nil) {
            self.predictorArn = predictorArn
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DataDestination: AWSEncodableShape & AWSDecodableShape {
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.
        public let s3Config: S3Config

        public init(s3Config: S3Config) {
            self.s3Config = s3Config
        }

        public func validate(name: String) throws {
            try self.s3Config.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The path to the training data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.
        public let s3Config: S3Config

        public init(s3Config: S3Config) {
            self.s3Config = s3Config
        }

        public func validate(name: String) throws {
            try self.s3Config.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct DatasetGroupSummary: AWSDecodableShape {
        /// When the dataset group was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The name of the dataset group.
        public let datasetGroupName: String?
        /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated, LastModificationTime is the current time of the ListDatasetGroups call.
        public let lastModificationTime: Date?

        public init(creationTime: Date? = nil, datasetGroupArn: String? = nil, datasetGroupName: String? = nil, lastModificationTime: Date? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case datasetGroupName = "DatasetGroupName"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public struct DatasetImportJobSummary: AWSDecodableShape {
        /// When the dataset import job was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?
        /// The name of the dataset import job.
        public let datasetImportJobName: String?
        /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
        public let dataSource: DataSource?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the dataset import job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED
        public let status: String?

        public init(creationTime: Date? = nil, datasetImportJobArn: String? = nil, datasetImportJobName: String? = nil, dataSource: DataSource? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSource = dataSource
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetImportJobArn = "DatasetImportJobArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSource = "DataSource"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct DatasetSummary: AWSDecodableShape {
        /// When the dataset was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The dataset type.
        public let datasetType: DatasetType?
        /// The domain associated with the dataset.
        public let domain: Domain?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the ListDatasets call. After a CreateDatasetImportJob operation has finished, LastModificationTime is when the import job completed or failed.
        public let lastModificationTime: Date?

        public init(creationTime: Date? = nil, datasetArn: String? = nil, datasetName: String? = nil, datasetType: DatasetType? = nil, domain: Domain? = nil, lastModificationTime: Date? = nil) {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArn = "DatasetArn"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public struct DeleteDatasetGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group to delete.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct DeleteDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job to delete.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, max: 256)
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to delete.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct DeleteForecastExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast export job to delete.
        public let forecastExportJobArn: String

        public init(forecastExportJobArn: String) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, max: 256)
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct DeleteForecastRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast to delete.
        public let forecastArn: String

        public init(forecastArn: String) {
            self.forecastArn = forecastArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, max: 256)
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct DeletePredictorBacktestExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor backtest export job to delete.
        public let predictorBacktestExportJobArn: String

        public init(predictorBacktestExportJobArn: String) {
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, max: 256)
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        }
    }

    public struct DeletePredictorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor to delete.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DeleteResourceTreeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the parent resource to delete. All child resources of the parent resource will also be deleted.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct DescribeDatasetGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct DescribeDatasetGroupResponse: AWSDecodableShape {
        /// When the dataset group was created.
        public let creationTime: Date?
        /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset group.
        public let datasetArns: [String]?
        /// The ARN of the dataset group.
        public let datasetGroupArn: String?
        /// The name of the dataset group.
        public let datasetGroupName: String?
        /// The domain associated with the dataset group.
        public let domain: Domain?
        /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated, LastModificationTime is the current time of the DescribeDatasetGroup call.
        public let lastModificationTime: Date?
        /// The status of the dataset group. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED    The UPDATE states apply when you call the UpdateDatasetGroup operation.  The Status of the dataset group must be ACTIVE before you can use the dataset group to create a predictor.
        public let status: String?

        public init(creationTime: Date? = nil, datasetArns: [String]? = nil, datasetGroupArn: String? = nil, datasetGroupName: String? = nil, domain: Domain? = nil, lastModificationTime: Date? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetArns = datasetArns
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.domain = domain
            self.lastModificationTime = lastModificationTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArns = "DatasetArns"
            case datasetGroupArn = "DatasetGroupArn"
            case datasetGroupName = "DatasetGroupName"
            case domain = "Domain"
            case lastModificationTime = "LastModificationTime"
            case status = "Status"
        }
    }

    public struct DescribeDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, max: 256)
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct DescribeDatasetImportJobResponse: AWSDecodableShape {
        /// When the dataset import job was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset that the training data was imported to.
        public let datasetArn: String?
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?
        /// The name of the dataset import job.
        public let datasetImportJobName: String?
        /// The size of the dataset in gigabytes (GB) after the import job has finished.
        public let dataSize: Double?
        /// The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. If encryption is used, DataSource includes an AWS Key Management Service (KMS) key.
        public let dataSource: DataSource?
        /// The estimated time remaining in minutes for the dataset import job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// Statistical information about each field in the input data.
        public let fieldStatistics: [String: Statistics]?
        /// The format of the geolocation attribute. Valid Values:"LAT_LONG" and "CC_POSTALCODE".
        public let geolocationFormat: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the dataset import job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED
        public let status: String?
        /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported   "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D   "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
        public let timestampFormat: String?
        /// The single time zone applied to every item in the dataset
        public let timeZone: String?
        /// Whether TimeZone is automatically derived from the geolocation attribute.
        public let useGeolocationForTimeZone: Bool?

        public init(creationTime: Date? = nil, datasetArn: String? = nil, datasetImportJobArn: String? = nil, datasetImportJobName: String? = nil, dataSize: Double? = nil, dataSource: DataSource? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, fieldStatistics: [String: Statistics]? = nil, geolocationFormat: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, timestampFormat: String? = nil, timeZone: String? = nil, useGeolocationForTimeZone: Bool? = nil) {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSize = dataSize
            self.dataSource = dataSource
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.fieldStatistics = fieldStatistics
            self.geolocationFormat = geolocationFormat
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.timestampFormat = timestampFormat
            self.timeZone = timeZone
            self.useGeolocationForTimeZone = useGeolocationForTimeZone
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArn = "DatasetArn"
            case datasetImportJobArn = "DatasetImportJobArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSize = "DataSize"
            case dataSource = "DataSource"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case fieldStatistics = "FieldStatistics"
            case geolocationFormat = "GeolocationFormat"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case timestampFormat = "TimestampFormat"
            case timeZone = "TimeZone"
            case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// When the dataset was created.
        public let creationTime: Date?
        /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "M" indicates every month and "30min" indicates every 30 minutes.
        public let dataFrequency: String?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The dataset type.
        public let datasetType: DatasetType?
        /// The domain associated with the dataset.
        public let domain: Domain?
        /// The AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the DescribeDataset call. After a CreateDatasetImportJob operation has finished, LastModificationTime is when the import job completed or failed.
        public let lastModificationTime: Date?
        /// An array of SchemaAttribute objects that specify the dataset fields. Each SchemaAttribute specifies the name and data type of a field.
        public let schema: Schema?
        /// The status of the dataset. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED    The UPDATE states apply while data is imported to the dataset from a call to the CreateDatasetImportJob operation and reflect the status of the dataset import job. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS.  The Status of the dataset must be ACTIVE before you can import training data.
        public let status: String?

        public init(creationTime: Date? = nil, dataFrequency: String? = nil, datasetArn: String? = nil, datasetName: String? = nil, datasetType: DatasetType? = nil, domain: Domain? = nil, encryptionConfig: EncryptionConfig? = nil, lastModificationTime: Date? = nil, schema: Schema? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.dataFrequency = dataFrequency
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.encryptionConfig = encryptionConfig
            self.lastModificationTime = lastModificationTime
            self.schema = schema
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataFrequency = "DataFrequency"
            case datasetArn = "DatasetArn"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case encryptionConfig = "EncryptionConfig"
            case lastModificationTime = "LastModificationTime"
            case schema = "Schema"
            case status = "Status"
        }
    }

    public struct DescribeForecastExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public let forecastExportJobArn: String

        public init(forecastExportJobArn: String) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, max: 256)
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct DescribeForecastExportJobResponse: AWSDecodableShape {
        /// When the forecast export job was created.
        public let creationTime: Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the exported forecast.
        public let forecastArn: String?
        /// The ARN of the forecast export job.
        public let forecastExportJobArn: String?
        /// The name of the forecast export job.
        public let forecastExportJobName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the forecast export job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, forecastArn: String? = nil, forecastExportJobArn: String? = nil, forecastExportJobName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastArn = forecastArn
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case forecastArn = "ForecastArn"
            case forecastExportJobArn = "ForecastExportJobArn"
            case forecastExportJobName = "ForecastExportJobName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct DescribeForecastRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast.
        public let forecastArn: String

        public init(forecastArn: String) {
            self.forecastArn = forecastArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, max: 256)
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct DescribeForecastResponse: AWSDecodableShape {
        /// When the forecast creation task was created.
        public let creationTime: Date?
        /// The ARN of the dataset group that provided the data used to train the predictor.
        public let datasetGroupArn: String?
        /// The estimated time remaining in minutes for the forecast job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// The forecast ARN as specified in the request.
        public let forecastArn: String?
        /// The name of the forecast.
        public let forecastName: String?
        /// The quantiles at which probabilistic forecasts were generated.
        public let forecastTypes: [String]?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor used to generate the forecast.
        public let predictorArn: String?
        /// The status of the forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public let status: String?

        public init(creationTime: Date? = nil, datasetGroupArn: String? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, forecastArn: String? = nil, forecastName: String? = nil, forecastTypes: [String]? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.forecastTypes = forecastTypes
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case forecastArn = "ForecastArn"
            case forecastName = "ForecastName"
            case forecastTypes = "ForecastTypes"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case status = "Status"
        }
    }

    public struct DescribePredictorBacktestExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public let predictorBacktestExportJobArn: String

        public init(predictorBacktestExportJobArn: String) {
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, max: 256)
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        }
    }

    public struct DescribePredictorBacktestExportJobResponse: AWSDecodableShape {
        /// When the predictor backtest export job was created.
        public let creationTime: Date?
        public let destination: DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// Information about any errors that may have occurred during the backtest export.
        public let message: String?
        /// The Amazon Resource Name (ARN) of the predictor.
        public let predictorArn: String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public let predictorBacktestExportJobArn: String?
        /// The name of the predictor backtest export job.
        public let predictorBacktestExportJobName: String?
        /// The status of the predictor backtest export job. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, predictorBacktestExportJobArn: String? = nil, predictorBacktestExportJobName: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
            case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
            case status = "Status"
        }
    }

    public struct DescribePredictorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor that you want information about.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DescribePredictorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm used for model training.
        public let algorithmArn: String?
        /// When PerformAutoML is specified, the ARN of the chosen algorithm.
        public let autoMLAlgorithmArns: [String]?
        /// The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
        public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
        /// When the model training task was created.
        public let creationTime: Date?
        /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
        public let datasetImportJobArns: [String]?
        /// An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// The estimated time remaining in minutes for the predictor training job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
        public let evaluationParameters: EvaluationParameters?
        /// The featurization configuration.
        public let featurizationConfig: FeaturizationConfig?
        /// The number of time-steps of the forecast. The forecast horizon is also called the prediction length.
        public let forecastHorizon: Int?
        /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"]
        public let forecastTypes: [String]?
        /// The hyperparameter override values for the algorithm.
        public let hPOConfig: HyperParameterTuningJobConfig?
        /// Describes the dataset group that contains the data to use to train the predictor.
        public let inputDataConfig: InputDataConfig?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// Whether the predictor is set to perform AutoML.
        public let performAutoML: Bool?
        /// Whether the predictor is set to perform hyperparameter optimization (HPO).
        public let performHPO: Bool?
        /// The ARN of the predictor.
        public let predictorArn: String?
        /// Details on the the status and results of the backtests performed to evaluate the accuracy of the predictor. You specify the number of backtests to perform when you call the  operation.
        public let predictorExecutionDetails: PredictorExecutionDetails?
        /// The name of the predictor.
        public let predictorName: String?
        /// The status of the predictor. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED     The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public let status: String?
        /// The default training parameters or overrides selected during model training. When running AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen hyperparameters are returned. For more information, see aws-forecast-choosing-recipes.
        public let trainingParameters: [String: String]?

        public init(algorithmArn: String? = nil, autoMLAlgorithmArns: [String]? = nil, autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil, creationTime: Date? = nil, datasetImportJobArns: [String]? = nil, encryptionConfig: EncryptionConfig? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, evaluationParameters: EvaluationParameters? = nil, featurizationConfig: FeaturizationConfig? = nil, forecastHorizon: Int? = nil, forecastTypes: [String]? = nil, hPOConfig: HyperParameterTuningJobConfig? = nil, inputDataConfig: InputDataConfig? = nil, lastModificationTime: Date? = nil, message: String? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, predictorArn: String? = nil, predictorExecutionDetails: PredictorExecutionDetails? = nil, predictorName: String? = nil, status: String? = nil, trainingParameters: [String: String]? = nil) {
            self.algorithmArn = algorithmArn
            self.autoMLAlgorithmArns = autoMLAlgorithmArns
            self.autoMLOverrideStrategy = autoMLOverrideStrategy
            self.creationTime = creationTime
            self.datasetImportJobArns = datasetImportJobArns
            self.encryptionConfig = encryptionConfig
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.evaluationParameters = evaluationParameters
            self.featurizationConfig = featurizationConfig
            self.forecastHorizon = forecastHorizon
            self.forecastTypes = forecastTypes
            self.hPOConfig = hPOConfig
            self.inputDataConfig = inputDataConfig
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.predictorArn = predictorArn
            self.predictorExecutionDetails = predictorExecutionDetails
            self.predictorName = predictorName
            self.status = status
            self.trainingParameters = trainingParameters
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
            case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
            case creationTime = "CreationTime"
            case datasetImportJobArns = "DatasetImportJobArns"
            case encryptionConfig = "EncryptionConfig"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case evaluationParameters = "EvaluationParameters"
            case featurizationConfig = "FeaturizationConfig"
            case forecastHorizon = "ForecastHorizon"
            case forecastTypes = "ForecastTypes"
            case hPOConfig = "HPOConfig"
            case inputDataConfig = "InputDataConfig"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case performAutoML = "PerformAutoML"
            case performHPO = "PerformHPO"
            case predictorArn = "PredictorArn"
            case predictorExecutionDetails = "PredictorExecutionDetails"
            case predictorName = "PredictorName"
            case status = "Status"
            case trainingParameters = "TrainingParameters"
        }
    }

    public struct EncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key.
        public let kMSKeyArn: String
        /// The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        public let roleArn: String

        public init(kMSKeyArn: String, roleArn: String) {
            self.kMSKeyArn = kMSKeyArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kMSKeyArn, name: "kMSKeyArn", parent: name, max: 256)
            try self.validate(self.kMSKeyArn, name: "kMSKeyArn", parent: name, pattern: "^arn:aws:kms:.*:key/")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kMSKeyArn = "KMSKeyArn"
            case roleArn = "RoleArn"
        }
    }

    public struct ErrorMetric: AWSDecodableShape {
        ///  The Forecast type used to compute WAPE and RMSE.
        public let forecastType: String?
        ///  The root-mean-square error (RMSE).
        public let rmse: Double?
        ///  The weighted absolute percentage error (WAPE).
        public let wape: Double?

        public init(forecastType: String? = nil, rmse: Double? = nil, wape: Double? = nil) {
            self.forecastType = forecastType
            self.rmse = rmse
            self.wape = wape
        }

        private enum CodingKeys: String, CodingKey {
            case forecastType = "ForecastType"
            case rmse = "RMSE"
            case wape = "WAPE"
        }
    }

    public struct EvaluationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. BackTestWindowOffset can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length.  ForecastHorizon BackTestWindowOffset
        public let backTestWindowOffset: Int?
        /// The number of times to split the input data. The default is 1. Valid values are 1 through 5.
        public let numberOfBacktestWindows: Int?

        public init(backTestWindowOffset: Int? = nil, numberOfBacktestWindows: Int? = nil) {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }

        private enum CodingKeys: String, CodingKey {
            case backTestWindowOffset = "BackTestWindowOffset"
            case numberOfBacktestWindows = "NumberOfBacktestWindows"
        }
    }

    public struct EvaluationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public let algorithmArn: String?
        /// The array of test windows used for evaluating the algorithm. The NumberOfBacktestWindows from the EvaluationParameters object determines the number of windows in the array.
        public let testWindows: [WindowSummary]?

        public init(algorithmArn: String? = nil, testWindows: [WindowSummary]? = nil) {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case testWindows = "TestWindows"
        }
    }

    public struct Featurization: AWSEncodableShape & AWSDecodableShape {
        /// The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of  the TARGET_TIME_SERIES and the RELATED_TIME_SERIES datasets. For example, for the RETAIL domain, the target is demand, and for the CUSTOM domain, the target is target_value. For more information, see howitworks-missing-values.
        public let attributeName: String
        /// An array of one FeaturizationMethod object that specifies the feature transformation method.
        public let featurizationPipeline: [FeaturizationMethod]?

        public init(attributeName: String, featurizationPipeline: [FeaturizationMethod]? = nil) {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 63)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.featurizationPipeline?.forEach {
                try $0.validate(name: "\(name).featurizationPipeline[]")
            }
            try self.validate(self.featurizationPipeline, name: "featurizationPipeline", parent: name, max: 1)
            try self.validate(self.featurizationPipeline, name: "featurizationPipeline", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case featurizationPipeline = "FeaturizationPipeline"
        }
    }

    public struct FeaturizationConfig: AWSEncodableShape & AWSDecodableShape {
        /// An array of featurization (transformation) information for the fields of a dataset.
        public let featurizations: [Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a store_id field. If you want the sales forecast for each item by store, you would specify store_id as the dimension. All forecast dimensions specified in the TARGET_TIME_SERIES dataset don't need to be specified in the CreatePredictor request. All forecast dimensions specified in the RELATED_TIME_SERIES dataset must be specified in the CreatePredictor request.
        public let forecastDimensions: [String]?
        /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes. The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
        public let forecastFrequency: String

        public init(featurizations: [Featurization]? = nil, forecastDimensions: [String]? = nil, forecastFrequency: String) {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }

        public func validate(name: String) throws {
            try self.featurizations?.forEach {
                try $0.validate(name: "\(name).featurizations[]")
            }
            try self.validate(self.featurizations, name: "featurizations", parent: name, max: 50)
            try self.validate(self.featurizations, name: "featurizations", parent: name, min: 1)
            try self.forecastDimensions?.forEach {
                try validate($0, name: "forecastDimensions[]", parent: name, max: 63)
                try validate($0, name: "forecastDimensions[]", parent: name, min: 1)
                try validate($0, name: "forecastDimensions[]", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            }
            try self.validate(self.forecastDimensions, name: "forecastDimensions", parent: name, max: 5)
            try self.validate(self.forecastDimensions, name: "forecastDimensions", parent: name, min: 1)
            try self.validate(self.forecastFrequency, name: "forecastFrequency", parent: name, pattern: "^Y|M|W|D|H|30min|15min|10min|5min|1min$")
        }

        private enum CodingKeys: String, CodingKey {
            case featurizations = "Featurizations"
            case forecastDimensions = "ForecastDimensions"
            case forecastFrequency = "ForecastFrequency"
        }
    }

    public struct FeaturizationMethod: AWSEncodableShape & AWSDecodableShape {
        /// The name of the method. The "filling" method is the only supported method.
        public let featurizationMethodName: FeaturizationMethodName
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values.  Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Bold signifies the default value.    aggregation: sum, avg, first, min, max     frontfill: none     middlefill: zero, nan (not a number), value, median, mean, min, max     backfill: zero, nan, value, median, mean, min, max
        ///  The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):    middlefill: zero, value, median, mean, min, max     backfill: zero, value, median, mean, min, max     futurefill: zero, value, median, mean, min, max    To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        public let featurizationMethodParameters: [String: String]?

        public init(featurizationMethodName: FeaturizationMethodName, featurizationMethodParameters: [String: String]? = nil) {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }

        public func validate(name: String) throws {
            try self.featurizationMethodParameters?.forEach {
                try validate($0.key, name: "featurizationMethodParameters.key", parent: name, max: 256)
                try validate($0.key, name: "featurizationMethodParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\\]+$")
                try validate($0.value, name: "featurizationMethodParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "featurizationMethodParameters[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\"\\\\\\s]+$")
            }
            try self.validate(self.featurizationMethodParameters, name: "featurizationMethodParameters", parent: name, max: 20)
            try self.validate(self.featurizationMethodParameters, name: "featurizationMethodParameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case featurizationMethodName = "FeaturizationMethodName"
            case featurizationMethodParameters = "FeaturizationMethodParameters"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The condition to apply. To include the objects that match the statement, specify IS. To exclude matching objects, specify IS_NOT.
        public let condition: FilterConditionString
        /// The name of the parameter to filter on.
        public let key: String
        /// The value to match.
        public let value: String

        public init(condition: FilterConditionString, key: String, value: String) {
            self.condition = condition
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 256)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9\\_]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ForecastExportJobSummary: AWSDecodableShape {
        /// When the forecast export job was created.
        public let creationTime: Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public let forecastExportJobArn: String?
        /// The name of the forecast export job.
        public let forecastExportJobName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the forecast export job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, forecastExportJobArn: String? = nil, forecastExportJobName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case forecastExportJobArn = "ForecastExportJobArn"
            case forecastExportJobName = "ForecastExportJobName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct ForecastSummary: AWSDecodableShape {
        /// When the forecast creation task was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.
        public let datasetGroupArn: String?
        /// The ARN of the forecast.
        public let forecastArn: String?
        /// The name of the forecast.
        public let forecastName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor used to generate the forecast.
        public let predictorArn: String?
        /// The status of the forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public let status: String?

        public init(creationTime: Date? = nil, datasetGroupArn: String? = nil, forecastArn: String? = nil, forecastName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case forecastArn = "ForecastArn"
            case forecastName = "ForecastName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case status = "Status"
        }
    }

    public struct GetAccuracyMetricsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct GetAccuracyMetricsResponse: AWSDecodableShape {
        /// The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
        public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
        /// An array of results from evaluating the predictor.
        public let predictorEvaluationResults: [EvaluationResult]?

        public init(autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil, predictorEvaluationResults: [EvaluationResult]? = nil) {
            self.autoMLOverrideStrategy = autoMLOverrideStrategy
            self.predictorEvaluationResults = predictorEvaluationResults
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
            case predictorEvaluationResults = "PredictorEvaluationResults"
        }
    }

    public struct HyperParameterTuningJobConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the ranges of valid values for the hyperparameters.
        public let parameterRanges: ParameterRanges?

        public init(parameterRanges: ParameterRanges? = nil) {
            self.parameterRanges = parameterRanges
        }

        public func validate(name: String) throws {
            try self.parameterRanges?.validate(name: "\(name).parameterRanges")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterRanges = "ParameterRanges"
        }
    }

    public struct InputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String
        /// An array of supplementary features. The only supported feature is a holiday calendar.
        public let supplementaryFeatures: [SupplementaryFeature]?

        public init(datasetGroupArn: String, supplementaryFeatures: [SupplementaryFeature]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.supplementaryFeatures?.forEach {
                try $0.validate(name: "\(name).supplementaryFeatures[]")
            }
            try self.validate(self.supplementaryFeatures, name: "supplementaryFeatures", parent: name, max: 2)
            try self.validate(self.supplementaryFeatures, name: "supplementaryFeatures", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
            case supplementaryFeatures = "SupplementaryFeatures"
        }
    }

    public struct IntegerParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum tunable value of the hyperparameter.
        public let maxValue: Int
        /// The minimum tunable value of the hyperparameter.
        public let minValue: Int
        /// The name of the hyperparameter to tune.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:  Auto  Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0.  ReverseLogarithmic  Not supported for IntegerParameterRange. Reverse logarithmic scaling works only for ranges that are entirely within the range 0    For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:
        public let scalingType: ScalingType?

        public init(maxValue: Int, minValue: Int, name: String, scalingType: ScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct ListDatasetGroupsRequest: AWSEncodableShape {
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetGroupsResponse: AWSDecodableShape {
        /// An array of objects that summarize each dataset group's properties.
        public let datasetGroups: [DatasetGroupSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasetGroups: [DatasetGroupSummary]? = nil, nextToken: String? = nil) {
            self.datasetGroups = datasetGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroups = "DatasetGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetImportJobsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the datasets that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the datasets that match the statement, specify IS. To exclude matching datasets, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are DatasetArn and Status.    Value - The value to match.   For example, to list all dataset import jobs whose status is ACTIVE, you specify the following filter:  "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetImportJobsResponse: AWSDecodableShape {
        /// An array of objects that summarize each dataset import job's properties.
        public let datasetImportJobs: [DatasetImportJobSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasetImportJobs: [DatasetImportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetImportJobs = datasetImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobs = "DatasetImportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// An array of objects that summarize each dataset's properties.
        public let datasets: [DatasetSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasets: [DatasetSummary]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "Datasets"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastExportJobsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are ForecastArn and Status.    Value - The value to match.   For example, to list all jobs that export a forecast named electricityforecast, specify the following filter:  "Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityforecast" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastExportJobsResponse: AWSDecodableShape {
        /// An array of objects that summarize each export job's properties.
        public let forecastExportJobs: [ForecastExportJobSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(forecastExportJobs: [ForecastExportJobSummary]? = nil, nextToken: String? = nil) {
            self.forecastExportJobs = forecastExportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobs = "ForecastExportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecasts that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecasts that match the statement, specify IS. To exclude matching forecasts, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are DatasetGroupArn, PredictorArn, and Status.    Value - The value to match.   For example, to list all forecasts whose status is not ACTIVE, you would specify:  "Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastsResponse: AWSDecodableShape {
        /// An array of objects that summarize each forecast's properties.
        public let forecasts: [ForecastSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(forecasts: [ForecastSummary]? = nil, nextToken: String? = nil) {
            self.forecasts = forecasts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case forecasts = "Forecasts"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorBacktestExportJobsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictor backtest export jobs that match the statement from the list. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictor backtest export jobs that match the statement, specify IS. To exclude matching predictor backtest export jobs, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.    Value - The value to match.
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorBacktestExportJobsResponse: AWSDecodableShape {
        /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// An array of objects that summarize the properties of each predictor backtest export job.
        public let predictorBacktestExportJobs: [PredictorBacktestExportJobSummary]?

        public init(nextToken: String? = nil, predictorBacktestExportJobs: [PredictorBacktestExportJobSummary]? = nil) {
            self.nextToken = nextToken
            self.predictorBacktestExportJobs = predictorBacktestExportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case predictorBacktestExportJobs = "PredictorBacktestExportJobs"
        }
    }

    public struct ListPredictorsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictors that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictors that match the statement, specify IS. To exclude matching predictors, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are DatasetGroupArn and Status.    Value - The value to match.   For example, to list all predictors whose status is ACTIVE, you would specify:  "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// An array of objects that summarize each predictor's properties.
        public let predictors: [PredictorSummary]?

        public init(nextToken: String? = nil, predictors: [PredictorSummary]? = nil) {
            self.nextToken = nextToken
            self.predictors = predictors
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case predictors = "Predictors"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct Metrics: AWSDecodableShape {
        ///  Provides detailed error metrics on forecast type, root-mean square-error (RMSE), and weighted average percentage error (WAPE).
        public let errorMetrics: [ErrorMetric]?
        /// The root-mean-square error (RMSE).
        public let rmse: Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.
        public let weightedQuantileLosses: [WeightedQuantileLoss]?

        public init(errorMetrics: [ErrorMetric]? = nil, rmse: Double? = nil, weightedQuantileLosses: [WeightedQuantileLoss]? = nil) {
            self.errorMetrics = errorMetrics
            self.rmse = rmse
            self.weightedQuantileLosses = weightedQuantileLosses
        }

        private enum CodingKeys: String, CodingKey {
            case errorMetrics = "ErrorMetrics"
            case rmse = "RMSE"
            case weightedQuantileLosses = "WeightedQuantileLosses"
        }
    }

    public struct ParameterRanges: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the tunable range for each categorical hyperparameter.
        public let categoricalParameterRanges: [CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public let continuousParameterRanges: [ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public let integerParameterRanges: [IntegerParameterRange]?

        public init(categoricalParameterRanges: [CategoricalParameterRange]? = nil, continuousParameterRanges: [ContinuousParameterRange]? = nil, integerParameterRanges: [IntegerParameterRange]? = nil) {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalParameterRanges[]")
            }
            try self.validate(self.categoricalParameterRanges, name: "categoricalParameterRanges", parent: name, max: 20)
            try self.validate(self.categoricalParameterRanges, name: "categoricalParameterRanges", parent: name, min: 1)
            try self.continuousParameterRanges?.forEach {
                try $0.validate(name: "\(name).continuousParameterRanges[]")
            }
            try self.validate(self.continuousParameterRanges, name: "continuousParameterRanges", parent: name, max: 20)
            try self.validate(self.continuousParameterRanges, name: "continuousParameterRanges", parent: name, min: 1)
            try self.integerParameterRanges?.forEach {
                try $0.validate(name: "\(name).integerParameterRanges[]")
            }
            try self.validate(self.integerParameterRanges, name: "integerParameterRanges", parent: name, max: 20)
            try self.validate(self.integerParameterRanges, name: "integerParameterRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalParameterRanges = "CategoricalParameterRanges"
            case continuousParameterRanges = "ContinuousParameterRanges"
            case integerParameterRanges = "IntegerParameterRanges"
        }
    }

    public struct PredictorBacktestExportJobSummary: AWSDecodableShape {
        /// When the predictor backtest export job was created.
        public let creationTime: Date?
        public let destination: DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// Information about any errors that may have occurred during the backtest export.
        public let message: String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public let predictorBacktestExportJobArn: String?
        /// The name of the predictor backtest export job.
        public let predictorBacktestExportJobName: String?
        /// The status of the predictor backtest export job. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorBacktestExportJobArn: String? = nil, predictorBacktestExportJobName: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
            case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
            case status = "Status"
        }
    }

    public struct PredictorExecution: AWSDecodableShape {
        /// The ARN of the algorithm used to test the predictor.
        public let algorithmArn: String?
        /// An array of test windows used to evaluate the algorithm. The NumberOfBacktestWindows from the  object determines the number of windows in the array.
        public let testWindows: [TestWindowSummary]?

        public init(algorithmArn: String? = nil, testWindows: [TestWindowSummary]? = nil) {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case testWindows = "TestWindows"
        }
    }

    public struct PredictorExecutionDetails: AWSDecodableShape {
        /// An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The NumberOfBacktestWindows from the  object determines the number of windows in the array.
        public let predictorExecutions: [PredictorExecution]?

        public init(predictorExecutions: [PredictorExecution]? = nil) {
            self.predictorExecutions = predictorExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case predictorExecutions = "PredictorExecutions"
        }
    }

    public struct PredictorSummary: AWSDecodableShape {
        /// When the model training task was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.
        public let datasetGroupArn: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor.
        public let predictorArn: String?
        /// The name of the predictor.
        public let predictorName: String?
        /// The status of the predictor. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED     The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public let status: String?

        public init(creationTime: Date? = nil, datasetGroupArn: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, predictorName: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case predictorName = "PredictorName"
            case status = "Status"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.
        public let kMSKeyArn: String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        public let path: String
        /// The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the KMSKeyArn key, the role must allow access to the key. Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        public let roleArn: String

        public init(kMSKeyArn: String? = nil, path: String, roleArn: String) {
            self.kMSKeyArn = kMSKeyArn
            self.path = path
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kMSKeyArn, name: "kMSKeyArn", parent: name, max: 256)
            try self.validate(self.kMSKeyArn, name: "kMSKeyArn", parent: name, pattern: "^arn:aws:kms:.*:key/")
            try self.validate(self.path, name: "path", parent: name, pattern: "^s3://[a-z0-9].+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kMSKeyArn = "KMSKeyArn"
            case path = "Path"
            case roleArn = "RoleArn"
        }
    }

    public struct Schema: AWSEncodableShape & AWSDecodableShape {
        /// An array of attributes specifying the name and type of each field in a dataset.
        public let attributes: [SchemaAttribute]?

        public init(attributes: [SchemaAttribute]? = nil) {
            self.attributes = attributes
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 100)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
        }
    }

    public struct SchemaAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of the dataset field.
        public let attributeName: String?
        /// The data type of the field.
        public let attributeType: AttributeType?

        public init(attributeName: String? = nil, attributeType: AttributeType? = nil) {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 63)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeType = "AttributeType"
        }
    }

    public struct Statistics: AWSDecodableShape {
        /// For a numeric field, the average value in the field.
        public let avg: Double?
        /// The number of values in the field. If the response value is -1, refer to CountLong.
        public let count: Int?
        /// The number of distinct values in the field. If the response value is -1, refer to CountDistinctLong.
        public let countDistinct: Int?
        /// The number of distinct values in the field. CountDistinctLong is used instead of CountDistinct if the value is greater than 2,147,483,647.
        public let countDistinctLong: Int64?
        /// The number of values in the field. CountLong is used instead of Count if the value is greater than 2,147,483,647.
        public let countLong: Int64?
        /// The number of NAN (not a number) values in the field. If the response value is -1, refer to CountNanLong.
        public let countNan: Int?
        /// The number of NAN (not a number) values in the field. CountNanLong is used instead of CountNan if the value is greater than 2,147,483,647.
        public let countNanLong: Int64?
        /// The number of null values in the field. If the response value is -1, refer to CountNullLong.
        public let countNull: Int?
        /// The number of null values in the field. CountNullLong is used instead of CountNull if the value is greater than 2,147,483,647.
        public let countNullLong: Int64?
        /// For a numeric field, the maximum value in the field.
        public let max: String?
        /// For a numeric field, the minimum value in the field.
        public let min: String?
        /// For a numeric field, the standard deviation.
        public let stddev: Double?

        public init(avg: Double? = nil, count: Int? = nil, countDistinct: Int? = nil, countDistinctLong: Int64? = nil, countLong: Int64? = nil, countNan: Int? = nil, countNanLong: Int64? = nil, countNull: Int? = nil, countNullLong: Int64? = nil, max: String? = nil, min: String? = nil, stddev: Double? = nil) {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countDistinctLong = countDistinctLong
            self.countLong = countLong
            self.countNan = countNan
            self.countNanLong = countNanLong
            self.countNull = countNull
            self.countNullLong = countNullLong
            self.max = max
            self.min = min
            self.stddev = stddev
        }

        private enum CodingKeys: String, CodingKey {
            case avg = "Avg"
            case count = "Count"
            case countDistinct = "CountDistinct"
            case countDistinctLong = "CountDistinctLong"
            case countLong = "CountLong"
            case countNan = "CountNan"
            case countNanLong = "CountNanLong"
            case countNull = "CountNull"
            case countNullLong = "CountNullLong"
            case max = "Max"
            case min = "Min"
            case stddev = "Stddev"
        }
    }

    public struct StopResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs are DatasetImportJobArn, PredictorArn, PredictorBacktestExportJobArn, ForecastArn, and ForecastExportJobArn.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct SupplementaryFeature: AWSEncodableShape & AWSDecodableShape {
        /// The name of the feature. Valid values: "holiday" and "weather".
        public let name: String
        ///  Weather Index  To enable the Weather Index, set the value to "true"   Holidays  To enable Holidays, specify a country with one of the following two-letter country codes:   "AL" - ALBANIA   "AR" - ARGENTINA   "AT" - AUSTRIA   "AU" - AUSTRALIA   "BA" - BOSNIA HERZEGOVINA   "BE" - BELGIUM   "BG" - BULGARIA   "BO" - BOLIVIA   "BR" - BRAZIL   "BY" - BELARUS   "CA" - CANADA   "CL" - CHILE   "CO" - COLOMBIA   "CR" - COSTA RICA   "HR" - CROATIA   "CZ" - CZECH REPUBLIC   "DK" - DENMARK   "EC" - ECUADOR   "EE" - ESTONIA   "ET" - ETHIOPIA   "FI" - FINLAND   "FR" - FRANCE   "DE" - GERMANY   "GR" - GREECE   "HU" - HUNGARY   "IS" - ICELAND   "IN" - INDIA   "IE" - IRELAND   "IT" - ITALY   "JP" - JAPAN   "KZ" - KAZAKHSTAN   "KR" - KOREA   "LV" - LATVIA   "LI" - LIECHTENSTEIN   "LT" - LITHUANIA   "LU" - LUXEMBOURG   "MK" - MACEDONIA   "MT" - MALTA   "MX" - MEXICO   "MD" - MOLDOVA   "ME" - MONTENEGRO   "NL" - NETHERLANDS   "NZ" - NEW ZEALAND   "NI" - NICARAGUA   "NG" - NIGERIA   "NO" - NORWAY   "PA" - PANAMA   "PY" - PARAGUAY   "PE" - PERU   "PL" - POLAND   "PT" - PORTUGAL   "RO" - ROMANIA   "RU" - RUSSIA   "RS" - SERBIA   "SK" - SLOVAKIA   "SI" - SLOVENIA   "ZA" - SOUTH AFRICA   "ES" - SPAIN   "SE" - SWEDEN   "CH" - SWITZERLAND   "UA" - UKRAINE   "AE" - UNITED ARAB EMIRATES   "US" - UNITED STATES   "UK" - UNITED KINGDOM   "UY" - URUGUAY   "VE" - VENEZUELA
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TestWindowSummary: AWSDecodableShape {
        /// If the test failed, the reason why it failed.
        public let message: String?
        /// The status of the test. Possible status values are:    ACTIVE     CREATE_IN_PROGRESS     CREATE_FAILED
        public let status: String?
        /// The time at which the test ended.
        public let testWindowEnd: Date?
        /// The time at which the test began.
        public let testWindowStart: Date?

        public init(message: String? = nil, status: String? = nil, testWindowEnd: Date? = nil, testWindowStart: Date? = nil) {
            self.message = message
            self.status = status
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case status = "Status"
            case testWindowEnd = "TestWindowEnd"
            case testWindowStart = "TestWindowStart"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast exports.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatasetGroupRequest: AWSEncodableShape {
        /// An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset group.
        public let datasetArns: [String]
        /// The ARN of the dataset group.
        public let datasetGroupArn: String

        public init(datasetArns: [String], datasetGroupArn: String) {
            self.datasetArns = datasetArns
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.datasetArns.forEach {
                try validate($0, name: "datasetArns[]", parent: name, max: 256)
                try validate($0, name: "datasetArns[]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
            }
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\:]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArns = "DatasetArns"
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct UpdateDatasetGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct WeightedQuantileLoss: AWSDecodableShape {
        /// The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.
        public let lossValue: Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public let quantile: Double?

        public init(lossValue: Double? = nil, quantile: Double? = nil) {
            self.lossValue = lossValue
            self.quantile = quantile
        }

        private enum CodingKeys: String, CodingKey {
            case lossValue = "LossValue"
            case quantile = "Quantile"
        }
    }

    public struct WindowSummary: AWSDecodableShape {
        /// The type of evaluation.    SUMMARY - The average metrics across all windows.    COMPUTED - The metrics for the specified window.
        public let evaluationType: EvaluationType?
        /// The number of data points within the window.
        public let itemCount: Int?
        /// Provides metrics used to evaluate the performance of a predictor.
        public let metrics: Metrics?
        /// The timestamp that defines the end of the window.
        public let testWindowEnd: Date?
        /// The timestamp that defines the start of the window.
        public let testWindowStart: Date?

        public init(evaluationType: EvaluationType? = nil, itemCount: Int? = nil, metrics: Metrics? = nil, testWindowEnd: Date? = nil, testWindowStart: Date? = nil) {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationType = "EvaluationType"
            case itemCount = "ItemCount"
            case metrics = "Metrics"
            case testWindowEnd = "TestWindowEnd"
            case testWindowStart = "TestWindowStart"
        }
    }
}
