//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Forecast {
    // MARK: Enums

    public enum AttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case float = "float"
        case geolocation = "geolocation"
        case integer = "integer"
        case string = "string"
        case timestamp = "timestamp"
        public var description: String { return self.rawValue }
    }

    public enum AutoMLOverrideStrategy: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accuracyOptimized = "AccuracyOptimized"
        case latencyOptimized = "LatencyOptimized"
        public var description: String { return self.rawValue }
    }

    public enum Condition: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equals = "EQUALS"
        case greaterThan = "GREATER_THAN"
        case lessThan = "LESS_THAN"
        case notEquals = "NOT_EQUALS"
        public var description: String { return self.rawValue }
    }

    public enum DatasetType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case itemMetadata = "ITEM_METADATA"
        case relatedTimeSeries = "RELATED_TIME_SERIES"
        case targetTimeSeries = "TARGET_TIME_SERIES"
        public var description: String { return self.rawValue }
    }

    public enum DayOfWeek: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case friday = "FRIDAY"
        case monday = "MONDAY"
        case saturday = "SATURDAY"
        case sunday = "SUNDAY"
        case thursday = "THURSDAY"
        case tuesday = "TUESDAY"
        case wednesday = "WEDNESDAY"
        public var description: String { return self.rawValue }
    }

    public enum Domain: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case custom = "CUSTOM"
        case ec2Capacity = "EC2_CAPACITY"
        case inventoryPlanning = "INVENTORY_PLANNING"
        case metrics = "METRICS"
        case retail = "RETAIL"
        case webTraffic = "WEB_TRAFFIC"
        case workForce = "WORK_FORCE"
        public var description: String { return self.rawValue }
    }

    public enum EvaluationType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case computed = "COMPUTED"
        case summary = "SUMMARY"
        public var description: String { return self.rawValue }
    }

    public enum FeaturizationMethodName: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case filling = "filling"
        public var description: String { return self.rawValue }
    }

    public enum FilterConditionString: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `is` = "IS"
        case isNot = "IS_NOT"
        public var description: String { return self.rawValue }
    }

    public enum ImportMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case full = "FULL"
        case incremental = "INCREMENTAL"
        public var description: String { return self.rawValue }
    }

    public enum Month: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case april = "APRIL"
        case august = "AUGUST"
        case december = "DECEMBER"
        case february = "FEBRUARY"
        case january = "JANUARY"
        case july = "JULY"
        case june = "JUNE"
        case march = "MARCH"
        case may = "MAY"
        case november = "NOVEMBER"
        case october = "OCTOBER"
        case september = "SEPTEMBER"
        public var description: String { return self.rawValue }
    }

    public enum Operation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case add = "ADD"
        case divide = "DIVIDE"
        case multiply = "MULTIPLY"
        case subtract = "SUBTRACT"
        public var description: String { return self.rawValue }
    }

    public enum OptimizationMetric: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case averageWeightedQuantileLoss = "AverageWeightedQuantileLoss"
        case mape = "MAPE"
        case mase = "MASE"
        case rmse = "RMSE"
        case wape = "WAPE"
        public var description: String { return self.rawValue }
    }

    public enum ScalingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case auto = "Auto"
        case linear = "Linear"
        case logarithmic = "Logarithmic"
        case reverseLogarithmic = "ReverseLogarithmic"
        public var description: String { return self.rawValue }
    }

    public enum State: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "Active"
        case deleted = "Deleted"
        public var description: String { return self.rawValue }
    }

    public enum TimePointGranularity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case specific = "SPECIFIC"
        public var description: String { return self.rawValue }
    }

    public enum TimeSeriesGranularity: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case all = "ALL"
        case specific = "SPECIFIC"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Action: AWSEncodableShape & AWSDecodableShape {
        /// The related time series that you are modifying. This value is case insensitive.
        public let attributeName: String
        /// The operation that is applied to the provided attribute. Operations include:    ADD - adds Value to all rows of AttributeName.    SUBTRACT - subtracts Value from all rows of AttributeName.    MULTIPLY - multiplies all rows of AttributeName by Value.    DIVIDE - divides all rows of AttributeName by Value.
        public let operation: Operation
        /// The value that is applied for the chosen Operation.
        public let value: Double

        public init(attributeName: String, operation: Operation, value: Double) {
            self.attributeName = attributeName
            self.operation = operation
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 63)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case operation = "Operation"
            case value = "Value"
        }
    }

    public struct AdditionalDataset: AWSEncodableShape & AWSDecodableShape {
        ///  Weather Index  To enable the Weather Index, do not specify a value for Configuration.  Holidays   Holidays  To enable Holidays, set CountryCode to one of the following two-letter country codes:   "AL" - ALBANIA   "AR" - ARGENTINA   "AT" - AUSTRIA   "AU" - AUSTRALIA   "BA" - BOSNIA HERZEGOVINA   "BE" - BELGIUM   "BG" - BULGARIA   "BO" - BOLIVIA   "BR" - BRAZIL   "BY" - BELARUS   "CA" - CANADA   "CL" - CHILE   "CO" - COLOMBIA   "CR" - COSTA RICA   "HR" - CROATIA   "CZ" - CZECH REPUBLIC   "DK" - DENMARK   "EC" - ECUADOR   "EE" - ESTONIA   "ET" - ETHIOPIA   "FI" - FINLAND   "FR" - FRANCE   "DE" - GERMANY   "GR" - GREECE   "HU" - HUNGARY   "IS" - ICELAND   "IN" - INDIA   "IE" - IRELAND   "IT" - ITALY   "JP" - JAPAN   "KZ" - KAZAKHSTAN   "KR" - KOREA   "LV" - LATVIA   "LI" - LIECHTENSTEIN   "LT" - LITHUANIA   "LU" - LUXEMBOURG   "MK" - MACEDONIA   "MT" - MALTA   "MX" - MEXICO   "MD" - MOLDOVA   "ME" - MONTENEGRO   "NL" - NETHERLANDS   "NZ" - NEW ZEALAND   "NI" - NICARAGUA   "NG" - NIGERIA   "NO" - NORWAY   "PA" - PANAMA   "PY" - PARAGUAY   "PE" - PERU   "PL" - POLAND   "PT" - PORTUGAL   "RO" - ROMANIA   "RU" - RUSSIA   "RS" - SERBIA   "SK" - SLOVAKIA   "SI" - SLOVENIA   "ZA" - SOUTH AFRICA   "ES" - SPAIN   "SE" - SWEDEN   "CH" - SWITZERLAND   "UA" - UKRAINE   "AE" - UNITED ARAB EMIRATES   "US" - UNITED STATES   "UK" - UNITED KINGDOM   "UY" - URUGUAY   "VE" - VENEZUELA
        public let configuration: [String: [String]]?
        /// The name of the additional dataset. Valid names: "holiday" and "weather".
        public let name: String

        public init(configuration: [String: [String]]? = nil, name: String) {
            self.configuration = configuration
            self.name = name
        }

        public func validate(name: String) throws {
            try self.configuration?.forEach {
                try validate($0.key, name: "configuration.key", parent: name, max: 63)
                try validate($0.key, name: "configuration.key", parent: name, min: 1)
                try validate($0.key, name: "configuration.key", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
                try validate($0.value, name: "configuration[\"\($0.key)\"]", parent: name, max: 20)
                try validate($0.value, name: "configuration[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "Configuration"
            case name = "Name"
        }
    }

    public struct AttributeConfig: AWSEncodableShape & AWSDecodableShape {
        /// The name of the attribute as specified in the schema. Amazon Forecast supports the target field of the target time series and the related time series datasets. For example, for the RETAIL domain, the target is demand.
        public let attributeName: String
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Default values are bolded.    aggregation: sum, avg, first, min, max     frontfill: none     middlefill: zero, nan (not a number), value, median, mean, min, max     backfill: zero, nan, value, median, mean, min, max    The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):    middlefill: zero, value, median, mean, min, max     backfill: zero, value, median, mean, min, max     futurefill: zero, value, median, mean, min, max    To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        public let transformations: [String: String]

        public init(attributeName: String, transformations: [String: String]) {
            self.attributeName = attributeName
            self.transformations = transformations
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 63)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.transformations.forEach {
                try validate($0.key, name: "transformations.key", parent: name, max: 63)
                try validate($0.key, name: "transformations.key", parent: name, min: 1)
                try validate($0.key, name: "transformations.key", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
                try validate($0.value, name: "transformations[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "transformations[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
            }
            try self.validate(self.transformations, name: "transformations", parent: name, max: 20)
            try self.validate(self.transformations, name: "transformations", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case transformations = "Transformations"
        }
    }

    public struct Baseline: AWSDecodableShape {
        /// The initial accuracy metrics for the predictor you are monitoring. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public let predictorBaseline: PredictorBaseline?

        public init(predictorBaseline: PredictorBaseline? = nil) {
            self.predictorBaseline = predictorBaseline
        }

        private enum CodingKeys: String, CodingKey {
            case predictorBaseline = "PredictorBaseline"
        }
    }

    public struct BaselineMetric: AWSDecodableShape {
        /// The name of the metric.
        public let name: String?
        /// The value for the metric.
        public let value: Double?

        public init(name: String? = nil, value: Double? = nil) {
            self.name = name
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct CategoricalParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The name of the categorical hyperparameter to tune.
        public let name: String
        /// A list of the tunable categories for the hyperparameter.
        public let values: [String]

        public init(name: String, values: [String]) {
            self.name = name
            self.values = values
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 256)
                try validate($0, name: "values[]", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
            }
            try self.validate(self.values, name: "values", parent: name, max: 20)
            try self.validate(self.values, name: "values", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case values = "Values"
        }
    }

    public struct ContinuousParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum tunable value of the hyperparameter.
        public let maxValue: Double
        /// The minimum tunable value of the hyperparameter.
        public let minValue: Double
        /// The name of the hyperparameter to tune.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:  Auto  Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0.  ReverseLogarithmic  hyperparameter tuning searches the values in the hyperparameter range by using a reverse logarithmic scale. Reverse logarithmic scaling works only for ranges that are entirely within the range 0    For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:
        public let scalingType: ScalingType?

        public init(maxValue: Double, minValue: Double, name: String, scalingType: ScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct CreateAutoPredictorRequest: AWSEncodableShape {
        /// The data configuration for your dataset group and any additional datasets.
        public let dataConfig: DataConfig?
        public let encryptionConfig: EncryptionConfig?
        /// Create an Explainability resource for the predictor.
        public let explainPredictor: Bool?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, if you are generating forecasts for item sales across all your stores, and your dataset contains a store_id field, you would specify store_id as a dimension to group sales forecasts for each store.
        public let forecastDimensions: [String]?
        /// The frequency of predictions in a forecast. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:   Minute - 1-59   Hour - 1-23   Day - 1-6   Week - 1-4   Month - 1-11   Year - 1   Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M". The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the RELATED_TIME_SERIES dataset frequency.
        public let forecastFrequency: String?
        /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length. The maximum forecast horizon is the lesser of 500 time-steps or 1/4 of the TARGET_TIME_SERIES dataset length. If you are retraining an existing AutoPredictor, then the maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length. If you are upgrading to an AutoPredictor or retraining an existing AutoPredictor, you cannot update the forecast horizon parameter. You can meet this requirement by providing longer time-series in the dataset.
        public let forecastHorizon: Int?
        /// The forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean.
        public let forecastTypes: [String]?
        /// The configuration details for predictor monitoring. Provide a name for the monitor resource to enable predictor monitoring. Predictor monitoring allows you to see how your predictor's performance changes over time. For more information, see Predictor Monitoring.
        public let monitorConfig: MonitorConfig?
        /// The accuracy metric used to optimize the predictor.
        public let optimizationMetric: OptimizationMetric?
        /// A unique name for the predictor
        public let predictorName: String
        /// The ARN of the predictor to retrain or upgrade. This parameter is only used when retraining or upgrading a predictor. When creating a new predictor, do not specify a value for this parameter. When upgrading or retraining a predictor, only specify values for the ReferencePredictorArn and PredictorName. The value for PredictorName must be a unique predictor name.
        public let referencePredictorArn: String?
        /// Optional metadata to help you categorize and organize your predictors. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:   For each resource, each tag key must be unique and each tag key must have one value.   Maximum number of tags per resource: 50.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.    Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
        public let tags: [Tag]?
        /// The time boundary Forecast uses to align and aggregate any data that doesn't align with your forecast frequency. Provide the unit of time and the time boundary as a key value pair.  For more information on specifying a time boundary, see Specifying a Time Boundary. If you don't provide a time boundary, Forecast uses a set of Default Time Boundaries.
        public let timeAlignmentBoundary: TimeAlignmentBoundary?

        public init(dataConfig: DataConfig? = nil, encryptionConfig: EncryptionConfig? = nil, explainPredictor: Bool? = nil, forecastDimensions: [String]? = nil, forecastFrequency: String? = nil, forecastHorizon: Int? = nil, forecastTypes: [String]? = nil, monitorConfig: MonitorConfig? = nil, optimizationMetric: OptimizationMetric? = nil, predictorName: String, referencePredictorArn: String? = nil, tags: [Tag]? = nil, timeAlignmentBoundary: TimeAlignmentBoundary? = nil) {
            self.dataConfig = dataConfig
            self.encryptionConfig = encryptionConfig
            self.explainPredictor = explainPredictor
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
            self.forecastHorizon = forecastHorizon
            self.forecastTypes = forecastTypes
            self.monitorConfig = monitorConfig
            self.optimizationMetric = optimizationMetric
            self.predictorName = predictorName
            self.referencePredictorArn = referencePredictorArn
            self.tags = tags
            self.timeAlignmentBoundary = timeAlignmentBoundary
        }

        public func validate(name: String) throws {
            try self.dataConfig?.validate(name: "\(name).dataConfig")
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
            try self.forecastDimensions?.forEach {
                try validate($0, name: "forecastDimensions[]", parent: name, max: 63)
                try validate($0, name: "forecastDimensions[]", parent: name, min: 1)
                try validate($0, name: "forecastDimensions[]", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            }
            try self.validate(self.forecastDimensions, name: "forecastDimensions", parent: name, max: 10)
            try self.validate(self.forecastDimensions, name: "forecastDimensions", parent: name, min: 1)
            try self.validate(self.forecastFrequency, name: "forecastFrequency", parent: name, max: 5)
            try self.validate(self.forecastFrequency, name: "forecastFrequency", parent: name, min: 1)
            try self.validate(self.forecastFrequency, name: "forecastFrequency", parent: name, pattern: "^Y|M|W|D|H|30min|15min|10min|5min|1min$")
            try self.forecastTypes?.forEach {
                try validate($0, name: "forecastTypes[]", parent: name, max: 4)
                try validate($0, name: "forecastTypes[]", parent: name, min: 2)
                try validate($0, name: "forecastTypes[]", parent: name, pattern: "^(^0?\\.\\d\\d?$|^mean$)$")
            }
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, max: 20)
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, min: 1)
            try self.monitorConfig?.validate(name: "\(name).monitorConfig")
            try self.validate(self.predictorName, name: "predictorName", parent: name, max: 63)
            try self.validate(self.predictorName, name: "predictorName", parent: name, min: 1)
            try self.validate(self.predictorName, name: "predictorName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.referencePredictorArn, name: "referencePredictorArn", parent: name, max: 256)
            try self.validate(self.referencePredictorArn, name: "referencePredictorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.timeAlignmentBoundary?.validate(name: "\(name).timeAlignmentBoundary")
        }

        private enum CodingKeys: String, CodingKey {
            case dataConfig = "DataConfig"
            case encryptionConfig = "EncryptionConfig"
            case explainPredictor = "ExplainPredictor"
            case forecastDimensions = "ForecastDimensions"
            case forecastFrequency = "ForecastFrequency"
            case forecastHorizon = "ForecastHorizon"
            case forecastTypes = "ForecastTypes"
            case monitorConfig = "MonitorConfig"
            case optimizationMetric = "OptimizationMetric"
            case predictorName = "PredictorName"
            case referencePredictorArn = "ReferencePredictorArn"
            case tags = "Tags"
            case timeAlignmentBoundary = "TimeAlignmentBoundary"
        }
    }

    public struct CreateAutoPredictorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the predictor.
        public let predictorArn: String?

        public init(predictorArn: String? = nil) {
            self.predictorArn = predictorArn
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct CreateDatasetGroupRequest: AWSEncodableShape {
        /// An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset group.
        public let datasetArns: [String]?
        /// A name for the dataset group.
        public let datasetGroupName: String
        /// The domain associated with the dataset group. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the CreateDataset operation must match. The Domain and DatasetType that you choose determine the fields that must be present in training data that you import to a dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires that item_id, timestamp, and demand fields are present in your data. For more information, see Dataset groups.
        public let domain: Domain
        /// The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?

        public init(datasetArns: [String]? = nil, datasetGroupName: String, domain: Domain, tags: [Tag]? = nil) {
            self.datasetArns = datasetArns
            self.datasetGroupName = datasetGroupName
            self.domain = domain
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.datasetArns?.forEach {
                try validate($0, name: "datasetArns[]", parent: name, max: 256)
                try validate($0, name: "datasetArns[]", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            }
            try self.validate(self.datasetGroupName, name: "datasetGroupName", parent: name, max: 63)
            try self.validate(self.datasetGroupName, name: "datasetGroupName", parent: name, min: 1)
            try self.validate(self.datasetGroupName, name: "datasetGroupName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArns = "DatasetArns"
            case datasetGroupName = "DatasetGroupName"
            case domain = "Domain"
            case tags = "Tags"
        }
    }

    public struct CreateDatasetGroupResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?

        public init(datasetGroupArn: String? = nil) {
            self.datasetGroupArn = datasetGroupArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct CreateDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data to.
        public let datasetArn: String
        /// The name for the dataset import job. We recommend including the current timestamp in the name, for example, 20190721DatasetImport. This can help you avoid getting a ResourceAlreadyExistsException exception.
        public let datasetImportJobName: String
        /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource must include an Key Management Service (KMS) key and the IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must match those specified in the EncryptionConfig parameter of the CreateDataset operation.
        public let dataSource: DataSource
        /// The format of the imported data, CSV or PARQUET. The default value is CSV.
        public let format: String?
        /// The format of the geolocation attribute. The geolocation attribute can be formatted in one of two ways:    LAT_LONG - the latitude and longitude in decimal format (Example: 47.61_-122.33).    CC_POSTALCODE (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).
        public let geolocationFormat: String?
        /// Specifies whether the dataset import job is a FULL or INCREMENTAL import. A FULL dataset import replaces all of the existing data with the newly imported data. An INCREMENTAL import appends the imported data to the existing data.
        public let importMode: ImportMode?
        /// The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?
        /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported   "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D   "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D   If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd HH:mm:ss".
        public let timestampFormat: String?
        /// A single time zone for every item in your dataset. This option is ideal for datasets with all timestamps within a single time zone, or if all timestamps are normalized to a single time zone.  Refer to the Joda-Time API for a complete list of valid time zone names.
        public let timeZone: String?
        /// Automatically derive time zone information from the geolocation attribute. This option is ideal for datasets that contain timestamps in multiple time zones and those timestamps are expressed in local time.
        public let useGeolocationForTimeZone: Bool?

        public init(datasetArn: String, datasetImportJobName: String, dataSource: DataSource, format: String? = nil, geolocationFormat: String? = nil, importMode: ImportMode? = nil, tags: [Tag]? = nil, timestampFormat: String? = nil, timeZone: String? = nil, useGeolocationForTimeZone: Bool? = nil) {
            self.datasetArn = datasetArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSource = dataSource
            self.format = format
            self.geolocationFormat = geolocationFormat
            self.importMode = importMode
            self.tags = tags
            self.timestampFormat = timestampFormat
            self.timeZone = timeZone
            self.useGeolocationForTimeZone = useGeolocationForTimeZone
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.validate(self.datasetImportJobName, name: "datasetImportJobName", parent: name, max: 63)
            try self.validate(self.datasetImportJobName, name: "datasetImportJobName", parent: name, min: 1)
            try self.validate(self.datasetImportJobName, name: "datasetImportJobName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.dataSource.validate(name: "\(name).dataSource")
            try self.validate(self.format, name: "format", parent: name, max: 7)
            try self.validate(self.format, name: "format", parent: name, pattern: "^CSV|PARQUET$")
            try self.validate(self.geolocationFormat, name: "geolocationFormat", parent: name, max: 256)
            try self.validate(self.geolocationFormat, name: "geolocationFormat", parent: name, pattern: "^[a-zA-Z0-9_]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.timestampFormat, name: "timestampFormat", parent: name, max: 256)
            try self.validate(self.timestampFormat, name: "timestampFormat", parent: name, pattern: "^[a-zA-Z0-9\\-\\:\\.\\,\\'\\s]+$")
            try self.validate(self.timeZone, name: "timeZone", parent: name, max: 256)
            try self.validate(self.timeZone, name: "timeZone", parent: name, pattern: "^[a-zA-Z0-9\\/\\+\\-\\_]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSource = "DataSource"
            case format = "Format"
            case geolocationFormat = "GeolocationFormat"
            case importMode = "ImportMode"
            case tags = "Tags"
            case timestampFormat = "TimestampFormat"
            case timeZone = "TimeZone"
            case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
        }
    }

    public struct CreateDatasetImportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?

        public init(datasetImportJobArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// The frequency of data collection. This parameter is required for RELATED_TIME_SERIES datasets. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:   Minute - 1-59   Hour - 1-23   Day - 1-6   Week - 1-4   Month - 1-11   Year - 1   Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M".
        public let dataFrequency: String?
        /// A name for the dataset.
        public let datasetName: String
        /// The dataset type. Valid values depend on the chosen Domain.
        public let datasetType: DatasetType
        /// The domain associated with the dataset. When you add a dataset to a dataset group, this value and the value specified for the Domain parameter of the CreateDatasetGroup operation must match. The Domain and DatasetType that you choose determine the fields that must be present in the training data that you import to the dataset. For example, if you choose the RETAIL domain and TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires item_id, timestamp, and demand fields to be present in your data. For more information, see Importing datasets.
        public let domain: Domain
        /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// The schema for the dataset. The schema attributes and their order must match the fields in your data. The dataset Domain and DatasetType that you choose determine the minimum required fields in your training data. For information about the required fields for a specific dataset domain and type, see Dataset Domains and Dataset Types.
        public let schema: Schema
        /// The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?

        public init(dataFrequency: String? = nil, datasetName: String, datasetType: DatasetType, domain: Domain, encryptionConfig: EncryptionConfig? = nil, schema: Schema, tags: [Tag]? = nil) {
            self.dataFrequency = dataFrequency
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.encryptionConfig = encryptionConfig
            self.schema = schema
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.dataFrequency, name: "dataFrequency", parent: name, max: 5)
            try self.validate(self.dataFrequency, name: "dataFrequency", parent: name, min: 1)
            try self.validate(self.dataFrequency, name: "dataFrequency", parent: name, pattern: "^Y|M|W|D|H|30min|15min|10min|5min|1min$")
            try self.validate(self.datasetName, name: "datasetName", parent: name, max: 63)
            try self.validate(self.datasetName, name: "datasetName", parent: name, min: 1)
            try self.validate(self.datasetName, name: "datasetName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
            try self.schema.validate(name: "\(name).schema")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case dataFrequency = "DataFrequency"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case encryptionConfig = "EncryptionConfig"
            case schema = "Schema"
            case tags = "Tags"
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?

        public init(datasetArn: String? = nil) {
            self.datasetArn = datasetArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct CreateExplainabilityExportRequest: AWSEncodableShape {
        public let destination: DataDestination
        /// The Amazon Resource Name (ARN) of the Explainability to export.
        public let explainabilityArn: String
        /// A unique name for the Explainability export.
        public let explainabilityExportName: String
        /// The format of the exported data, CSV or PARQUET.
        public let format: String?
        /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:   For each resource, each tag key must be unique and each tag key must have one value.   Maximum number of tags per resource: 50.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.    Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
        public let tags: [Tag]?

        public init(destination: DataDestination, explainabilityArn: String, explainabilityExportName: String, format: String? = nil, tags: [Tag]? = nil) {
            self.destination = destination
            self.explainabilityArn = explainabilityArn
            self.explainabilityExportName = explainabilityExportName
            self.format = format
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.explainabilityArn, name: "explainabilityArn", parent: name, max: 256)
            try self.validate(self.explainabilityArn, name: "explainabilityArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.validate(self.explainabilityExportName, name: "explainabilityExportName", parent: name, max: 63)
            try self.validate(self.explainabilityExportName, name: "explainabilityExportName", parent: name, min: 1)
            try self.validate(self.explainabilityExportName, name: "explainabilityExportName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.format, name: "format", parent: name, max: 7)
            try self.validate(self.format, name: "format", parent: name, pattern: "^CSV|PARQUET$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case explainabilityArn = "ExplainabilityArn"
            case explainabilityExportName = "ExplainabilityExportName"
            case format = "Format"
            case tags = "Tags"
        }
    }

    public struct CreateExplainabilityExportResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the export.
        public let explainabilityExportArn: String?

        public init(explainabilityExportArn: String? = nil) {
            self.explainabilityExportArn = explainabilityExportArn
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityExportArn = "ExplainabilityExportArn"
        }
    }

    public struct CreateExplainabilityRequest: AWSEncodableShape {
        public let dataSource: DataSource?
        /// Create an Explainability visualization that is viewable within the Amazon Web Services console.
        public let enableVisualization: Bool?
        /// If TimePointGranularity is set to SPECIFIC, define the last time point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
        public let endDateTime: String?
        /// The configuration settings that define the granularity of time series and time points for the Explainability.
        public let explainabilityConfig: ExplainabilityConfig
        /// A unique name for the Explainability.
        public let explainabilityName: String
        /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
        public let resourceArn: String
        public let schema: Schema?
        /// If TimePointGranularity is set to SPECIFIC, define the first point for the Explainability. Use the following timestamp format: yyyy-MM-ddTHH:mm:ss (example: 2015-01-01T20:00:00)
        public let startDateTime: String?
        /// Optional metadata to help you categorize and organize your resources. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:   For each resource, each tag key must be unique and each tag key must have one value.   Maximum number of tags per resource: 50.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.    Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
        public let tags: [Tag]?

        public init(dataSource: DataSource? = nil, enableVisualization: Bool? = nil, endDateTime: String? = nil, explainabilityConfig: ExplainabilityConfig, explainabilityName: String, resourceArn: String, schema: Schema? = nil, startDateTime: String? = nil, tags: [Tag]? = nil) {
            self.dataSource = dataSource
            self.enableVisualization = enableVisualization
            self.endDateTime = endDateTime
            self.explainabilityConfig = explainabilityConfig
            self.explainabilityName = explainabilityName
            self.resourceArn = resourceArn
            self.schema = schema
            self.startDateTime = startDateTime
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.dataSource?.validate(name: "\(name).dataSource")
            try self.validate(self.endDateTime, name: "endDateTime", parent: name, max: 19)
            try self.validate(self.endDateTime, name: "endDateTime", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}$")
            try self.validate(self.explainabilityName, name: "explainabilityName", parent: name, max: 63)
            try self.validate(self.explainabilityName, name: "explainabilityName", parent: name, min: 1)
            try self.validate(self.explainabilityName, name: "explainabilityName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.schema?.validate(name: "\(name).schema")
            try self.validate(self.startDateTime, name: "startDateTime", parent: name, max: 19)
            try self.validate(self.startDateTime, name: "startDateTime", parent: name, pattern: "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case enableVisualization = "EnableVisualization"
            case endDateTime = "EndDateTime"
            case explainabilityConfig = "ExplainabilityConfig"
            case explainabilityName = "ExplainabilityName"
            case resourceArn = "ResourceArn"
            case schema = "Schema"
            case startDateTime = "StartDateTime"
            case tags = "Tags"
        }
    }

    public struct CreateExplainabilityResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Explainability.
        public let explainabilityArn: String?

        public init(explainabilityArn: String? = nil) {
            self.explainabilityArn = explainabilityArn
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityArn = "ExplainabilityArn"
        }
    }

    public struct CreateForecastExportJobRequest: AWSEncodableShape {
        /// The location where you want to save the forecast and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
        public let destination: DataDestination
        /// The Amazon Resource Name (ARN) of the forecast that you want to export.
        public let forecastArn: String
        /// The name for the forecast export job.
        public let forecastExportJobName: String
        /// The format of the exported data, CSV or PARQUET. The default value is CSV.
        public let format: String?
        /// The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?

        public init(destination: DataDestination, forecastArn: String, forecastExportJobName: String, format: String? = nil, tags: [Tag]? = nil) {
            self.destination = destination
            self.forecastArn = forecastArn
            self.forecastExportJobName = forecastExportJobName
            self.format = format
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, max: 256)
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.validate(self.forecastExportJobName, name: "forecastExportJobName", parent: name, max: 63)
            try self.validate(self.forecastExportJobName, name: "forecastExportJobName", parent: name, min: 1)
            try self.validate(self.forecastExportJobName, name: "forecastExportJobName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.format, name: "format", parent: name, max: 7)
            try self.validate(self.format, name: "format", parent: name, pattern: "^CSV|PARQUET$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case forecastArn = "ForecastArn"
            case forecastExportJobName = "ForecastExportJobName"
            case format = "Format"
            case tags = "Tags"
        }
    }

    public struct CreateForecastExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the export job.
        public let forecastExportJobArn: String?

        public init(forecastExportJobArn: String? = nil) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct CreateForecastRequest: AWSEncodableShape {
        /// A name for the forecast.
        public let forecastName: String
        /// The quantiles at which probabilistic forecasts are generated. You can currently specify up to 5 quantiles per forecast. Accepted values include 0.01 to 0.99 (increments of .01 only) and mean. The mean forecast is different from the median (0.50) when the distribution is not symmetric (for example, Beta and Negative Binomial).  The default quantiles are the quantiles you specified during predictor creation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
        public let forecastTypes: [String]?
        /// The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
        public let predictorArn: String
        /// The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?
        /// Defines the set of time series that are used to create the forecasts in a TimeSeriesIdentifiers object. The TimeSeriesIdentifiers object needs the following information:    DataSource     Format     Schema
        public let timeSeriesSelector: TimeSeriesSelector?

        public init(forecastName: String, forecastTypes: [String]? = nil, predictorArn: String, tags: [Tag]? = nil, timeSeriesSelector: TimeSeriesSelector? = nil) {
            self.forecastName = forecastName
            self.forecastTypes = forecastTypes
            self.predictorArn = predictorArn
            self.tags = tags
            self.timeSeriesSelector = timeSeriesSelector
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastName, name: "forecastName", parent: name, max: 63)
            try self.validate(self.forecastName, name: "forecastName", parent: name, min: 1)
            try self.validate(self.forecastName, name: "forecastName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.forecastTypes?.forEach {
                try validate($0, name: "forecastTypes[]", parent: name, max: 4)
                try validate($0, name: "forecastTypes[]", parent: name, min: 2)
                try validate($0, name: "forecastTypes[]", parent: name, pattern: "^(^0?\\.\\d\\d?$|^mean$)$")
            }
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, max: 20)
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, min: 1)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.timeSeriesSelector?.validate(name: "\(name).timeSeriesSelector")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastName = "ForecastName"
            case forecastTypes = "ForecastTypes"
            case predictorArn = "PredictorArn"
            case tags = "Tags"
            case timeSeriesSelector = "TimeSeriesSelector"
        }
    }

    public struct CreateForecastResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the forecast.
        public let forecastArn: String?

        public init(forecastArn: String? = nil) {
            self.forecastArn = forecastArn
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct CreateMonitorRequest: AWSEncodableShape {
        /// The name of the monitor resource.
        public let monitorName: String
        /// The Amazon Resource Name (ARN) of the predictor to monitor.
        public let resourceArn: String
        /// A list of tags to apply to the monitor resource.
        public let tags: [Tag]?

        public init(monitorName: String, resourceArn: String, tags: [Tag]? = nil) {
            self.monitorName = monitorName
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 63)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case monitorName = "MonitorName"
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct CreateMonitorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public let monitorArn: String?

        public init(monitorArn: String? = nil) {
            self.monitorArn = monitorArn
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
        }
    }

    public struct CreatePredictorBacktestExportJobRequest: AWSEncodableShape {
        public let destination: DataDestination
        /// The format of the exported data, CSV or PARQUET. The default value is CSV.
        public let format: String?
        /// The Amazon Resource Name (ARN) of the predictor that you want to export.
        public let predictorArn: String
        /// The name for the backtest export job.
        public let predictorBacktestExportJobName: String
        /// Optional metadata to help you categorize and organize your backtests. Each tag consists of a key and an optional value, both of which you define. Tag keys and values are case sensitive. The following restrictions apply to tags:   For each resource, each tag key must be unique and each tag key must have one value.   Maximum number of tags per resource: 50.   Maximum key length: 128 Unicode characters in UTF-8.   Maximum value length: 256 Unicode characters in UTF-8.   Accepted characters: all letters and numbers, spaces representable in UTF-8, and + - = . _ : / @. If your tagging schema is used across other services and resources, the character restrictions of those services also apply.    Key prefixes cannot include any upper or lowercase combination of aws: or AWS:. Values can have this prefix. If a tag value has aws as its prefix but the key does not, Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit. You cannot edit or delete tag keys with this prefix.
        public let tags: [Tag]?

        public init(destination: DataDestination, format: String? = nil, predictorArn: String, predictorBacktestExportJobName: String, tags: [Tag]? = nil) {
            self.destination = destination
            self.format = format
            self.predictorArn = predictorArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.format, name: "format", parent: name, max: 7)
            try self.validate(self.format, name: "format", parent: name, pattern: "^CSV|PARQUET$")
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.validate(self.predictorBacktestExportJobName, name: "predictorBacktestExportJobName", parent: name, max: 63)
            try self.validate(self.predictorBacktestExportJobName, name: "predictorBacktestExportJobName", parent: name, min: 1)
            try self.validate(self.predictorBacktestExportJobName, name: "predictorBacktestExportJobName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case format = "Format"
            case predictorArn = "PredictorArn"
            case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
            case tags = "Tags"
        }
    }

    public struct CreatePredictorBacktestExportJobResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the predictor backtest export job that you want to export.
        public let predictorBacktestExportJobArn: String?

        public init(predictorBacktestExportJobArn: String? = nil) {
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        }

        private enum CodingKeys: String, CodingKey {
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        }
    }

    public struct CreatePredictorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if PerformAutoML is not set to true.  Supported algorithms:     arn:aws:forecast:::algorithm/ARIMA     arn:aws:forecast:::algorithm/CNN-QR     arn:aws:forecast:::algorithm/Deep_AR_Plus     arn:aws:forecast:::algorithm/ETS     arn:aws:forecast:::algorithm/NPTS     arn:aws:forecast:::algorithm/Prophet
        public let algorithmArn: String?
        ///  The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges.   Used to overide the default AutoML strategy, which is to optimize predictor accuracy. To apply an AutoML strategy that minimizes training time, use LatencyOptimized. This parameter is only valid for predictors trained using AutoML.
        public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
        /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
        public let evaluationParameters: EvaluationParameters?
        /// The featurization configuration.
        public let featurizationConfig: FeaturizationConfig
        /// Specifies the number of time-steps that the model is trained to predict. The forecast horizon is also called the prediction length. For example, if you configure a dataset for daily data collection (using the DataFrequency parameter of the CreateDataset operation) and set the forecast horizon to 10, the model returns predictions for 10 days. The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the TARGET_TIME_SERIES dataset length.
        public let forecastHorizon: Int
        /// Specifies the forecast types used to train a predictor. You can specify up to five forecast types. Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify the mean forecast with mean.  The default value is ["0.10", "0.50", "0.9"].
        public let forecastTypes: [String]?
        /// Provides hyperparameter override values for the algorithm. If you don't provide this parameter, Amazon Forecast uses default values. The individual algorithms specify which hyperparameters support hyperparameter optimization (HPO). For more information, see aws-forecast-choosing-recipes. If you included the HPOConfig object, you must set PerformHPO to true.
        public let hpoConfig: HyperParameterTuningJobConfig?
        /// Describes the dataset group that contains the data to use to train the predictor.
        public let inputDataConfig: InputDataConfig
        /// The accuracy metric used to optimize the predictor.
        public let optimizationMetric: OptimizationMetric?
        /// Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it provides and chooses the best algorithm and configuration for your training dataset. The default value is false. In this case, you are required to specify an algorithm. Set PerformAutoML to true to have Amazon Forecast perform AutoML. This is a good option if you aren't sure which algorithm is suitable for your training data. In this case, PerformHPO must be false.
        public let performAutoML: Bool?
        /// Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter values for your training data. The process of performing HPO is known as running a hyperparameter tuning job. The default value is false. In this case, Amazon Forecast uses default hyperparameter values from the chosen algorithm. To override the default values, set PerformHPO to true and, optionally, supply the HyperParameterTuningJobConfig object. The tuning job specifies a metric to optimize, which hyperparameters participate in tuning, and the valid range for each tunable hyperparameter. In this case, you are required to specify an algorithm and PerformAutoML must be false. The following algorithms support HPO:   DeepAR+   CNN-QR
        public let performHPO: Bool?
        /// A name for the predictor.
        public let predictorName: String
        /// The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]?
        /// The hyperparameters to override for model training. The hyperparameters that you can override are listed in the individual algorithms. For the list of supported algorithms, see aws-forecast-choosing-recipes.
        public let trainingParameters: [String: String]?

        public init(algorithmArn: String? = nil, autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil, encryptionConfig: EncryptionConfig? = nil, evaluationParameters: EvaluationParameters? = nil, featurizationConfig: FeaturizationConfig, forecastHorizon: Int, forecastTypes: [String]? = nil, hpoConfig: HyperParameterTuningJobConfig? = nil, inputDataConfig: InputDataConfig, optimizationMetric: OptimizationMetric? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, predictorName: String, tags: [Tag]? = nil, trainingParameters: [String: String]? = nil) {
            self.algorithmArn = algorithmArn
            self.autoMLOverrideStrategy = autoMLOverrideStrategy
            self.encryptionConfig = encryptionConfig
            self.evaluationParameters = evaluationParameters
            self.featurizationConfig = featurizationConfig
            self.forecastHorizon = forecastHorizon
            self.forecastTypes = forecastTypes
            self.hpoConfig = hpoConfig
            self.inputDataConfig = inputDataConfig
            self.optimizationMetric = optimizationMetric
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.predictorName = predictorName
            self.tags = tags
            self.trainingParameters = trainingParameters
        }

        public func validate(name: String) throws {
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, max: 256)
            try self.validate(self.algorithmArn, name: "algorithmArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.encryptionConfig?.validate(name: "\(name).encryptionConfig")
            try self.featurizationConfig.validate(name: "\(name).featurizationConfig")
            try self.forecastTypes?.forEach {
                try validate($0, name: "forecastTypes[]", parent: name, max: 4)
                try validate($0, name: "forecastTypes[]", parent: name, min: 2)
                try validate($0, name: "forecastTypes[]", parent: name, pattern: "^(^0?\\.\\d\\d?$|^mean$)$")
            }
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, max: 20)
            try self.validate(self.forecastTypes, name: "forecastTypes", parent: name, min: 1)
            try self.hpoConfig?.validate(name: "\(name).hpoConfig")
            try self.inputDataConfig.validate(name: "\(name).inputDataConfig")
            try self.validate(self.predictorName, name: "predictorName", parent: name, max: 63)
            try self.validate(self.predictorName, name: "predictorName", parent: name, min: 1)
            try self.validate(self.predictorName, name: "predictorName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.trainingParameters?.forEach {
                try validate($0.key, name: "trainingParameters.key", parent: name, max: 256)
                try validate($0.key, name: "trainingParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\\]+$")
                try validate($0.value, name: "trainingParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "trainingParameters[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\"\\\\\\s]+$")
            }
            try self.validate(self.trainingParameters, name: "trainingParameters", parent: name, max: 100)
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
            case encryptionConfig = "EncryptionConfig"
            case evaluationParameters = "EvaluationParameters"
            case featurizationConfig = "FeaturizationConfig"
            case forecastHorizon = "ForecastHorizon"
            case forecastTypes = "ForecastTypes"
            case hpoConfig = "HPOConfig"
            case inputDataConfig = "InputDataConfig"
            case optimizationMetric = "OptimizationMetric"
            case performAutoML = "PerformAutoML"
            case performHPO = "PerformHPO"
            case predictorName = "PredictorName"
            case tags = "Tags"
            case trainingParameters = "TrainingParameters"
        }
    }

    public struct CreatePredictorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the predictor.
        public let predictorArn: String?

        public init(predictorArn: String? = nil) {
            self.predictorArn = predictorArn
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct CreateWhatIfAnalysisRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the baseline forecast.
        public let forecastArn: String
        /// A list of tags to apply to the what if forecast.
        public let tags: [Tag]?
        /// Defines the set of time series that are used in the what-if analysis with a TimeSeriesIdentifiers object. What-if analyses are performed only for the time series in this object. The TimeSeriesIdentifiers object needs the following information:    DataSource     Format     Schema
        public let timeSeriesSelector: TimeSeriesSelector?
        /// The name of the what-if analysis. Each name must be unique.
        public let whatIfAnalysisName: String

        public init(forecastArn: String, tags: [Tag]? = nil, timeSeriesSelector: TimeSeriesSelector? = nil, whatIfAnalysisName: String) {
            self.forecastArn = forecastArn
            self.tags = tags
            self.timeSeriesSelector = timeSeriesSelector
            self.whatIfAnalysisName = whatIfAnalysisName
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, max: 256)
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.timeSeriesSelector?.validate(name: "\(name).timeSeriesSelector")
            try self.validate(self.whatIfAnalysisName, name: "whatIfAnalysisName", parent: name, max: 63)
            try self.validate(self.whatIfAnalysisName, name: "whatIfAnalysisName", parent: name, min: 1)
            try self.validate(self.whatIfAnalysisName, name: "whatIfAnalysisName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
            case tags = "Tags"
            case timeSeriesSelector = "TimeSeriesSelector"
            case whatIfAnalysisName = "WhatIfAnalysisName"
        }
    }

    public struct CreateWhatIfAnalysisResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the what-if analysis.
        public let whatIfAnalysisArn: String?

        public init(whatIfAnalysisArn: String? = nil) {
            self.whatIfAnalysisArn = whatIfAnalysisArn
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
        }
    }

    public struct CreateWhatIfForecastExportRequest: AWSEncodableShape {
        /// The location where you want to save the forecast and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3 bucket. If encryption is used, Destination must include an Key Management Service (KMS) key. The IAM role must allow Amazon Forecast permission to access the key.
        public let destination: DataDestination
        /// The format of the exported data, CSV or PARQUET.
        public let format: String?
        /// A list of tags to apply to the what if forecast.
        public let tags: [Tag]?
        /// The list of what-if forecast Amazon Resource Names (ARNs) to export.
        public let whatIfForecastArns: [String]
        /// The name of the what-if forecast to export.
        public let whatIfForecastExportName: String

        public init(destination: DataDestination, format: String? = nil, tags: [Tag]? = nil, whatIfForecastArns: [String], whatIfForecastExportName: String) {
            self.destination = destination
            self.format = format
            self.tags = tags
            self.whatIfForecastArns = whatIfForecastArns
            self.whatIfForecastExportName = whatIfForecastExportName
        }

        public func validate(name: String) throws {
            try self.destination.validate(name: "\(name).destination")
            try self.validate(self.format, name: "format", parent: name, max: 7)
            try self.validate(self.format, name: "format", parent: name, pattern: "^CSV|PARQUET$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.whatIfForecastArns.forEach {
                try validate($0, name: "whatIfForecastArns[]", parent: name, max: 300)
                try validate($0, name: "whatIfForecastArns[]", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            }
            try self.validate(self.whatIfForecastArns, name: "whatIfForecastArns", parent: name, max: 50)
            try self.validate(self.whatIfForecastArns, name: "whatIfForecastArns", parent: name, min: 1)
            try self.validate(self.whatIfForecastExportName, name: "whatIfForecastExportName", parent: name, max: 63)
            try self.validate(self.whatIfForecastExportName, name: "whatIfForecastExportName", parent: name, min: 1)
            try self.validate(self.whatIfForecastExportName, name: "whatIfForecastExportName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case destination = "Destination"
            case format = "Format"
            case tags = "Tags"
            case whatIfForecastArns = "WhatIfForecastArns"
            case whatIfForecastExportName = "WhatIfForecastExportName"
        }
    }

    public struct CreateWhatIfForecastExportResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public let whatIfForecastExportArn: String?

        public init(whatIfForecastExportArn: String? = nil) {
            self.whatIfForecastExportArn = whatIfForecastExportArn
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfForecastExportArn = "WhatIfForecastExportArn"
        }
    }

    public struct CreateWhatIfForecastRequest: AWSEncodableShape {
        /// A list of tags to apply to the what if forecast.
        public let tags: [Tag]?
        /// The replacement time series dataset, which contains the rows that you want to change in the related time series dataset. A replacement time series does not need to contain all rows that are in the baseline related time series. Include only the rows (measure-dimension combinations) that you want to include in the what-if forecast. This dataset is merged with the original time series to create a transformed dataset that is used for the what-if analysis. This dataset should contain the items to modify (such as item_id or workforce_type), any relevant dimensions, the timestamp column, and at least one of the related time series columns. This file should not contain duplicate timestamps for the same time series. Timestamps and item_ids not included in this dataset are not included in the what-if analysis.
        public let timeSeriesReplacementsDataSource: TimeSeriesReplacementsDataSource?
        /// The transformations that are applied to the baseline time series. Each transformation contains an action and a set of conditions. An action is applied only when all conditions are met. If no conditions are provided, the action is applied to all items.
        public let timeSeriesTransformations: [TimeSeriesTransformation]?
        /// The Amazon Resource Name (ARN) of the what-if analysis.
        public let whatIfAnalysisArn: String
        /// The name of the what-if forecast. Names must be unique within each what-if analysis.
        public let whatIfForecastName: String

        public init(tags: [Tag]? = nil, timeSeriesReplacementsDataSource: TimeSeriesReplacementsDataSource? = nil, timeSeriesTransformations: [TimeSeriesTransformation]? = nil, whatIfAnalysisArn: String, whatIfForecastName: String) {
            self.tags = tags
            self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
            self.timeSeriesTransformations = timeSeriesTransformations
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfForecastName = whatIfForecastName
        }

        public func validate(name: String) throws {
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.timeSeriesReplacementsDataSource?.validate(name: "\(name).timeSeriesReplacementsDataSource")
            try self.timeSeriesTransformations?.forEach {
                try $0.validate(name: "\(name).timeSeriesTransformations[]")
            }
            try self.validate(self.timeSeriesTransformations, name: "timeSeriesTransformations", parent: name, max: 30)
            try self.validate(self.whatIfAnalysisArn, name: "whatIfAnalysisArn", parent: name, max: 256)
            try self.validate(self.whatIfAnalysisArn, name: "whatIfAnalysisArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.validate(self.whatIfForecastName, name: "whatIfForecastName", parent: name, max: 63)
            try self.validate(self.whatIfForecastName, name: "whatIfForecastName", parent: name, min: 1)
            try self.validate(self.whatIfForecastName, name: "whatIfForecastName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
            case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
            case timeSeriesTransformations = "TimeSeriesTransformations"
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
            case whatIfForecastName = "WhatIfForecastName"
        }
    }

    public struct CreateWhatIfForecastResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public let whatIfForecastArn: String?

        public init(whatIfForecastArn: String? = nil) {
            self.whatIfForecastArn = whatIfForecastArn
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfForecastArn = "WhatIfForecastArn"
        }
    }

    public struct DataConfig: AWSEncodableShape & AWSDecodableShape {
        /// Additional built-in datasets like Holidays and the Weather Index.
        public let additionalDatasets: [AdditionalDataset]?
        /// Aggregation and filling options for attributes in your dataset group.
        public let attributeConfigs: [AttributeConfig]?
        /// The ARN of the dataset group used to train the predictor.
        public let datasetGroupArn: String

        public init(additionalDatasets: [AdditionalDataset]? = nil, attributeConfigs: [AttributeConfig]? = nil, datasetGroupArn: String) {
            self.additionalDatasets = additionalDatasets
            self.attributeConfigs = attributeConfigs
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.additionalDatasets?.forEach {
                try $0.validate(name: "\(name).additionalDatasets[]")
            }
            try self.validate(self.additionalDatasets, name: "additionalDatasets", parent: name, max: 2)
            try self.validate(self.additionalDatasets, name: "additionalDatasets", parent: name, min: 1)
            try self.attributeConfigs?.forEach {
                try $0.validate(name: "\(name).attributeConfigs[]")
            }
            try self.validate(self.attributeConfigs, name: "attributeConfigs", parent: name, max: 50)
            try self.validate(self.attributeConfigs, name: "attributeConfigs", parent: name, min: 1)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case additionalDatasets = "AdditionalDatasets"
            case attributeConfigs = "AttributeConfigs"
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct DataDestination: AWSEncodableShape & AWSDecodableShape {
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the bucket.
        public let s3Config: S3Config

        public init(s3Config: S3Config) {
            self.s3Config = s3Config
        }

        public func validate(name: String) throws {
            try self.s3Config.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct DataSource: AWSEncodableShape & AWSDecodableShape {
        /// The path to the data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the data.
        public let s3Config: S3Config

        public init(s3Config: S3Config) {
            self.s3Config = s3Config
        }

        public func validate(name: String) throws {
            try self.s3Config.validate(name: "\(name).s3Config")
        }

        private enum CodingKeys: String, CodingKey {
            case s3Config = "S3Config"
        }
    }

    public struct DatasetGroupSummary: AWSDecodableShape {
        /// When the dataset group was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String?
        /// The name of the dataset group.
        public let datasetGroupName: String?
        /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated, LastModificationTime is the current time of the ListDatasetGroups call.
        public let lastModificationTime: Date?

        public init(creationTime: Date? = nil, datasetGroupArn: String? = nil, datasetGroupName: String? = nil, lastModificationTime: Date? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case datasetGroupName = "DatasetGroupName"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public struct DatasetImportJobSummary: AWSDecodableShape {
        /// When the dataset import job was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String?
        /// The name of the dataset import job.
        public let datasetImportJobName: String?
        /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. The training data must be stored in an Amazon S3 bucket. If encryption is used, DataSource includes an Key Management Service (KMS) key.
        public let dataSource: DataSource?
        /// The import mode of the dataset import job, FULL or INCREMENTAL.
        public let importMode: ImportMode?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the dataset import job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED
        public let status: String?

        public init(creationTime: Date? = nil, datasetImportJobArn: String? = nil, datasetImportJobName: String? = nil, dataSource: DataSource? = nil, importMode: ImportMode? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSource = dataSource
            self.importMode = importMode
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetImportJobArn = "DatasetImportJobArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSource = "DataSource"
            case importMode = "ImportMode"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct DatasetSummary: AWSDecodableShape {
        /// When the dataset was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The dataset type.
        public let datasetType: DatasetType?
        /// The domain associated with the dataset.
        public let domain: Domain?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the ListDatasets call. After a CreateDatasetImportJob operation has finished, LastModificationTime is when the import job completed or failed.
        public let lastModificationTime: Date?

        public init(creationTime: Date? = nil, datasetArn: String? = nil, datasetName: String? = nil, datasetType: DatasetType? = nil, domain: Domain? = nil, lastModificationTime: Date? = nil) {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.lastModificationTime = lastModificationTime
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArn = "DatasetArn"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case lastModificationTime = "LastModificationTime"
        }
    }

    public struct DeleteDatasetGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group to delete.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct DeleteDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job to delete.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, max: 256)
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset to delete.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct DeleteExplainabilityExportRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Explainability export to delete.
        public let explainabilityExportArn: String

        public init(explainabilityExportArn: String) {
            self.explainabilityExportArn = explainabilityExportArn
        }

        public func validate(name: String) throws {
            try self.validate(self.explainabilityExportArn, name: "explainabilityExportArn", parent: name, max: 256)
            try self.validate(self.explainabilityExportArn, name: "explainabilityExportArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityExportArn = "ExplainabilityExportArn"
        }
    }

    public struct DeleteExplainabilityRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Explainability resource to delete.
        public let explainabilityArn: String

        public init(explainabilityArn: String) {
            self.explainabilityArn = explainabilityArn
        }

        public func validate(name: String) throws {
            try self.validate(self.explainabilityArn, name: "explainabilityArn", parent: name, max: 256)
            try self.validate(self.explainabilityArn, name: "explainabilityArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityArn = "ExplainabilityArn"
        }
    }

    public struct DeleteForecastExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast export job to delete.
        public let forecastExportJobArn: String

        public init(forecastExportJobArn: String) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, max: 256)
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct DeleteForecastRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast to delete.
        public let forecastArn: String

        public init(forecastArn: String) {
            self.forecastArn = forecastArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, max: 256)
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct DeleteMonitorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the monitor resource to delete.
        public let monitorArn: String

        public init(monitorArn: String) {
            self.monitorArn = monitorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 256)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
        }
    }

    public struct DeletePredictorBacktestExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor backtest export job to delete.
        public let predictorBacktestExportJobArn: String

        public init(predictorBacktestExportJobArn: String) {
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, max: 256)
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        }
    }

    public struct DeletePredictorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor to delete.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DeleteResourceTreeRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the parent resource to delete. All child resources of the parent resource will also be deleted.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct DeleteWhatIfAnalysisRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the what-if analysis that you want to delete.
        public let whatIfAnalysisArn: String

        public init(whatIfAnalysisArn: String) {
            self.whatIfAnalysisArn = whatIfAnalysisArn
        }

        public func validate(name: String) throws {
            try self.validate(self.whatIfAnalysisArn, name: "whatIfAnalysisArn", parent: name, max: 256)
            try self.validate(self.whatIfAnalysisArn, name: "whatIfAnalysisArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
        }
    }

    public struct DeleteWhatIfForecastExportRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the what-if forecast export that you want to delete.
        public let whatIfForecastExportArn: String

        public init(whatIfForecastExportArn: String) {
            self.whatIfForecastExportArn = whatIfForecastExportArn
        }

        public func validate(name: String) throws {
            try self.validate(self.whatIfForecastExportArn, name: "whatIfForecastExportArn", parent: name, max: 300)
            try self.validate(self.whatIfForecastExportArn, name: "whatIfForecastExportArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfForecastExportArn = "WhatIfForecastExportArn"
        }
    }

    public struct DeleteWhatIfForecastRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the what-if forecast that you want to delete.
        public let whatIfForecastArn: String

        public init(whatIfForecastArn: String) {
            self.whatIfForecastArn = whatIfForecastArn
        }

        public func validate(name: String) throws {
            try self.validate(self.whatIfForecastArn, name: "whatIfForecastArn", parent: name, max: 300)
            try self.validate(self.whatIfForecastArn, name: "whatIfForecastArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfForecastArn = "WhatIfForecastArn"
        }
    }

    public struct DescribeAutoPredictorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DescribeAutoPredictorResponse: AWSDecodableShape {
        /// The timestamp of the CreateAutoPredictor request.
        public let creationTime: Date?
        /// The data configuration for your dataset group and any additional datasets.
        public let dataConfig: DataConfig?
        /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
        public let datasetImportJobArns: [String]?
        public let encryptionConfig: EncryptionConfig?
        /// The estimated time remaining in minutes for the predictor training job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// Provides the status and ARN of the Predictor Explainability.
        public let explainabilityInfo: ExplainabilityInfo?
        /// An array of dimension (field) names that specify the attributes used to group your time series.
        public let forecastDimensions: [String]?
        /// The frequency of predictions in a forecast. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "Y" indicates every year and "5min" indicates every five minutes.
        public let forecastFrequency: String?
        /// The number of time-steps that the model predicts. The forecast horizon is also called the prediction length.
        public let forecastHorizon: Int?
        /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"].
        public let forecastTypes: [String]?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// In the event of an error, a message detailing the cause of the error.
        public let message: String?
        /// A  object with the Amazon Resource Name (ARN) and status of the monitor resource.
        public let monitorInfo: MonitorInfo?
        /// The accuracy metric used to optimize the predictor.
        public let optimizationMetric: OptimizationMetric?
        /// The Amazon Resource Name (ARN) of the predictor
        public let predictorArn: String?
        /// The name of the predictor.
        public let predictorName: String?
        /// The ARN and state of the reference predictor. This parameter is only valid for retrained or upgraded predictors.
        public let referencePredictorSummary: ReferencePredictorSummary?
        /// The status of the predictor. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?
        /// The time boundary Forecast uses when aggregating data.
        public let timeAlignmentBoundary: TimeAlignmentBoundary?

        public init(creationTime: Date? = nil, dataConfig: DataConfig? = nil, datasetImportJobArns: [String]? = nil, encryptionConfig: EncryptionConfig? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, explainabilityInfo: ExplainabilityInfo? = nil, forecastDimensions: [String]? = nil, forecastFrequency: String? = nil, forecastHorizon: Int? = nil, forecastTypes: [String]? = nil, lastModificationTime: Date? = nil, message: String? = nil, monitorInfo: MonitorInfo? = nil, optimizationMetric: OptimizationMetric? = nil, predictorArn: String? = nil, predictorName: String? = nil, referencePredictorSummary: ReferencePredictorSummary? = nil, status: String? = nil, timeAlignmentBoundary: TimeAlignmentBoundary? = nil) {
            self.creationTime = creationTime
            self.dataConfig = dataConfig
            self.datasetImportJobArns = datasetImportJobArns
            self.encryptionConfig = encryptionConfig
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.explainabilityInfo = explainabilityInfo
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
            self.forecastHorizon = forecastHorizon
            self.forecastTypes = forecastTypes
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.monitorInfo = monitorInfo
            self.optimizationMetric = optimizationMetric
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.referencePredictorSummary = referencePredictorSummary
            self.status = status
            self.timeAlignmentBoundary = timeAlignmentBoundary
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataConfig = "DataConfig"
            case datasetImportJobArns = "DatasetImportJobArns"
            case encryptionConfig = "EncryptionConfig"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case explainabilityInfo = "ExplainabilityInfo"
            case forecastDimensions = "ForecastDimensions"
            case forecastFrequency = "ForecastFrequency"
            case forecastHorizon = "ForecastHorizon"
            case forecastTypes = "ForecastTypes"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case monitorInfo = "MonitorInfo"
            case optimizationMetric = "OptimizationMetric"
            case predictorArn = "PredictorArn"
            case predictorName = "PredictorName"
            case referencePredictorSummary = "ReferencePredictorSummary"
            case status = "Status"
            case timeAlignmentBoundary = "TimeAlignmentBoundary"
        }
    }

    public struct DescribeDatasetGroupRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String

        public init(datasetGroupArn: String) {
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct DescribeDatasetGroupResponse: AWSDecodableShape {
        /// When the dataset group was created.
        public let creationTime: Date?
        /// An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset group.
        public let datasetArns: [String]?
        /// The ARN of the dataset group.
        public let datasetGroupArn: String?
        /// The name of the dataset group.
        public let datasetGroupName: String?
        /// The domain associated with the dataset group.
        public let domain: Domain?
        /// When the dataset group was created or last updated from a call to the UpdateDatasetGroup operation. While the dataset group is being updated, LastModificationTime is the current time of the DescribeDatasetGroup call.
        public let lastModificationTime: Date?
        /// The status of the dataset group. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED    The UPDATE states apply when you call the UpdateDatasetGroup operation.  The Status of the dataset group must be ACTIVE before you can use the dataset group to create a predictor.
        public let status: String?

        public init(creationTime: Date? = nil, datasetArns: [String]? = nil, datasetGroupArn: String? = nil, datasetGroupName: String? = nil, domain: Domain? = nil, lastModificationTime: Date? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetArns = datasetArns
            self.datasetGroupArn = datasetGroupArn
            self.datasetGroupName = datasetGroupName
            self.domain = domain
            self.lastModificationTime = lastModificationTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArns = "DatasetArns"
            case datasetGroupArn = "DatasetGroupArn"
            case datasetGroupName = "DatasetGroupName"
            case domain = "Domain"
            case lastModificationTime = "LastModificationTime"
            case status = "Status"
        }
    }

    public struct DescribeDatasetImportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job.
        public let datasetImportJobArn: String

        public init(datasetImportJobArn: String) {
            self.datasetImportJobArn = datasetImportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, max: 256)
            try self.validate(self.datasetImportJobArn, name: "datasetImportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
        }
    }

    public struct DescribeDatasetImportJobResponse: AWSDecodableShape {
        /// When the dataset import job was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset that the training data was imported to.
        public let datasetArn: String?
        /// The ARN of the dataset import job.
        public let datasetImportJobArn: String?
        /// The name of the dataset import job.
        public let datasetImportJobName: String?
        /// The size of the dataset in gigabytes (GB) after the import job has finished.
        public let dataSize: Double?
        /// The location of the training data to import and an Identity and Access Management (IAM) role that Amazon Forecast can assume to access the data. If encryption is used, DataSource includes an Key Management Service (KMS) key.
        public let dataSource: DataSource?
        /// The estimated time remaining in minutes for the dataset import job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// Statistical information about each field in the input data.
        public let fieldStatistics: [String: Statistics]?
        /// The format of the imported data, CSV or PARQUET.
        public let format: String?
        /// The format of the geolocation attribute. Valid Values:"LAT_LONG" and "CC_POSTALCODE".
        public let geolocationFormat: String?
        /// The import mode of the dataset import job, FULL or INCREMENTAL.
        public let importMode: ImportMode?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the dataset import job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED
        public let status: String?
        /// The format of timestamps in the dataset. The format that you specify depends on the DataFrequency specified when the dataset was created. The following formats are supported   "yyyy-MM-dd" For the following data frequencies: Y, M, W, and D   "yyyy-MM-dd HH:mm:ss" For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y, M, W, and D
        public let timestampFormat: String?
        /// The single time zone applied to every item in the dataset
        public let timeZone: String?
        /// Whether TimeZone is automatically derived from the geolocation attribute.
        public let useGeolocationForTimeZone: Bool?

        public init(creationTime: Date? = nil, datasetArn: String? = nil, datasetImportJobArn: String? = nil, datasetImportJobName: String? = nil, dataSize: Double? = nil, dataSource: DataSource? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, fieldStatistics: [String: Statistics]? = nil, format: String? = nil, geolocationFormat: String? = nil, importMode: ImportMode? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, timestampFormat: String? = nil, timeZone: String? = nil, useGeolocationForTimeZone: Bool? = nil) {
            self.creationTime = creationTime
            self.datasetArn = datasetArn
            self.datasetImportJobArn = datasetImportJobArn
            self.datasetImportJobName = datasetImportJobName
            self.dataSize = dataSize
            self.dataSource = dataSource
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.fieldStatistics = fieldStatistics
            self.format = format
            self.geolocationFormat = geolocationFormat
            self.importMode = importMode
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.timestampFormat = timestampFormat
            self.timeZone = timeZone
            self.useGeolocationForTimeZone = useGeolocationForTimeZone
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetArn = "DatasetArn"
            case datasetImportJobArn = "DatasetImportJobArn"
            case datasetImportJobName = "DatasetImportJobName"
            case dataSize = "DataSize"
            case dataSource = "DataSource"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case fieldStatistics = "FieldStatistics"
            case format = "Format"
            case geolocationFormat = "GeolocationFormat"
            case importMode = "ImportMode"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case timestampFormat = "TimestampFormat"
            case timeZone = "TimeZone"
            case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
        }
    }

    public struct DescribeDatasetRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String

        public init(datasetArn: String) {
            self.datasetArn = datasetArn
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, max: 256)
            try self.validate(self.datasetArn, name: "datasetArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArn = "DatasetArn"
        }
    }

    public struct DescribeDatasetResponse: AWSDecodableShape {
        /// When the dataset was created.
        public let creationTime: Date?
        /// The frequency of data collection. Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes), 15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example, "M" indicates every month and "30min" indicates every 30 minutes.
        public let dataFrequency: String?
        /// The Amazon Resource Name (ARN) of the dataset.
        public let datasetArn: String?
        /// The name of the dataset.
        public let datasetName: String?
        /// The dataset type.
        public let datasetType: DatasetType?
        /// The domain associated with the dataset.
        public let domain: Domain?
        /// The Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// When you create a dataset, LastModificationTime is the same as CreationTime. While data is being imported to the dataset, LastModificationTime is the current time of the DescribeDataset call. After a CreateDatasetImportJob operation has finished, LastModificationTime is when the import job completed or failed.
        public let lastModificationTime: Date?
        /// An array of SchemaAttribute objects that specify the dataset fields. Each SchemaAttribute specifies the name and data type of a field.
        public let schema: Schema?
        /// The status of the dataset. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     UPDATE_PENDING, UPDATE_IN_PROGRESS, UPDATE_FAILED    The UPDATE states apply while data is imported to the dataset from a call to the CreateDatasetImportJob operation and reflect the status of the dataset import job. For example, when the import job status is CREATE_IN_PROGRESS, the status of the dataset is UPDATE_IN_PROGRESS.  The Status of the dataset must be ACTIVE before you can import training data.
        public let status: String?

        public init(creationTime: Date? = nil, dataFrequency: String? = nil, datasetArn: String? = nil, datasetName: String? = nil, datasetType: DatasetType? = nil, domain: Domain? = nil, encryptionConfig: EncryptionConfig? = nil, lastModificationTime: Date? = nil, schema: Schema? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.dataFrequency = dataFrequency
            self.datasetArn = datasetArn
            self.datasetName = datasetName
            self.datasetType = datasetType
            self.domain = domain
            self.encryptionConfig = encryptionConfig
            self.lastModificationTime = lastModificationTime
            self.schema = schema
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataFrequency = "DataFrequency"
            case datasetArn = "DatasetArn"
            case datasetName = "DatasetName"
            case datasetType = "DatasetType"
            case domain = "Domain"
            case encryptionConfig = "EncryptionConfig"
            case lastModificationTime = "LastModificationTime"
            case schema = "Schema"
            case status = "Status"
        }
    }

    public struct DescribeExplainabilityExportRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public let explainabilityExportArn: String

        public init(explainabilityExportArn: String) {
            self.explainabilityExportArn = explainabilityExportArn
        }

        public func validate(name: String) throws {
            try self.validate(self.explainabilityExportArn, name: "explainabilityExportArn", parent: name, max: 256)
            try self.validate(self.explainabilityExportArn, name: "explainabilityExportArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityExportArn = "ExplainabilityExportArn"
        }
    }

    public struct DescribeExplainabilityExportResponse: AWSDecodableShape {
        /// When the Explainability export was created.
        public let creationTime: Date?
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public let explainabilityArn: String?
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public let explainabilityExportArn: String?
        /// The name of the Explainability export.
        public let explainabilityExportName: String?
        /// The format of the exported data, CSV or PARQUET.
        public let format: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// Information about any errors that occurred during the export.
        public let message: String?
        /// The status of the Explainability export. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, explainabilityArn: String? = nil, explainabilityExportArn: String? = nil, explainabilityExportName: String? = nil, format: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.explainabilityArn = explainabilityArn
            self.explainabilityExportArn = explainabilityExportArn
            self.explainabilityExportName = explainabilityExportName
            self.format = format
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case explainabilityArn = "ExplainabilityArn"
            case explainabilityExportArn = "ExplainabilityExportArn"
            case explainabilityExportName = "ExplainabilityExportName"
            case format = "Format"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct DescribeExplainabilityRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Explaianability to describe.
        public let explainabilityArn: String

        public init(explainabilityArn: String) {
            self.explainabilityArn = explainabilityArn
        }

        public func validate(name: String) throws {
            try self.validate(self.explainabilityArn, name: "explainabilityArn", parent: name, max: 256)
            try self.validate(self.explainabilityArn, name: "explainabilityArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityArn = "ExplainabilityArn"
        }
    }

    public struct DescribeExplainabilityResponse: AWSDecodableShape {
        /// When the Explainability resource was created.
        public let creationTime: Date?
        public let dataSource: DataSource?
        /// Whether the visualization was enabled for the Explainability resource.
        public let enableVisualization: Bool?
        /// If TimePointGranularity is set to SPECIFIC, the last time point in the Explainability.
        public let endDateTime: String?
        /// The estimated time remaining in minutes for the CreateExplainability job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// The Amazon Resource Name (ARN) of the Explainability.
        public let explainabilityArn: String?
        /// The configuration settings that define the granularity of time series and time points for the Explainability.
        public let explainabilityConfig: ExplainabilityConfig?
        /// The name of the Explainability.
        public let explainabilityName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, a message about the error.
        public let message: String?
        /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability resource.
        public let resourceArn: String?
        public let schema: Schema?
        /// If TimePointGranularity is set to SPECIFIC, the first time point in the Explainability.
        public let startDateTime: String?
        /// The status of the Explainability resource. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, dataSource: DataSource? = nil, enableVisualization: Bool? = nil, endDateTime: String? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, explainabilityArn: String? = nil, explainabilityConfig: ExplainabilityConfig? = nil, explainabilityName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, resourceArn: String? = nil, schema: Schema? = nil, startDateTime: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.dataSource = dataSource
            self.enableVisualization = enableVisualization
            self.endDateTime = endDateTime
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.explainabilityArn = explainabilityArn
            self.explainabilityConfig = explainabilityConfig
            self.explainabilityName = explainabilityName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.resourceArn = resourceArn
            self.schema = schema
            self.startDateTime = startDateTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case dataSource = "DataSource"
            case enableVisualization = "EnableVisualization"
            case endDateTime = "EndDateTime"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case explainabilityArn = "ExplainabilityArn"
            case explainabilityConfig = "ExplainabilityConfig"
            case explainabilityName = "ExplainabilityName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case resourceArn = "ResourceArn"
            case schema = "Schema"
            case startDateTime = "StartDateTime"
            case status = "Status"
        }
    }

    public struct DescribeForecastExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public let forecastExportJobArn: String

        public init(forecastExportJobArn: String) {
            self.forecastExportJobArn = forecastExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, max: 256)
            try self.validate(self.forecastExportJobArn, name: "forecastExportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobArn = "ForecastExportJobArn"
        }
    }

    public struct DescribeForecastExportJobResponse: AWSDecodableShape {
        /// When the forecast export job was created.
        public let creationTime: Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the exported forecast.
        public let forecastArn: String?
        /// The ARN of the forecast export job.
        public let forecastExportJobArn: String?
        /// The name of the forecast export job.
        public let forecastExportJobName: String?
        /// The format of the exported data, CSV or PARQUET.
        public let format: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the forecast export job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, forecastArn: String? = nil, forecastExportJobArn: String? = nil, forecastExportJobName: String? = nil, format: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastArn = forecastArn
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.format = format
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case forecastArn = "ForecastArn"
            case forecastExportJobArn = "ForecastExportJobArn"
            case forecastExportJobName = "ForecastExportJobName"
            case format = "Format"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct DescribeForecastRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the forecast.
        public let forecastArn: String

        public init(forecastArn: String) {
            self.forecastArn = forecastArn
        }

        public func validate(name: String) throws {
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, max: 256)
            try self.validate(self.forecastArn, name: "forecastArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case forecastArn = "ForecastArn"
        }
    }

    public struct DescribeForecastResponse: AWSDecodableShape {
        /// When the forecast creation task was created.
        public let creationTime: Date?
        /// The ARN of the dataset group that provided the data used to train the predictor.
        public let datasetGroupArn: String?
        /// The estimated time remaining in minutes for the forecast job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// The forecast ARN as specified in the request.
        public let forecastArn: String?
        /// The name of the forecast.
        public let forecastName: String?
        /// The quantiles at which probabilistic forecasts were generated.
        public let forecastTypes: [String]?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor used to generate the forecast.
        public let predictorArn: String?
        /// The status of the forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public let status: String?
        /// The time series to include in the forecast.
        public let timeSeriesSelector: TimeSeriesSelector?

        public init(creationTime: Date? = nil, datasetGroupArn: String? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, forecastArn: String? = nil, forecastName: String? = nil, forecastTypes: [String]? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, status: String? = nil, timeSeriesSelector: TimeSeriesSelector? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.forecastTypes = forecastTypes
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
            self.timeSeriesSelector = timeSeriesSelector
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case forecastArn = "ForecastArn"
            case forecastName = "ForecastName"
            case forecastTypes = "ForecastTypes"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case status = "Status"
            case timeSeriesSelector = "TimeSeriesSelector"
        }
    }

    public struct DescribeMonitorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the monitor resource to describe.
        public let monitorArn: String

        public init(monitorArn: String) {
            self.monitorArn = monitorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 256)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
        }
    }

    public struct DescribeMonitorResponse: AWSDecodableShape {
        /// Metrics you can use as a baseline for comparison purposes. Use these values you interpret monitoring results for an auto predictor.
        public let baseline: Baseline?
        /// The timestamp for when the monitor resource was created.
        public let creationTime: Date?
        /// The estimated number of minutes remaining before the monitor resource finishes its current evaluation.
        public let estimatedEvaluationTimeRemainingInMinutes: Int64?
        /// The state of the monitor's latest evaluation.
        public let lastEvaluationState: String?
        /// The timestamp of the latest evaluation completed by the monitor.
        public let lastEvaluationTime: Date?
        /// The timestamp of the latest modification to the monitor.
        public let lastModificationTime: Date?
        /// An error message, if any, for the monitor.
        public let message: String?
        /// The Amazon Resource Name (ARN) of the monitor resource described.
        public let monitorArn: String?
        /// The name of the monitor.
        public let monitorName: String?
        /// The Amazon Resource Name (ARN) of the auto predictor being monitored.
        public let resourceArn: String?
        /// The status of the monitor resource.
        public let status: String?

        public init(baseline: Baseline? = nil, creationTime: Date? = nil, estimatedEvaluationTimeRemainingInMinutes: Int64? = nil, lastEvaluationState: String? = nil, lastEvaluationTime: Date? = nil, lastModificationTime: Date? = nil, message: String? = nil, monitorArn: String? = nil, monitorName: String? = nil, resourceArn: String? = nil, status: String? = nil) {
            self.baseline = baseline
            self.creationTime = creationTime
            self.estimatedEvaluationTimeRemainingInMinutes = estimatedEvaluationTimeRemainingInMinutes
            self.lastEvaluationState = lastEvaluationState
            self.lastEvaluationTime = lastEvaluationTime
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.resourceArn = resourceArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case baseline = "Baseline"
            case creationTime = "CreationTime"
            case estimatedEvaluationTimeRemainingInMinutes = "EstimatedEvaluationTimeRemainingInMinutes"
            case lastEvaluationState = "LastEvaluationState"
            case lastEvaluationTime = "LastEvaluationTime"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case monitorArn = "MonitorArn"
            case monitorName = "MonitorName"
            case resourceArn = "ResourceArn"
            case status = "Status"
        }
    }

    public struct DescribePredictorBacktestExportJobRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public let predictorBacktestExportJobArn: String

        public init(predictorBacktestExportJobArn: String) {
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, max: 256)
            try self.validate(self.predictorBacktestExportJobArn, name: "predictorBacktestExportJobArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        }
    }

    public struct DescribePredictorBacktestExportJobResponse: AWSDecodableShape {
        /// When the predictor backtest export job was created.
        public let creationTime: Date?
        public let destination: DataDestination?
        /// The format of the exported data, CSV or PARQUET.
        public let format: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// Information about any errors that may have occurred during the backtest export.
        public let message: String?
        /// The Amazon Resource Name (ARN) of the predictor.
        public let predictorArn: String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public let predictorBacktestExportJobArn: String?
        /// The name of the predictor backtest export job.
        public let predictorBacktestExportJobName: String?
        /// The status of the predictor backtest export job. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, format: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, predictorBacktestExportJobArn: String? = nil, predictorBacktestExportJobName: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.format = format
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case format = "Format"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
            case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
            case status = "Status"
        }
    }

    public struct DescribePredictorRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor that you want information about.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct DescribePredictorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm used for model training.
        public let algorithmArn: String?
        /// When PerformAutoML is specified, the ARN of the chosen algorithm.
        public let autoMLAlgorithmArns: [String]?
        ///  The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges.   The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
        public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
        /// When the model training task was created.
        public let creationTime: Date?
        /// An array of the ARNs of the dataset import jobs used to import training data for the predictor.
        public let datasetImportJobArns: [String]?
        /// An Key Management Service (KMS) key and the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the key.
        public let encryptionConfig: EncryptionConfig?
        /// The estimated time remaining in minutes for the predictor training job to complete.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast evaluates a predictor by splitting a dataset into training data and testing data. The evaluation parameters define how to perform the split and the number of iterations.
        public let evaluationParameters: EvaluationParameters?
        /// The featurization configuration.
        public let featurizationConfig: FeaturizationConfig?
        /// The number of time-steps of the forecast. The forecast horizon is also called the prediction length.
        public let forecastHorizon: Int?
        /// The forecast types used during predictor training. Default value is ["0.1","0.5","0.9"]
        public let forecastTypes: [String]?
        /// The hyperparameter override values for the algorithm.
        public let hpoConfig: HyperParameterTuningJobConfig?
        /// Describes the dataset group that contains the data to use to train the predictor.
        public let inputDataConfig: InputDataConfig?
        /// Whether the predictor was created with CreateAutoPredictor.
        public let isAutoPredictor: Bool?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The accuracy metric used to optimize the predictor.
        public let optimizationMetric: OptimizationMetric?
        /// Whether the predictor is set to perform AutoML.
        public let performAutoML: Bool?
        /// Whether the predictor is set to perform hyperparameter optimization (HPO).
        public let performHPO: Bool?
        /// The ARN of the predictor.
        public let predictorArn: String?
        /// Details on the the status and results of the backtests performed to evaluate the accuracy of the predictor. You specify the number of backtests to perform when you call the  operation.
        public let predictorExecutionDetails: PredictorExecutionDetails?
        /// The name of the predictor.
        public let predictorName: String?
        /// The status of the predictor. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED     The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public let status: String?
        /// The default training parameters or overrides selected during model training. When running AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen hyperparameters are returned. For more information, see aws-forecast-choosing-recipes.
        public let trainingParameters: [String: String]?

        public init(algorithmArn: String? = nil, autoMLAlgorithmArns: [String]? = nil, autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil, creationTime: Date? = nil, datasetImportJobArns: [String]? = nil, encryptionConfig: EncryptionConfig? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, evaluationParameters: EvaluationParameters? = nil, featurizationConfig: FeaturizationConfig? = nil, forecastHorizon: Int? = nil, forecastTypes: [String]? = nil, hpoConfig: HyperParameterTuningJobConfig? = nil, inputDataConfig: InputDataConfig? = nil, isAutoPredictor: Bool? = nil, lastModificationTime: Date? = nil, message: String? = nil, optimizationMetric: OptimizationMetric? = nil, performAutoML: Bool? = nil, performHPO: Bool? = nil, predictorArn: String? = nil, predictorExecutionDetails: PredictorExecutionDetails? = nil, predictorName: String? = nil, status: String? = nil, trainingParameters: [String: String]? = nil) {
            self.algorithmArn = algorithmArn
            self.autoMLAlgorithmArns = autoMLAlgorithmArns
            self.autoMLOverrideStrategy = autoMLOverrideStrategy
            self.creationTime = creationTime
            self.datasetImportJobArns = datasetImportJobArns
            self.encryptionConfig = encryptionConfig
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.evaluationParameters = evaluationParameters
            self.featurizationConfig = featurizationConfig
            self.forecastHorizon = forecastHorizon
            self.forecastTypes = forecastTypes
            self.hpoConfig = hpoConfig
            self.inputDataConfig = inputDataConfig
            self.isAutoPredictor = isAutoPredictor
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.optimizationMetric = optimizationMetric
            self.performAutoML = performAutoML
            self.performHPO = performHPO
            self.predictorArn = predictorArn
            self.predictorExecutionDetails = predictorExecutionDetails
            self.predictorName = predictorName
            self.status = status
            self.trainingParameters = trainingParameters
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
            case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
            case creationTime = "CreationTime"
            case datasetImportJobArns = "DatasetImportJobArns"
            case encryptionConfig = "EncryptionConfig"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case evaluationParameters = "EvaluationParameters"
            case featurizationConfig = "FeaturizationConfig"
            case forecastHorizon = "ForecastHorizon"
            case forecastTypes = "ForecastTypes"
            case hpoConfig = "HPOConfig"
            case inputDataConfig = "InputDataConfig"
            case isAutoPredictor = "IsAutoPredictor"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case optimizationMetric = "OptimizationMetric"
            case performAutoML = "PerformAutoML"
            case performHPO = "PerformHPO"
            case predictorArn = "PredictorArn"
            case predictorExecutionDetails = "PredictorExecutionDetails"
            case predictorName = "PredictorName"
            case status = "Status"
            case trainingParameters = "TrainingParameters"
        }
    }

    public struct DescribeWhatIfAnalysisRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the what-if analysis that you are interested in.
        public let whatIfAnalysisArn: String

        public init(whatIfAnalysisArn: String) {
            self.whatIfAnalysisArn = whatIfAnalysisArn
        }

        public func validate(name: String) throws {
            try self.validate(self.whatIfAnalysisArn, name: "whatIfAnalysisArn", parent: name, max: 256)
            try self.validate(self.whatIfAnalysisArn, name: "whatIfAnalysisArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
        }
    }

    public struct DescribeWhatIfAnalysisResponse: AWSDecodableShape {
        /// When the what-if analysis was created.
        public let creationTime: Date?
        /// The approximate time remaining to complete the what-if analysis, in minutes.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public let forecastArn: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the what-if analysis. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public let status: String?
        public let timeSeriesSelector: TimeSeriesSelector?
        /// The Amazon Resource Name (ARN) of the what-if analysis.
        public let whatIfAnalysisArn: String?
        /// The name of the what-if analysis.
        public let whatIfAnalysisName: String?

        public init(creationTime: Date? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, forecastArn: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, timeSeriesSelector: TimeSeriesSelector? = nil, whatIfAnalysisArn: String? = nil, whatIfAnalysisName: String? = nil) {
            self.creationTime = creationTime
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.forecastArn = forecastArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.timeSeriesSelector = timeSeriesSelector
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfAnalysisName = whatIfAnalysisName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case forecastArn = "ForecastArn"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case timeSeriesSelector = "TimeSeriesSelector"
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
            case whatIfAnalysisName = "WhatIfAnalysisName"
        }
    }

    public struct DescribeWhatIfForecastExportRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the what-if forecast export that you are interested in.
        public let whatIfForecastExportArn: String

        public init(whatIfForecastExportArn: String) {
            self.whatIfForecastExportArn = whatIfForecastExportArn
        }

        public func validate(name: String) throws {
            try self.validate(self.whatIfForecastExportArn, name: "whatIfForecastExportArn", parent: name, max: 300)
            try self.validate(self.whatIfForecastExportArn, name: "whatIfForecastExportArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfForecastExportArn = "WhatIfForecastExportArn"
        }
    }

    public struct DescribeWhatIfForecastExportResponse: AWSDecodableShape {
        /// When the what-if forecast export was created.
        public let creationTime: Date?
        public let destination: DataDestination?
        /// The approximate time remaining to complete the what-if forecast export, in minutes.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// The format of the exported data, CSV or PARQUET.
        public let format: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the what-if forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the what-if forecast export must be ACTIVE before you can access the forecast export.
        public let status: String?
        /// An array of Amazon Resource Names (ARNs) that represent all of the what-if forecasts exported in this resource.
        public let whatIfForecastArns: [String]?
        /// The Amazon Resource Name (ARN) of the what-if forecast export.
        public let whatIfForecastExportArn: String?
        /// The name of the what-if forecast export.
        public let whatIfForecastExportName: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, format: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, whatIfForecastArns: [String]? = nil, whatIfForecastExportArn: String? = nil, whatIfForecastExportName: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.format = format
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfForecastArns = whatIfForecastArns
            self.whatIfForecastExportArn = whatIfForecastExportArn
            self.whatIfForecastExportName = whatIfForecastExportName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case format = "Format"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case whatIfForecastArns = "WhatIfForecastArns"
            case whatIfForecastExportArn = "WhatIfForecastExportArn"
            case whatIfForecastExportName = "WhatIfForecastExportName"
        }
    }

    public struct DescribeWhatIfForecastRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the what-if forecast that you are interested in.
        public let whatIfForecastArn: String

        public init(whatIfForecastArn: String) {
            self.whatIfForecastArn = whatIfForecastArn
        }

        public func validate(name: String) throws {
            try self.validate(self.whatIfForecastArn, name: "whatIfForecastArn", parent: name, max: 300)
            try self.validate(self.whatIfForecastArn, name: "whatIfForecastArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case whatIfForecastArn = "WhatIfForecastArn"
        }
    }

    public struct DescribeWhatIfForecastResponse: AWSDecodableShape {
        /// When the what-if forecast was created.
        public let creationTime: Date?
        /// The approximate time remaining to complete the what-if forecast, in minutes.
        public let estimatedTimeRemainingInMinutes: Int64?
        /// The quantiles at which probabilistic forecasts are generated. You can specify up to five quantiles per what-if forecast in the CreateWhatIfForecast operation. If you didn't specify quantiles, the default values are ["0.1", "0.5", "0.9"].
        public let forecastTypes: [String]?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the what-if forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the what-if forecast must be ACTIVE before you can access the forecast.
        public let status: String?
        /// An array of S3Config, Schema, and Format elements that describe the replacement time series.
        public let timeSeriesReplacementsDataSource: TimeSeriesReplacementsDataSource?
        /// An array of Action and TimeSeriesConditions elements that describe what transformations were applied to which time series.
        public let timeSeriesTransformations: [TimeSeriesTransformation]?
        /// The Amazon Resource Name (ARN) of the what-if analysis that contains this forecast.
        public let whatIfAnalysisArn: String?
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public let whatIfForecastArn: String?
        /// The name of the what-if forecast.
        public let whatIfForecastName: String?

        public init(creationTime: Date? = nil, estimatedTimeRemainingInMinutes: Int64? = nil, forecastTypes: [String]? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, timeSeriesReplacementsDataSource: TimeSeriesReplacementsDataSource? = nil, timeSeriesTransformations: [TimeSeriesTransformation]? = nil, whatIfAnalysisArn: String? = nil, whatIfForecastArn: String? = nil, whatIfForecastName: String? = nil) {
            self.creationTime = creationTime
            self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
            self.forecastTypes = forecastTypes
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.timeSeriesReplacementsDataSource = timeSeriesReplacementsDataSource
            self.timeSeriesTransformations = timeSeriesTransformations
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfForecastArn = whatIfForecastArn
            self.whatIfForecastName = whatIfForecastName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
            case forecastTypes = "ForecastTypes"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case timeSeriesReplacementsDataSource = "TimeSeriesReplacementsDataSource"
            case timeSeriesTransformations = "TimeSeriesTransformations"
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
            case whatIfForecastArn = "WhatIfForecastArn"
            case whatIfForecastName = "WhatIfForecastName"
        }
    }

    public struct EncryptionConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the KMS key.
        public let kmsKeyArn: String
        /// The ARN of the IAM role that Amazon Forecast can assume to access the KMS key. Passing a role across Amazon Web Services accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        public let roleArn: String

        public init(kmsKeyArn: String, roleArn: String) {
            self.kmsKeyArn = kmsKeyArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 256)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:.*:key/")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KMSKeyArn"
            case roleArn = "RoleArn"
        }
    }

    public struct ErrorMetric: AWSDecodableShape {
        ///  The Forecast type used to compute WAPE, MAPE, MASE, and RMSE.
        public let forecastType: String?
        /// The Mean Absolute Percentage Error (MAPE)
        public let mape: Double?
        /// The Mean Absolute Scaled Error (MASE)
        public let mase: Double?
        ///  The root-mean-square error (RMSE).
        public let rmse: Double?
        ///  The weighted absolute percentage error (WAPE).
        public let wape: Double?

        public init(forecastType: String? = nil, mape: Double? = nil, mase: Double? = nil, rmse: Double? = nil, wape: Double? = nil) {
            self.forecastType = forecastType
            self.mape = mape
            self.mase = mase
            self.rmse = rmse
            self.wape = wape
        }

        private enum CodingKeys: String, CodingKey {
            case forecastType = "ForecastType"
            case mape = "MAPE"
            case mase = "MASE"
            case rmse = "RMSE"
            case wape = "WAPE"
        }
    }

    public struct EvaluationParameters: AWSEncodableShape & AWSDecodableShape {
        /// The point from the end of the dataset where you want to split the data for model training and testing (evaluation). Specify the value as the number of data points. The default is the value of the forecast horizon. BackTestWindowOffset can be used to mimic a past virtual forecast start date. This value must be greater than or equal to the forecast horizon and less than half of the TARGET_TIME_SERIES dataset length.  ForecastHorizon BackTestWindowOffset
        public let backTestWindowOffset: Int?
        /// The number of times to split the input data. The default is 1. Valid values are 1 through 5.
        public let numberOfBacktestWindows: Int?

        public init(backTestWindowOffset: Int? = nil, numberOfBacktestWindows: Int? = nil) {
            self.backTestWindowOffset = backTestWindowOffset
            self.numberOfBacktestWindows = numberOfBacktestWindows
        }

        private enum CodingKeys: String, CodingKey {
            case backTestWindowOffset = "BackTestWindowOffset"
            case numberOfBacktestWindows = "NumberOfBacktestWindows"
        }
    }

    public struct EvaluationResult: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the algorithm that was evaluated.
        public let algorithmArn: String?
        /// The array of test windows used for evaluating the algorithm. The NumberOfBacktestWindows from the EvaluationParameters object determines the number of windows in the array.
        public let testWindows: [WindowSummary]?

        public init(algorithmArn: String? = nil, testWindows: [WindowSummary]? = nil) {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case testWindows = "TestWindows"
        }
    }

    public struct ExplainabilityConfig: AWSEncodableShape & AWSDecodableShape {
        /// To create an Explainability for all time points in your forecast horizon, use ALL. To create an Explainability for specific time points in your forecast horizon, use SPECIFIC. Specify time points with the StartDateTime and EndDateTime parameters within the CreateExplainability operation.
        public let timePointGranularity: TimePointGranularity
        /// To create an Explainability for all time series in your datasets, use ALL. To create an Explainability for specific time series in your datasets, use SPECIFIC. Specify time series by uploading a CSV or Parquet file to an Amazon S3 bucket and set the location within the DataDestination data type.
        public let timeSeriesGranularity: TimeSeriesGranularity

        public init(timePointGranularity: TimePointGranularity, timeSeriesGranularity: TimeSeriesGranularity) {
            self.timePointGranularity = timePointGranularity
            self.timeSeriesGranularity = timeSeriesGranularity
        }

        private enum CodingKeys: String, CodingKey {
            case timePointGranularity = "TimePointGranularity"
            case timeSeriesGranularity = "TimeSeriesGranularity"
        }
    }

    public struct ExplainabilityExportSummary: AWSDecodableShape {
        /// When the Explainability was created.
        public let creationTime: Date?
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the Explainability export.
        public let explainabilityExportArn: String?
        /// The name of the Explainability export
        public let explainabilityExportName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// Information about any errors that may have occurred during the Explainability export.
        public let message: String?
        /// The status of the Explainability export. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, explainabilityExportArn: String? = nil, explainabilityExportName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.explainabilityExportArn = explainabilityExportArn
            self.explainabilityExportName = explainabilityExportName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case explainabilityExportArn = "ExplainabilityExportArn"
            case explainabilityExportName = "ExplainabilityExportName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct ExplainabilityInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Explainability.
        public let explainabilityArn: String?
        /// The status of the Explainability. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(explainabilityArn: String? = nil, status: String? = nil) {
            self.explainabilityArn = explainabilityArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityArn = "ExplainabilityArn"
            case status = "Status"
        }
    }

    public struct ExplainabilitySummary: AWSDecodableShape {
        /// When the Explainability was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the Explainability.
        public let explainabilityArn: String?
        /// The configuration settings that define the granularity of time series and time points for the Explainability.
        public let explainabilityConfig: ExplainabilityConfig?
        /// The name of the Explainability.
        public let explainabilityName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// Information about any errors that may have occurred during the Explainability creation process.
        public let message: String?
        /// The Amazon Resource Name (ARN) of the Predictor or Forecast used to create the Explainability.
        public let resourceArn: String?
        /// The status of the Explainability. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, explainabilityArn: String? = nil, explainabilityConfig: ExplainabilityConfig? = nil, explainabilityName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, resourceArn: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.explainabilityArn = explainabilityArn
            self.explainabilityConfig = explainabilityConfig
            self.explainabilityName = explainabilityName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.resourceArn = resourceArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case explainabilityArn = "ExplainabilityArn"
            case explainabilityConfig = "ExplainabilityConfig"
            case explainabilityName = "ExplainabilityName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case resourceArn = "ResourceArn"
            case status = "Status"
        }
    }

    public struct Featurization: AWSEncodableShape & AWSDecodableShape {
        /// The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of the TARGET_TIME_SERIES and the RELATED_TIME_SERIES datasets. For example, for the RETAIL domain, the target is demand, and for the CUSTOM domain, the target is target_value. For more information, see howitworks-missing-values.
        public let attributeName: String
        /// An array of one FeaturizationMethod object that specifies the feature transformation method.
        public let featurizationPipeline: [FeaturizationMethod]?

        public init(attributeName: String, featurizationPipeline: [FeaturizationMethod]? = nil) {
            self.attributeName = attributeName
            self.featurizationPipeline = featurizationPipeline
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 63)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.featurizationPipeline?.forEach {
                try $0.validate(name: "\(name).featurizationPipeline[]")
            }
            try self.validate(self.featurizationPipeline, name: "featurizationPipeline", parent: name, max: 1)
            try self.validate(self.featurizationPipeline, name: "featurizationPipeline", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case featurizationPipeline = "FeaturizationPipeline"
        }
    }

    public struct FeaturizationConfig: AWSEncodableShape & AWSDecodableShape {
        /// An array of featurization (transformation) information for the fields of a dataset.
        public let featurizations: [Featurization]?
        /// An array of dimension (field) names that specify how to group the generated forecast. For example, suppose that you are generating a forecast for item sales across all of your stores, and your dataset contains a store_id field. If you want the sales forecast for each item by store, you would specify store_id as the dimension. All forecast dimensions specified in the TARGET_TIME_SERIES dataset don't need to be specified in the CreatePredictor request. All forecast dimensions specified in the RELATED_TIME_SERIES dataset must be specified in the CreatePredictor request.
        public let forecastDimensions: [String]?
        /// The frequency of predictions in a forecast. Valid intervals are an integer followed by Y (Year), M (Month), W (Week), D (Day), H (Hour), and min (Minute). For example, "1D" indicates every day and "15min" indicates every 15 minutes. You cannot specify a value that would overlap with the next larger frequency. That means, for example, you cannot specify a frequency of 60 minutes, because that is equivalent to 1 hour. The valid values for each frequency are the following:   Minute - 1-59   Hour - 1-23   Day - 1-6   Week - 1-4   Month - 1-11   Year - 1   Thus, if you want every other week forecasts, specify "2W". Or, if you want quarterly forecasts, you specify "3M". The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset frequency. When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the TARGET_TIME_SERIES dataset frequency.
        public let forecastFrequency: String

        public init(featurizations: [Featurization]? = nil, forecastDimensions: [String]? = nil, forecastFrequency: String) {
            self.featurizations = featurizations
            self.forecastDimensions = forecastDimensions
            self.forecastFrequency = forecastFrequency
        }

        public func validate(name: String) throws {
            try self.featurizations?.forEach {
                try $0.validate(name: "\(name).featurizations[]")
            }
            try self.validate(self.featurizations, name: "featurizations", parent: name, max: 50)
            try self.validate(self.featurizations, name: "featurizations", parent: name, min: 1)
            try self.forecastDimensions?.forEach {
                try validate($0, name: "forecastDimensions[]", parent: name, max: 63)
                try validate($0, name: "forecastDimensions[]", parent: name, min: 1)
                try validate($0, name: "forecastDimensions[]", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            }
            try self.validate(self.forecastDimensions, name: "forecastDimensions", parent: name, max: 10)
            try self.validate(self.forecastDimensions, name: "forecastDimensions", parent: name, min: 1)
            try self.validate(self.forecastFrequency, name: "forecastFrequency", parent: name, max: 5)
            try self.validate(self.forecastFrequency, name: "forecastFrequency", parent: name, min: 1)
            try self.validate(self.forecastFrequency, name: "forecastFrequency", parent: name, pattern: "^Y|M|W|D|H|30min|15min|10min|5min|1min$")
        }

        private enum CodingKeys: String, CodingKey {
            case featurizations = "Featurizations"
            case forecastDimensions = "ForecastDimensions"
            case forecastFrequency = "ForecastFrequency"
        }
    }

    public struct FeaturizationMethod: AWSEncodableShape & AWSDecodableShape {
        /// The name of the method. The "filling" method is the only supported method.
        public let featurizationMethodName: FeaturizationMethodName
        /// The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values. Related Time Series attributes do not accept aggregation parameters. The following list shows the parameters and their valid values for the "filling" featurization method for a Target Time Series dataset. Bold signifies the default value.    aggregation: sum, avg, first, min, max     frontfill: none     middlefill: zero, nan (not a number), value, median, mean, min, max     backfill: zero, nan, value, median, mean, min, max    The following list shows the parameters and their valid values for a Related Time Series featurization method (there are no defaults):    middlefill: zero, value, median, mean, min, max     backfill: zero, value, median, mean, min, max     futurefill: zero, value, median, mean, min, max    To set a filling method to a specific value, set the fill parameter to value and define the value in a corresponding _value parameter. For example, to set backfilling to a value of 2, include the following: "backfill": "value" and "backfill_value":"2".
        public let featurizationMethodParameters: [String: String]?

        public init(featurizationMethodName: FeaturizationMethodName, featurizationMethodParameters: [String: String]? = nil) {
            self.featurizationMethodName = featurizationMethodName
            self.featurizationMethodParameters = featurizationMethodParameters
        }

        public func validate(name: String) throws {
            try self.featurizationMethodParameters?.forEach {
                try validate($0.key, name: "featurizationMethodParameters.key", parent: name, max: 256)
                try validate($0.key, name: "featurizationMethodParameters.key", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\\]+$")
                try validate($0.value, name: "featurizationMethodParameters[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "featurizationMethodParameters[\"\($0.key)\"]", parent: name, pattern: "^[a-zA-Z0-9\\-\\_\\.\\/\\[\\]\\,\\\"\\\\\\s]+$")
            }
            try self.validate(self.featurizationMethodParameters, name: "featurizationMethodParameters", parent: name, max: 20)
            try self.validate(self.featurizationMethodParameters, name: "featurizationMethodParameters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case featurizationMethodName = "FeaturizationMethodName"
            case featurizationMethodParameters = "FeaturizationMethodParameters"
        }
    }

    public struct Filter: AWSEncodableShape {
        /// The condition to apply. To include the objects that match the statement, specify IS. To exclude matching objects, specify IS_NOT.
        public let condition: FilterConditionString
        /// The name of the parameter to filter on.
        public let key: String
        /// The value to match.
        public let value: String

        public init(condition: FilterConditionString, key: String, value: String) {
            self.condition = condition
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 256)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9\\_]+$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case key = "Key"
            case value = "Value"
        }
    }

    public struct ForecastExportJobSummary: AWSDecodableShape {
        /// When the forecast export job was created.
        public let creationTime: Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public let destination: DataDestination?
        /// The Amazon Resource Name (ARN) of the forecast export job.
        public let forecastExportJobArn: String?
        /// The name of the forecast export job.
        public let forecastExportJobName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the forecast export job. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast export job must be ACTIVE before you can access the forecast in your S3 bucket.
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, forecastExportJobArn: String? = nil, forecastExportJobName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.forecastExportJobArn = forecastExportJobArn
            self.forecastExportJobName = forecastExportJobName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case forecastExportJobArn = "ForecastExportJobArn"
            case forecastExportJobName = "ForecastExportJobName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
        }
    }

    public struct ForecastSummary: AWSDecodableShape {
        /// Whether the Forecast was created from an AutoPredictor.
        public let createdUsingAutoPredictor: Bool?
        /// When the forecast creation task was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that provided the data used to train the predictor.
        public let datasetGroupArn: String?
        /// The ARN of the forecast.
        public let forecastArn: String?
        /// The name of the forecast.
        public let forecastName: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor used to generate the forecast.
        public let predictorArn: String?
        /// The status of the forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the forecast must be ACTIVE before you can query or export the forecast.
        public let status: String?

        public init(createdUsingAutoPredictor: Bool? = nil, creationTime: Date? = nil, datasetGroupArn: String? = nil, forecastArn: String? = nil, forecastName: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, status: String? = nil) {
            self.createdUsingAutoPredictor = createdUsingAutoPredictor
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.forecastArn = forecastArn
            self.forecastName = forecastName
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case createdUsingAutoPredictor = "CreatedUsingAutoPredictor"
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case forecastArn = "ForecastArn"
            case forecastName = "ForecastName"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case status = "Status"
        }
    }

    public struct GetAccuracyMetricsRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the predictor to get metrics for.
        public let predictorArn: String

        public init(predictorArn: String) {
            self.predictorArn = predictorArn
        }

        public func validate(name: String) throws {
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, max: 256)
            try self.validate(self.predictorArn, name: "predictorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case predictorArn = "PredictorArn"
        }
    }

    public struct GetAccuracyMetricsResponse: AWSDecodableShape {
        ///  The LatencyOptimized AutoML override strategy is only available in private beta. Contact Amazon Web Services Support or your account manager to learn more about access privileges.   The AutoML strategy used to train the predictor. Unless LatencyOptimized is specified, the AutoML strategy optimizes predictor accuracy. This parameter is only valid for predictors trained using AutoML.
        public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
        /// Whether the predictor was created with CreateAutoPredictor.
        public let isAutoPredictor: Bool?
        /// The accuracy metric used to optimize the predictor.
        public let optimizationMetric: OptimizationMetric?
        /// An array of results from evaluating the predictor.
        public let predictorEvaluationResults: [EvaluationResult]?

        public init(autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil, isAutoPredictor: Bool? = nil, optimizationMetric: OptimizationMetric? = nil, predictorEvaluationResults: [EvaluationResult]? = nil) {
            self.autoMLOverrideStrategy = autoMLOverrideStrategy
            self.isAutoPredictor = isAutoPredictor
            self.optimizationMetric = optimizationMetric
            self.predictorEvaluationResults = predictorEvaluationResults
        }

        private enum CodingKeys: String, CodingKey {
            case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
            case isAutoPredictor = "IsAutoPredictor"
            case optimizationMetric = "OptimizationMetric"
            case predictorEvaluationResults = "PredictorEvaluationResults"
        }
    }

    public struct HyperParameterTuningJobConfig: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the ranges of valid values for the hyperparameters.
        public let parameterRanges: ParameterRanges?

        public init(parameterRanges: ParameterRanges? = nil) {
            self.parameterRanges = parameterRanges
        }

        public func validate(name: String) throws {
            try self.parameterRanges?.validate(name: "\(name).parameterRanges")
        }

        private enum CodingKeys: String, CodingKey {
            case parameterRanges = "ParameterRanges"
        }
    }

    public struct InputDataConfig: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset group.
        public let datasetGroupArn: String
        /// An array of supplementary features. The only supported feature is a holiday calendar.
        public let supplementaryFeatures: [SupplementaryFeature]?

        public init(datasetGroupArn: String, supplementaryFeatures: [SupplementaryFeature]? = nil) {
            self.datasetGroupArn = datasetGroupArn
            self.supplementaryFeatures = supplementaryFeatures
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.supplementaryFeatures?.forEach {
                try $0.validate(name: "\(name).supplementaryFeatures[]")
            }
            try self.validate(self.supplementaryFeatures, name: "supplementaryFeatures", parent: name, max: 2)
            try self.validate(self.supplementaryFeatures, name: "supplementaryFeatures", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroupArn = "DatasetGroupArn"
            case supplementaryFeatures = "SupplementaryFeatures"
        }
    }

    public struct IntegerParameterRange: AWSEncodableShape & AWSDecodableShape {
        /// The maximum tunable value of the hyperparameter.
        public let maxValue: Int
        /// The minimum tunable value of the hyperparameter.
        public let minValue: Int
        /// The name of the hyperparameter to tune.
        public let name: String
        /// The scale that hyperparameter tuning uses to search the hyperparameter range. Valid values:  Auto  Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.  Linear  Hyperparameter tuning searches the values in the hyperparameter range by using a linear scale.  Logarithmic  Hyperparameter tuning searches the values in the hyperparameter range by using a logarithmic scale. Logarithmic scaling works only for ranges that have values greater than 0.  ReverseLogarithmic  Not supported for IntegerParameterRange. Reverse logarithmic scaling works only for ranges that are entirely within the range 0    For information about choosing a hyperparameter scale, see Hyperparameter Scaling. One of the following values:
        public let scalingType: ScalingType?

        public init(maxValue: Int, minValue: Int, name: String, scalingType: ScalingType? = nil) {
            self.maxValue = maxValue
            self.minValue = minValue
            self.name = name
            self.scalingType = scalingType
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxValue = "MaxValue"
            case minValue = "MinValue"
            case name = "Name"
            case scalingType = "ScalingType"
        }
    }

    public struct ListDatasetGroupsRequest: AWSEncodableShape {
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetGroupsResponse: AWSDecodableShape {
        /// An array of objects that summarize each dataset group's properties.
        public let datasetGroups: [DatasetGroupSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasetGroups: [DatasetGroupSummary]? = nil, nextToken: String? = nil) {
            self.datasetGroups = datasetGroups
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetGroups = "DatasetGroups"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetImportJobsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the datasets that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the datasets that match the statement, specify IS. To exclude matching datasets, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are DatasetArn and Status.    Value - The value to match.   For example, to list all dataset import jobs whose status is ACTIVE, you specify the following filter:  "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetImportJobsResponse: AWSDecodableShape {
        /// An array of objects that summarize each dataset import job's properties.
        public let datasetImportJobs: [DatasetImportJobSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasetImportJobs: [DatasetImportJobSummary]? = nil, nextToken: String? = nil) {
            self.datasetImportJobs = datasetImportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobs = "DatasetImportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// An array of objects that summarize each dataset's properties.
        public let datasets: [DatasetSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(datasets: [DatasetSummary]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets = "Datasets"
            case nextToken = "NextToken"
        }
    }

    public struct ListExplainabilitiesRequest: AWSEncodableShape {
        /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT.    Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.    Value - The value to match.
        public let filters: [Filter]?
        /// The number of items returned in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListExplainabilitiesResponse: AWSDecodableShape {
        /// An array of objects that summarize the properties of each Explainability resource.
        public let explainabilities: [ExplainabilitySummary]?
        /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(explainabilities: [ExplainabilitySummary]? = nil, nextToken: String? = nil) {
            self.explainabilities = explainabilities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilities = "Explainabilities"
            case nextToken = "NextToken"
        }
    }

    public struct ListExplainabilityExportsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude resources that match the statement from the list. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT.    Key - The name of the parameter to filter on. Valid values are ResourceArn and Status.    Value - The value to match.
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListExplainabilityExportsResponse: AWSDecodableShape {
        /// An array of objects that summarize the properties of each Explainability export.
        public let explainabilityExports: [ExplainabilityExportSummary]?
        /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(explainabilityExports: [ExplainabilityExportSummary]? = nil, nextToken: String? = nil) {
            self.explainabilityExports = explainabilityExports
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case explainabilityExports = "ExplainabilityExports"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastExportJobsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are ForecastArn and Status.    Value - The value to match.   For example, to list all jobs that export a forecast named electricityforecast, specify the following filter:  "Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityforecast" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastExportJobsResponse: AWSDecodableShape {
        /// An array of objects that summarize each export job's properties.
        public let forecastExportJobs: [ForecastExportJobSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(forecastExportJobs: [ForecastExportJobSummary]? = nil, nextToken: String? = nil) {
            self.forecastExportJobs = forecastExportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case forecastExportJobs = "ForecastExportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the forecasts that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecasts that match the statement, specify IS. To exclude matching forecasts, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are DatasetGroupArn, PredictorArn, and Status.    Value - The value to match.   For example, to list all forecasts whose status is not ACTIVE, you would specify:  "Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListForecastsResponse: AWSDecodableShape {
        /// An array of objects that summarize each forecast's properties.
        public let forecasts: [ForecastSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(forecasts: [ForecastSummary]? = nil, nextToken: String? = nil) {
            self.forecasts = forecasts
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case forecasts = "Forecasts"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitorEvaluationsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT.    Key - The name of the parameter to filter on. The only valid value is  EvaluationState.    Value - The value to match. Valid values are only SUCCESS or FAILURE.   For example, to list only successful monitor evaluations, you would specify:  "Filters": [ { "Condition": "IS", "Key": "EvaluationState", "Value": "SUCCESS" } ]
        public let filters: [Filter]?
        /// The maximum number of monitoring results to return.
        public let maxResults: Int?
        /// The Amazon Resource Name (ARN) of the monitor resource to get results from.
        public let monitorArn: String
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, monitorArn: String, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.monitorArn = monitorArn
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, max: 256)
            try self.validate(self.monitorArn, name: "monitorArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case monitorArn = "MonitorArn"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitorEvaluationsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?
        /// The monitoring results and predictor events collected by the monitor resource during different windows of time. For information about monitoring see Viewing Monitoring Results. For more information about retrieving monitoring results see Viewing Monitoring Results.
        public let predictorMonitorEvaluations: [PredictorMonitorEvaluation]?

        public init(nextToken: String? = nil, predictorMonitorEvaluations: [PredictorMonitorEvaluation]? = nil) {
            self.nextToken = nextToken
            self.predictorMonitorEvaluations = predictorMonitorEvaluations
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case predictorMonitorEvaluations = "PredictorMonitorEvaluations"
        }
    }

    public struct ListMonitorsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the resources that match the statement from the list. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT.    Key - The name of the parameter to filter on. The only valid value is  Status.    Value - The value to match.   For example, to list all monitors who's status is ACTIVE, you would specify:  "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
        public let filters: [Filter]?
        /// The maximum number of monitors to include in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListMonitorsResponse: AWSDecodableShape {
        /// An array of objects that summarize each monitor's properties.
        public let monitors: [MonitorSummary]?
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?

        public init(monitors: [MonitorSummary]? = nil, nextToken: String? = nil) {
            self.monitors = monitors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case monitors = "Monitors"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorBacktestExportJobsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictor backtest export jobs that match the statement from the list. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictor backtest export jobs that match the statement, specify IS. To exclude matching predictor backtest export jobs, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are PredictorArn and Status.    Value - The value to match.
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorBacktestExportJobsResponse: AWSDecodableShape {
        /// Returns this token if the response is truncated. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// An array of objects that summarize the properties of each predictor backtest export job.
        public let predictorBacktestExportJobs: [PredictorBacktestExportJobSummary]?

        public init(nextToken: String? = nil, predictorBacktestExportJobs: [PredictorBacktestExportJobSummary]? = nil) {
            self.nextToken = nextToken
            self.predictorBacktestExportJobs = predictorBacktestExportJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case predictorBacktestExportJobs = "PredictorBacktestExportJobs"
        }
    }

    public struct ListPredictorsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the predictors that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the predictors that match the statement, specify IS. To exclude matching predictors, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are DatasetGroupArn and Status.    Value - The value to match.   For example, to list all predictors whose status is ACTIVE, you would specify:  "Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListPredictorsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// An array of objects that summarize each predictor's properties.
        public let predictors: [PredictorSummary]?

        public init(nextToken: String? = nil, predictors: [PredictorSummary]? = nil) {
            self.nextToken = nextToken
            self.predictors = predictors
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case predictors = "Predictors"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags for the resource.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct ListWhatIfAnalysesRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if analysis jobs that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the what-if analysis jobs that match the statement, specify IS. To exclude matching what-if analysis jobs, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are WhatIfAnalysisArn and Status.    Value - The value to match.   For example, to list all jobs that export a forecast named electricityWhatIf, specify the following filter:  "Filters": [ { "Condition": "IS", "Key": "WhatIfAnalysisArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIf" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListWhatIfAnalysesResponse: AWSDecodableShape {
        /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// An array of WhatIfAnalysisSummary objects that describe the matched analyses.
        public let whatIfAnalyses: [WhatIfAnalysisSummary]?

        public init(nextToken: String? = nil, whatIfAnalyses: [WhatIfAnalysisSummary]? = nil) {
            self.nextToken = nextToken
            self.whatIfAnalyses = whatIfAnalyses
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case whatIfAnalyses = "WhatIfAnalyses"
        }
    }

    public struct ListWhatIfForecastExportsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are WhatIfForecastExportArn and Status.    Value - The value to match.   For example, to list all jobs that export a forecast named electricityWIFExport, specify the following filter:  "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastExportArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWIFExport" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListWhatIfForecastExportsResponse: AWSDecodableShape {
        /// If the response is truncated, Forecast returns this token. To retrieve the next set of results, use the token in the next request.
        public let nextToken: String?
        /// An array of WhatIfForecastExports objects that describe the matched forecast exports.
        public let whatIfForecastExports: [WhatIfForecastExportSummary]?

        public init(nextToken: String? = nil, whatIfForecastExports: [WhatIfForecastExportSummary]? = nil) {
            self.nextToken = nextToken
            self.whatIfForecastExports = whatIfForecastExports
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case whatIfForecastExports = "WhatIfForecastExports"
        }
    }

    public struct ListWhatIfForecastsRequest: AWSEncodableShape {
        /// An array of filters. For each filter, you provide a condition and a match statement. The condition is either IS or IS_NOT, which specifies whether to include or exclude the what-if forecast export jobs that match the statement from the list, respectively. The match statement consists of a key and a value.  Filter properties     Condition - The condition to apply. Valid values are IS and IS_NOT. To include the forecast export jobs that match the statement, specify IS. To exclude matching forecast export jobs, specify IS_NOT.    Key - The name of the parameter to filter on. Valid values are WhatIfForecastArn and Status.    Value - The value to match.   For example, to list all jobs that export a forecast named electricityWhatIfForecast, specify the following filter:  "Filters": [ { "Condition": "IS", "Key": "WhatIfForecastArn", "Value": "arn:aws:forecast:us-west-2::forecast/electricityWhatIfForecast" } ]
        public let filters: [Filter]?
        /// The number of items to return in the response.
        public let maxResults: Int?
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
        public let nextToken: String?

        public init(filters: [Filter]? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filters = filters
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filters?.forEach {
                try $0.validate(name: "\(name).filters[]")
            }
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 3000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case filters = "Filters"
            case maxResults = "MaxResults"
            case nextToken = "NextToken"
        }
    }

    public struct ListWhatIfForecastsResponse: AWSDecodableShape {
        /// If the result of the previous request was truncated, the response includes a NextToken. To retrieve the next set of results, use the token in the next  request. Tokens expire after 24 hours.
        public let nextToken: String?
        /// An array of WhatIfForecasts objects that describe the matched forecasts.
        public let whatIfForecasts: [WhatIfForecastSummary]?

        public init(nextToken: String? = nil, whatIfForecasts: [WhatIfForecastSummary]? = nil) {
            self.nextToken = nextToken
            self.whatIfForecasts = whatIfForecasts
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case whatIfForecasts = "WhatIfForecasts"
        }
    }

    public struct MetricResult: AWSDecodableShape {
        /// The name of the metric.
        public let metricName: String?
        /// The value for the metric.
        public let metricValue: Double?

        public init(metricName: String? = nil, metricValue: Double? = nil) {
            self.metricName = metricName
            self.metricValue = metricValue
        }

        private enum CodingKeys: String, CodingKey {
            case metricName = "MetricName"
            case metricValue = "MetricValue"
        }
    }

    public struct Metrics: AWSDecodableShape {
        /// The average value of all weighted quantile losses.
        public let averageWeightedQuantileLoss: Double?
        ///  Provides detailed error metrics for each forecast type. Metrics include root-mean square-error (RMSE), mean absolute percentage error (MAPE), mean absolute scaled error (MASE), and weighted average percentage error (WAPE).
        public let errorMetrics: [ErrorMetric]?
        /// The root-mean-square error (RMSE).
        public let rmse: Double?
        /// An array of weighted quantile losses. Quantiles divide a probability distribution into regions of equal probability. The distribution in this case is the loss function.
        public let weightedQuantileLosses: [WeightedQuantileLoss]?

        public init(averageWeightedQuantileLoss: Double? = nil, errorMetrics: [ErrorMetric]? = nil, weightedQuantileLosses: [WeightedQuantileLoss]? = nil) {
            self.averageWeightedQuantileLoss = averageWeightedQuantileLoss
            self.errorMetrics = errorMetrics
            self.rmse = nil
            self.weightedQuantileLosses = weightedQuantileLosses
        }

        @available(*, deprecated, message: "Members rmse have been deprecated")
        public init(averageWeightedQuantileLoss: Double? = nil, errorMetrics: [ErrorMetric]? = nil, rmse: Double? = nil, weightedQuantileLosses: [WeightedQuantileLoss]? = nil) {
            self.averageWeightedQuantileLoss = averageWeightedQuantileLoss
            self.errorMetrics = errorMetrics
            self.rmse = rmse
            self.weightedQuantileLosses = weightedQuantileLosses
        }

        private enum CodingKeys: String, CodingKey {
            case averageWeightedQuantileLoss = "AverageWeightedQuantileLoss"
            case errorMetrics = "ErrorMetrics"
            case rmse = "RMSE"
            case weightedQuantileLosses = "WeightedQuantileLosses"
        }
    }

    public struct MonitorConfig: AWSEncodableShape {
        /// The name of the monitor resource.
        public let monitorName: String

        public init(monitorName: String) {
            self.monitorName = monitorName
        }

        public func validate(name: String) throws {
            try self.validate(self.monitorName, name: "monitorName", parent: name, max: 63)
            try self.validate(self.monitorName, name: "monitorName", parent: name, min: 1)
            try self.validate(self.monitorName, name: "monitorName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case monitorName = "MonitorName"
        }
    }

    public struct MonitorDataSource: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the dataset import job used to import the data that initiated the monitor evaluation.
        public let datasetImportJobArn: String?
        /// The Amazon Resource Name (ARN) of the forecast the monitor used during the evaluation.
        public let forecastArn: String?
        /// The Amazon Resource Name (ARN) of the predictor resource you are monitoring.
        public let predictorArn: String?

        public init(datasetImportJobArn: String? = nil, forecastArn: String? = nil, predictorArn: String? = nil) {
            self.datasetImportJobArn = datasetImportJobArn
            self.forecastArn = forecastArn
            self.predictorArn = predictorArn
        }

        private enum CodingKeys: String, CodingKey {
            case datasetImportJobArn = "DatasetImportJobArn"
            case forecastArn = "ForecastArn"
            case predictorArn = "PredictorArn"
        }
    }

    public struct MonitorInfo: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public let monitorArn: String?
        /// The status of the monitor. States include:    ACTIVE     ACTIVE_STOPPING, ACTIVE_STOPPED     UPDATE_IN_PROGRESS     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(monitorArn: String? = nil, status: String? = nil) {
            self.monitorArn = monitorArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case monitorArn = "MonitorArn"
            case status = "Status"
        }
    }

    public struct MonitorSummary: AWSDecodableShape {
        /// When the monitor resource was created.
        public let creationTime: Date?
        /// The last time the monitor resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    STOPPED - When the resource stopped.    ACTIVE or CREATE_FAILED - When the monitor creation finished or failed.
        public let lastModificationTime: Date?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public let monitorArn: String?
        /// The name of the monitor resource.
        public let monitorName: String?
        /// The Amazon Resource Name (ARN) of the predictor being monitored.
        public let resourceArn: String?
        /// The status of the monitor. States include:    ACTIVE     ACTIVE_STOPPING, ACTIVE_STOPPED     UPDATE_IN_PROGRESS     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, lastModificationTime: Date? = nil, monitorArn: String? = nil, monitorName: String? = nil, resourceArn: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.monitorArn = monitorArn
            self.monitorName = monitorName
            self.resourceArn = resourceArn
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case monitorArn = "MonitorArn"
            case monitorName = "MonitorName"
            case resourceArn = "ResourceArn"
            case status = "Status"
        }
    }

    public struct ParameterRanges: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the tunable range for each categorical hyperparameter.
        public let categoricalParameterRanges: [CategoricalParameterRange]?
        /// Specifies the tunable range for each continuous hyperparameter.
        public let continuousParameterRanges: [ContinuousParameterRange]?
        /// Specifies the tunable range for each integer hyperparameter.
        public let integerParameterRanges: [IntegerParameterRange]?

        public init(categoricalParameterRanges: [CategoricalParameterRange]? = nil, continuousParameterRanges: [ContinuousParameterRange]? = nil, integerParameterRanges: [IntegerParameterRange]? = nil) {
            self.categoricalParameterRanges = categoricalParameterRanges
            self.continuousParameterRanges = continuousParameterRanges
            self.integerParameterRanges = integerParameterRanges
        }

        public func validate(name: String) throws {
            try self.categoricalParameterRanges?.forEach {
                try $0.validate(name: "\(name).categoricalParameterRanges[]")
            }
            try self.validate(self.categoricalParameterRanges, name: "categoricalParameterRanges", parent: name, max: 20)
            try self.validate(self.categoricalParameterRanges, name: "categoricalParameterRanges", parent: name, min: 1)
            try self.continuousParameterRanges?.forEach {
                try $0.validate(name: "\(name).continuousParameterRanges[]")
            }
            try self.validate(self.continuousParameterRanges, name: "continuousParameterRanges", parent: name, max: 20)
            try self.validate(self.continuousParameterRanges, name: "continuousParameterRanges", parent: name, min: 1)
            try self.integerParameterRanges?.forEach {
                try $0.validate(name: "\(name).integerParameterRanges[]")
            }
            try self.validate(self.integerParameterRanges, name: "integerParameterRanges", parent: name, max: 20)
            try self.validate(self.integerParameterRanges, name: "integerParameterRanges", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case categoricalParameterRanges = "CategoricalParameterRanges"
            case continuousParameterRanges = "ContinuousParameterRanges"
            case integerParameterRanges = "IntegerParameterRanges"
        }
    }

    public struct PredictorBacktestExportJobSummary: AWSDecodableShape {
        /// When the predictor backtest export job was created.
        public let creationTime: Date?
        public let destination: DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// Information about any errors that may have occurred during the backtest export.
        public let message: String?
        /// The Amazon Resource Name (ARN) of the predictor backtest export job.
        public let predictorBacktestExportJobArn: String?
        /// The name of the predictor backtest export job.
        public let predictorBacktestExportJobName: String?
        /// The status of the predictor backtest export job. States include:     ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED
        public let status: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorBacktestExportJobArn: String? = nil, predictorBacktestExportJobName: String? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = predictorBacktestExportJobName
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
            case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
            case status = "Status"
        }
    }

    public struct PredictorBaseline: AWSDecodableShape {
        /// The initial accuracy metrics for the predictor. Use these metrics as a baseline for comparison purposes as you use your predictor and the metrics change.
        public let baselineMetrics: [BaselineMetric]?

        public init(baselineMetrics: [BaselineMetric]? = nil) {
            self.baselineMetrics = baselineMetrics
        }

        private enum CodingKeys: String, CodingKey {
            case baselineMetrics = "BaselineMetrics"
        }
    }

    public struct PredictorEvent: AWSDecodableShape {
        /// The timestamp for when the event occurred.
        public let datetime: Date?
        /// The type of event. For example, Retrain. A retraining event denotes the timepoint when a predictor was retrained. Any monitor results from before the Datetime are from the previous predictor. Any new metrics are for the newly retrained predictor.
        public let detail: String?

        public init(datetime: Date? = nil, detail: String? = nil) {
            self.datetime = datetime
            self.detail = detail
        }

        private enum CodingKeys: String, CodingKey {
            case datetime = "Datetime"
            case detail = "Detail"
        }
    }

    public struct PredictorExecution: AWSDecodableShape {
        /// The ARN of the algorithm used to test the predictor.
        public let algorithmArn: String?
        /// An array of test windows used to evaluate the algorithm. The NumberOfBacktestWindows from the  object determines the number of windows in the array.
        public let testWindows: [TestWindowSummary]?

        public init(algorithmArn: String? = nil, testWindows: [TestWindowSummary]? = nil) {
            self.algorithmArn = algorithmArn
            self.testWindows = testWindows
        }

        private enum CodingKeys: String, CodingKey {
            case algorithmArn = "AlgorithmArn"
            case testWindows = "TestWindows"
        }
    }

    public struct PredictorExecutionDetails: AWSDecodableShape {
        /// An array of the backtests performed to evaluate the accuracy of the predictor against a particular algorithm. The NumberOfBacktestWindows from the  object determines the number of windows in the array.
        public let predictorExecutions: [PredictorExecution]?

        public init(predictorExecutions: [PredictorExecution]? = nil) {
            self.predictorExecutions = predictorExecutions
        }

        private enum CodingKeys: String, CodingKey {
            case predictorExecutions = "PredictorExecutions"
        }
    }

    public struct PredictorMonitorEvaluation: AWSDecodableShape {
        /// The status of the monitor evaluation. The state can be SUCCESS or FAILURE.
        public let evaluationState: String?
        /// The timestamp that indicates when the monitor evaluation was started.
        public let evaluationTime: Date?
        /// Information about any errors that may have occurred during the monitor evaluation.
        public let message: String?
        /// A list of metrics Forecast calculated when monitoring a predictor. You can compare the value for each metric in the list to the metric's value in the Baseline to see how your predictor's performance is changing.
        public let metricResults: [MetricResult]?
        /// The Amazon Resource Name (ARN) of the monitor resource.
        public let monitorArn: String?
        /// The source of the data the monitor resource used during the evaluation.
        public let monitorDataSource: MonitorDataSource?
        /// The number of items considered during the evaluation.
        public let numItemsEvaluated: Int64?
        /// Provides details about a predictor event, such as a retraining.
        public let predictorEvent: PredictorEvent?
        /// The Amazon Resource Name (ARN) of the resource to monitor.
        public let resourceArn: String?
        /// The timestamp that indicates the end of the window that is used for monitor evaluation.
        public let windowEndDatetime: Date?
        /// The timestamp that indicates the start of the window that is used for monitor evaluation.
        public let windowStartDatetime: Date?

        public init(evaluationState: String? = nil, evaluationTime: Date? = nil, message: String? = nil, metricResults: [MetricResult]? = nil, monitorArn: String? = nil, monitorDataSource: MonitorDataSource? = nil, numItemsEvaluated: Int64? = nil, predictorEvent: PredictorEvent? = nil, resourceArn: String? = nil, windowEndDatetime: Date? = nil, windowStartDatetime: Date? = nil) {
            self.evaluationState = evaluationState
            self.evaluationTime = evaluationTime
            self.message = message
            self.metricResults = metricResults
            self.monitorArn = monitorArn
            self.monitorDataSource = monitorDataSource
            self.numItemsEvaluated = numItemsEvaluated
            self.predictorEvent = predictorEvent
            self.resourceArn = resourceArn
            self.windowEndDatetime = windowEndDatetime
            self.windowStartDatetime = windowStartDatetime
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationState = "EvaluationState"
            case evaluationTime = "EvaluationTime"
            case message = "Message"
            case metricResults = "MetricResults"
            case monitorArn = "MonitorArn"
            case monitorDataSource = "MonitorDataSource"
            case numItemsEvaluated = "NumItemsEvaluated"
            case predictorEvent = "PredictorEvent"
            case resourceArn = "ResourceArn"
            case windowEndDatetime = "WindowEndDatetime"
            case windowStartDatetime = "WindowStartDatetime"
        }
    }

    public struct PredictorSummary: AWSDecodableShape {
        /// When the model training task was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the dataset group that contains the data used to train the predictor.
        public let datasetGroupArn: String?
        /// Whether AutoPredictor was used to create the predictor.
        public let isAutoPredictor: Bool?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The ARN of the predictor.
        public let predictorArn: String?
        /// The name of the predictor.
        public let predictorName: String?
        /// A summary of the reference predictor used if the predictor was retrained or upgraded.
        public let referencePredictorSummary: ReferencePredictorSummary?
        /// The status of the predictor. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     CREATE_STOPPING, CREATE_STOPPED     The Status of the predictor must be ACTIVE before you can use the predictor to create a forecast.
        public let status: String?

        public init(creationTime: Date? = nil, datasetGroupArn: String? = nil, isAutoPredictor: Bool? = nil, lastModificationTime: Date? = nil, message: String? = nil, predictorArn: String? = nil, predictorName: String? = nil, referencePredictorSummary: ReferencePredictorSummary? = nil, status: String? = nil) {
            self.creationTime = creationTime
            self.datasetGroupArn = datasetGroupArn
            self.isAutoPredictor = isAutoPredictor
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.predictorArn = predictorArn
            self.predictorName = predictorName
            self.referencePredictorSummary = referencePredictorSummary
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case datasetGroupArn = "DatasetGroupArn"
            case isAutoPredictor = "IsAutoPredictor"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case predictorArn = "PredictorArn"
            case predictorName = "PredictorName"
            case referencePredictorSummary = "ReferencePredictorSummary"
            case status = "Status"
        }
    }

    public struct ReferencePredictorSummary: AWSDecodableShape {
        /// The ARN of the reference predictor.
        public let arn: String?
        /// Whether the reference predictor is Active or Deleted.
        public let state: State?

        public init(arn: String? = nil, state: State? = nil) {
            self.arn = arn
            self.state = state
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case state = "State"
        }
    }

    public struct ResumeResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the monitor resource to resume.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct S3Config: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an Key Management Service (KMS) key.
        public let kmsKeyArn: String?
        /// The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.
        public let path: String
        /// The ARN of the Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3 bucket or files. If you provide a value for the KMSKeyArn key, the role must allow access to the key. Passing a role across Amazon Web Services accounts is not allowed. If you pass a role that isn't in your account, you get an InvalidInputException error.
        public let roleArn: String

        public init(kmsKeyArn: String? = nil, path: String, roleArn: String) {
            self.kmsKeyArn = kmsKeyArn
            self.path = path
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, max: 256)
            try self.validate(self.kmsKeyArn, name: "kmsKeyArn", parent: name, pattern: "^arn:aws:kms:.*:key/")
            try self.validate(self.path, name: "path", parent: name, max: 4096)
            try self.validate(self.path, name: "path", parent: name, min: 7)
            try self.validate(self.path, name: "path", parent: name, pattern: "^s3://[a-z0-9].+$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 256)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyArn = "KMSKeyArn"
            case path = "Path"
            case roleArn = "RoleArn"
        }
    }

    public struct Schema: AWSEncodableShape & AWSDecodableShape {
        /// An array of attributes specifying the name and type of each field in a dataset.
        public let attributes: [SchemaAttribute]?

        public init(attributes: [SchemaAttribute]? = nil) {
            self.attributes = attributes
        }

        public func validate(name: String) throws {
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 100)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
        }
    }

    public struct SchemaAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The name of the dataset field.
        public let attributeName: String?
        /// The data type of the field. For a related time series dataset, other than date, item_id, and forecast dimensions attributes, all attributes should be of numerical type (integer/float).
        public let attributeType: AttributeType?

        public init(attributeName: String? = nil, attributeType: AttributeType? = nil) {
            self.attributeName = attributeName
            self.attributeType = attributeType
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 63)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeType = "AttributeType"
        }
    }

    public struct Statistics: AWSDecodableShape {
        /// For a numeric field, the average value in the field.
        public let avg: Double?
        /// The number of values in the field. If the response value is -1, refer to CountLong.
        public let count: Int?
        /// The number of distinct values in the field. If the response value is -1, refer to CountDistinctLong.
        public let countDistinct: Int?
        /// The number of distinct values in the field. CountDistinctLong is used instead of CountDistinct if the value is greater than 2,147,483,647.
        public let countDistinctLong: Int64?
        /// The number of values in the field. CountLong is used instead of Count if the value is greater than 2,147,483,647.
        public let countLong: Int64?
        /// The number of NAN (not a number) values in the field. If the response value is -1, refer to CountNanLong.
        public let countNan: Int?
        /// The number of NAN (not a number) values in the field. CountNanLong is used instead of CountNan if the value is greater than 2,147,483,647.
        public let countNanLong: Int64?
        /// The number of null values in the field. If the response value is -1, refer to CountNullLong.
        public let countNull: Int?
        /// The number of null values in the field. CountNullLong is used instead of CountNull if the value is greater than 2,147,483,647.
        public let countNullLong: Int64?
        /// For a numeric field, the maximum value in the field.
        public let max: String?
        /// For a numeric field, the minimum value in the field.
        public let min: String?
        /// For a numeric field, the standard deviation.
        public let stddev: Double?

        public init(avg: Double? = nil, count: Int? = nil, countDistinct: Int? = nil, countDistinctLong: Int64? = nil, countLong: Int64? = nil, countNan: Int? = nil, countNanLong: Int64? = nil, countNull: Int? = nil, countNullLong: Int64? = nil, max: String? = nil, min: String? = nil, stddev: Double? = nil) {
            self.avg = avg
            self.count = count
            self.countDistinct = countDistinct
            self.countDistinctLong = countDistinctLong
            self.countLong = countLong
            self.countNan = countNan
            self.countNanLong = countNanLong
            self.countNull = countNull
            self.countNullLong = countNullLong
            self.max = max
            self.min = min
            self.stddev = stddev
        }

        private enum CodingKeys: String, CodingKey {
            case avg = "Avg"
            case count = "Count"
            case countDistinct = "CountDistinct"
            case countDistinctLong = "CountDistinctLong"
            case countLong = "CountLong"
            case countNan = "CountNan"
            case countNanLong = "CountNanLong"
            case countNull = "CountNull"
            case countNullLong = "CountNullLong"
            case max = "Max"
            case min = "Min"
            case stddev = "Stddev"
        }
    }

    public struct StopResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs are DatasetImportJobArn, PredictorArn, PredictorBacktestExportJobArn, ForecastArn, ForecastExportJobArn, ExplainabilityArn, and ExplainabilityExportArn.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
        }
    }

    public struct SupplementaryFeature: AWSEncodableShape & AWSDecodableShape {
        /// The name of the feature. Valid values: "holiday" and "weather".
        public let name: String
        ///  Weather Index  To enable the Weather Index, set the value to "true"   Holidays  To enable Holidays, specify a country with one of the following two-letter country codes:   "AL" - ALBANIA   "AR" - ARGENTINA   "AT" - AUSTRIA   "AU" - AUSTRALIA   "BA" - BOSNIA HERZEGOVINA   "BE" - BELGIUM   "BG" - BULGARIA   "BO" - BOLIVIA   "BR" - BRAZIL   "BY" - BELARUS   "CA" - CANADA   "CL" - CHILE   "CO" - COLOMBIA   "CR" - COSTA RICA   "HR" - CROATIA   "CZ" - CZECH REPUBLIC   "DK" - DENMARK   "EC" - ECUADOR   "EE" - ESTONIA   "ET" - ETHIOPIA   "FI" - FINLAND   "FR" - FRANCE   "DE" - GERMANY   "GR" - GREECE   "HU" - HUNGARY   "IS" - ICELAND   "IN" - INDIA   "IE" - IRELAND   "IT" - ITALY   "JP" - JAPAN   "KZ" - KAZAKHSTAN   "KR" - KOREA   "LV" - LATVIA   "LI" - LIECHTENSTEIN   "LT" - LITHUANIA   "LU" - LUXEMBOURG   "MK" - MACEDONIA   "MT" - MALTA   "MX" - MEXICO   "MD" - MOLDOVA   "ME" - MONTENEGRO   "NL" - NETHERLANDS   "NZ" - NEW ZEALAND   "NI" - NICARAGUA   "NG" - NIGERIA   "NO" - NORWAY   "PA" - PANAMA   "PY" - PARAGUAY   "PE" - PERU   "PL" - POLAND   "PT" - PORTUGAL   "RO" - ROMANIA   "RU" - RUSSIA   "RS" - SERBIA   "SK" - SLOVAKIA   "SI" - SLOVENIA   "ZA" - SOUTH AFRICA   "ES" - SPAIN   "SE" - SWEDEN   "CH" - SWITZERLAND   "UA" - UKRAINE   "AE" - UNITED ARAB EMIRATES   "US" - UNITED STATES   "UK" - UNITED KINGDOM   "UY" - URUGUAY   "VE" - VENEZUELA
        public let value: String

        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 63)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case value = "Value"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        public let key: String
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor within a tag category (key).
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            try self.validate(self.value, name: "value", parent: name, max: 256)
            try self.validate(self.value, name: "value", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "Key"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
        public let resourceArn: String
        /// The tags to add to the resource. A tag is an array of key-value pairs. The following basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource, each tag key must be unique, and each tag key can have only one value.   Maximum key length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of such as a prefix for keys as it is reserved for Amazon Web Services use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per resource limit.
        public let tags: [Tag]

        public init(resourceArn: String, tags: [Tag]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TestWindowSummary: AWSDecodableShape {
        /// If the test failed, the reason why it failed.
        public let message: String?
        /// The status of the test. Possible status values are:    ACTIVE     CREATE_IN_PROGRESS     CREATE_FAILED
        public let status: String?
        /// The time at which the test ended.
        public let testWindowEnd: Date?
        /// The time at which the test began.
        public let testWindowStart: Date?

        public init(message: String? = nil, status: String? = nil, testWindowEnd: Date? = nil, testWindowStart: Date? = nil) {
            self.message = message
            self.status = status
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case status = "Status"
            case testWindowEnd = "TestWindowEnd"
            case testWindowStart = "TestWindowStart"
        }
    }

    public struct TimeAlignmentBoundary: AWSEncodableShape & AWSDecodableShape {
        /// The day of the month to use for time alignment during aggregation.
        public let dayOfMonth: Int?
        /// The day of week to use for time alignment during aggregation. The day must be in uppercase.
        public let dayOfWeek: DayOfWeek?
        /// The hour of day to use for time alignment during aggregation.
        public let hour: Int?
        /// The month to use for time alignment during aggregation. The month must be in uppercase.
        public let month: Month?

        public init(dayOfMonth: Int? = nil, dayOfWeek: DayOfWeek? = nil, hour: Int? = nil, month: Month? = nil) {
            self.dayOfMonth = dayOfMonth
            self.dayOfWeek = dayOfWeek
            self.hour = hour
            self.month = month
        }

        public func validate(name: String) throws {
            try self.validate(self.dayOfMonth, name: "dayOfMonth", parent: name, max: 28)
            try self.validate(self.dayOfMonth, name: "dayOfMonth", parent: name, min: 1)
            try self.validate(self.hour, name: "hour", parent: name, max: 23)
            try self.validate(self.hour, name: "hour", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case dayOfMonth = "DayOfMonth"
            case dayOfWeek = "DayOfWeek"
            case hour = "Hour"
            case month = "Month"
        }
    }

    public struct TimeSeriesCondition: AWSEncodableShape & AWSDecodableShape {
        /// The item_id, dimension name, IM name, or timestamp that you are modifying.
        public let attributeName: String
        /// The value that is applied for the chosen Condition.
        public let attributeValue: String
        /// The condition to apply. Valid values are EQUALS, NOT_EQUALS, LESS_THAN and GREATER_THAN.
        public let condition: Condition

        public init(attributeName: String, attributeValue: String, condition: Condition) {
            self.attributeName = attributeName
            self.attributeValue = attributeValue
            self.condition = condition
        }

        public func validate(name: String) throws {
            try self.validate(self.attributeName, name: "attributeName", parent: name, max: 63)
            try self.validate(self.attributeName, name: "attributeName", parent: name, min: 1)
            try self.validate(self.attributeName, name: "attributeName", parent: name, pattern: "^[a-zA-Z][a-zA-Z0-9_]*$")
            try self.validate(self.attributeValue, name: "attributeValue", parent: name, max: 256)
            try self.validate(self.attributeValue, name: "attributeValue", parent: name, pattern: "^.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeName = "AttributeName"
            case attributeValue = "AttributeValue"
            case condition = "Condition"
        }
    }

    public struct TimeSeriesIdentifiers: AWSEncodableShape & AWSDecodableShape {
        public let dataSource: DataSource?
        /// The format of the data, either CSV or PARQUET.
        public let format: String?
        public let schema: Schema?

        public init(dataSource: DataSource? = nil, format: String? = nil, schema: Schema? = nil) {
            self.dataSource = dataSource
            self.format = format
            self.schema = schema
        }

        public func validate(name: String) throws {
            try self.dataSource?.validate(name: "\(name).dataSource")
            try self.validate(self.format, name: "format", parent: name, max: 7)
            try self.validate(self.format, name: "format", parent: name, pattern: "^CSV|PARQUET$")
            try self.schema?.validate(name: "\(name).schema")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSource = "DataSource"
            case format = "Format"
            case schema = "Schema"
        }
    }

    public struct TimeSeriesReplacementsDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The format of the replacement data, CSV or PARQUET.
        public let format: String?
        public let s3Config: S3Config
        public let schema: Schema
        /// The timestamp format of the replacement data.
        public let timestampFormat: String?

        public init(format: String? = nil, s3Config: S3Config, schema: Schema, timestampFormat: String? = nil) {
            self.format = format
            self.s3Config = s3Config
            self.schema = schema
            self.timestampFormat = timestampFormat
        }

        public func validate(name: String) throws {
            try self.validate(self.format, name: "format", parent: name, max: 7)
            try self.validate(self.format, name: "format", parent: name, pattern: "^CSV|PARQUET$")
            try self.s3Config.validate(name: "\(name).s3Config")
            try self.schema.validate(name: "\(name).schema")
            try self.validate(self.timestampFormat, name: "timestampFormat", parent: name, max: 256)
            try self.validate(self.timestampFormat, name: "timestampFormat", parent: name, pattern: "^[a-zA-Z0-9\\-\\:\\.\\,\\'\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case format = "Format"
            case s3Config = "S3Config"
            case schema = "Schema"
            case timestampFormat = "TimestampFormat"
        }
    }

    public struct TimeSeriesSelector: AWSEncodableShape & AWSDecodableShape {
        /// Details about the import file that contains the time series for which you want to create forecasts.
        public let timeSeriesIdentifiers: TimeSeriesIdentifiers?

        public init(timeSeriesIdentifiers: TimeSeriesIdentifiers? = nil) {
            self.timeSeriesIdentifiers = timeSeriesIdentifiers
        }

        public func validate(name: String) throws {
            try self.timeSeriesIdentifiers?.validate(name: "\(name).timeSeriesIdentifiers")
        }

        private enum CodingKeys: String, CodingKey {
            case timeSeriesIdentifiers = "TimeSeriesIdentifiers"
        }
    }

    public struct TimeSeriesTransformation: AWSEncodableShape & AWSDecodableShape {
        /// An array of actions that define a time series and how it is transformed. These transformations create a new time series that is used for the what-if analysis.
        public let action: Action?
        /// An array of conditions that define which members of the related time series are transformed.
        public let timeSeriesConditions: [TimeSeriesCondition]?

        public init(action: Action? = nil, timeSeriesConditions: [TimeSeriesCondition]? = nil) {
            self.action = action
            self.timeSeriesConditions = timeSeriesConditions
        }

        public func validate(name: String) throws {
            try self.action?.validate(name: "\(name).action")
            try self.timeSeriesConditions?.forEach {
                try $0.validate(name: "\(name).timeSeriesConditions[]")
            }
            try self.validate(self.timeSeriesConditions, name: "timeSeriesConditions", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case action = "Action"
            case timeSeriesConditions = "TimeSeriesConditions"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags.
        public let resourceArn: String
        /// The keys of the tags to be removed.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-@]*)$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case resourceArn = "ResourceArn"
            case tagKeys = "TagKeys"
        }
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDatasetGroupRequest: AWSEncodableShape {
        /// An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset group.
        public let datasetArns: [String]
        /// The ARN of the dataset group.
        public let datasetGroupArn: String

        public init(datasetArns: [String], datasetGroupArn: String) {
            self.datasetArns = datasetArns
            self.datasetGroupArn = datasetGroupArn
        }

        public func validate(name: String) throws {
            try self.datasetArns.forEach {
                try validate($0, name: "datasetArns[]", parent: name, max: 256)
                try validate($0, name: "datasetArns[]", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
            }
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, max: 256)
            try self.validate(self.datasetGroupArn, name: "datasetGroupArn", parent: name, pattern: "^arn:([a-z\\d-]+):forecast:.*:.*:.+$")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetArns = "DatasetArns"
            case datasetGroupArn = "DatasetGroupArn"
        }
    }

    public struct UpdateDatasetGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct WeightedQuantileLoss: AWSDecodableShape {
        /// The difference between the predicted value and the actual value over the quantile, weighted (normalized) by dividing by the sum over all quantiles.
        public let lossValue: Double?
        /// The quantile. Quantiles divide a probability distribution into regions of equal probability. For example, if the distribution was divided into 5 regions of equal probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.
        public let quantile: Double?

        public init(lossValue: Double? = nil, quantile: Double? = nil) {
            self.lossValue = lossValue
            self.quantile = quantile
        }

        private enum CodingKeys: String, CodingKey {
            case lossValue = "LossValue"
            case quantile = "Quantile"
        }
    }

    public struct WhatIfAnalysisSummary: AWSDecodableShape {
        /// When the what-if analysis was created.
        public let creationTime: Date?
        /// The Amazon Resource Name (ARN) of the baseline forecast that is being used in this what-if analysis.
        public let forecastArn: String?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the what-if analysis. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public let status: String?
        /// The Amazon Resource Name (ARN) of the what-if analysis.
        public let whatIfAnalysisArn: String?
        /// The name of the what-if analysis.
        public let whatIfAnalysisName: String?

        public init(creationTime: Date? = nil, forecastArn: String? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, whatIfAnalysisArn: String? = nil, whatIfAnalysisName: String? = nil) {
            self.creationTime = creationTime
            self.forecastArn = forecastArn
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfAnalysisName = whatIfAnalysisName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case forecastArn = "ForecastArn"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
            case whatIfAnalysisName = "WhatIfAnalysisName"
        }
    }

    public struct WhatIfForecastExportSummary: AWSDecodableShape {
        /// When the what-if forecast export was created.
        public let creationTime: Date?
        /// The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.
        public let destination: DataDestination?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the what-if forecast export. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public let status: String?
        /// An array of Amazon Resource Names (ARNs) that define the what-if forecasts included in the export.
        public let whatIfForecastArns: [String]?
        /// The Amazon Resource Name (ARN) of the what-if forecast export.
        public let whatIfForecastExportArn: String?
        /// The what-if forecast export name.
        public let whatIfForecastExportName: String?

        public init(creationTime: Date? = nil, destination: DataDestination? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, whatIfForecastArns: [String]? = nil, whatIfForecastExportArn: String? = nil, whatIfForecastExportName: String? = nil) {
            self.creationTime = creationTime
            self.destination = destination
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfForecastArns = whatIfForecastArns
            self.whatIfForecastExportArn = whatIfForecastExportArn
            self.whatIfForecastExportName = whatIfForecastExportName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case destination = "Destination"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case whatIfForecastArns = "WhatIfForecastArns"
            case whatIfForecastExportArn = "WhatIfForecastExportArn"
            case whatIfForecastExportName = "WhatIfForecastExportName"
        }
    }

    public struct WhatIfForecastSummary: AWSDecodableShape {
        /// When the what-if forecast was created.
        public let creationTime: Date?
        /// The last time the resource was modified. The timestamp depends on the status of the job:    CREATE_PENDING - The CreationTime.    CREATE_IN_PROGRESS - The current timestamp.    CREATE_STOPPING - The current timestamp.    CREATE_STOPPED - When the job stopped.    ACTIVE or CREATE_FAILED - When the job finished or failed.
        public let lastModificationTime: Date?
        /// If an error occurred, an informational message about the error.
        public let message: String?
        /// The status of the what-if forecast. States include:    ACTIVE     CREATE_PENDING, CREATE_IN_PROGRESS, CREATE_FAILED     CREATE_STOPPING, CREATE_STOPPED     DELETE_PENDING, DELETE_IN_PROGRESS, DELETE_FAILED     The Status of the what-if analysis must be ACTIVE before you can access the analysis.
        public let status: String?
        /// The Amazon Resource Name (ARN) of the what-if analysis that contains this what-if forecast.
        public let whatIfAnalysisArn: String?
        /// The Amazon Resource Name (ARN) of the what-if forecast.
        public let whatIfForecastArn: String?
        /// The name of the what-if forecast.
        public let whatIfForecastName: String?

        public init(creationTime: Date? = nil, lastModificationTime: Date? = nil, message: String? = nil, status: String? = nil, whatIfAnalysisArn: String? = nil, whatIfForecastArn: String? = nil, whatIfForecastName: String? = nil) {
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.status = status
            self.whatIfAnalysisArn = whatIfAnalysisArn
            self.whatIfForecastArn = whatIfForecastArn
            self.whatIfForecastName = whatIfForecastName
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case lastModificationTime = "LastModificationTime"
            case message = "Message"
            case status = "Status"
            case whatIfAnalysisArn = "WhatIfAnalysisArn"
            case whatIfForecastArn = "WhatIfForecastArn"
            case whatIfForecastName = "WhatIfForecastName"
        }
    }

    public struct WindowSummary: AWSDecodableShape {
        /// The type of evaluation.    SUMMARY - The average metrics across all windows.    COMPUTED - The metrics for the specified window.
        public let evaluationType: EvaluationType?
        /// The number of data points within the window.
        public let itemCount: Int?
        /// Provides metrics used to evaluate the performance of a predictor.
        public let metrics: Metrics?
        /// The timestamp that defines the end of the window.
        public let testWindowEnd: Date?
        /// The timestamp that defines the start of the window.
        public let testWindowStart: Date?

        public init(evaluationType: EvaluationType? = nil, itemCount: Int? = nil, metrics: Metrics? = nil, testWindowEnd: Date? = nil, testWindowStart: Date? = nil) {
            self.evaluationType = evaluationType
            self.itemCount = itemCount
            self.metrics = metrics
            self.testWindowEnd = testWindowEnd
            self.testWindowStart = testWindowStart
        }

        private enum CodingKeys: String, CodingKey {
            case evaluationType = "EvaluationType"
            case itemCount = "ItemCount"
            case metrics = "Metrics"
            case testWindowEnd = "TestWindowEnd"
            case testWindowStart = "TestWindowStart"
        }
    }
}

// MARK: - Errors

/// Error enum for Forecast
public struct ForecastErrorType: AWSErrorType {
    enum Code: String {
        case invalidInputException = "InvalidInputException"
        case invalidNextTokenException = "InvalidNextTokenException"
        case limitExceededException = "LimitExceededException"
        case resourceAlreadyExistsException = "ResourceAlreadyExistsException"
        case resourceInUseException = "ResourceInUseException"
        case resourceNotFoundException = "ResourceNotFoundException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Forecast
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// We can't process the request because it includes an invalid value or a value that exceeds the valid range.
    public static var invalidInputException: Self { .init(.invalidInputException) }
    /// The token is not valid. Tokens expire after 24 hours.
    public static var invalidNextTokenException: Self { .init(.invalidNextTokenException) }
    /// The limit on the number of resources per account has been exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// There is already a resource with this name. Try again with a different name.
    public static var resourceAlreadyExistsException: Self { .init(.resourceAlreadyExistsException) }
    /// The specified resource is in use.
    public static var resourceInUseException: Self { .init(.resourceInUseException) }
    /// We can't find a resource with that Amazon Resource Name (ARN). Check the ARN and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
}

extension ForecastErrorType: Equatable {
    public static func == (lhs: ForecastErrorType, rhs: ForecastErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension ForecastErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
