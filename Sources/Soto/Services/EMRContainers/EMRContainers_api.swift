//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_exported import SotoCore

/// Service object for interacting with AWS EMRContainers service.
///
/// Amazon EMR on EKS provides a deployment option for Amazon EMR that allows you to run open-source big data frameworks on Amazon Elastic Kubernetes Service (Amazon EKS). With this deployment option, you can focus on running analytics workloads while Amazon EMR on EKS builds, configures, and manages containers for open-source applications. For more information about Amazon EMR on EKS concepts and tasks, see What is Amazon EMR on EKS.  Amazon EMR containers is the API name for Amazon EMR on EKS. The emr-containers prefix is used in the following scenarios:    It is the prefix in the CLI commands for Amazon EMR on EKS. For example, aws emr-containers start-job-run.   It is the prefix before IAM policy actions for Amazon EMR on EKS. For example, "Action": [ "emr-containers:StartJobRun"]. For more information, see Policy actions for Amazon EMR on EKS.   It is the prefix used in Amazon EMR on EKS service endpoints. For example, emr-containers.us-east-2.amazonaws.com. For more information, see Amazon EMR on EKSService Endpoints.
public struct EMRContainers: AWSService {
    // MARK: Member variables

    /// Client used for communication with AWS
    public let client: AWSClient
    /// Service configuration
    public let config: AWSServiceConfig

    // MARK: Initialization

    /// Initialize the EMRContainers client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - middleware: Middleware chain used to edit requests before they are sent and responses before they are decoded 
    ///     - timeout: Timeout value for HTTP requests
    ///     - byteBufferAllocator: Allocator for ByteBuffers
    ///     - options: Service options
    public init(
        client: AWSClient,
        region: SotoCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        middleware: AWSMiddlewareProtocol? = nil,
        timeout: TimeAmount? = nil,
        byteBufferAllocator: ByteBufferAllocator = ByteBufferAllocator(),
        options: AWSServiceConfig.Options = []
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            serviceName: "EMRContainers",
            serviceIdentifier: "emr-containers",
            serviceProtocol: .restjson,
            apiVersion: "2020-10-01",
            endpoint: endpoint,
            variantEndpoints: Self.variantEndpoints,
            errorType: EMRContainersErrorType.self,
            middleware: middleware,
            timeout: timeout,
            byteBufferAllocator: byteBufferAllocator,
            options: options
        )
    }




    /// FIPS and dualstack endpoints
    static var variantEndpoints: [EndpointVariantType: AWSServiceConfig.EndpointVariant] {[
        [.fips]: .init(endpoints: [
            "ca-central-1": "emr-containers-fips.ca-central-1.amazonaws.com",
            "us-east-1": "emr-containers-fips.us-east-1.amazonaws.com",
            "us-east-2": "emr-containers-fips.us-east-2.amazonaws.com",
            "us-gov-east-1": "emr-containers.us-gov-east-1.amazonaws.com",
            "us-gov-west-1": "emr-containers.us-gov-west-1.amazonaws.com",
            "us-west-1": "emr-containers-fips.us-west-1.amazonaws.com",
            "us-west-2": "emr-containers-fips.us-west-2.amazonaws.com"
        ])
    ]}

    // MARK: API Calls

    /// Cancels a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    @Sendable
    @inlinable
    public func cancelJobRun(_ input: CancelJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CancelJobRunResponse {
        try await self.client.execute(
            operation: "CancelJobRun", 
            path: "/virtualclusters/{virtualClusterId}/jobruns/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Cancels a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    ///
    /// Parameters:
    ///   - id: The ID of the job run to cancel.
    ///   - virtualClusterId: The ID of the virtual cluster for which the job run will be canceled.
    ///   - logger: Logger use during operation
    @inlinable
    public func cancelJobRun(
        id: String,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CancelJobRunResponse {
        let input = CancelJobRunRequest(
            id: id, 
            virtualClusterId: virtualClusterId
        )
        return try await self.cancelJobRun(input, logger: logger)
    }

    /// Creates a job template. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    @Sendable
    @inlinable
    public func createJobTemplate(_ input: CreateJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateJobTemplateResponse {
        try await self.client.execute(
            operation: "CreateJobTemplate", 
            path: "/jobtemplates", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a job template. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    ///
    /// Parameters:
    ///   - clientToken: The client token of the job template.
    ///   - jobTemplateData: The job template data which holds values of StartJobRun API request.
    ///   - kmsKeyArn: The KMS key ARN used to encrypt the job template.
    ///   - name: The specified name of the job template.
    ///   - tags: The tags that are associated with the job template.
    ///   - logger: Logger use during operation
    @inlinable
    public func createJobTemplate(
        clientToken: String = CreateJobTemplateRequest.idempotencyToken(),
        jobTemplateData: JobTemplateData,
        kmsKeyArn: String? = nil,
        name: String,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateJobTemplateResponse {
        let input = CreateJobTemplateRequest(
            clientToken: clientToken, 
            jobTemplateData: jobTemplateData, 
            kmsKeyArn: kmsKeyArn, 
            name: name, 
            tags: tags
        )
        return try await self.createJobTemplate(input, logger: logger)
    }

    /// Creates a managed endpoint. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    @Sendable
    @inlinable
    public func createManagedEndpoint(_ input: CreateManagedEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateManagedEndpointResponse {
        try await self.client.execute(
            operation: "CreateManagedEndpoint", 
            path: "/virtualclusters/{virtualClusterId}/endpoints", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a managed endpoint. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    ///
    /// Parameters:
    ///   - clientToken: The client idempotency token for this create call.
    ///   - configurationOverrides: The configuration settings that will be used to override existing configurations.
    ///   - executionRoleArn: The ARN of the execution role.
    ///   - name: The name of the managed endpoint.
    ///   - releaseLabel: The Amazon EMR release version.
    ///   - tags: The tags of the managed endpoint.
    ///   - type: The type of the managed endpoint.
    ///   - virtualClusterId: The ID of the virtual cluster for which a managed endpoint is created.
    ///   - logger: Logger use during operation
    @inlinable
    public func createManagedEndpoint(
        clientToken: String = CreateManagedEndpointRequest.idempotencyToken(),
        configurationOverrides: ConfigurationOverrides? = nil,
        executionRoleArn: String,
        name: String,
        releaseLabel: String,
        tags: [String: String]? = nil,
        type: String,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateManagedEndpointResponse {
        let input = CreateManagedEndpointRequest(
            clientToken: clientToken, 
            configurationOverrides: configurationOverrides, 
            executionRoleArn: executionRoleArn, 
            name: name, 
            releaseLabel: releaseLabel, 
            tags: tags, 
            type: type, 
            virtualClusterId: virtualClusterId
        )
        return try await self.createManagedEndpoint(input, logger: logger)
    }

    /// Creates a security configuration. Security configurations in Amazon EMR on EKS are templates for different security setups. You can use security configurations to configure the Lake Formation integration setup. You can also create a security configuration to re-use a security setup each time you create a virtual cluster.
    @Sendable
    @inlinable
    public func createSecurityConfiguration(_ input: CreateSecurityConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateSecurityConfigurationResponse {
        try await self.client.execute(
            operation: "CreateSecurityConfiguration", 
            path: "/securityconfigurations", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a security configuration. Security configurations in Amazon EMR on EKS are templates for different security setups. You can use security configurations to configure the Lake Formation integration setup. You can also create a security configuration to re-use a security setup each time you create a virtual cluster.
    ///
    /// Parameters:
    ///   - clientToken: The client idempotency token to use when creating the security configuration.
    ///   - name: The name of the security configuration.
    ///   - securityConfigurationData: Security configuration input for the request.
    ///   - tags: The tags to add to the security configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func createSecurityConfiguration(
        clientToken: String = CreateSecurityConfigurationRequest.idempotencyToken(),
        name: String,
        securityConfigurationData: SecurityConfigurationData,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateSecurityConfigurationResponse {
        let input = CreateSecurityConfigurationRequest(
            clientToken: clientToken, 
            name: name, 
            securityConfigurationData: securityConfigurationData, 
            tags: tags
        )
        return try await self.createSecurityConfiguration(input, logger: logger)
    }

    /// Creates a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    @Sendable
    @inlinable
    public func createVirtualCluster(_ input: CreateVirtualClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> CreateVirtualClusterResponse {
        try await self.client.execute(
            operation: "CreateVirtualCluster", 
            path: "/virtualclusters", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Creates a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    ///
    /// Parameters:
    ///   - clientToken: The client token of the virtual cluster.
    ///   - containerProvider: The container provider of the virtual cluster.
    ///   - name: The specified name of the virtual cluster.
    ///   - securityConfigurationId: The ID of the security configuration.
    ///   - tags: The tags assigned to the virtual cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func createVirtualCluster(
        clientToken: String = CreateVirtualClusterRequest.idempotencyToken(),
        containerProvider: ContainerProvider,
        name: String,
        securityConfigurationId: String? = nil,
        tags: [String: String]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> CreateVirtualClusterResponse {
        let input = CreateVirtualClusterRequest(
            clientToken: clientToken, 
            containerProvider: containerProvider, 
            name: name, 
            securityConfigurationId: securityConfigurationId, 
            tags: tags
        )
        return try await self.createVirtualCluster(input, logger: logger)
    }

    /// Deletes a job template. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    @Sendable
    @inlinable
    public func deleteJobTemplate(_ input: DeleteJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteJobTemplateResponse {
        try await self.client.execute(
            operation: "DeleteJobTemplate", 
            path: "/jobtemplates/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a job template. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    ///
    /// Parameters:
    ///   - id: The ID of the job template that will be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteJobTemplate(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteJobTemplateResponse {
        let input = DeleteJobTemplateRequest(
            id: id
        )
        return try await self.deleteJobTemplate(input, logger: logger)
    }

    /// Deletes a managed endpoint. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    @Sendable
    @inlinable
    public func deleteManagedEndpoint(_ input: DeleteManagedEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteManagedEndpointResponse {
        try await self.client.execute(
            operation: "DeleteManagedEndpoint", 
            path: "/virtualclusters/{virtualClusterId}/endpoints/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a managed endpoint. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    ///
    /// Parameters:
    ///   - id: The ID of the managed endpoint.
    ///   - virtualClusterId: The ID of the endpoint's virtual cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteManagedEndpoint(
        id: String,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteManagedEndpointResponse {
        let input = DeleteManagedEndpointRequest(
            id: id, 
            virtualClusterId: virtualClusterId
        )
        return try await self.deleteManagedEndpoint(input, logger: logger)
    }

    /// Deletes a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    @Sendable
    @inlinable
    public func deleteVirtualCluster(_ input: DeleteVirtualClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DeleteVirtualClusterResponse {
        try await self.client.execute(
            operation: "DeleteVirtualCluster", 
            path: "/virtualclusters/{id}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Deletes a virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    ///
    /// Parameters:
    ///   - id: The ID of the virtual cluster that will be deleted.
    ///   - logger: Logger use during operation
    @inlinable
    public func deleteVirtualCluster(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DeleteVirtualClusterResponse {
        let input = DeleteVirtualClusterRequest(
            id: id
        )
        return try await self.deleteVirtualCluster(input, logger: logger)
    }

    /// Displays detailed information about a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    @Sendable
    @inlinable
    public func describeJobRun(_ input: DescribeJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobRunResponse {
        try await self.client.execute(
            operation: "DescribeJobRun", 
            path: "/virtualclusters/{virtualClusterId}/jobruns/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Displays detailed information about a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    ///
    /// Parameters:
    ///   - id: The ID of the job run request.
    ///   - virtualClusterId: The ID of the virtual cluster for which the job run is submitted.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobRun(
        id: String,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobRunResponse {
        let input = DescribeJobRunRequest(
            id: id, 
            virtualClusterId: virtualClusterId
        )
        return try await self.describeJobRun(input, logger: logger)
    }

    /// Displays detailed information about a specified job template. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    @Sendable
    @inlinable
    public func describeJobTemplate(_ input: DescribeJobTemplateRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeJobTemplateResponse {
        try await self.client.execute(
            operation: "DescribeJobTemplate", 
            path: "/jobtemplates/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Displays detailed information about a specified job template. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    ///
    /// Parameters:
    ///   - id: The ID of the job template that will be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeJobTemplate(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeJobTemplateResponse {
        let input = DescribeJobTemplateRequest(
            id: id
        )
        return try await self.describeJobTemplate(input, logger: logger)
    }

    /// Displays detailed information about a managed endpoint. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    @Sendable
    @inlinable
    public func describeManagedEndpoint(_ input: DescribeManagedEndpointRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeManagedEndpointResponse {
        try await self.client.execute(
            operation: "DescribeManagedEndpoint", 
            path: "/virtualclusters/{virtualClusterId}/endpoints/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Displays detailed information about a managed endpoint. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    ///
    /// Parameters:
    ///   - id: This output displays ID of the managed endpoint.
    ///   - virtualClusterId: The ID of the endpoint's virtual cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeManagedEndpoint(
        id: String,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeManagedEndpointResponse {
        let input = DescribeManagedEndpointRequest(
            id: id, 
            virtualClusterId: virtualClusterId
        )
        return try await self.describeManagedEndpoint(input, logger: logger)
    }

    /// Displays detailed information about a specified security configuration. Security configurations in Amazon EMR on EKS are templates for different security setups. You can use security configurations to configure the Lake Formation integration setup. You can also create a security configuration to re-use a security setup each time you create a virtual cluster.
    @Sendable
    @inlinable
    public func describeSecurityConfiguration(_ input: DescribeSecurityConfigurationRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeSecurityConfigurationResponse {
        try await self.client.execute(
            operation: "DescribeSecurityConfiguration", 
            path: "/securityconfigurations/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Displays detailed information about a specified security configuration. Security configurations in Amazon EMR on EKS are templates for different security setups. You can use security configurations to configure the Lake Formation integration setup. You can also create a security configuration to re-use a security setup each time you create a virtual cluster.
    ///
    /// Parameters:
    ///   - id: The ID of the security configuration.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeSecurityConfiguration(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeSecurityConfigurationResponse {
        let input = DescribeSecurityConfigurationRequest(
            id: id
        )
        return try await self.describeSecurityConfiguration(input, logger: logger)
    }

    /// Displays detailed information about a specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    @Sendable
    @inlinable
    public func describeVirtualCluster(_ input: DescribeVirtualClusterRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> DescribeVirtualClusterResponse {
        try await self.client.execute(
            operation: "DescribeVirtualCluster", 
            path: "/virtualclusters/{id}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Displays detailed information about a specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    ///
    /// Parameters:
    ///   - id: The ID of the virtual cluster that will be described.
    ///   - logger: Logger use during operation
    @inlinable
    public func describeVirtualCluster(
        id: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> DescribeVirtualClusterResponse {
        let input = DescribeVirtualClusterRequest(
            id: id
        )
        return try await self.describeVirtualCluster(input, logger: logger)
    }

    /// Generate a session token to connect to a managed endpoint.
    @Sendable
    @inlinable
    public func getManagedEndpointSessionCredentials(_ input: GetManagedEndpointSessionCredentialsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> GetManagedEndpointSessionCredentialsResponse {
        try await self.client.execute(
            operation: "GetManagedEndpointSessionCredentials", 
            path: "/virtualclusters/{virtualClusterIdentifier}/endpoints/{endpointIdentifier}/credentials", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Generate a session token to connect to a managed endpoint.
    ///
    /// Parameters:
    ///   - clientToken: The client idempotency token of the job run request.
    ///   - credentialType: Type of the token requested. Currently supported and default value of this field is “TOKEN.”
    ///   - durationInSeconds: Duration in seconds for which the session token is valid. The default duration is 15 minutes and the maximum is 12 hours.
    ///   - endpointIdentifier: The ARN of the managed endpoint for which the request is submitted.
    ///   - executionRoleArn: The IAM Execution Role ARN that will be used by the job run.
    ///   - logContext: String identifier used to separate sections of the execution logs uploaded to S3.
    ///   - virtualClusterIdentifier: The ARN of the Virtual Cluster which the Managed Endpoint belongs to.
    ///   - logger: Logger use during operation
    @inlinable
    public func getManagedEndpointSessionCredentials(
        clientToken: String? = GetManagedEndpointSessionCredentialsRequest.idempotencyToken(),
        credentialType: String,
        durationInSeconds: Int? = nil,
        endpointIdentifier: String,
        executionRoleArn: String,
        logContext: String? = nil,
        virtualClusterIdentifier: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> GetManagedEndpointSessionCredentialsResponse {
        let input = GetManagedEndpointSessionCredentialsRequest(
            clientToken: clientToken, 
            credentialType: credentialType, 
            durationInSeconds: durationInSeconds, 
            endpointIdentifier: endpointIdentifier, 
            executionRoleArn: executionRoleArn, 
            logContext: logContext, 
            virtualClusterIdentifier: virtualClusterIdentifier
        )
        return try await self.getManagedEndpointSessionCredentials(input, logger: logger)
    }

    /// Lists job runs based on a set of parameters. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    @Sendable
    @inlinable
    public func listJobRuns(_ input: ListJobRunsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobRunsResponse {
        try await self.client.execute(
            operation: "ListJobRuns", 
            path: "/virtualclusters/{virtualClusterId}/jobruns", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists job runs based on a set of parameters. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    ///
    /// Parameters:
    ///   - createdAfter: The date and time after which the job runs were submitted.
    ///   - createdBefore: The date and time before which the job runs were submitted.
    ///   - maxResults: The maximum number of job runs that can be listed.
    ///   - name: The name of the job run.
    ///   - nextToken: The token for the next set of job runs to return.
    ///   - states: The states of the job run.
    ///   - virtualClusterId: The ID of the virtual cluster for which to list the job run.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobRuns(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        name: String? = nil,
        nextToken: String? = nil,
        states: [JobRunState]? = nil,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobRunsResponse {
        let input = ListJobRunsRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults, 
            name: name, 
            nextToken: nextToken, 
            states: states, 
            virtualClusterId: virtualClusterId
        )
        return try await self.listJobRuns(input, logger: logger)
    }

    /// Lists job templates based on a set of parameters. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    @Sendable
    @inlinable
    public func listJobTemplates(_ input: ListJobTemplatesRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListJobTemplatesResponse {
        try await self.client.execute(
            operation: "ListJobTemplates", 
            path: "/jobtemplates", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists job templates based on a set of parameters. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    ///
    /// Parameters:
    ///   - createdAfter: The date and time after which the job templates were created.
    ///   - createdBefore:  The date and time before which the job templates were created.
    ///   - maxResults:  The maximum number of job templates that can be listed.
    ///   - nextToken:  The token for the next set of job templates to return.
    ///   - logger: Logger use during operation
    @inlinable
    public func listJobTemplates(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListJobTemplatesResponse {
        let input = ListJobTemplatesRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listJobTemplates(input, logger: logger)
    }

    /// Lists managed endpoints based on a set of parameters. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    @Sendable
    @inlinable
    public func listManagedEndpoints(_ input: ListManagedEndpointsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListManagedEndpointsResponse {
        try await self.client.execute(
            operation: "ListManagedEndpoints", 
            path: "/virtualclusters/{virtualClusterId}/endpoints", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists managed endpoints based on a set of parameters. A managed endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR Studio can communicate with your virtual cluster.
    ///
    /// Parameters:
    ///   - createdAfter:  The date and time after which the endpoints are created.
    ///   - createdBefore: The date and time before which the endpoints are created.
    ///   - maxResults: The maximum number of managed endpoints that can be listed.
    ///   - nextToken:  The token for the next set of managed endpoints to return.
    ///   - states: The states of the managed endpoints.
    ///   - types: The types of the managed endpoints.
    ///   - virtualClusterId: The ID of the virtual cluster.
    ///   - logger: Logger use during operation
    @inlinable
    public func listManagedEndpoints(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        states: [EndpointState]? = nil,
        types: [String]? = nil,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListManagedEndpointsResponse {
        let input = ListManagedEndpointsRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            states: states, 
            types: types, 
            virtualClusterId: virtualClusterId
        )
        return try await self.listManagedEndpoints(input, logger: logger)
    }

    /// Lists security configurations based on a set of parameters. Security configurations in Amazon EMR on EKS are templates for different security setups. You can use security configurations to configure the Lake Formation integration setup. You can also create a security configuration to re-use a security setup each time you create a virtual cluster.
    @Sendable
    @inlinable
    public func listSecurityConfigurations(_ input: ListSecurityConfigurationsRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListSecurityConfigurationsResponse {
        try await self.client.execute(
            operation: "ListSecurityConfigurations", 
            path: "/securityconfigurations", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists security configurations based on a set of parameters. Security configurations in Amazon EMR on EKS are templates for different security setups. You can use security configurations to configure the Lake Formation integration setup. You can also create a security configuration to re-use a security setup each time you create a virtual cluster.
    ///
    /// Parameters:
    ///   - createdAfter: The date and time after which the security configuration was created.
    ///   - createdBefore: The date and time before which the security configuration was created.
    ///   - maxResults: The maximum number of security configurations the operation can list.
    ///   - nextToken: The token for the next set of security configurations to return.
    ///   - logger: Logger use during operation
    @inlinable
    public func listSecurityConfigurations(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListSecurityConfigurationsResponse {
        let input = ListSecurityConfigurationsRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults, 
            nextToken: nextToken
        )
        return try await self.listSecurityConfigurations(input, logger: logger)
    }

    /// Lists the tags assigned to the resources.
    @Sendable
    @inlinable
    public func listTagsForResource(_ input: ListTagsForResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListTagsForResourceResponse {
        try await self.client.execute(
            operation: "ListTagsForResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists the tags assigned to the resources.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of tagged resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func listTagsForResource(
        resourceArn: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListTagsForResourceResponse {
        let input = ListTagsForResourceRequest(
            resourceArn: resourceArn
        )
        return try await self.listTagsForResource(input, logger: logger)
    }

    /// Lists information about the specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    @Sendable
    @inlinable
    public func listVirtualClusters(_ input: ListVirtualClustersRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> ListVirtualClustersResponse {
        try await self.client.execute(
            operation: "ListVirtualClusters", 
            path: "/virtualclusters", 
            httpMethod: .GET, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Lists information about the specified virtual cluster. Virtual cluster is a managed entity on Amazon EMR on EKS. You can create, describe, list and delete virtual clusters. They do not consume any additional resource in your system. A single virtual cluster maps to a single Kubernetes namespace. Given this relationship, you can model virtual clusters the same way you model Kubernetes namespaces to meet your requirements.
    ///
    /// Parameters:
    ///   - containerProviderId: The container provider ID of the virtual cluster.
    ///   - containerProviderType: The container provider type of the virtual cluster. Amazon EKS is the only supported type as of now.
    ///   - createdAfter: The date and time after which the virtual clusters are created.
    ///   - createdBefore: The date and time before which the virtual clusters are created.
    ///   - eksAccessEntryIntegrated: Optional Boolean that specifies whether the operation should return the  virtual clusters that have the access entry integration enabled or disabled. If not specified, the operation returns all applicable virtual clusters.
    ///   - maxResults: The maximum number of virtual clusters that can be listed.
    ///   - nextToken: The token for the next set of virtual clusters to return.
    ///   - states: The states of the requested virtual clusters.
    ///   - logger: Logger use during operation
    @inlinable
    public func listVirtualClusters(
        containerProviderId: String? = nil,
        containerProviderType: ContainerProviderType? = nil,
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        eksAccessEntryIntegrated: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        states: [VirtualClusterState]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> ListVirtualClustersResponse {
        let input = ListVirtualClustersRequest(
            containerProviderId: containerProviderId, 
            containerProviderType: containerProviderType, 
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            eksAccessEntryIntegrated: eksAccessEntryIntegrated, 
            maxResults: maxResults, 
            nextToken: nextToken, 
            states: states
        )
        return try await self.listVirtualClusters(input, logger: logger)
    }

    /// Starts a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    @Sendable
    @inlinable
    public func startJobRun(_ input: StartJobRunRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> StartJobRunResponse {
        try await self.client.execute(
            operation: "StartJobRun", 
            path: "/virtualclusters/{virtualClusterId}/jobruns", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Starts a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    ///
    /// Parameters:
    ///   - clientToken: The client idempotency token of the job run request.
    ///   - configurationOverrides: The configuration overrides for the job run.
    ///   - executionRoleArn: The execution role ARN for the job run.
    ///   - jobDriver: The job driver for the job run.
    ///   - jobTemplateId: The job template ID to be used to start the job run.
    ///   - jobTemplateParameters: The values of job template parameters to start a job run.
    ///   - name: The name of the job run.
    ///   - releaseLabel: The Amazon EMR release version to use for the job run.
    ///   - retryPolicyConfiguration: The retry policy configuration for the job run.
    ///   - tags: The tags assigned to job runs.
    ///   - virtualClusterId: The virtual cluster ID for which the job run request is submitted.
    ///   - logger: Logger use during operation
    @inlinable
    public func startJobRun(
        clientToken: String = StartJobRunRequest.idempotencyToken(),
        configurationOverrides: ConfigurationOverrides? = nil,
        executionRoleArn: String? = nil,
        jobDriver: JobDriver? = nil,
        jobTemplateId: String? = nil,
        jobTemplateParameters: [String: String]? = nil,
        name: String? = nil,
        releaseLabel: String? = nil,
        retryPolicyConfiguration: RetryPolicyConfiguration? = nil,
        tags: [String: String]? = nil,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> StartJobRunResponse {
        let input = StartJobRunRequest(
            clientToken: clientToken, 
            configurationOverrides: configurationOverrides, 
            executionRoleArn: executionRoleArn, 
            jobDriver: jobDriver, 
            jobTemplateId: jobTemplateId, 
            jobTemplateParameters: jobTemplateParameters, 
            name: name, 
            releaseLabel: releaseLabel, 
            retryPolicyConfiguration: retryPolicyConfiguration, 
            tags: tags, 
            virtualClusterId: virtualClusterId
        )
        return try await self.startJobRun(input, logger: logger)
    }

    /// Assigns tags to resources. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define. Tags enable you to categorize your Amazon Web Services resources by attributes such as purpose, owner, or environment. When you have many resources of the same type, you can quickly identify a specific resource based on the tags you've assigned to it. For example, you can define a set of tags for your Amazon EMR on EKS clusters to help you track each cluster's owner and stack level. We recommend that you devise a consistent set of tag keys for each resource type. You can then search and filter the resources based on the tags that you add.
    @Sendable
    @inlinable
    public func tagResource(_ input: TagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> TagResourceResponse {
        try await self.client.execute(
            operation: "TagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .POST, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Assigns tags to resources. A tag is a label that you assign to an Amazon Web Services resource. Each tag consists of a key and an optional value, both of which you define. Tags enable you to categorize your Amazon Web Services resources by attributes such as purpose, owner, or environment. When you have many resources of the same type, you can quickly identify a specific resource based on the tags you've assigned to it. For example, you can define a set of tags for your Amazon EMR on EKS clusters to help you track each cluster's owner and stack level. We recommend that you devise a consistent set of tag keys for each resource type. You can then search and filter the resources based on the tags that you add.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of resources.
    ///   - tags: The tags assigned to resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func tagResource(
        resourceArn: String,
        tags: [String: String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> TagResourceResponse {
        let input = TagResourceRequest(
            resourceArn: resourceArn, 
            tags: tags
        )
        return try await self.tagResource(input, logger: logger)
    }

    /// Removes tags from resources.
    @Sendable
    @inlinable
    public func untagResource(_ input: UntagResourceRequest, logger: Logger = AWSClient.loggingDisabled) async throws -> UntagResourceResponse {
        try await self.client.execute(
            operation: "UntagResource", 
            path: "/tags/{resourceArn}", 
            httpMethod: .DELETE, 
            serviceConfig: self.config, 
            input: input, 
            logger: logger
        )
    }
    /// Removes tags from resources.
    ///
    /// Parameters:
    ///   - resourceArn: The ARN of resources.
    ///   - tagKeys: The tag keys of the resources.
    ///   - logger: Logger use during operation
    @inlinable
    public func untagResource(
        resourceArn: String,
        tagKeys: [String],
        logger: Logger = AWSClient.loggingDisabled        
    ) async throws -> UntagResourceResponse {
        let input = UntagResourceRequest(
            resourceArn: resourceArn, 
            tagKeys: tagKeys
        )
        return try await self.untagResource(input, logger: logger)
    }
}

extension EMRContainers {
    /// Initializer required by `AWSService.with(middlewares:timeout:byteBufferAllocator:options)`. You are not able to use this initializer directly as there are not public
    /// initializers for `AWSServiceConfig.Patch`. Please use `AWSService.with(middlewares:timeout:byteBufferAllocator:options)` instead.
    public init(from: EMRContainers, patch: AWSServiceConfig.Patch) {
        self.client = from.client
        self.config = from.config.with(patch: patch)
    }
}

// MARK: Paginators

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension EMRContainers {
    /// Return PaginatorSequence for operation ``listJobRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobRunsPaginator(
        _ input: ListJobRunsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobRunsRequest, ListJobRunsResponse> {
        return .init(
            input: input,
            command: self.listJobRuns,
            inputKey: \ListJobRunsRequest.nextToken,
            outputKey: \ListJobRunsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobRuns(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAfter: The date and time after which the job runs were submitted.
    ///   - createdBefore: The date and time before which the job runs were submitted.
    ///   - maxResults: The maximum number of job runs that can be listed.
    ///   - name: The name of the job run.
    ///   - states: The states of the job run.
    ///   - virtualClusterId: The ID of the virtual cluster for which to list the job run.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobRunsPaginator(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        name: String? = nil,
        states: [JobRunState]? = nil,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobRunsRequest, ListJobRunsResponse> {
        let input = ListJobRunsRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults, 
            name: name, 
            states: states, 
            virtualClusterId: virtualClusterId
        )
        return self.listJobRunsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobTemplatesPaginator(
        _ input: ListJobTemplatesRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListJobTemplatesRequest, ListJobTemplatesResponse> {
        return .init(
            input: input,
            command: self.listJobTemplates,
            inputKey: \ListJobTemplatesRequest.nextToken,
            outputKey: \ListJobTemplatesResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listJobTemplates(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAfter: The date and time after which the job templates were created.
    ///   - createdBefore:  The date and time before which the job templates were created.
    ///   - maxResults:  The maximum number of job templates that can be listed.
    ///   - logger: Logger used for logging
    @inlinable
    public func listJobTemplatesPaginator(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListJobTemplatesRequest, ListJobTemplatesResponse> {
        let input = ListJobTemplatesRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults
        )
        return self.listJobTemplatesPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listManagedEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedEndpointsPaginator(
        _ input: ListManagedEndpointsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListManagedEndpointsRequest, ListManagedEndpointsResponse> {
        return .init(
            input: input,
            command: self.listManagedEndpoints,
            inputKey: \ListManagedEndpointsRequest.nextToken,
            outputKey: \ListManagedEndpointsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listManagedEndpoints(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAfter:  The date and time after which the endpoints are created.
    ///   - createdBefore: The date and time before which the endpoints are created.
    ///   - maxResults: The maximum number of managed endpoints that can be listed.
    ///   - states: The states of the managed endpoints.
    ///   - types: The types of the managed endpoints.
    ///   - virtualClusterId: The ID of the virtual cluster.
    ///   - logger: Logger used for logging
    @inlinable
    public func listManagedEndpointsPaginator(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        states: [EndpointState]? = nil,
        types: [String]? = nil,
        virtualClusterId: String,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListManagedEndpointsRequest, ListManagedEndpointsResponse> {
        let input = ListManagedEndpointsRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults, 
            states: states, 
            types: types, 
            virtualClusterId: virtualClusterId
        )
        return self.listManagedEndpointsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listSecurityConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listSecurityConfigurationsPaginator(
        _ input: ListSecurityConfigurationsRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListSecurityConfigurationsRequest, ListSecurityConfigurationsResponse> {
        return .init(
            input: input,
            command: self.listSecurityConfigurations,
            inputKey: \ListSecurityConfigurationsRequest.nextToken,
            outputKey: \ListSecurityConfigurationsResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listSecurityConfigurations(_:logger:)``.
    ///
    /// - Parameters:
    ///   - createdAfter: The date and time after which the security configuration was created.
    ///   - createdBefore: The date and time before which the security configuration was created.
    ///   - maxResults: The maximum number of security configurations the operation can list.
    ///   - logger: Logger used for logging
    @inlinable
    public func listSecurityConfigurationsPaginator(
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        maxResults: Int? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListSecurityConfigurationsRequest, ListSecurityConfigurationsResponse> {
        let input = ListSecurityConfigurationsRequest(
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            maxResults: maxResults
        )
        return self.listSecurityConfigurationsPaginator(input, logger: logger)
    }

    /// Return PaginatorSequence for operation ``listVirtualClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - input: Input for operation
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualClustersPaginator(
        _ input: ListVirtualClustersRequest,
        logger: Logger = AWSClient.loggingDisabled
    ) -> AWSClient.PaginatorSequence<ListVirtualClustersRequest, ListVirtualClustersResponse> {
        return .init(
            input: input,
            command: self.listVirtualClusters,
            inputKey: \ListVirtualClustersRequest.nextToken,
            outputKey: \ListVirtualClustersResponse.nextToken,
            logger: logger
        )
    }
    /// Return PaginatorSequence for operation ``listVirtualClusters(_:logger:)``.
    ///
    /// - Parameters:
    ///   - containerProviderId: The container provider ID of the virtual cluster.
    ///   - containerProviderType: The container provider type of the virtual cluster. Amazon EKS is the only supported type as of now.
    ///   - createdAfter: The date and time after which the virtual clusters are created.
    ///   - createdBefore: The date and time before which the virtual clusters are created.
    ///   - eksAccessEntryIntegrated: Optional Boolean that specifies whether the operation should return the  virtual clusters that have the access entry integration enabled or disabled. If not specified, the operation returns all applicable virtual clusters.
    ///   - maxResults: The maximum number of virtual clusters that can be listed.
    ///   - states: The states of the requested virtual clusters.
    ///   - logger: Logger used for logging
    @inlinable
    public func listVirtualClustersPaginator(
        containerProviderId: String? = nil,
        containerProviderType: ContainerProviderType? = nil,
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        eksAccessEntryIntegrated: Bool? = nil,
        maxResults: Int? = nil,
        states: [VirtualClusterState]? = nil,
        logger: Logger = AWSClient.loggingDisabled        
    ) -> AWSClient.PaginatorSequence<ListVirtualClustersRequest, ListVirtualClustersResponse> {
        let input = ListVirtualClustersRequest(
            containerProviderId: containerProviderId, 
            containerProviderType: containerProviderType, 
            createdAfter: createdAfter, 
            createdBefore: createdBefore, 
            eksAccessEntryIntegrated: eksAccessEntryIntegrated, 
            maxResults: maxResults, 
            states: states
        )
        return self.listVirtualClustersPaginator(input, logger: logger)
    }
}

extension EMRContainers.ListJobRunsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EMRContainers.ListJobRunsRequest {
        return .init(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            states: self.states,
            virtualClusterId: self.virtualClusterId
        )
    }
}

extension EMRContainers.ListJobTemplatesRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EMRContainers.ListJobTemplatesRequest {
        return .init(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EMRContainers.ListManagedEndpointsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EMRContainers.ListManagedEndpointsRequest {
        return .init(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token,
            states: self.states,
            types: self.types,
            virtualClusterId: self.virtualClusterId
        )
    }
}

extension EMRContainers.ListSecurityConfigurationsRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EMRContainers.ListSecurityConfigurationsRequest {
        return .init(
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            maxResults: self.maxResults,
            nextToken: token
        )
    }
}

extension EMRContainers.ListVirtualClustersRequest: AWSPaginateToken {
    @inlinable
    public func usingPaginationToken(_ token: String) -> EMRContainers.ListVirtualClustersRequest {
        return .init(
            containerProviderId: self.containerProviderId,
            containerProviderType: self.containerProviderType,
            createdAfter: self.createdAfter,
            createdBefore: self.createdBefore,
            eksAccessEntryIntegrated: self.eksAccessEntryIntegrated,
            maxResults: self.maxResults,
            nextToken: token,
            states: self.states
        )
    }
}
