//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if canImport(FoundationEssentials)
import FoundationEssentials
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension BackupSearch {
    // MARK: Enums

    public enum ExportJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        public var description: String { return self.rawValue }
    }

    public enum LongConditionOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equalsTo = "EQUALS_TO"
        case greaterThanEqualTo = "GREATER_THAN_EQUAL_TO"
        case lessThanEqualTo = "LESS_THAN_EQUAL_TO"
        case notEqualsTo = "NOT_EQUALS_TO"
        public var description: String { return self.rawValue }
    }

    public enum ResourceType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case ebs = "EBS"
        case s3 = "S3"
        public var description: String { return self.rawValue }
    }

    public enum SearchJobState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case running = "RUNNING"
        case stopped = "STOPPED"
        case stopping = "STOPPING"
        public var description: String { return self.rawValue }
    }

    public enum StringConditionOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case beginsWith = "BEGINS_WITH"
        case contains = "CONTAINS"
        case doesNotBeginWith = "DOES_NOT_BEGIN_WITH"
        case doesNotContain = "DOES_NOT_CONTAIN"
        case doesNotEndWith = "DOES_NOT_END_WITH"
        case endsWith = "ENDS_WITH"
        case equalsTo = "EQUALS_TO"
        case notEqualsTo = "NOT_EQUALS_TO"
        public var description: String { return self.rawValue }
    }

    public enum TimeConditionOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case equalsTo = "EQUALS_TO"
        case greaterThanEqualTo = "GREATER_THAN_EQUAL_TO"
        case lessThanEqualTo = "LESS_THAN_EQUAL_TO"
        case notEqualsTo = "NOT_EQUALS_TO"
        public var description: String { return self.rawValue }
    }

    public enum ResultItem: AWSDecodableShape, Sendable {
        /// These are items returned in the search results  of an Amazon EBS search.
        case ebsResultItem(EBSResultItem)
        /// These are items returned in the search results  of an Amazon S3 search.
        case s3ResultItem(S3ResultItem)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .ebsResultItem:
                let value = try container.decode(EBSResultItem.self, forKey: .ebsResultItem)
                self = .ebsResultItem(value)
            case .s3ResultItem:
                let value = try container.decode(S3ResultItem.self, forKey: .s3ResultItem)
                self = .s3ResultItem(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case ebsResultItem = "EBSResultItem"
            case s3ResultItem = "S3ResultItem"
        }
    }

    // MARK: Shapes

    public struct BackupCreationTimeFilter: AWSEncodableShape & AWSDecodableShape {
        /// This timestamp includes recovery points only  created after the specified time.
        public let createdAfter: Date?
        /// This timestamp includes recovery points only  created before the specified time.
        public let createdBefore: Date?

        @inlinable
        public init(createdAfter: Date? = nil, createdBefore: Date? = nil) {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
        }

        private enum CodingKeys: String, CodingKey {
            case createdAfter = "CreatedAfter"
            case createdBefore = "CreatedBefore"
        }
    }

    public struct ConflictException: AWSErrorShape {
        /// Updating or deleting a resource can cause an inconsistent state.
        public let message: String
        /// Identifier of the resource affected.
        public let resourceId: String
        /// Type of the resource affected.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct CurrentSearchProgress: AWSDecodableShape {
        /// This number is the sum of all items that match  the item filters in a search job in progress.
        public let itemsMatchedCount: Int64?
        /// This number is the sum of all items that  have been scanned so far during a search job.
        public let itemsScannedCount: Int64?
        /// This number is the sum of all backups that  have been scanned so far during a search job.
        public let recoveryPointsScannedCount: Int?

        @inlinable
        public init(itemsMatchedCount: Int64? = nil, itemsScannedCount: Int64? = nil, recoveryPointsScannedCount: Int? = nil) {
            self.itemsMatchedCount = itemsMatchedCount
            self.itemsScannedCount = itemsScannedCount
            self.recoveryPointsScannedCount = recoveryPointsScannedCount
        }

        private enum CodingKeys: String, CodingKey {
            case itemsMatchedCount = "ItemsMatchedCount"
            case itemsScannedCount = "ItemsScannedCount"
            case recoveryPointsScannedCount = "RecoveryPointsScannedCount"
        }
    }

    public struct EBSItemFilter: AWSEncodableShape & AWSDecodableShape {
        /// You can include 1 to 10 values. If one is included, the results will  return only items that match. If more than one is included, the  results will return all items that match any of  the included values.
        public let creationTimes: [TimeCondition]?
        /// You can include 1 to 10 values. If one file path is included, the results will  return only items that match the file path. If more than one file path is included, the  results will return all items that match any of the  file paths.
        public let filePaths: [StringCondition]?
        /// You can include 1 to 10 values. If one is included, the results will  return only items that match. If more than one is included, the  results will return all items that match any of  the included values.
        public let lastModificationTimes: [TimeCondition]?
        /// You can include 1 to 10 values. If one is included, the results will  return only items that match. If more than one is included, the  results will return all items that match any of  the included values.
        public let sizes: [LongCondition]?

        @inlinable
        public init(creationTimes: [TimeCondition]? = nil, filePaths: [StringCondition]? = nil, lastModificationTimes: [TimeCondition]? = nil, sizes: [LongCondition]? = nil) {
            self.creationTimes = creationTimes
            self.filePaths = filePaths
            self.lastModificationTimes = lastModificationTimes
            self.sizes = sizes
        }

        public func validate(name: String) throws {
            try self.validate(self.creationTimes, name: "creationTimes", parent: name, max: 10)
            try self.validate(self.creationTimes, name: "creationTimes", parent: name, min: 1)
            try self.validate(self.filePaths, name: "filePaths", parent: name, max: 10)
            try self.validate(self.filePaths, name: "filePaths", parent: name, min: 1)
            try self.validate(self.lastModificationTimes, name: "lastModificationTimes", parent: name, max: 10)
            try self.validate(self.lastModificationTimes, name: "lastModificationTimes", parent: name, min: 1)
            try self.validate(self.sizes, name: "sizes", parent: name, max: 10)
            try self.validate(self.sizes, name: "sizes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimes = "CreationTimes"
            case filePaths = "FilePaths"
            case lastModificationTimes = "LastModificationTimes"
            case sizes = "Sizes"
        }
    }

    public struct EBSResultItem: AWSDecodableShape {
        /// These are one or more items in the   results that match values for the Amazon Resource  Name (ARN) of recovery points returned in a search  of Amazon EBS backup metadata.
        public let backupResourceArn: String?
        /// The name of the backup vault.
        public let backupVaultName: String?
        /// These are one or more items in the   results that match values for creation times returned  in a search of Amazon EBS backup metadata.
        public let creationTime: Date?
        /// These are one or more items in the   results that match values for file paths returned  in a search of Amazon EBS backup metadata.
        public let filePath: String?
        /// These are one or more items in the   results that match values for file sizes returned  in a search of Amazon EBS backup metadata.
        public let fileSize: Int64?
        /// These are one or more items in the   results that match values for file systems returned  in a search of Amazon EBS backup metadata.
        public let fileSystemIdentifier: String?
        /// These are one or more items in the   results that match values for Last Modified Time returned  in a search of Amazon EBS backup metadata.
        public let lastModifiedTime: Date?
        /// These are one or more items in the   results that match values for the Amazon Resource  Name (ARN) of source resources returned in a search  of Amazon EBS backup metadata.
        public let sourceResourceArn: String?

        @inlinable
        public init(backupResourceArn: String? = nil, backupVaultName: String? = nil, creationTime: Date? = nil, filePath: String? = nil, fileSize: Int64? = nil, fileSystemIdentifier: String? = nil, lastModifiedTime: Date? = nil, sourceResourceArn: String? = nil) {
            self.backupResourceArn = backupResourceArn
            self.backupVaultName = backupVaultName
            self.creationTime = creationTime
            self.filePath = filePath
            self.fileSize = fileSize
            self.fileSystemIdentifier = fileSystemIdentifier
            self.lastModifiedTime = lastModifiedTime
            self.sourceResourceArn = sourceResourceArn
        }

        private enum CodingKeys: String, CodingKey {
            case backupResourceArn = "BackupResourceArn"
            case backupVaultName = "BackupVaultName"
            case creationTime = "CreationTime"
            case filePath = "FilePath"
            case fileSize = "FileSize"
            case fileSystemIdentifier = "FileSystemIdentifier"
            case lastModifiedTime = "LastModifiedTime"
            case sourceResourceArn = "SourceResourceArn"
        }
    }

    public struct ExportJobSummary: AWSDecodableShape {
        /// This is a timestamp of the time the export job  compeleted.
        public let completionTime: Date?
        /// This is a timestamp of the time the export job  was created.
        public let creationTime: Date?
        /// This is the unique ARN (Amazon Resource Name) that  belongs to the new export job.
        public let exportJobArn: String?
        /// This is the unique string that identifies a  specific export job.
        public let exportJobIdentifier: String
        /// The unique string that identifies the Amazon Resource  Name (ARN) of the specified search job.
        public let searchJobArn: String?
        /// The status of the export job is one of the  following:  CREATED; RUNNING;  FAILED; or COMPLETED.
        public let status: ExportJobStatus?
        /// A status message is a string that is returned for an export job. A status message is included for any status other  than COMPLETED without issues.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date? = nil, exportJobArn: String? = nil, exportJobIdentifier: String, searchJobArn: String? = nil, status: ExportJobStatus? = nil, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.exportJobArn = exportJobArn
            self.exportJobIdentifier = exportJobIdentifier
            self.searchJobArn = searchJobArn
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case exportJobArn = "ExportJobArn"
            case exportJobIdentifier = "ExportJobIdentifier"
            case searchJobArn = "SearchJobArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct GetSearchJobInput: AWSEncodableShape {
        /// Required unique string that specifies the  search job.
        public let searchJobIdentifier: String

        @inlinable
        public init(searchJobIdentifier: String) {
            self.searchJobIdentifier = searchJobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.searchJobIdentifier, key: "SearchJobIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSearchJobOutput: AWSDecodableShape {
        /// The date and time that a search job completed, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionTime: Date?
        /// The date and time that a search job was created, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date
        /// Returns numbers representing BackupsScannedCount,  ItemsScanned, and ItemsMatched.
        public let currentSearchProgress: CurrentSearchProgress?
        /// The encryption key for the specified  search job. Example: arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        public let encryptionKeyArn: String?
        /// Item Filters represent all input item   properties specified when the search was  created.
        public let itemFilters: ItemFilters
        /// Returned name of the specified search job.
        public let name: String?
        /// The unique string that identifies the Amazon Resource  Name (ARN) of the specified search job.
        public let searchJobArn: String
        /// The unique string that identifies the specified search job.
        public let searchJobIdentifier: String
        /// The search scope is all backup  properties input into a search.
        public let searchScope: SearchScope
        /// Returned summary of the specified search job scope,  including:    TotalBackupsToScanCount, the number of  recovery points returned by the search.   TotalItemsToScanCount, the number of  items returned by the search.
        public let searchScopeSummary: SearchScopeSummary?
        /// The current status of the specified search job. A search job may have one of the following statuses:  RUNNING; COMPLETED; STOPPED;  FAILED; TIMED_OUT; or EXPIRED .
        public let status: SearchJobState
        /// A status message will be returned for either a  earch job with a status of ERRORED or a status of  COMPLETED jobs with issues. For example, a message may say that a search  contained recovery points unable to be scanned because  of a permissions issue.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date, currentSearchProgress: CurrentSearchProgress? = nil, encryptionKeyArn: String? = nil, itemFilters: ItemFilters, name: String? = nil, searchJobArn: String, searchJobIdentifier: String, searchScope: SearchScope, searchScopeSummary: SearchScopeSummary? = nil, status: SearchJobState, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.currentSearchProgress = currentSearchProgress
            self.encryptionKeyArn = encryptionKeyArn
            self.itemFilters = itemFilters
            self.name = name
            self.searchJobArn = searchJobArn
            self.searchJobIdentifier = searchJobIdentifier
            self.searchScope = searchScope
            self.searchScopeSummary = searchScopeSummary
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case currentSearchProgress = "CurrentSearchProgress"
            case encryptionKeyArn = "EncryptionKeyArn"
            case itemFilters = "ItemFilters"
            case name = "Name"
            case searchJobArn = "SearchJobArn"
            case searchJobIdentifier = "SearchJobIdentifier"
            case searchScope = "SearchScope"
            case searchScopeSummary = "SearchScopeSummary"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct GetSearchResultExportJobInput: AWSEncodableShape {
        /// This is the unique string that identifies a  specific export job. Required for this operation.
        public let exportJobIdentifier: String

        @inlinable
        public init(exportJobIdentifier: String) {
            self.exportJobIdentifier = exportJobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.exportJobIdentifier, key: "ExportJobIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSearchResultExportJobOutput: AWSDecodableShape {
        /// The date and time that an export job completed, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let completionTime: Date?
        /// The date and time that an export job was created, in Unix format and Coordinated Universal Time (UTC). The value of CreationTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The unique Amazon Resource Name (ARN) that uniquely identifies  the export job.
        public let exportJobArn: String?
        /// This is the unique string that identifies the    specified export job.
        public let exportJobIdentifier: String
        /// The export specification consists of the destination  S3 bucket to which the search results were exported, along  with the destination prefix.
        public let exportSpecification: ExportSpecification?
        /// The unique string that identifies the Amazon Resource  Name (ARN) of the specified search job.
        public let searchJobArn: String?
        /// This is the current status of the export job.
        public let status: ExportJobStatus?
        /// A status message is a string that is returned for search job  with a status of FAILED, along with steps to remedy  and retry the operation.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date? = nil, exportJobArn: String? = nil, exportJobIdentifier: String, exportSpecification: ExportSpecification? = nil, searchJobArn: String? = nil, status: ExportJobStatus? = nil, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.exportJobArn = exportJobArn
            self.exportJobIdentifier = exportJobIdentifier
            self.exportSpecification = exportSpecification
            self.searchJobArn = searchJobArn
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case exportJobArn = "ExportJobArn"
            case exportJobIdentifier = "ExportJobIdentifier"
            case exportSpecification = "ExportSpecification"
            case searchJobArn = "SearchJobArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct ItemFilters: AWSEncodableShape & AWSDecodableShape {
        /// This array can contain CreationTimes,  FilePaths, LastModificationTimes, or Sizes objects.
        public let ebsItemFilters: [EBSItemFilter]?
        /// This array can contain CreationTimes, ETags,  ObjectKeys, Sizes, or VersionIds objects.
        public let s3ItemFilters: [S3ItemFilter]?

        @inlinable
        public init(ebsItemFilters: [EBSItemFilter]? = nil, s3ItemFilters: [S3ItemFilter]? = nil) {
            self.ebsItemFilters = ebsItemFilters
            self.s3ItemFilters = s3ItemFilters
        }

        public func validate(name: String) throws {
            try self.ebsItemFilters?.forEach {
                try $0.validate(name: "\(name).ebsItemFilters[]")
            }
            try self.validate(self.ebsItemFilters, name: "ebsItemFilters", parent: name, max: 10)
            try self.s3ItemFilters?.forEach {
                try $0.validate(name: "\(name).s3ItemFilters[]")
            }
            try self.validate(self.s3ItemFilters, name: "s3ItemFilters", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case ebsItemFilters = "EBSItemFilters"
            case s3ItemFilters = "S3ItemFilters"
        }
    }

    public struct ListSearchJobBackupsInput: AWSEncodableShape {
        /// The maximum number of resource list items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned backups  included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// The unique string that specifies the search job.
        public let searchJobIdentifier: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, searchJobIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchJobIdentifier = searchJobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.searchJobIdentifier, key: "SearchJobIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSearchJobBackupsOutput: AWSDecodableShape {
        /// The next item following a partial list of returned backups  included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// The recovery points returned the results of a  search job
        public let results: [SearchJobBackupsResult]

        @inlinable
        public init(nextToken: String? = nil, results: [SearchJobBackupsResult]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListSearchJobResultsInput: AWSEncodableShape {
        /// The maximum number of resource list items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned  search job results. For example, if a request is made to return MaxResults number of  search job results, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// The unique string that specifies the search job.
        public let searchJobIdentifier: String

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, searchJobIdentifier: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchJobIdentifier = searchJobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.searchJobIdentifier, key: "SearchJobIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSearchJobResultsOutput: AWSDecodableShape {
        /// The next item following a partial list of  search job results. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// The results consist of either EBSResultItem or S3ResultItem.
        public let results: [ResultItem]

        @inlinable
        public init(nextToken: String? = nil, results: [ResultItem]) {
            self.nextToken = nextToken
            self.results = results
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case results = "Results"
        }
    }

    public struct ListSearchJobsInput: AWSEncodableShape {
        /// Include this parameter to filter list by search  job status.
        public let byStatus: SearchJobState?
        /// The maximum number of resource list items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned  search jobs. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(byStatus: SearchJobState? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.byStatus = byStatus
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.byStatus, key: "Status")
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSearchJobsOutput: AWSDecodableShape {
        /// The next item following a partial list of returned backups  included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// The search jobs among the list, with details of  the returned search jobs.
        public let searchJobs: [SearchJobSummary]

        @inlinable
        public init(nextToken: String? = nil, searchJobs: [SearchJobSummary]) {
            self.nextToken = nextToken
            self.searchJobs = searchJobs
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case searchJobs = "SearchJobs"
        }
    }

    public struct ListSearchResultExportJobsInput: AWSEncodableShape {
        /// The maximum number of resource list items to be returned.
        public let maxResults: Int?
        /// The next item following a partial list of returned backups  included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?
        /// The unique string that specifies the search job.
        public let searchJobIdentifier: String?
        /// The search jobs to be included in the export job  can be filtered by including this parameter.
        public let status: ExportJobStatus?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, searchJobIdentifier: String? = nil, status: ExportJobStatus? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.searchJobIdentifier = searchJobIdentifier
            self.status = status
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "MaxResults")
            request.encodeQuery(self.nextToken, key: "NextToken")
            request.encodeQuery(self.searchJobIdentifier, key: "SearchJobIdentifier")
            request.encodeQuery(self.status, key: "Status")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSearchResultExportJobsOutput: AWSDecodableShape {
        /// The operation returns the included export jobs.
        public let exportJobs: [ExportJobSummary]
        /// The next item following a partial list of returned backups  included in a search job. For example, if a request is made to return MaxResults number of backups, NextToken allows you to return more items in your list starting at the location pointed to by the next token.
        public let nextToken: String?

        @inlinable
        public init(exportJobs: [ExportJobSummary], nextToken: String? = nil) {
            self.exportJobs = exportJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobs = "ExportJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies  the resource.&gt;
        public let resourceArn: String

        @inlinable
        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// List of tags returned by the operation.
        public let tags: [String: String]?

        @inlinable
        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct LongCondition: AWSEncodableShape & AWSDecodableShape {
        /// A string that defines what values will be  returned. If this is included, avoid combinations of  operators that will return all possible values.  For example, including both EQUALS_TO  and NOT_EQUALS_TO with a value of 4  will return all values.
        public let `operator`: LongConditionOperator?
        /// The value of an item included in one of the search  item filters.
        public let value: Int64

        @inlinable
        public init(operator: LongConditionOperator? = nil, value: Int64) {
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct ResourceNotFoundException: AWSErrorShape {
        /// Request references a resource which does not exist.
        public let message: String
        /// Hypothetical identifier of the resource affected.
        public let resourceId: String
        /// Hypothetical type of the resource affected.
        public let resourceType: String

        @inlinable
        public init(message: String, resourceId: String, resourceType: String) {
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
        }
    }

    public struct S3ExportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// This specifies the destination Amazon S3  bucket for the export job.
        public let destinationBucket: String
        /// This specifies the prefix for the destination  Amazon S3 bucket for the export job.
        public let destinationPrefix: String?

        @inlinable
        public init(destinationBucket: String, destinationPrefix: String? = nil) {
            self.destinationBucket = destinationBucket
            self.destinationPrefix = destinationPrefix
        }

        private enum CodingKeys: String, CodingKey {
            case destinationBucket = "DestinationBucket"
            case destinationPrefix = "DestinationPrefix"
        }
    }

    public struct S3ItemFilter: AWSEncodableShape & AWSDecodableShape {
        /// You can include 1 to 10 values. If one value is included, the results will  return only items that match the value. If more than one value is included, the  results will return all items that match any of the  values.
        public let creationTimes: [TimeCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will  return only items that match the value. If more than one value is included, the  results will return all items that match any of the  values.
        public let eTags: [StringCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will  return only items that match the value. If more than one value is included, the  results will return all items that match any of the  values.
        public let objectKeys: [StringCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will  return only items that match the value. If more than one value is included, the  results will return all items that match any of the  values.
        public let sizes: [LongCondition]?
        /// You can include 1 to 10 values. If one value is included, the results will  return only items that match the value. If more than one value is included, the  results will return all items that match any of the  values.
        public let versionIds: [StringCondition]?

        @inlinable
        public init(creationTimes: [TimeCondition]? = nil, eTags: [StringCondition]? = nil, objectKeys: [StringCondition]? = nil, sizes: [LongCondition]? = nil, versionIds: [StringCondition]? = nil) {
            self.creationTimes = creationTimes
            self.eTags = eTags
            self.objectKeys = objectKeys
            self.sizes = sizes
            self.versionIds = versionIds
        }

        public func validate(name: String) throws {
            try self.validate(self.creationTimes, name: "creationTimes", parent: name, max: 10)
            try self.validate(self.creationTimes, name: "creationTimes", parent: name, min: 1)
            try self.validate(self.eTags, name: "eTags", parent: name, max: 10)
            try self.validate(self.eTags, name: "eTags", parent: name, min: 1)
            try self.validate(self.objectKeys, name: "objectKeys", parent: name, max: 10)
            try self.validate(self.objectKeys, name: "objectKeys", parent: name, min: 1)
            try self.validate(self.sizes, name: "sizes", parent: name, max: 10)
            try self.validate(self.sizes, name: "sizes", parent: name, min: 1)
            try self.validate(self.versionIds, name: "versionIds", parent: name, max: 10)
            try self.validate(self.versionIds, name: "versionIds", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case creationTimes = "CreationTimes"
            case eTags = "ETags"
            case objectKeys = "ObjectKeys"
            case sizes = "Sizes"
            case versionIds = "VersionIds"
        }
    }

    public struct S3ResultItem: AWSDecodableShape {
        /// These are items in the returned results that match  recovery point Amazon Resource Names (ARN) input during  a search of Amazon S3 backup metadata.
        public let backupResourceArn: String?
        /// The name of the backup vault.
        public let backupVaultName: String?
        /// These are one or more items in the returned results  that match values for item creation time input during  a search of Amazon S3 backup metadata.
        public let creationTime: Date?
        /// These are one or more items in the returned results  that match values for ETags input during  a search of Amazon S3 backup metadata.
        public let eTag: String?
        /// This is one or more items     returned in the results of a search of Amazon S3  backup metadata that match the values input for  object key.
        public let objectKey: String?
        /// These are items in the returned results that match  values for object size(s) input during a search of  Amazon S3 backup metadata.
        public let objectSize: Int64?
        /// These are items in the returned results that match  source Amazon Resource Names (ARN) input during  a search of Amazon S3 backup metadata.
        public let sourceResourceArn: String?
        /// These are one or more items in the returned results  that match values for version IDs input during  a search of Amazon S3 backup metadata.
        public let versionId: String?

        @inlinable
        public init(backupResourceArn: String? = nil, backupVaultName: String? = nil, creationTime: Date? = nil, eTag: String? = nil, objectKey: String? = nil, objectSize: Int64? = nil, sourceResourceArn: String? = nil, versionId: String? = nil) {
            self.backupResourceArn = backupResourceArn
            self.backupVaultName = backupVaultName
            self.creationTime = creationTime
            self.eTag = eTag
            self.objectKey = objectKey
            self.objectSize = objectSize
            self.sourceResourceArn = sourceResourceArn
            self.versionId = versionId
        }

        private enum CodingKeys: String, CodingKey {
            case backupResourceArn = "BackupResourceArn"
            case backupVaultName = "BackupVaultName"
            case creationTime = "CreationTime"
            case eTag = "ETag"
            case objectKey = "ObjectKey"
            case objectSize = "ObjectSize"
            case sourceResourceArn = "SourceResourceArn"
            case versionId = "VersionId"
        }
    }

    public struct SearchJobBackupsResult: AWSDecodableShape {
        /// This is the creation time of the backup (recovery point).
        public let backupCreationTime: Date?
        /// The Amazon Resource Name (ARN) that uniquely identifies  the backup resources.
        public let backupResourceArn: String?
        /// This is the creation time of the backup index.
        public let indexCreationTime: Date?
        /// This is the resource type of the search.
        public let resourceType: ResourceType?
        /// The Amazon Resource Name (ARN) that uniquely identifies  the source resources.
        public let sourceResourceArn: String?
        /// This is the status of the search job backup result.
        public let status: SearchJobState?
        /// This is the status message included with the results.
        public let statusMessage: String?

        @inlinable
        public init(backupCreationTime: Date? = nil, backupResourceArn: String? = nil, indexCreationTime: Date? = nil, resourceType: ResourceType? = nil, sourceResourceArn: String? = nil, status: SearchJobState? = nil, statusMessage: String? = nil) {
            self.backupCreationTime = backupCreationTime
            self.backupResourceArn = backupResourceArn
            self.indexCreationTime = indexCreationTime
            self.resourceType = resourceType
            self.sourceResourceArn = sourceResourceArn
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case backupCreationTime = "BackupCreationTime"
            case backupResourceArn = "BackupResourceArn"
            case indexCreationTime = "IndexCreationTime"
            case resourceType = "ResourceType"
            case sourceResourceArn = "SourceResourceArn"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct SearchJobSummary: AWSDecodableShape {
        /// This is the completion time of the search job.
        public let completionTime: Date?
        /// This is the creation time of the search job.
        public let creationTime: Date?
        /// This is the name of the search job.
        public let name: String?
        /// The unique string that identifies the Amazon Resource  Name (ARN) of the specified search job.
        public let searchJobArn: String?
        /// The unique string that specifies the search job.
        public let searchJobIdentifier: String?
        /// Returned summary of the specified search job scope,  including:    TotalBackupsToScanCount, the number of  recovery points returned by the search.   TotalItemsToScanCount, the number of  items returned by the search.
        public let searchScopeSummary: SearchScopeSummary?
        /// This is the status of the search job.
        public let status: SearchJobState?
        /// A status message will be returned for either a  earch job with a status of ERRORED or a status of  COMPLETED jobs with issues. For example, a message may say that a search  contained recovery points unable to be scanned because  of a permissions issue.
        public let statusMessage: String?

        @inlinable
        public init(completionTime: Date? = nil, creationTime: Date? = nil, name: String? = nil, searchJobArn: String? = nil, searchJobIdentifier: String? = nil, searchScopeSummary: SearchScopeSummary? = nil, status: SearchJobState? = nil, statusMessage: String? = nil) {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.name = name
            self.searchJobArn = searchJobArn
            self.searchJobIdentifier = searchJobIdentifier
            self.searchScopeSummary = searchScopeSummary
            self.status = status
            self.statusMessage = statusMessage
        }

        private enum CodingKeys: String, CodingKey {
            case completionTime = "CompletionTime"
            case creationTime = "CreationTime"
            case name = "Name"
            case searchJobArn = "SearchJobArn"
            case searchJobIdentifier = "SearchJobIdentifier"
            case searchScopeSummary = "SearchScopeSummary"
            case status = "Status"
            case statusMessage = "StatusMessage"
        }
    }

    public struct SearchScope: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies  the backup resources.
        public let backupResourceArns: [String]?
        /// This is the time a backup resource was created.
        public let backupResourceCreationTime: BackupCreationTimeFilter?
        /// These are one or more tags on the backup (recovery  point).
        public let backupResourceTags: [String: String]?
        /// The resource types included in a search. Eligible resource types include S3 and EBS.
        public let backupResourceTypes: [ResourceType]
        /// The Amazon Resource Name (ARN) that uniquely identifies  the source resources.
        public let sourceResourceArns: [String]?

        @inlinable
        public init(backupResourceArns: [String]? = nil, backupResourceCreationTime: BackupCreationTimeFilter? = nil, backupResourceTags: [String: String]? = nil, backupResourceTypes: [ResourceType], sourceResourceArns: [String]? = nil) {
            self.backupResourceArns = backupResourceArns
            self.backupResourceCreationTime = backupResourceCreationTime
            self.backupResourceTags = backupResourceTags
            self.backupResourceTypes = backupResourceTypes
            self.sourceResourceArns = sourceResourceArns
        }

        public func validate(name: String) throws {
            try self.validate(self.backupResourceArns, name: "backupResourceArns", parent: name, max: 50)
            try self.validate(self.backupResourceTypes, name: "backupResourceTypes", parent: name, max: 1)
            try self.validate(self.backupResourceTypes, name: "backupResourceTypes", parent: name, min: 1)
            try self.validate(self.sourceResourceArns, name: "sourceResourceArns", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case backupResourceArns = "BackupResourceArns"
            case backupResourceCreationTime = "BackupResourceCreationTime"
            case backupResourceTags = "BackupResourceTags"
            case backupResourceTypes = "BackupResourceTypes"
            case sourceResourceArns = "SourceResourceArns"
        }
    }

    public struct SearchScopeSummary: AWSDecodableShape {
        /// This is the count of the total number of items   that will be scanned in a search.
        public let totalItemsToScanCount: Int64?
        /// This is the count of the total number of backups  that will be scanned in a search.
        public let totalRecoveryPointsToScanCount: Int?

        @inlinable
        public init(totalItemsToScanCount: Int64? = nil, totalRecoveryPointsToScanCount: Int? = nil) {
            self.totalItemsToScanCount = totalItemsToScanCount
            self.totalRecoveryPointsToScanCount = totalRecoveryPointsToScanCount
        }

        private enum CodingKeys: String, CodingKey {
            case totalItemsToScanCount = "TotalItemsToScanCount"
            case totalRecoveryPointsToScanCount = "TotalRecoveryPointsToScanCount"
        }
    }

    public struct ServiceQuotaExceededException: AWSErrorShape {
        /// This request was not successful due to a service quota exceeding limits.
        public let message: String
        /// This is the code specific to the quota type.
        public let quotaCode: String
        /// Identifier of the resource.
        public let resourceId: String
        /// Type of resource.
        public let resourceType: String
        /// This is the code unique to the originating service with the quota.
        public let serviceCode: String

        @inlinable
        public init(message: String, quotaCode: String, resourceId: String, resourceType: String, serviceCode: String) {
            self.message = message
            self.quotaCode = quotaCode
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.serviceCode = serviceCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "message"
            case quotaCode = "quotaCode"
            case resourceId = "resourceId"
            case resourceType = "resourceType"
            case serviceCode = "serviceCode"
        }
    }

    public struct StartSearchJobInput: AWSEncodableShape {
        /// Include this parameter to allow multiple identical  calls for idempotency. A client token is valid for 8 hours after the first  request that uses it is completed. After this time, any request with the same token is treated as a  new request.
        public let clientToken: String?
        /// The encryption key for the specified  search job.
        public let encryptionKeyArn: String?
        /// Item Filters represent all input item   properties specified when the search was  created. Contains either EBSItemFilters or  S3ItemFilters
        public let itemFilters: ItemFilters?
        /// Include alphanumeric characters to create a  name for this search job.
        public let name: String?
        /// This object can contain BackupResourceTypes,  BackupResourceArns, BackupResourceCreationTime,  BackupResourceTags, and SourceResourceArns to  filter the recovery points returned by the search  job.
        public let searchScope: SearchScope
        /// List of tags returned by the operation.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = nil, encryptionKeyArn: String? = nil, itemFilters: ItemFilters? = nil, name: String? = nil, searchScope: SearchScope, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.encryptionKeyArn = encryptionKeyArn
            self.itemFilters = itemFilters
            self.name = name
            self.searchScope = searchScope
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.itemFilters?.validate(name: "\(name).itemFilters")
            try self.searchScope.validate(name: "\(name).searchScope")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case encryptionKeyArn = "EncryptionKeyArn"
            case itemFilters = "ItemFilters"
            case name = "Name"
            case searchScope = "SearchScope"
            case tags = "Tags"
        }
    }

    public struct StartSearchJobOutput: AWSDecodableShape {
        /// The date and time that a job was created, in Unix format and Coordinated Universal Time (UTC). The value of CompletionTime is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public let creationTime: Date?
        /// The unique string that identifies the Amazon Resource  Name (ARN) of the specified search job.
        public let searchJobArn: String?
        /// The unique string that specifies the search job.
        public let searchJobIdentifier: String?

        @inlinable
        public init(creationTime: Date? = nil, searchJobArn: String? = nil, searchJobIdentifier: String? = nil) {
            self.creationTime = creationTime
            self.searchJobArn = searchJobArn
            self.searchJobIdentifier = searchJobIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case creationTime = "CreationTime"
            case searchJobArn = "SearchJobArn"
            case searchJobIdentifier = "SearchJobIdentifier"
        }
    }

    public struct StartSearchResultExportJobInput: AWSEncodableShape {
        /// Include this parameter to allow multiple identical  calls for idempotency. A client token is valid for 8 hours after the first  request that uses it is completed. After this time, any request with the same token is treated as a  new request.
        public let clientToken: String?
        /// This specification contains a required string of the  destination bucket; optionally, you can include the  destination prefix.
        public let exportSpecification: ExportSpecification
        /// This parameter specifies the role ARN used to start  the search results export jobs.
        public let roleArn: String?
        /// The unique string that specifies the search job.
        public let searchJobIdentifier: String
        /// Optional tags to include. A tag is a key-value pair you can use to manage,  filter, and search for your resources. Allowed characters include UTF-8 letters,  numbers, spaces, and the following characters: + - = . _ : /.
        public let tags: [String: String]?

        @inlinable
        public init(clientToken: String? = nil, exportSpecification: ExportSpecification, roleArn: String? = nil, searchJobIdentifier: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.exportSpecification = exportSpecification
            self.roleArn = roleArn
            self.searchJobIdentifier = searchJobIdentifier
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 2048)
            try self.validate(self.roleArn, name: "roleArn", parent: name, min: 20)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:(?:aws|aws-cn|aws-us-gov):iam::[a-z0-9-]+:role/(.+)$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case exportSpecification = "ExportSpecification"
            case roleArn = "RoleArn"
            case searchJobIdentifier = "SearchJobIdentifier"
            case tags = "Tags"
        }
    }

    public struct StartSearchResultExportJobOutput: AWSDecodableShape {
        /// This is the unique ARN (Amazon Resource Name) that  belongs to the new export job.
        public let exportJobArn: String?
        /// This is the unique identifier that  specifies the new export job.
        public let exportJobIdentifier: String

        @inlinable
        public init(exportJobArn: String? = nil, exportJobIdentifier: String) {
            self.exportJobArn = exportJobArn
            self.exportJobIdentifier = exportJobIdentifier
        }

        private enum CodingKeys: String, CodingKey {
            case exportJobArn = "ExportJobArn"
            case exportJobIdentifier = "ExportJobIdentifier"
        }
    }

    public struct StopSearchJobInput: AWSEncodableShape {
        /// The unique string that specifies the search job.
        public let searchJobIdentifier: String

        @inlinable
        public init(searchJobIdentifier: String) {
            self.searchJobIdentifier = searchJobIdentifier
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.searchJobIdentifier, key: "SearchJobIdentifier")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopSearchJobOutput: AWSDecodableShape {
        public init() {}
    }

    public struct StringCondition: AWSEncodableShape & AWSDecodableShape {
        /// A string that defines what values will be  returned. If this is included, avoid combinations of  operators that will return all possible values.  For example, including both EQUALS_TO  and NOT_EQUALS_TO with a value of 4  will return all values.
        public let `operator`: StringConditionOperator?
        /// The value of the string.
        public let value: String

        @inlinable
        public init(operator: StringConditionOperator? = nil, value: String) {
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies  the resource. This is the resource that will have the indicated tags.
        public let resourceArn: String
        /// Required tags to include. A tag is a key-value pair you can use to manage,  filter, and search for your resources. Allowed characters include UTF-8 letters,  numbers, spaces, and the following characters: + - = . _ : /.
        public let tags: [String: String]

        @inlinable
        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            try container.encode(self.tags, forKey: .tags)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "Tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TimeCondition: AWSEncodableShape & AWSDecodableShape {
        /// A string that defines what values will be  returned. If this is included, avoid combinations of  operators that will return all possible values.  For example, including both EQUALS_TO  and NOT_EQUALS_TO with a value of 4  will return all values.
        public let `operator`: TimeConditionOperator?
        /// This is the timestamp value of the time condition.
        public let value: Date

        @inlinable
        public init(operator: TimeConditionOperator? = nil, value: Date) {
            self.`operator` = `operator`
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case `operator` = "Operator"
            case value = "Value"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) that uniquely identifies  the resource where you want to remove tags.
        public let resourceArn: String
        /// This required parameter contains the tag keys you  want to remove from the source.
        public let tagKeys: [String]

        @inlinable
        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceArn, key: "ResourceArn")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct ExportSpecification: AWSEncodableShape & AWSDecodableShape {
        /// This specifies the destination Amazon S3  bucket for the export job. And, if included, it also  specifies the destination prefix.
        public let s3ExportSpecification: S3ExportSpecification?

        @inlinable
        public init(s3ExportSpecification: S3ExportSpecification? = nil) {
            self.s3ExportSpecification = s3ExportSpecification
        }

        private enum CodingKeys: String, CodingKey {
            case s3ExportSpecification = "s3ExportSpecification"
        }
    }
}

// MARK: - Errors

/// Error enum for BackupSearch
public struct BackupSearchErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize BackupSearch
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// This exception occurs when a conflict with a previous successful operation is detected. This generally occurs when the previous  operation did not have time to propagate to the host serving the  current request. A retry (with appropriate backoff logic) is the recommended  response to this exception.
    public static var conflictException: Self { .init(.conflictException) }
    /// An internal server error occurred. Retry your request.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource was not found for this request. Confirm the resource information, such as the ARN or type is correct  and exists, then retry the request.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request denied due to exceeding the quota limits permitted.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by a service.
    public static var validationException: Self { .init(.validationException) }
}

extension BackupSearchErrorType: AWSServiceErrorType {
    public static let errorCodeMap: [String: AWSErrorShape.Type] = [
        "ConflictException": BackupSearch.ConflictException.self,
        "ResourceNotFoundException": BackupSearch.ResourceNotFoundException.self,
        "ServiceQuotaExceededException": BackupSearch.ServiceQuotaExceededException.self
    ]
}

extension BackupSearchErrorType: Equatable {
    public static func == (lhs: BackupSearchErrorType, rhs: BackupSearchErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension BackupSearchErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
