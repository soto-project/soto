//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2024 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension QBusiness {
    // MARK: Enums

    public enum APISchemaType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case openApiV3 = "OPEN_API_V3"
        public var description: String { return self.rawValue }
    }

    public enum ActionPayloadFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "ARRAY"
        case boolean = "BOOLEAN"
        case number = "NUMBER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentsControlMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case date = "DATE"
        case number = "NUMBER"
        case string = "STRING"
        case stringList = "STRING_LIST"
        public var description: String { return self.rawValue }
    }

    public enum AttributeValueOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        public var description: String { return self.rawValue }
    }

    public enum AudioExtractionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AudioExtractionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case summary = "SUMMARY"
        case transcript = "TRANSCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum AutoSubscriptionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum BrowserExtension: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case chrome = "CHROME"
        case firefox = "FIREFOX"
        public var description: String { return self.rawValue }
    }

    public enum ChatMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case creatorMode = "CREATOR_MODE"
        case pluginMode = "PLUGIN_MODE"
        case retrievalMode = "RETRIEVAL_MODE"
        public var description: String { return self.rawValue }
    }

    public enum ContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case html = "HTML"
        case json = "JSON"
        case md = "MD"
        case msExcel = "MS_EXCEL"
        case msWord = "MS_WORD"
        case pdf = "PDF"
        case plainText = "PLAIN_TEXT"
        case ppt = "PPT"
        case rtf = "RTF"
        case xml = "XML"
        case xslt = "XSLT"
        public var description: String { return self.rawValue }
    }

    public enum CreatorModeControl: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pendingCreation = "PENDING_CREATION"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceSyncJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case failed = "FAILED"
        case incomplete = "INCOMPLETE"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case syncing = "SYNCING"
        case syncingIndexing = "SYNCING_INDEXING"
        public var description: String { return self.rawValue }
    }

    public enum DocumentAttributeBoostingLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        case veryHigh = "VERY_HIGH"
        public var description: String { return self.rawValue }
    }

    public enum DocumentContentOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        public var description: String { return self.rawValue }
    }

    public enum DocumentEnrichmentConditionOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case beginsWith = "BEGINS_WITH"
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case exists = "EXISTS"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEquals = "GREATER_THAN_OR_EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanOrEquals = "LESS_THAN_OR_EQUALS"
        case notContains = "NOT_CONTAINS"
        case notEquals = "NOT_EQUALS"
        case notExists = "NOT_EXISTS"
        public var description: String { return self.rawValue }
    }

    public enum DocumentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case deleting = "DELETING"
        case documentFailedToIndex = "DOCUMENT_FAILED_TO_INDEX"
        case failed = "FAILED"
        case indexed = "INDEXED"
        case processing = "PROCESSING"
        case received = "RECEIVED"
        case updated = "UPDATED"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "InternalError"
        case invalidRequest = "InvalidRequest"
        case resourceInactive = "ResourceInactive"
        case resourceNotFound = "ResourceNotFound"
        public var description: String { return self.rawValue }
    }

    public enum GroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case processing = "PROCESSING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum IdentityType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case awsIamIdc = "AWS_IAM_IDC"
        case awsIamIdpOidc = "AWS_IAM_IDP_OIDC"
        case awsIamIdpSaml = "AWS_IAM_IDP_SAML"
        case awsQuicksightIdp = "AWS_QUICKSIGHT_IDP"
        public var description: String { return self.rawValue }
    }

    public enum ImageExtractionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum IndexStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum IndexType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enterprise = "ENTERPRISE"
        case starter = "STARTER"
        public var description: String { return self.rawValue }
    }

    public enum MemberRelation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum MembershipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datasource = "DATASOURCE"
        case index = "INDEX"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case system = "SYSTEM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum MessageUsefulness: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notUseful = "NOT_USEFUL"
        case useful = "USEFUL"
        public var description: String { return self.rawValue }
    }

    public enum MessageUsefulnessReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case factuallyCorrect = "FACTUALLY_CORRECT"
        case harmfulOrUnsafe = "HARMFUL_OR_UNSAFE"
        case helpful = "HELPFUL"
        case incorrectOrMissingSources = "INCORRECT_OR_MISSING_SOURCES"
        case notBasedOnDocuments = "NOT_BASED_ON_DOCUMENTS"
        case notComplete = "NOT_COMPLETE"
        case notConcise = "NOT_CONCISE"
        case notFactuallyCorrect = "NOT_FACTUALLY_CORRECT"
        case notHelpful = "NOT_HELPFUL"
        case other = "OTHER"
        case relevantSources = "RELEVANT_SOURCES"
        public var description: String { return self.rawValue }
    }

    public enum NumberAttributeBoostingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case prioritizeLargerValues = "PRIORITIZE_LARGER_VALUES"
        case prioritizeSmallerValues = "PRIORITIZE_SMALLER_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum OrchestrationControl: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PersonalizationControlMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PluginBuildStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case createFailed = "CREATE_FAILED"
        case createInProgress = "CREATE_IN_PROGRESS"
        case deleteFailed = "DELETE_FAILED"
        case deleteInProgress = "DELETE_IN_PROGRESS"
        case ready = "READY"
        case updateFailed = "UPDATE_FAILED"
        case updateInProgress = "UPDATE_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum PluginState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PluginType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case asana = "ASANA"
        case atlassianConfluence = "ATLASSIAN_CONFLUENCE"
        case custom = "CUSTOM"
        case googleCalendar = "GOOGLE_CALENDAR"
        case jira = "JIRA"
        case jiraCloud = "JIRA_CLOUD"
        case microsoftExchange = "MICROSOFT_EXCHANGE"
        case microsoftTeams = "MICROSOFT_TEAMS"
        case pagerdutyAdvance = "PAGERDUTY_ADVANCE"
        case quicksight = "QUICKSIGHT"
        case salesforce = "SALESFORCE"
        case salesforceCrm = "SALESFORCE_CRM"
        case serviceNow = "SERVICE_NOW"
        case servicenowNowPlatform = "SERVICENOW_NOW_PLATFORM"
        case smartsheet = "SMARTSHEET"
        case zendesk = "ZENDESK"
        case zendeskSuite = "ZENDESK_SUITE"
        public var description: String { return self.rawValue }
    }

    public enum PluginTypeCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case communication = "Communication"
        case crm = "Customer relationship management (CRM)"
        case productivity = "Productivity"
        case projectManagement = "Project management"
        case ticketingManagement = "Ticketing and incident management"
        public var description: String { return self.rawValue }
    }

    public enum QAppsControlMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ReadAccessType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum ResponseScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enterpriseContentOnly = "ENTERPRISE_CONTENT_ONLY"
        case extendedKnowledgeEnabled = "EXTENDED_KNOWLEDGE_ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum RetrieverStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum RetrieverType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kendraIndex = "KENDRA_INDEX"
        case nativeIndex = "NATIVE_INDEX"
        public var description: String { return self.rawValue }
    }

    public enum RuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentBlockerRule = "CONTENT_BLOCKER_RULE"
        case contentRetrievalRule = "CONTENT_RETRIEVAL_RULE"
        public var description: String { return self.rawValue }
    }

    public enum ScoreConfidence: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case notAvailable = "NOT_AVAILABLE"
        case veryHigh = "VERY_HIGH"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StringAttributeValueBoostingLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case veryHigh = "VERY_HIGH"
        public var description: String { return self.rawValue }
    }

    public enum SubscriptionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case qBusiness = "Q_BUSINESS"
        case qLite = "Q_LITE"
        public var description: String { return self.rawValue }
    }

    public enum VideoExtractionStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum VideoExtractionType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case summary = "SUMMARY"
        case transcript = "TRANSCRIPT"
        public var description: String { return self.rawValue }
    }

    public enum WebExperienceSamplePromptsControlMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum WebExperienceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pendingAuthConfig = "PENDING_AUTH_CONFIG"
        public var description: String { return self.rawValue }
    }

    public enum APISchema: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for a custom plugin.
        case payload(String)
        /// Contains details about the S3 object containing the OpenAPI schema for a custom plugin. The schema could be in either JSON or YAML format.
        case s3(S3)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .payload:
                let value = try container.decode(String.self, forKey: .payload)
                self = .payload(value)
            case .s3:
                let value = try container.decode(S3.self, forKey: .s3)
                self = .s3(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .payload(let value):
                try container.encode(value, forKey: .payload)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case s3 = "s3"
        }
    }

    public enum ChatInputStream: AWSEncodableShape, Sendable {
        /// A request from an end user to perform an Amazon Q Business plugin action.
        case actionExecutionEvent(ActionExecutionEvent)
        /// A request by an end user to upload a file during chat.
        case attachmentEvent(AttachmentInputEvent)
        /// An authentication verification event response by a third party authentication server to Amazon Q Business.
        case authChallengeResponseEvent(AuthChallengeResponseEvent)
        /// A configuration event activated by an end user request to select a specific chat mode.
        case configurationEvent(ConfigurationEvent)
        /// The end of the streaming input for the Chat API.
        case endOfInputEvent(EndOfInputEvent)
        /// Information about the payload of the ChatInputStream event containing the end user message input.
        case textEvent(TextInputEvent)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .actionExecutionEvent(let value):
                try container.encode(value, forKey: .actionExecutionEvent)
            case .attachmentEvent(let value):
                try container.encode(value, forKey: .attachmentEvent)
            case .authChallengeResponseEvent(let value):
                try container.encode(value, forKey: .authChallengeResponseEvent)
            case .configurationEvent(let value):
                try container.encode(value, forKey: .configurationEvent)
            case .endOfInputEvent(let value):
                try container.encode(value, forKey: .endOfInputEvent)
            case .textEvent(let value):
                try container.encode(value, forKey: .textEvent)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .actionExecutionEvent(let value):
                try value.validate(name: "\(name).actionExecutionEvent")
            case .attachmentEvent(let value):
                try value.validate(name: "\(name).attachmentEvent")
            case .authChallengeResponseEvent(let value):
                try value.validate(name: "\(name).authChallengeResponseEvent")
            case .configurationEvent(let value):
                try value.validate(name: "\(name).configurationEvent")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actionExecutionEvent = "actionExecutionEvent"
            case attachmentEvent = "attachmentEvent"
            case authChallengeResponseEvent = "authChallengeResponseEvent"
            case configurationEvent = "configurationEvent"
            case endOfInputEvent = "endOfInputEvent"
            case textEvent = "textEvent"
        }
    }

    public enum ChatOutputStream: AWSDecodableShape, Sendable {
        /// A request from Amazon Q Business to the end user for information Amazon Q Business needs to successfully complete a requested plugin action.
        case actionReviewEvent(ActionReviewEvent)
        /// An authentication verification event activated by an end user request to use a custom plugin.
        case authChallengeRequestEvent(AuthChallengeRequestEvent)
        /// A failed file upload event during a web experience chat.
        case failedAttachmentEvent(FailedAttachmentEvent)
        /// A metadata event for a AI-generated text output message in a Amazon Q Business conversation.
        case metadataEvent(MetadataEvent)
        /// Information about the payload of the ChatOutputStream event containing the AI-generated message output.
        case textEvent(TextOutputEvent)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .actionReviewEvent:
                let value = try container.decode(ActionReviewEvent.self, forKey: .actionReviewEvent)
                self = .actionReviewEvent(value)
            case .authChallengeRequestEvent:
                let value = try container.decode(AuthChallengeRequestEvent.self, forKey: .authChallengeRequestEvent)
                self = .authChallengeRequestEvent(value)
            case .failedAttachmentEvent:
                let value = try container.decode(FailedAttachmentEvent.self, forKey: .failedAttachmentEvent)
                self = .failedAttachmentEvent(value)
            case .metadataEvent:
                let value = try container.decode(MetadataEvent.self, forKey: .metadataEvent)
                self = .metadataEvent(value)
            case .textEvent:
                let value = try container.decode(TextOutputEvent.self, forKey: .textEvent)
                self = .textEvent(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case actionReviewEvent = "actionReviewEvent"
            case authChallengeRequestEvent = "authChallengeRequestEvent"
            case failedAttachmentEvent = "failedAttachmentEvent"
            case metadataEvent = "metadataEvent"
            case textEvent = "textEvent"
        }
    }

    public enum DocumentAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Provides information on boosting DATE type document attributes.
        case dateConfiguration(DateAttributeBoostingConfiguration)
        /// Provides information on boosting NUMBER type document attributes.
        case numberConfiguration(NumberAttributeBoostingConfiguration)
        /// Provides information on boosting STRING type document attributes.
        case stringConfiguration(StringAttributeBoostingConfiguration)
        /// Provides information on boosting STRING_LIST type document attributes.
        case stringListConfiguration(StringListAttributeBoostingConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dateConfiguration:
                let value = try container.decode(DateAttributeBoostingConfiguration.self, forKey: .dateConfiguration)
                self = .dateConfiguration(value)
            case .numberConfiguration:
                let value = try container.decode(NumberAttributeBoostingConfiguration.self, forKey: .numberConfiguration)
                self = .numberConfiguration(value)
            case .stringConfiguration:
                let value = try container.decode(StringAttributeBoostingConfiguration.self, forKey: .stringConfiguration)
                self = .stringConfiguration(value)
            case .stringListConfiguration:
                let value = try container.decode(StringListAttributeBoostingConfiguration.self, forKey: .stringListConfiguration)
                self = .stringListConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dateConfiguration(let value):
                try container.encode(value, forKey: .dateConfiguration)
            case .numberConfiguration(let value):
                try container.encode(value, forKey: .numberConfiguration)
            case .stringConfiguration(let value):
                try container.encode(value, forKey: .stringConfiguration)
            case .stringListConfiguration(let value):
                try container.encode(value, forKey: .stringListConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dateConfiguration(let value):
                try value.validate(name: "\(name).dateConfiguration")
            case .stringConfiguration(let value):
                try value.validate(name: "\(name).stringConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dateConfiguration = "dateConfiguration"
            case numberConfiguration = "numberConfiguration"
            case stringConfiguration = "stringConfiguration"
            case stringListConfiguration = "stringListConfiguration"
        }
    }

    public enum DocumentAttributeValue: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case dateValue(Date)
        /// A long integer value.
        case longValue(Int64)
        /// A list of strings.
        case stringListValue([String])
        /// A string.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dateValue:
                let value = try container.decode(Date.self, forKey: .dateValue)
                self = .dateValue(value)
            case .longValue:
                let value = try container.decode(Int64.self, forKey: .longValue)
                self = .longValue(value)
            case .stringListValue:
                let value = try container.decode([String].self, forKey: .stringListValue)
                self = .stringListValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dateValue(let value):
                try container.encode(value, forKey: .dateValue)
            case .longValue(let value):
                try container.encode(value, forKey: .longValue)
            case .stringListValue(let value):
                try container.encode(value, forKey: .stringListValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .stringListValue(let value):
                try value.forEach {
                    try validate($0, name: "stringListValue[]", parent: name, max: 2048)
                    try validate($0, name: "stringListValue[]", parent: name, min: 1)
                }
            case .stringValue(let value):
                try self.validate(value, name: "stringValue", parent: name, max: 2048)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dateValue = "dateValue"
            case longValue = "longValue"
            case stringListValue = "stringListValue"
            case stringValue = "stringValue"
        }
    }

    public enum DocumentContent: AWSEncodableShape, Sendable {
        /// The contents of the document. Documents passed to the blob parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Q Business APIs. If you are calling the Amazon Q Business endpoint directly using REST, you must base64 encode the contents before sending.
        case blob(AWSBase64Data)
        /// The path to the document in an Amazon S3 bucket.
        case s3(S3)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .blob(let value):
                try container.encode(value, forKey: .blob)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case s3 = "s3"
        }
    }

    public enum IdentityProviderConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        case openIDConnectConfiguration(OpenIDConnectProviderConfiguration)
        case samlConfiguration(SamlProviderConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .openIDConnectConfiguration:
                let value = try container.decode(OpenIDConnectProviderConfiguration.self, forKey: .openIDConnectConfiguration)
                self = .openIDConnectConfiguration(value)
            case .samlConfiguration:
                let value = try container.decode(SamlProviderConfiguration.self, forKey: .samlConfiguration)
                self = .samlConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .openIDConnectConfiguration(let value):
                try container.encode(value, forKey: .openIDConnectConfiguration)
            case .samlConfiguration(let value):
                try container.encode(value, forKey: .samlConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .openIDConnectConfiguration(let value):
                try value.validate(name: "\(name).openIDConnectConfiguration")
            case .samlConfiguration(let value):
                try value.validate(name: "\(name).samlConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case openIDConnectConfiguration = "openIDConnectConfiguration"
            case samlConfiguration = "samlConfiguration"
        }
    }

    public enum PluginAuthConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Information about the basic authentication credentials used to configure a plugin.
        case basicAuthConfiguration(BasicAuthConfiguration)
        /// Information about the IAM Identity Center Application used to configure authentication for a plugin.
        case idcAuthConfiguration(IdcAuthConfiguration)
        /// Information about invoking a custom plugin without any authentication.
        case noAuthConfiguration(NoAuthConfiguration)
        /// Information about the OAuth 2.0 authentication credential/token used to configure a plugin.
        case oAuth2ClientCredentialConfiguration(OAuth2ClientCredentialConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .basicAuthConfiguration:
                let value = try container.decode(BasicAuthConfiguration.self, forKey: .basicAuthConfiguration)
                self = .basicAuthConfiguration(value)
            case .idcAuthConfiguration:
                let value = try container.decode(IdcAuthConfiguration.self, forKey: .idcAuthConfiguration)
                self = .idcAuthConfiguration(value)
            case .noAuthConfiguration:
                let value = try container.decode(NoAuthConfiguration.self, forKey: .noAuthConfiguration)
                self = .noAuthConfiguration(value)
            case .oAuth2ClientCredentialConfiguration:
                let value = try container.decode(OAuth2ClientCredentialConfiguration.self, forKey: .oAuth2ClientCredentialConfiguration)
                self = .oAuth2ClientCredentialConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .basicAuthConfiguration(let value):
                try container.encode(value, forKey: .basicAuthConfiguration)
            case .idcAuthConfiguration(let value):
                try container.encode(value, forKey: .idcAuthConfiguration)
            case .noAuthConfiguration(let value):
                try container.encode(value, forKey: .noAuthConfiguration)
            case .oAuth2ClientCredentialConfiguration(let value):
                try container.encode(value, forKey: .oAuth2ClientCredentialConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .basicAuthConfiguration(let value):
                try value.validate(name: "\(name).basicAuthConfiguration")
            case .idcAuthConfiguration(let value):
                try value.validate(name: "\(name).idcAuthConfiguration")
            case .oAuth2ClientCredentialConfiguration(let value):
                try value.validate(name: "\(name).oAuth2ClientCredentialConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case basicAuthConfiguration = "basicAuthConfiguration"
            case idcAuthConfiguration = "idcAuthConfiguration"
            case noAuthConfiguration = "noAuthConfiguration"
            case oAuth2ClientCredentialConfiguration = "oAuth2ClientCredentialConfiguration"
        }
    }

    public enum Principal: AWSEncodableShape, Sendable {
        ///  The group associated with the principal.
        case group(PrincipalGroup)
        /// The user associated with the principal.
        case user(PrincipalUser)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .group(let value):
                try container.encode(value, forKey: .group)
            case .user(let value):
                try container.encode(value, forKey: .user)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .group(let value):
                try value.validate(name: "\(name).group")
            case .user(let value):
                try value.validate(name: "\(name).user")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public enum RetrieverConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Provides information on how the Amazon Kendra index used as a retriever for your Amazon Q Business application is configured.
        case kendraIndexConfiguration(KendraIndexConfiguration)
        /// Provides information on how a Amazon Q Business index used as a retriever for your Amazon Q Business application is configured.
        case nativeIndexConfiguration(NativeIndexConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .kendraIndexConfiguration:
                let value = try container.decode(KendraIndexConfiguration.self, forKey: .kendraIndexConfiguration)
                self = .kendraIndexConfiguration(value)
            case .nativeIndexConfiguration:
                let value = try container.decode(NativeIndexConfiguration.self, forKey: .nativeIndexConfiguration)
                self = .nativeIndexConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .kendraIndexConfiguration(let value):
                try container.encode(value, forKey: .kendraIndexConfiguration)
            case .nativeIndexConfiguration(let value):
                try container.encode(value, forKey: .nativeIndexConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .kendraIndexConfiguration(let value):
                try value.validate(name: "\(name).kendraIndexConfiguration")
            case .nativeIndexConfiguration(let value):
                try value.validate(name: "\(name).nativeIndexConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case kendraIndexConfiguration = "kendraIndexConfiguration"
            case nativeIndexConfiguration = "nativeIndexConfiguration"
        }
    }

    public enum RuleConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A rule for configuring how Amazon Q Business responds when it encounters a a blocked topic.
        case contentBlockerRule(ContentBlockerRule)
        case contentRetrievalRule(ContentRetrievalRule)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contentBlockerRule:
                let value = try container.decode(ContentBlockerRule.self, forKey: .contentBlockerRule)
                self = .contentBlockerRule(value)
            case .contentRetrievalRule:
                let value = try container.decode(ContentRetrievalRule.self, forKey: .contentRetrievalRule)
                self = .contentRetrievalRule(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .contentBlockerRule(let value):
                try container.encode(value, forKey: .contentBlockerRule)
            case .contentRetrievalRule(let value):
                try container.encode(value, forKey: .contentRetrievalRule)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contentBlockerRule(let value):
                try value.validate(name: "\(name).contentBlockerRule")
            case .contentRetrievalRule(let value):
                try value.validate(name: "\(name).contentRetrievalRule")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contentBlockerRule = "contentBlockerRule"
            case contentRetrievalRule = "contentRetrievalRule"
        }
    }

    public enum SourceDetails: AWSDecodableShape, Sendable {
        /// Details specific to audio content within the source.
        case audioSourceDetails(AudioSourceDetails)
        /// Details specific to image content within the source.
        case imageSourceDetails(ImageSourceDetails)
        /// Details specific to video content within the source.
        case videoSourceDetails(VideoSourceDetails)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .audioSourceDetails:
                let value = try container.decode(AudioSourceDetails.self, forKey: .audioSourceDetails)
                self = .audioSourceDetails(value)
            case .imageSourceDetails:
                let value = try container.decode(ImageSourceDetails.self, forKey: .imageSourceDetails)
                self = .imageSourceDetails(value)
            case .videoSourceDetails:
                let value = try container.decode(VideoSourceDetails.self, forKey: .videoSourceDetails)
                self = .videoSourceDetails(value)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case audioSourceDetails = "audioSourceDetails"
            case imageSourceDetails = "imageSourceDetails"
            case videoSourceDetails = "videoSourceDetails"
        }
    }

    public enum SubscriptionPrincipal: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// The identifier of a group in the IAM Identity Center instance connected to the Amazon Q Business application.
        case group(String)
        /// The identifier of a user in the IAM Identity Center instance connected to the Amazon Q Business application.
        case user(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .group:
                let value = try container.decode(String.self, forKey: .group)
                self = .group(value)
            case .user:
                let value = try container.decode(String.self, forKey: .user)
                self = .user(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .group(let value):
                try container.encode(value, forKey: .group)
            case .user(let value):
                try container.encode(value, forKey: .user)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .group(let value):
                try self.validate(value, name: "group", parent: name, max: 47)
                try self.validate(value, name: "group", parent: name, min: 1)
                try self.validate(value, name: "group", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
            case .user(let value):
                try self.validate(value, name: "user", parent: name, max: 47)
                try self.validate(value, name: "user", parent: name, min: 1)
                try self.validate(value, name: "user", parent: name, pattern: "^([0-9a-f]{10}-|)[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    // MARK: Shapes

    public struct AccessConfiguration: AWSEncodableShape {
        /// A list of AccessControlList objects.
        public let accessControls: [AccessControl]
        /// Describes the member relation within the AccessControlList object.
        public let memberRelation: MemberRelation?

        @inlinable
        public init(accessControls: [AccessControl], memberRelation: MemberRelation? = nil) {
            self.accessControls = accessControls
            self.memberRelation = memberRelation
        }

        public func validate(name: String) throws {
            try self.accessControls.forEach {
                try $0.validate(name: "\(name).accessControls[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessControls = "accessControls"
            case memberRelation = "memberRelation"
        }
    }

    public struct AccessControl: AWSEncodableShape {
        /// Describes the member relation within a principal list.
        public let memberRelation: MemberRelation?
        /// Contains a list of principals, where a principal can be either a USER or a GROUP. Each principal can be have the following type of document access: ALLOW or DENY.
        public let principals: [Principal]

        @inlinable
        public init(memberRelation: MemberRelation? = nil, principals: [Principal]) {
            self.memberRelation = memberRelation
            self.principals = principals
        }

        public func validate(name: String) throws {
            try self.principals.forEach {
                try $0.validate(name: "\(name).principals[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case memberRelation = "memberRelation"
            case principals = "principals"
        }
    }

    public struct ActionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Q Business action that is allowed.
        public let action: String
        /// The filter configuration for the action, if any.
        public let filterConfiguration: ActionFilterConfiguration?

        @inlinable
        public init(action: String, filterConfiguration: ActionFilterConfiguration? = nil) {
            self.action = action
            self.filterConfiguration = filterConfiguration
        }

        public func validate(name: String) throws {
            try self.validate(self.action, name: "action", parent: name, pattern: "^qbusiness:[a-zA-Z]+$")
            try self.filterConfiguration?.validate(name: "\(name).filterConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case action = "action"
            case filterConfiguration = "filterConfiguration"
        }
    }

    public struct ActionExecution: AWSEncodableShape & AWSDecodableShape {
        /// A mapping of field names to the field values in input that an end user provides to Amazon Q Business requests to perform their plugin action.
        public let payload: [String: ActionExecutionPayloadField]
        /// A string used to retain information about the hierarchical contexts within an action execution event payload.
        public let payloadFieldNameSeparator: String
        /// The identifier of the plugin the action is attached to.
        public let pluginId: String

        @inlinable
        public init(payload: [String: ActionExecutionPayloadField], payloadFieldNameSeparator: String, pluginId: String) {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
        }

        public func validate(name: String) throws {
            try self.payload.forEach {
                try validate($0.key, name: "payload.key", parent: name, min: 1)
            }
            try self.validate(self.payloadFieldNameSeparator, name: "payloadFieldNameSeparator", parent: name, max: 1)
            try self.validate(self.payloadFieldNameSeparator, name: "payloadFieldNameSeparator", parent: name, min: 1)
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case payloadFieldNameSeparator = "payloadFieldNameSeparator"
            case pluginId = "pluginId"
        }
    }

    public struct ActionExecutionEvent: AWSEncodableShape {
        /// A mapping of field names to the field values in input that an end user provides to Amazon Q Business requests to perform their plugin action.
        public let payload: [String: ActionExecutionPayloadField]
        /// A string used to retain information about the hierarchical contexts within a action execution event payload.
        public let payloadFieldNameSeparator: String
        /// The identifier of the plugin for which the action is being requested.
        public let pluginId: String

        @inlinable
        public init(payload: [String: ActionExecutionPayloadField], payloadFieldNameSeparator: String, pluginId: String) {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
        }

        public func validate(name: String) throws {
            try self.payload.forEach {
                try validate($0.key, name: "payload.key", parent: name, min: 1)
            }
            try self.validate(self.payloadFieldNameSeparator, name: "payloadFieldNameSeparator", parent: name, max: 1)
            try self.validate(self.payloadFieldNameSeparator, name: "payloadFieldNameSeparator", parent: name, min: 1)
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case payloadFieldNameSeparator = "payloadFieldNameSeparator"
            case pluginId = "pluginId"
        }
    }

    public struct ActionExecutionPayloadField: AWSEncodableShape & AWSDecodableShape {
        /// The content of a user input field in an plugin action execution payload.
        public let value: AWSDocument

        @inlinable
        public init(value: AWSDocument) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct ActionFilterConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let documentAttributeFilter: AttributeFilter

        @inlinable
        public init(documentAttributeFilter: AttributeFilter) {
            self.documentAttributeFilter = documentAttributeFilter
        }

        public func validate(name: String) throws {
            try self.documentAttributeFilter.validate(name: "\(name).documentAttributeFilter")
        }

        private enum CodingKeys: String, CodingKey {
            case documentAttributeFilter = "documentAttributeFilter"
        }
    }

    public struct ActionReview: AWSDecodableShape {
        /// Field values that an end user needs to provide to Amazon Q Business for Amazon Q Business to perform the requested plugin action.
        public let payload: [String: ActionReviewPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action review payload.
        public let payloadFieldNameSeparator: String?
        /// The identifier of the plugin associated with the action review.
        public let pluginId: String?
        /// The type of plugin.
        public let pluginType: PluginType?

        @inlinable
        public init(payload: [String: ActionReviewPayloadField]? = nil, payloadFieldNameSeparator: String? = nil, pluginId: String? = nil, pluginType: PluginType? = nil) {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
            self.pluginType = pluginType
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case payloadFieldNameSeparator = "payloadFieldNameSeparator"
            case pluginId = "pluginId"
            case pluginType = "pluginType"
        }
    }

    public struct ActionReviewEvent: AWSDecodableShape {
        /// The identifier of the conversation with which the action review event is associated.
        public let conversationId: String?
        /// Field values that an end user needs to provide to Amazon Q Business for Amazon Q Business to perform the requested plugin action.
        public let payload: [String: ActionReviewPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action review event payload.
        public let payloadFieldNameSeparator: String?
        /// The identifier of the plugin associated with the action review event.
        public let pluginId: String?
        /// The type of plugin.
        public let pluginType: PluginType?
        /// The identifier of an Amazon Q Business AI generated associated with the action review event.
        public let systemMessageId: String?
        /// The identifier of the conversation with which the plugin action is associated.
        public let userMessageId: String?

        @inlinable
        public init(conversationId: String? = nil, payload: [String: ActionReviewPayloadField]? = nil, payloadFieldNameSeparator: String? = nil, pluginId: String? = nil, pluginType: PluginType? = nil, systemMessageId: String? = nil, userMessageId: String? = nil) {
            self.conversationId = conversationId
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
            self.pluginType = pluginType
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case payload = "payload"
            case payloadFieldNameSeparator = "payloadFieldNameSeparator"
            case pluginId = "pluginId"
            case pluginType = "pluginType"
            case systemMessageId = "systemMessageId"
            case userMessageId = "userMessageId"
        }
    }

    public struct ActionReviewPayloadField: AWSDecodableShape {
        /// The expected data format for the action review input field value. For example, in PTO request, from and to would be of datetime allowed format.
        public let allowedFormat: String?
        /// Information about the field values that an end user can use to provide to Amazon Q Business for Amazon Q Business to perform the requested plugin action.
        public let allowedValues: [ActionReviewPayloadFieldAllowedValue]?
        /// Use to create a custom form with array fields (fields with nested objects inside an array).
        public let arrayItemJsonSchema: AWSDocument?
        /// The field level description of each action review input field. This could be an explanation of the field. In the Amazon Q Business web experience, these descriptions could be used to display as tool tips to help users understand the field.
        public let displayDescription: String?
        ///  The name of the field.
        public let displayName: String?
        /// The display order of fields in a payload.
        public let displayOrder: Int?
        /// Information about whether the field is required.
        public let required: Bool?
        /// The type of field.
        public let type: ActionPayloadFieldType?
        /// The field value.
        public let value: AWSDocument?

        @inlinable
        public init(allowedFormat: String? = nil, allowedValues: [ActionReviewPayloadFieldAllowedValue]? = nil, arrayItemJsonSchema: AWSDocument? = nil, displayDescription: String? = nil, displayName: String? = nil, displayOrder: Int? = nil, required: Bool? = nil, type: ActionPayloadFieldType? = nil, value: AWSDocument? = nil) {
            self.allowedFormat = allowedFormat
            self.allowedValues = allowedValues
            self.arrayItemJsonSchema = arrayItemJsonSchema
            self.displayDescription = displayDescription
            self.displayName = displayName
            self.displayOrder = displayOrder
            self.required = required
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case allowedFormat = "allowedFormat"
            case allowedValues = "allowedValues"
            case arrayItemJsonSchema = "arrayItemJsonSchema"
            case displayDescription = "displayDescription"
            case displayName = "displayName"
            case displayOrder = "displayOrder"
            case required = "required"
            case type = "type"
            case value = "value"
        }
    }

    public struct ActionReviewPayloadFieldAllowedValue: AWSDecodableShape {
        /// The name of the field.
        public let displayValue: AWSDocument?
        /// The field value.
        public let value: AWSDocument?

        @inlinable
        public init(displayValue: AWSDocument? = nil, value: AWSDocument? = nil) {
            self.displayValue = displayValue
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case displayValue = "displayValue"
            case value = "value"
        }
    }

    public struct ActionSummary: AWSDecodableShape {
        /// The identifier of an Amazon Q Business plugin action.
        public let actionIdentifier: String?
        /// The description of an Amazon Q Business plugin action.
        public let description: String?
        /// The display name assigned by Amazon Q Business to a plugin action. You can't modify this value.
        public let displayName: String?
        /// An Amazon Q Business suggested prompt and end user can use to invoke a plugin action. This value can be modified and sent as input to initiate an action. For example:   Create a Jira task   Create a chat assistant task to find the root cause of a specific incident
        public let instructionExample: String?

        @inlinable
        public init(actionIdentifier: String? = nil, description: String? = nil, displayName: String? = nil, instructionExample: String? = nil) {
            self.actionIdentifier = actionIdentifier
            self.description = description
            self.displayName = displayName
            self.instructionExample = instructionExample
        }

        private enum CodingKeys: String, CodingKey {
            case actionIdentifier = "actionIdentifier"
            case description = "description"
            case displayName = "displayName"
            case instructionExample = "instructionExample"
        }
    }

    public struct Application: AWSDecodableShape {
        /// The identifier for the Amazon Q Business application.
        public let applicationId: String?
        /// The Unix timestamp when the Amazon Q Business application was created.
        public let createdAt: Date?
        /// The name of the Amazon Q Business application.
        public let displayName: String?
        /// The authentication type being used by a Amazon Q Business application.
        public let identityType: IdentityType?
        /// The Amazon QuickSight configuration for an Amazon Q Business application that uses QuickSight as the identity provider.
        public let quickSightConfiguration: QuickSightConfiguration?
        /// The status of the Amazon Q Business application. The application is ready to use when the status is ACTIVE.
        public let status: ApplicationStatus?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(applicationId: String? = nil, createdAt: Date? = nil, displayName: String? = nil, identityType: IdentityType? = nil, quickSightConfiguration: QuickSightConfiguration? = nil, status: ApplicationStatus? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.createdAt = createdAt
            self.displayName = displayName
            self.identityType = identityType
            self.quickSightConfiguration = quickSightConfiguration
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case identityType = "identityType"
            case quickSightConfiguration = "quickSightConfiguration"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct AppliedAttachmentsConfiguration: AWSDecodableShape {
        /// Information about whether file upload during chat functionality is activated for your application.
        public let attachmentsControlMode: AttachmentsControlMode?

        @inlinable
        public init(attachmentsControlMode: AttachmentsControlMode? = nil) {
            self.attachmentsControlMode = attachmentsControlMode
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsControlMode = "attachmentsControlMode"
        }
    }

    public struct AppliedCreatorModeConfiguration: AWSDecodableShape {
        ///  Information about whether creator mode is enabled or disabled for an Amazon Q Business application.
        public let creatorModeControl: CreatorModeControl

        @inlinable
        public init(creatorModeControl: CreatorModeControl) {
            self.creatorModeControl = creatorModeControl
        }

        private enum CodingKeys: String, CodingKey {
            case creatorModeControl = "creatorModeControl"
        }
    }

    public struct AppliedOrchestrationConfiguration: AWSDecodableShape {
        ///  Information about whether chat orchestration is enabled or disabled for an Amazon Q Business application.
        public let control: OrchestrationControl

        @inlinable
        public init(control: OrchestrationControl) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control = "control"
        }
    }

    public struct AssociatePermissionRequest: AWSEncodableShape {
        /// The list of Amazon Q Business actions that the ISV is allowed to perform.
        public let actions: [String]
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The Amazon Resource Name of the IAM role for the ISV that is being granted permission.
        public let principal: String
        /// A unique identifier for the policy statement.
        public let statementId: String

        @inlinable
        public init(actions: [String], applicationId: String, principal: String, statementId: String) {
            self.actions = actions
            self.applicationId = applicationId
            self.principal = principal
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actions, forKey: .actions)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encode(self.principal, forKey: .principal)
            try container.encode(self.statementId, forKey: .statementId)
        }

        public func validate(name: String) throws {
            try self.actions.forEach {
                try validate($0, name: "actions[]", parent: name, pattern: "^qbusiness:[a-zA-Z]+$")
            }
            try self.validate(self.actions, name: "actions", parent: name, max: 10)
            try self.validate(self.actions, name: "actions", parent: name, min: 1)
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.principal, name: "principal", parent: name, max: 1284)
            try self.validate(self.principal, name: "principal", parent: name, min: 1)
            try self.validate(self.principal, name: "principal", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/[a-zA-Z0-9_/+=,.@-]+$")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 100)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
            try self.validate(self.statementId, name: "statementId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case actions = "actions"
            case principal = "principal"
            case statementId = "statementId"
        }
    }

    public struct AssociatePermissionResponse: AWSDecodableShape {
        /// The JSON representation of the added permission statement.
        public let statement: String?

        @inlinable
        public init(statement: String? = nil) {
            self.statement = statement
        }

        private enum CodingKeys: String, CodingKey {
            case statement = "statement"
        }
    }

    public struct Attachment: AWSDecodableShape {
        /// The identifier of the Amazon Q Business attachment.
        public let attachmentId: String?
        /// The identifier of the Amazon Q Business conversation the attachment is associated with.
        public let conversationId: String?
        /// A CopyFromSource containing a reference to the original source of the Amazon Q Business attachment.
        public let copyFrom: CopyFromSource?
        /// The Unix timestamp when the Amazon Q Business attachment was created.
        public let createdAt: Date?
        /// ErrorDetail providing information about a Amazon Q Business attachment error.
        public let error: ErrorDetail?
        /// Size in bytes of the Amazon Q Business attachment.
        public let fileSize: Int?
        /// Filetype of the Amazon Q Business attachment.
        public let fileType: String?
        /// MD5 checksum of the Amazon Q Business attachment contents.
        public let md5chksum: String?
        /// Filename of the Amazon Q Business attachment.
        public let name: String?
        /// AttachmentStatus of the Amazon Q Business attachment.
        public let status: AttachmentStatus?

        @inlinable
        public init(attachmentId: String? = nil, conversationId: String? = nil, copyFrom: CopyFromSource? = nil, createdAt: Date? = nil, error: ErrorDetail? = nil, fileSize: Int? = nil, fileType: String? = nil, md5chksum: String? = nil, name: String? = nil, status: AttachmentStatus? = nil) {
            self.attachmentId = attachmentId
            self.conversationId = conversationId
            self.copyFrom = copyFrom
            self.createdAt = createdAt
            self.error = error
            self.fileSize = fileSize
            self.fileType = fileType
            self.md5chksum = md5chksum
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "attachmentId"
            case conversationId = "conversationId"
            case copyFrom = "copyFrom"
            case createdAt = "createdAt"
            case error = "error"
            case fileSize = "fileSize"
            case fileType = "fileType"
            case md5chksum = "md5chksum"
            case name = "name"
            case status = "status"
        }
    }

    public struct AttachmentInput: AWSEncodableShape {
        /// A reference to an existing attachment.
        public let copyFrom: CopyFromSource?
        /// The contents of the attachment.
        public let data: AWSBase64Data?
        /// The filename of the attachment.
        public let name: String?

        @inlinable
        public init(copyFrom: CopyFromSource? = nil, data: AWSBase64Data? = nil, name: String? = nil) {
            self.copyFrom = copyFrom
            self.data = data
            self.name = name
        }

        public func validate(name: String) throws {
            try self.copyFrom?.validate(name: "\(name).copyFrom")
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case copyFrom = "copyFrom"
            case data = "data"
            case name = "name"
        }
    }

    public struct AttachmentInputEvent: AWSEncodableShape {
        public let attachment: AttachmentInput?

        @inlinable
        public init(attachment: AttachmentInput? = nil) {
            self.attachment = attachment
        }

        public func validate(name: String) throws {
            try self.attachment?.validate(name: "\(name).attachment")
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "attachment"
        }
    }

    public struct AttachmentOutput: AWSDecodableShape {
        /// The unique identifier of the Amazon Q Business attachment.
        public let attachmentId: String?
        /// The unique identifier of the Amazon Q Business conversation.
        public let conversationId: String?
        /// An error associated with a file uploaded during chat.
        public let error: ErrorDetail?
        /// The name of a file uploaded during chat.
        public let name: String?
        /// The status of a file uploaded during chat.
        public let status: AttachmentStatus?

        @inlinable
        public init(attachmentId: String? = nil, conversationId: String? = nil, error: ErrorDetail? = nil, name: String? = nil, status: AttachmentStatus? = nil) {
            self.attachmentId = attachmentId
            self.conversationId = conversationId
            self.error = error
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "attachmentId"
            case conversationId = "conversationId"
            case error = "error"
            case name = "name"
            case status = "status"
        }
    }

    public struct AttachmentsConfiguration: AWSEncodableShape {
        /// Status information about whether file upload functionality is activated or deactivated for your end user.
        public let attachmentsControlMode: AttachmentsControlMode

        @inlinable
        public init(attachmentsControlMode: AttachmentsControlMode) {
            self.attachmentsControlMode = attachmentsControlMode
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsControlMode = "attachmentsControlMode"
        }
    }

    public final class AttributeFilter: AWSEncodableShape & AWSDecodableShape {
        /// Performs a logical AND operation on all supplied filters.
        public let andAllFilters: [AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields. Supported for the following document attribute value types: stringListValue.
        public let containsAll: DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields. Supported for the following document attribute value types: stringListValue.
        public let containsAny: DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue, longValue, stringListValue and stringValue.
        public let equalsTo: DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let greaterThan: DocumentAttribute?
        /// Performs a greater or equals than operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let greaterThanOrEquals: DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Supported for the following document attribute value types: dateValue and longValue.
        public let lessThan: DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields.Supported for the following document attribute value type: dateValue and longValue.
        public let lessThanOrEquals: DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        public let notFilter: AttributeFilter?
        ///  Performs a logical OR operation on all supplied filters.
        public let orAllFilters: [AttributeFilter]?

        @inlinable
        public init(andAllFilters: [AttributeFilter]? = nil, containsAll: DocumentAttribute? = nil, containsAny: DocumentAttribute? = nil, equalsTo: DocumentAttribute? = nil, greaterThan: DocumentAttribute? = nil, greaterThanOrEquals: DocumentAttribute? = nil, lessThan: DocumentAttribute? = nil, lessThanOrEquals: DocumentAttribute? = nil, notFilter: AttributeFilter? = nil, orAllFilters: [AttributeFilter]? = nil) {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }

        public func validate(name: String) throws {
            try self.andAllFilters?.forEach {
                try $0.validate(name: "\(name).andAllFilters[]")
            }
            try self.containsAll?.validate(name: "\(name).containsAll")
            try self.containsAny?.validate(name: "\(name).containsAny")
            try self.equalsTo?.validate(name: "\(name).equalsTo")
            try self.greaterThan?.validate(name: "\(name).greaterThan")
            try self.greaterThanOrEquals?.validate(name: "\(name).greaterThanOrEquals")
            try self.lessThan?.validate(name: "\(name).lessThan")
            try self.lessThanOrEquals?.validate(name: "\(name).lessThanOrEquals")
            try self.notFilter?.validate(name: "\(name).notFilter")
            try self.orAllFilters?.forEach {
                try $0.validate(name: "\(name).orAllFilters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAllFilters = "andAllFilters"
            case containsAll = "containsAll"
            case containsAny = "containsAny"
            case equalsTo = "equalsTo"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case notFilter = "notFilter"
            case orAllFilters = "orAllFilters"
        }
    }

    public struct AudioExtractionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The status of audio extraction (ENABLED or DISABLED) for processing audio content from files.
        public let audioExtractionStatus: AudioExtractionStatus

        @inlinable
        public init(audioExtractionStatus: AudioExtractionStatus) {
            self.audioExtractionStatus = audioExtractionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case audioExtractionStatus = "audioExtractionStatus"
        }
    }

    public struct AudioSourceDetails: AWSDecodableShape {
        /// The type of audio extraction performed on the content.
        public let audioExtractionType: AudioExtractionType?
        /// The ending timestamp in milliseconds for the relevant audio segment.
        public let endTimeMilliseconds: Int64?
        /// Unique identifier for the audio media file.
        public let mediaId: String?
        /// The MIME type of the audio file (e.g., audio/mp3, audio/wav).
        public let mediaMimeType: String?
        /// The starting timestamp in milliseconds for the relevant audio segment.
        public let startTimeMilliseconds: Int64?

        @inlinable
        public init(audioExtractionType: AudioExtractionType? = nil, endTimeMilliseconds: Int64? = nil, mediaId: String? = nil, mediaMimeType: String? = nil, startTimeMilliseconds: Int64? = nil) {
            self.audioExtractionType = audioExtractionType
            self.endTimeMilliseconds = endTimeMilliseconds
            self.mediaId = mediaId
            self.mediaMimeType = mediaMimeType
            self.startTimeMilliseconds = startTimeMilliseconds
        }

        private enum CodingKeys: String, CodingKey {
            case audioExtractionType = "audioExtractionType"
            case endTimeMilliseconds = "endTimeMilliseconds"
            case mediaId = "mediaId"
            case mediaMimeType = "mediaMimeType"
            case startTimeMilliseconds = "startTimeMilliseconds"
        }
    }

    public struct AuthChallengeRequest: AWSDecodableShape {
        /// The URL sent by Amazon Q Business to the third party authentication server to authenticate a custom plugin user through an OAuth protocol.
        public let authorizationUrl: String

        @inlinable
        public init(authorizationUrl: String) {
            self.authorizationUrl = authorizationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationUrl = "authorizationUrl"
        }
    }

    public struct AuthChallengeRequestEvent: AWSDecodableShape {
        /// The URL sent by Amazon Q Business to a third party authentication server in response to an authentication verification event activated by an end user request to use a custom plugin.
        public let authorizationUrl: String

        @inlinable
        public init(authorizationUrl: String) {
            self.authorizationUrl = authorizationUrl
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationUrl = "authorizationUrl"
        }
    }

    public struct AuthChallengeResponse: AWSEncodableShape {
        /// The mapping of key-value pairs in an authentication challenge response.
        public let responseMap: [String: String]

        @inlinable
        public init(responseMap: [String: String]) {
            self.responseMap = responseMap
        }

        public func validate(name: String) throws {
            try self.responseMap.forEach {
                try validate($0.key, name: "responseMap.key", parent: name, max: 100)
                try validate($0.key, name: "responseMap.key", parent: name, min: 1)
                try validate($0.value, name: "responseMap[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "responseMap[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case responseMap = "responseMap"
        }
    }

    public struct AuthChallengeResponseEvent: AWSEncodableShape {
        /// The mapping of key-value pairs in an authentication challenge response.
        public let responseMap: [String: String]

        @inlinable
        public init(responseMap: [String: String]) {
            self.responseMap = responseMap
        }

        public func validate(name: String) throws {
            try self.responseMap.forEach {
                try validate($0.key, name: "responseMap.key", parent: name, max: 100)
                try validate($0.key, name: "responseMap.key", parent: name, min: 1)
                try validate($0.value, name: "responseMap[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "responseMap[\"\($0.key)\"]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case responseMap = "responseMap"
        }
    }

    public struct AutoSubscriptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Describes whether automatic subscriptions are enabled for an Amazon Q Business application using IAM identity federation for user management.
        public let autoSubscribe: AutoSubscriptionStatus
        /// Describes the default subscription type assigned to an Amazon Q Business application using IAM identity federation for user management. If the value for autoSubscribe is set to ENABLED you must select a value for this field.
        public let defaultSubscriptionType: SubscriptionType?

        @inlinable
        public init(autoSubscribe: AutoSubscriptionStatus, defaultSubscriptionType: SubscriptionType? = nil) {
            self.autoSubscribe = autoSubscribe
            self.defaultSubscriptionType = defaultSubscriptionType
        }

        private enum CodingKeys: String, CodingKey {
            case autoSubscribe = "autoSubscribe"
            case defaultSubscriptionType = "defaultSubscriptionType"
        }
    }

    public struct BasicAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of an IAM role used by Amazon Q Business to access the basic authentication credentials stored in a Secrets Manager secret.
        public let roleArn: String
        /// The ARN of the Secrets Manager secret that stores the basic authentication credentials used for plugin configuration..
        public let secretArn: String

        @inlinable
        public init(roleArn: String, secretArn: String) {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 1284)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case secretArn = "secretArn"
        }
    }

    public struct BatchDeleteDocumentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The identifier of the data source sync during which the documents were deleted.
        public let dataSourceSyncId: String?
        /// Documents deleted from the Amazon Q Business index.
        public let documents: [DeleteDocument]
        /// The identifier of the Amazon Q Business index that contains the documents to delete.
        public let indexId: String

        @inlinable
        public init(applicationId: String, dataSourceSyncId: String? = nil, documents: [DeleteDocument], indexId: String) {
            self.applicationId = applicationId
            self.dataSourceSyncId = dataSourceSyncId
            self.documents = documents
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.dataSourceSyncId, forKey: .dataSourceSyncId)
            try container.encode(self.documents, forKey: .documents)
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, max: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, min: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.documents.forEach {
                try $0.validate(name: "\(name).documents[]")
            }
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSyncId = "dataSourceSyncId"
            case documents = "documents"
        }
    }

    public struct BatchDeleteDocumentResponse: AWSDecodableShape {
        /// A list of documents that couldn't be removed from the Amazon Q Business index. Each entry contains an error message that indicates why the document couldn't be removed from the index.
        public let failedDocuments: [FailedDocument]?

        @inlinable
        public init(failedDocuments: [FailedDocument]? = nil) {
            self.failedDocuments = failedDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case failedDocuments = "failedDocuments"
        }
    }

    public struct BatchPutDocumentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The identifier of the data source sync during which the documents were added.
        public let dataSourceSyncId: String?
        /// One or more documents to add to the index.
        public let documents: [Document]
        /// The identifier of the Amazon Q Business index to add the documents to.
        public let indexId: String
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access your S3 bucket.
        public let roleArn: String?

        @inlinable
        public init(applicationId: String, dataSourceSyncId: String? = nil, documents: [Document], indexId: String, roleArn: String? = nil) {
            self.applicationId = applicationId
            self.dataSourceSyncId = dataSourceSyncId
            self.documents = documents
            self.indexId = indexId
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.dataSourceSyncId, forKey: .dataSourceSyncId)
            try container.encode(self.documents, forKey: .documents)
            request.encodePath(self.indexId, key: "indexId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, max: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, min: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.documents.forEach {
                try $0.validate(name: "\(name).documents[]")
            }
            try self.validate(self.documents, name: "documents", parent: name, max: 10)
            try self.validate(self.documents, name: "documents", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSyncId = "dataSourceSyncId"
            case documents = "documents"
            case roleArn = "roleArn"
        }
    }

    public struct BatchPutDocumentResponse: AWSDecodableShape {
        ///  A list of documents that were not added to the Amazon Q Business index because the document failed a validation check. Each document contains an error message that indicates why the document couldn't be added to the index.
        public let failedDocuments: [FailedDocument]?

        @inlinable
        public init(failedDocuments: [FailedDocument]? = nil) {
            self.failedDocuments = failedDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case failedDocuments = "failedDocuments"
        }
    }

    public struct BlockedPhrasesConfiguration: AWSDecodableShape {
        /// A list of phrases blocked from a Amazon Q Business web experience chat.
        public let blockedPhrases: [String]?
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public let systemMessageOverride: String?

        @inlinable
        public init(blockedPhrases: [String]? = nil, systemMessageOverride: String? = nil) {
            self.blockedPhrases = blockedPhrases
            self.systemMessageOverride = systemMessageOverride
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrases = "blockedPhrases"
            case systemMessageOverride = "systemMessageOverride"
        }
    }

    public struct BlockedPhrasesConfigurationUpdate: AWSEncodableShape {
        /// Creates or updates a blocked phrases configuration in your Amazon Q Business application.
        public let blockedPhrasesToCreateOrUpdate: [String]?
        /// Deletes a blocked phrases configuration in your Amazon Q Business application.
        public let blockedPhrasesToDelete: [String]?
        /// The configured custom message displayed to your end user when they use blocked phrase during chat.
        public let systemMessageOverride: String?

        @inlinable
        public init(blockedPhrasesToCreateOrUpdate: [String]? = nil, blockedPhrasesToDelete: [String]? = nil, systemMessageOverride: String? = nil) {
            self.blockedPhrasesToCreateOrUpdate = blockedPhrasesToCreateOrUpdate
            self.blockedPhrasesToDelete = blockedPhrasesToDelete
            self.systemMessageOverride = systemMessageOverride
        }

        public func validate(name: String) throws {
            try self.blockedPhrasesToCreateOrUpdate?.forEach {
                try validate($0, name: "blockedPhrasesToCreateOrUpdate[]", parent: name, max: 36)
                try validate($0, name: "blockedPhrasesToCreateOrUpdate[]", parent: name, pattern: "^\\P{C}*$")
            }
            try self.blockedPhrasesToDelete?.forEach {
                try validate($0, name: "blockedPhrasesToDelete[]", parent: name, max: 36)
                try validate($0, name: "blockedPhrasesToDelete[]", parent: name, pattern: "^\\P{C}*$")
            }
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, max: 350)
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrasesToCreateOrUpdate = "blockedPhrasesToCreateOrUpdate"
            case blockedPhrasesToDelete = "blockedPhrasesToDelete"
            case systemMessageOverride = "systemMessageOverride"
        }
    }

    public struct BrowserExtensionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specify the browser extensions allowed for your Amazon Q web experience.    CHROME — Enables the extension for Chromium-based browsers (Google Chrome, Microsoft Edge, Opera, etc.).    FIREFOX — Enables the extension for Mozilla Firefox.    CHROME and FIREFOX — Enable the extension for Chromium-based browsers and Mozilla Firefox.
        public let enabledBrowserExtensions: [BrowserExtension]

        @inlinable
        public init(enabledBrowserExtensions: [BrowserExtension]) {
            self.enabledBrowserExtensions = enabledBrowserExtensions
        }

        public func validate(name: String) throws {
            try self.validate(self.enabledBrowserExtensions, name: "enabledBrowserExtensions", parent: name, max: 2)
        }

        private enum CodingKeys: String, CodingKey {
            case enabledBrowserExtensions = "enabledBrowserExtensions"
        }
    }

    public struct CancelSubscriptionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application for which the subscription is being cancelled.
        public let applicationId: String
        /// The identifier of the Amazon Q Business subscription being cancelled.
        public let subscriptionId: String

        @inlinable
        public init(applicationId: String, subscriptionId: String) {
            self.applicationId = applicationId
            self.subscriptionId = subscriptionId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.subscriptionId, key: "subscriptionId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.subscriptionId, name: "subscriptionId", parent: name, max: 1224)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct CancelSubscriptionResponse: AWSDecodableShape {
        /// The type of your current Amazon Q Business subscription.
        public let currentSubscription: SubscriptionDetails?
        /// The type of the Amazon Q Business subscription for the next month.
        public let nextSubscription: SubscriptionDetails?
        /// The Amazon Resource Name (ARN) of the Amazon Q Business subscription being cancelled.
        public let subscriptionArn: String?

        @inlinable
        public init(currentSubscription: SubscriptionDetails? = nil, nextSubscription: SubscriptionDetails? = nil, subscriptionArn: String? = nil) {
            self.currentSubscription = currentSubscription
            self.nextSubscription = nextSubscription
            self.subscriptionArn = subscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case currentSubscription = "currentSubscription"
            case nextSubscription = "nextSubscription"
            case subscriptionArn = "subscriptionArn"
        }
    }

    public struct ChatInput: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application linked to a streaming Amazon Q Business conversation.
        public let applicationId: String
        /// A token that you provide to identify the chat input.
        public let clientToken: String?
        /// The identifier of the Amazon Q Business conversation.
        public let conversationId: String?
        /// The streaming input for the Chat API.
        public let inputStream: AWSEventStream<ChatInputStream>?
        /// The identifier used to associate a user message with a AI generated response.
        public let parentMessageId: String?
        /// The group names that a user associated with the chat input belongs to.
        public let userGroups: [String]?
        /// The identifier of the user attached to the chat input.
        public let userId: String?

        @inlinable
        public init(applicationId: String, clientToken: String? = ChatInput.idempotencyToken(), conversationId: String? = nil, inputStream: AWSEventStream<ChatInputStream>? = nil, parentMessageId: String? = nil, userGroups: [String]? = nil, userId: String? = nil) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.conversationId = conversationId
            self.inputStream = inputStream
            self.parentMessageId = parentMessageId
            self.userGroups = userGroups
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.singleValueContainer()
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.clientToken, key: "clientToken")
            request.encodeQuery(self.conversationId, key: "conversationId")
            try container.encode(self.inputStream)
            request.encodeQuery(self.parentMessageId, key: "parentMessageId")
            request.encodeQuery(self.userGroups, key: "userGroups")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, max: 36)
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, min: 36)
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 2048)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ChatOutput: AWSDecodableShape {
        public static let _options: AWSShapeOptions = [.rawPayload]
        /// The streaming output for the Chat API.
        public let outputStream: AWSEventStream<ChatOutputStream>

        @inlinable
        public init(outputStream: AWSEventStream<ChatOutputStream>) {
            self.outputStream = outputStream
        }

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            self.outputStream = try container.decode(AWSEventStream<ChatOutputStream>.self)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ChatSyncInput: AWSEncodableShape {
        /// A request from an end user to perform an Amazon Q Business plugin action.
        public let actionExecution: ActionExecution?
        /// The identifier of the Amazon Q Business application linked to the Amazon Q Business conversation.
        public let applicationId: String
        /// A list of files uploaded directly during chat. You can upload a maximum of 5 files of upto 10 MB each.
        public let attachments: [AttachmentInput]?
        /// Enables filtering of Amazon Q Business web experience responses based on document attributes or metadata fields.
        public let attributeFilter: AttributeFilter?
        /// An authentication verification event response by a third party authentication server to Amazon Q Business.
        public let authChallengeResponse: AuthChallengeResponse?
        /// The chatMode parameter determines the chat modes available to  Amazon Q Business users:    RETRIEVAL_MODE - If you choose this mode, Amazon Q generates responses solely from the data sources connected and indexed by the application. If an answer is not found in the data sources or there are no data sources available, Amazon Q will respond with a "No Answer Found" message, unless LLM knowledge has been enabled. In that case, Amazon Q will generate a response from the LLM knowledge    CREATOR_MODE - By selecting this mode, you can choose to generate  responses only from the LLM knowledge. You can also attach files and have Amazon Q  generate a response based on the data in those files.  If the attached files do not contain an answer for the query, Amazon Q  will automatically fall back to generating a response from the LLM knowledge.    PLUGIN_MODE - By selecting this mode, users can choose to use plugins in chat to get their responses.    If none of the modes are selected, Amazon Q will only respond using the information from the attached files.  For more information, see Admin controls and guardrails, Plugins, and Response sources.
        public let chatMode: ChatMode?
        /// The chat mode configuration for an Amazon Q Business application.
        public let chatModeConfiguration: ChatModeConfiguration?
        /// A token that you provide to identify a chat request.
        public let clientToken: String?
        /// The identifier of the Amazon Q Business conversation.
        public let conversationId: String?
        /// The identifier of the previous system message in a conversation.
        public let parentMessageId: String?
        /// The group names that a user associated with the chat input belongs to.
        public let userGroups: [String]?
        /// The identifier of the user attached to the chat input.
        public let userId: String?
        /// A end user message in a conversation.
        public let userMessage: String?

        @inlinable
        public init(actionExecution: ActionExecution? = nil, applicationId: String, attachments: [AttachmentInput]? = nil, attributeFilter: AttributeFilter? = nil, authChallengeResponse: AuthChallengeResponse? = nil, chatMode: ChatMode? = nil, chatModeConfiguration: ChatModeConfiguration? = nil, clientToken: String? = ChatSyncInput.idempotencyToken(), conversationId: String? = nil, parentMessageId: String? = nil, userGroups: [String]? = nil, userId: String? = nil, userMessage: String? = nil) {
            self.actionExecution = actionExecution
            self.applicationId = applicationId
            self.attachments = attachments
            self.attributeFilter = attributeFilter
            self.authChallengeResponse = authChallengeResponse
            self.chatMode = chatMode
            self.chatModeConfiguration = chatModeConfiguration
            self.clientToken = clientToken
            self.conversationId = conversationId
            self.parentMessageId = parentMessageId
            self.userGroups = userGroups
            self.userId = userId
            self.userMessage = userMessage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionExecution, forKey: .actionExecution)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.attachments, forKey: .attachments)
            try container.encodeIfPresent(self.attributeFilter, forKey: .attributeFilter)
            try container.encodeIfPresent(self.authChallengeResponse, forKey: .authChallengeResponse)
            try container.encodeIfPresent(self.chatMode, forKey: .chatMode)
            try container.encodeIfPresent(self.chatModeConfiguration, forKey: .chatModeConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.conversationId, forKey: .conversationId)
            try container.encodeIfPresent(self.parentMessageId, forKey: .parentMessageId)
            request.encodeQuery(self.userGroups, key: "userGroups")
            request.encodeQuery(self.userId, key: "userId")
            try container.encodeIfPresent(self.userMessage, forKey: .userMessage)
        }

        public func validate(name: String) throws {
            try self.actionExecution?.validate(name: "\(name).actionExecution")
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.attachments?.forEach {
                try $0.validate(name: "\(name).attachments[]")
            }
            try self.validate(self.attachments, name: "attachments", parent: name, min: 1)
            try self.attributeFilter?.validate(name: "\(name).attributeFilter")
            try self.authChallengeResponse?.validate(name: "\(name).authChallengeResponse")
            try self.chatModeConfiguration?.validate(name: "\(name).chatModeConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, max: 36)
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, min: 36)
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 2048)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionExecution = "actionExecution"
            case attachments = "attachments"
            case attributeFilter = "attributeFilter"
            case authChallengeResponse = "authChallengeResponse"
            case chatMode = "chatMode"
            case chatModeConfiguration = "chatModeConfiguration"
            case clientToken = "clientToken"
            case conversationId = "conversationId"
            case parentMessageId = "parentMessageId"
            case userMessage = "userMessage"
        }
    }

    public struct ChatSyncOutput: AWSDecodableShape {
        /// A request from Amazon Q Business to the end user for information Amazon Q Business needs to successfully complete a requested plugin action.
        public let actionReview: ActionReview?
        /// An authentication verification event activated by an end user request to use a custom plugin.
        public let authChallengeRequest: AuthChallengeRequest?
        /// The identifier of the Amazon Q Business conversation.
        public let conversationId: String?
        /// A list of files which failed to upload during chat.
        public let failedAttachments: [AttachmentOutput]?
        /// The source documents used to generate the conversation response.
        public let sourceAttributions: [SourceAttribution]?
        /// An AI-generated message in a conversation.
        public let systemMessage: String?
        /// The identifier of an Amazon Q Business AI generated message within the conversation.
        public let systemMessageId: String?
        /// The identifier of an Amazon Q Business end user text input message within the conversation.
        public let userMessageId: String?

        @inlinable
        public init(actionReview: ActionReview? = nil, authChallengeRequest: AuthChallengeRequest? = nil, conversationId: String? = nil, failedAttachments: [AttachmentOutput]? = nil, sourceAttributions: [SourceAttribution]? = nil, systemMessage: String? = nil, systemMessageId: String? = nil, userMessageId: String? = nil) {
            self.actionReview = actionReview
            self.authChallengeRequest = authChallengeRequest
            self.conversationId = conversationId
            self.failedAttachments = failedAttachments
            self.sourceAttributions = sourceAttributions
            self.systemMessage = systemMessage
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case actionReview = "actionReview"
            case authChallengeRequest = "authChallengeRequest"
            case conversationId = "conversationId"
            case failedAttachments = "failedAttachments"
            case sourceAttributions = "sourceAttributions"
            case systemMessage = "systemMessage"
            case systemMessageId = "systemMessageId"
            case userMessageId = "userMessageId"
        }
    }

    public struct ConfigurationEvent: AWSEncodableShape {
        public let attributeFilter: AttributeFilter?
        /// The chat modes available to an Amazon Q Business end user.    RETRIEVAL_MODE - The default chat mode for an Amazon Q Business application. When this mode is enabled, Amazon Q Business generates responses only from data sources connected to an Amazon Q Business application.    CREATOR_MODE - By selecting this mode, users can choose to generate responses only from the LLM knowledge, without consulting connected data sources, for a chat request.    PLUGIN_MODE - By selecting this mode, users can choose to use plugins in chat.   For more information, see Admin controls and guardrails, Plugins, and Conversation settings.
        public let chatMode: ChatMode?
        public let chatModeConfiguration: ChatModeConfiguration?

        @inlinable
        public init(attributeFilter: AttributeFilter? = nil, chatMode: ChatMode? = nil, chatModeConfiguration: ChatModeConfiguration? = nil) {
            self.attributeFilter = attributeFilter
            self.chatMode = chatMode
            self.chatModeConfiguration = chatModeConfiguration
        }

        public func validate(name: String) throws {
            try self.attributeFilter?.validate(name: "\(name).attributeFilter")
            try self.chatModeConfiguration?.validate(name: "\(name).chatModeConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "attributeFilter"
            case chatMode = "chatMode"
            case chatModeConfiguration = "chatModeConfiguration"
        }
    }

    public struct ContentBlockerRule: AWSEncodableShape & AWSDecodableShape {
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public let systemMessageOverride: String?

        @inlinable
        public init(systemMessageOverride: String? = nil) {
            self.systemMessageOverride = systemMessageOverride
        }

        public func validate(name: String) throws {
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, max: 350)
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case systemMessageOverride = "systemMessageOverride"
        }
    }

    public struct ContentRetrievalRule: AWSEncodableShape & AWSDecodableShape {
        /// Specifies data sources in a Amazon Q Business application to use for content generation.
        public let eligibleDataSources: [EligibleDataSource]?

        @inlinable
        public init(eligibleDataSources: [EligibleDataSource]? = nil) {
            self.eligibleDataSources = eligibleDataSources
        }

        public func validate(name: String) throws {
            try self.eligibleDataSources?.forEach {
                try $0.validate(name: "\(name).eligibleDataSources[]")
            }
            try self.validate(self.eligibleDataSources, name: "eligibleDataSources", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case eligibleDataSources = "eligibleDataSources"
        }
    }

    public struct Conversation: AWSDecodableShape {
        /// The identifier of the Amazon Q Business conversation.
        public let conversationId: String?
        /// The start time of the conversation.
        public let startTime: Date?
        /// The title of the conversation.
        public let title: String?

        @inlinable
        public init(conversationId: String? = nil, startTime: Date? = nil, title: String? = nil) {
            self.conversationId = conversationId
            self.startTime = startTime
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case startTime = "startTime"
            case title = "title"
        }
    }

    public struct ConversationSource: AWSEncodableShape & AWSDecodableShape {
        /// The unique identifier of the Amazon Q Business attachment.
        public let attachmentId: String
        /// The unique identifier of the Amazon Q Business conversation.
        public let conversationId: String

        @inlinable
        public init(attachmentId: String, conversationId: String) {
            self.attachmentId = attachmentId
            self.conversationId = conversationId
        }

        public func validate(name: String) throws {
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentId = "attachmentId"
            case conversationId = "conversationId"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// An option to allow end users to upload files directly during chat.
        public let attachmentsConfiguration: AttachmentsConfiguration?
        /// The OIDC client ID for a Amazon Q Business application.
        public let clientIdsForOIDC: [String]?
        /// A token that you provide to identify the request to create your Amazon Q Business application.
        public let clientToken: String?
        /// A description for the Amazon Q Business application.
        public let description: String?
        /// A name for the Amazon Q Business application.
        public let displayName: String
        /// The identifier of the KMS key that is used to encrypt your data. Amazon Q Business doesn't support asymmetric keys.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// The Amazon Resource Name (ARN) of an identity provider being used by an Amazon Q Business application.
        public let iamIdentityProviderArn: String?
        ///  The Amazon Resource Name (ARN) of the IAM Identity Center instance you are either creating for—or connecting to—your Amazon Q Business application.
        public let identityCenterInstanceArn: String?
        /// The authentication type being used by a Amazon Q Business application.
        public let identityType: IdentityType?
        /// Configuration information about chat response personalization. For more information, see Personalizing chat responses
        public let personalizationConfiguration: PersonalizationConfiguration?
        /// An option to allow end users to create and use Amazon Q Apps in the web experience.
        public let qAppsConfiguration: QAppsConfiguration?
        /// The Amazon QuickSight configuration for an Amazon Q Business application that uses QuickSight for authentication. This configuration is required if your application uses QuickSight as the identity provider. For more information, see Creating an Amazon QuickSight integrated application.
        public let quickSightConfiguration: QuickSightConfiguration?
        ///  The Amazon Resource Name (ARN) of an IAM role with permissions to access your Amazon CloudWatch logs and metrics. If this property is not specified, Amazon Q Business will create a service linked role (SLR) and use it as the application's role.
        public let roleArn: String?
        /// A list of key-value pairs that identify or categorize your Amazon Q Business application. You can also use tags to help control access to the application. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?

        @inlinable
        public init(attachmentsConfiguration: AttachmentsConfiguration? = nil, clientIdsForOIDC: [String]? = nil, clientToken: String? = CreateApplicationRequest.idempotencyToken(), description: String? = nil, displayName: String, encryptionConfiguration: EncryptionConfiguration? = nil, iamIdentityProviderArn: String? = nil, identityCenterInstanceArn: String? = nil, identityType: IdentityType? = nil, personalizationConfiguration: PersonalizationConfiguration? = nil, qAppsConfiguration: QAppsConfiguration? = nil, quickSightConfiguration: QuickSightConfiguration? = nil, roleArn: String? = nil, tags: [Tag]? = nil) {
            self.attachmentsConfiguration = attachmentsConfiguration
            self.clientIdsForOIDC = clientIdsForOIDC
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.encryptionConfiguration = encryptionConfiguration
            self.iamIdentityProviderArn = iamIdentityProviderArn
            self.identityCenterInstanceArn = identityCenterInstanceArn
            self.identityType = identityType
            self.personalizationConfiguration = personalizationConfiguration
            self.qAppsConfiguration = qAppsConfiguration
            self.quickSightConfiguration = quickSightConfiguration
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.clientIdsForOIDC?.forEach {
                try validate($0, name: "clientIdsForOIDC[]", parent: name, max: 255)
                try validate($0, name: "clientIdsForOIDC[]", parent: name, min: 1)
                try validate($0, name: "clientIdsForOIDC[]", parent: name, pattern: "^[a-zA-Z0-9_.:/()*?=-]*$")
            }
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.iamIdentityProviderArn, name: "iamIdentityProviderArn", parent: name, max: 2048)
            try self.validate(self.iamIdentityProviderArn, name: "iamIdentityProviderArn", parent: name, min: 20)
            try self.validate(self.iamIdentityProviderArn, name: "iamIdentityProviderArn", parent: name, pattern: "^arn:aws:iam::\\d{12}:(oidc-provider|saml-provider)/[a-zA-Z0-9_\\.\\/@\\-]+$")
            try self.validate(self.identityCenterInstanceArn, name: "identityCenterInstanceArn", parent: name, max: 1224)
            try self.validate(self.identityCenterInstanceArn, name: "identityCenterInstanceArn", parent: name, min: 10)
            try self.validate(self.identityCenterInstanceArn, name: "identityCenterInstanceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn|aws-iso|aws-iso-b):sso:::instance/(sso)?ins-[a-zA-Z0-9-.]{16}$")
            try self.quickSightConfiguration?.validate(name: "\(name).quickSightConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsConfiguration = "attachmentsConfiguration"
            case clientIdsForOIDC = "clientIdsForOIDC"
            case clientToken = "clientToken"
            case description = "description"
            case displayName = "displayName"
            case encryptionConfiguration = "encryptionConfiguration"
            case iamIdentityProviderArn = "iamIdentityProviderArn"
            case identityCenterInstanceArn = "identityCenterInstanceArn"
            case identityType = "identityType"
            case personalizationConfiguration = "personalizationConfiguration"
            case qAppsConfiguration = "qAppsConfiguration"
            case quickSightConfiguration = "quickSightConfiguration"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the Amazon Q Business application.
        public let applicationArn: String?
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String?

        @inlinable
        public init(applicationArn: String? = nil, applicationId: String? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationId = "applicationId"
        }
    }

    public struct CreateDataAccessorRequest: AWSEncodableShape {
        /// A list of action configurations specifying the allowed actions and any associated filters.
        public let actionConfigurations: [ActionConfiguration]
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String
        /// A unique, case-sensitive identifier you provide to ensure idempotency of the request.
        public let clientToken: String?
        /// A friendly name for the data accessor.
        public let displayName: String
        /// The Amazon Resource Name (ARN) of the IAM role for the ISV that will be accessing the data.
        public let principal: String
        /// The tags to associate with the data accessor.
        public let tags: [Tag]?

        @inlinable
        public init(actionConfigurations: [ActionConfiguration], applicationId: String, clientToken: String? = CreateDataAccessorRequest.idempotencyToken(), displayName: String, principal: String, tags: [Tag]? = nil) {
            self.actionConfigurations = actionConfigurations
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.displayName = displayName
            self.principal = principal
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actionConfigurations, forKey: .actionConfigurations)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encode(self.principal, forKey: .principal)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.actionConfigurations.forEach {
                try $0.validate(name: "\(name).actionConfigurations[]")
            }
            try self.validate(self.actionConfigurations, name: "actionConfigurations", parent: name, max: 10)
            try self.validate(self.actionConfigurations, name: "actionConfigurations", parent: name, min: 1)
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.principal, name: "principal", parent: name, max: 1284)
            try self.validate(self.principal, name: "principal", parent: name, min: 1)
            try self.validate(self.principal, name: "principal", parent: name, pattern: "^arn:aws:iam::[0-9]{12}:role/[a-zA-Z0-9_/+=,.@-]+$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case actionConfigurations = "actionConfigurations"
            case clientToken = "clientToken"
            case displayName = "displayName"
            case principal = "principal"
            case tags = "tags"
        }
    }

    public struct CreateDataAccessorResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the created data accessor.
        public let dataAccessorArn: String
        /// The unique identifier of the created data accessor.
        public let dataAccessorId: String
        /// The Amazon Resource Name (ARN) of the IAM Identity Center application created for this data accessor.
        public let idcApplicationArn: String

        @inlinable
        public init(dataAccessorArn: String, dataAccessorId: String, idcApplicationArn: String) {
            self.dataAccessorArn = dataAccessorArn
            self.dataAccessorId = dataAccessorId
            self.idcApplicationArn = idcApplicationArn
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessorArn = "dataAccessorArn"
            case dataAccessorId = "dataAccessorId"
            case idcApplicationArn = "idcApplicationArn"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        ///  The identifier of the Amazon Q Business application the data source will be attached to.
        public let applicationId: String
        /// A token you provide to identify a request to create a data source connector. Multiple calls to the CreateDataSource API with the same client token will create only one data source connector.
        public let clientToken: String?
        /// Configuration information to connect your data source repository to Amazon Q Business. Use this parameter to provide a JSON schema with configuration information specific to your data source connector. Each data source has a JSON schema provided by Amazon Q Business that you must use. For example, the Amazon S3 and Web Crawler connectors require the following JSON schemas:    Amazon S3 JSON schema     Web Crawler JSON schema    You can find configuration templates for your specific data source using the following steps:   Navigate to the Supported connectors page in the Amazon Q Business User Guide, and select the data source of your choice.   Then, from your specific data source connector page, select Using the API. You will find the JSON schema for your data source, including parameter descriptions, in this section.
        public let configuration: AWSDocument
        /// A description for the data source connector.
        public let description: String?
        /// A name for the data source connector.
        public let displayName: String
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// The identifier of the index that you want to use with the data source connector.
        public let indexId: String
        /// The configuration for extracting information from media in documents during ingestion.
        public let mediaExtractionConfiguration: MediaExtractionConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
        public let roleArn: String?
        /// Sets the frequency for Amazon Q Business to check the documents in your data source repository and update your index. If you don't set a schedule, Amazon Q Business won't periodically update the index. Specify a cron- format schedule string or an empty string to indicate that the index is updated on demand. You can't specify the Schedule parameter when the Type parameter is set to CUSTOM. If you do, you receive a ValidationException exception.
        public let syncSchedule: String?
        /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source. For more information, see Using Amazon VPC with Amazon Q Business connectors.
        public let vpcConfiguration: DataSourceVpcConfiguration?

        @inlinable
        public init(applicationId: String, clientToken: String? = CreateDataSourceRequest.idempotencyToken(), configuration: AWSDocument, description: String? = nil, displayName: String, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, indexId: String, mediaExtractionConfiguration: MediaExtractionConfiguration? = nil, roleArn: String? = nil, syncSchedule: String? = nil, tags: [Tag]? = nil, vpcConfiguration: DataSourceVpcConfiguration? = nil) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.displayName = displayName
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.indexId = indexId
            self.mediaExtractionConfiguration = mediaExtractionConfiguration
            self.roleArn = roleArn
            self.syncSchedule = syncSchedule
            self.tags = tags
            self.vpcConfiguration = vpcConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.documentEnrichmentConfiguration, forKey: .documentEnrichmentConfiguration)
            request.encodePath(self.indexId, key: "indexId")
            try container.encodeIfPresent(self.mediaExtractionConfiguration, forKey: .mediaExtractionConfiguration)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.syncSchedule, forKey: .syncSchedule)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.vpcConfiguration, forKey: .vpcConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.documentEnrichmentConfiguration?.validate(name: "\(name).documentEnrichmentConfiguration")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, max: 998)
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case displayName = "displayName"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case mediaExtractionConfiguration = "mediaExtractionConfiguration"
            case roleArn = "roleArn"
            case syncSchedule = "syncSchedule"
            case tags = "tags"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of a data source in an Amazon Q Business application.
        public let dataSourceArn: String?
        /// The identifier of the data source connector.
        public let dataSourceId: String?

        @inlinable
        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "dataSourceArn"
            case dataSourceId = "dataSourceId"
        }
    }

    public struct CreateIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application using the index.
        public let applicationId: String
        /// The capacity units you want to provision for your index. You can add and remove capacity to fit your usage needs.
        public let capacityConfiguration: IndexCapacityConfiguration?
        /// A token that you provide to identify the request to create an index. Multiple calls to the CreateIndex API with the same client token will create only one index.
        public let clientToken: String?
        /// A description for the Amazon Q Business index.
        public let description: String?
        /// A name for the Amazon Q Business index.
        public let displayName: String
        /// A list of key-value pairs that identify or categorize the index. You can also use tags to help control access to the index. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// The index type that's suitable for your needs. For more information on what's included in each type of index, see Amazon Q Business tiers.
        public let type: IndexType?

        @inlinable
        public init(applicationId: String, capacityConfiguration: IndexCapacityConfiguration? = nil, clientToken: String? = CreateIndexRequest.idempotencyToken(), description: String? = nil, displayName: String, tags: [Tag]? = nil, type: IndexType? = nil) {
            self.applicationId = applicationId
            self.capacityConfiguration = capacityConfiguration
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.capacityConfiguration, forKey: .capacityConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.capacityConfiguration?.validate(name: "\(name).capacityConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case capacityConfiguration = "capacityConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case displayName = "displayName"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateIndexResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Q Business index.
        public let indexArn: String?
        /// The identifier for the Amazon Q Business index.
        public let indexId: String?

        @inlinable
        public init(indexArn: String? = nil, indexId: String? = nil) {
            self.indexArn = indexArn
            self.indexId = indexId
        }

        private enum CodingKeys: String, CodingKey {
            case indexArn = "indexArn"
            case indexId = "indexId"
        }
    }

    public struct CreatePluginRequest: AWSEncodableShape {
        /// The identifier of the application that will contain the plugin.
        public let applicationId: String
        public let authConfiguration: PluginAuthConfiguration
        /// A token that you provide to identify the request to create your Amazon Q Business plugin.
        public let clientToken: String?
        /// Contains configuration for a custom plugin.
        public let customPluginConfiguration: CustomPluginConfiguration?
        /// A the name for your plugin.
        public let displayName: String
        /// The source URL used for plugin configuration.
        public let serverUrl: String?
        /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// The type of plugin you want to create.
        public let type: PluginType

        @inlinable
        public init(applicationId: String, authConfiguration: PluginAuthConfiguration, clientToken: String? = CreatePluginRequest.idempotencyToken(), customPluginConfiguration: CustomPluginConfiguration? = nil, displayName: String, serverUrl: String? = nil, tags: [Tag]? = nil, type: PluginType) {
            self.applicationId = applicationId
            self.authConfiguration = authConfiguration
            self.clientToken = clientToken
            self.customPluginConfiguration = customPluginConfiguration
            self.displayName = displayName
            self.serverUrl = serverUrl
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encode(self.authConfiguration, forKey: .authConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.customPluginConfiguration, forKey: .customPluginConfiguration)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.serverUrl, forKey: .serverUrl)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.authConfiguration.validate(name: "\(name).authConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.customPluginConfiguration?.validate(name: "\(name).customPluginConfiguration")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, max: 2048)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, min: 1)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, pattern: "^(https?|ftp|file)://([^\\s]*)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case authConfiguration = "authConfiguration"
            case clientToken = "clientToken"
            case customPluginConfiguration = "customPluginConfiguration"
            case displayName = "displayName"
            case serverUrl = "serverUrl"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreatePluginResponse: AWSDecodableShape {
        /// The current status of a plugin. A plugin is modified asynchronously.
        public let buildStatus: PluginBuildStatus?
        /// The Amazon Resource Name (ARN) of a plugin.
        public let pluginArn: String?
        /// The identifier of the plugin created.
        public let pluginId: String?

        @inlinable
        public init(buildStatus: PluginBuildStatus? = nil, pluginArn: String? = nil, pluginId: String? = nil) {
            self.buildStatus = buildStatus
            self.pluginArn = pluginArn
            self.pluginId = pluginId
        }

        private enum CodingKeys: String, CodingKey {
            case buildStatus = "buildStatus"
            case pluginArn = "pluginArn"
            case pluginId = "pluginId"
        }
    }

    public struct CreateRetrieverRequest: AWSEncodableShape {
        /// The identifier of your Amazon Q Business application.
        public let applicationId: String
        /// A token that you provide to identify the request to create your Amazon Q Business application retriever.
        public let clientToken: String?
        public let configuration: RetrieverConfiguration
        /// The name of your retriever.
        public let displayName: String
        /// The ARN of an IAM role used by Amazon Q Business to access the basic authentication credentials stored in a Secrets Manager secret.
        public let roleArn: String?
        /// A list of key-value pairs that identify or categorize the retriever. You can also use tags to help control access to the retriever. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// The type of retriever you are using.
        public let type: RetrieverType

        @inlinable
        public init(applicationId: String, clientToken: String? = CreateRetrieverRequest.idempotencyToken(), configuration: RetrieverConfiguration, displayName: String, roleArn: String? = nil, tags: [Tag]? = nil, type: RetrieverType) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.configuration = configuration
            self.displayName = displayName
            self.roleArn = roleArn
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case displayName = "displayName"
            case roleArn = "roleArn"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateRetrieverResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an IAM role associated with a retriever.
        public let retrieverArn: String?
        /// The identifier of the retriever you are using.
        public let retrieverId: String?

        @inlinable
        public init(retrieverArn: String? = nil, retrieverId: String? = nil) {
            self.retrieverArn = retrieverArn
            self.retrieverId = retrieverId
        }

        private enum CodingKeys: String, CodingKey {
            case retrieverArn = "retrieverArn"
            case retrieverId = "retrieverId"
        }
    }

    public struct CreateSubscriptionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application the subscription should be added to.
        public let applicationId: String
        /// A token that you provide to identify the request to create a subscription for your Amazon Q Business application.
        public let clientToken: String?
        /// The IAM Identity Center UserId or GroupId of a user or group in the IAM Identity Center instance connected to the Amazon Q Business application.
        public let principal: SubscriptionPrincipal
        /// The type of Amazon Q Business subscription you want to create.
        public let type: SubscriptionType

        @inlinable
        public init(applicationId: String, clientToken: String? = CreateSubscriptionRequest.idempotencyToken(), principal: SubscriptionPrincipal, type: SubscriptionType) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.principal = principal
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.principal, forKey: .principal)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.principal.validate(name: "\(name).principal")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case principal = "principal"
            case type = "type"
        }
    }

    public struct CreateSubscriptionResponse: AWSDecodableShape {
        /// The type of your current Amazon Q Business subscription.
        public let currentSubscription: SubscriptionDetails?
        /// The type of the Amazon Q Business subscription for the next month.
        public let nextSubscription: SubscriptionDetails?
        /// The Amazon Resource Name (ARN) of the Amazon Q Business subscription created.
        public let subscriptionArn: String?
        /// The identifier of the Amazon Q Business subscription created.
        public let subscriptionId: String?

        @inlinable
        public init(currentSubscription: SubscriptionDetails? = nil, nextSubscription: SubscriptionDetails? = nil, subscriptionArn: String? = nil, subscriptionId: String? = nil) {
            self.currentSubscription = currentSubscription
            self.nextSubscription = nextSubscription
            self.subscriptionArn = subscriptionArn
            self.subscriptionId = subscriptionId
        }

        private enum CodingKeys: String, CodingKey {
            case currentSubscription = "currentSubscription"
            case nextSubscription = "nextSubscription"
            case subscriptionArn = "subscriptionArn"
            case subscriptionId = "subscriptionId"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// The identifier of the application for which the user mapping will be created.
        public let applicationId: String
        /// A token that you provide to identify the request to create your Amazon Q Business user mapping.
        public let clientToken: String?
        /// The list of user aliases in the mapping.
        public let userAliases: [UserAlias]?
        /// The user emails attached to a user mapping.
        public let userId: String

        @inlinable
        public init(applicationId: String, clientToken: String? = CreateUserRequest.idempotencyToken(), userAliases: [UserAlias]? = nil, userId: String) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.userAliases = userAliases
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.userAliases, forKey: .userAliases)
            try container.encode(self.userId, forKey: .userId)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.userAliases?.forEach {
                try $0.validate(name: "\(name).userAliases[]")
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case userAliases = "userAliases"
            case userId = "userId"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business web experience.
        public let applicationId: String
        /// The browser extension configuration for an Amazon Q Business web experience.   For Amazon Q Business application using external OIDC-compliant identity providers (IdPs). The IdP administrator must add the browser extension sign-in redirect URLs to the IdP application. For more information, see Configure external OIDC identity provider for your browser extensions..
        public let browserExtensionConfiguration: BrowserExtensionConfiguration?
        /// A token you provide to identify a request to create an Amazon Q Business web experience.
        public let clientToken: String?
        /// Sets the custom logo, favicon, font, and color used in the Amazon Q web experience.
        public let customizationConfiguration: CustomizationConfiguration?
        /// Information about the identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
        public let identityProviderConfiguration: IdentityProviderConfiguration?
        /// Sets the website domain origins that  are allowed to embed the Amazon Q Business web experience.  The domain origin refers to the  base URL for accessing a website including the protocol  (http/https), the domain name, and the port number (if specified).   You must only submit a base URL and  not a full path. For example, https://docs.aws.amazon.com.
        public let origins: [String]?
        /// The Amazon Resource Name (ARN) of the service role attached to your web experience.  You must provide this value if you're using IAM Identity Center to manage end user access to your application. If you're using legacy identity management to manage user access, you don't need to provide this value.
        public let roleArn: String?
        /// Determines whether sample prompts are enabled in the web experience for an end user.
        public let samplePromptsControlMode: WebExperienceSamplePromptsControlMode?
        /// A subtitle to personalize your Amazon Q Business web experience.
        public let subtitle: String?
        /// A list of key-value pairs that identify or categorize your Amazon Q Business web experience. You can also use tags to help control access to the web experience. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// The title for your Amazon Q Business web experience.
        public let title: String?
        /// The customized welcome message for end users of an Amazon Q Business web experience.
        public let welcomeMessage: String?

        @inlinable
        public init(applicationId: String, browserExtensionConfiguration: BrowserExtensionConfiguration? = nil, clientToken: String? = CreateWebExperienceRequest.idempotencyToken(), customizationConfiguration: CustomizationConfiguration? = nil, identityProviderConfiguration: IdentityProviderConfiguration? = nil, origins: [String]? = nil, roleArn: String? = nil, samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, subtitle: String? = nil, tags: [Tag]? = nil, title: String? = nil, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.browserExtensionConfiguration = browserExtensionConfiguration
            self.clientToken = clientToken
            self.customizationConfiguration = customizationConfiguration
            self.identityProviderConfiguration = identityProviderConfiguration
            self.origins = origins
            self.roleArn = roleArn
            self.samplePromptsControlMode = samplePromptsControlMode
            self.subtitle = subtitle
            self.tags = tags
            self.title = title
            self.welcomeMessage = welcomeMessage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.browserExtensionConfiguration, forKey: .browserExtensionConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.customizationConfiguration, forKey: .customizationConfiguration)
            try container.encodeIfPresent(self.identityProviderConfiguration, forKey: .identityProviderConfiguration)
            try container.encodeIfPresent(self.origins, forKey: .origins)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.samplePromptsControlMode, forKey: .samplePromptsControlMode)
            try container.encodeIfPresent(self.subtitle, forKey: .subtitle)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encodeIfPresent(self.welcomeMessage, forKey: .welcomeMessage)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.browserExtensionConfiguration?.validate(name: "\(name).browserExtensionConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.customizationConfiguration?.validate(name: "\(name).customizationConfiguration")
            try self.identityProviderConfiguration?.validate(name: "\(name).identityProviderConfiguration")
            try self.origins?.forEach {
                try validate($0, name: "origins[]", parent: name, max: 256)
                try validate($0, name: "origins[]", parent: name, min: 1)
                try validate($0, name: "origins[]", parent: name, pattern: "^(http://|https://)[a-zA-Z0-9-_.]+(?::[0-9]{1,5})?$")
            }
            try self.validate(self.origins, name: "origins", parent: name, max: 10)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subtitle, name: "subtitle", parent: name, max: 500)
            try self.validate(self.subtitle, name: "subtitle", parent: name, pattern: "^[\\s\\S]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.title, name: "title", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.welcomeMessage, name: "welcomeMessage", parent: name, max: 300)
        }

        private enum CodingKeys: String, CodingKey {
            case browserExtensionConfiguration = "browserExtensionConfiguration"
            case clientToken = "clientToken"
            case customizationConfiguration = "customizationConfiguration"
            case identityProviderConfiguration = "identityProviderConfiguration"
            case origins = "origins"
            case roleArn = "roleArn"
            case samplePromptsControlMode = "samplePromptsControlMode"
            case subtitle = "subtitle"
            case tags = "tags"
            case title = "title"
            case welcomeMessage = "welcomeMessage"
        }
    }

    public struct CreateWebExperienceResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Q Business web experience.
        public let webExperienceArn: String?
        /// The identifier of the Amazon Q Business web experience.
        public let webExperienceId: String?

        @inlinable
        public init(webExperienceArn: String? = nil, webExperienceId: String? = nil) {
            self.webExperienceArn = webExperienceArn
            self.webExperienceId = webExperienceId
        }

        private enum CodingKeys: String, CodingKey {
            case webExperienceArn = "webExperienceArn"
            case webExperienceId = "webExperienceId"
        }
    }

    public struct CreatorModeConfiguration: AWSEncodableShape {
        /// Status information about whether CREATOR_MODE has been enabled or disabled. The default status is DISABLED.
        public let creatorModeControl: CreatorModeControl

        @inlinable
        public init(creatorModeControl: CreatorModeControl) {
            self.creatorModeControl = creatorModeControl
        }

        private enum CodingKeys: String, CodingKey {
            case creatorModeControl = "creatorModeControl"
        }
    }

    public struct CustomPluginConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema.
        public let apiSchema: APISchema
        /// The type of OpenAPI schema to use.
        public let apiSchemaType: APISchemaType
        /// A description for your custom plugin configuration.
        public let description: String

        @inlinable
        public init(apiSchema: APISchema, apiSchemaType: APISchemaType, description: String) {
            self.apiSchema = apiSchema
            self.apiSchemaType = apiSchemaType
            self.description = description
        }

        public func validate(name: String) throws {
            try self.apiSchema.validate(name: "\(name).apiSchema")
            try self.validate(self.description, name: "description", parent: name, max: 200)
            try self.validate(self.description, name: "description", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case apiSchema = "apiSchema"
            case apiSchemaType = "apiSchemaType"
            case description = "description"
        }
    }

    public struct CustomizationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Provides the URL where the custom CSS file is hosted for an Amazon Q web experience.
        public let customCSSUrl: String?
        /// Provides the URL where the custom favicon file is hosted for an Amazon Q web experience.
        public let faviconUrl: String?
        /// Provides the URL where the custom font file is hosted for an Amazon Q web experience.
        public let fontUrl: String?
        /// Provides the URL where the custom logo file is hosted for an Amazon Q web experience.
        public let logoUrl: String?

        @inlinable
        public init(customCSSUrl: String? = nil, faviconUrl: String? = nil, fontUrl: String? = nil, logoUrl: String? = nil) {
            self.customCSSUrl = customCSSUrl
            self.faviconUrl = faviconUrl
            self.fontUrl = fontUrl
            self.logoUrl = logoUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.customCSSUrl, name: "customCSSUrl", parent: name, max: 1284)
            try self.validate(self.customCSSUrl, name: "customCSSUrl", parent: name, pattern: "^(https?://[a-zA-Z0-9-_.+%/]+\\.css)?$")
            try self.validate(self.faviconUrl, name: "faviconUrl", parent: name, max: 1284)
            try self.validate(self.faviconUrl, name: "faviconUrl", parent: name, pattern: "^(https?://[a-zA-Z0-9-_.+%/]+\\.(svg|ico))?$")
            try self.validate(self.fontUrl, name: "fontUrl", parent: name, max: 1284)
            try self.validate(self.fontUrl, name: "fontUrl", parent: name, pattern: "^(https?://[a-zA-Z0-9-_.+%/]+\\.(ttf|woff|woff2|otf))?$")
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, max: 1284)
            try self.validate(self.logoUrl, name: "logoUrl", parent: name, pattern: "^(https?://[a-zA-Z0-9-_.+%/]+\\.(svg|png))?$")
        }

        private enum CodingKeys: String, CodingKey {
            case customCSSUrl = "customCSSUrl"
            case faviconUrl = "faviconUrl"
            case fontUrl = "fontUrl"
            case logoUrl = "logoUrl"
        }
    }

    public struct DataAccessor: AWSDecodableShape {
        /// The timestamp when the data accessor was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the data accessor.
        public let dataAccessorArn: String?
        /// The unique identifier of the data accessor.
        public let dataAccessorId: String?
        /// The friendly name of the data accessor.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the associated IAM Identity Center application.
        public let idcApplicationArn: String?
        /// The Amazon Resource Name (ARN) of the IAM role for the ISV associated with this data accessor.
        public let principal: String?
        /// The timestamp when the data accessor was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, dataAccessorArn: String? = nil, dataAccessorId: String? = nil, displayName: String? = nil, idcApplicationArn: String? = nil, principal: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.dataAccessorArn = dataAccessorArn
            self.dataAccessorId = dataAccessorId
            self.displayName = displayName
            self.idcApplicationArn = idcApplicationArn
            self.principal = principal
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataAccessorArn = "dataAccessorArn"
            case dataAccessorId = "dataAccessorId"
            case displayName = "displayName"
            case idcApplicationArn = "idcApplicationArn"
            case principal = "principal"
            case updatedAt = "updatedAt"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The Unix timestamp when the Amazon Q Business data source was created.
        public let createdAt: Date?
        /// The identifier of the Amazon Q Business data source.
        public let dataSourceId: String?
        /// The name of the Amazon Q Business data source.
        public let displayName: String?
        /// The status of the Amazon Q Business data source.
        public let status: DataSourceStatus?
        /// The type of the Amazon Q Business data source.
        public let type: String?
        /// The Unix timestamp when the Amazon Q Business data source was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, dataSourceId: String? = nil, displayName: String? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.displayName = displayName
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceId = "dataSourceId"
            case displayName = "displayName"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DataSourceSyncJob: AWSDecodableShape {
        /// If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.
        public let dataSourceErrorCode: String?
        /// The Unix timestamp when the synchronization job completed.
        public let endTime: Date?
        /// If the Status field is set to FAILED, the ErrorCode field indicates the reason the synchronization failed.
        public let error: ErrorDetail?
        /// The identifier of a data source synchronization job.
        public let executionId: String?
        /// Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.
        public let metrics: DataSourceSyncJobMetrics?
        /// The Unix time stamp when the data source synchronization job started.
        public let startTime: Date?
        /// The status of the synchronization job. When the Status field is set to SUCCEEDED, the synchronization job is done. If the status code is FAILED, the ErrorCode and ErrorMessage fields give you the reason for the failure.
        public let status: DataSourceSyncJobStatus?

        @inlinable
        public init(dataSourceErrorCode: String? = nil, endTime: Date? = nil, error: ErrorDetail? = nil, executionId: String? = nil, metrics: DataSourceSyncJobMetrics? = nil, startTime: Date? = nil, status: DataSourceSyncJobStatus? = nil) {
            self.dataSourceErrorCode = dataSourceErrorCode
            self.endTime = endTime
            self.error = error
            self.executionId = executionId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceErrorCode = "dataSourceErrorCode"
            case endTime = "endTime"
            case error = "error"
            case executionId = "executionId"
            case metrics = "metrics"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct DataSourceSyncJobMetrics: AWSDecodableShape {
        /// The current count of documents added from the data source during the data source sync.
        public let documentsAdded: String?
        /// The current count of documents deleted from the data source during the data source sync.
        public let documentsDeleted: String?
        /// The current count of documents that failed to sync from the data source during the data source sync.
        public let documentsFailed: String?
        /// The current count of documents modified in the data source during the data source sync.
        public let documentsModified: String?
        /// The current count of documents crawled by the ongoing sync job in the data source.
        public let documentsScanned: String?

        @inlinable
        public init(documentsAdded: String? = nil, documentsDeleted: String? = nil, documentsFailed: String? = nil, documentsModified: String? = nil, documentsScanned: String? = nil) {
            self.documentsAdded = documentsAdded
            self.documentsDeleted = documentsDeleted
            self.documentsFailed = documentsFailed
            self.documentsModified = documentsModified
            self.documentsScanned = documentsScanned
        }

        private enum CodingKeys: String, CodingKey {
            case documentsAdded = "documentsAdded"
            case documentsDeleted = "documentsDeleted"
            case documentsFailed = "documentsFailed"
            case documentsModified = "documentsModified"
            case documentsScanned = "documentsScanned"
        }
    }

    public struct DataSourceVpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Q Business to connect to the data source.
        public let securityGroupIds: [String]
        /// A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        public let subnetIds: [String]

        @inlinable
        public init(securityGroupIds: [String], subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 10)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 200)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct DateAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the duration, in seconds, of a boost applies to a DATE type document attribute.
        public let boostingDurationInSeconds: Int64?
        /// Specifies how much a document attribute is boosted.
        public let boostingLevel: DocumentAttributeBoostingLevel

        @inlinable
        public init(boostingDurationInSeconds: Int64? = nil, boostingLevel: DocumentAttributeBoostingLevel) {
            self.boostingDurationInSeconds = boostingDurationInSeconds
            self.boostingLevel = boostingLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.boostingDurationInSeconds, name: "boostingDurationInSeconds", parent: name, max: 999999999)
            try self.validate(self.boostingDurationInSeconds, name: "boostingDurationInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case boostingDurationInSeconds = "boostingDurationInSeconds"
            case boostingLevel = "boostingLevel"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String

        @inlinable
        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteAttachmentRequest: AWSEncodableShape {
        /// The unique identifier for the Amazon Q Business application environment.
        public let applicationId: String
        /// The unique identifier for the attachment.
        public let attachmentId: String
        /// The unique identifier of the conversation.
        public let conversationId: String
        /// The unique identifier of the user involved in the conversation.
        public let userId: String?

        @inlinable
        public init(applicationId: String, attachmentId: String, conversationId: String, userId: String? = nil) {
            self.applicationId = applicationId
            self.attachmentId = attachmentId
            self.conversationId = conversationId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.attachmentId, key: "attachmentId")
            request.encodePath(self.conversationId, key: "conversationId")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.attachmentId, name: "attachmentId", parent: name, pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteAttachmentResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteChatControlsConfigurationRequest: AWSEncodableShape {
        /// The identifier of the application the chat controls have been configured for.
        public let applicationId: String

        @inlinable
        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChatControlsConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConversationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application associated with the conversation.
        public let applicationId: String
        /// The identifier of the Amazon Q Business web experience conversation being deleted.
        public let conversationId: String
        /// The identifier of the user who is deleting the conversation.
        public let userId: String?

        @inlinable
        public init(applicationId: String, conversationId: String, userId: String? = nil) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.conversationId, key: "conversationId")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConversationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataAccessorRequest: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The unique identifier of the data accessor to delete.
        public let dataAccessorId: String

        @inlinable
        public init(applicationId: String, dataAccessorId: String) {
            self.applicationId = applicationId
            self.dataAccessorId = dataAccessorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataAccessorId, key: "dataAccessorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, max: 36)
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, min: 36)
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataAccessorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application used with the data source connector.
        public let applicationId: String
        /// The identifier of the data source connector that you want to delete.
        public let dataSourceId: String
        /// The identifier of the index used with the data source connector.
        public let indexId: String

        @inlinable
        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDocument: AWSEncodableShape {
        /// The identifier of the deleted document.
        public let documentId: String

        @inlinable
        public init(documentId: String) {
            self.documentId = documentId
        }

        public func validate(name: String) throws {
            try self.validate(self.documentId, name: "documentId", parent: name, max: 1825)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentId = "documentId"
        }
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        /// The identifier of the application in which the group mapping belongs.
        public let applicationId: String
        /// The identifier of the data source linked to the group A group can be tied to multiple data sources. You can delete a group from accessing documents in a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. You want to delete "Research" and "Engineering" groups from Salesforce, so that these groups cannot access customer-related documents stored in Salesforce. Only "Sales and Marketing" should access documents in the Salesforce data source.
        public let dataSourceId: String?
        /// The name of the group you want to delete.
        public let groupName: String
        /// The identifier of the index you want to delete the group from.
        public let indexId: String

        @inlinable
        public init(applicationId: String, dataSourceId: String? = nil, groupName: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.groupName = groupName
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.groupName, key: "groupName")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application the Amazon Q Business index is linked to.
        public let applicationId: String
        /// The identifier of the Amazon Q Business index.
        public let indexId: String

        @inlinable
        public init(applicationId: String, indexId: String) {
            self.applicationId = applicationId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePluginRequest: AWSEncodableShape {
        /// The identifier the application attached to the Amazon Q Business plugin.
        public let applicationId: String
        /// The identifier of the plugin being deleted.
        public let pluginId: String

        @inlinable
        public init(applicationId: String, pluginId: String) {
            self.applicationId = applicationId
            self.pluginId = pluginId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.pluginId, key: "pluginId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePluginResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRetrieverRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application using the retriever.
        public let applicationId: String
        /// The identifier of the retriever being deleted.
        public let retrieverId: String

        @inlinable
        public init(applicationId: String, retrieverId: String) {
            self.applicationId = applicationId
            self.retrieverId = retrieverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.retrieverId, key: "retrieverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, max: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, min: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRetrieverResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// The identifier of the application from which the user is being deleted.
        public let applicationId: String
        /// The user email being deleted.
        public let userId: String

        @inlinable
        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application linked to the Amazon Q Business web experience.
        public let applicationId: String
        /// The identifier of the Amazon Q Business web experience being deleted.
        public let webExperienceId: String

        @inlinable
        public init(applicationId: String, webExperienceId: String) {
            self.applicationId = applicationId
            self.webExperienceId = webExperienceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.webExperienceId, key: "webExperienceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, max: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, min: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWebExperienceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DisassociatePermissionRequest: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The statement ID of the permission to remove.
        public let statementId: String

        @inlinable
        public init(applicationId: String, statementId: String) {
            self.applicationId = applicationId
            self.statementId = statementId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.statementId, key: "statementId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.statementId, name: "statementId", parent: name, max: 2048)
            try self.validate(self.statementId, name: "statementId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociatePermissionResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Document: AWSEncodableShape {
        /// Configuration information for access permission to a document.
        public let accessConfiguration: AccessConfiguration?
        /// Custom attributes to apply to the document for refining Amazon Q Business web experience responses.
        public let attributes: [DocumentAttribute]?
        /// The contents of the document.
        public let content: DocumentContent?
        /// The file type of the document in the Blob field. If you want to index snippets or subsets of HTML documents instead of the entirety of the HTML documents, you add the HTML start and closing tags (&lt;HTML&gt;content&lt;/HTML&gt;) around the content.
        public let contentType: ContentType?
        /// The configuration information for altering document metadata and content during the document ingestion process.
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// The identifier of the document.
        public let id: String
        /// The configuration for extracting information from media in the document.
        public let mediaExtractionConfiguration: MediaExtractionConfiguration?
        /// The title of the document.
        public let title: String?

        @inlinable
        public init(accessConfiguration: AccessConfiguration? = nil, attributes: [DocumentAttribute]? = nil, content: DocumentContent? = nil, contentType: ContentType? = nil, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, id: String, mediaExtractionConfiguration: MediaExtractionConfiguration? = nil, title: String? = nil) {
            self.accessConfiguration = accessConfiguration
            self.attributes = attributes
            self.content = content
            self.contentType = contentType
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.id = id
            self.mediaExtractionConfiguration = mediaExtractionConfiguration
            self.title = title
        }

        public func validate(name: String) throws {
            try self.accessConfiguration?.validate(name: "\(name).accessConfiguration")
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 500)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 1)
            try self.content?.validate(name: "\(name).content")
            try self.documentEnrichmentConfiguration?.validate(name: "\(name).documentEnrichmentConfiguration")
            try self.validate(self.id, name: "id", parent: name, max: 1825)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.title, name: "title", parent: name, max: 1024)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "accessConfiguration"
            case attributes = "attributes"
            case content = "content"
            case contentType = "contentType"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case id = "id"
            case mediaExtractionConfiguration = "mediaExtractionConfiguration"
            case title = "title"
        }
    }

    public struct DocumentAttribute: AWSEncodableShape & AWSDecodableShape {
        /// The identifier for the attribute.
        public let name: String
        /// The value of the attribute.
        public let value: DocumentAttributeValue

        @inlinable
        public init(name: String, value: DocumentAttributeValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct DocumentAttributeCondition: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Q Business currently doesn't support _document_body as an attribute key used for the condition.
        public let key: String
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Q Business currently does not support _document_body as an attribute key used for the condition.
        public let `operator`: DocumentEnrichmentConditionOperator
        public let value: DocumentAttributeValue?

        @inlinable
        public init(key: String, operator: DocumentEnrichmentConditionOperator, value: DocumentAttributeValue? = nil) {
            self.key = key
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 200)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct DocumentAttributeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the document attribute.
        public let name: String?
        /// Information about whether the document attribute can be used by an end user to search for information on their web experience.
        public let search: Status?
        /// The type of document attribute.
        public let type: AttributeType?

        @inlinable
        public init(name: String? = nil, search: Status? = nil, type: AttributeType? = nil) {
            self.name = name
            self.search = search
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 30)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case search = "search"
            case type = "type"
        }
    }

    public struct DocumentAttributeTarget: AWSEncodableShape & AWSDecodableShape {
        ///  TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE.
        public let attributeValueOperator: AttributeValueOperator?
        /// The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
        public let key: String
        public let value: DocumentAttributeValue?

        @inlinable
        public init(attributeValueOperator: AttributeValueOperator? = nil, key: String, value: DocumentAttributeValue? = nil) {
            self.attributeValueOperator = attributeValueOperator
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 200)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeValueOperator = "attributeValueOperator"
            case key = "key"
            case value = "value"
        }
    }

    public struct DocumentDetails: AWSDecodableShape {
        /// The timestamp for when the document was created.
        public let createdAt: Date?
        /// The identifier of the document.
        public let documentId: String?
        /// An error message associated with the document.
        public let error: ErrorDetail?
        /// The current status of the document.
        public let status: DocumentStatus?
        /// The timestamp for when the document was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, documentId: String? = nil, error: ErrorDetail? = nil, status: DocumentStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.documentId = documentId
            self.error = error
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case documentId = "documentId"
            case error = "error"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DocumentEnrichmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Q Business.
        public let inlineConfigurations: [InlineDocumentEnrichmentConfiguration]?
        public let postExtractionHookConfiguration: HookConfiguration?
        public let preExtractionHookConfiguration: HookConfiguration?

        @inlinable
        public init(inlineConfigurations: [InlineDocumentEnrichmentConfiguration]? = nil, postExtractionHookConfiguration: HookConfiguration? = nil, preExtractionHookConfiguration: HookConfiguration? = nil) {
            self.inlineConfigurations = inlineConfigurations
            self.postExtractionHookConfiguration = postExtractionHookConfiguration
            self.preExtractionHookConfiguration = preExtractionHookConfiguration
        }

        public func validate(name: String) throws {
            try self.inlineConfigurations?.forEach {
                try $0.validate(name: "\(name).inlineConfigurations[]")
            }
            try self.validate(self.inlineConfigurations, name: "inlineConfigurations", parent: name, max: 100)
            try self.validate(self.inlineConfigurations, name: "inlineConfigurations", parent: name, min: 1)
            try self.postExtractionHookConfiguration?.validate(name: "\(name).postExtractionHookConfiguration")
            try self.preExtractionHookConfiguration?.validate(name: "\(name).preExtractionHookConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case inlineConfigurations = "inlineConfigurations"
            case postExtractionHookConfiguration = "postExtractionHookConfiguration"
            case preExtractionHookConfiguration = "preExtractionHookConfiguration"
        }
    }

    public struct EligibleDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the data source.
        public let dataSourceId: String?
        /// The identifier of the index the data source is attached to.
        public let indexId: String?

        @inlinable
        public init(dataSourceId: String? = nil, indexId: String? = nil) {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case indexId = "indexId"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the KMS key. Amazon Q Business doesn't support asymmetric keys.
        public let kmsKeyId: String?

        @inlinable
        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct EndOfInputEvent: AWSEncodableShape {
        public init() {}
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// The code associated with the Amazon Q Business request error.
        public let errorCode: ErrorCode?
        /// The message explaining the Amazon Q Business request error.
        public let errorMessage: String?

        @inlinable
        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct FailedAttachmentEvent: AWSDecodableShape {
        public let attachment: AttachmentOutput?
        ///  The identifier of the conversation associated with the failed file upload.
        public let conversationId: String?
        /// The identifier of the AI-generated message associated with the file upload.
        public let systemMessageId: String?
        /// The identifier of the end user chat message associated with the file upload.
        public let userMessageId: String?

        @inlinable
        public init(attachment: AttachmentOutput? = nil, conversationId: String? = nil, systemMessageId: String? = nil, userMessageId: String? = nil) {
            self.attachment = attachment
            self.conversationId = conversationId
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case attachment = "attachment"
            case conversationId = "conversationId"
            case systemMessageId = "systemMessageId"
            case userMessageId = "userMessageId"
        }
    }

    public struct FailedDocument: AWSDecodableShape {
        /// The identifier of the Amazon Q Business data source connector that contains the failed document.
        public let dataSourceId: String?
        /// An explanation for why the document couldn't be removed from the index.
        public let error: ErrorDetail?
        /// The identifier of the document that couldn't be removed from the Amazon Q Business index.
        public let id: String?

        @inlinable
        public init(dataSourceId: String? = nil, error: ErrorDetail? = nil, id: String? = nil) {
            self.dataSourceId = dataSourceId
            self.error = error
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case error = "error"
            case id = "id"
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String

        @inlinable
        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q Business application.
        public let applicationArn: String?
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String?
        /// Settings for whether end users can upload files directly during chat.
        public let attachmentsConfiguration: AppliedAttachmentsConfiguration?
        /// Settings for auto-subscription behavior for this application. This is only applicable to SAML and OIDC applications.
        public let autoSubscriptionConfiguration: AutoSubscriptionConfiguration?
        /// The OIDC client ID for a Amazon Q Business application.
        public let clientIdsForOIDC: [String]?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public let createdAt: Date?
        /// A description for the Amazon Q Business application.
        public let description: String?
        /// The name of the Amazon Q Business application.
        public let displayName: String?
        /// The identifier of the Amazon Web Services KMS key that is used to encrypt your data. Amazon Q Business doesn't support asymmetric keys.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// If the Status field is set to ERROR, the ErrorMessage field contains a description of the error that caused the synchronization to fail.
        public let error: ErrorDetail?
        /// The Amazon Resource Name (ARN) of an identity provider being used by an Amazon Q Business application.
        public let iamIdentityProviderArn: String?
        /// The Amazon Resource Name (ARN) of the AWS IAM Identity Center instance attached to your Amazon Q Business application.
        public let identityCenterApplicationArn: String?
        /// The authentication type being used by a Amazon Q Business application.
        public let identityType: IdentityType?
        /// Configuration information about chat response personalization. For more information, see Personalizing chat responses.
        public let personalizationConfiguration: PersonalizationConfiguration?
        /// Settings for whether end users can create and use Amazon Q Apps in the web experience.
        public let qAppsConfiguration: QAppsConfiguration?
        /// The Amazon QuickSight authentication configuration for the Amazon Q Business application.
        public let quickSightConfiguration: QuickSightConfiguration?
        /// The Amazon Resource Name (ARN) of the IAM with permissions to access your CloudWatch logs and metrics.
        public let roleArn: String?
        /// The status of the Amazon Q Business application.
        public let status: ApplicationStatus?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(applicationArn: String? = nil, applicationId: String? = nil, attachmentsConfiguration: AppliedAttachmentsConfiguration? = nil, autoSubscriptionConfiguration: AutoSubscriptionConfiguration? = nil, clientIdsForOIDC: [String]? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, error: ErrorDetail? = nil, iamIdentityProviderArn: String? = nil, identityCenterApplicationArn: String? = nil, identityType: IdentityType? = nil, personalizationConfiguration: PersonalizationConfiguration? = nil, qAppsConfiguration: QAppsConfiguration? = nil, quickSightConfiguration: QuickSightConfiguration? = nil, roleArn: String? = nil, status: ApplicationStatus? = nil, updatedAt: Date? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.attachmentsConfiguration = attachmentsConfiguration
            self.autoSubscriptionConfiguration = autoSubscriptionConfiguration
            self.clientIdsForOIDC = clientIdsForOIDC
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionConfiguration = encryptionConfiguration
            self.error = error
            self.iamIdentityProviderArn = iamIdentityProviderArn
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.identityType = identityType
            self.personalizationConfiguration = personalizationConfiguration
            self.qAppsConfiguration = qAppsConfiguration
            self.quickSightConfiguration = quickSightConfiguration
            self.roleArn = roleArn
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationId = "applicationId"
            case attachmentsConfiguration = "attachmentsConfiguration"
            case autoSubscriptionConfiguration = "autoSubscriptionConfiguration"
            case clientIdsForOIDC = "clientIdsForOIDC"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case encryptionConfiguration = "encryptionConfiguration"
            case error = "error"
            case iamIdentityProviderArn = "iamIdentityProviderArn"
            case identityCenterApplicationArn = "identityCenterApplicationArn"
            case identityType = "identityType"
            case personalizationConfiguration = "personalizationConfiguration"
            case qAppsConfiguration = "qAppsConfiguration"
            case quickSightConfiguration = "quickSightConfiguration"
            case roleArn = "roleArn"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetChatControlsConfigurationRequest: AWSEncodableShape {
        /// The identifier of the application for which the chat controls are configured.
        public let applicationId: String
        /// The maximum number of configured chat controls to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business chat controls configured.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChatControlsConfigurationResponse: AWSDecodableShape {
        /// The phrases blocked from chat by your chat control configuration.
        public let blockedPhrases: BlockedPhrasesConfiguration?
        /// The configuration details for CREATOR_MODE.
        public let creatorModeConfiguration: AppliedCreatorModeConfiguration?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business chat controls configured.
        public let nextToken: String?
        ///  The chat response orchestration settings for your application.  Chat orchestration is optimized to work for English language content. For more details on language support in Amazon Q Business, see Supported languages.
        public let orchestrationConfiguration: AppliedOrchestrationConfiguration?
        /// The response scope configured for a Amazon Q Business application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
        public let responseScope: ResponseScope?
        /// The topic specific controls configured for a Amazon Q Business application.
        public let topicConfigurations: [TopicConfiguration]?

        @inlinable
        public init(blockedPhrases: BlockedPhrasesConfiguration? = nil, creatorModeConfiguration: AppliedCreatorModeConfiguration? = nil, nextToken: String? = nil, orchestrationConfiguration: AppliedOrchestrationConfiguration? = nil, responseScope: ResponseScope? = nil, topicConfigurations: [TopicConfiguration]? = nil) {
            self.blockedPhrases = blockedPhrases
            self.creatorModeConfiguration = creatorModeConfiguration
            self.nextToken = nextToken
            self.orchestrationConfiguration = orchestrationConfiguration
            self.responseScope = responseScope
            self.topicConfigurations = topicConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrases = "blockedPhrases"
            case creatorModeConfiguration = "creatorModeConfiguration"
            case nextToken = "nextToken"
            case orchestrationConfiguration = "orchestrationConfiguration"
            case responseScope = "responseScope"
            case topicConfigurations = "topicConfigurations"
        }
    }

    public struct GetDataAccessorRequest: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The unique identifier of the data accessor to retrieve.
        public let dataAccessorId: String

        @inlinable
        public init(applicationId: String, dataAccessorId: String) {
            self.applicationId = applicationId
            self.dataAccessorId = dataAccessorId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataAccessorId, key: "dataAccessorId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, max: 36)
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, min: 36)
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataAccessorResponse: AWSDecodableShape {
        /// The list of action configurations specifying the allowed actions and any associated filters.
        public let actionConfigurations: [ActionConfiguration]?
        /// The unique identifier of the Amazon Q Business application associated with this data accessor.
        public let applicationId: String?
        /// The timestamp when the data accessor was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the data accessor.
        public let dataAccessorArn: String?
        /// The unique identifier of the data accessor.
        public let dataAccessorId: String?
        /// The friendly name of the data accessor.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the IAM Identity Center application associated with this data accessor.
        public let idcApplicationArn: String?
        /// The Amazon Resource Name (ARN) of the IAM role for the ISV associated with this data accessor.
        public let principal: String?
        /// The timestamp when the data accessor was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(actionConfigurations: [ActionConfiguration]? = nil, applicationId: String? = nil, createdAt: Date? = nil, dataAccessorArn: String? = nil, dataAccessorId: String? = nil, displayName: String? = nil, idcApplicationArn: String? = nil, principal: String? = nil, updatedAt: Date? = nil) {
            self.actionConfigurations = actionConfigurations
            self.applicationId = applicationId
            self.createdAt = createdAt
            self.dataAccessorArn = dataAccessorArn
            self.dataAccessorId = dataAccessorId
            self.displayName = displayName
            self.idcApplicationArn = idcApplicationArn
            self.principal = principal
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case actionConfigurations = "actionConfigurations"
            case applicationId = "applicationId"
            case createdAt = "createdAt"
            case dataAccessorArn = "dataAccessorArn"
            case dataAccessorId = "dataAccessorId"
            case displayName = "displayName"
            case idcApplicationArn = "idcApplicationArn"
            case principal = "principal"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The identifier of the data source connector.
        public let dataSourceId: String
        /// The identfier of the index used with the data source connector.
        public let indexId: String

        @inlinable
        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String?
        /// The details of how the data source connector is configured.
        public let configuration: AWSDocument?
        /// The Unix timestamp when the data source connector was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The identifier of the data source connector.
        public let dataSourceId: String?
        /// The description for the data source connector.
        public let description: String?
        /// The name for the data source connector.
        public let displayName: String?
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let error: ErrorDetail?
        /// The identifier of the index linked to the data source connector.
        public let indexId: String?
        /// The configuration for extracting information from media in documents for the data source.
        public let mediaExtractionConfiguration: MediaExtractionConfiguration?
        /// The Amazon Resource Name (ARN) of the role with permission to access the data source and required resources.
        public let roleArn: String?
        /// The current status of the data source connector. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let status: DataSourceStatus?
        /// The schedule for Amazon Q Business to update the index.
        public let syncSchedule: String?
        /// The type of the data source connector. For example, S3.
        public let type: String?
        /// The Unix timestamp when the data source connector was last updated.
        public let updatedAt: Date?
        /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source.
        public let vpcConfiguration: DataSourceVpcConfiguration?

        @inlinable
        public init(applicationId: String? = nil, configuration: AWSDocument? = nil, createdAt: Date? = nil, dataSourceArn: String? = nil, dataSourceId: String? = nil, description: String? = nil, displayName: String? = nil, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, error: ErrorDetail? = nil, indexId: String? = nil, mediaExtractionConfiguration: MediaExtractionConfiguration? = nil, roleArn: String? = nil, status: DataSourceStatus? = nil, syncSchedule: String? = nil, type: String? = nil, updatedAt: Date? = nil, vpcConfiguration: DataSourceVpcConfiguration? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.createdAt = createdAt
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.description = description
            self.displayName = displayName
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.error = error
            self.indexId = indexId
            self.mediaExtractionConfiguration = mediaExtractionConfiguration
            self.roleArn = roleArn
            self.status = status
            self.syncSchedule = syncSchedule
            self.type = type
            self.updatedAt = updatedAt
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case dataSourceArn = "dataSourceArn"
            case dataSourceId = "dataSourceId"
            case description = "description"
            case displayName = "displayName"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case error = "error"
            case indexId = "indexId"
            case mediaExtractionConfiguration = "mediaExtractionConfiguration"
            case roleArn = "roleArn"
            case status = "status"
            case syncSchedule = "syncSchedule"
            case type = "type"
            case updatedAt = "updatedAt"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct GetGroupRequest: AWSEncodableShape {
        /// The identifier of the application id the group is attached to.
        public let applicationId: String
        /// The identifier of the data source the group is attached to.
        public let dataSourceId: String?
        /// The name of the group.
        public let groupName: String
        /// The identifier of the index the group is attached to.
        public let indexId: String

        @inlinable
        public init(applicationId: String, dataSourceId: String? = nil, groupName: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.groupName = groupName
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.groupName, key: "groupName")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupResponse: AWSDecodableShape {
        /// The current status of the group.
        public let status: GroupStatusDetail?
        /// The status history of the group.
        public let statusHistory: [GroupStatusDetail]?

        @inlinable
        public init(status: GroupStatusDetail? = nil, statusHistory: [GroupStatusDetail]? = nil) {
            self.status = status
            self.statusHistory = statusHistory
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusHistory = "statusHistory"
        }
    }

    public struct GetIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application connected to the index.
        public let applicationId: String
        /// The identifier of the Amazon Q Business index you want information on.
        public let indexId: String

        @inlinable
        public init(applicationId: String, indexId: String) {
            self.applicationId = applicationId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIndexResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q Business application associated with the index.
        public let applicationId: String?
        /// The storage capacity units chosen for your Amazon Q Business index.
        public let capacityConfiguration: IndexCapacityConfiguration?
        /// The Unix timestamp when the Amazon Q Business index was created.
        public let createdAt: Date?
        /// The description for the Amazon Q Business index.
        public let description: String?
        /// The name of the Amazon Q Business index.
        public let displayName: String?
        /// Configuration information for document attributes or metadata. Document metadata are fields associated with your documents. For example, the company department name associated with each document. For more information, see Understanding document attributes.
        public let documentAttributeConfigurations: [DocumentAttributeConfiguration]?
        /// When the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
        public let error: ErrorDetail?
        ///  The Amazon Resource Name (ARN) of the Amazon Q Business index.
        public let indexArn: String?
        /// The identifier of the Amazon Q Business index.
        public let indexId: String?
        /// Provides information about the number of documents indexed.
        public let indexStatistics: IndexStatistics?
        /// The current status of the index. When the value is ACTIVE, the index is ready for use. If the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
        public let status: IndexStatus?
        /// The type of index attached to your Amazon Q Business application.
        public let type: IndexType?
        /// The Unix timestamp when the Amazon Q Business index was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(applicationId: String? = nil, capacityConfiguration: IndexCapacityConfiguration? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, documentAttributeConfigurations: [DocumentAttributeConfiguration]? = nil, error: ErrorDetail? = nil, indexArn: String? = nil, indexId: String? = nil, indexStatistics: IndexStatistics? = nil, status: IndexStatus? = nil, type: IndexType? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.capacityConfiguration = capacityConfiguration
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.documentAttributeConfigurations = documentAttributeConfigurations
            self.error = error
            self.indexArn = indexArn
            self.indexId = indexId
            self.indexStatistics = indexStatistics
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case capacityConfiguration = "capacityConfiguration"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case documentAttributeConfigurations = "documentAttributeConfigurations"
            case error = "error"
            case indexArn = "indexArn"
            case indexId = "indexId"
            case indexStatistics = "indexStatistics"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetMediaRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business which contains the media object.
        public let applicationId: String
        /// The identifier of the Amazon Q Business conversation.
        public let conversationId: String
        /// The identifier of the media object. You can find this in the sourceAttributions returned by the Chat, ChatSync, and ListMessages API responses.
        public let mediaId: String
        /// The identifier of the Amazon Q Business message.
        public let messageId: String

        @inlinable
        public init(applicationId: String, conversationId: String, mediaId: String, messageId: String) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.mediaId = mediaId
            self.messageId = messageId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.conversationId, key: "conversationId")
            request.encodePath(self.mediaId, key: "mediaId")
            request.encodePath(self.messageId, key: "messageId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.mediaId, name: "mediaId", parent: name, max: 36)
            try self.validate(self.mediaId, name: "mediaId", parent: name, min: 36)
            try self.validate(self.mediaId, name: "mediaId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 36)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 36)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetMediaResponse: AWSDecodableShape {
        /// The base64-encoded bytes of the media object.
        public let mediaBytes: AWSBase64Data?
        /// The MIME type of the media object (image/png).
        public let mediaMimeType: String?

        @inlinable
        public init(mediaBytes: AWSBase64Data? = nil, mediaMimeType: String? = nil) {
            self.mediaBytes = mediaBytes
            self.mediaMimeType = mediaMimeType
        }

        private enum CodingKeys: String, CodingKey {
            case mediaBytes = "mediaBytes"
            case mediaMimeType = "mediaMimeType"
        }
    }

    public struct GetPluginRequest: AWSEncodableShape {
        /// The identifier of the application which contains the plugin.
        public let applicationId: String
        /// The identifier of the plugin.
        public let pluginId: String

        @inlinable
        public init(applicationId: String, pluginId: String) {
            self.applicationId = applicationId
            self.pluginId = pluginId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.pluginId, key: "pluginId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPluginResponse: AWSDecodableShape {
        /// The identifier of the application which contains the plugin.
        public let applicationId: String?
        public let authConfiguration: PluginAuthConfiguration?
        /// The current status of a plugin. A plugin is modified asynchronously.
        public let buildStatus: PluginBuildStatus?
        /// The timestamp for when the plugin was created.
        public let createdAt: Date?
        /// Configuration information required to create a custom plugin.
        public let customPluginConfiguration: CustomPluginConfiguration?
        /// The name of the plugin.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the role with permission to access resources needed to create the plugin.
        public let pluginArn: String?
        /// The identifier of the plugin.
        public let pluginId: String?
        /// The source URL used for plugin configuration.
        public let serverUrl: String?
        /// The current state of the plugin.
        public let state: PluginState?
        /// The type of the plugin.
        public let type: PluginType?
        /// The timestamp for when the plugin was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(applicationId: String? = nil, authConfiguration: PluginAuthConfiguration? = nil, buildStatus: PluginBuildStatus? = nil, createdAt: Date? = nil, customPluginConfiguration: CustomPluginConfiguration? = nil, displayName: String? = nil, pluginArn: String? = nil, pluginId: String? = nil, serverUrl: String? = nil, state: PluginState? = nil, type: PluginType? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.authConfiguration = authConfiguration
            self.buildStatus = buildStatus
            self.createdAt = createdAt
            self.customPluginConfiguration = customPluginConfiguration
            self.displayName = displayName
            self.pluginArn = pluginArn
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case authConfiguration = "authConfiguration"
            case buildStatus = "buildStatus"
            case createdAt = "createdAt"
            case customPluginConfiguration = "customPluginConfiguration"
            case displayName = "displayName"
            case pluginArn = "pluginArn"
            case pluginId = "pluginId"
            case serverUrl = "serverUrl"
            case state = "state"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetPolicyRequest: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String

        @inlinable
        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPolicyResponse: AWSDecodableShape {
        /// The JSON representation of the permission policy.
        public let policy: String?

        @inlinable
        public init(policy: String? = nil) {
            self.policy = policy
        }

        private enum CodingKeys: String, CodingKey {
            case policy = "policy"
        }
    }

    public struct GetRetrieverRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application using the retriever.
        public let applicationId: String
        /// The identifier of the retriever.
        public let retrieverId: String

        @inlinable
        public init(applicationId: String, retrieverId: String) {
            self.applicationId = applicationId
            self.retrieverId = retrieverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.retrieverId, key: "retrieverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, max: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, min: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRetrieverResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q Business application using the retriever.
        public let applicationId: String?
        public let configuration: RetrieverConfiguration?
        /// The Unix timestamp when the retriever was created.
        public let createdAt: Date?
        /// The name of the retriever.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the retriever.
        public let retrieverArn: String?
        /// The identifier of the retriever.
        public let retrieverId: String?
        /// The Amazon Resource Name (ARN) of the role with the permission to access the retriever and required resources.
        public let roleArn: String?
        /// The status of the retriever.
        public let status: RetrieverStatus?
        /// The type of the retriever.
        public let type: RetrieverType?
        /// The Unix timestamp when the retriever was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(applicationId: String? = nil, configuration: RetrieverConfiguration? = nil, createdAt: Date? = nil, displayName: String? = nil, retrieverArn: String? = nil, retrieverId: String? = nil, roleArn: String? = nil, status: RetrieverStatus? = nil, type: RetrieverType? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.createdAt = createdAt
            self.displayName = displayName
            self.retrieverArn = retrieverArn
            self.retrieverId = retrieverId
            self.roleArn = roleArn
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case retrieverArn = "retrieverArn"
            case retrieverId = "retrieverId"
            case roleArn = "roleArn"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetUserRequest: AWSEncodableShape {
        /// The identifier of the application connected to the user.
        public let applicationId: String
        /// The user email address attached to the user.
        public let userId: String

        @inlinable
        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserResponse: AWSDecodableShape {
        /// A list of user aliases attached to a user.
        public let userAliases: [UserAlias]?

        @inlinable
        public init(userAliases: [UserAlias]? = nil) {
            self.userAliases = userAliases
        }

        private enum CodingKeys: String, CodingKey {
            case userAliases = "userAliases"
        }
    }

    public struct GetWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application linked to the web experience.
        public let applicationId: String
        /// The identifier of the Amazon Q Business web experience.
        public let webExperienceId: String

        @inlinable
        public init(applicationId: String, webExperienceId: String) {
            self.applicationId = applicationId
            self.webExperienceId = webExperienceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.webExperienceId, key: "webExperienceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, max: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, min: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWebExperienceResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q Business application linked to the web experience.
        public let applicationId: String?
        /// The authentication configuration information for your Amazon Q Business web experience.
        public let authenticationConfiguration: WebExperienceAuthConfiguration?
        /// The browser extension configuration for an Amazon Q Business web experience.
        public let browserExtensionConfiguration: BrowserExtensionConfiguration?
        /// The Unix timestamp when the Amazon Q Business web experience was last created.
        public let createdAt: Date?
        /// Gets the custom logo, favicon, font, and color used in the Amazon Q web experience.
        public let customizationConfiguration: CustomizationConfiguration?
        /// The endpoint of your Amazon Q Business web experience.
        public let defaultEndpoint: String?
        /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let error: ErrorDetail?
        /// Information about the identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
        public let identityProviderConfiguration: IdentityProviderConfiguration?
        /// Gets the website domain origins that  are allowed to embed the Amazon Q Business web experience.  The domain origin refers to the  base URL for accessing a website including the protocol  (http/https), the domain name, and the port number (if specified).
        public let origins: [String]?
        ///  The Amazon Resource Name (ARN) of the service role attached to your web experience.
        public let roleArn: String?
        /// Determines whether sample prompts are enabled in the web experience for an end user.
        public let samplePromptsControlMode: WebExperienceSamplePromptsControlMode?
        /// The current status of the Amazon Q Business web experience. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let status: WebExperienceStatus?
        /// The subtitle for your Amazon Q Business web experience.
        public let subtitle: String?
        /// The title for your Amazon Q Business web experience.
        public let title: String?
        /// The Unix timestamp when the Amazon Q Business web experience was last updated.
        public let updatedAt: Date?
        /// The Amazon Resource Name (ARN) of the role with the permission to access the Amazon Q Business web experience and required resources.
        public let webExperienceArn: String?
        /// The identifier of the Amazon Q Business web experience.
        public let webExperienceId: String?
        /// The customized welcome message for end users of an Amazon Q Business web experience.
        public let welcomeMessage: String?

        @inlinable
        public init(applicationId: String? = nil, browserExtensionConfiguration: BrowserExtensionConfiguration? = nil, createdAt: Date? = nil, customizationConfiguration: CustomizationConfiguration? = nil, defaultEndpoint: String? = nil, error: ErrorDetail? = nil, identityProviderConfiguration: IdentityProviderConfiguration? = nil, origins: [String]? = nil, roleArn: String? = nil, samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, status: WebExperienceStatus? = nil, subtitle: String? = nil, title: String? = nil, updatedAt: Date? = nil, webExperienceArn: String? = nil, webExperienceId: String? = nil, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.authenticationConfiguration = nil
            self.browserExtensionConfiguration = browserExtensionConfiguration
            self.createdAt = createdAt
            self.customizationConfiguration = customizationConfiguration
            self.defaultEndpoint = defaultEndpoint
            self.error = error
            self.identityProviderConfiguration = identityProviderConfiguration
            self.origins = origins
            self.roleArn = roleArn
            self.samplePromptsControlMode = samplePromptsControlMode
            self.status = status
            self.subtitle = subtitle
            self.title = title
            self.updatedAt = updatedAt
            self.webExperienceArn = webExperienceArn
            self.webExperienceId = webExperienceId
            self.welcomeMessage = welcomeMessage
        }

        @available(*, deprecated, message: "Members authenticationConfiguration have been deprecated")
        @inlinable
        public init(applicationId: String? = nil, authenticationConfiguration: WebExperienceAuthConfiguration? = nil, browserExtensionConfiguration: BrowserExtensionConfiguration? = nil, createdAt: Date? = nil, customizationConfiguration: CustomizationConfiguration? = nil, defaultEndpoint: String? = nil, error: ErrorDetail? = nil, identityProviderConfiguration: IdentityProviderConfiguration? = nil, origins: [String]? = nil, roleArn: String? = nil, samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, status: WebExperienceStatus? = nil, subtitle: String? = nil, title: String? = nil, updatedAt: Date? = nil, webExperienceArn: String? = nil, webExperienceId: String? = nil, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.authenticationConfiguration = authenticationConfiguration
            self.browserExtensionConfiguration = browserExtensionConfiguration
            self.createdAt = createdAt
            self.customizationConfiguration = customizationConfiguration
            self.defaultEndpoint = defaultEndpoint
            self.error = error
            self.identityProviderConfiguration = identityProviderConfiguration
            self.origins = origins
            self.roleArn = roleArn
            self.samplePromptsControlMode = samplePromptsControlMode
            self.status = status
            self.subtitle = subtitle
            self.title = title
            self.updatedAt = updatedAt
            self.webExperienceArn = webExperienceArn
            self.webExperienceId = webExperienceId
            self.welcomeMessage = welcomeMessage
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case authenticationConfiguration = "authenticationConfiguration"
            case browserExtensionConfiguration = "browserExtensionConfiguration"
            case createdAt = "createdAt"
            case customizationConfiguration = "customizationConfiguration"
            case defaultEndpoint = "defaultEndpoint"
            case error = "error"
            case identityProviderConfiguration = "identityProviderConfiguration"
            case origins = "origins"
            case roleArn = "roleArn"
            case samplePromptsControlMode = "samplePromptsControlMode"
            case status = "status"
            case subtitle = "subtitle"
            case title = "title"
            case updatedAt = "updatedAt"
            case webExperienceArn = "webExperienceArn"
            case webExperienceId = "webExperienceId"
            case welcomeMessage = "welcomeMessage"
        }
    }

    public struct GroupMembers: AWSEncodableShape {
        /// A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".
        public let memberGroups: [MemberGroup]?
        /// A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.
        public let memberUsers: [MemberUser]?
        public let s3PathForGroupMembers: S3?

        @inlinable
        public init(memberGroups: [MemberGroup]? = nil, memberUsers: [MemberUser]? = nil, s3PathForGroupMembers: S3? = nil) {
            self.memberGroups = memberGroups
            self.memberUsers = memberUsers
            self.s3PathForGroupMembers = s3PathForGroupMembers
        }

        public func validate(name: String) throws {
            try self.memberGroups?.forEach {
                try $0.validate(name: "\(name).memberGroups[]")
            }
            try self.memberUsers?.forEach {
                try $0.validate(name: "\(name).memberUsers[]")
            }
            try self.s3PathForGroupMembers?.validate(name: "\(name).s3PathForGroupMembers")
        }

        private enum CodingKeys: String, CodingKey {
            case memberGroups = "memberGroups"
            case memberUsers = "memberUsers"
            case s3PathForGroupMembers = "s3PathForGroupMembers"
        }
    }

    public struct GroupStatusDetail: AWSDecodableShape {
        /// The details of an error associated a group status.
        public let errorDetail: ErrorDetail?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public let lastUpdatedAt: Date?
        /// The status of a group.
        public let status: GroupStatus?

        @inlinable
        public init(errorDetail: ErrorDetail? = nil, lastUpdatedAt: Date? = nil, status: GroupStatus? = nil) {
            self.errorDetail = errorDetail
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "errorDetail"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct GroupSummary: AWSDecodableShape {
        /// The name of the group the summary information is for.
        public let groupName: String?

        @inlinable
        public init(groupName: String? = nil) {
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "groupName"
        }
    }

    public struct HookConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Q Business should invoke a function that inserts the current date-time.
        public let invocationCondition: DocumentAttributeCondition?
        /// The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see IAM roles for Custom Document Enrichment (CDE).
        public let lambdaArn: String?
        /// The Amazon Resource Name (ARN) of a role with permission to run PreExtractionHookConfiguration and PostExtractionHookConfiguration for altering document metadata and content during the document ingestion process.
        public let roleArn: String?
        /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
        public let s3BucketName: String?

        @inlinable
        public init(invocationCondition: DocumentAttributeCondition? = nil, lambdaArn: String? = nil, roleArn: String? = nil, s3BucketName: String? = nil) {
            self.invocationCondition = invocationCondition
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
            self.s3BucketName = s3BucketName
        }

        public func validate(name: String) throws {
            try self.invocationCondition?.validate(name: "\(name).invocationCondition")
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 2048)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, min: 1)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:lambda:[a-z-]*-[0-9]:[0-9]{12}:function:[a-zA-Z0-9-_]+(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?(:[a-zA-Z0-9-_]+)?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationCondition = "invocationCondition"
            case lambdaArn = "lambdaArn"
            case roleArn = "roleArn"
            case s3BucketName = "s3BucketName"
        }
    }

    public struct IdcAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the IAM Identity Center Application used to configure authentication.
        public let idcApplicationArn: String
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to perform actions on Amazon Web Services services on your behalf.
        public let roleArn: String

        @inlinable
        public init(idcApplicationArn: String, roleArn: String) {
            self.idcApplicationArn = idcApplicationArn
            self.roleArn = roleArn
        }

        public func validate(name: String) throws {
            try self.validate(self.idcApplicationArn, name: "idcApplicationArn", parent: name, max: 1224)
            try self.validate(self.idcApplicationArn, name: "idcApplicationArn", parent: name, min: 10)
            try self.validate(self.idcApplicationArn, name: "idcApplicationArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn|aws-iso|aws-iso-b):sso::\\d{12}:application/(sso)?ins-[a-zA-Z0-9-.]{16}/apl-[a-zA-Z0-9]{16}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case idcApplicationArn = "idcApplicationArn"
            case roleArn = "roleArn"
        }
    }

    public struct ImageExtractionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specify whether to extract semantic meaning from images and visuals from documents.
        public let imageExtractionStatus: ImageExtractionStatus

        @inlinable
        public init(imageExtractionStatus: ImageExtractionStatus) {
            self.imageExtractionStatus = imageExtractionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case imageExtractionStatus = "imageExtractionStatus"
        }
    }

    public struct ImageSourceDetails: AWSDecodableShape {
        /// Unique identifier for the image file.
        public let mediaId: String?
        /// The MIME type of the image file.
        public let mediaMimeType: String?

        @inlinable
        public init(mediaId: String? = nil, mediaMimeType: String? = nil) {
            self.mediaId = mediaId
            self.mediaMimeType = mediaMimeType
        }

        private enum CodingKeys: String, CodingKey {
            case mediaId = "mediaId"
            case mediaMimeType = "mediaMimeType"
        }
    }

    public struct Index: AWSDecodableShape {
        /// The Unix timestamp when the index was created.
        public let createdAt: Date?
        /// The name of the index.
        public let displayName: String?
        /// The identifier for the index.
        public let indexId: String?
        /// The current status of the index. When the status is ACTIVE, the index is ready.
        public let status: IndexStatus?
        /// The Unix timestamp when the index was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(createdAt: Date? = nil, displayName: String? = nil, indexId: String? = nil, status: IndexStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.displayName = displayName
            self.indexId = indexId
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case displayName = "displayName"
            case indexId = "indexId"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct IndexCapacityConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of storage units configured for an Amazon Q Business index.
        public let units: Int?

        @inlinable
        public init(units: Int? = nil) {
            self.units = units
        }

        public func validate(name: String) throws {
            try self.validate(self.units, name: "units", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
        }
    }

    public struct IndexStatistics: AWSDecodableShape {
        /// The number of documents indexed.
        public let textDocumentStatistics: TextDocumentStatistics?

        @inlinable
        public init(textDocumentStatistics: TextDocumentStatistics? = nil) {
            self.textDocumentStatistics = textDocumentStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case textDocumentStatistics = "textDocumentStatistics"
        }
    }

    public struct InlineDocumentEnrichmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let condition: DocumentAttributeCondition?
        ///  TRUE to delete content if the condition used for the target attribute is met.
        public let documentContentOperator: DocumentContentOperator?
        public let target: DocumentAttributeTarget?

        @inlinable
        public init(condition: DocumentAttributeCondition? = nil, documentContentOperator: DocumentContentOperator? = nil, target: DocumentAttributeTarget? = nil) {
            self.condition = condition
            self.documentContentOperator = documentContentOperator
            self.target = target
        }

        public func validate(name: String) throws {
            try self.condition?.validate(name: "\(name).condition")
            try self.target?.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case documentContentOperator = "documentContentOperator"
            case target = "target"
        }
    }

    public struct KendraIndexConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Amazon Kendra index.
        public let indexId: String

        @inlinable
        public init(indexId: String) {
            self.indexId = indexId
        }

        public func validate(name: String) throws {
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case indexId = "indexId"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The maximum number of Amazon Q Business applications to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business applications.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// An array of summary information on the configuration of one or more Amazon Q Business applications.
        public let applications: [Application]?
        /// If the response is truncated, Amazon Q Business returns this token. You can use this token in a subsequent request to retrieve the next set of applications.
        public let nextToken: String?

        @inlinable
        public init(applications: [Application]? = nil, nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "applications"
            case nextToken = "nextToken"
        }
    }

    public struct ListAttachmentsRequest: AWSEncodableShape {
        /// The unique identifier for the Amazon Q Business application.
        public let applicationId: String
        /// The unique identifier of the Amazon Q Business web experience conversation.
        public let conversationId: String?
        /// The maximum number of attachements to return.
        public let maxResults: Int?
        /// If the number of attachments returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of attachments.
        public let nextToken: String?
        /// The unique identifier of the user involved in the Amazon Q Business web experience conversation.
        public let userId: String?

        @inlinable
        public init(applicationId: String, conversationId: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, userId: String? = nil) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.conversationId, key: "conversationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListAttachmentsResponse: AWSDecodableShape {
        /// An array of information on one or more attachments.
        public let attachments: [Attachment]?
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of attachments.
        public let nextToken: String?

        @inlinable
        public init(attachments: [Attachment]? = nil, nextToken: String? = nil) {
            self.attachments = attachments
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case attachments = "attachments"
            case nextToken = "nextToken"
        }
    }

    public struct ListConversationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The maximum number of Amazon Q Business conversations to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business conversations.
        public let nextToken: String?
        /// The identifier of the user involved in the Amazon Q Business web experience conversation.
        public let userId: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil, userId: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConversationsResponse: AWSDecodableShape {
        /// An array of summary information on the configuration of one or more Amazon Q Business web experiences.
        public let conversations: [Conversation]?
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of messages.
        public let nextToken: String?

        @inlinable
        public init(conversations: [Conversation]? = nil, nextToken: String? = nil) {
            self.conversations = conversations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conversations = "conversations"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataAccessorsRequest: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The maximum number of results to return in a single call.
        public let maxResults: Int?
        /// The token for the next set of results. (You received this token from a previous call.)
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1500)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataAccessorsResponse: AWSDecodableShape {
        /// The list of data accessors.
        public let dataAccessors: [DataAccessor]?
        /// The token to use to retrieve the next set of results, if there are any.
        public let nextToken: String?

        @inlinable
        public init(dataAccessors: [DataAccessor]? = nil, nextToken: String? = nil) {
            self.dataAccessors = dataAccessors
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataAccessors = "dataAccessors"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourceSyncJobsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application connected to the data source.
        public let applicationId: String
        ///  The identifier of the data source connector.
        public let dataSourceId: String
        ///  The end time of the data source connector sync.
        public let endTime: Date?
        /// The identifier of the index used with the Amazon Q Business data source connector.
        public let indexId: String
        /// The maximum number of synchronization jobs to return in the response.
        public let maxResults: Int?
        /// If the maxResults response was incpmplete because there is more data to retriever, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of responses.
        public let nextToken: String?
        ///  The start time of the data source connector sync.
        public let startTime: Date?
        /// Only returns synchronization jobs with the Status field equal to the specified status.
        public let statusFilter: DataSourceSyncJobStatus?

        @inlinable
        public init(applicationId: String, dataSourceId: String, endTime: Date? = nil, indexId: String, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date? = nil, statusFilter: DataSourceSyncJobStatus? = nil) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.endTime = endTime
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
            self.statusFilter = statusFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.startTime, key: "startTime")
            request.encodeQuery(self.statusFilter, key: "syncStatus")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourceSyncJobsResponse: AWSDecodableShape {
        /// A history of synchronization jobs for the data source connector.
        public let history: [DataSourceSyncJob]?
        /// If the response is truncated, Amazon Q Business returns this token. You can use this token in any subsequent request to retrieve the next set of jobs.
        public let nextToken: String?

        @inlinable
        public init(history: [DataSourceSyncJob]? = nil, nextToken: String? = nil) {
            self.history = history
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case history = "history"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application linked to the data source connectors.
        public let applicationId: String
        /// The identifier of the index used with one or more data source connectors.
        public let indexId: String
        /// The maximum number of data source connectors to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business data source connectors.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, indexId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// An array of summary information for one or more data source connector.
        public let dataSources: [DataSource]?
        /// If the response is truncated, Amazon Q Business returns this token. You can use this token in a subsequent request to retrieve the next set of data source connectors.
        public let nextToken: String?

        @inlinable
        public init(dataSources: [DataSource]? = nil, nextToken: String? = nil) {
            self.dataSources = dataSources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "dataSources"
            case nextToken = "nextToken"
        }
    }

    public struct ListDocumentsRequest: AWSEncodableShape {
        /// The identifier of the application id the documents are attached to.
        public let applicationId: String
        /// The identifier of the data sources the documents are attached to.
        public let dataSourceIds: [String]?
        /// The identifier of the index the documents are attached to.
        public let indexId: String
        /// The maximum number of documents to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, dataSourceIds: [String]? = nil, indexId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.dataSourceIds = dataSourceIds
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceIds, key: "dataSourceIds")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.dataSourceIds?.forEach {
                try validate($0, name: "dataSourceIds[]", parent: name, max: 36)
                try validate($0, name: "dataSourceIds[]", parent: name, min: 36)
                try validate($0, name: "dataSourceIds[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            }
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, max: 1)
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDocumentsResponse: AWSDecodableShape {
        /// A list of document details.
        public let documentDetailList: [DocumentDetails]?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
        public let nextToken: String?

        @inlinable
        public init(documentDetailList: [DocumentDetails]? = nil, nextToken: String? = nil) {
            self.documentDetailList = documentDetailList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case documentDetailList = "documentDetailList"
            case nextToken = "nextToken"
        }
    }

    public struct ListGroupsRequest: AWSEncodableShape {
        /// The identifier of the application for getting a list of groups mapped to users.
        public let applicationId: String
        /// The identifier of the data source for getting a list of groups mapped to users.
        public let dataSourceId: String?
        /// The identifier of the index for getting a list of groups mapped to users.
        public let indexId: String
        /// The maximum number of returned groups that are mapped to users.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of groups that are mapped to users.
        public let nextToken: String?
        /// The timestamp identifier used for the latest PUT or DELETE action for mapping users to their groups.
        public let updatedEarlierThan: Date

        @inlinable
        public init(applicationId: String, dataSourceId: String? = nil, indexId: String, maxResults: Int? = nil, nextToken: String? = nil, updatedEarlierThan: Date) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.updatedEarlierThan = updatedEarlierThan
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.updatedEarlierThan, key: "updatedEarlierThan")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupsResponse: AWSDecodableShape {
        /// Summary information for list of groups that are mapped to users.
        public let items: [GroupSummary]?
        /// If the response is truncated, Amazon Q Business returns this token that you can use in the subsequent request to retrieve the next set of groups that are mapped to users.
        public let nextToken: String?

        @inlinable
        public init(items: [GroupSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListIndicesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application connected to the index.
        public let applicationId: String
        /// The maximum number of indices to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business indices.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIndicesResponse: AWSDecodableShape {
        /// An array of information on the items in one or more indexes.
        public let indices: [Index]?
        /// If the response is truncated, Amazon Q Business returns this token that you can use in the subsequent request to retrieve the next set of indexes.
        public let nextToken: String?

        @inlinable
        public init(indices: [Index]? = nil, nextToken: String? = nil) {
            self.indices = indices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case indices = "indices"
            case nextToken = "nextToken"
        }
    }

    public struct ListMessagesRequest: AWSEncodableShape {
        /// The identifier for the Amazon Q Business application.
        public let applicationId: String
        /// The identifier of the Amazon Q Business web experience conversation.
        public let conversationId: String
        /// The maximum number of messages to return.
        public let maxResults: Int?
        /// If the number of messages returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of messages.
        public let nextToken: String?
        /// The identifier of the user involved in the Amazon Q Business web experience conversation.
        public let userId: String?

        @inlinable
        public init(applicationId: String, conversationId: String, maxResults: Int? = nil, nextToken: String? = nil, userId: String? = nil) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.conversationId, key: "conversationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMessagesResponse: AWSDecodableShape {
        /// An array of information on one or more messages.
        public let messages: [Message]?
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of messages.
        public let nextToken: String?

        @inlinable
        public init(messages: [Message]? = nil, nextToken: String? = nil) {
            self.messages = messages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
            case nextToken = "nextToken"
        }
    }

    public struct ListPluginActionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application the plugin is attached to.
        public let applicationId: String
        /// The maximum number of plugin actions to return.
        public let maxResults: Int?
        /// If the number of plugin actions returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of plugin actions.
        public let nextToken: String?
        /// The identifier of the Amazon Q Business plugin.
        public let pluginId: String

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil, pluginId: String) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pluginId = pluginId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.pluginId, key: "pluginId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPluginActionsResponse: AWSDecodableShape {
        /// An array of information on one or more plugin actions.
        public let items: [ActionSummary]?
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of plugin actions.
        public let nextToken: String?

        @inlinable
        public init(items: [ActionSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListPluginTypeActionsRequest: AWSEncodableShape {
        /// The maximum number of plugins to return.
        public let maxResults: Int?
        /// If the number of plugins returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of plugins.
        public let nextToken: String?
        /// The type of the plugin.
        public let pluginType: PluginType

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil, pluginType: PluginType) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.pluginType = pluginType
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodePath(self.pluginType, key: "pluginType")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPluginTypeActionsResponse: AWSDecodableShape {
        /// An array of information on one or more plugins.
        public let items: [ActionSummary]?
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of plugins.
        public let nextToken: String?

        @inlinable
        public init(items: [ActionSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListPluginTypeMetadataRequest: AWSEncodableShape {
        /// The maximum number of plugin metadata items to return.
        public let maxResults: Int?
        /// If the metadata returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of metadata.
        public let nextToken: String?

        @inlinable
        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPluginTypeMetadataResponse: AWSDecodableShape {
        /// An array of information on plugin metadata.
        public let items: [PluginTypeMetadataSummary]?
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of plugin metadata.
        public let nextToken: String?

        @inlinable
        public init(items: [PluginTypeMetadataSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListPluginsRequest: AWSEncodableShape {
        /// The identifier of the application the plugin is attached to.
        public let applicationId: String
        /// The maximum number of documents to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPluginsResponse: AWSDecodableShape {
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
        public let nextToken: String?
        /// Information about a configured plugin.
        public let plugins: [Plugin]?

        @inlinable
        public init(nextToken: String? = nil, plugins: [Plugin]? = nil) {
            self.nextToken = nextToken
            self.plugins = plugins
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case plugins = "plugins"
        }
    }

    public struct ListRetrieversRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application using the retriever.
        public let applicationId: String
        /// The maximum number of retrievers returned.
        public let maxResults: Int?
        /// If the number of retrievers returned exceeds maxResults, Amazon Q Business returns a next token as a pagination token to retrieve the next set of retrievers.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRetrieversResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of retrievers.
        public let nextToken: String?
        /// An array of summary information for one or more retrievers.
        public let retrievers: [Retriever]?

        @inlinable
        public init(nextToken: String? = nil, retrievers: [Retriever]? = nil) {
            self.nextToken = nextToken
            self.retrievers = retrievers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievers = "retrievers"
        }
    }

    public struct ListSubscriptionsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application linked to the subscription.
        public let applicationId: String
        /// The maximum number of Amazon Q Business subscriptions to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business subscriptions.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSubscriptionsResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Q Business returns this token. You can use this token in a subsequent request to retrieve the next set of subscriptions.
        public let nextToken: String?
        /// An array of summary information on the subscriptions configured for an Amazon Q Business application.
        public let subscriptions: [Subscription]?

        @inlinable
        public init(nextToken: String? = nil, subscriptions: [Subscription]? = nil) {
            self.nextToken = nextToken
            self.subscriptions = subscriptions
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case subscriptions = "subscriptions"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q Business application or data source to get a list of tags for.
        public let resourceARN: String

        @inlinable
        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the Amazon Q Business application or data source.
        public let tags: [Tag]?

        @inlinable
        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWebExperiencesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application linked to the listed web experiences.
        public let applicationId: String
        /// The maximum number of Amazon Q Business Web Experiences to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q Business returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q Business conversations.
        public let nextToken: String?

        @inlinable
        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWebExperiencesResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Q Business returns this token, which you can use in a later request to list the next set of messages.
        public let nextToken: String?
        /// An array of summary information for one or more Amazon Q Business experiences.
        public let webExperiences: [WebExperience]?

        @inlinable
        public init(nextToken: String? = nil, webExperiences: [WebExperience]? = nil) {
            self.nextToken = nextToken
            self.webExperiences = webExperiences
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case webExperiences = "webExperiences"
        }
    }

    public struct MediaExtractionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration settings for extracting and processing audio content from media files.
        public let audioExtractionConfiguration: AudioExtractionConfiguration?
        /// The configuration for extracting semantic meaning from images in documents.  For more information, see Extracting semantic meaning from images and visuals.
        public let imageExtractionConfiguration: ImageExtractionConfiguration?
        /// Configuration settings for extracting and processing video content from media files.
        public let videoExtractionConfiguration: VideoExtractionConfiguration?

        @inlinable
        public init(audioExtractionConfiguration: AudioExtractionConfiguration? = nil, imageExtractionConfiguration: ImageExtractionConfiguration? = nil, videoExtractionConfiguration: VideoExtractionConfiguration? = nil) {
            self.audioExtractionConfiguration = audioExtractionConfiguration
            self.imageExtractionConfiguration = imageExtractionConfiguration
            self.videoExtractionConfiguration = videoExtractionConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case audioExtractionConfiguration = "audioExtractionConfiguration"
            case imageExtractionConfiguration = "imageExtractionConfiguration"
            case videoExtractionConfiguration = "videoExtractionConfiguration"
        }
    }

    public struct MemberGroup: AWSEncodableShape {
        /// The name of the sub group.
        public let groupName: String
        /// The type of the sub group.
        public let type: MembershipType?

        @inlinable
        public init(groupName: String, type: MembershipType? = nil) {
            self.groupName = groupName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "groupName"
            case type = "type"
        }
    }

    public struct MemberUser: AWSEncodableShape {
        /// The type of the user.
        public let type: MembershipType?
        /// The identifier of the user you want to map to a group.
        public let userId: String

        @inlinable
        public init(type: MembershipType? = nil, userId: String) {
            self.type = type
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case userId = "userId"
        }
    }

    public struct Message: AWSDecodableShape {
        public let actionExecution: ActionExecution?
        public let actionReview: ActionReview?
        /// A file directly uploaded into an Amazon Q Business web experience chat.
        public let attachments: [AttachmentOutput]?
        /// The content of the Amazon Q Business web experience message.
        public let body: String?
        /// The identifier of the Amazon Q Business web experience message.
        public let messageId: String?
        /// The source documents used to generate Amazon Q Business web experience message.
        public let sourceAttribution: [SourceAttribution]?
        /// The timestamp of the first Amazon Q Business web experience message.
        public let time: Date?
        /// The type of Amazon Q Business message, whether HUMAN or AI generated.
        public let type: MessageType?

        @inlinable
        public init(actionExecution: ActionExecution? = nil, actionReview: ActionReview? = nil, attachments: [AttachmentOutput]? = nil, body: String? = nil, messageId: String? = nil, sourceAttribution: [SourceAttribution]? = nil, time: Date? = nil, type: MessageType? = nil) {
            self.actionExecution = actionExecution
            self.actionReview = actionReview
            self.attachments = attachments
            self.body = body
            self.messageId = messageId
            self.sourceAttribution = sourceAttribution
            self.time = time
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionExecution = "actionExecution"
            case actionReview = "actionReview"
            case attachments = "attachments"
            case body = "body"
            case messageId = "messageId"
            case sourceAttribution = "sourceAttribution"
            case time = "time"
            case type = "type"
        }
    }

    public struct MessageUsefulnessFeedback: AWSEncodableShape {
        /// A comment given by an end user on the usefulness of an AI-generated chat message.
        public let comment: String?
        /// The reason for a usefulness rating.
        public let reason: MessageUsefulnessReason?
        /// The timestamp for when the feedback was submitted.
        public let submittedAt: Date
        /// The usefulness value assigned by an end user to a message.
        public let usefulness: MessageUsefulness

        @inlinable
        public init(comment: String? = nil, reason: MessageUsefulnessReason? = nil, submittedAt: Date, usefulness: MessageUsefulness) {
            self.comment = comment
            self.reason = reason
            self.submittedAt = submittedAt
            self.usefulness = usefulness
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1000)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case reason = "reason"
            case submittedAt = "submittedAt"
            case usefulness = "usefulness"
        }
    }

    public struct MetadataEvent: AWSDecodableShape {
        /// The identifier of the conversation with which the generated metadata is associated.
        public let conversationId: String?
        /// The final text output message generated by the system.
        public let finalTextMessage: String?
        /// The source documents used to generate the conversation response.
        public let sourceAttributions: [SourceAttribution]?
        /// The identifier of an Amazon Q Business AI generated message within the conversation.
        public let systemMessageId: String?
        /// The identifier of an Amazon Q Business end user text input message within the conversation.
        public let userMessageId: String?

        @inlinable
        public init(conversationId: String? = nil, finalTextMessage: String? = nil, sourceAttributions: [SourceAttribution]? = nil, systemMessageId: String? = nil, userMessageId: String? = nil) {
            self.conversationId = conversationId
            self.finalTextMessage = finalTextMessage
            self.sourceAttributions = sourceAttributions
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case finalTextMessage = "finalTextMessage"
            case sourceAttributions = "sourceAttributions"
            case systemMessageId = "systemMessageId"
            case userMessageId = "userMessageId"
        }
    }

    public struct NativeIndexConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Overrides the default boosts applied by Amazon Q Business to supported document attribute data types.
        public let boostingOverride: [String: DocumentAttributeBoostingConfiguration]?
        /// The identifier for the Amazon Q Business index.
        public let indexId: String

        @inlinable
        public init(boostingOverride: [String: DocumentAttributeBoostingConfiguration]? = nil, indexId: String) {
            self.boostingOverride = boostingOverride
            self.indexId = indexId
        }

        public func validate(name: String) throws {
            try self.boostingOverride?.forEach {
                try validate($0.key, name: "boostingOverride.key", parent: name, max: 200)
                try validate($0.key, name: "boostingOverride.key", parent: name, min: 1)
                try validate($0.key, name: "boostingOverride.key", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
                try $0.value.validate(name: "\(name).boostingOverride[\"\($0.key)\"]")
            }
            try self.validate(self.boostingOverride, name: "boostingOverride", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case boostingOverride = "boostingOverride"
            case indexId = "indexId"
        }
    }

    public struct NoAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        public init() {}
    }

    public struct NumberAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the duration, in seconds, of a boost applies to a NUMBER type document attribute.
        public let boostingLevel: DocumentAttributeBoostingLevel
        /// Specifies how much a document attribute is boosted.
        public let boostingType: NumberAttributeBoostingType?

        @inlinable
        public init(boostingLevel: DocumentAttributeBoostingLevel, boostingType: NumberAttributeBoostingType? = nil) {
            self.boostingLevel = boostingLevel
            self.boostingType = boostingType
        }

        private enum CodingKeys: String, CodingKey {
            case boostingLevel = "boostingLevel"
            case boostingType = "boostingType"
        }
    }

    public struct OAuth2ClientCredentialConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The redirect URL required by the OAuth 2.0 protocol for Amazon Q Business to authenticate a plugin user through a third party authentication server.
        public let authorizationUrl: String?
        /// The ARN of an IAM role used by Amazon Q Business to access the OAuth 2.0 authentication credentials stored in a Secrets Manager secret.
        public let roleArn: String
        /// The ARN of the Secrets Manager secret that stores the OAuth 2.0 credentials/token used for plugin configuration.
        public let secretArn: String
        /// The URL required by the OAuth 2.0 protocol to exchange an end user authorization code for an access token.
        public let tokenUrl: String?

        @inlinable
        public init(authorizationUrl: String? = nil, roleArn: String, secretArn: String, tokenUrl: String? = nil) {
            self.authorizationUrl = authorizationUrl
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.tokenUrl = tokenUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.authorizationUrl, name: "authorizationUrl", parent: name, max: 2048)
            try self.validate(self.authorizationUrl, name: "authorizationUrl", parent: name, min: 1)
            try self.validate(self.authorizationUrl, name: "authorizationUrl", parent: name, pattern: "^(https?|ftp|file)://([^\\s]*)$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 1284)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, max: 2048)
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, min: 1)
            try self.validate(self.tokenUrl, name: "tokenUrl", parent: name, pattern: "^(https?|ftp|file)://([^\\s]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case authorizationUrl = "authorizationUrl"
            case roleArn = "roleArn"
            case secretArn = "secretArn"
            case tokenUrl = "tokenUrl"
        }
    }

    public struct OpenIDConnectProviderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a Secrets Manager secret containing the OIDC client secret.
        public let secretsArn: String
        /// An IAM role with permissions to access KMS to decrypt the Secrets Manager secret containing your OIDC client secret.
        public let secretsRole: String

        @inlinable
        public init(secretsArn: String, secretsRole: String) {
            self.secretsArn = secretsArn
            self.secretsRole = secretsRole
        }

        public func validate(name: String) throws {
            try self.validate(self.secretsArn, name: "secretsArn", parent: name, max: 1284)
            try self.validate(self.secretsArn, name: "secretsArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.secretsRole, name: "secretsRole", parent: name, max: 1284)
            try self.validate(self.secretsRole, name: "secretsRole", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case secretsArn = "secretsArn"
            case secretsRole = "secretsRole"
        }
    }

    public struct OrchestrationConfiguration: AWSEncodableShape {
        ///  Status information about whether chat orchestration is activated or deactivated for your Amazon Q Business application.
        public let control: OrchestrationControl

        @inlinable
        public init(control: OrchestrationControl) {
            self.control = control
        }

        private enum CodingKeys: String, CodingKey {
            case control = "control"
        }
    }

    public struct PersonalizationConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// An option to allow Amazon Q Business to customize chat responses using user specific metadata—specifically, location and job information—in your IAM Identity Center instance.
        public let personalizationControlMode: PersonalizationControlMode

        @inlinable
        public init(personalizationControlMode: PersonalizationControlMode) {
            self.personalizationControlMode = personalizationControlMode
        }

        private enum CodingKeys: String, CodingKey {
            case personalizationControlMode = "personalizationControlMode"
        }
    }

    public struct Plugin: AWSDecodableShape {
        /// The status of the plugin.
        public let buildStatus: PluginBuildStatus?
        /// The timestamp for when the plugin was created.
        public let createdAt: Date?
        /// The name of the plugin.
        public let displayName: String?
        /// The identifier of the plugin.
        public let pluginId: String?
        /// The plugin server URL used for configuration.
        public let serverUrl: String?
        /// The current status of the plugin.
        public let state: PluginState?
        /// The type of the plugin.
        public let type: PluginType?
        /// The timestamp for when the plugin was last updated.
        public let updatedAt: Date?

        @inlinable
        public init(buildStatus: PluginBuildStatus? = nil, createdAt: Date? = nil, displayName: String? = nil, pluginId: String? = nil, serverUrl: String? = nil, state: PluginState? = nil, type: PluginType? = nil, updatedAt: Date? = nil) {
            self.buildStatus = buildStatus
            self.createdAt = createdAt
            self.displayName = displayName
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case buildStatus = "buildStatus"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case pluginId = "pluginId"
            case serverUrl = "serverUrl"
            case state = "state"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct PluginConfiguration: AWSEncodableShape {
        ///  The identifier of the plugin you want to use.
        public let pluginId: String

        @inlinable
        public init(pluginId: String) {
            self.pluginId = pluginId
        }

        public func validate(name: String) throws {
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case pluginId = "pluginId"
        }
    }

    public struct PluginTypeMetadataSummary: AWSDecodableShape {
        /// The category of the plugin type.
        public let category: PluginTypeCategory?
        /// The description assigned by Amazon Q Business to a plugin. You can't modify this value.
        public let description: String?
        /// The type of the plugin.
        public let type: PluginType?

        @inlinable
        public init(category: PluginTypeCategory? = nil, description: String? = nil, type: PluginType? = nil) {
            self.category = category
            self.description = description
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case description = "description"
            case type = "type"
        }
    }

    public struct PrincipalGroup: AWSEncodableShape {
        /// Provides information about whether to allow or deny access to the principal.
        public let access: ReadAccessType
        /// The type of group.
        public let membershipType: MembershipType?
        /// The name of the group.
        public let name: String?

        @inlinable
        public init(access: ReadAccessType, membershipType: MembershipType? = nil, name: String? = nil) {
            self.access = access
            self.membershipType = membershipType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case access = "access"
            case membershipType = "membershipType"
            case name = "name"
        }
    }

    public struct PrincipalUser: AWSEncodableShape {
        /// Provides information about whether to allow or deny access to the principal.
        public let access: ReadAccessType
        ///  The identifier of the user.
        public let id: String?
        /// The type of group.
        public let membershipType: MembershipType?

        @inlinable
        public init(access: ReadAccessType, id: String? = nil, membershipType: MembershipType? = nil) {
            self.access = access
            self.id = id
            self.membershipType = membershipType
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 1024)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case access = "access"
            case id = "id"
            case membershipType = "membershipType"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        /// The identifier of the application associated with the feedback.
        public let applicationId: String
        /// The identifier of the conversation the feedback is attached to.
        public let conversationId: String
        /// The timestamp for when the feedback was recorded.
        public let messageCopiedAt: Date?
        /// The identifier of the chat message that the feedback was given for.
        public let messageId: String
        /// The feedback usefulness value given by the user to the chat message.
        public let messageUsefulness: MessageUsefulnessFeedback?
        /// The identifier of the user giving the feedback.
        public let userId: String?

        @inlinable
        public init(applicationId: String, conversationId: String, messageCopiedAt: Date? = nil, messageId: String, messageUsefulness: MessageUsefulnessFeedback? = nil, userId: String? = nil) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.messageCopiedAt = messageCopiedAt
            self.messageId = messageId
            self.messageUsefulness = messageUsefulness
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.conversationId, key: "conversationId")
            try container.encodeIfPresent(self.messageCopiedAt, forKey: .messageCopiedAt)
            request.encodePath(self.messageId, key: "messageId")
            try container.encodeIfPresent(self.messageUsefulness, forKey: .messageUsefulness)
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 36)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 36)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.messageUsefulness?.validate(name: "\(name).messageUsefulness")
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case messageCopiedAt = "messageCopiedAt"
            case messageUsefulness = "messageUsefulness"
        }
    }

    public struct PutGroupRequest: AWSEncodableShape {
        /// The identifier of the application in which the user and group mapping belongs.
        public let applicationId: String
        /// The identifier of the data source for which you want to map users to their groups. This is useful if a group is tied to multiple data sources, but you only want the group to access documents of a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. However, "Sales and Marketing" team only needs access to customer-related documents stored in Salesforce.
        public let dataSourceId: String?
        public let groupMembers: GroupMembers
        /// The list that contains your users or sub groups that belong the same group. For example, the group "Company" includes the user "CEO" and the sub groups "Research", "Engineering", and "Sales and Marketing".
        public let groupName: String
        /// The identifier of the index in which you want to map users to their groups.
        public let indexId: String
        /// The Amazon Resource Name (ARN) of an IAM role that has access to the S3 file that contains  your list of users that belong to a group.
        public let roleArn: String?
        /// The type of the group.
        public let type: MembershipType

        @inlinable
        public init(applicationId: String, dataSourceId: String? = nil, groupMembers: GroupMembers, groupName: String, indexId: String, roleArn: String? = nil, type: MembershipType) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.groupMembers = groupMembers
            self.groupName = groupName
            self.indexId = indexId
            self.roleArn = roleArn
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.dataSourceId, forKey: .dataSourceId)
            try container.encode(self.groupMembers, forKey: .groupMembers)
            try container.encode(self.groupName, forKey: .groupName)
            request.encodePath(self.indexId, key: "indexId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.groupMembers.validate(name: "\(name).groupMembers")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case groupMembers = "groupMembers"
            case groupName = "groupName"
            case roleArn = "roleArn"
            case type = "type"
        }
    }

    public struct PutGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct QAppsConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Status information about whether end users can create and use Amazon Q Apps in the web experience.
        public let qAppsControlMode: QAppsControlMode

        @inlinable
        public init(qAppsControlMode: QAppsControlMode) {
            self.qAppsControlMode = qAppsControlMode
        }

        private enum CodingKeys: String, CodingKey {
            case qAppsControlMode = "qAppsControlMode"
        }
    }

    public struct QuickSightConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The Amazon QuickSight namespace that is used as the identity provider. For more information about QuickSight namespaces, see  Namespace operations.
        public let clientNamespace: String

        @inlinable
        public init(clientNamespace: String) {
            self.clientNamespace = clientNamespace
        }

        public func validate(name: String) throws {
            try self.validate(self.clientNamespace, name: "clientNamespace", parent: name, max: 64)
            try self.validate(self.clientNamespace, name: "clientNamespace", parent: name, min: 1)
            try self.validate(self.clientNamespace, name: "clientNamespace", parent: name, pattern: "^[a-zA-Z0-9._-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientNamespace = "clientNamespace"
        }
    }

    public struct RelevantContent: AWSDecodableShape {
        /// The actual content of the relevant item.
        public let content: String?
        /// Additional attributes of the document containing the relevant content.
        public let documentAttributes: [DocumentAttribute]?
        /// The unique identifier of the document containing the relevant content.
        public let documentId: String?
        /// The title of the document containing the relevant content.
        public let documentTitle: String?
        /// The URI of the document containing the relevant content.
        public let documentUri: String?
        /// Attributes related to the relevance score of the content.
        public let scoreAttributes: ScoreAttributes?

        @inlinable
        public init(content: String? = nil, documentAttributes: [DocumentAttribute]? = nil, documentId: String? = nil, documentTitle: String? = nil, documentUri: String? = nil, scoreAttributes: ScoreAttributes? = nil) {
            self.content = content
            self.documentAttributes = documentAttributes
            self.documentId = documentId
            self.documentTitle = documentTitle
            self.documentUri = documentUri
            self.scoreAttributes = scoreAttributes
        }

        private enum CodingKeys: String, CodingKey {
            case content = "content"
            case documentAttributes = "documentAttributes"
            case documentId = "documentId"
            case documentTitle = "documentTitle"
            case documentUri = "documentUri"
            case scoreAttributes = "scoreAttributes"
        }
    }

    public struct Retriever: AWSDecodableShape {
        /// The identifier of the Amazon Q Business application using the retriever.
        public let applicationId: String?
        /// The name of your retriever.
        public let displayName: String?
        /// The identifier of the retriever used by your Amazon Q Business application.
        public let retrieverId: String?
        /// The status of your retriever.
        public let status: RetrieverStatus?
        /// The type of your retriever.
        public let type: RetrieverType?

        @inlinable
        public init(applicationId: String? = nil, displayName: String? = nil, retrieverId: String? = nil, status: RetrieverStatus? = nil, type: RetrieverType? = nil) {
            self.applicationId = applicationId
            self.displayName = displayName
            self.retrieverId = retrieverId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case displayName = "displayName"
            case retrieverId = "retrieverId"
            case status = "status"
            case type = "type"
        }
    }

    public struct RetrieverContentSource: AWSEncodableShape {
        /// The unique identifier of the retriever to use as the content source.
        public let retrieverId: String

        @inlinable
        public init(retrieverId: String) {
            self.retrieverId = retrieverId
        }

        public func validate(name: String) throws {
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, max: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, min: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case retrieverId = "retrieverId"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// Users and groups to be excluded from a rule.
        public let excludedUsersAndGroups: UsersAndGroups?
        /// Users and groups to be included in a rule.
        public let includedUsersAndGroups: UsersAndGroups?
        /// The configuration information for a rule.
        public let ruleConfiguration: RuleConfiguration?
        /// The type of rule.
        public let ruleType: RuleType

        @inlinable
        public init(excludedUsersAndGroups: UsersAndGroups? = nil, includedUsersAndGroups: UsersAndGroups? = nil, ruleConfiguration: RuleConfiguration? = nil, ruleType: RuleType) {
            self.excludedUsersAndGroups = excludedUsersAndGroups
            self.includedUsersAndGroups = includedUsersAndGroups
            self.ruleConfiguration = ruleConfiguration
            self.ruleType = ruleType
        }

        public func validate(name: String) throws {
            try self.excludedUsersAndGroups?.validate(name: "\(name).excludedUsersAndGroups")
            try self.includedUsersAndGroups?.validate(name: "\(name).includedUsersAndGroups")
            try self.ruleConfiguration?.validate(name: "\(name).ruleConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case excludedUsersAndGroups = "excludedUsersAndGroups"
            case includedUsersAndGroups = "includedUsersAndGroups"
            case ruleConfiguration = "ruleConfiguration"
            case ruleType = "ruleType"
        }
    }

    public struct S3: AWSEncodableShape & AWSDecodableShape {
        /// The name of the S3 bucket that contains the file.
        public let bucket: String
        /// The name of the file.
        public let key: String

        @inlinable
        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 1)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
        }
    }

    public struct SamlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The metadata XML that your IdP generated.
        public let metadataXML: String
        /// The Amazon Resource Name (ARN) of an IAM role assumed by users when they authenticate into their Amazon Q Business web experience, containing the relevant Amazon Q Business permissions for conversing with Amazon Q Business.
        public let roleArn: String
        /// The group attribute name in your IdP that maps to user groups.
        public let userGroupAttribute: String?
        /// The user attribute name in your IdP that maps to the user email.
        public let userIdAttribute: String

        @inlinable
        public init(metadataXML: String, roleArn: String, userGroupAttribute: String? = nil, userIdAttribute: String) {
            self.metadataXML = metadataXML
            self.roleArn = roleArn
            self.userGroupAttribute = userGroupAttribute
            self.userIdAttribute = userIdAttribute
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataXML, name: "metadataXML", parent: name, max: 10000000)
            try self.validate(self.metadataXML, name: "metadataXML", parent: name, min: 1000)
            try self.validate(self.metadataXML, name: "metadataXML", parent: name, pattern: "^.*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.userGroupAttribute, name: "userGroupAttribute", parent: name, max: 256)
            try self.validate(self.userGroupAttribute, name: "userGroupAttribute", parent: name, min: 1)
            try self.validate(self.userIdAttribute, name: "userIdAttribute", parent: name, max: 256)
            try self.validate(self.userIdAttribute, name: "userIdAttribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadataXML = "metadataXML"
            case roleArn = "roleArn"
            case userGroupAttribute = "userGroupAttribute"
            case userIdAttribute = "userIdAttribute"
        }
    }

    public struct SamlProviderConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The URL where Amazon Q Business end users will be redirected for authentication.
        public let authenticationUrl: String

        @inlinable
        public init(authenticationUrl: String) {
            self.authenticationUrl = authenticationUrl
        }

        public func validate(name: String) throws {
            try self.validate(self.authenticationUrl, name: "authenticationUrl", parent: name, max: 1284)
            try self.validate(self.authenticationUrl, name: "authenticationUrl", parent: name, min: 1)
            try self.validate(self.authenticationUrl, name: "authenticationUrl", parent: name, pattern: "^https://.*$")
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationUrl = "authenticationUrl"
        }
    }

    public struct ScoreAttributes: AWSDecodableShape {
        /// The confidence level of the relevance score.
        public let scoreConfidence: ScoreConfidence?

        @inlinable
        public init(scoreConfidence: ScoreConfidence? = nil) {
            self.scoreConfidence = scoreConfidence
        }

        private enum CodingKeys: String, CodingKey {
            case scoreConfidence = "scoreConfidence"
        }
    }

    public struct SearchRelevantContentRequest: AWSEncodableShape {
        /// The unique identifier of the Amazon Q Business application to search.
        public let applicationId: String
        public let attributeFilter: AttributeFilter?
        /// The source of content to search in.
        public let contentSource: ContentSource
        /// The maximum number of results to return.
        public let maxResults: Int?
        /// The token for the next set of results. (You received this token from a previous call.)
        public let nextToken: String?
        /// The text to search for.
        public let queryText: String

        @inlinable
        public init(applicationId: String, attributeFilter: AttributeFilter? = nil, contentSource: ContentSource, maxResults: Int? = nil, nextToken: String? = nil, queryText: String) {
            self.applicationId = applicationId
            self.attributeFilter = attributeFilter
            self.contentSource = contentSource
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.queryText = queryText
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.attributeFilter, forKey: .attributeFilter)
            try container.encode(self.contentSource, forKey: .contentSource)
            try container.encodeIfPresent(self.maxResults, forKey: .maxResults)
            try container.encodeIfPresent(self.nextToken, forKey: .nextToken)
            try container.encode(self.queryText, forKey: .queryText)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.attributeFilter?.validate(name: "\(name).attributeFilter")
            try self.contentSource.validate(name: "\(name).contentSource")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeFilter = "attributeFilter"
            case contentSource = "contentSource"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case queryText = "queryText"
        }
    }

    public struct SearchRelevantContentResponse: AWSDecodableShape {
        /// The token to use to retrieve the next set of results, if there are any.
        public let nextToken: String?
        /// The list of relevant content items found.
        public let relevantContent: [RelevantContent]?

        @inlinable
        public init(nextToken: String? = nil, relevantContent: [RelevantContent]? = nil) {
            self.nextToken = nextToken
            self.relevantContent = relevantContent
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case relevantContent = "relevantContent"
        }
    }

    public struct SnippetExcerpt: AWSDecodableShape {
        /// The relevant text excerpt from a source that was used to generate a citation text segment in an Amazon Q chat response.
        public let text: String?

        @inlinable
        public init(text: String? = nil) {
            self.text = text
        }

        private enum CodingKeys: String, CodingKey {
            case text = "text"
        }
    }

    public struct SourceAttribution: AWSDecodableShape {
        /// The number attached to a citation in an Amazon Q Business generated response.
        public let citationNumber: Int?
        /// The content extract from the document on which the generated response is based.
        public let snippet: String?
        /// A text extract from a source document that is used for source attribution.
        public let textMessageSegments: [TextSegment]?
        /// The title of the document which is the source for the Amazon Q Business generated response.
        public let title: String?
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public let updatedAt: Date?
        /// The URL of the document which is the source for the Amazon Q Business generated response.
        public let url: String?

        @inlinable
        public init(citationNumber: Int? = nil, snippet: String? = nil, textMessageSegments: [TextSegment]? = nil, title: String? = nil, updatedAt: Date? = nil, url: String? = nil) {
            self.citationNumber = citationNumber
            self.snippet = snippet
            self.textMessageSegments = textMessageSegments
            self.title = title
            self.updatedAt = updatedAt
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case citationNumber = "citationNumber"
            case snippet = "snippet"
            case textMessageSegments = "textMessageSegments"
            case title = "title"
            case updatedAt = "updatedAt"
            case url = "url"
        }
    }

    public struct StartDataSourceSyncJobRequest: AWSEncodableShape {
        /// The identifier of Amazon Q Business application the data source is connected to.
        public let applicationId: String
        ///  The identifier of the data source connector.
        public let dataSourceId: String
        /// The identifier of the index used with the data source connector.
        public let indexId: String

        @inlinable
        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartDataSourceSyncJobResponse: AWSDecodableShape {
        /// The identifier for a particular synchronization job.
        public let executionId: String?

        @inlinable
        public init(executionId: String? = nil) {
            self.executionId = executionId
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
        }
    }

    public struct StopDataSourceSyncJobRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application that the data source is connected to.
        public let applicationId: String
        ///  The identifier of the data source connector.
        public let dataSourceId: String
        /// The identifier of the index used with the Amazon Q Business data source connector.
        public let indexId: String

        @inlinable
        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopDataSourceSyncJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StringAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies specific values of a STRING type document attribute being boosted.
        public let attributeValueBoosting: [String: StringAttributeValueBoostingLevel]?
        /// Specifies how much a document attribute is boosted.
        public let boostingLevel: DocumentAttributeBoostingLevel

        @inlinable
        public init(attributeValueBoosting: [String: StringAttributeValueBoostingLevel]? = nil, boostingLevel: DocumentAttributeBoostingLevel) {
            self.attributeValueBoosting = attributeValueBoosting
            self.boostingLevel = boostingLevel
        }

        public func validate(name: String) throws {
            try self.attributeValueBoosting?.forEach {
                try validate($0.key, name: "attributeValueBoosting.key", parent: name, max: 2048)
                try validate($0.key, name: "attributeValueBoosting.key", parent: name, min: 1)
            }
            try self.validate(self.attributeValueBoosting, name: "attributeValueBoosting", parent: name, max: 10)
            try self.validate(self.attributeValueBoosting, name: "attributeValueBoosting", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeValueBoosting = "attributeValueBoosting"
            case boostingLevel = "boostingLevel"
        }
    }

    public struct StringListAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how much a document attribute is boosted.
        public let boostingLevel: DocumentAttributeBoostingLevel

        @inlinable
        public init(boostingLevel: DocumentAttributeBoostingLevel) {
            self.boostingLevel = boostingLevel
        }

        private enum CodingKeys: String, CodingKey {
            case boostingLevel = "boostingLevel"
        }
    }

    public struct Subscription: AWSDecodableShape {
        /// The type of your current Amazon Q Business subscription.
        public let currentSubscription: SubscriptionDetails?
        /// The type of the Amazon Q Business subscription for the next month.
        public let nextSubscription: SubscriptionDetails?
        /// The IAM Identity Center UserId or GroupId of a user or group in the IAM Identity Center instance connected to the Amazon Q Business application.
        public let principal: SubscriptionPrincipal?
        /// The Amazon Resource Name (ARN) of the Amazon Q Business subscription that was updated.
        public let subscriptionArn: String?
        /// The identifier of the Amazon Q Business subscription to be updated.
        public let subscriptionId: String?

        @inlinable
        public init(currentSubscription: SubscriptionDetails? = nil, nextSubscription: SubscriptionDetails? = nil, principal: SubscriptionPrincipal? = nil, subscriptionArn: String? = nil, subscriptionId: String? = nil) {
            self.currentSubscription = currentSubscription
            self.nextSubscription = nextSubscription
            self.principal = principal
            self.subscriptionArn = subscriptionArn
            self.subscriptionId = subscriptionId
        }

        private enum CodingKeys: String, CodingKey {
            case currentSubscription = "currentSubscription"
            case nextSubscription = "nextSubscription"
            case principal = "principal"
            case subscriptionArn = "subscriptionArn"
            case subscriptionId = "subscriptionId"
        }
    }

    public struct SubscriptionDetails: AWSDecodableShape {
        ///  The type of an Amazon Q Business subscription.
        public let type: SubscriptionType?

        @inlinable
        public init(type: SubscriptionType? = nil) {
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        ///  The key for the tag. Keys are not case sensitive and must be unique for the Amazon Q Business application or data source.
        public let key: String
        /// The value associated with the tag. The value may be an empty string but it can't be null.
        public let value: String

        @inlinable
        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q Business application or data source to tag.
        public let resourceARN: String
        /// A list of tag keys to add to the Amazon Q Business application or data source. If a tag already exists, the existing value is replaced with the new value.
        public let tags: [Tag]

        @inlinable
        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextDocumentStatistics: AWSDecodableShape {
        /// The total size, in bytes, of the indexed documents.
        public let indexedTextBytes: Int64?
        /// The number of text documents indexed.
        public let indexedTextDocumentCount: Int?

        @inlinable
        public init(indexedTextBytes: Int64? = nil, indexedTextDocumentCount: Int? = nil) {
            self.indexedTextBytes = indexedTextBytes
            self.indexedTextDocumentCount = indexedTextDocumentCount
        }

        private enum CodingKeys: String, CodingKey {
            case indexedTextBytes = "indexedTextBytes"
            case indexedTextDocumentCount = "indexedTextDocumentCount"
        }
    }

    public struct TextInputEvent: AWSEncodableShape {
        /// A user message in a text message input event.
        public let userMessage: String

        @inlinable
        public init(userMessage: String) {
            self.userMessage = userMessage
        }

        private enum CodingKeys: String, CodingKey {
            case userMessage = "userMessage"
        }
    }

    public struct TextOutputEvent: AWSDecodableShape {
        /// The identifier of the conversation with which the text output event is associated.
        public let conversationId: String?
        /// An AI-generated message in a TextOutputEvent.
        public let systemMessage: String?
        /// The identifier of an AI-generated message in a TextOutputEvent.
        public let systemMessageId: String?
        /// The identifier of an end user message in a TextOutputEvent.
        public let userMessageId: String?

        @inlinable
        public init(conversationId: String? = nil, systemMessage: String? = nil, systemMessageId: String? = nil, userMessageId: String? = nil) {
            self.conversationId = conversationId
            self.systemMessage = systemMessage
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case systemMessage = "systemMessage"
            case systemMessageId = "systemMessageId"
            case userMessageId = "userMessageId"
        }
    }

    public struct TextSegment: AWSDecodableShape {
        /// The zero-based location in the response string where the source attribution starts.
        public let beginOffset: Int?
        /// The zero-based location in the response string where the source attribution ends.
        public let endOffset: Int?
        /// The identifier of the media object associated with the text segment in the source attribution.
        public let mediaId: String?
        /// The MIME type (image/png) of the media object associated with the text segment in the source attribution.
        public let mediaMimeType: String?
        /// The relevant text excerpt from a source that was used to generate a citation text segment in an Amazon Q Business chat response.
        public let snippetExcerpt: SnippetExcerpt?
        /// Source information for a segment of extracted text, including its media type.
        public let sourceDetails: SourceDetails?

        @inlinable
        public init(beginOffset: Int? = nil, endOffset: Int? = nil, snippetExcerpt: SnippetExcerpt? = nil, sourceDetails: SourceDetails? = nil) {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.mediaId = nil
            self.mediaMimeType = nil
            self.snippetExcerpt = snippetExcerpt
            self.sourceDetails = sourceDetails
        }

        @available(*, deprecated, message: "Members mediaId, mediaMimeType have been deprecated")
        @inlinable
        public init(beginOffset: Int? = nil, endOffset: Int? = nil, mediaId: String? = nil, mediaMimeType: String? = nil, snippetExcerpt: SnippetExcerpt? = nil, sourceDetails: SourceDetails? = nil) {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.mediaId = mediaId
            self.mediaMimeType = mediaMimeType
            self.snippetExcerpt = snippetExcerpt
            self.sourceDetails = sourceDetails
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "beginOffset"
            case endOffset = "endOffset"
            case mediaId = "mediaId"
            case mediaMimeType = "mediaMimeType"
            case snippetExcerpt = "snippetExcerpt"
            case sourceDetails = "sourceDetails"
        }
    }

    public struct TopicConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A description for your topic control configuration. Use this to outline how the large language model (LLM) should use this topic control configuration.
        public let description: String?
        /// A list of example phrases that you expect the end user to use in relation to the topic.
        public let exampleChatMessages: [String]?
        /// A name for your topic control configuration.
        public let name: String
        /// Rules defined for a topic configuration.
        public let rules: [Rule]

        @inlinable
        public init(description: String? = nil, exampleChatMessages: [String]? = nil, name: String, rules: [Rule]) {
            self.description = description
            self.exampleChatMessages = exampleChatMessages
            self.name = name
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 350)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.exampleChatMessages?.forEach {
                try validate($0, name: "exampleChatMessages[]", parent: name, max: 350)
                try validate($0, name: "exampleChatMessages[]", parent: name, pattern: "^\\P{C}*$")
            }
            try self.validate(self.exampleChatMessages, name: "exampleChatMessages", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{0,35}$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case exampleChatMessages = "exampleChatMessages"
            case name = "name"
            case rules = "rules"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q Business application, or data source to remove the tag from.
        public let resourceARN: String
        /// A list of tag keys to remove from the Amazon Q Business application or data source. If a tag key does not exist on the resource, it is ignored.
        public let tagKeys: [String]

        @inlinable
        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application.
        public let applicationId: String
        /// An option to allow end users to upload files directly during chat.
        public let attachmentsConfiguration: AttachmentsConfiguration?
        /// An option to enable updating the default subscription type assigned to an Amazon Q Business application using IAM identity federation for user management.
        public let autoSubscriptionConfiguration: AutoSubscriptionConfiguration?
        /// A description for the Amazon Q Business application.
        public let description: String?
        /// A name for the Amazon Q Business application.
        public let displayName: String?
        ///  The Amazon Resource Name (ARN) of the IAM Identity Center instance you are either creating for—or connecting to—your Amazon Q Business application.
        public let identityCenterInstanceArn: String?
        /// Configuration information about chat response personalization. For more information, see Personalizing chat responses.
        public let personalizationConfiguration: PersonalizationConfiguration?
        /// An option to allow end users to create and use Amazon Q Apps in the web experience.
        public let qAppsConfiguration: QAppsConfiguration?
        /// An Amazon Web Services Identity and Access Management (IAM) role that gives Amazon Q Business permission to access Amazon CloudWatch logs and metrics.
        public let roleArn: String?

        @inlinable
        public init(applicationId: String, attachmentsConfiguration: AttachmentsConfiguration? = nil, autoSubscriptionConfiguration: AutoSubscriptionConfiguration? = nil, description: String? = nil, displayName: String? = nil, identityCenterInstanceArn: String? = nil, personalizationConfiguration: PersonalizationConfiguration? = nil, qAppsConfiguration: QAppsConfiguration? = nil, roleArn: String? = nil) {
            self.applicationId = applicationId
            self.attachmentsConfiguration = attachmentsConfiguration
            self.autoSubscriptionConfiguration = autoSubscriptionConfiguration
            self.description = description
            self.displayName = displayName
            self.identityCenterInstanceArn = identityCenterInstanceArn
            self.personalizationConfiguration = personalizationConfiguration
            self.qAppsConfiguration = qAppsConfiguration
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.attachmentsConfiguration, forKey: .attachmentsConfiguration)
            try container.encodeIfPresent(self.autoSubscriptionConfiguration, forKey: .autoSubscriptionConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.identityCenterInstanceArn, forKey: .identityCenterInstanceArn)
            try container.encodeIfPresent(self.personalizationConfiguration, forKey: .personalizationConfiguration)
            try container.encodeIfPresent(self.qAppsConfiguration, forKey: .qAppsConfiguration)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.identityCenterInstanceArn, name: "identityCenterInstanceArn", parent: name, max: 1224)
            try self.validate(self.identityCenterInstanceArn, name: "identityCenterInstanceArn", parent: name, min: 10)
            try self.validate(self.identityCenterInstanceArn, name: "identityCenterInstanceArn", parent: name, pattern: "^arn:(aws|aws-us-gov|aws-cn|aws-iso|aws-iso-b):sso:::instance/(sso)?ins-[a-zA-Z0-9-.]{16}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsConfiguration = "attachmentsConfiguration"
            case autoSubscriptionConfiguration = "autoSubscriptionConfiguration"
            case description = "description"
            case displayName = "displayName"
            case identityCenterInstanceArn = "identityCenterInstanceArn"
            case personalizationConfiguration = "personalizationConfiguration"
            case qAppsConfiguration = "qAppsConfiguration"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateChatControlsConfigurationRequest: AWSEncodableShape {
        /// The identifier of the application for which the chat controls are configured.
        public let applicationId: String
        /// The phrases blocked from chat by your chat control configuration.
        public let blockedPhrasesConfigurationUpdate: BlockedPhrasesConfigurationUpdate?
        /// A token that you provide to identify the request to update a Amazon Q Business application chat configuration.
        public let clientToken: String?
        /// The configuration details for CREATOR_MODE.
        public let creatorModeConfiguration: CreatorModeConfiguration?
        ///  The chat response orchestration settings for your application.
        public let orchestrationConfiguration: OrchestrationConfiguration?
        /// The response scope configured for your application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
        public let responseScope: ResponseScope?
        /// The configured topic specific chat controls you want to update.
        public let topicConfigurationsToCreateOrUpdate: [TopicConfiguration]?
        /// The configured topic specific chat controls you want to delete.
        public let topicConfigurationsToDelete: [TopicConfiguration]?

        @inlinable
        public init(applicationId: String, blockedPhrasesConfigurationUpdate: BlockedPhrasesConfigurationUpdate? = nil, clientToken: String? = UpdateChatControlsConfigurationRequest.idempotencyToken(), creatorModeConfiguration: CreatorModeConfiguration? = nil, orchestrationConfiguration: OrchestrationConfiguration? = nil, responseScope: ResponseScope? = nil, topicConfigurationsToCreateOrUpdate: [TopicConfiguration]? = nil, topicConfigurationsToDelete: [TopicConfiguration]? = nil) {
            self.applicationId = applicationId
            self.blockedPhrasesConfigurationUpdate = blockedPhrasesConfigurationUpdate
            self.clientToken = clientToken
            self.creatorModeConfiguration = creatorModeConfiguration
            self.orchestrationConfiguration = orchestrationConfiguration
            self.responseScope = responseScope
            self.topicConfigurationsToCreateOrUpdate = topicConfigurationsToCreateOrUpdate
            self.topicConfigurationsToDelete = topicConfigurationsToDelete
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.blockedPhrasesConfigurationUpdate, forKey: .blockedPhrasesConfigurationUpdate)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.creatorModeConfiguration, forKey: .creatorModeConfiguration)
            try container.encodeIfPresent(self.orchestrationConfiguration, forKey: .orchestrationConfiguration)
            try container.encodeIfPresent(self.responseScope, forKey: .responseScope)
            try container.encodeIfPresent(self.topicConfigurationsToCreateOrUpdate, forKey: .topicConfigurationsToCreateOrUpdate)
            try container.encodeIfPresent(self.topicConfigurationsToDelete, forKey: .topicConfigurationsToDelete)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.blockedPhrasesConfigurationUpdate?.validate(name: "\(name).blockedPhrasesConfigurationUpdate")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.topicConfigurationsToCreateOrUpdate?.forEach {
                try $0.validate(name: "\(name).topicConfigurationsToCreateOrUpdate[]")
            }
            try self.validate(self.topicConfigurationsToCreateOrUpdate, name: "topicConfigurationsToCreateOrUpdate", parent: name, max: 10)
            try self.topicConfigurationsToDelete?.forEach {
                try $0.validate(name: "\(name).topicConfigurationsToDelete[]")
            }
            try self.validate(self.topicConfigurationsToDelete, name: "topicConfigurationsToDelete", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrasesConfigurationUpdate = "blockedPhrasesConfigurationUpdate"
            case clientToken = "clientToken"
            case creatorModeConfiguration = "creatorModeConfiguration"
            case orchestrationConfiguration = "orchestrationConfiguration"
            case responseScope = "responseScope"
            case topicConfigurationsToCreateOrUpdate = "topicConfigurationsToCreateOrUpdate"
            case topicConfigurationsToDelete = "topicConfigurationsToDelete"
        }
    }

    public struct UpdateChatControlsConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDataAccessorRequest: AWSEncodableShape {
        /// The updated list of action configurations specifying the allowed actions and any associated filters.
        public let actionConfigurations: [ActionConfiguration]
        /// The unique identifier of the Amazon Q Business application.
        public let applicationId: String
        /// The unique identifier of the data accessor to update.
        public let dataAccessorId: String
        /// The updated friendly name for the data accessor.
        public let displayName: String?

        @inlinable
        public init(actionConfigurations: [ActionConfiguration], applicationId: String, dataAccessorId: String, displayName: String? = nil) {
            self.actionConfigurations = actionConfigurations
            self.applicationId = applicationId
            self.dataAccessorId = dataAccessorId
            self.displayName = displayName
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actionConfigurations, forKey: .actionConfigurations)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataAccessorId, key: "dataAccessorId")
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
        }

        public func validate(name: String) throws {
            try self.actionConfigurations.forEach {
                try $0.validate(name: "\(name).actionConfigurations[]")
            }
            try self.validate(self.actionConfigurations, name: "actionConfigurations", parent: name, max: 10)
            try self.validate(self.actionConfigurations, name: "actionConfigurations", parent: name, min: 1)
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, max: 36)
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, min: 36)
            try self.validate(self.dataAccessorId, name: "dataAccessorId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case actionConfigurations = "actionConfigurations"
            case displayName = "displayName"
        }
    }

    public struct UpdateDataAccessorResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        ///  The identifier of the Amazon Q Business application the data source is attached to.
        public let applicationId: String
        public let configuration: AWSDocument?
        /// The identifier of the data source connector.
        public let dataSourceId: String
        /// The description of the data source connector.
        public let description: String?
        /// A name of the data source connector.
        public let displayName: String?
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// The identifier of the index attached to the data source connector.
        public let indexId: String
        /// The configuration for extracting information from media in documents for your data source.
        public let mediaExtractionConfiguration: MediaExtractionConfiguration?
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
        public let roleArn: String?
        /// The chosen update frequency for your data source.
        public let syncSchedule: String?
        public let vpcConfiguration: DataSourceVpcConfiguration?

        @inlinable
        public init(applicationId: String, configuration: AWSDocument? = nil, dataSourceId: String, description: String? = nil, displayName: String? = nil, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, indexId: String, mediaExtractionConfiguration: MediaExtractionConfiguration? = nil, roleArn: String? = nil, syncSchedule: String? = nil, vpcConfiguration: DataSourceVpcConfiguration? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.dataSourceId = dataSourceId
            self.description = description
            self.displayName = displayName
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.indexId = indexId
            self.mediaExtractionConfiguration = mediaExtractionConfiguration
            self.roleArn = roleArn
            self.syncSchedule = syncSchedule
            self.vpcConfiguration = vpcConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.documentEnrichmentConfiguration, forKey: .documentEnrichmentConfiguration)
            request.encodePath(self.indexId, key: "indexId")
            try container.encodeIfPresent(self.mediaExtractionConfiguration, forKey: .mediaExtractionConfiguration)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.syncSchedule, forKey: .syncSchedule)
            try container.encodeIfPresent(self.vpcConfiguration, forKey: .vpcConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.documentEnrichmentConfiguration?.validate(name: "\(name).documentEnrichmentConfiguration")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, max: 998)
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, pattern: "^[\\s\\S]*$")
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case displayName = "displayName"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case mediaExtractionConfiguration = "mediaExtractionConfiguration"
            case roleArn = "roleArn"
            case syncSchedule = "syncSchedule"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application connected to the index.
        public let applicationId: String
        /// The storage capacity units you want to provision for your Amazon Q Business index. You can add and remove capacity to fit your usage needs.
        public let capacityConfiguration: IndexCapacityConfiguration?
        /// The description of the Amazon Q Business index.
        public let description: String?
        /// The name of the Amazon Q Business index.
        public let displayName: String?
        /// Configuration information for document metadata or fields. Document metadata are fields or attributes associated with your documents. For example, the company department name associated with each document. For more information, see Understanding document attributes.
        public let documentAttributeConfigurations: [DocumentAttributeConfiguration]?
        /// The identifier of the Amazon Q Business index.
        public let indexId: String

        @inlinable
        public init(applicationId: String, capacityConfiguration: IndexCapacityConfiguration? = nil, description: String? = nil, displayName: String? = nil, documentAttributeConfigurations: [DocumentAttributeConfiguration]? = nil, indexId: String) {
            self.applicationId = applicationId
            self.capacityConfiguration = capacityConfiguration
            self.description = description
            self.displayName = displayName
            self.documentAttributeConfigurations = documentAttributeConfigurations
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.capacityConfiguration, forKey: .capacityConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.documentAttributeConfigurations, forKey: .documentAttributeConfigurations)
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.capacityConfiguration?.validate(name: "\(name).capacityConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.documentAttributeConfigurations?.forEach {
                try $0.validate(name: "\(name).documentAttributeConfigurations[]")
            }
            try self.validate(self.documentAttributeConfigurations, name: "documentAttributeConfigurations", parent: name, max: 500)
            try self.validate(self.documentAttributeConfigurations, name: "documentAttributeConfigurations", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityConfiguration = "capacityConfiguration"
            case description = "description"
            case displayName = "displayName"
            case documentAttributeConfigurations = "documentAttributeConfigurations"
        }
    }

    public struct UpdateIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePluginRequest: AWSEncodableShape {
        /// The identifier of the application the plugin is attached to.
        public let applicationId: String
        /// The authentication configuration the plugin is using.
        public let authConfiguration: PluginAuthConfiguration?
        /// The configuration for a custom plugin.
        public let customPluginConfiguration: CustomPluginConfiguration?
        /// The name of the plugin.
        public let displayName: String?
        /// The identifier of the plugin.
        public let pluginId: String
        /// The source URL used for plugin configuration.
        public let serverUrl: String?
        /// The status of the plugin.
        public let state: PluginState?

        @inlinable
        public init(applicationId: String, authConfiguration: PluginAuthConfiguration? = nil, customPluginConfiguration: CustomPluginConfiguration? = nil, displayName: String? = nil, pluginId: String, serverUrl: String? = nil, state: PluginState? = nil) {
            self.applicationId = applicationId
            self.authConfiguration = authConfiguration
            self.customPluginConfiguration = customPluginConfiguration
            self.displayName = displayName
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.authConfiguration, forKey: .authConfiguration)
            try container.encodeIfPresent(self.customPluginConfiguration, forKey: .customPluginConfiguration)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.pluginId, key: "pluginId")
            try container.encodeIfPresent(self.serverUrl, forKey: .serverUrl)
            try container.encodeIfPresent(self.state, forKey: .state)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.authConfiguration?.validate(name: "\(name).authConfiguration")
            try self.customPluginConfiguration?.validate(name: "\(name).customPluginConfiguration")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, max: 2048)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, min: 1)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, pattern: "^(https?|ftp|file)://([^\\s]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case authConfiguration = "authConfiguration"
            case customPluginConfiguration = "customPluginConfiguration"
            case displayName = "displayName"
            case serverUrl = "serverUrl"
            case state = "state"
        }
    }

    public struct UpdatePluginResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRetrieverRequest: AWSEncodableShape {
        /// The identifier of your Amazon Q Business application.
        public let applicationId: String
        public let configuration: RetrieverConfiguration?
        /// The name of your retriever.
        public let displayName: String?
        /// The identifier of your retriever.
        public let retrieverId: String
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access the retriever and required resources.
        public let roleArn: String?

        @inlinable
        public init(applicationId: String, configuration: RetrieverConfiguration? = nil, displayName: String? = nil, retrieverId: String, roleArn: String? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.displayName = displayName
            self.retrieverId = retrieverId
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.retrieverId, key: "retrieverId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, max: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, min: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case displayName = "displayName"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateRetrieverResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateSubscriptionRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application where the subscription update should take effect.
        public let applicationId: String
        /// The identifier of the Amazon Q Business subscription to be updated.
        public let subscriptionId: String
        /// The type of the Amazon Q Business subscription to be updated.
        public let type: SubscriptionType

        @inlinable
        public init(applicationId: String, subscriptionId: String, type: SubscriptionType) {
            self.applicationId = applicationId
            self.subscriptionId = subscriptionId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.subscriptionId, key: "subscriptionId")
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.subscriptionId, name: "subscriptionId", parent: name, max: 1224)
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
        }
    }

    public struct UpdateSubscriptionResponse: AWSDecodableShape {
        /// The type of your current Amazon Q Business subscription.
        public let currentSubscription: SubscriptionDetails?
        /// The type of the Amazon Q Business subscription for the next month.
        public let nextSubscription: SubscriptionDetails?
        /// The Amazon Resource Name (ARN) of the Amazon Q Business subscription that was updated.
        public let subscriptionArn: String?

        @inlinable
        public init(currentSubscription: SubscriptionDetails? = nil, nextSubscription: SubscriptionDetails? = nil, subscriptionArn: String? = nil) {
            self.currentSubscription = currentSubscription
            self.nextSubscription = nextSubscription
            self.subscriptionArn = subscriptionArn
        }

        private enum CodingKeys: String, CodingKey {
            case currentSubscription = "currentSubscription"
            case nextSubscription = "nextSubscription"
            case subscriptionArn = "subscriptionArn"
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        /// The identifier of the application the user is attached to.
        public let applicationId: String
        /// The user aliases attached to the user id that are to be deleted.
        public let userAliasesToDelete: [UserAlias]?
        /// The user aliases attached to the user id that are to be updated.
        public let userAliasesToUpdate: [UserAlias]?
        /// The email id attached to the user.
        public let userId: String

        @inlinable
        public init(applicationId: String, userAliasesToDelete: [UserAlias]? = nil, userAliasesToUpdate: [UserAlias]? = nil, userId: String) {
            self.applicationId = applicationId
            self.userAliasesToDelete = userAliasesToDelete
            self.userAliasesToUpdate = userAliasesToUpdate
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.userAliasesToDelete, forKey: .userAliasesToDelete)
            try container.encodeIfPresent(self.userAliasesToUpdate, forKey: .userAliasesToUpdate)
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.userAliasesToDelete?.forEach {
                try $0.validate(name: "\(name).userAliasesToDelete[]")
            }
            try self.userAliasesToUpdate?.forEach {
                try $0.validate(name: "\(name).userAliasesToUpdate[]")
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case userAliasesToDelete = "userAliasesToDelete"
            case userAliasesToUpdate = "userAliasesToUpdate"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        /// The user aliases that have been to be added to a user id.
        public let userAliasesAdded: [UserAlias]?
        /// The user aliases that have been deleted from a user id.
        public let userAliasesDeleted: [UserAlias]?
        /// The user aliases attached to a user id that have been updated.
        public let userAliasesUpdated: [UserAlias]?

        @inlinable
        public init(userAliasesAdded: [UserAlias]? = nil, userAliasesDeleted: [UserAlias]? = nil, userAliasesUpdated: [UserAlias]? = nil) {
            self.userAliasesAdded = userAliasesAdded
            self.userAliasesDeleted = userAliasesDeleted
            self.userAliasesUpdated = userAliasesUpdated
        }

        private enum CodingKeys: String, CodingKey {
            case userAliasesAdded = "userAliasesAdded"
            case userAliasesDeleted = "userAliasesDeleted"
            case userAliasesUpdated = "userAliasesUpdated"
        }
    }

    public struct UpdateWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q Business application attached to the web experience.
        public let applicationId: String
        /// The authentication configuration of the Amazon Q Business web experience.
        public let authenticationConfiguration: WebExperienceAuthConfiguration?
        /// The browser extension configuration for an Amazon Q Business web experience.   For Amazon Q Business application using external OIDC-compliant identity providers (IdPs). The IdP administrator must add the browser extension sign-in redirect URLs to the IdP application. For more information, see Configure external OIDC identity provider for your browser extensions..
        public let browserExtensionConfiguration: BrowserExtensionConfiguration?
        /// Updates the custom logo, favicon, font, and color used in the Amazon Q web experience.
        public let customizationConfiguration: CustomizationConfiguration?
        /// Information about the identity provider (IdP) used to authenticate end users of an Amazon Q Business web experience.
        public let identityProviderConfiguration: IdentityProviderConfiguration?
        /// Updates the website domain origins that  are allowed to embed the Amazon Q Business web experience.  The domain origin refers to the  base URL for accessing a website including the protocol  (http/https), the domain name, and the port number (if specified).    Any values except null submitted as part of this  update will replace all previous values.   You must only submit a base URL and  not a full path. For example, https://docs.aws.amazon.com.
        public let origins: [String]?
        /// The Amazon Resource Name (ARN) of the role with permission to access the Amazon Q Business web experience and required resources.
        public let roleArn: String?
        /// Determines whether sample prompts are enabled in the web experience for an end user.
        public let samplePromptsControlMode: WebExperienceSamplePromptsControlMode?
        /// The subtitle of the Amazon Q Business web experience.
        public let subtitle: String?
        /// The title of the Amazon Q Business web experience.
        public let title: String?
        /// The identifier of the Amazon Q Business web experience.
        public let webExperienceId: String
        /// A customized welcome message for an end user in an Amazon Q Business web experience.
        public let welcomeMessage: String?

        @inlinable
        public init(applicationId: String, browserExtensionConfiguration: BrowserExtensionConfiguration? = nil, customizationConfiguration: CustomizationConfiguration? = nil, identityProviderConfiguration: IdentityProviderConfiguration? = nil, origins: [String]? = nil, roleArn: String? = nil, samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, subtitle: String? = nil, title: String? = nil, webExperienceId: String, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.authenticationConfiguration = nil
            self.browserExtensionConfiguration = browserExtensionConfiguration
            self.customizationConfiguration = customizationConfiguration
            self.identityProviderConfiguration = identityProviderConfiguration
            self.origins = origins
            self.roleArn = roleArn
            self.samplePromptsControlMode = samplePromptsControlMode
            self.subtitle = subtitle
            self.title = title
            self.webExperienceId = webExperienceId
            self.welcomeMessage = welcomeMessage
        }

        @available(*, deprecated, message: "Members authenticationConfiguration have been deprecated")
        @inlinable
        public init(applicationId: String, authenticationConfiguration: WebExperienceAuthConfiguration? = nil, browserExtensionConfiguration: BrowserExtensionConfiguration? = nil, customizationConfiguration: CustomizationConfiguration? = nil, identityProviderConfiguration: IdentityProviderConfiguration? = nil, origins: [String]? = nil, roleArn: String? = nil, samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, subtitle: String? = nil, title: String? = nil, webExperienceId: String, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.authenticationConfiguration = authenticationConfiguration
            self.browserExtensionConfiguration = browserExtensionConfiguration
            self.customizationConfiguration = customizationConfiguration
            self.identityProviderConfiguration = identityProviderConfiguration
            self.origins = origins
            self.roleArn = roleArn
            self.samplePromptsControlMode = samplePromptsControlMode
            self.subtitle = subtitle
            self.title = title
            self.webExperienceId = webExperienceId
            self.welcomeMessage = welcomeMessage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.authenticationConfiguration, forKey: .authenticationConfiguration)
            try container.encodeIfPresent(self.browserExtensionConfiguration, forKey: .browserExtensionConfiguration)
            try container.encodeIfPresent(self.customizationConfiguration, forKey: .customizationConfiguration)
            try container.encodeIfPresent(self.identityProviderConfiguration, forKey: .identityProviderConfiguration)
            try container.encodeIfPresent(self.origins, forKey: .origins)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.samplePromptsControlMode, forKey: .samplePromptsControlMode)
            try container.encodeIfPresent(self.subtitle, forKey: .subtitle)
            try container.encodeIfPresent(self.title, forKey: .title)
            request.encodePath(self.webExperienceId, key: "webExperienceId")
            try container.encodeIfPresent(self.welcomeMessage, forKey: .welcomeMessage)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.authenticationConfiguration?.validate(name: "\(name).authenticationConfiguration")
            try self.browserExtensionConfiguration?.validate(name: "\(name).browserExtensionConfiguration")
            try self.customizationConfiguration?.validate(name: "\(name).customizationConfiguration")
            try self.identityProviderConfiguration?.validate(name: "\(name).identityProviderConfiguration")
            try self.origins?.forEach {
                try validate($0, name: "origins[]", parent: name, max: 256)
                try validate($0, name: "origins[]", parent: name, min: 1)
                try validate($0, name: "origins[]", parent: name, pattern: "^(http://|https://)[a-zA-Z0-9-_.]+(?::[0-9]{1,5})?$")
            }
            try self.validate(self.origins, name: "origins", parent: name, max: 10)
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.subtitle, name: "subtitle", parent: name, max: 500)
            try self.validate(self.subtitle, name: "subtitle", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.title, name: "title", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, max: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, min: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.welcomeMessage, name: "welcomeMessage", parent: name, max: 300)
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationConfiguration = "authenticationConfiguration"
            case browserExtensionConfiguration = "browserExtensionConfiguration"
            case customizationConfiguration = "customizationConfiguration"
            case identityProviderConfiguration = "identityProviderConfiguration"
            case origins = "origins"
            case roleArn = "roleArn"
            case samplePromptsControlMode = "samplePromptsControlMode"
            case subtitle = "subtitle"
            case title = "title"
            case welcomeMessage = "welcomeMessage"
        }
    }

    public struct UpdateWebExperienceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserAlias: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the data source that the user aliases are associated with.
        public let dataSourceId: String?
        /// The identifier of the index that the user aliases are associated with.
        public let indexId: String?
        /// The identifier of the user id associated with the user aliases.
        public let userId: String

        @inlinable
        public init(dataSourceId: String? = nil, indexId: String? = nil, userId: String) {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case indexId = "indexId"
            case userId = "userId"
        }
    }

    public struct UsersAndGroups: AWSEncodableShape & AWSDecodableShape {
        /// The user group names associated with a topic control rule.
        public let userGroups: [String]?
        /// The user ids associated with a topic control rule.
        public let userIds: [String]?

        @inlinable
        public init(userGroups: [String]? = nil, userIds: [String]? = nil) {
            self.userGroups = userGroups
            self.userIds = userIds
        }

        public func validate(name: String) throws {
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 2048)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.userIds?.forEach {
                try validate($0, name: "userIds[]", parent: name, max: 2048)
                try validate($0, name: "userIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userGroups = "userGroups"
            case userIds = "userIds"
        }
    }

    public struct VideoExtractionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The status of video extraction (ENABLED or DISABLED) for processing video content from files.
        public let videoExtractionStatus: VideoExtractionStatus

        @inlinable
        public init(videoExtractionStatus: VideoExtractionStatus) {
            self.videoExtractionStatus = videoExtractionStatus
        }

        private enum CodingKeys: String, CodingKey {
            case videoExtractionStatus = "videoExtractionStatus"
        }
    }

    public struct VideoSourceDetails: AWSDecodableShape {
        /// The ending timestamp in milliseconds for the relevant video segment.
        public let endTimeMilliseconds: Int64?
        /// Unique identifier for the video media file.
        public let mediaId: String?
        /// The MIME type of the video file (e.g., video/mp4, video/avi).
        public let mediaMimeType: String?
        /// The starting timestamp in milliseconds for the relevant video segment.
        public let startTimeMilliseconds: Int64?
        /// The type of video extraction performed on the content.
        public let videoExtractionType: VideoExtractionType?

        @inlinable
        public init(endTimeMilliseconds: Int64? = nil, mediaId: String? = nil, mediaMimeType: String? = nil, startTimeMilliseconds: Int64? = nil, videoExtractionType: VideoExtractionType? = nil) {
            self.endTimeMilliseconds = endTimeMilliseconds
            self.mediaId = mediaId
            self.mediaMimeType = mediaMimeType
            self.startTimeMilliseconds = startTimeMilliseconds
            self.videoExtractionType = videoExtractionType
        }

        private enum CodingKeys: String, CodingKey {
            case endTimeMilliseconds = "endTimeMilliseconds"
            case mediaId = "mediaId"
            case mediaMimeType = "mediaMimeType"
            case startTimeMilliseconds = "startTimeMilliseconds"
            case videoExtractionType = "videoExtractionType"
        }
    }

    public struct WebExperience: AWSDecodableShape {
        /// The Unix timestamp when the Amazon Q Business application was last updated.
        public let createdAt: Date?
        /// The endpoint URLs for your Amazon Q Business web experience. The URLs are unique and fully hosted by Amazon Web Services.
        public let defaultEndpoint: String?
        /// The status of your Amazon Q Business web experience.
        public let status: WebExperienceStatus?
        /// The Unix timestamp when your Amazon Q Business web experience was updated.
        public let updatedAt: Date?
        /// The identifier of your Amazon Q Business web experience.
        public let webExperienceId: String?

        @inlinable
        public init(createdAt: Date? = nil, defaultEndpoint: String? = nil, status: WebExperienceStatus? = nil, updatedAt: Date? = nil, webExperienceId: String? = nil) {
            self.createdAt = createdAt
            self.defaultEndpoint = defaultEndpoint
            self.status = status
            self.updatedAt = updatedAt
            self.webExperienceId = webExperienceId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case defaultEndpoint = "defaultEndpoint"
            case status = "status"
            case updatedAt = "updatedAt"
            case webExperienceId = "webExperienceId"
        }
    }

    public struct ChatModeConfiguration: AWSEncodableShape {
        /// Configuration information required to invoke chat in PLUGIN_MODE.
        public let pluginConfiguration: PluginConfiguration?

        @inlinable
        public init(pluginConfiguration: PluginConfiguration? = nil) {
            self.pluginConfiguration = pluginConfiguration
        }

        public func validate(name: String) throws {
            try self.pluginConfiguration?.validate(name: "\(name).pluginConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case pluginConfiguration = "pluginConfiguration"
        }
    }

    public struct ContentSource: AWSEncodableShape {
        /// The retriever to use as the content source.
        public let retriever: RetrieverContentSource?

        @inlinable
        public init(retriever: RetrieverContentSource? = nil) {
            self.retriever = retriever
        }

        public func validate(name: String) throws {
            try self.retriever?.validate(name: "\(name).retriever")
        }

        private enum CodingKeys: String, CodingKey {
            case retriever = "retriever"
        }
    }

    public struct CopyFromSource: AWSEncodableShape & AWSDecodableShape {
        /// A reference to an attachment in an existing conversation.
        public let conversation: ConversationSource?

        @inlinable
        public init(conversation: ConversationSource? = nil) {
            self.conversation = conversation
        }

        public func validate(name: String) throws {
            try self.conversation?.validate(name: "\(name).conversation")
        }

        private enum CodingKeys: String, CodingKey {
            case conversation = "conversation"
        }
    }

    public struct WebExperienceAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let samlConfiguration: SamlConfiguration?

        @inlinable
        public init(samlConfiguration: SamlConfiguration? = nil) {
            self.samlConfiguration = samlConfiguration
        }

        public func validate(name: String) throws {
            try self.samlConfiguration?.validate(name: "\(name).samlConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case samlConfiguration = "samlConfiguration"
        }
    }
}

// MARK: - Errors

/// Error enum for QBusiness
public struct QBusinessErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case externalResourceException = "ExternalResourceException"
        case internalServerException = "InternalServerException"
        case licenseNotFoundException = "LicenseNotFoundException"
        case mediaTooLargeException = "MediaTooLargeException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QBusiness
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  You don't have access to perform this action. Make sure you have the required permission policies and user accounts and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// You are trying to perform an action that conflicts with the current status of your resource. Fix any inconsistencies with your resources and try again.
    public static var conflictException: Self { .init(.conflictException) }
    /// An external resource that you configured with your application is returning errors and preventing this operation from succeeding. Fix those errors and try again.
    public static var externalResourceException: Self { .init(.externalResourceException) }
    /// An issue occurred with the internal server used for your Amazon Q Business service. Wait some minutes and try again, or contact Support for help.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// You don't have permissions to perform the action because your license is inactive. Ask your admin to activate your license and try again after your licence is active.
    public static var licenseNotFoundException: Self { .init(.licenseNotFoundException) }
    /// The requested media object is too large to be returned.
    public static var mediaTooLargeException: Self { .init(.mediaTooLargeException) }
    /// The application or plugin resource you want to use doesn’t exist. Make sure you have provided the correct resource and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded the set limits for your Amazon Q Business service.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to throttling. Reduce the number of requests and try again.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input doesn't meet the constraints set by the Amazon Q Business service. Provide the correct input and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension QBusinessErrorType: Equatable {
    public static func == (lhs: QBusinessErrorType, rhs: QBusinessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QBusinessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
