//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension QBusiness {
    // MARK: Enums

    public enum ActionPayloadFieldType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case array = "ARRAY"
        case boolean = "BOOLEAN"
        case number = "NUMBER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case failed = "FAILED"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum AttachmentsControlMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum AttributeType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case date = "DATE"
        case number = "NUMBER"
        case string = "STRING"
        case stringList = "STRING_LIST"
        public var description: String { return self.rawValue }
    }

    public enum AttributeValueOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        public var description: String { return self.rawValue }
    }

    public enum ContentType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case csv = "CSV"
        case html = "HTML"
        case json = "JSON"
        case md = "MD"
        case msExcel = "MS_EXCEL"
        case msWord = "MS_WORD"
        case pdf = "PDF"
        case plainText = "PLAIN_TEXT"
        case ppt = "PPT"
        case rtf = "RTF"
        case xml = "XML"
        case xslt = "XSLT"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pendingCreation = "PENDING_CREATION"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum DataSourceSyncJobStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case aborted = "ABORTED"
        case failed = "FAILED"
        case incomplete = "INCOMPLETE"
        case stopping = "STOPPING"
        case succeeded = "SUCCEEDED"
        case syncing = "SYNCING"
        case syncingIndexing = "SYNCING_INDEXING"
        public var description: String { return self.rawValue }
    }

    public enum DocumentAttributeBoostingLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case none = "NONE"
        case veryHigh = "VERY_HIGH"
        public var description: String { return self.rawValue }
    }

    public enum DocumentContentOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case delete = "DELETE"
        public var description: String { return self.rawValue }
    }

    public enum DocumentEnrichmentConditionOperator: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case beginsWith = "BEGINS_WITH"
        case contains = "CONTAINS"
        case equals = "EQUALS"
        case exists = "EXISTS"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEquals = "GREATER_THAN_OR_EQUALS"
        case lessThan = "LESS_THAN"
        case lessThanOrEquals = "LESS_THAN_OR_EQUALS"
        case notContains = "NOT_CONTAINS"
        case notEquals = "NOT_EQUALS"
        case notExists = "NOT_EXISTS"
        public var description: String { return self.rawValue }
    }

    public enum DocumentStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case deleting = "DELETING"
        case documentFailedToIndex = "DOCUMENT_FAILED_TO_INDEX"
        case failed = "FAILED"
        case indexed = "INDEXED"
        case processing = "PROCESSING"
        case received = "RECEIVED"
        case updated = "UPDATED"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case internalError = "InternalError"
        case invalidRequest = "InvalidRequest"
        case resourceInactive = "ResourceInactive"
        case resourceNotFound = "ResourceNotFound"
        public var description: String { return self.rawValue }
    }

    public enum GroupStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case deleted = "DELETED"
        case deleting = "DELETING"
        case failed = "FAILED"
        case processing = "PROCESSING"
        case succeeded = "SUCCEEDED"
        public var description: String { return self.rawValue }
    }

    public enum IndexStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case updating = "UPDATING"
        public var description: String { return self.rawValue }
    }

    public enum MemberRelation: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case and = "AND"
        case or = "OR"
        public var description: String { return self.rawValue }
    }

    public enum MembershipType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case datasource = "DATASOURCE"
        case index = "INDEX"
        public var description: String { return self.rawValue }
    }

    public enum MessageType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case system = "SYSTEM"
        case user = "USER"
        public var description: String { return self.rawValue }
    }

    public enum MessageUsefulness: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case notUseful = "NOT_USEFUL"
        case useful = "USEFUL"
        public var description: String { return self.rawValue }
    }

    public enum MessageUsefulnessReason: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case complete = "COMPLETE"
        case factuallyCorrect = "FACTUALLY_CORRECT"
        case harmfulOrUnsafe = "HARMFUL_OR_UNSAFE"
        case helpful = "HELPFUL"
        case incorrectOrMissingSources = "INCORRECT_OR_MISSING_SOURCES"
        case notBasedOnDocuments = "NOT_BASED_ON_DOCUMENTS"
        case notComplete = "NOT_COMPLETE"
        case notConcise = "NOT_CONCISE"
        case notFactuallyCorrect = "NOT_FACTUALLY_CORRECT"
        case notHelpful = "NOT_HELPFUL"
        case other = "OTHER"
        case relevantSources = "RELEVANT_SOURCES"
        public var description: String { return self.rawValue }
    }

    public enum NumberAttributeBoostingType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case prioritizeLargerValues = "PRIORITIZE_LARGER_VALUES"
        case prioritizeSmallerValues = "PRIORITIZE_SMALLER_VALUES"
        public var description: String { return self.rawValue }
    }

    public enum PluginState: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum PluginType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case jira = "JIRA"
        case salesforce = "SALESFORCE"
        case serviceNow = "SERVICE_NOW"
        case zendesk = "ZENDESK"
        public var description: String { return self.rawValue }
    }

    public enum ReadAccessType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case allow = "ALLOW"
        case deny = "DENY"
        public var description: String { return self.rawValue }
    }

    public enum ResponseScope: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case enterpriseContentOnly = "ENTERPRISE_CONTENT_ONLY"
        case extendedKnowledgeEnabled = "EXTENDED_KNOWLEDGE_ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum RetrieverStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case failed = "FAILED"
        public var description: String { return self.rawValue }
    }

    public enum RetrieverType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case kendraIndex = "KENDRA_INDEX"
        case nativeIndex = "NATIVE_INDEX"
        public var description: String { return self.rawValue }
    }

    public enum RuleType: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case contentBlockerRule = "CONTENT_BLOCKER_RULE"
        case contentRetrievalRule = "CONTENT_RETRIEVAL_RULE"
        public var description: String { return self.rawValue }
    }

    public enum Status: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum StringAttributeValueBoostingLevel: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case high = "HIGH"
        case low = "LOW"
        case medium = "MEDIUM"
        case veryHigh = "VERY_HIGH"
        public var description: String { return self.rawValue }
    }

    public enum WebExperienceSamplePromptsControlMode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum WebExperienceStatus: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case active = "ACTIVE"
        case creating = "CREATING"
        case deleting = "DELETING"
        case failed = "FAILED"
        case pendingAuthConfig = "PENDING_AUTH_CONFIG"
        public var description: String { return self.rawValue }
    }

    public enum DocumentAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Provides information on boosting DATE type document attributes.
        case dateConfiguration(DateAttributeBoostingConfiguration)
        /// Provides information on boosting NUMBER type document attributes.
        case numberConfiguration(NumberAttributeBoostingConfiguration)
        /// Provides information on boosting STRING type document attributes.
        case stringConfiguration(StringAttributeBoostingConfiguration)
        /// Provides information on boosting STRING_LIST type document attributes.
        case stringListConfiguration(StringListAttributeBoostingConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dateConfiguration:
                let value = try container.decode(DateAttributeBoostingConfiguration.self, forKey: .dateConfiguration)
                self = .dateConfiguration(value)
            case .numberConfiguration:
                let value = try container.decode(NumberAttributeBoostingConfiguration.self, forKey: .numberConfiguration)
                self = .numberConfiguration(value)
            case .stringConfiguration:
                let value = try container.decode(StringAttributeBoostingConfiguration.self, forKey: .stringConfiguration)
                self = .stringConfiguration(value)
            case .stringListConfiguration:
                let value = try container.decode(StringListAttributeBoostingConfiguration.self, forKey: .stringListConfiguration)
                self = .stringListConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dateConfiguration(let value):
                try container.encode(value, forKey: .dateConfiguration)
            case .numberConfiguration(let value):
                try container.encode(value, forKey: .numberConfiguration)
            case .stringConfiguration(let value):
                try container.encode(value, forKey: .stringConfiguration)
            case .stringListConfiguration(let value):
                try container.encode(value, forKey: .stringListConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .dateConfiguration(let value):
                try value.validate(name: "\(name).dateConfiguration")
            case .stringConfiguration(let value):
                try value.validate(name: "\(name).stringConfiguration")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dateConfiguration = "dateConfiguration"
            case numberConfiguration = "numberConfiguration"
            case stringConfiguration = "stringConfiguration"
            case stringListConfiguration = "stringListConfiguration"
        }
    }

    public enum DocumentAttributeValue: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A date expressed as an ISO 8601 string. It's important for the time zone to be included in the ISO 8601 date-time format. For example, 2012-03-25T12:30:10+01:00 is the ISO 8601 date-time format for March 25th 2012 at 12:30PM (plus 10 seconds) in Central European Time.
        case dateValue(Date)
        /// A long integer value.
        case longValue(Int64)
        /// A list of strings.
        case stringListValue([String])
        /// A string.
        case stringValue(String)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .dateValue:
                let value = try container.decode(Date.self, forKey: .dateValue)
                self = .dateValue(value)
            case .longValue:
                let value = try container.decode(Int64.self, forKey: .longValue)
                self = .longValue(value)
            case .stringListValue:
                let value = try container.decode([String].self, forKey: .stringListValue)
                self = .stringListValue(value)
            case .stringValue:
                let value = try container.decode(String.self, forKey: .stringValue)
                self = .stringValue(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .dateValue(let value):
                try container.encode(value, forKey: .dateValue)
            case .longValue(let value):
                try container.encode(value, forKey: .longValue)
            case .stringListValue(let value):
                try container.encode(value, forKey: .stringListValue)
            case .stringValue(let value):
                try container.encode(value, forKey: .stringValue)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .stringListValue(let value):
                try value.forEach {
                    try validate($0, name: "stringListValue[]", parent: name, max: 2048)
                    try validate($0, name: "stringListValue[]", parent: name, min: 1)
                }
            case .stringValue(let value):
                try self.validate(value, name: "stringValue", parent: name, max: 2048)
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case dateValue = "dateValue"
            case longValue = "longValue"
            case stringListValue = "stringListValue"
            case stringValue = "stringValue"
        }
    }

    public enum DocumentContent: AWSEncodableShape, Sendable {
        /// The contents of the document. Documents passed to the blob parameter must be base64 encoded. Your code might not need to encode the document file bytes if you're using an Amazon Web Services SDK to call Amazon Q APIs. If you are calling the Amazon Q endpoint directly using REST, you must base64 encode the contents before sending.
        case blob(AWSBase64Data)
        /// The path to the document in an Amazon S3 bucket.
        case s3(S3)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .blob(let value):
                try container.encode(value, forKey: .blob)
            case .s3(let value):
                try container.encode(value, forKey: .s3)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .s3(let value):
                try value.validate(name: "\(name).s3")
            default:
                break
            }
        }

        private enum CodingKeys: String, CodingKey {
            case blob = "blob"
            case s3 = "s3"
        }
    }

    public enum PluginAuthConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Information about the basic authentication credentials used to configure a plugin.
        case basicAuthConfiguration(BasicAuthConfiguration)
        /// Information about the OAuth 2.0 authentication credential/token used to configure a plugin.
        case oAuth2ClientCredentialConfiguration(OAuth2ClientCredentialConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .basicAuthConfiguration:
                let value = try container.decode(BasicAuthConfiguration.self, forKey: .basicAuthConfiguration)
                self = .basicAuthConfiguration(value)
            case .oAuth2ClientCredentialConfiguration:
                let value = try container.decode(OAuth2ClientCredentialConfiguration.self, forKey: .oAuth2ClientCredentialConfiguration)
                self = .oAuth2ClientCredentialConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .basicAuthConfiguration(let value):
                try container.encode(value, forKey: .basicAuthConfiguration)
            case .oAuth2ClientCredentialConfiguration(let value):
                try container.encode(value, forKey: .oAuth2ClientCredentialConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .basicAuthConfiguration(let value):
                try value.validate(name: "\(name).basicAuthConfiguration")
            case .oAuth2ClientCredentialConfiguration(let value):
                try value.validate(name: "\(name).oAuth2ClientCredentialConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case basicAuthConfiguration = "basicAuthConfiguration"
            case oAuth2ClientCredentialConfiguration = "oAuth2ClientCredentialConfiguration"
        }
    }

    public enum Principal: AWSEncodableShape, Sendable {
        ///  The group associated with the principal.
        case group(PrincipalGroup)
        /// The user associated with the principal.
        case user(PrincipalUser)

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .group(let value):
                try container.encode(value, forKey: .group)
            case .user(let value):
                try container.encode(value, forKey: .user)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .group(let value):
                try value.validate(name: "\(name).group")
            case .user(let value):
                try value.validate(name: "\(name).user")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case group = "group"
            case user = "user"
        }
    }

    public enum RetrieverConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// Provides information on how the Amazon Kendra index used as a retriever for your Amazon Q application is configured.
        case kendraIndexConfiguration(KendraIndexConfiguration)
        /// Provides information on how a Amazon Q index used as a retriever for your Amazon Q application is configured.
        case nativeIndexConfiguration(NativeIndexConfiguration)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .kendraIndexConfiguration:
                let value = try container.decode(KendraIndexConfiguration.self, forKey: .kendraIndexConfiguration)
                self = .kendraIndexConfiguration(value)
            case .nativeIndexConfiguration:
                let value = try container.decode(NativeIndexConfiguration.self, forKey: .nativeIndexConfiguration)
                self = .nativeIndexConfiguration(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .kendraIndexConfiguration(let value):
                try container.encode(value, forKey: .kendraIndexConfiguration)
            case .nativeIndexConfiguration(let value):
                try container.encode(value, forKey: .nativeIndexConfiguration)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .kendraIndexConfiguration(let value):
                try value.validate(name: "\(name).kendraIndexConfiguration")
            case .nativeIndexConfiguration(let value):
                try value.validate(name: "\(name).nativeIndexConfiguration")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case kendraIndexConfiguration = "kendraIndexConfiguration"
            case nativeIndexConfiguration = "nativeIndexConfiguration"
        }
    }

    public enum RuleConfiguration: AWSEncodableShape & AWSDecodableShape, Sendable {
        /// A rule for configuring how Amazon Q responds when it encounters a a blocked topic.
        case contentBlockerRule(ContentBlockerRule)
        case contentRetrievalRule(ContentRetrievalRule)

        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            guard container.allKeys.count == 1, let key = container.allKeys.first else {
                let context = DecodingError.Context(
                    codingPath: container.codingPath,
                    debugDescription: "Expected exactly one key, but got \(container.allKeys.count)"
                )
                throw DecodingError.dataCorrupted(context)
            }
            switch key {
            case .contentBlockerRule:
                let value = try container.decode(ContentBlockerRule.self, forKey: .contentBlockerRule)
                self = .contentBlockerRule(value)
            case .contentRetrievalRule:
                let value = try container.decode(ContentRetrievalRule.self, forKey: .contentRetrievalRule)
                self = .contentRetrievalRule(value)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case .contentBlockerRule(let value):
                try container.encode(value, forKey: .contentBlockerRule)
            case .contentRetrievalRule(let value):
                try container.encode(value, forKey: .contentRetrievalRule)
            }
        }

        public func validate(name: String) throws {
            switch self {
            case .contentBlockerRule(let value):
                try value.validate(name: "\(name).contentBlockerRule")
            case .contentRetrievalRule(let value):
                try value.validate(name: "\(name).contentRetrievalRule")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case contentBlockerRule = "contentBlockerRule"
            case contentRetrievalRule = "contentRetrievalRule"
        }
    }

    // MARK: Shapes

    public struct AccessConfiguration: AWSEncodableShape {
        /// A list of AccessControlList objects.
        public let accessControls: [AccessControl]
        /// Describes the member relation within the AccessControlList object.
        public let memberRelation: MemberRelation?

        public init(accessControls: [AccessControl], memberRelation: MemberRelation? = nil) {
            self.accessControls = accessControls
            self.memberRelation = memberRelation
        }

        public func validate(name: String) throws {
            try self.accessControls.forEach {
                try $0.validate(name: "\(name).accessControls[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case accessControls = "accessControls"
            case memberRelation = "memberRelation"
        }
    }

    public struct AccessControl: AWSEncodableShape {
        /// Describes the member relation within a principal list.
        public let memberRelation: MemberRelation?
        /// Contains a list of principals, where a principal can be either a USER or a GROUP. Each principal can be have the following type of document access: ALLOW or DENY.
        public let principals: [Principal]

        public init(memberRelation: MemberRelation? = nil, principals: [Principal]) {
            self.memberRelation = memberRelation
            self.principals = principals
        }

        public func validate(name: String) throws {
            try self.principals.forEach {
                try $0.validate(name: "\(name).principals[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case memberRelation = "memberRelation"
            case principals = "principals"
        }
    }

    public struct ActionExecution: AWSEncodableShape & AWSDecodableShape {
        /// A mapping of field names to the field values in input that an end user provides to Amazon Q requests to perform their plugin action.
        public let payload: [String: ActionExecutionPayloadField]
        /// A string used to retain information about the hierarchical contexts within an action execution event payload.
        public let payloadFieldNameSeparator: String
        /// The identifier of the plugin the action is attached to.
        public let pluginId: String

        public init(payload: [String: ActionExecutionPayloadField], payloadFieldNameSeparator: String, pluginId: String) {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
        }

        public func validate(name: String) throws {
            try self.payload.forEach {
                try validate($0.key, name: "payload.key", parent: name, min: 1)
            }
            try self.validate(self.payloadFieldNameSeparator, name: "payloadFieldNameSeparator", parent: name, max: 1)
            try self.validate(self.payloadFieldNameSeparator, name: "payloadFieldNameSeparator", parent: name, min: 1)
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case payloadFieldNameSeparator = "payloadFieldNameSeparator"
            case pluginId = "pluginId"
        }
    }

    public struct ActionExecutionPayloadField: AWSEncodableShape & AWSDecodableShape {
        /// The content of a user input field in an plugin action execution payload.
        public let value: String

        public init(value: String) {
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case value = "value"
        }
    }

    public struct ActionReview: AWSDecodableShape {
        /// Field values that an end user needs to provide to Amazon Q for Amazon Q to perform the requested plugin action.
        public let payload: [String: ActionReviewPayloadField]?
        /// A string used to retain information about the hierarchical contexts within an action review payload.
        public let payloadFieldNameSeparator: String?
        /// The identifier of the plugin associated with the action review.
        public let pluginId: String?
        /// The type of plugin.
        public let pluginType: PluginType?

        public init(payload: [String: ActionReviewPayloadField]? = nil, payloadFieldNameSeparator: String? = nil, pluginId: String? = nil, pluginType: PluginType? = nil) {
            self.payload = payload
            self.payloadFieldNameSeparator = payloadFieldNameSeparator
            self.pluginId = pluginId
            self.pluginType = pluginType
        }

        private enum CodingKeys: String, CodingKey {
            case payload = "payload"
            case payloadFieldNameSeparator = "payloadFieldNameSeparator"
            case pluginId = "pluginId"
            case pluginType = "pluginType"
        }
    }

    public struct ActionReviewPayloadField: AWSDecodableShape {
        /// Information about the field values that an end user can use to provide to Amazon Q for Amazon Q to perform the requested plugin action.
        public let allowedValues: [ActionReviewPayloadFieldAllowedValue]?
        ///  The name of the field.
        public let displayName: String?
        /// The display order of fields in a payload.
        public let displayOrder: Int?
        /// Information about whether the field is required.
        public let required: Bool?
        /// The type of field.
        public let type: ActionPayloadFieldType?
        /// The field value.
        public let value: String?

        public init(allowedValues: [ActionReviewPayloadFieldAllowedValue]? = nil, displayName: String? = nil, displayOrder: Int? = nil, required: Bool? = nil, type: ActionPayloadFieldType? = nil, value: String? = nil) {
            self.allowedValues = allowedValues
            self.displayName = displayName
            self.displayOrder = displayOrder
            self.required = required
            self.type = type
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case allowedValues = "allowedValues"
            case displayName = "displayName"
            case displayOrder = "displayOrder"
            case required = "required"
            case type = "type"
            case value = "value"
        }
    }

    public struct ActionReviewPayloadFieldAllowedValue: AWSDecodableShape {
        /// The name of the field.
        public let displayValue: String?
        /// The field value.
        public let value: String?

        public init(displayValue: String? = nil, value: String? = nil) {
            self.displayValue = displayValue
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case displayValue = "displayValue"
            case value = "value"
        }
    }

    public struct Application: AWSDecodableShape {
        /// The identifier for the Amazon Q application.
        public let applicationId: String?
        /// The Unix timestamp when the Amazon Q application was created.
        public let createdAt: Date?
        /// The name of the Amazon Q application.
        public let displayName: String?
        /// The status of the Amazon Q application. The application is ready to use when the status is ACTIVE.
        public let status: ApplicationStatus?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public let updatedAt: Date?

        public init(applicationId: String? = nil, createdAt: Date? = nil, displayName: String? = nil, status: ApplicationStatus? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.createdAt = createdAt
            self.displayName = displayName
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct AppliedAttachmentsConfiguration: AWSDecodableShape {
        /// Information about whether file upload during chat functionality is activated for your application.
        public let attachmentsControlMode: AttachmentsControlMode?

        public init(attachmentsControlMode: AttachmentsControlMode? = nil) {
            self.attachmentsControlMode = attachmentsControlMode
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsControlMode = "attachmentsControlMode"
        }
    }

    public struct AttachmentInput: AWSEncodableShape {
        /// The data contained within the uploaded file.
        public let data: AWSBase64Data
        /// The name of the file.
        public let name: String

        public init(data: AWSBase64Data, name: String) {
            self.data = data
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 1000)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"
            case name = "name"
        }
    }

    public struct AttachmentOutput: AWSDecodableShape {
        /// An error associated with a file uploaded during chat.
        public let error: ErrorDetail?
        /// The name of a file uploaded during chat.
        public let name: String?
        /// The status of a file uploaded during chat.
        public let status: AttachmentStatus?

        public init(error: ErrorDetail? = nil, name: String? = nil, status: AttachmentStatus? = nil) {
            self.error = error
            self.name = name
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case error = "error"
            case name = "name"
            case status = "status"
        }
    }

    public struct AttachmentsConfiguration: AWSEncodableShape {
        /// Status information about whether file upload functionality is activated or deactivated for your end user.
        public let attachmentsControlMode: AttachmentsControlMode

        public init(attachmentsControlMode: AttachmentsControlMode) {
            self.attachmentsControlMode = attachmentsControlMode
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsControlMode = "attachmentsControlMode"
        }
    }

    public final class AttributeFilter: AWSEncodableShape {
        /// Performs a logical AND operation on all supplied filters.
        public let andAllFilters: [AttributeFilter]?
        /// Returns true when a document contains all the specified document attributes or metadata fields.
        public let containsAll: DocumentAttribute?
        /// Returns true when a document contains any of the specified document attributes or metadata fields.
        public let containsAny: DocumentAttribute?
        /// Performs an equals operation on two document attributes or metadata fields.
        public let equalsTo: DocumentAttribute?
        /// Performs a greater than operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public let greaterThan: DocumentAttribute?
        /// Performs a greater or equals than operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public let greaterThanOrEquals: DocumentAttribute?
        /// Performs a less than operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public let lessThan: DocumentAttribute?
        /// Performs a less than or equals operation on two document attributes or metadata fields. Use with a document attribute of type Date or Long.
        public let lessThanOrEquals: DocumentAttribute?
        /// Performs a logical NOT operation on all supplied filters.
        public let notFilter: AttributeFilter?
        ///  Performs a logical OR operation on all supplied filters.
        public let orAllFilters: [AttributeFilter]?

        public init(andAllFilters: [AttributeFilter]? = nil, containsAll: DocumentAttribute? = nil, containsAny: DocumentAttribute? = nil, equalsTo: DocumentAttribute? = nil, greaterThan: DocumentAttribute? = nil, greaterThanOrEquals: DocumentAttribute? = nil, lessThan: DocumentAttribute? = nil, lessThanOrEquals: DocumentAttribute? = nil, notFilter: AttributeFilter? = nil, orAllFilters: [AttributeFilter]? = nil) {
            self.andAllFilters = andAllFilters
            self.containsAll = containsAll
            self.containsAny = containsAny
            self.equalsTo = equalsTo
            self.greaterThan = greaterThan
            self.greaterThanOrEquals = greaterThanOrEquals
            self.lessThan = lessThan
            self.lessThanOrEquals = lessThanOrEquals
            self.notFilter = notFilter
            self.orAllFilters = orAllFilters
        }

        public func validate(name: String) throws {
            try self.andAllFilters?.forEach {
                try $0.validate(name: "\(name).andAllFilters[]")
            }
            try self.containsAll?.validate(name: "\(name).containsAll")
            try self.containsAny?.validate(name: "\(name).containsAny")
            try self.equalsTo?.validate(name: "\(name).equalsTo")
            try self.greaterThan?.validate(name: "\(name).greaterThan")
            try self.greaterThanOrEquals?.validate(name: "\(name).greaterThanOrEquals")
            try self.lessThan?.validate(name: "\(name).lessThan")
            try self.lessThanOrEquals?.validate(name: "\(name).lessThanOrEquals")
            try self.notFilter?.validate(name: "\(name).notFilter")
            try self.orAllFilters?.forEach {
                try $0.validate(name: "\(name).orAllFilters[]")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case andAllFilters = "andAllFilters"
            case containsAll = "containsAll"
            case containsAny = "containsAny"
            case equalsTo = "equalsTo"
            case greaterThan = "greaterThan"
            case greaterThanOrEquals = "greaterThanOrEquals"
            case lessThan = "lessThan"
            case lessThanOrEquals = "lessThanOrEquals"
            case notFilter = "notFilter"
            case orAllFilters = "orAllFilters"
        }
    }

    public struct BasicAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of an IAM role used by Amazon Q to access the basic authentication credentials stored in a Secrets Manager secret.
        public let roleArn: String
        /// The ARN of the Secrets Manager secret that stores the basic authentication credentials used for plugin configuration..
        public let secretArn: String

        public init(roleArn: String, secretArn: String) {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 1284)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case secretArn = "secretArn"
        }
    }

    public struct BatchDeleteDocumentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String
        /// The identifier of the data source sync during which the documents were deleted.
        public let dataSourceSyncId: String?
        /// Documents deleted from the Amazon Q index.
        public let documents: [DeleteDocument]
        /// The identifier of the Amazon Q index that contains the documents to delete.
        public let indexId: String

        public init(applicationId: String, dataSourceSyncId: String? = nil, documents: [DeleteDocument], indexId: String) {
            self.applicationId = applicationId
            self.dataSourceSyncId = dataSourceSyncId
            self.documents = documents
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.dataSourceSyncId, forKey: .dataSourceSyncId)
            try container.encode(self.documents, forKey: .documents)
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, max: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, min: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.documents.forEach {
                try $0.validate(name: "\(name).documents[]")
            }
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSyncId = "dataSourceSyncId"
            case documents = "documents"
        }
    }

    public struct BatchDeleteDocumentResponse: AWSDecodableShape {
        /// A list of documents that couldn't be removed from the Amazon Q index. Each entry contains an error message that indicates why the document couldn't be removed from the index.
        public let failedDocuments: [FailedDocument]?

        public init(failedDocuments: [FailedDocument]? = nil) {
            self.failedDocuments = failedDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case failedDocuments = "failedDocuments"
        }
    }

    public struct BatchPutDocumentRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String
        /// The identifier of the data source sync during which the documents were added.
        public let dataSourceSyncId: String?
        /// One or more documents to add to the index.
        public let documents: [Document]
        /// The identifier of the Amazon Q index to add the documents to.
        public let indexId: String
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access your S3 bucket.
        public let roleArn: String?

        public init(applicationId: String, dataSourceSyncId: String? = nil, documents: [Document], indexId: String, roleArn: String? = nil) {
            self.applicationId = applicationId
            self.dataSourceSyncId = dataSourceSyncId
            self.documents = documents
            self.indexId = indexId
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.dataSourceSyncId, forKey: .dataSourceSyncId)
            try container.encode(self.documents, forKey: .documents)
            request.encodePath(self.indexId, key: "indexId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, max: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, min: 36)
            try self.validate(self.dataSourceSyncId, name: "dataSourceSyncId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.documents.forEach {
                try $0.validate(name: "\(name).documents[]")
            }
            try self.validate(self.documents, name: "documents", parent: name, max: 10)
            try self.validate(self.documents, name: "documents", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceSyncId = "dataSourceSyncId"
            case documents = "documents"
            case roleArn = "roleArn"
        }
    }

    public struct BatchPutDocumentResponse: AWSDecodableShape {
        ///  A list of documents that were not added to the Amazon Q index because the document failed a validation check. Each document contains an error message that indicates why the document couldn't be added to the index.
        public let failedDocuments: [FailedDocument]?

        public init(failedDocuments: [FailedDocument]? = nil) {
            self.failedDocuments = failedDocuments
        }

        private enum CodingKeys: String, CodingKey {
            case failedDocuments = "failedDocuments"
        }
    }

    public struct BlockedPhrasesConfiguration: AWSDecodableShape {
        /// A list of phrases blocked from a Amazon Q web experience chat.
        public let blockedPhrases: [String]?
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public let systemMessageOverride: String?

        public init(blockedPhrases: [String]? = nil, systemMessageOverride: String? = nil) {
            self.blockedPhrases = blockedPhrases
            self.systemMessageOverride = systemMessageOverride
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrases = "blockedPhrases"
            case systemMessageOverride = "systemMessageOverride"
        }
    }

    public struct BlockedPhrasesConfigurationUpdate: AWSEncodableShape {
        /// Creates or updates a blocked phrases configuration in your Amazon Q application.
        public let blockedPhrasesToCreateOrUpdate: [String]?
        /// Deletes a blocked phrases configuration in your Amazon Q application.
        public let blockedPhrasesToDelete: [String]?
        /// The configured custom message displayed to your end user when they use blocked phrase during chat.
        public let systemMessageOverride: String?

        public init(blockedPhrasesToCreateOrUpdate: [String]? = nil, blockedPhrasesToDelete: [String]? = nil, systemMessageOverride: String? = nil) {
            self.blockedPhrasesToCreateOrUpdate = blockedPhrasesToCreateOrUpdate
            self.blockedPhrasesToDelete = blockedPhrasesToDelete
            self.systemMessageOverride = systemMessageOverride
        }

        public func validate(name: String) throws {
            try self.blockedPhrasesToCreateOrUpdate?.forEach {
                try validate($0, name: "blockedPhrasesToCreateOrUpdate[]", parent: name, max: 36)
                try validate($0, name: "blockedPhrasesToCreateOrUpdate[]", parent: name, pattern: "^\\P{C}*$")
            }
            try self.validate(self.blockedPhrasesToCreateOrUpdate, name: "blockedPhrasesToCreateOrUpdate", parent: name, max: 5)
            try self.blockedPhrasesToDelete?.forEach {
                try validate($0, name: "blockedPhrasesToDelete[]", parent: name, max: 36)
                try validate($0, name: "blockedPhrasesToDelete[]", parent: name, pattern: "^\\P{C}*$")
            }
            try self.validate(self.blockedPhrasesToDelete, name: "blockedPhrasesToDelete", parent: name, max: 5)
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, max: 350)
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrasesToCreateOrUpdate = "blockedPhrasesToCreateOrUpdate"
            case blockedPhrasesToDelete = "blockedPhrasesToDelete"
            case systemMessageOverride = "systemMessageOverride"
        }
    }

    public struct ChatSyncInput: AWSEncodableShape {
        /// A request from an end user to perform an Amazon Q plugin action.
        public let actionExecution: ActionExecution?
        /// The identifier of the Amazon Q application linked to the Amazon Q conversation.
        public let applicationId: String
        /// A list of files uploaded directly during chat. You can upload a maximum of 5 files of upto 10 MB each.
        public let attachments: [AttachmentInput]?
        /// Enables filtering of Amazon Q web experience responses based on document attributes or metadata fields.
        public let attributeFilter: AttributeFilter?
        /// A token that you provide to identify a chat request.
        public let clientToken: String?
        /// The identifier of the Amazon Q conversation.
        public let conversationId: String?
        /// The identifier of the previous end user text input message in a conversation.
        public let parentMessageId: String?
        /// The groups that a user associated with the chat input belongs to.
        public let userGroups: [String]?
        /// The identifier of the user attached to the chat input.
        public let userId: String
        /// A end user message in a conversation.
        public let userMessage: String?

        public init(actionExecution: ActionExecution? = nil, applicationId: String, attachments: [AttachmentInput]? = nil, attributeFilter: AttributeFilter? = nil, clientToken: String? = ChatSyncInput.idempotencyToken(), conversationId: String? = nil, parentMessageId: String? = nil, userGroups: [String]? = nil, userId: String, userMessage: String? = nil) {
            self.actionExecution = actionExecution
            self.applicationId = applicationId
            self.attachments = attachments
            self.attributeFilter = attributeFilter
            self.clientToken = clientToken
            self.conversationId = conversationId
            self.parentMessageId = parentMessageId
            self.userGroups = userGroups
            self.userId = userId
            self.userMessage = userMessage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actionExecution, forKey: .actionExecution)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.attachments, forKey: .attachments)
            try container.encodeIfPresent(self.attributeFilter, forKey: .attributeFilter)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.conversationId, forKey: .conversationId)
            try container.encodeIfPresent(self.parentMessageId, forKey: .parentMessageId)
            request.encodeQuery(self.userGroups, key: "userGroups")
            request.encodeQuery(self.userId, key: "userId")
            try container.encodeIfPresent(self.userMessage, forKey: .userMessage)
        }

        public func validate(name: String) throws {
            try self.actionExecution?.validate(name: "\(name).actionExecution")
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.attachments?.forEach {
                try $0.validate(name: "\(name).attachments[]")
            }
            try self.validate(self.attachments, name: "attachments", parent: name, min: 1)
            try self.attributeFilter?.validate(name: "\(name).attributeFilter")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, max: 36)
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, min: 36)
            try self.validate(self.parentMessageId, name: "parentMessageId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 2048)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.userMessage, name: "userMessage", parent: name, max: 7000)
            try self.validate(self.userMessage, name: "userMessage", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case actionExecution = "actionExecution"
            case attachments = "attachments"
            case attributeFilter = "attributeFilter"
            case clientToken = "clientToken"
            case conversationId = "conversationId"
            case parentMessageId = "parentMessageId"
            case userMessage = "userMessage"
        }
    }

    public struct ChatSyncOutput: AWSDecodableShape {
        /// A request from Amazon Q to the end user for information Amazon Q needs to successfully complete a requested plugin action.
        public let actionReview: ActionReview?
        /// The identifier of the Amazon Q conversation.
        public let conversationId: String?
        /// A list of files which failed to upload during chat.
        public let failedAttachments: [AttachmentOutput]?
        /// The source documents used to generate the conversation response.
        public let sourceAttributions: [SourceAttribution]?
        /// An AI-generated message in a conversation.
        public let systemMessage: String?
        /// The identifier of an Amazon Q AI generated message within the conversation.
        public let systemMessageId: String?
        /// The identifier of an Amazon Q end user text input message within the conversation.
        public let userMessageId: String?

        public init(actionReview: ActionReview? = nil, conversationId: String? = nil, failedAttachments: [AttachmentOutput]? = nil, sourceAttributions: [SourceAttribution]? = nil, systemMessage: String? = nil, systemMessageId: String? = nil, userMessageId: String? = nil) {
            self.actionReview = actionReview
            self.conversationId = conversationId
            self.failedAttachments = failedAttachments
            self.sourceAttributions = sourceAttributions
            self.systemMessage = systemMessage
            self.systemMessageId = systemMessageId
            self.userMessageId = userMessageId
        }

        private enum CodingKeys: String, CodingKey {
            case actionReview = "actionReview"
            case conversationId = "conversationId"
            case failedAttachments = "failedAttachments"
            case sourceAttributions = "sourceAttributions"
            case systemMessage = "systemMessage"
            case systemMessageId = "systemMessageId"
            case userMessageId = "userMessageId"
        }
    }

    public struct ContentBlockerRule: AWSEncodableShape & AWSDecodableShape {
        /// The configured custom message displayed to an end user informing them that they've used a blocked phrase during chat.
        public let systemMessageOverride: String?

        public init(systemMessageOverride: String? = nil) {
            self.systemMessageOverride = systemMessageOverride
        }

        public func validate(name: String) throws {
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, max: 350)
            try self.validate(self.systemMessageOverride, name: "systemMessageOverride", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case systemMessageOverride = "systemMessageOverride"
        }
    }

    public struct ContentRetrievalRule: AWSEncodableShape & AWSDecodableShape {
        /// Specifies data sources in a Amazon Q application to use for content generation.
        public let eligibleDataSources: [EligibleDataSource]?

        public init(eligibleDataSources: [EligibleDataSource]? = nil) {
            self.eligibleDataSources = eligibleDataSources
        }

        public func validate(name: String) throws {
            try self.eligibleDataSources?.forEach {
                try $0.validate(name: "\(name).eligibleDataSources[]")
            }
            try self.validate(self.eligibleDataSources, name: "eligibleDataSources", parent: name, max: 5)
        }

        private enum CodingKeys: String, CodingKey {
            case eligibleDataSources = "eligibleDataSources"
        }
    }

    public struct Conversation: AWSDecodableShape {
        /// The identifier of the Amazon Q conversation.
        public let conversationId: String?
        /// The start time of the conversation.
        public let startTime: Date?
        /// The title of the conversation.
        public let title: String?

        public init(conversationId: String? = nil, startTime: Date? = nil, title: String? = nil) {
            self.conversationId = conversationId
            self.startTime = startTime
            self.title = title
        }

        private enum CodingKeys: String, CodingKey {
            case conversationId = "conversationId"
            case startTime = "startTime"
            case title = "title"
        }
    }

    public struct CreateApplicationRequest: AWSEncodableShape {
        /// An option to allow end users to upload files directly during chat.
        public let attachmentsConfiguration: AttachmentsConfiguration?
        /// A token that you provide to identify the request to create your Amazon Q application.
        public let clientToken: String?
        /// A description for the Amazon Q application.
        public let description: String?
        /// A name for the Amazon Q application.
        public let displayName: String
        /// The identifier of the KMS key that is used to encrypt your data. Amazon Q doesn't support asymmetric keys.
        public let encryptionConfiguration: EncryptionConfiguration?
        ///  The Amazon Resource Name (ARN) of an IAM role with permissions to access your Amazon CloudWatch logs and metrics.
        public let roleArn: String
        /// A list of key-value pairs that identify or categorize your Amazon Q application. You can also use tags to help control access to the application. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?

        public init(attachmentsConfiguration: AttachmentsConfiguration? = nil, clientToken: String? = CreateApplicationRequest.idempotencyToken(), description: String? = nil, displayName: String, encryptionConfiguration: EncryptionConfiguration? = nil, roleArn: String, tags: [Tag]? = nil) {
            self.attachmentsConfiguration = attachmentsConfiguration
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.encryptionConfiguration = encryptionConfiguration
            self.roleArn = roleArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.encryptionConfiguration?.validate(name: "\(name).encryptionConfiguration")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsConfiguration = "attachmentsConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case displayName = "displayName"
            case encryptionConfiguration = "encryptionConfiguration"
            case roleArn = "roleArn"
            case tags = "tags"
        }
    }

    public struct CreateApplicationResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of the Amazon Q application.
        public let applicationArn: String?
        /// The identifier of the Amazon Q application.
        public let applicationId: String?

        public init(applicationArn: String? = nil, applicationId: String? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationId = "applicationId"
        }
    }

    public struct CreateDataSourceRequest: AWSEncodableShape {
        ///  The identifier of the Amazon Q application the data source will be attached to.
        public let applicationId: String
        /// A token you provide to identify a request to create a data source connector. Multiple calls to the CreateDataSource API with the same client token will create only one data source connector.
        public let clientToken: String?
        /// Configuration information to connect to your data source repository. For configuration templates for your specific data source, see Supported connectors.
        public let configuration: String
        /// A description for the data source connector.
        public let description: String?
        /// A name for the data source connector.
        public let displayName: String
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// The identifier of the index that you want to use with the data source connector.
        public let indexId: String
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
        public let roleArn: String?
        /// Sets the frequency for Amazon Q to check the documents in your data source repository and update your index. If you don't set a schedule, Amazon Q won't periodically update the index. Specify a cron- format schedule string or an empty string to indicate that the index is updated on demand. You can't specify the Schedule parameter when the Type parameter is set to CUSTOM. If you do, you receive a ValidationException exception.
        public let syncSchedule: String?
        /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source. For more information, see Using Amazon VPC with Amazon Q connectors.
        public let vpcConfiguration: DataSourceVpcConfiguration?

        public init(applicationId: String, clientToken: String? = CreateDataSourceRequest.idempotencyToken(), configuration: String, description: String? = nil, displayName: String, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, indexId: String, roleArn: String? = nil, syncSchedule: String? = nil, tags: [Tag]? = nil, vpcConfiguration: DataSourceVpcConfiguration? = nil) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.configuration = configuration
            self.description = description
            self.displayName = displayName
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.indexId = indexId
            self.roleArn = roleArn
            self.syncSchedule = syncSchedule
            self.tags = tags
            self.vpcConfiguration = vpcConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.documentEnrichmentConfiguration, forKey: .documentEnrichmentConfiguration)
            request.encodePath(self.indexId, key: "indexId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.syncSchedule, forKey: .syncSchedule)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.vpcConfiguration, forKey: .vpcConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.documentEnrichmentConfiguration?.validate(name: "\(name).documentEnrichmentConfiguration")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, max: 998)
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, pattern: "^\\P{C}*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case description = "description"
            case displayName = "displayName"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case roleArn = "roleArn"
            case syncSchedule = "syncSchedule"
            case tags = "tags"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct CreateDataSourceResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of a data source in an Amazon Q application.
        public let dataSourceArn: String?
        /// The identifier of the data source connector.
        public let dataSourceId: String?

        public init(dataSourceArn: String? = nil, dataSourceId: String? = nil) {
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceArn = "dataSourceArn"
            case dataSourceId = "dataSourceId"
        }
    }

    public struct CreateIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application using the index.
        public let applicationId: String
        /// The capacity units you want to provision for your index. You can add and remove capacity to fit your usage needs.
        public let capacityConfiguration: IndexCapacityConfiguration?
        /// A token that you provide to identify the request to create an index. Multiple calls to the CreateIndex API with the same client token will create only one index.
        public let clientToken: String?
        /// A description for the Amazon Q index.
        public let description: String?
        /// A name for the Amazon Q index.
        public let displayName: String
        /// A list of key-value pairs that identify or categorize the index. You can also use tags to help control access to the index. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?

        public init(applicationId: String, capacityConfiguration: IndexCapacityConfiguration? = nil, clientToken: String? = CreateIndexRequest.idempotencyToken(), description: String? = nil, displayName: String, tags: [Tag]? = nil) {
            self.applicationId = applicationId
            self.capacityConfiguration = capacityConfiguration
            self.clientToken = clientToken
            self.description = description
            self.displayName = displayName
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.capacityConfiguration, forKey: .capacityConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.capacityConfiguration?.validate(name: "\(name).capacityConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case capacityConfiguration = "capacityConfiguration"
            case clientToken = "clientToken"
            case description = "description"
            case displayName = "displayName"
            case tags = "tags"
        }
    }

    public struct CreateIndexResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Q index.
        public let indexArn: String?
        /// The identifier for the Amazon Q index.
        public let indexId: String?

        public init(indexArn: String? = nil, indexId: String? = nil) {
            self.indexArn = indexArn
            self.indexId = indexId
        }

        private enum CodingKeys: String, CodingKey {
            case indexArn = "indexArn"
            case indexId = "indexId"
        }
    }

    public struct CreatePluginRequest: AWSEncodableShape {
        /// The identifier of the application that will contain the plugin.
        public let applicationId: String
        public let authConfiguration: PluginAuthConfiguration
        /// A token that you provide to identify the request to create your Amazon Q plugin.
        public let clientToken: String?
        /// A the name for your plugin.
        public let displayName: String
        /// The source URL used for plugin configuration.
        public let serverUrl: String
        /// A list of key-value pairs that identify or categorize the data source connector. You can also use tags to help control access to the data source connector. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// The type of plugin you want to create.
        public let type: PluginType

        public init(applicationId: String, authConfiguration: PluginAuthConfiguration, clientToken: String? = CreatePluginRequest.idempotencyToken(), displayName: String, serverUrl: String, tags: [Tag]? = nil, type: PluginType) {
            self.applicationId = applicationId
            self.authConfiguration = authConfiguration
            self.clientToken = clientToken
            self.displayName = displayName
            self.serverUrl = serverUrl
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encode(self.authConfiguration, forKey: .authConfiguration)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encode(self.serverUrl, forKey: .serverUrl)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.authConfiguration.validate(name: "\(name).authConfiguration")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, max: 2048)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, min: 1)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, pattern: "^(https?|ftp|file)://([^\\s]*)$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case authConfiguration = "authConfiguration"
            case clientToken = "clientToken"
            case displayName = "displayName"
            case serverUrl = "serverUrl"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreatePluginResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of a plugin.
        public let pluginArn: String?
        /// The identifier of the plugin created.
        public let pluginId: String?

        public init(pluginArn: String? = nil, pluginId: String? = nil) {
            self.pluginArn = pluginArn
            self.pluginId = pluginId
        }

        private enum CodingKeys: String, CodingKey {
            case pluginArn = "pluginArn"
            case pluginId = "pluginId"
        }
    }

    public struct CreateRetrieverRequest: AWSEncodableShape {
        /// The identifier of your Amazon Q application.
        public let applicationId: String
        /// A token that you provide to identify the request to create your Amazon Q application retriever.
        public let clientToken: String?
        public let configuration: RetrieverConfiguration
        /// The name of your retriever.
        public let displayName: String
        /// The ARN of an IAM role used by Amazon Q to access the basic authentication credentials stored in a Secrets Manager secret.
        public let roleArn: String?
        /// A list of key-value pairs that identify or categorize the retriever. You can also use tags to help control access to the retriever. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// The type of retriever you are using.
        public let type: RetrieverType

        public init(applicationId: String, clientToken: String? = CreateRetrieverRequest.idempotencyToken(), configuration: RetrieverConfiguration, displayName: String, roleArn: String? = nil, tags: [Tag]? = nil, type: RetrieverType) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.configuration = configuration
            self.displayName = displayName
            self.roleArn = roleArn
            self.tags = tags
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encode(self.configuration, forKey: .configuration)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.configuration.validate(name: "\(name).configuration")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case configuration = "configuration"
            case displayName = "displayName"
            case roleArn = "roleArn"
            case tags = "tags"
            case type = "type"
        }
    }

    public struct CreateRetrieverResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of an IAM role associated with a retriever.
        public let retrieverArn: String?
        /// The identifier of the retriever you are using.
        public let retrieverId: String?

        public init(retrieverArn: String? = nil, retrieverId: String? = nil) {
            self.retrieverArn = retrieverArn
            self.retrieverId = retrieverId
        }

        private enum CodingKeys: String, CodingKey {
            case retrieverArn = "retrieverArn"
            case retrieverId = "retrieverId"
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// The identifier of the application for which the user mapping will be created.
        public let applicationId: String
        /// A token that you provide to identify the request to create your Amazon Q user mapping.
        public let clientToken: String?
        /// The list of user aliases in the mapping.
        public let userAliases: [UserAlias]?
        /// The user emails attached to a user mapping.
        public let userId: String

        public init(applicationId: String, clientToken: String? = CreateUserRequest.idempotencyToken(), userAliases: [UserAlias]? = nil, userId: String) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.userAliases = userAliases
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.userAliases, forKey: .userAliases)
            try container.encode(self.userId, forKey: .userId)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.userAliases?.forEach {
                try $0.validate(name: "\(name).userAliases[]")
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case userAliases = "userAliases"
            case userId = "userId"
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct CreateWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q web experience.
        public let applicationId: String
        /// A token you provide to identify a request to create an Amazon Q web experience.
        public let clientToken: String?
        /// Determines whether sample prompts are enabled in the web experience for an end user.
        public let samplePromptsControlMode: WebExperienceSamplePromptsControlMode?
        /// A subtitle to personalize your Amazon Q web experience.
        public let subtitle: String?
        /// A list of key-value pairs that identify or categorize your Amazon Q web experience. You can also use tags to help control access to the web experience. Tag keys and values can consist of Unicode letters, digits, white space, and any of the following symbols: _ . : / = + - @.
        public let tags: [Tag]?
        /// The title for your Amazon Q web experience.
        public let title: String?
        /// The customized welcome message for end users of an Amazon Q web experience.
        public let welcomeMessage: String?

        public init(applicationId: String, clientToken: String? = CreateWebExperienceRequest.idempotencyToken(), samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, subtitle: String? = nil, tags: [Tag]? = nil, title: String? = nil, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.clientToken = clientToken
            self.samplePromptsControlMode = samplePromptsControlMode
            self.subtitle = subtitle
            self.tags = tags
            self.title = title
            self.welcomeMessage = welcomeMessage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.samplePromptsControlMode, forKey: .samplePromptsControlMode)
            try container.encodeIfPresent(self.subtitle, forKey: .subtitle)
            try container.encodeIfPresent(self.tags, forKey: .tags)
            try container.encodeIfPresent(self.title, forKey: .title)
            try container.encodeIfPresent(self.welcomeMessage, forKey: .welcomeMessage)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.subtitle, name: "subtitle", parent: name, max: 500)
            try self.validate(self.subtitle, name: "subtitle", parent: name, pattern: "^\\P{C}*$")
            try self.tags?.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
            try self.validate(self.title, name: "title", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.welcomeMessage, name: "welcomeMessage", parent: name, max: 300)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "clientToken"
            case samplePromptsControlMode = "samplePromptsControlMode"
            case subtitle = "subtitle"
            case tags = "tags"
            case title = "title"
            case welcomeMessage = "welcomeMessage"
        }
    }

    public struct CreateWebExperienceResponse: AWSDecodableShape {
        ///  The Amazon Resource Name (ARN) of an Amazon Q web experience.
        public let webExperienceArn: String?
        /// The identifier of the Amazon Q web experience.
        public let webExperienceId: String?

        public init(webExperienceArn: String? = nil, webExperienceId: String? = nil) {
            self.webExperienceArn = webExperienceArn
            self.webExperienceId = webExperienceId
        }

        private enum CodingKeys: String, CodingKey {
            case webExperienceArn = "webExperienceArn"
            case webExperienceId = "webExperienceId"
        }
    }

    public struct DataSource: AWSDecodableShape {
        /// The Unix timestamp when the Amazon Q data source was created.
        public let createdAt: Date?
        /// The identifier of the Amazon Q data source.
        public let dataSourceId: String?
        /// The name of the Amazon Q data source.
        public let displayName: String?
        /// The status of the Amazon Q data source.
        public let status: DataSourceStatus?
        /// The type of the Amazon Q data source.
        public let type: String?
        /// The Unix timestamp when the Amazon Q data source was last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, dataSourceId: String? = nil, displayName: String? = nil, status: DataSourceStatus? = nil, type: String? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.dataSourceId = dataSourceId
            self.displayName = displayName
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case dataSourceId = "dataSourceId"
            case displayName = "displayName"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct DataSourceSyncJob: AWSDecodableShape {
        /// If the reason that the synchronization failed is due to an error with the underlying data source, this field contains a code that identifies the error.
        public let dataSourceErrorCode: String?
        /// The Unix timestamp when the synchronization job completed.
        public let endTime: Date?
        /// If the Status field is set to FAILED, the ErrorCode field indicates the reason the synchronization failed.
        public let error: ErrorDetail?
        /// The identifier of a data source synchronization job.
        public let executionId: String?
        /// Maps a batch delete document request to a specific data source sync job. This is optional and should only be supplied when documents are deleted by a data source connector.
        public let metrics: DataSourceSyncJobMetrics?
        /// The Unix time stamp when the data source synchronization job started.
        public let startTime: Date?
        /// The status of the synchronization job. When the Status field is set to SUCCEEDED, the synchronization job is done. If the status code is FAILED, the ErrorCode and ErrorMessage fields give you the reason for the failure.
        public let status: DataSourceSyncJobStatus?

        public init(dataSourceErrorCode: String? = nil, endTime: Date? = nil, error: ErrorDetail? = nil, executionId: String? = nil, metrics: DataSourceSyncJobMetrics? = nil, startTime: Date? = nil, status: DataSourceSyncJobStatus? = nil) {
            self.dataSourceErrorCode = dataSourceErrorCode
            self.endTime = endTime
            self.error = error
            self.executionId = executionId
            self.metrics = metrics
            self.startTime = startTime
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceErrorCode = "dataSourceErrorCode"
            case endTime = "endTime"
            case error = "error"
            case executionId = "executionId"
            case metrics = "metrics"
            case startTime = "startTime"
            case status = "status"
        }
    }

    public struct DataSourceSyncJobMetrics: AWSDecodableShape {
        /// The current count of documents added from the data source during the data source sync.
        public let documentsAdded: String?
        /// The current count of documents deleted from the data source during the data source sync.
        public let documentsDeleted: String?
        /// The current count of documents that failed to sync from the data source during the data source sync.
        public let documentsFailed: String?
        /// The current count of documents modified in the data source during the data source sync.
        public let documentsModified: String?
        /// The current count of documents crawled by the ongoing sync job in the data source.
        public let documentsScanned: String?

        public init(documentsAdded: String? = nil, documentsDeleted: String? = nil, documentsFailed: String? = nil, documentsModified: String? = nil, documentsScanned: String? = nil) {
            self.documentsAdded = documentsAdded
            self.documentsDeleted = documentsDeleted
            self.documentsFailed = documentsFailed
            self.documentsModified = documentsModified
            self.documentsScanned = documentsScanned
        }

        private enum CodingKeys: String, CodingKey {
            case documentsAdded = "documentsAdded"
            case documentsDeleted = "documentsDeleted"
            case documentsFailed = "documentsFailed"
            case documentsModified = "documentsModified"
            case documentsScanned = "documentsScanned"
        }
    }

    public struct DataSourceVpcConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A list of identifiers of security groups within your Amazon VPC. The security groups should enable Amazon Q to connect to the data source.
        public let securityGroupIds: [String]
        /// A list of identifiers for subnets within your Amazon VPC. The subnets should be able to connect to each other in the VPC, and they should have outgoing access to the Internet through a NAT device.
        public let subnetIds: [String]

        public init(securityGroupIds: [String], subnetIds: [String]) {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }

        public func validate(name: String) throws {
            try self.securityGroupIds.forEach {
                try validate($0, name: "securityGroupIds[]", parent: name, max: 200)
                try validate($0, name: "securityGroupIds[]", parent: name, min: 1)
                try validate($0, name: "securityGroupIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, max: 10)
            try self.validate(self.securityGroupIds, name: "securityGroupIds", parent: name, min: 1)
            try self.subnetIds.forEach {
                try validate($0, name: "subnetIds[]", parent: name, max: 200)
                try validate($0, name: "subnetIds[]", parent: name, min: 1)
                try validate($0, name: "subnetIds[]", parent: name, pattern: "^[-0-9a-zA-Z]+$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case securityGroupIds = "securityGroupIds"
            case subnetIds = "subnetIds"
        }
    }

    public struct DateAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the duration, in seconds, of a boost applies to a DATE type document attribute.
        public let boostingDurationInSeconds: Int64?
        /// Specifies how much a document attribute is boosted.
        public let boostingLevel: DocumentAttributeBoostingLevel

        public init(boostingDurationInSeconds: Int64? = nil, boostingLevel: DocumentAttributeBoostingLevel) {
            self.boostingDurationInSeconds = boostingDurationInSeconds
            self.boostingLevel = boostingLevel
        }

        public func validate(name: String) throws {
            try self.validate(self.boostingDurationInSeconds, name: "boostingDurationInSeconds", parent: name, max: 999999999)
            try self.validate(self.boostingDurationInSeconds, name: "boostingDurationInSeconds", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case boostingDurationInSeconds = "boostingDurationInSeconds"
            case boostingLevel = "boostingLevel"
        }
    }

    public struct DeleteApplicationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteChatControlsConfigurationRequest: AWSEncodableShape {
        /// The identifier of the application the chat controls have been configured for.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteChatControlsConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteConversationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application associated with the conversation.
        public let applicationId: String
        /// The identifier of the Amazon Q web experience conversation being deleted.
        public let conversationId: String
        /// The identifier of the user who is deleting the conversation.
        public let userId: String

        public init(applicationId: String, conversationId: String, userId: String) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.conversationId, key: "conversationId")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteConversationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDataSourceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application used with the data source connector.
        public let applicationId: String
        /// The identifier of the data source connector that you want to delete.
        public let dataSourceId: String
        /// The identifier of the index used with the data source connector.
        public let indexId: String

        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDataSourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteDocument: AWSEncodableShape {
        /// The identifier of the deleted document.
        public let documentId: String

        public init(documentId: String) {
            self.documentId = documentId
        }

        public func validate(name: String) throws {
            try self.validate(self.documentId, name: "documentId", parent: name, max: 1825)
            try self.validate(self.documentId, name: "documentId", parent: name, min: 1)
            try self.validate(self.documentId, name: "documentId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case documentId = "documentId"
        }
    }

    public struct DeleteGroupRequest: AWSEncodableShape {
        /// The identifier of the application in which the group mapping belongs.
        public let applicationId: String
        /// The identifier of the data source linked to the group A group can be tied to multiple data sources. You can delete a group from accessing documents in a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. You want to delete "Research" and "Engineering" groups from Salesforce, so that these groups cannot access customer-related documents stored in Salesforce. Only "Sales and Marketing" should access documents in the Salesforce data source.
        public let dataSourceId: String?
        /// The name of the group you want to delete.
        public let groupName: String
        /// The identifier of the index you want to delete the group from.
        public let indexId: String

        public init(applicationId: String, dataSourceId: String? = nil, groupName: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.groupName = groupName
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.groupName, key: "groupName")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application the Amazon Q index is linked to.
        public let applicationId: String
        /// The identifier of the Amazon Q index.
        public let indexId: String

        public init(applicationId: String, indexId: String) {
            self.applicationId = applicationId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeletePluginRequest: AWSEncodableShape {
        /// The identifier the application attached to the Amazon Q plugin.
        public let applicationId: String
        /// The identifier of the plugin being deleted.
        public let pluginId: String

        public init(applicationId: String, pluginId: String) {
            self.applicationId = applicationId
            self.pluginId = pluginId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.pluginId, key: "pluginId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePluginResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteRetrieverRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application using the retriever.
        public let applicationId: String
        /// The identifier of the retriever being deleted.
        public let retrieverId: String

        public init(applicationId: String, retrieverId: String) {
            self.applicationId = applicationId
            self.retrieverId = retrieverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.retrieverId, key: "retrieverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, max: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, min: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteRetrieverResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteUserRequest: AWSEncodableShape {
        /// The identifier of the application from which the user is being deleted.
        public let applicationId: String
        /// The user email being deleted.
        public let userId: String

        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteUserResponse: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application linked to the Amazon Q web experience.
        public let applicationId: String
        /// The identifier of the Amazon Q web experience being deleted.
        public let webExperienceId: String

        public init(applicationId: String, webExperienceId: String) {
            self.applicationId = applicationId
            self.webExperienceId = webExperienceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.webExperienceId, key: "webExperienceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, max: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, min: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteWebExperienceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Document: AWSEncodableShape {
        /// Configuration information for access permission to a document.
        public let accessConfiguration: AccessConfiguration?
        /// Custom attributes to apply to the document for refining Amazon Q web experience responses.
        public let attributes: [DocumentAttribute]?
        /// The contents of the document.
        public let content: DocumentContent?
        /// The file type of the document in the Blob field. If you want to index snippets or subsets of HTML documents instead of the entirety of the HTML documents, you add the HTML start and closing tags (&lt;HTML&gt;content&lt;/HTML&gt;) around the content.
        public let contentType: ContentType?
        /// The configuration information for altering document metadata and content during the document ingestion process.
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// The identifier of the document.
        public let id: String
        /// The title of the document.
        public let title: String?

        public init(accessConfiguration: AccessConfiguration? = nil, attributes: [DocumentAttribute]? = nil, content: DocumentContent? = nil, contentType: ContentType? = nil, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, id: String, title: String? = nil) {
            self.accessConfiguration = accessConfiguration
            self.attributes = attributes
            self.content = content
            self.contentType = contentType
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.id = id
            self.title = title
        }

        public func validate(name: String) throws {
            try self.accessConfiguration?.validate(name: "\(name).accessConfiguration")
            try self.attributes?.forEach {
                try $0.validate(name: "\(name).attributes[]")
            }
            try self.validate(self.attributes, name: "attributes", parent: name, max: 500)
            try self.validate(self.attributes, name: "attributes", parent: name, min: 1)
            try self.content?.validate(name: "\(name).content")
            try self.documentEnrichmentConfiguration?.validate(name: "\(name).documentEnrichmentConfiguration")
            try self.validate(self.id, name: "id", parent: name, max: 1825)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.title, name: "title", parent: name, max: 1024)
            try self.validate(self.title, name: "title", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case accessConfiguration = "accessConfiguration"
            case attributes = "attributes"
            case content = "content"
            case contentType = "contentType"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case id = "id"
            case title = "title"
        }
    }

    public struct DocumentAttribute: AWSEncodableShape {
        /// The identifier for the attribute.
        public let name: String
        /// The value of the attribute.
        public let value: DocumentAttributeValue

        public init(name: String, value: DocumentAttributeValue) {
            self.name = name
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 200)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
        }
    }

    public struct DocumentAttributeCondition: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Q currently doesn't support _document_body as an attribute key used for the condition.
        public let key: String
        /// The identifier of the document attribute used for the condition. For example, 'Source_URI' could be an identifier for the attribute or metadata field that contains source URIs associated with the documents. Amazon Kendra currently does not support _document_body as an attribute key used for the condition.
        public let `operator`: DocumentEnrichmentConditionOperator
        public let value: DocumentAttributeValue?

        public init(key: String, operator: DocumentEnrichmentConditionOperator, value: DocumentAttributeValue? = nil) {
            self.key = key
            self.`operator` = `operator`
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 200)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case `operator` = "operator"
            case value = "value"
        }
    }

    public struct DocumentAttributeConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The name of the document attribute.
        public let name: String?
        /// Information about whether the document attribute can be used by an end user to search for information on their web experience.
        public let search: Status?
        /// The type of document attribute.
        public let type: AttributeType?

        public init(name: String? = nil, search: Status? = nil, type: AttributeType? = nil) {
            self.name = name
            self.search = search
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 2048)
            try self.validate(self.name, name: "name", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case name = "name"
            case search = "search"
            case type = "type"
        }
    }

    public struct DocumentAttributeTarget: AWSEncodableShape & AWSDecodableShape {
        ///  TRUE to delete the existing target value for your specified target attribute key. You cannot create a target value and set this to TRUE.
        public let attributeValueOperator: AttributeValueOperator?
        /// The identifier of the target document attribute or metadata field. For example, 'Department' could be an identifier for the target attribute or metadata field that includes the department names associated with the documents.
        public let key: String
        public let value: DocumentAttributeValue?

        public init(attributeValueOperator: AttributeValueOperator? = nil, key: String, value: DocumentAttributeValue? = nil) {
            self.attributeValueOperator = attributeValueOperator
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 200)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.key, name: "key", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
            try self.value?.validate(name: "\(name).value")
        }

        private enum CodingKeys: String, CodingKey {
            case attributeValueOperator = "attributeValueOperator"
            case key = "key"
            case value = "value"
        }
    }

    public struct DocumentDetails: AWSDecodableShape {
        /// The timestamp for when the document was created.
        public let createdAt: Date?
        /// The identifier of the document.
        public let documentId: String?
        /// An error message associated with the document.
        public let error: ErrorDetail?
        /// The current status of the document.
        public let status: DocumentStatus?
        /// The timestamp for when the document was last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, documentId: String? = nil, error: ErrorDetail? = nil, status: DocumentStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.documentId = documentId
            self.error = error
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case documentId = "documentId"
            case error = "error"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct DocumentEnrichmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Configuration information to alter document attributes or metadata fields and content when ingesting documents into Amazon Q.
        public let inlineConfigurations: [InlineDocumentEnrichmentConfiguration]?
        public let postExtractionHookConfiguration: HookConfiguration?
        public let preExtractionHookConfiguration: HookConfiguration?

        public init(inlineConfigurations: [InlineDocumentEnrichmentConfiguration]? = nil, postExtractionHookConfiguration: HookConfiguration? = nil, preExtractionHookConfiguration: HookConfiguration? = nil) {
            self.inlineConfigurations = inlineConfigurations
            self.postExtractionHookConfiguration = postExtractionHookConfiguration
            self.preExtractionHookConfiguration = preExtractionHookConfiguration
        }

        public func validate(name: String) throws {
            try self.inlineConfigurations?.forEach {
                try $0.validate(name: "\(name).inlineConfigurations[]")
            }
            try self.validate(self.inlineConfigurations, name: "inlineConfigurations", parent: name, max: 100)
            try self.validate(self.inlineConfigurations, name: "inlineConfigurations", parent: name, min: 1)
            try self.postExtractionHookConfiguration?.validate(name: "\(name).postExtractionHookConfiguration")
            try self.preExtractionHookConfiguration?.validate(name: "\(name).preExtractionHookConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case inlineConfigurations = "inlineConfigurations"
            case postExtractionHookConfiguration = "postExtractionHookConfiguration"
            case preExtractionHookConfiguration = "preExtractionHookConfiguration"
        }
    }

    public struct EligibleDataSource: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the data source.
        public let dataSourceId: String?
        /// The identifier of the index the data source is attached to.
        public let indexId: String?

        public init(dataSourceId: String? = nil, indexId: String? = nil) {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case indexId = "indexId"
        }
    }

    public struct EncryptionConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the KMS key. Amazon Q doesn't support asymmetric keys.
        public let kmsKeyId: String?

        public init(kmsKeyId: String? = nil) {
            self.kmsKeyId = kmsKeyId
        }

        public func validate(name: String) throws {
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, max: 2048)
            try self.validate(self.kmsKeyId, name: "kmsKeyId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case kmsKeyId = "kmsKeyId"
        }
    }

    public struct ErrorDetail: AWSDecodableShape {
        /// The code associated with the data source sync error.
        public let errorCode: ErrorCode?
        /// The message explaining the data source sync error.
        public let errorMessage: String?

        public init(errorCode: ErrorCode? = nil, errorMessage: String? = nil) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCode = "errorCode"
            case errorMessage = "errorMessage"
        }
    }

    public struct FailedDocument: AWSDecodableShape {
        /// The identifier of the Amazon Q data source connector that contains the failed document.
        public let dataSourceId: String?
        /// An explanation for why the document couldn't be removed from the index.
        public let error: ErrorDetail?
        /// The identifier of the document that couldn't be removed from the Amazon Q index.
        public let id: String?

        public init(dataSourceId: String? = nil, error: ErrorDetail? = nil, id: String? = nil) {
            self.dataSourceId = dataSourceId
            self.error = error
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case error = "error"
            case id = "id"
        }
    }

    public struct GetApplicationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String

        public init(applicationId: String) {
            self.applicationId = applicationId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetApplicationResponse: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q application.
        public let applicationArn: String?
        /// The identifier of the Amazon Q application.
        public let applicationId: String?
        /// Settings for whether end users can upload files directly during chat.
        public let attachmentsConfiguration: AppliedAttachmentsConfiguration?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public let createdAt: Date?
        /// A description for the Amazon Q application.
        public let description: String?
        /// The name of the Amazon Q application.
        public let displayName: String?
        /// The identifier of the Amazon Web Services KMS key that is used to encrypt your data. Amazon Q doesn't support asymmetric keys.
        public let encryptionConfiguration: EncryptionConfiguration?
        /// If the Status field is set to ERROR, the ErrorMessage field contains a description of the error that caused the synchronization to fail.
        public let error: ErrorDetail?
        /// The Amazon Resource Name (ARN) of the IAM with permissions to access your CloudWatch logs and metrics.
        public let roleArn: String?
        /// The status of the Amazon Q application.
        public let status: ApplicationStatus?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public let updatedAt: Date?

        public init(applicationArn: String? = nil, applicationId: String? = nil, attachmentsConfiguration: AppliedAttachmentsConfiguration? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, encryptionConfiguration: EncryptionConfiguration? = nil, error: ErrorDetail? = nil, roleArn: String? = nil, status: ApplicationStatus? = nil, updatedAt: Date? = nil) {
            self.applicationArn = applicationArn
            self.applicationId = applicationId
            self.attachmentsConfiguration = attachmentsConfiguration
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.encryptionConfiguration = encryptionConfiguration
            self.error = error
            self.roleArn = roleArn
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationArn = "applicationArn"
            case applicationId = "applicationId"
            case attachmentsConfiguration = "attachmentsConfiguration"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case encryptionConfiguration = "encryptionConfiguration"
            case error = "error"
            case roleArn = "roleArn"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetChatControlsConfigurationRequest: AWSEncodableShape {
        /// The identifier of the application for which the chat controls are configured.
        public let applicationId: String
        /// The maximum number of configured chat controls to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q chat controls configured.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChatControlsConfigurationResponse: AWSDecodableShape {
        /// The phrases blocked from chat by your chat control configuration.
        public let blockedPhrases: BlockedPhrasesConfiguration?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q chat controls configured.
        public let nextToken: String?
        /// The response scope configured for a Amazon Q application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
        public let responseScope: ResponseScope?
        /// The topic specific controls configured for a Amazon Q application.
        public let topicConfigurations: [TopicConfiguration]?

        public init(blockedPhrases: BlockedPhrasesConfiguration? = nil, nextToken: String? = nil, responseScope: ResponseScope? = nil, topicConfigurations: [TopicConfiguration]? = nil) {
            self.blockedPhrases = blockedPhrases
            self.nextToken = nextToken
            self.responseScope = responseScope
            self.topicConfigurations = topicConfigurations
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrases = "blockedPhrases"
            case nextToken = "nextToken"
            case responseScope = "responseScope"
            case topicConfigurations = "topicConfigurations"
        }
    }

    public struct GetDataSourceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String
        /// The identifier of the data source connector.
        public let dataSourceId: String
        /// The identfier of the index used with the data source connector.
        public let indexId: String

        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataSourceResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String?
        /// The details of how the data source connector is configured.
        public let configuration: String?
        /// The Unix timestamp when the data source connector was created.
        public let createdAt: Date?
        /// The Amazon Resource Name (ARN) of the data source.
        public let dataSourceArn: String?
        /// The identifier of the data source connector.
        public let dataSourceId: String?
        /// The description for the data source connector.
        public let description: String?
        /// The name for the data source connector.
        public let displayName: String?
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let error: ErrorDetail?
        /// The identifier of the index linked to the data source connector.
        public let indexId: String?
        /// The Amazon Resource Name (ARN) of the role with permission to access the data source and required resources.
        public let roleArn: String?
        /// The current status of the data source connector. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let status: DataSourceStatus?
        /// The schedule for Amazon Q to update the index.
        public let syncSchedule: String?
        /// The type of the data source connector. For example, S3.
        public let type: String?
        /// The Unix timestamp when the data source connector was last updated.
        public let updatedAt: Date?
        /// Configuration information for an Amazon VPC (Virtual Private Cloud) to connect to your data source.
        public let vpcConfiguration: DataSourceVpcConfiguration?

        public init(applicationId: String? = nil, configuration: String? = nil, createdAt: Date? = nil, dataSourceArn: String? = nil, dataSourceId: String? = nil, description: String? = nil, displayName: String? = nil, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, error: ErrorDetail? = nil, indexId: String? = nil, roleArn: String? = nil, status: DataSourceStatus? = nil, syncSchedule: String? = nil, type: String? = nil, updatedAt: Date? = nil, vpcConfiguration: DataSourceVpcConfiguration? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.createdAt = createdAt
            self.dataSourceArn = dataSourceArn
            self.dataSourceId = dataSourceId
            self.description = description
            self.displayName = displayName
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.error = error
            self.indexId = indexId
            self.roleArn = roleArn
            self.status = status
            self.syncSchedule = syncSchedule
            self.type = type
            self.updatedAt = updatedAt
            self.vpcConfiguration = vpcConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case dataSourceArn = "dataSourceArn"
            case dataSourceId = "dataSourceId"
            case description = "description"
            case displayName = "displayName"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case error = "error"
            case indexId = "indexId"
            case roleArn = "roleArn"
            case status = "status"
            case syncSchedule = "syncSchedule"
            case type = "type"
            case updatedAt = "updatedAt"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct GetGroupRequest: AWSEncodableShape {
        /// The identifier of the application id the group is attached to.
        public let applicationId: String
        /// The identifier of the data source the group is attached to.
        public let dataSourceId: String?
        /// The name of the group.
        public let groupName: String
        /// The identifier of the index the group is attached to.
        public let indexId: String

        public init(applicationId: String, dataSourceId: String? = nil, groupName: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.groupName = groupName
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.groupName, key: "groupName")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGroupResponse: AWSDecodableShape {
        /// The current status of the group.
        public let status: GroupStatusDetail?
        /// The status history of the group.
        public let statusHistory: [GroupStatusDetail]?

        public init(status: GroupStatusDetail? = nil, statusHistory: [GroupStatusDetail]? = nil) {
            self.status = status
            self.statusHistory = statusHistory
        }

        private enum CodingKeys: String, CodingKey {
            case status = "status"
            case statusHistory = "statusHistory"
        }
    }

    public struct GetIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application connected to the index.
        public let applicationId: String
        /// The identifier of the Amazon Q index you want information on.
        public let indexId: String

        public init(applicationId: String, indexId: String) {
            self.applicationId = applicationId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetIndexResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q application associated with the index.
        public let applicationId: String?
        /// The storage capacity units chosen for your Amazon Q index.
        public let capacityConfiguration: IndexCapacityConfiguration?
        /// The Unix timestamp when the Amazon Q index was created.
        public let createdAt: Date?
        /// The description for the Amazon Q index.
        public let description: String?
        /// The name of the Amazon Q index.
        public let displayName: String?
        /// Configuration information for document attributes or metadata. Document metadata are fields associated with your documents. For example, the company department name associated with each document. For more information, see Understanding document attributes.
        public let documentAttributeConfigurations: [DocumentAttributeConfiguration]?
        /// When the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
        public let error: ErrorDetail?
        ///  The Amazon Resource Name (ARN) of the Amazon Q index.
        public let indexArn: String?
        /// The identifier of the Amazon Q index.
        public let indexId: String?
        /// Provides information about the number of documents indexed.
        public let indexStatistics: IndexStatistics?
        /// The current status of the index. When the value is ACTIVE, the index is ready for use. If the Status field value is FAILED, the ErrorMessage field contains a message that explains why.
        public let status: IndexStatus?
        /// The Unix timestamp when the Amazon Q index was last updated.
        public let updatedAt: Date?

        public init(applicationId: String? = nil, capacityConfiguration: IndexCapacityConfiguration? = nil, createdAt: Date? = nil, description: String? = nil, displayName: String? = nil, documentAttributeConfigurations: [DocumentAttributeConfiguration]? = nil, error: ErrorDetail? = nil, indexArn: String? = nil, indexId: String? = nil, indexStatistics: IndexStatistics? = nil, status: IndexStatus? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.capacityConfiguration = capacityConfiguration
            self.createdAt = createdAt
            self.description = description
            self.displayName = displayName
            self.documentAttributeConfigurations = documentAttributeConfigurations
            self.error = error
            self.indexArn = indexArn
            self.indexId = indexId
            self.indexStatistics = indexStatistics
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case capacityConfiguration = "capacityConfiguration"
            case createdAt = "createdAt"
            case description = "description"
            case displayName = "displayName"
            case documentAttributeConfigurations = "documentAttributeConfigurations"
            case error = "error"
            case indexArn = "indexArn"
            case indexId = "indexId"
            case indexStatistics = "indexStatistics"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetPluginRequest: AWSEncodableShape {
        /// The identifier of the application which contains the plugin.
        public let applicationId: String
        /// The identifier of the plugin.
        public let pluginId: String

        public init(applicationId: String, pluginId: String) {
            self.applicationId = applicationId
            self.pluginId = pluginId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.pluginId, key: "pluginId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPluginResponse: AWSDecodableShape {
        /// The identifier of the application which contains the plugin.
        public let applicationId: String?
        public let authConfiguration: PluginAuthConfiguration?
        /// The timestamp for when the plugin was created.
        public let createdAt: Date?
        /// The name of the plugin.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the role with permission to access resources needed to create the plugin.
        public let pluginArn: String?
        /// The identifier of the plugin.
        public let pluginId: String?
        /// The source URL used for plugin configuration.
        public let serverUrl: String?
        /// The current state of the plugin.
        public let state: PluginState?
        /// The type of the plugin.
        public let type: PluginType?
        /// The timestamp for when the plugin was last updated.
        public let updatedAt: Date?

        public init(applicationId: String? = nil, authConfiguration: PluginAuthConfiguration? = nil, createdAt: Date? = nil, displayName: String? = nil, pluginArn: String? = nil, pluginId: String? = nil, serverUrl: String? = nil, state: PluginState? = nil, type: PluginType? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.authConfiguration = authConfiguration
            self.createdAt = createdAt
            self.displayName = displayName
            self.pluginArn = pluginArn
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case authConfiguration = "authConfiguration"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case pluginArn = "pluginArn"
            case pluginId = "pluginId"
            case serverUrl = "serverUrl"
            case state = "state"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetRetrieverRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application using the retriever.
        public let applicationId: String
        /// The identifier of the retriever.
        public let retrieverId: String

        public init(applicationId: String, retrieverId: String) {
            self.applicationId = applicationId
            self.retrieverId = retrieverId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.retrieverId, key: "retrieverId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, max: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, min: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetRetrieverResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q application using the retriever.
        public let applicationId: String?
        public let configuration: RetrieverConfiguration?
        /// The Unix timestamp when the retriever was created.
        public let createdAt: Date?
        /// The name of the retriever.
        public let displayName: String?
        /// The Amazon Resource Name (ARN) of the IAM role associated with the retriever.
        public let retrieverArn: String?
        /// The identifier of the retriever.
        public let retrieverId: String?
        /// The Amazon Resource Name (ARN) of the role with the permission to access the retriever and required resources.
        public let roleArn: String?
        /// The status of the retriever.
        public let status: RetrieverStatus?
        /// The type of the retriever.
        public let type: RetrieverType?
        /// The Unix timestamp when the retriever was last updated.
        public let updatedAt: Date?

        public init(applicationId: String? = nil, configuration: RetrieverConfiguration? = nil, createdAt: Date? = nil, displayName: String? = nil, retrieverArn: String? = nil, retrieverId: String? = nil, roleArn: String? = nil, status: RetrieverStatus? = nil, type: RetrieverType? = nil, updatedAt: Date? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.createdAt = createdAt
            self.displayName = displayName
            self.retrieverArn = retrieverArn
            self.retrieverId = retrieverId
            self.roleArn = roleArn
            self.status = status
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case configuration = "configuration"
            case createdAt = "createdAt"
            case displayName = "displayName"
            case retrieverArn = "retrieverArn"
            case retrieverId = "retrieverId"
            case roleArn = "roleArn"
            case status = "status"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct GetUserRequest: AWSEncodableShape {
        /// The identifier of the application connected to the user.
        public let applicationId: String
        /// The user email address attached to the user.
        public let userId: String

        public init(applicationId: String, userId: String) {
            self.applicationId = applicationId
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserResponse: AWSDecodableShape {
        /// A list of user aliases attached to a user.
        public let userAliases: [UserAlias]?

        public init(userAliases: [UserAlias]? = nil) {
            self.userAliases = userAliases
        }

        private enum CodingKeys: String, CodingKey {
            case userAliases = "userAliases"
        }
    }

    public struct GetWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application linked to the web experience.
        public let applicationId: String
        /// The identifier of the Amazon Q web experience.
        public let webExperienceId: String

        public init(applicationId: String, webExperienceId: String) {
            self.applicationId = applicationId
            self.webExperienceId = webExperienceId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.webExperienceId, key: "webExperienceId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, max: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, min: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetWebExperienceResponse: AWSDecodableShape {
        /// The identifier of the Amazon Q application linked to the web experience.
        public let applicationId: String?
        /// The authentication configuration information for your Amazon Q web experience.
        public let authenticationConfiguration: WebExperienceAuthConfiguration?
        /// The Unix timestamp when the retriever was created.
        public let createdAt: Date?
        /// The endpoint of your Amazon Q web experience.
        public let defaultEndpoint: String?
        /// When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let error: ErrorDetail?
        /// Determines whether sample prompts are enabled in the web experience for an end user.
        public let samplePromptsControlMode: WebExperienceSamplePromptsControlMode?
        /// The current status of the Amazon Q web experience. When the Status field value is FAILED, the ErrorMessage field contains a description of the error that caused the data source connector to fail.
        public let status: WebExperienceStatus?
        /// The subtitle for your Amazon Q web experience.
        public let subtitle: String?
        /// The title for your Amazon Q web experience.
        public let title: String?
        /// The Unix timestamp when the data source connector was last updated.
        public let updatedAt: Date?
        /// The Amazon Resource Name (ARN) of the role with the permission to access the Amazon Q web experience and required resources.
        public let webExperienceArn: String?
        /// The identifier of the Amazon Q web experience.
        public let webExperienceId: String?
        /// The customized welcome message for end users of an Amazon Q web experience.
        public let welcomeMessage: String?

        public init(applicationId: String? = nil, authenticationConfiguration: WebExperienceAuthConfiguration? = nil, createdAt: Date? = nil, defaultEndpoint: String? = nil, error: ErrorDetail? = nil, samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, status: WebExperienceStatus? = nil, subtitle: String? = nil, title: String? = nil, updatedAt: Date? = nil, webExperienceArn: String? = nil, webExperienceId: String? = nil, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.authenticationConfiguration = authenticationConfiguration
            self.createdAt = createdAt
            self.defaultEndpoint = defaultEndpoint
            self.error = error
            self.samplePromptsControlMode = samplePromptsControlMode
            self.status = status
            self.subtitle = subtitle
            self.title = title
            self.updatedAt = updatedAt
            self.webExperienceArn = webExperienceArn
            self.webExperienceId = webExperienceId
            self.welcomeMessage = welcomeMessage
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case authenticationConfiguration = "authenticationConfiguration"
            case createdAt = "createdAt"
            case defaultEndpoint = "defaultEndpoint"
            case error = "error"
            case samplePromptsControlMode = "samplePromptsControlMode"
            case status = "status"
            case subtitle = "subtitle"
            case title = "title"
            case updatedAt = "updatedAt"
            case webExperienceArn = "webExperienceArn"
            case webExperienceId = "webExperienceId"
            case welcomeMessage = "welcomeMessage"
        }
    }

    public struct GroupMembers: AWSEncodableShape {
        /// A list of sub groups that belong to a group. For example, the sub groups "Research", "Engineering", and "Sales and Marketing" all belong to the group "Company".
        public let memberGroups: [MemberGroup]?
        /// A list of users that belong to a group. For example, a list of interns all belong to the "Interns" group.
        public let memberUsers: [MemberUser]?

        public init(memberGroups: [MemberGroup]? = nil, memberUsers: [MemberUser]? = nil) {
            self.memberGroups = memberGroups
            self.memberUsers = memberUsers
        }

        public func validate(name: String) throws {
            try self.memberGroups?.forEach {
                try $0.validate(name: "\(name).memberGroups[]")
            }
            try self.validate(self.memberGroups, name: "memberGroups", parent: name, max: 1000)
            try self.validate(self.memberGroups, name: "memberGroups", parent: name, min: 1)
            try self.memberUsers?.forEach {
                try $0.validate(name: "\(name).memberUsers[]")
            }
            try self.validate(self.memberUsers, name: "memberUsers", parent: name, max: 1000)
            try self.validate(self.memberUsers, name: "memberUsers", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case memberGroups = "memberGroups"
            case memberUsers = "memberUsers"
        }
    }

    public struct GroupStatusDetail: AWSDecodableShape {
        /// The details of an error associated a group status.
        public let errorDetail: ErrorDetail?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public let lastUpdatedAt: Date?
        /// The status of a group.
        public let status: GroupStatus?

        public init(errorDetail: ErrorDetail? = nil, lastUpdatedAt: Date? = nil, status: GroupStatus? = nil) {
            self.errorDetail = errorDetail
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case errorDetail = "errorDetail"
            case lastUpdatedAt = "lastUpdatedAt"
            case status = "status"
        }
    }

    public struct GroupSummary: AWSDecodableShape {
        /// The name of the group the summary information is for.
        public let groupName: String?

        public init(groupName: String? = nil) {
            self.groupName = groupName
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "groupName"
        }
    }

    public struct HookConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The condition used for when a Lambda function should be invoked. For example, you can specify a condition that if there are empty date-time values, then Amazon Q should invoke a function that inserts the current date-time.
        public let invocationCondition: DocumentAttributeCondition?
        /// The Amazon Resource Name (ARN) of a role with permission to run a Lambda function during ingestion. For more information, see IAM roles for Custom Document Enrichment (CDE).
        public let lambdaArn: String?
        /// The Amazon Resource Name (ARN) of a role with permission to run PreExtractionHookConfiguration and PostExtractionHookConfiguration for altering document metadata and content during the document ingestion process.
        public let roleArn: String?
        /// Stores the original, raw documents or the structured, parsed documents before and after altering them. For more information, see Data contracts for Lambda functions.
        public let s3BucketName: String?

        public init(invocationCondition: DocumentAttributeCondition? = nil, lambdaArn: String? = nil, roleArn: String? = nil, s3BucketName: String? = nil) {
            self.invocationCondition = invocationCondition
            self.lambdaArn = lambdaArn
            self.roleArn = roleArn
            self.s3BucketName = s3BucketName
        }

        public func validate(name: String) throws {
            try self.invocationCondition?.validate(name: "\(name).invocationCondition")
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, max: 2048)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, min: 1)
            try self.validate(self.lambdaArn, name: "lambdaArn", parent: name, pattern: "^arn:aws[a-zA-Z-]*:lambda:[a-z-]*-[0-9]:[0-9]{12}:function:[a-zA-Z0-9-_]+(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?(:[a-zA-Z0-9-_]+)?$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, max: 63)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, min: 1)
            try self.validate(self.s3BucketName, name: "s3BucketName", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
        }

        private enum CodingKeys: String, CodingKey {
            case invocationCondition = "invocationCondition"
            case lambdaArn = "lambdaArn"
            case roleArn = "roleArn"
            case s3BucketName = "s3BucketName"
        }
    }

    public struct Index: AWSDecodableShape {
        /// The Unix timestamp when the index was created.
        public let createdAt: Date?
        /// The name of the index.
        public let displayName: String?
        /// The identifier for the index.
        public let indexId: String?
        /// The current status of the index. When the status is ACTIVE, the index is ready.
        public let status: IndexStatus?
        /// The Unix timestamp when the index was last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, displayName: String? = nil, indexId: String? = nil, status: IndexStatus? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.displayName = displayName
            self.indexId = indexId
            self.status = status
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case displayName = "displayName"
            case indexId = "indexId"
            case status = "status"
            case updatedAt = "updatedAt"
        }
    }

    public struct IndexCapacityConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The number of storage units configured for an Amazon Q index.
        public let units: Int?

        public init(units: Int? = nil) {
            self.units = units
        }

        public func validate(name: String) throws {
            try self.validate(self.units, name: "units", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case units = "units"
        }
    }

    public struct IndexStatistics: AWSDecodableShape {
        /// The number of documents indexed.
        public let textDocumentStatistics: TextDocumentStatistics?

        public init(textDocumentStatistics: TextDocumentStatistics? = nil) {
            self.textDocumentStatistics = textDocumentStatistics
        }

        private enum CodingKeys: String, CodingKey {
            case textDocumentStatistics = "textDocumentStatistics"
        }
    }

    public struct InlineDocumentEnrichmentConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let condition: DocumentAttributeCondition?
        ///  TRUE to delete content if the condition used for the target attribute is met.
        public let documentContentOperator: DocumentContentOperator?
        public let target: DocumentAttributeTarget?

        public init(condition: DocumentAttributeCondition? = nil, documentContentOperator: DocumentContentOperator? = nil, target: DocumentAttributeTarget? = nil) {
            self.condition = condition
            self.documentContentOperator = documentContentOperator
            self.target = target
        }

        public func validate(name: String) throws {
            try self.condition?.validate(name: "\(name).condition")
            try self.target?.validate(name: "\(name).target")
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "condition"
            case documentContentOperator = "documentContentOperator"
            case target = "target"
        }
    }

    public struct KendraIndexConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the Amazon Kendra index.
        public let indexId: String

        public init(indexId: String) {
            self.indexId = indexId
        }

        public func validate(name: String) throws {
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case indexId = "indexId"
        }
    }

    public struct ListApplicationsRequest: AWSEncodableShape {
        /// The maximum number of Amazon Q applications to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q applications.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListApplicationsResponse: AWSDecodableShape {
        /// An array of summary information on the configuration of one or more Amazon Q applications.
        public let applications: [Application]?
        /// If the response is truncated, Amazon Q returns this token. You can use this token in a subsequent request to retrieve the next set of applications.
        public let nextToken: String?

        public init(applications: [Application]? = nil, nextToken: String? = nil) {
            self.applications = applications
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case applications = "applications"
            case nextToken = "nextToken"
        }
    }

    public struct ListConversationsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String
        /// The maximum number of Amazon Q conversations to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q conversations.
        public let nextToken: String?
        /// The identifier of the user involved in the Amazon Q web experience conversation.
        public let userId: String

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil, userId: String) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListConversationsResponse: AWSDecodableShape {
        /// An array of summary information on the configuration of one or more Amazon Q web experiences.
        public let conversations: [Conversation]?
        /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of messages.
        public let nextToken: String?

        public init(conversations: [Conversation]? = nil, nextToken: String? = nil) {
            self.conversations = conversations
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case conversations = "conversations"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourceSyncJobsRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application connected to the data source.
        public let applicationId: String
        ///  The identifier of the data source connector.
        public let dataSourceId: String
        ///  The end time of the data source connector sync.
        public let endTime: Date?
        /// The identifier of the index used with the Amazon Q data source connector.
        public let indexId: String
        /// The maximum number of synchronization jobs to return in the response.
        public let maxResults: Int?
        /// If the maxResults response was incpmplete because there is more data to retriever, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of responses.
        public let nextToken: String?
        ///  The start time of the data source connector sync.
        public let startTime: Date?
        /// Only returns synchronization jobs with the Status field equal to the specified status.
        public let statusFilter: DataSourceSyncJobStatus?

        public init(applicationId: String, dataSourceId: String, endTime: Date? = nil, indexId: String, maxResults: Int? = nil, nextToken: String? = nil, startTime: Date? = nil, statusFilter: DataSourceSyncJobStatus? = nil) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.endTime = endTime
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.startTime = startTime
            self.statusFilter = statusFilter
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodeQuery(self.endTime, key: "endTime")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.startTime, key: "startTime")
            request.encodeQuery(self.statusFilter, key: "syncStatus")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourceSyncJobsResponse: AWSDecodableShape {
        /// A history of synchronization jobs for the data source connector.
        public let history: [DataSourceSyncJob]?
        /// If the response is truncated, Amazon Q returns this token. You can use this token in any subsequent request to retrieve the next set of jobs.
        public let nextToken: String?

        public init(history: [DataSourceSyncJob]? = nil, nextToken: String? = nil) {
            self.history = history
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case history = "history"
            case nextToken = "nextToken"
        }
    }

    public struct ListDataSourcesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application linked to the data source connectors.
        public let applicationId: String
        /// The identifier of the index used with one or more data source connectors.
        public let indexId: String
        /// The maximum number of data source connectors to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q data source connectors.
        public let nextToken: String?

        public init(applicationId: String, indexId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataSourcesResponse: AWSDecodableShape {
        /// An array of summary information for one or more data source connector.
        public let dataSources: [DataSource]?
        /// If the response is truncated, Amazon Q returns this token. You can use this token in a subsequent request to retrieve the next set of data source connectors.
        public let nextToken: String?

        public init(dataSources: [DataSource]? = nil, nextToken: String? = nil) {
            self.dataSources = dataSources
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataSources = "dataSources"
            case nextToken = "nextToken"
        }
    }

    public struct ListDocumentsRequest: AWSEncodableShape {
        /// The identifier of the application id the documents are attached to.
        public let applicationId: String
        /// The identifier of the data sources the documents are attached to.
        public let dataSourceIds: [String]?
        /// The identifier of the index the documents are attached to.
        public let indexId: String
        /// The maximum number of documents to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
        public let nextToken: String?

        public init(applicationId: String, dataSourceIds: [String]? = nil, indexId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.dataSourceIds = dataSourceIds
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceIds, key: "dataSourceIds")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.dataSourceIds?.forEach {
                try validate($0, name: "dataSourceIds[]", parent: name, max: 36)
                try validate($0, name: "dataSourceIds[]", parent: name, min: 36)
                try validate($0, name: "dataSourceIds[]", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            }
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, max: 1)
            try self.validate(self.dataSourceIds, name: "dataSourceIds", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDocumentsResponse: AWSDecodableShape {
        /// A list of document details.
        public let documentDetailList: [DocumentDetails]?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of documents.
        public let nextToken: String?

        public init(documentDetailList: [DocumentDetails]? = nil, nextToken: String? = nil) {
            self.documentDetailList = documentDetailList
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case documentDetailList = "documentDetailList"
            case nextToken = "nextToken"
        }
    }

    public struct ListGroupsRequest: AWSEncodableShape {
        /// The identifier of the application for getting a list of groups mapped to users.
        public let applicationId: String
        /// The identifier of the data source for getting a list of groups mapped to users.
        public let dataSourceId: String?
        /// The identifier of the index for getting a list of groups mapped to users.
        public let indexId: String
        /// The maximum number of returned groups that are mapped to users.
        public let maxResults: Int?
        /// If the previous response was incomplete (because there is more data to retrieve), Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of groups that are mapped to users.
        public let nextToken: String?
        /// The timestamp identifier used for the latest PUT or DELETE action for mapping users to their groups.
        public let updatedEarlierThan: Date

        public init(applicationId: String, dataSourceId: String? = nil, indexId: String, maxResults: Int? = nil, nextToken: String? = nil, updatedEarlierThan: Date) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.updatedEarlierThan = updatedEarlierThan
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.updatedEarlierThan, key: "updatedEarlierThan")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 10)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGroupsResponse: AWSDecodableShape {
        /// Summary information for list of groups that are mapped to users.
        public let items: [GroupSummary]?
        /// If the response is truncated, Amazon Q returns this token that you can use in the subsequent request to retrieve the next set of groups that are mapped to users.
        public let nextToken: String?

        public init(items: [GroupSummary]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "items"
            case nextToken = "nextToken"
        }
    }

    public struct ListIndicesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application connected to the index.
        public let applicationId: String
        /// The maximum number of indices to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q indices.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIndicesResponse: AWSDecodableShape {
        /// An array of information on the items in one or more indexes.
        public let indices: [Index]?
        /// If the response is truncated, Amazon Q returns this token that you can use in the subsequent request to retrieve the next set of indexes.
        public let nextToken: String?

        public init(indices: [Index]? = nil, nextToken: String? = nil) {
            self.indices = indices
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case indices = "indices"
            case nextToken = "nextToken"
        }
    }

    public struct ListMessagesRequest: AWSEncodableShape {
        /// The identifier for the Amazon Q application.
        public let applicationId: String
        /// The identifier of the Amazon Q web experience conversation.
        public let conversationId: String
        /// The maximum number of messages to return.
        public let maxResults: Int?
        /// If the number of retrievers returned exceeds maxResults, Amazon Q returns a next token as a pagination token to retrieve the next set of messages.
        public let nextToken: String?
        /// The identifier of the user involved in the Amazon Q web experience conversation.
        public let userId: String

        public init(applicationId: String, conversationId: String, maxResults: Int? = nil, nextToken: String? = nil, userId: String) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.conversationId, key: "conversationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListMessagesResponse: AWSDecodableShape {
        /// An array of information on one or more messages.
        public let messages: [Message]?
        /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of messages.
        public let nextToken: String?

        public init(messages: [Message]? = nil, nextToken: String? = nil) {
            self.messages = messages
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case messages = "messages"
            case nextToken = "nextToken"
        }
    }

    public struct ListPluginsRequest: AWSEncodableShape {
        /// The identifier of the application the plugin is attached to.
        public let applicationId: String
        /// The maximum number of documents to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPluginsResponse: AWSDecodableShape {
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of plugins.
        public let nextToken: String?
        /// Information about a configured plugin.
        public let plugins: [Plugin]?

        public init(nextToken: String? = nil, plugins: [Plugin]? = nil) {
            self.nextToken = nextToken
            self.plugins = plugins
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case plugins = "plugins"
        }
    }

    public struct ListRetrieversRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application using the retriever.
        public let applicationId: String
        /// The maximum number of retrievers returned.
        public let maxResults: Int?
        /// If the number of retrievers returned exceeds maxResults, Amazon Q returns a next token as a pagination token to retrieve the next set of retrievers.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 50)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListRetrieversResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of retrievers.
        public let nextToken: String?
        /// An array of summary information for one or more retrievers.
        public let retrievers: [Retriever]?

        public init(nextToken: String? = nil, retrievers: [Retriever]? = nil) {
            self.nextToken = nextToken
            self.retrievers = retrievers
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case retrievers = "retrievers"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q application or data source to get a list of tags for.
        public let resourceARN: String

        public init(resourceARN: String) {
            self.resourceARN = resourceARN
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// A list of tags associated with the Amazon Q application or data source.
        public let tags: [Tag]?

        public init(tags: [Tag]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct ListWebExperiencesRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application linked to the listed web experiences.
        public let applicationId: String
        /// The maximum number of Amazon Q Web Experiences to return.
        public let maxResults: Int?
        /// If the maxResults response was incomplete because there is more data to retrieve, Amazon Q returns a pagination token in the response. You can use this pagination token to retrieve the next set of Amazon Q conversations.
        public let nextToken: String?

        public init(applicationId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.applicationId = applicationId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodeQuery(self.maxResults, key: "maxResults")
            request.encodeQuery(self.nextToken, key: "nextToken")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 800)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListWebExperiencesResponse: AWSDecodableShape {
        /// If the response is truncated, Amazon Q returns this token, which you can use in a later request to list the next set of messages.
        public let nextToken: String?
        /// An array of summary information for one or more Amazon Q experiences.
        public let webExperiences: [WebExperience]?

        public init(nextToken: String? = nil, webExperiences: [WebExperience]? = nil) {
            self.nextToken = nextToken
            self.webExperiences = webExperiences
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "nextToken"
            case webExperiences = "webExperiences"
        }
    }

    public struct MemberGroup: AWSEncodableShape {
        /// The name of the sub group.
        public let groupName: String
        /// The type of the sub group.
        public let type: MembershipType?

        public init(groupName: String, type: MembershipType? = nil) {
            self.groupName = groupName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case groupName = "groupName"
            case type = "type"
        }
    }

    public struct MemberUser: AWSEncodableShape {
        /// The type of the user.
        public let type: MembershipType?
        /// The identifier of the user you want to map to a group.
        public let userId: String

        public init(type: MembershipType? = nil, userId: String) {
            self.type = type
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case type = "type"
            case userId = "userId"
        }
    }

    public struct Message: AWSDecodableShape {
        public let actionExecution: ActionExecution?
        public let actionReview: ActionReview?
        /// A file directly uploaded into an Amazon Q web experience chat.
        public let attachments: [AttachmentOutput]?
        /// The content of the Amazon Q web experience message.
        public let body: String?
        /// The identifier of the Amazon Q web experience message.
        public let messageId: String?
        /// The source documents used to generate Amazon Q web experience message.
        public let sourceAttribution: [SourceAttribution]?
        /// The timestamp of the first Amazon Q web experience message.
        public let time: Date?
        /// The type of Amazon Q message, whether HUMAN or AI generated.
        public let type: MessageType?

        public init(actionExecution: ActionExecution? = nil, actionReview: ActionReview? = nil, attachments: [AttachmentOutput]? = nil, body: String? = nil, messageId: String? = nil, sourceAttribution: [SourceAttribution]? = nil, time: Date? = nil, type: MessageType? = nil) {
            self.actionExecution = actionExecution
            self.actionReview = actionReview
            self.attachments = attachments
            self.body = body
            self.messageId = messageId
            self.sourceAttribution = sourceAttribution
            self.time = time
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case actionExecution = "actionExecution"
            case actionReview = "actionReview"
            case attachments = "attachments"
            case body = "body"
            case messageId = "messageId"
            case sourceAttribution = "sourceAttribution"
            case time = "time"
            case type = "type"
        }
    }

    public struct MessageUsefulnessFeedback: AWSEncodableShape {
        /// A comment given by an end user on the usefulness of an AI-generated chat message.
        public let comment: String?
        /// The reason for a usefulness rating.
        public let reason: MessageUsefulnessReason?
        /// The timestamp for when the feedback was submitted.
        public let submittedAt: Date
        /// The usefulness value assigned by an end user to a message.
        public let usefulness: MessageUsefulness

        public init(comment: String? = nil, reason: MessageUsefulnessReason? = nil, submittedAt: Date, usefulness: MessageUsefulness) {
            self.comment = comment
            self.reason = reason
            self.submittedAt = submittedAt
            self.usefulness = usefulness
        }

        public func validate(name: String) throws {
            try self.validate(self.comment, name: "comment", parent: name, max: 1000)
            try self.validate(self.comment, name: "comment", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case comment = "comment"
            case reason = "reason"
            case submittedAt = "submittedAt"
            case usefulness = "usefulness"
        }
    }

    public struct NativeIndexConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Overrides the default boosts applied by Amazon Q to supported document attribute data types.
        public let boostingOverride: [String: DocumentAttributeBoostingConfiguration]?
        /// The identifier for the Amazon Q index.
        public let indexId: String

        public init(boostingOverride: [String: DocumentAttributeBoostingConfiguration]? = nil, indexId: String) {
            self.boostingOverride = boostingOverride
            self.indexId = indexId
        }

        public func validate(name: String) throws {
            try self.boostingOverride?.forEach {
                try validate($0.key, name: "boostingOverride.key", parent: name, max: 200)
                try validate($0.key, name: "boostingOverride.key", parent: name, min: 1)
                try validate($0.key, name: "boostingOverride.key", parent: name, pattern: "^[a-zA-Z0-9_][a-zA-Z0-9_-]*$")
                try $0.value.validate(name: "\(name).boostingOverride[\"\($0.key)\"]")
            }
            try self.validate(self.boostingOverride, name: "boostingOverride", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case boostingOverride = "boostingOverride"
            case indexId = "indexId"
        }
    }

    public struct NumberAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies the duration, in seconds, of a boost applies to a NUMBER type document attribute.
        public let boostingLevel: DocumentAttributeBoostingLevel
        /// Specifies how much a document attribute is boosted.
        public let boostingType: NumberAttributeBoostingType?

        public init(boostingLevel: DocumentAttributeBoostingLevel, boostingType: NumberAttributeBoostingType? = nil) {
            self.boostingLevel = boostingLevel
            self.boostingType = boostingType
        }

        private enum CodingKeys: String, CodingKey {
            case boostingLevel = "boostingLevel"
            case boostingType = "boostingType"
        }
    }

    public struct OAuth2ClientCredentialConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The ARN of an IAM role used by Amazon Q to access the OAuth 2.0 authentication credentials stored in a Secrets Manager secret.
        public let roleArn: String
        /// The ARN of the Secrets Manager secret that stores the OAuth 2.0 credentials/token used for plugin configuration.
        public let secretArn: String

        public init(roleArn: String, secretArn: String) {
            self.roleArn = roleArn
            self.secretArn = secretArn
        }

        public func validate(name: String) throws {
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.secretArn, name: "secretArn", parent: name, max: 1284)
            try self.validate(self.secretArn, name: "secretArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case roleArn = "roleArn"
            case secretArn = "secretArn"
        }
    }

    public struct Plugin: AWSDecodableShape {
        /// The timestamp for when the plugin was created.
        public let createdAt: Date?
        /// The name of the plugin.
        public let displayName: String?
        /// The identifier of the plugin.
        public let pluginId: String?
        /// The plugin server URL used for configuration.
        public let serverUrl: String?
        /// The current status of the plugin.
        public let state: PluginState?
        /// The type of the plugin.
        public let type: PluginType?
        /// The timestamp for when the plugin was last updated.
        public let updatedAt: Date?

        public init(createdAt: Date? = nil, displayName: String? = nil, pluginId: String? = nil, serverUrl: String? = nil, state: PluginState? = nil, type: PluginType? = nil, updatedAt: Date? = nil) {
            self.createdAt = createdAt
            self.displayName = displayName
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
            self.type = type
            self.updatedAt = updatedAt
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case displayName = "displayName"
            case pluginId = "pluginId"
            case serverUrl = "serverUrl"
            case state = "state"
            case type = "type"
            case updatedAt = "updatedAt"
        }
    }

    public struct PrincipalGroup: AWSEncodableShape {
        /// Provides information about whether to allow or deny access to the principal.
        public let access: ReadAccessType
        /// The type of group.
        public let membershipType: MembershipType?
        /// The name of the group.
        public let name: String?

        public init(access: ReadAccessType, membershipType: MembershipType? = nil, name: String? = nil) {
            self.access = access
            self.membershipType = membershipType
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 1024)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case access = "access"
            case membershipType = "membershipType"
            case name = "name"
        }
    }

    public struct PrincipalUser: AWSEncodableShape {
        /// Provides information about whether to allow or deny access to the principal.
        public let access: ReadAccessType
        ///  The identifier of the user.
        public let id: String?
        /// The type of group.
        public let membershipType: MembershipType?

        public init(access: ReadAccessType, id: String? = nil, membershipType: MembershipType? = nil) {
            self.access = access
            self.id = id
            self.membershipType = membershipType
        }

        public func validate(name: String) throws {
            try self.validate(self.id, name: "id", parent: name, max: 1024)
            try self.validate(self.id, name: "id", parent: name, min: 1)
            try self.validate(self.id, name: "id", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case access = "access"
            case id = "id"
            case membershipType = "membershipType"
        }
    }

    public struct PutFeedbackRequest: AWSEncodableShape {
        /// The identifier of the application associated with the feedback.
        public let applicationId: String
        /// The identifier of the conversation the feedback is attached to.
        public let conversationId: String
        /// The timestamp for when the feedback was recorded.
        public let messageCopiedAt: Date?
        /// The identifier of the chat message that the feedback was given for.
        public let messageId: String
        /// The feedback usefulness value given by the user to the chat message.
        public let messageUsefulness: MessageUsefulnessFeedback?
        /// The identifier of the user giving the feedback.
        public let userId: String

        public init(applicationId: String, conversationId: String, messageCopiedAt: Date? = nil, messageId: String, messageUsefulness: MessageUsefulnessFeedback? = nil, userId: String) {
            self.applicationId = applicationId
            self.conversationId = conversationId
            self.messageCopiedAt = messageCopiedAt
            self.messageId = messageId
            self.messageUsefulness = messageUsefulness
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.conversationId, key: "conversationId")
            try container.encodeIfPresent(self.messageCopiedAt, forKey: .messageCopiedAt)
            request.encodePath(self.messageId, key: "messageId")
            try container.encodeIfPresent(self.messageUsefulness, forKey: .messageUsefulness)
            request.encodeQuery(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.conversationId, name: "conversationId", parent: name, max: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, min: 36)
            try self.validate(self.conversationId, name: "conversationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.messageId, name: "messageId", parent: name, max: 36)
            try self.validate(self.messageId, name: "messageId", parent: name, min: 36)
            try self.validate(self.messageId, name: "messageId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.messageUsefulness?.validate(name: "\(name).messageUsefulness")
            try self.validate(self.userId, name: "userId", parent: name, max: 1024)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "^\\P{C}*$")
        }

        private enum CodingKeys: String, CodingKey {
            case messageCopiedAt = "messageCopiedAt"
            case messageUsefulness = "messageUsefulness"
        }
    }

    public struct PutGroupRequest: AWSEncodableShape {
        /// The identifier of the application in which the user and group mapping belongs.
        public let applicationId: String
        /// The identifier of the data source for which you want to map users to their groups. This is useful if a group is tied to multiple data sources, but you only want the group to access documents of a certain data source. For example, the groups "Research", "Engineering", and "Sales and Marketing" are all tied to the company's documents stored in the data sources Confluence and Salesforce. However, "Sales and Marketing" team only needs access to customer-related documents stored in Salesforce.
        public let dataSourceId: String?
        public let groupMembers: GroupMembers
        /// The list that contains your users or sub groups that belong the same group. For example, the group "Company" includes the user "CEO" and the sub groups "Research", "Engineering", and "Sales and Marketing". If you have more than 1000 users and/or sub groups for a single group, you need to provide the path to the S3 file that lists your users and sub groups for a group. Your sub groups can contain more than 1000 users, but the list of sub groups that belong to a group (and/or users) must be no more than 1000.
        public let groupName: String
        /// The identifier of the index in which you want to map users to their groups.
        public let indexId: String
        /// The type of the group.
        public let type: MembershipType

        public init(applicationId: String, dataSourceId: String? = nil, groupMembers: GroupMembers, groupName: String, indexId: String, type: MembershipType) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.groupMembers = groupMembers
            self.groupName = groupName
            self.indexId = indexId
            self.type = type
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.dataSourceId, forKey: .dataSourceId)
            try container.encode(self.groupMembers, forKey: .groupMembers)
            try container.encode(self.groupName, forKey: .groupName)
            request.encodePath(self.indexId, key: "indexId")
            try container.encode(self.type, forKey: .type)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.groupMembers.validate(name: "\(name).groupMembers")
            try self.validate(self.groupName, name: "groupName", parent: name, max: 1024)
            try self.validate(self.groupName, name: "groupName", parent: name, min: 1)
            try self.validate(self.groupName, name: "groupName", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case groupMembers = "groupMembers"
            case groupName = "groupName"
            case type = "type"
        }
    }

    public struct PutGroupResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Retriever: AWSDecodableShape {
        /// The identifier of the Amazon Q application using the retriever.
        public let applicationId: String?
        /// The name of your retriever.
        public let displayName: String?
        /// The identifier of the retriever used by your Amazon Q application.
        public let retrieverId: String?
        /// The status of your retriever.
        public let status: RetrieverStatus?
        /// The type of your retriever.
        public let type: RetrieverType?

        public init(applicationId: String? = nil, displayName: String? = nil, retrieverId: String? = nil, status: RetrieverStatus? = nil, type: RetrieverType? = nil) {
            self.applicationId = applicationId
            self.displayName = displayName
            self.retrieverId = retrieverId
            self.status = status
            self.type = type
        }

        private enum CodingKeys: String, CodingKey {
            case applicationId = "applicationId"
            case displayName = "displayName"
            case retrieverId = "retrieverId"
            case status = "status"
            case type = "type"
        }
    }

    public struct Rule: AWSEncodableShape & AWSDecodableShape {
        /// Users and groups to be excluded from a rule.
        public let excludedUsersAndGroups: UsersAndGroups?
        /// Users and groups to be included in a rule.
        public let includedUsersAndGroups: UsersAndGroups?
        /// The configuration information for a rule.
        public let ruleConfiguration: RuleConfiguration?
        /// The type of rule.
        public let ruleType: RuleType

        public init(excludedUsersAndGroups: UsersAndGroups? = nil, includedUsersAndGroups: UsersAndGroups? = nil, ruleConfiguration: RuleConfiguration? = nil, ruleType: RuleType) {
            self.excludedUsersAndGroups = excludedUsersAndGroups
            self.includedUsersAndGroups = includedUsersAndGroups
            self.ruleConfiguration = ruleConfiguration
            self.ruleType = ruleType
        }

        public func validate(name: String) throws {
            try self.excludedUsersAndGroups?.validate(name: "\(name).excludedUsersAndGroups")
            try self.includedUsersAndGroups?.validate(name: "\(name).includedUsersAndGroups")
            try self.ruleConfiguration?.validate(name: "\(name).ruleConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case excludedUsersAndGroups = "excludedUsersAndGroups"
            case includedUsersAndGroups = "includedUsersAndGroups"
            case ruleConfiguration = "ruleConfiguration"
            case ruleType = "ruleType"
        }
    }

    public struct S3: AWSEncodableShape {
        /// The name of the S3 bucket that contains the file.
        public let bucket: String
        /// The name of the file.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        public func validate(name: String) throws {
            try self.validate(self.bucket, name: "bucket", parent: name, max: 63)
            try self.validate(self.bucket, name: "bucket", parent: name, min: 1)
            try self.validate(self.bucket, name: "bucket", parent: name, pattern: "^[a-z0-9][\\.\\-a-z0-9]{1,61}[a-z0-9]$")
            try self.validate(self.key, name: "key", parent: name, max: 1024)
            try self.validate(self.key, name: "key", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case bucket = "bucket"
            case key = "key"
        }
    }

    public struct SamlConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// The metadata XML that your IdP generated.
        public let metadataXML: String
        /// The Amazon Resource Name (ARN) of an IAM role assumed by users when they authenticate into their Amazon Q web experience, containing the relevant Amazon Q permissions for conversing with Amazon Q.
        public let roleArn: String
        /// The group attribute name in your IdP that maps to user groups.
        public let userGroupAttribute: String?
        /// The user attribute name in your IdP that maps to the user email.
        public let userIdAttribute: String

        public init(metadataXML: String, roleArn: String, userGroupAttribute: String? = nil, userIdAttribute: String) {
            self.metadataXML = metadataXML
            self.roleArn = roleArn
            self.userGroupAttribute = userGroupAttribute
            self.userIdAttribute = userIdAttribute
        }

        public func validate(name: String) throws {
            try self.validate(self.metadataXML, name: "metadataXML", parent: name, max: 10000000)
            try self.validate(self.metadataXML, name: "metadataXML", parent: name, min: 1000)
            try self.validate(self.metadataXML, name: "metadataXML", parent: name, pattern: "^.*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.userGroupAttribute, name: "userGroupAttribute", parent: name, max: 256)
            try self.validate(self.userGroupAttribute, name: "userGroupAttribute", parent: name, min: 1)
            try self.validate(self.userIdAttribute, name: "userIdAttribute", parent: name, max: 256)
            try self.validate(self.userIdAttribute, name: "userIdAttribute", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case metadataXML = "metadataXML"
            case roleArn = "roleArn"
            case userGroupAttribute = "userGroupAttribute"
            case userIdAttribute = "userIdAttribute"
        }
    }

    public struct SourceAttribution: AWSDecodableShape {
        /// The number attached to a citation in an Amazon Q generated response.
        public let citationNumber: Int?
        /// The content extract from the document on which the generated response is based.
        public let snippet: String?
        /// A text extract from a source document that is used for source attribution.
        public let textMessageSegments: [TextSegment]?
        /// The title of the document which is the source for the Amazon Q generated response.
        public let title: String?
        /// The Unix timestamp when the Amazon Q application was last updated.
        public let updatedAt: Date?
        /// The URL of the document which is the source for the Amazon Q generated response.
        public let url: String?

        public init(citationNumber: Int? = nil, snippet: String? = nil, textMessageSegments: [TextSegment]? = nil, title: String? = nil, updatedAt: Date? = nil, url: String? = nil) {
            self.citationNumber = citationNumber
            self.snippet = snippet
            self.textMessageSegments = textMessageSegments
            self.title = title
            self.updatedAt = updatedAt
            self.url = url
        }

        private enum CodingKeys: String, CodingKey {
            case citationNumber = "citationNumber"
            case snippet = "snippet"
            case textMessageSegments = "textMessageSegments"
            case title = "title"
            case updatedAt = "updatedAt"
            case url = "url"
        }
    }

    public struct StartDataSourceSyncJobRequest: AWSEncodableShape {
        /// The identifier of Amazon Q application the data source is connected to.
        public let applicationId: String
        ///  The identifier of the data source connector.
        public let dataSourceId: String
        /// The identifier of the index used with the data source connector.
        public let indexId: String

        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StartDataSourceSyncJobResponse: AWSDecodableShape {
        /// The identifier for a particular synchronization job.
        public let executionId: String?

        public init(executionId: String? = nil) {
            self.executionId = executionId
        }

        private enum CodingKeys: String, CodingKey {
            case executionId = "executionId"
        }
    }

    public struct StopDataSourceSyncJobRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application that the data source is connected to.
        public let applicationId: String
        ///  The identifier of the data source connector.
        public let dataSourceId: String
        /// The identifier of the index used with the Amazon Q data source connector.
        public let indexId: String

        public init(applicationId: String, dataSourceId: String, indexId: String) {
            self.applicationId = applicationId
            self.dataSourceId = dataSourceId
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct StopDataSourceSyncJobResponse: AWSDecodableShape {
        public init() {}
    }

    public struct StringAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies specific values of a STRING type document attribute being boosted.
        public let attributeValueBoosting: [String: StringAttributeValueBoostingLevel]?
        /// Specifies how much a document attribute is boosted.
        public let boostingLevel: DocumentAttributeBoostingLevel

        public init(attributeValueBoosting: [String: StringAttributeValueBoostingLevel]? = nil, boostingLevel: DocumentAttributeBoostingLevel) {
            self.attributeValueBoosting = attributeValueBoosting
            self.boostingLevel = boostingLevel
        }

        public func validate(name: String) throws {
            try self.attributeValueBoosting?.forEach {
                try validate($0.key, name: "attributeValueBoosting.key", parent: name, max: 2048)
                try validate($0.key, name: "attributeValueBoosting.key", parent: name, min: 1)
            }
            try self.validate(self.attributeValueBoosting, name: "attributeValueBoosting", parent: name, max: 10)
            try self.validate(self.attributeValueBoosting, name: "attributeValueBoosting", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case attributeValueBoosting = "attributeValueBoosting"
            case boostingLevel = "boostingLevel"
        }
    }

    public struct StringListAttributeBoostingConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// Specifies how much a document attribute is boosted.
        public let boostingLevel: DocumentAttributeBoostingLevel

        public init(boostingLevel: DocumentAttributeBoostingLevel) {
            self.boostingLevel = boostingLevel
        }

        private enum CodingKeys: String, CodingKey {
            case boostingLevel = "boostingLevel"
        }
    }

    public struct Tag: AWSEncodableShape & AWSDecodableShape {
        ///  The key for the tag. Keys are not case sensitive and must be unique for the Amazon Q application or data source.
        public let key: String
        /// The value associated with the tag. The value may be an empty string but it can't be null.
        public let value: String

        public init(key: String, value: String) {
            self.key = key
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.key, name: "key", parent: name, max: 128)
            try self.validate(self.key, name: "key", parent: name, min: 1)
            try self.validate(self.value, name: "value", parent: name, max: 256)
        }

        private enum CodingKeys: String, CodingKey {
            case key = "key"
            case value = "value"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q application or data source to tag.
        public let resourceARN: String
        /// A list of tag keys to add to the Amazon Q application or data source. If a tag already exists, the existing value is replaced with the new value.
        public let tags: [Tag]

        public init(resourceARN: String, tags: [Tag]) {
            self.resourceARN = resourceARN
            self.tags = tags
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            try container.encode(self.tags, forKey: .tags)
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tags.forEach {
                try $0.validate(name: "\(name).tags[]")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 200)
        }

        private enum CodingKeys: String, CodingKey {
            case tags = "tags"
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct TextDocumentStatistics: AWSDecodableShape {
        /// The total size, in bytes, of the indexed documents.
        public let indexedTextBytes: Int64?
        /// The number of text documents indexed.
        public let indexedTextDocumentCount: Int?

        public init(indexedTextBytes: Int64? = nil, indexedTextDocumentCount: Int? = nil) {
            self.indexedTextBytes = indexedTextBytes
            self.indexedTextDocumentCount = indexedTextDocumentCount
        }

        private enum CodingKeys: String, CodingKey {
            case indexedTextBytes = "indexedTextBytes"
            case indexedTextDocumentCount = "indexedTextDocumentCount"
        }
    }

    public struct TextSegment: AWSDecodableShape {
        /// The zero-based location in the response string where the source attribution starts.
        public let beginOffset: Int?
        /// The zero-based location in the response string where the source attribution ends.
        public let endOffset: Int?

        public init(beginOffset: Int? = nil, endOffset: Int? = nil) {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
        }

        private enum CodingKeys: String, CodingKey {
            case beginOffset = "beginOffset"
            case endOffset = "endOffset"
        }
    }

    public struct TopicConfiguration: AWSEncodableShape & AWSDecodableShape {
        /// A description for your topic control configuration. Use this to outline how the large language model (LLM) should use this topic control configuration.
        public let description: String?
        /// A list of example phrases that you expect the end user to use in relation to the topic.
        public let exampleChatMessages: [String]?
        /// A name for your topic control configuration.
        public let name: String
        /// Rules defined for a topic configuration.
        public let rules: [Rule]

        public init(description: String? = nil, exampleChatMessages: [String]? = nil, name: String, rules: [Rule]) {
            self.description = description
            self.exampleChatMessages = exampleChatMessages
            self.name = name
            self.rules = rules
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 350)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.exampleChatMessages?.forEach {
                try validate($0, name: "exampleChatMessages[]", parent: name, max: 350)
                try validate($0, name: "exampleChatMessages[]", parent: name, pattern: "^\\P{C}*$")
            }
            try self.validate(self.exampleChatMessages, name: "exampleChatMessages", parent: name, max: 5)
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{0,35}$")
            try self.rules.forEach {
                try $0.validate(name: "\(name).rules[]")
            }
            try self.validate(self.rules, name: "rules", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case description = "description"
            case exampleChatMessages = "exampleChatMessages"
            case name = "name"
            case rules = "rules"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        /// The Amazon Resource Name (ARN) of the Amazon Q application, or data source to remove the tag from.
        public let resourceARN: String
        /// A list of tag keys to remove from the Amazon Q application or data source. If a tag key does not exist on the resource, it is ignored.
        public let tagKeys: [String]

        public init(resourceARN: String, tagKeys: [String]) {
            self.resourceARN = resourceARN
            self.tagKeys = tagKeys
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            _ = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.resourceARN, key: "resourceARN")
            request.encodeQuery(self.tagKeys, key: "tagKeys")
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, max: 1011)
            try self.validate(self.resourceARN, name: "resourceARN", parent: name, min: 1)
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 200)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateApplicationRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application.
        public let applicationId: String
        /// An option to allow end users to upload files directly during chat.
        public let attachmentsConfiguration: AttachmentsConfiguration?
        /// A description for the Amazon Q application.
        public let description: String?
        /// A name for the Amazon Q application.
        public let displayName: String?
        /// An Amazon Web Services Identity and Access Management (IAM) role that gives Amazon Q permission to access Amazon CloudWatch logs and metrics.
        public let roleArn: String?

        public init(applicationId: String, attachmentsConfiguration: AttachmentsConfiguration? = nil, description: String? = nil, displayName: String? = nil, roleArn: String? = nil) {
            self.applicationId = applicationId
            self.attachmentsConfiguration = attachmentsConfiguration
            self.description = description
            self.displayName = displayName
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.attachmentsConfiguration, forKey: .attachmentsConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case attachmentsConfiguration = "attachmentsConfiguration"
            case description = "description"
            case displayName = "displayName"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateApplicationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateChatControlsConfigurationRequest: AWSEncodableShape {
        /// The identifier of the application for which the chat controls are configured.
        public let applicationId: String
        /// The phrases blocked from chat by your chat control configuration.
        public let blockedPhrasesConfigurationUpdate: BlockedPhrasesConfigurationUpdate?
        /// A token that you provide to identify the request to update a Amazon Q application chat configuration.
        public let clientToken: String?
        /// The response scope configured for your application. This determines whether your application uses its retrieval augmented generation (RAG) system to generate answers only from your enterprise data, or also uses the large language models (LLM) knowledge to respons to end user questions in chat.
        public let responseScope: ResponseScope?
        /// The configured topic specific chat controls you want to update.
        public let topicConfigurationsToCreateOrUpdate: [TopicConfiguration]?
        /// The configured topic specific chat controls you want to delete.
        public let topicConfigurationsToDelete: [TopicConfiguration]?

        public init(applicationId: String, blockedPhrasesConfigurationUpdate: BlockedPhrasesConfigurationUpdate? = nil, clientToken: String? = UpdateChatControlsConfigurationRequest.idempotencyToken(), responseScope: ResponseScope? = nil, topicConfigurationsToCreateOrUpdate: [TopicConfiguration]? = nil, topicConfigurationsToDelete: [TopicConfiguration]? = nil) {
            self.applicationId = applicationId
            self.blockedPhrasesConfigurationUpdate = blockedPhrasesConfigurationUpdate
            self.clientToken = clientToken
            self.responseScope = responseScope
            self.topicConfigurationsToCreateOrUpdate = topicConfigurationsToCreateOrUpdate
            self.topicConfigurationsToDelete = topicConfigurationsToDelete
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.blockedPhrasesConfigurationUpdate, forKey: .blockedPhrasesConfigurationUpdate)
            try container.encodeIfPresent(self.clientToken, forKey: .clientToken)
            try container.encodeIfPresent(self.responseScope, forKey: .responseScope)
            try container.encodeIfPresent(self.topicConfigurationsToCreateOrUpdate, forKey: .topicConfigurationsToCreateOrUpdate)
            try container.encodeIfPresent(self.topicConfigurationsToDelete, forKey: .topicConfigurationsToDelete)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.blockedPhrasesConfigurationUpdate?.validate(name: "\(name).blockedPhrasesConfigurationUpdate")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 100)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.topicConfigurationsToCreateOrUpdate?.forEach {
                try $0.validate(name: "\(name).topicConfigurationsToCreateOrUpdate[]")
            }
            try self.validate(self.topicConfigurationsToCreateOrUpdate, name: "topicConfigurationsToCreateOrUpdate", parent: name, max: 10)
            try self.topicConfigurationsToDelete?.forEach {
                try $0.validate(name: "\(name).topicConfigurationsToDelete[]")
            }
            try self.validate(self.topicConfigurationsToDelete, name: "topicConfigurationsToDelete", parent: name, max: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case blockedPhrasesConfigurationUpdate = "blockedPhrasesConfigurationUpdate"
            case clientToken = "clientToken"
            case responseScope = "responseScope"
            case topicConfigurationsToCreateOrUpdate = "topicConfigurationsToCreateOrUpdate"
            case topicConfigurationsToDelete = "topicConfigurationsToDelete"
        }
    }

    public struct UpdateChatControlsConfigurationResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateDataSourceRequest: AWSEncodableShape {
        ///  The identifier of the Amazon Q application the data source is attached to.
        public let applicationId: String
        public let configuration: String?
        /// The identifier of the data source connector.
        public let dataSourceId: String
        /// The description of the data source connector.
        public let description: String?
        /// A name of the data source connector.
        public let displayName: String?
        public let documentEnrichmentConfiguration: DocumentEnrichmentConfiguration?
        /// The identifier of the index attached to the data source connector.
        public let indexId: String
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access the data source and required resources.
        public let roleArn: String?
        /// The chosen update frequency for your data source.
        public let syncSchedule: String?
        public let vpcConfiguration: DataSourceVpcConfiguration?

        public init(applicationId: String, configuration: String? = nil, dataSourceId: String, description: String? = nil, displayName: String? = nil, documentEnrichmentConfiguration: DocumentEnrichmentConfiguration? = nil, indexId: String, roleArn: String? = nil, syncSchedule: String? = nil, vpcConfiguration: DataSourceVpcConfiguration? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.dataSourceId = dataSourceId
            self.description = description
            self.displayName = displayName
            self.documentEnrichmentConfiguration = documentEnrichmentConfiguration
            self.indexId = indexId
            self.roleArn = roleArn
            self.syncSchedule = syncSchedule
            self.vpcConfiguration = vpcConfiguration
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            request.encodePath(self.dataSourceId, key: "dataSourceId")
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.documentEnrichmentConfiguration, forKey: .documentEnrichmentConfiguration)
            request.encodePath(self.indexId, key: "indexId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
            try container.encodeIfPresent(self.syncSchedule, forKey: .syncSchedule)
            try container.encodeIfPresent(self.vpcConfiguration, forKey: .vpcConfiguration)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.documentEnrichmentConfiguration?.validate(name: "\(name).documentEnrichmentConfiguration")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, max: 998)
            try self.validate(self.syncSchedule, name: "syncSchedule", parent: name, pattern: "^\\P{C}*$")
            try self.vpcConfiguration?.validate(name: "\(name).vpcConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case description = "description"
            case displayName = "displayName"
            case documentEnrichmentConfiguration = "documentEnrichmentConfiguration"
            case roleArn = "roleArn"
            case syncSchedule = "syncSchedule"
            case vpcConfiguration = "vpcConfiguration"
        }
    }

    public struct UpdateDataSourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateIndexRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application connected to the index.
        public let applicationId: String
        /// The storage capacity units you want to provision for your Amazon Q index. You can add and remove capacity to fit your usage needs.
        public let capacityConfiguration: IndexCapacityConfiguration?
        /// The description of the Amazon Q index.
        public let description: String?
        /// The name of the Amazon Q index.
        public let displayName: String?
        /// Configuration information for document metadata or fields. Document metadata are fields or attributes associated with your documents. For example, the company department name associated with each document. For more information, see Understanding document attributes.
        public let documentAttributeConfigurations: [DocumentAttributeConfiguration]?
        /// The identifier of the Amazon Q index.
        public let indexId: String

        public init(applicationId: String, capacityConfiguration: IndexCapacityConfiguration? = nil, description: String? = nil, displayName: String? = nil, documentAttributeConfigurations: [DocumentAttributeConfiguration]? = nil, indexId: String) {
            self.applicationId = applicationId
            self.capacityConfiguration = capacityConfiguration
            self.description = description
            self.displayName = displayName
            self.documentAttributeConfigurations = documentAttributeConfigurations
            self.indexId = indexId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.capacityConfiguration, forKey: .capacityConfiguration)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.documentAttributeConfigurations, forKey: .documentAttributeConfigurations)
            request.encodePath(self.indexId, key: "indexId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.capacityConfiguration?.validate(name: "\(name).capacityConfiguration")
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.documentAttributeConfigurations?.forEach {
                try $0.validate(name: "\(name).documentAttributeConfigurations[]")
            }
            try self.validate(self.documentAttributeConfigurations, name: "documentAttributeConfigurations", parent: name, max: 500)
            try self.validate(self.documentAttributeConfigurations, name: "documentAttributeConfigurations", parent: name, min: 1)
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
        }

        private enum CodingKeys: String, CodingKey {
            case capacityConfiguration = "capacityConfiguration"
            case description = "description"
            case displayName = "displayName"
            case documentAttributeConfigurations = "documentAttributeConfigurations"
        }
    }

    public struct UpdateIndexResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdatePluginRequest: AWSEncodableShape {
        /// The identifier of the application the plugin is attached to.
        public let applicationId: String
        /// The authentication configuration the plugin is using.
        public let authConfiguration: PluginAuthConfiguration?
        /// The name of the plugin.
        public let displayName: String?
        /// The identifier of the plugin.
        public let pluginId: String
        /// The source URL used for plugin configuration.
        public let serverUrl: String?
        /// The status of the plugin.
        public let state: PluginState?

        public init(applicationId: String, authConfiguration: PluginAuthConfiguration? = nil, displayName: String? = nil, pluginId: String, serverUrl: String? = nil, state: PluginState? = nil) {
            self.applicationId = applicationId
            self.authConfiguration = authConfiguration
            self.displayName = displayName
            self.pluginId = pluginId
            self.serverUrl = serverUrl
            self.state = state
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.authConfiguration, forKey: .authConfiguration)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.pluginId, key: "pluginId")
            try container.encodeIfPresent(self.serverUrl, forKey: .serverUrl)
            try container.encodeIfPresent(self.state, forKey: .state)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.authConfiguration?.validate(name: "\(name).authConfiguration")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 100)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.pluginId, name: "pluginId", parent: name, max: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, min: 36)
            try self.validate(self.pluginId, name: "pluginId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, max: 2048)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, min: 1)
            try self.validate(self.serverUrl, name: "serverUrl", parent: name, pattern: "^(https?|ftp|file)://([^\\s]*)$")
        }

        private enum CodingKeys: String, CodingKey {
            case authConfiguration = "authConfiguration"
            case displayName = "displayName"
            case serverUrl = "serverUrl"
            case state = "state"
        }
    }

    public struct UpdatePluginResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateRetrieverRequest: AWSEncodableShape {
        /// The identifier of your Amazon Q application.
        public let applicationId: String
        public let configuration: RetrieverConfiguration?
        /// The name of your retriever.
        public let displayName: String?
        /// The identifier of your retriever.
        public let retrieverId: String
        /// The Amazon Resource Name (ARN) of an IAM role with permission to access the retriever and required resources.
        public let roleArn: String?

        public init(applicationId: String, configuration: RetrieverConfiguration? = nil, displayName: String? = nil, retrieverId: String, roleArn: String? = nil) {
            self.applicationId = applicationId
            self.configuration = configuration
            self.displayName = displayName
            self.retrieverId = retrieverId
            self.roleArn = roleArn
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.configuration, forKey: .configuration)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            request.encodePath(self.retrieverId, key: "retrieverId")
            try container.encodeIfPresent(self.roleArn, forKey: .roleArn)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.configuration?.validate(name: "\(name).configuration")
            try self.validate(self.displayName, name: "displayName", parent: name, max: 1000)
            try self.validate(self.displayName, name: "displayName", parent: name, min: 1)
            try self.validate(self.displayName, name: "displayName", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9_-]*$")
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, max: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, min: 36)
            try self.validate(self.retrieverId, name: "retrieverId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.roleArn, name: "roleArn", parent: name, max: 1284)
            try self.validate(self.roleArn, name: "roleArn", parent: name, pattern: "^arn:[a-z0-9-\\.]{1,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[a-z0-9-\\.]{0,63}:[^/].{0,1023}$")
        }

        private enum CodingKeys: String, CodingKey {
            case configuration = "configuration"
            case displayName = "displayName"
            case roleArn = "roleArn"
        }
    }

    public struct UpdateRetrieverResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        /// The identifier of the application the user is attached to.
        public let applicationId: String
        /// The user aliases attached to the user id that are to be deleted.
        public let userAliasesToDelete: [UserAlias]?
        /// The user aliases attached to the user id that are to be updated.
        public let userAliasesToUpdate: [UserAlias]?
        /// The email id attached to the user.
        public let userId: String

        public init(applicationId: String, userAliasesToDelete: [UserAlias]? = nil, userAliasesToUpdate: [UserAlias]? = nil, userId: String) {
            self.applicationId = applicationId
            self.userAliasesToDelete = userAliasesToDelete
            self.userAliasesToUpdate = userAliasesToUpdate
            self.userId = userId
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.userAliasesToDelete, forKey: .userAliasesToDelete)
            try container.encodeIfPresent(self.userAliasesToUpdate, forKey: .userAliasesToUpdate)
            request.encodePath(self.userId, key: "userId")
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.userAliasesToDelete?.forEach {
                try $0.validate(name: "\(name).userAliasesToDelete[]")
            }
            try self.userAliasesToUpdate?.forEach {
                try $0.validate(name: "\(name).userAliasesToUpdate[]")
            }
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case userAliasesToDelete = "userAliasesToDelete"
            case userAliasesToUpdate = "userAliasesToUpdate"
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        /// The user aliases that have been to be added to a user id.
        public let userAliasesAdded: [UserAlias]?
        /// The user aliases that have been deleted from a user id.
        public let userAliasesDeleted: [UserAlias]?
        /// The user aliases attached to a user id that have been updated.
        public let userAliasesUpdated: [UserAlias]?

        public init(userAliasesAdded: [UserAlias]? = nil, userAliasesDeleted: [UserAlias]? = nil, userAliasesUpdated: [UserAlias]? = nil) {
            self.userAliasesAdded = userAliasesAdded
            self.userAliasesDeleted = userAliasesDeleted
            self.userAliasesUpdated = userAliasesUpdated
        }

        private enum CodingKeys: String, CodingKey {
            case userAliasesAdded = "userAliasesAdded"
            case userAliasesDeleted = "userAliasesDeleted"
            case userAliasesUpdated = "userAliasesUpdated"
        }
    }

    public struct UpdateWebExperienceRequest: AWSEncodableShape {
        /// The identifier of the Amazon Q application attached to the web experience.
        public let applicationId: String
        /// The authentication configuration of the Amazon Q web experience.
        public let authenticationConfiguration: WebExperienceAuthConfiguration?
        /// Determines whether sample prompts are enabled in the web experience for an end user.
        public let samplePromptsControlMode: WebExperienceSamplePromptsControlMode?
        /// The subtitle of the Amazon Q web experience.
        public let subtitle: String?
        /// The title of the Amazon Q web experience.
        public let title: String?
        /// The identifier of the Amazon Q web experience.
        public let webExperienceId: String
        /// A customized welcome message for an end user in an Amazon Q web experience.
        public let welcomeMessage: String?

        public init(applicationId: String, authenticationConfiguration: WebExperienceAuthConfiguration? = nil, samplePromptsControlMode: WebExperienceSamplePromptsControlMode? = nil, subtitle: String? = nil, title: String? = nil, webExperienceId: String, welcomeMessage: String? = nil) {
            self.applicationId = applicationId
            self.authenticationConfiguration = authenticationConfiguration
            self.samplePromptsControlMode = samplePromptsControlMode
            self.subtitle = subtitle
            self.title = title
            self.webExperienceId = webExperienceId
            self.welcomeMessage = welcomeMessage
        }

        public func encode(to encoder: Encoder) throws {
            let request = encoder.userInfo[.awsRequest]! as! RequestEncodingContainer
            var container = encoder.container(keyedBy: CodingKeys.self)
            request.encodePath(self.applicationId, key: "applicationId")
            try container.encodeIfPresent(self.authenticationConfiguration, forKey: .authenticationConfiguration)
            try container.encodeIfPresent(self.samplePromptsControlMode, forKey: .samplePromptsControlMode)
            try container.encodeIfPresent(self.subtitle, forKey: .subtitle)
            try container.encodeIfPresent(self.title, forKey: .title)
            request.encodePath(self.webExperienceId, key: "webExperienceId")
            try container.encodeIfPresent(self.welcomeMessage, forKey: .welcomeMessage)
        }

        public func validate(name: String) throws {
            try self.validate(self.applicationId, name: "applicationId", parent: name, max: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, min: 36)
            try self.validate(self.applicationId, name: "applicationId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.authenticationConfiguration?.validate(name: "\(name).authenticationConfiguration")
            try self.validate(self.subtitle, name: "subtitle", parent: name, max: 500)
            try self.validate(self.subtitle, name: "subtitle", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.title, name: "title", parent: name, max: 500)
            try self.validate(self.title, name: "title", parent: name, pattern: "^\\P{C}*$")
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, max: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, min: 36)
            try self.validate(self.webExperienceId, name: "webExperienceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]*$")
            try self.validate(self.welcomeMessage, name: "welcomeMessage", parent: name, max: 300)
        }

        private enum CodingKeys: String, CodingKey {
            case authenticationConfiguration = "authenticationConfiguration"
            case samplePromptsControlMode = "samplePromptsControlMode"
            case subtitle = "subtitle"
            case title = "title"
            case welcomeMessage = "welcomeMessage"
        }
    }

    public struct UpdateWebExperienceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UserAlias: AWSEncodableShape & AWSDecodableShape {
        /// The identifier of the data source that the user aliases are associated with.
        public let dataSourceId: String?
        /// The identifier of the index that the user aliases are associated with.
        public let indexId: String?
        /// The identifier of the user id associated with the user aliases.
        public let userId: String

        public init(dataSourceId: String? = nil, indexId: String? = nil, userId: String) {
            self.dataSourceId = dataSourceId
            self.indexId = indexId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, max: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, min: 36)
            try self.validate(self.dataSourceId, name: "dataSourceId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.indexId, name: "indexId", parent: name, max: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, min: 36)
            try self.validate(self.indexId, name: "indexId", parent: name, pattern: "^[a-zA-Z0-9][a-zA-Z0-9-]{35}$")
            try self.validate(self.userId, name: "userId", parent: name, max: 2048)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case dataSourceId = "dataSourceId"
            case indexId = "indexId"
            case userId = "userId"
        }
    }

    public struct UsersAndGroups: AWSEncodableShape & AWSDecodableShape {
        /// The user groups associated with a topic control rule.
        public let userGroups: [String]?
        /// The user ids associated with a topic control rule.
        public let userIds: [String]?

        public init(userGroups: [String]? = nil, userIds: [String]? = nil) {
            self.userGroups = userGroups
            self.userIds = userIds
        }

        public func validate(name: String) throws {
            try self.userGroups?.forEach {
                try validate($0, name: "userGroups[]", parent: name, max: 2048)
                try validate($0, name: "userGroups[]", parent: name, min: 1)
            }
            try self.userIds?.forEach {
                try validate($0, name: "userIds[]", parent: name, max: 2048)
                try validate($0, name: "userIds[]", parent: name, min: 1)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case userGroups = "userGroups"
            case userIds = "userIds"
        }
    }

    public struct WebExperience: AWSDecodableShape {
        /// The Unix timestamp when the Amazon Q application was last updated.
        public let createdAt: Date?
        /// The endpoint URLs for your Amazon Q web experience. The URLs are unique and fully hosted by Amazon Web Services.
        public let defaultEndpoint: String?
        /// The status of your Amazon Q web experience.
        public let status: WebExperienceStatus?
        /// The Unix timestamp when your Amazon Q web experience was updated.
        public let updatedAt: Date?
        /// The identifier of your Amazon Q web experience.
        public let webExperienceId: String?

        public init(createdAt: Date? = nil, defaultEndpoint: String? = nil, status: WebExperienceStatus? = nil, updatedAt: Date? = nil, webExperienceId: String? = nil) {
            self.createdAt = createdAt
            self.defaultEndpoint = defaultEndpoint
            self.status = status
            self.updatedAt = updatedAt
            self.webExperienceId = webExperienceId
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "createdAt"
            case defaultEndpoint = "defaultEndpoint"
            case status = "status"
            case updatedAt = "updatedAt"
            case webExperienceId = "webExperienceId"
        }
    }

    public struct WebExperienceAuthConfiguration: AWSEncodableShape & AWSDecodableShape {
        public let samlConfiguration: SamlConfiguration?

        public init(samlConfiguration: SamlConfiguration? = nil) {
            self.samlConfiguration = samlConfiguration
        }

        public func validate(name: String) throws {
            try self.samlConfiguration?.validate(name: "\(name).samlConfiguration")
        }

        private enum CodingKeys: String, CodingKey {
            case samlConfiguration = "samlConfiguration"
        }
    }
}

// MARK: - Errors

/// Error enum for QBusiness
public struct QBusinessErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case licenseNotFoundException = "LicenseNotFoundException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize QBusiness
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  You don't have access to perform this action. Make sure you have the required permission policies and user accounts and try again.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// You are trying to perform an action that conflicts with the current status of your resource. Fix any inconsistences with your resources and try again.
    public static var conflictException: Self { .init(.conflictException) }
    /// An issue occurred with the internal server used for your Amazon Q service. Wait some minutes and try again, or contact Support for help.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// You don't have permissions to perform the action because your license is inactive. Ask your admin to activate your license and try again after your licence is active.
    public static var licenseNotFoundException: Self { .init(.licenseNotFoundException) }
    /// The resource you want to use doesnt exist. Make sure you have provided the correct resource and try again.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// You have exceeded the set limits for your Amazon Q service.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request was denied due to throttling. Reduce the number of requests and try again.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input doesn't meet the constraints set by the Amazon Q service. Provide the correct input and try again.
    public static var validationException: Self { .init(.validationException) }
}

extension QBusinessErrorType: Equatable {
    public static func == (lhs: QBusinessErrorType, rhs: QBusinessErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension QBusinessErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
