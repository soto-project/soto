//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension GameSparks {
    // MARK: Enums

    public enum DeploymentAction: String, CustomStringConvertible, Codable, _SotoSendable {
        case deploy = "DEPLOY"
        case undeploy = "UNDEPLOY"
        public var description: String { return self.rawValue }
    }

    public enum DeploymentState: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum GameState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    public enum GeneratedCodeJobState: String, CustomStringConvertible, Codable, _SotoSendable {
        case completed = "COMPLETED"
        case failed = "FAILED"
        case inProgress = "IN_PROGRESS"
        case pending = "PENDING"
        public var description: String { return self.rawValue }
    }

    public enum Operation: String, CustomStringConvertible, Codable, _SotoSendable {
        case add = "ADD"
        case remove = "REMOVE"
        case replace = "REPLACE"
        public var description: String { return self.rawValue }
    }

    public enum ResultCode: String, CustomStringConvertible, Codable, _SotoSendable {
        case invalidRoleFailure = "INVALID_ROLE_FAILURE"
        case success = "SUCCESS"
        case unspecifiedFailure = "UNSPECIFIED_FAILURE"
        public var description: String { return self.rawValue }
    }

    public enum StageState: String, CustomStringConvertible, Codable, _SotoSendable {
        case active = "ACTIVE"
        case deleting = "DELETING"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct Connection: AWSDecodableShape {
        /// The date and time when the connection was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The identifier used to indicate a specific WebSocket connection.
        public let id: String?

        public init(created: Date? = nil, id: String? = nil) {
            self.created = created
            self.id = id
        }

        private enum CodingKeys: String, CodingKey {
            case created = "Created"
            case id = "Id"
        }
    }

    public struct CreateGameRequest: AWSEncodableShape {
        ///  A client-defined token. With an active client token in the request, this action is idempotent.
        public let clientToken: String?
        /// The description of the game.
        public let description: String?
        /// The name of the game.
        public let gameName: String
        /// The list of tags to apply to the game.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, gameName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.gameName = gameName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 126)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\S(.*\\S)?$|^$")
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case gameName = "GameName"
            case tags = "Tags"
        }
    }

    public struct CreateGameResult: AWSDecodableShape {
        /// Details about the game that was created.
        public let game: GameDetails?

        public init(game: GameDetails? = nil) {
            self.game = game
        }

        private enum CodingKeys: String, CodingKey {
            case game = "Game"
        }
    }

    public struct CreateSnapshotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName"))
        ]

        /// The description of the snapshot.
        public let description: String?
        /// The name of the game.
        public let gameName: String

        public init(description: String? = nil, gameName: String) {
            self.description = description
            self.gameName = gameName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\S(.*\\S)?$|^$")
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct CreateSnapshotResult: AWSDecodableShape {
        /// Properties that provide details of the created snapshot.
        public let snapshot: SnapshotDetails?

        public init(snapshot: SnapshotDetails? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "Snapshot"
        }
    }

    public struct CreateStageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName"))
        ]

        ///  A client-defined token. With an active client token in the request, this action is idempotent.
        public let clientToken: String?
        /// The description of the stage.
        public let description: String?
        /// The name of the game.
        public let gameName: String
        ///  The Amazon Resource Name (ARN) of the role to run the game with. This role can be a game-defined role or the default role that GameSparks created.
        public let role: String
        /// The name of the stage.
        public let stageName: String
        /// The list of tags to apply to the stage.
        public let tags: [String: String]?

        public init(clientToken: String? = nil, description: String? = nil, gameName: String, role: String, stageName: String, tags: [String: String]? = nil) {
            self.clientToken = clientToken
            self.description = description
            self.gameName = gameName
            self.role = role
            self.stageName = stageName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 126)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\S(.*\\S)?$|^$")
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/.+$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case description = "Description"
            case role = "Role"
            case stageName = "StageName"
            case tags = "Tags"
        }
    }

    public struct CreateStageResult: AWSDecodableShape {
        /// Properties that describe the stage.
        public let stage: StageDetails?

        public init(stage: StageDetails? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "Stage"
        }
    }

    public struct DeleteGameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName"))
        ]

        /// The name of the game to delete.
        public let gameName: String

        public init(gameName: String) {
            self.gameName = gameName
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteGameResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeleteStageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The name of the stage to delete.
        public let stageName: String

        public init(gameName: String, stageName: String) {
            self.gameName = gameName
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteStageResult: AWSDecodableShape {
        public init() {}
    }

    public struct DeploymentResult: AWSDecodableShape {
        /// Details about the deployment result.
        public let message: String?
        /// The type of deployment result.
        public let resultCode: ResultCode?

        public init(message: String? = nil, resultCode: ResultCode? = nil) {
            self.message = message
            self.resultCode = resultCode
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
            case resultCode = "ResultCode"
        }
    }

    public struct DisconnectPlayerRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "playerId", location: .uri("PlayerId")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The unique identifier representing a player.
        public let playerId: String
        /// The name of the stage.
        public let stageName: String

        public init(gameName: String, playerId: String, stageName: String) {
            self.gameName = gameName
            self.playerId = playerId
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.playerId, name: "playerId", parent: name, max: 44)
            try self.validate(self.playerId, name: "playerId", parent: name, min: 1)
            try self.validate(self.playerId, name: "playerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisconnectPlayerResult: AWSDecodableShape {
        /// The list of the connection ids that could not be disconnected.
        public let disconnectFailures: [String]?
        /// The list of the connection ids that were disconnected.
        public let disconnectSuccesses: [String]?

        public init(disconnectFailures: [String]? = nil, disconnectSuccesses: [String]? = nil) {
            self.disconnectFailures = disconnectFailures
            self.disconnectSuccesses = disconnectSuccesses
        }

        private enum CodingKeys: String, CodingKey {
            case disconnectFailures = "DisconnectFailures"
            case disconnectSuccesses = "DisconnectSuccesses"
        }
    }

    public struct ExportSnapshotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "snapshotId", location: .uri("SnapshotId"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The identifier of the snapshot to export.
        public let snapshotId: String

        public init(gameName: String, snapshotId: String) {
            self.gameName = gameName
            self.snapshotId = snapshotId
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 36)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 33)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^Snapshot_\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3,6}Z$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ExportSnapshotResult: AWSDecodableShape {
        /// The presigned URL for the snapshot data.  This URL will be available for 10 minutes, and can be used to download the snapshot content. If the URL expires, a new one can be requested using the same operation.
        public let s3Url: String?

        public init(s3Url: String? = nil) {
            self.s3Url = s3Url
        }

        private enum CodingKeys: String, CodingKey {
            case s3Url = "S3Url"
        }
    }

    public struct ExtensionDetails: AWSDecodableShape {
        /// The description of the extension.
        public let description: String?
        /// The name of the extension.
        public let name: String?
        /// The namespace (qualifier) of the extension.
        public let namespace: String?

        public init(description: String? = nil, name: String? = nil, namespace: String? = nil) {
            self.description = description
            self.name = name
            self.namespace = namespace
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case namespace = "Namespace"
        }
    }

    public struct ExtensionVersionDetails: AWSDecodableShape {
        /// The name of the extension.
        public let name: String?
        /// The namespace (qualifier) of the extension.
        public let namespace: String?
        /// The model that defines the interface for this extension version.
        public let schema: String?
        /// The version of the extension.
        public let version: String?

        public init(name: String? = nil, namespace: String? = nil, schema: String? = nil, version: String? = nil) {
            self.name = name
            self.namespace = namespace
            self.schema = schema
            self.version = version
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case namespace = "Namespace"
            case schema = "Schema"
            case version = "Version"
        }
    }

    public struct GameConfigurationDetails: AWSDecodableShape {
        /// The date when the game was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The date when the game was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        /// Configuration data, organized by section name.
        public let sections: [String: Section]?

        public init(created: Date? = nil, lastUpdated: Date? = nil, sections: [String: Section]? = nil) {
            self.created = created
            self.lastUpdated = lastUpdated
            self.sections = sections
        }

        private enum CodingKeys: String, CodingKey {
            case created = "Created"
            case lastUpdated = "LastUpdated"
            case sections = "Sections"
        }
    }

    public struct GameDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of this game.
        public let arn: String?
        /// The date when the game was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The description of the game.
        public let description: String?
        /// Determines if the game can be deleted.
        public let enableTerminationProtection: Bool?
        /// The date when the game was last modified.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        /// The name of the game.
        public let name: String?
        /// The state of the game.
        public let state: GameState?
        /// The tags associated with the game.
        public let tags: [String: String]?

        public init(arn: String? = nil, created: Date? = nil, description: String? = nil, enableTerminationProtection: Bool? = nil, lastUpdated: Date? = nil, name: String? = nil, state: GameState? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.created = created
            self.description = description
            self.enableTerminationProtection = enableTerminationProtection
            self.lastUpdated = lastUpdated
            self.name = name
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case created = "Created"
            case description = "Description"
            case enableTerminationProtection = "EnableTerminationProtection"
            case lastUpdated = "LastUpdated"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct GameSummary: AWSDecodableShape {
        /// The description of the game.
        public let description: String?
        /// The name of the game.
        public let name: String?
        /// The state of the game.
        public let state: GameState?
        /// The tags associated with the game.
        public let tags: [String: String]?

        public init(description: String? = nil, name: String? = nil, state: GameState? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.name = name
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct GeneratedCodeJobDetails: AWSDecodableShape {
        /// The description of the generated code job.
        public let description: String?
        /// The expiration date and time for the download URL.  The download URL us guaranteed to be available until at least this time.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var expirationTime: Date?
        /// The identifier for the generated code job.
        public let generatedCodeJobId: String?
        /// A presigned URL that can be used to download the generated code.
        public let s3Url: String?
        /// The status of the generated code job
        public let status: GeneratedCodeJobState?

        public init(description: String? = nil, expirationTime: Date? = nil, generatedCodeJobId: String? = nil, s3Url: String? = nil, status: GeneratedCodeJobState? = nil) {
            self.description = description
            self.expirationTime = expirationTime
            self.generatedCodeJobId = generatedCodeJobId
            self.s3Url = s3Url
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case expirationTime = "ExpirationTime"
            case generatedCodeJobId = "GeneratedCodeJobId"
            case s3Url = "S3Url"
            case status = "Status"
        }
    }

    public struct Generator: AWSEncodableShape {
        /// The target version of the GameSparks Game SDK.
        public let gameSdkVersion: String?
        /// The programming language for the generated code.  Not all languages are supported for each platform. For cases where multiple languages are supported, this parameter specifies the language to be used. If this value is omitted, the default language for the target platform will be used.
        public let language: String?
        /// The platform that will be used to run the generated code.
        public let targetPlatform: String?

        public init(gameSdkVersion: String? = nil, language: String? = nil, targetPlatform: String? = nil) {
            self.gameSdkVersion = gameSdkVersion
            self.language = language
            self.targetPlatform = targetPlatform
        }

        public func validate(name: String) throws {
            try self.validate(self.gameSdkVersion, name: "gameSdkVersion", parent: name, max: 10)
            try self.validate(self.gameSdkVersion, name: "gameSdkVersion", parent: name, min: 5)
            try self.validate(self.gameSdkVersion, name: "gameSdkVersion", parent: name, pattern: "^((\\d|[1-9]\\d*)\\.(\\d|[0-9]\\d*)\\.(\\d|[0-9]\\d*)|LATEST)$")
            try self.validate(self.language, name: "language", parent: name, max: 16)
            try self.validate(self.language, name: "language", parent: name, min: 1)
            try self.validate(self.language, name: "language", parent: name, pattern: "^[a-zA-Z_]+$")
            try self.validate(self.targetPlatform, name: "targetPlatform", parent: name, max: 16)
            try self.validate(self.targetPlatform, name: "targetPlatform", parent: name, min: 1)
            try self.validate(self.targetPlatform, name: "targetPlatform", parent: name, pattern: "^[a-zA-Z]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case gameSdkVersion = "GameSdkVersion"
            case language = "Language"
            case targetPlatform = "TargetPlatform"
        }
    }

    public struct GetExtensionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "name", location: .uri("Name")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The name of the extension.
        public let name: String
        /// The namespace (qualifier) of the extension.
        public let namespace: String

        public init(name: String, namespace: String) {
            self.name = name
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 36)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExtensionResult: AWSDecodableShape {
        /// Details about the extension.
        public let `extension`: ExtensionDetails?

        public init(extension: ExtensionDetails? = nil) {
            self.`extension` = `extension`
        }

        private enum CodingKeys: String, CodingKey {
            case `extension` = "Extension"
        }
    }

    public struct GetExtensionVersionRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "extensionVersion", location: .uri("ExtensionVersion")),
            AWSMemberEncoding(label: "name", location: .uri("Name")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace"))
        ]

        /// The version of the extension.
        public let extensionVersion: String
        /// The name of the extension.
        public let name: String
        /// The namespace (qualifier) of the extension.
        public let namespace: String

        public init(extensionVersion: String, name: String, namespace: String) {
            self.extensionVersion = extensionVersion
            self.name = name
            self.namespace = namespace
        }

        public func validate(name: String) throws {
            try self.validate(self.extensionVersion, name: "extensionVersion", parent: name, max: 20)
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 36)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExtensionVersionResult: AWSDecodableShape {
        /// The version of the extension.
        public let extensionVersion: ExtensionVersionDetails?

        public init(extensionVersion: ExtensionVersionDetails? = nil) {
            self.extensionVersion = extensionVersion
        }

        private enum CodingKeys: String, CodingKey {
            case extensionVersion = "ExtensionVersion"
        }
    }

    public struct GetGameConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "sections", location: .querystring("Sections"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The list of sections to return.
        public let sections: [String]?

        public init(gameName: String, sections: [String]? = nil) {
            self.gameName = gameName
            self.sections = sections
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.sections?.forEach {
                try validate($0, name: "sections[]", parent: name, max: 36)
                try validate($0, name: "sections[]", parent: name, min: 1)
                try validate($0, name: "sections[]", parent: name, pattern: "^[a-zA-Z0-9.]+$")
            }
            try self.validate(self.sections, name: "sections", parent: name, max: 100)
            try self.validate(self.sections, name: "sections", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGameConfigurationResult: AWSDecodableShape {
        /// Details about the game configuration.
        public let gameConfiguration: GameConfigurationDetails?

        public init(gameConfiguration: GameConfigurationDetails? = nil) {
            self.gameConfiguration = gameConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case gameConfiguration = "GameConfiguration"
        }
    }

    public struct GetGameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName"))
        ]

        /// The name of the game.
        public let gameName: String

        public init(gameName: String) {
            self.gameName = gameName
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGameResult: AWSDecodableShape {
        /// The details of the game.
        public let game: GameDetails?

        public init(game: GameDetails? = nil) {
            self.game = game
        }

        private enum CodingKeys: String, CodingKey {
            case game = "Game"
        }
    }

    public struct GetGeneratedCodeJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "jobId", location: .uri("JobId")),
            AWSMemberEncoding(label: "snapshotId", location: .uri("SnapshotId"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The identifier of the code generation job.
        public let jobId: String
        /// The identifier of the snapshot for the code generation job.
        public let snapshotId: String

        public init(gameName: String, jobId: String, snapshotId: String) {
            self.gameName = gameName
            self.jobId = jobId
            self.snapshotId = snapshotId
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.jobId, name: "jobId", parent: name, pattern: "^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 36)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 33)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^Snapshot_\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3,6}Z$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetGeneratedCodeJobResult: AWSDecodableShape {
        /// Details about the generated code job.
        public let generatedCodeJob: GeneratedCodeJobDetails?

        public init(generatedCodeJob: GeneratedCodeJobDetails? = nil) {
            self.generatedCodeJob = generatedCodeJob
        }

        private enum CodingKeys: String, CodingKey {
            case generatedCodeJob = "GeneratedCodeJob"
        }
    }

    public struct GetPlayerConnectionStatusRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "playerId", location: .uri("PlayerId")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The unique identifier representing a player.
        public let playerId: String
        /// The name of the stage.
        public let stageName: String

        public init(gameName: String, playerId: String, stageName: String) {
            self.gameName = gameName
            self.playerId = playerId
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.playerId, name: "playerId", parent: name, max: 44)
            try self.validate(self.playerId, name: "playerId", parent: name, min: 1)
            try self.validate(self.playerId, name: "playerId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPlayerConnectionStatusResult: AWSDecodableShape {
        /// The list of connection ids, one for each connection in use by the player.
        public let connections: [Connection]?

        public init(connections: [Connection]? = nil) {
            self.connections = connections
        }

        private enum CodingKeys: String, CodingKey {
            case connections = "Connections"
        }
    }

    public struct GetSnapshotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "sections", location: .querystring("Sections")),
            AWSMemberEncoding(label: "snapshotId", location: .uri("SnapshotId"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The list of game configuration sections to be described.
        public let sections: [String]?
        /// The identifier of the snapshot.
        public let snapshotId: String

        public init(gameName: String, sections: [String]? = nil, snapshotId: String) {
            self.gameName = gameName
            self.sections = sections
            self.snapshotId = snapshotId
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.sections?.forEach {
                try validate($0, name: "sections[]", parent: name, max: 36)
                try validate($0, name: "sections[]", parent: name, min: 1)
                try validate($0, name: "sections[]", parent: name, pattern: "^[a-zA-Z0-9.]+$")
            }
            try self.validate(self.sections, name: "sections", parent: name, max: 100)
            try self.validate(self.sections, name: "sections", parent: name, min: 1)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 36)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 33)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^Snapshot_\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3,6}Z$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetSnapshotResult: AWSDecodableShape {
        /// Properties that provide details of the snapshot.
        public let snapshot: SnapshotDetails?

        public init(snapshot: SnapshotDetails? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "Snapshot"
        }
    }

    public struct GetStageDeploymentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "deploymentId", location: .querystring("DeploymentId")),
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        ///  The identifier of the stage deployment. StartStageDeployment returns the identifier that you use here.
        public let deploymentId: String?
        /// The name of the game.
        public let gameName: String
        /// The name of the stage.
        public let stageName: String

        public init(deploymentId: String? = nil, gameName: String, stageName: String) {
            self.deploymentId = deploymentId
            self.gameName = gameName
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, max: 128)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, min: 1)
            try self.validate(self.deploymentId, name: "deploymentId", parent: name, pattern: "^\\S(.*\\S)?$")
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStageDeploymentResult: AWSDecodableShape {
        /// Properties that provide details of the stage deployment.
        public let stageDeployment: StageDeploymentDetails?

        public init(stageDeployment: StageDeploymentDetails? = nil) {
            self.stageDeployment = stageDeployment
        }

        private enum CodingKeys: String, CodingKey {
            case stageDeployment = "StageDeployment"
        }
    }

    public struct GetStageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The name of the stage.
        public let stageName: String

        public init(gameName: String, stageName: String) {
            self.gameName = gameName
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetStageResult: AWSDecodableShape {
        /// Properties that provide details of the stage.
        public let stage: StageDetails?

        public init(stage: StageDetails? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "Stage"
        }
    }

    public struct ImportGameConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The source used to import configuration sections.
        public let importSource: ImportGameConfigurationSource

        public init(gameName: String, importSource: ImportGameConfigurationSource) {
            self.gameName = gameName
            self.importSource = importSource
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.importSource.validate(name: "\(name).importSource")
        }

        private enum CodingKeys: String, CodingKey {
            case importSource = "ImportSource"
        }
    }

    public struct ImportGameConfigurationResult: AWSDecodableShape {
        /// Details about the game configuration.
        public let gameConfiguration: GameConfigurationDetails?

        public init(gameConfiguration: GameConfigurationDetails? = nil) {
            self.gameConfiguration = gameConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case gameConfiguration = "GameConfiguration"
        }
    }

    public struct ImportGameConfigurationSource: AWSEncodableShape {
        /// The JSON string containing the configuration sections.
        public let file: AWSBase64Data

        public init(file: AWSBase64Data) {
            self.file = file
        }

        public func validate(name: String) throws {
            try self.validate(self.file, name: "file", parent: name, max: 1_024_000)
            try self.validate(self.file, name: "file", parent: name, min: 10)
        }

        private enum CodingKeys: String, CodingKey {
            case file = "File"
        }
    }

    public struct ListExtensionVersionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "name", location: .uri("Name")),
            AWSMemberEncoding(label: "namespace", location: .uri("Namespace")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of results to return.  Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The name of the extension.
        public let name: String
        /// The namespace (qualifier) of the extension.
        public let namespace: String
        /// The token that indicates the start of the next sequential page of results.  Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, name: String, namespace: String, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.name = name
            self.namespace = namespace
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, max: 36)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.namespace, name: "namespace", parent: name, max: 36)
            try self.validate(self.namespace, name: "namespace", parent: name, min: 1)
            try self.validate(self.namespace, name: "namespace", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S(.*\\S)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExtensionVersionsResult: AWSDecodableShape {
        /// The list of extension versions.
        public let extensionVersions: [ExtensionVersionDetails]?
        /// The token that indicates the start of the next sequential page of results.  Use this value when making the next call to this operation to continue where the last one finished.
        public let nextToken: String?

        public init(extensionVersions: [ExtensionVersionDetails]? = nil, nextToken: String? = nil) {
            self.extensionVersions = extensionVersions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case extensionVersions = "ExtensionVersions"
            case nextToken = "NextToken"
        }
    }

    public struct ListExtensionsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of results to return.  Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token that indicates the start of the next sequential page of results.  Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S(.*\\S)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListExtensionsResult: AWSDecodableShape {
        /// The list of extensions.
        public let extensions: [ExtensionDetails]?
        /// The token that indicates the start of the next sequential page of results.  Use this value when making the next call to this operation to continue where the last one finished.
        public let nextToken: String?

        public init(extensions: [ExtensionDetails]? = nil, nextToken: String? = nil) {
            self.extensions = extensions
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case extensions = "Extensions"
            case nextToken = "NextToken"
        }
    }

    public struct ListGamesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The maximum number of results to return.  Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token that indicates the start of the next sequential page of results.  Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S(.*\\S)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGamesResult: AWSDecodableShape {
        /// The list of games.
        public let games: [GameSummary]?
        /// The token that indicates the start of the next sequential page of results.  Use this value when making the next call to this operation to continue where the last one finished.
        public let nextToken: String?

        public init(games: [GameSummary]? = nil, nextToken: String? = nil) {
            self.games = games
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case games = "Games"
            case nextToken = "NextToken"
        }
    }

    public struct ListGeneratedCodeJobsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "snapshotId", location: .uri("SnapshotId"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The maximum number of results to return.  Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token that indicates the start of the next sequential page of results.  Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        public let nextToken: String?
        /// The identifier of the snapshot.
        public let snapshotId: String

        public init(gameName: String, maxResults: Int? = nil, nextToken: String? = nil, snapshotId: String) {
            self.gameName = gameName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.snapshotId = snapshotId
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S(.*\\S)?$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 36)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 33)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^Snapshot_\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3,6}Z$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListGeneratedCodeJobsResult: AWSDecodableShape {
        /// The list of generated code jobs.
        public let generatedCodeJobs: [GeneratedCodeJobDetails]?
        /// The token that indicates the start of the next sequential page of results.  Use this value when making the next call to this operation to continue where the last one finished.
        public let nextToken: String?

        public init(generatedCodeJobs: [GeneratedCodeJobDetails]? = nil, nextToken: String? = nil) {
            self.generatedCodeJobs = generatedCodeJobs
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case generatedCodeJobs = "GeneratedCodeJobs"
            case nextToken = "NextToken"
        }
    }

    public struct ListSnapshotsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The maximum number of results to return.  Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token that indicates the start of the next sequential page of results.  Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        public let nextToken: String?

        public init(gameName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.gameName = gameName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S(.*\\S)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListSnapshotsResult: AWSDecodableShape {
        /// The token that indicates the start of the next sequential page of results.  Use this value when making the next call to this operation to continue where the last one finished.
        public let nextToken: String?
        ///  A list of snapshot summaries. You can use the returned snapshot IDs in the UpdateSnapshot and GetSnapshot operations.
        public let snapshots: [SnapshotSummary]?

        public init(nextToken: String? = nil, snapshots: [SnapshotSummary]? = nil) {
            self.nextToken = nextToken
            self.snapshots = snapshots
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case snapshots = "Snapshots"
        }
    }

    public struct ListStageDeploymentsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The maximum number of results to return.  Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token that indicates the start of the next sequential page of results.  Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        public let nextToken: String?
        /// The name of the stage.
        public let stageName: String

        public init(gameName: String, maxResults: Int? = nil, nextToken: String? = nil, stageName: String) {
            self.gameName = gameName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S(.*\\S)?$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStageDeploymentsResult: AWSDecodableShape {
        /// The token that indicates the start of the next sequential page of results.  Use this value when making the next call to this operation to continue where the last one finished.
        public let nextToken: String?
        ///  A list of stage deployment summaries. You can use the deployment IDs in the UpdateStageDeployment and GetStageDeployment actions.
        public let stageDeployments: [StageDeploymentSummary]?

        public init(nextToken: String? = nil, stageDeployments: [StageDeploymentSummary]? = nil) {
            self.nextToken = nextToken
            self.stageDeployments = stageDeployments
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case stageDeployments = "StageDeployments"
        }
    }

    public struct ListStagesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("MaxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("NextToken"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The maximum number of results to return.  Use this parameter with NextToken to get results as a set of sequential pages.
        public let maxResults: Int?
        /// The token that indicates the start of the next sequential page of results.  Use the token that is returned with a previous call to this operation. To start at the beginning of the result set, do not specify a value.
        public let nextToken: String?

        public init(gameName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.gameName = gameName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^\\S(.*\\S)?$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListStagesResult: AWSDecodableShape {
        /// The token that indicates the start of the next sequential page of results.  Use this value when making the next call to this operation to continue where the last one finished.
        public let nextToken: String?
        ///  A list of stage summaries. You can use the stage names in the UpdateStage and GetStage actions.
        public let stages: [StageSummary]?

        public init(nextToken: String? = nil, stages: [StageSummary]? = nil) {
            self.nextToken = nextToken
            self.stages = stages
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken = "NextToken"
            case stages = "Stages"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the GameSparks resource.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:gamesparks:")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResult: AWSDecodableShape {
        /// The tags associated with the resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct Section: AWSDecodableShape {
        /// The content of a configuration section.
        public let attributes: String?
        /// The name of the section.
        public let name: String?
        /// The size, in bytes, of the section contents.
        public let size: Int?

        public init(attributes: String? = nil, name: String? = nil, size: Int? = nil) {
            self.attributes = attributes
            self.name = name
            self.size = size
        }

        private enum CodingKeys: String, CodingKey {
            case attributes = "Attributes"
            case name = "Name"
            case size = "Size"
        }
    }

    public struct SectionModification: AWSEncodableShape {
        /// The operation to be performed on a configuration section.  Content can be added, deleted, or replaced within a section.
        public let operation: Operation
        /// The path within the section content to be modified.
        public let path: String
        /// The name of the section to be modified.
        public let section: String
        /// For add and replace operations, this is the value that will be used.  This field should be omitted for delete operations.
        public let value: String?

        public init(operation: Operation, path: String, section: String, value: String? = nil) {
            self.operation = operation
            self.path = path
            self.section = section
            self.value = value
        }

        public func validate(name: String) throws {
            try self.validate(self.path, name: "path", parent: name, max: 500)
            try self.validate(self.path, name: "path", parent: name, min: 1)
            try self.validate(self.path, name: "path", parent: name, pattern: "^\\/.*[^\\/]$")
            try self.validate(self.section, name: "section", parent: name, max: 36)
            try self.validate(self.section, name: "section", parent: name, min: 1)
            try self.validate(self.section, name: "section", parent: name, pattern: "^[a-zA-Z0-9.]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case operation = "Operation"
            case path = "Path"
            case section = "Section"
            case value = "Value"
        }
    }

    public struct SnapshotDetails: AWSDecodableShape {
        /// The timestamp of when the snapshot was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The description of the snapshot.
        public let description: String?
        /// The identifier of the snapshot.
        public let id: String?
        /// The timestamp of when the snapshot was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        /// The sections in the snapshot.
        public let sections: [String: Section]?

        public init(created: Date? = nil, description: String? = nil, id: String? = nil, lastUpdated: Date? = nil, sections: [String: Section]? = nil) {
            self.created = created
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
            self.sections = sections
        }

        private enum CodingKeys: String, CodingKey {
            case created = "Created"
            case description = "Description"
            case id = "Id"
            case lastUpdated = "LastUpdated"
            case sections = "Sections"
        }
    }

    public struct SnapshotSummary: AWSDecodableShape {
        /// The timestamp of when the snapshot was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The description of the snapshot.
        public let description: String?
        /// The identifier of the snapshot.
        public let id: String?
        /// Then timestamp of when the snapshot was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?

        public init(created: Date? = nil, description: String? = nil, id: String? = nil, lastUpdated: Date? = nil) {
            self.created = created
            self.description = description
            self.id = id
            self.lastUpdated = lastUpdated
        }

        private enum CodingKeys: String, CodingKey {
            case created = "Created"
            case description = "Description"
            case id = "Id"
            case lastUpdated = "LastUpdated"
        }
    }

    public struct StageDeploymentDetails: AWSDecodableShape {
        /// The timestamp of when the stage deployment was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The type of action of the stage deployment.
        public let deploymentAction: DeploymentAction?
        /// The identifier of the deployment.
        public let deploymentId: String?
        /// The result of the deployment.
        public let deploymentResult: DeploymentResult?
        /// The state of the deployment.
        public let deploymentState: DeploymentState?
        /// The timestamp of when the deployment was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        /// The identifier of the snapshot associated with the stage deployment.
        public let snapshotId: String?

        public init(created: Date? = nil, deploymentAction: DeploymentAction? = nil, deploymentId: String? = nil, deploymentResult: DeploymentResult? = nil, deploymentState: DeploymentState? = nil, lastUpdated: Date? = nil, snapshotId: String? = nil) {
            self.created = created
            self.deploymentAction = deploymentAction
            self.deploymentId = deploymentId
            self.deploymentResult = deploymentResult
            self.deploymentState = deploymentState
            self.lastUpdated = lastUpdated
            self.snapshotId = snapshotId
        }

        private enum CodingKeys: String, CodingKey {
            case created = "Created"
            case deploymentAction = "DeploymentAction"
            case deploymentId = "DeploymentId"
            case deploymentResult = "DeploymentResult"
            case deploymentState = "DeploymentState"
            case lastUpdated = "LastUpdated"
            case snapshotId = "SnapshotId"
        }
    }

    public struct StageDeploymentSummary: AWSDecodableShape {
        /// The type of action of the deployment.
        public let deploymentAction: DeploymentAction?
        /// The identifier of the deployment.
        public let deploymentId: String?
        /// The result of the deployment.
        public let deploymentResult: DeploymentResult?
        /// The state of the deployment.
        public let deploymentState: DeploymentState?
        /// The timestamp of when the deployment was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        /// The identifier of the snapshot associated with the stage deployment.
        public let snapshotId: String?

        public init(deploymentAction: DeploymentAction? = nil, deploymentId: String? = nil, deploymentResult: DeploymentResult? = nil, deploymentState: DeploymentState? = nil, lastUpdated: Date? = nil, snapshotId: String? = nil) {
            self.deploymentAction = deploymentAction
            self.deploymentId = deploymentId
            self.deploymentResult = deploymentResult
            self.deploymentState = deploymentState
            self.lastUpdated = lastUpdated
            self.snapshotId = snapshotId
        }

        private enum CodingKeys: String, CodingKey {
            case deploymentAction = "DeploymentAction"
            case deploymentId = "DeploymentId"
            case deploymentResult = "DeploymentResult"
            case deploymentState = "DeploymentState"
            case lastUpdated = "LastUpdated"
            case snapshotId = "SnapshotId"
        }
    }

    public struct StageDetails: AWSDecodableShape {
        /// The Amazon Resource Name (ARN) of the stage.
        public let arn: String?
        /// The timestamp of when the stage was created.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var created: Date?
        /// The description of the stage.
        public let description: String?
        /// The game key associated with the stage.  The game key is a unique identifier that the game client uses to connect to the GameSparks backend.
        public let gameKey: String?
        /// The timestamp of when the stage was last updated.
        @OptionalCustomCoding<ISO8601DateCoder>
        public var lastUpdated: Date?
        /// The Amazon CloudWatch log group for game runtimes deployed to the stage.
        public let logGroup: String?
        /// The name of the stage.
        public let name: String?
        /// The Amazon Resource Name (ARN) of the role used to run the game runtimes deployed to the stage.
        public let role: String?
        /// The state of the stage.
        public let state: StageState?
        /// The tags associated with the stage.
        public let tags: [String: String]?

        public init(arn: String? = nil, created: Date? = nil, description: String? = nil, gameKey: String? = nil, lastUpdated: Date? = nil, logGroup: String? = nil, name: String? = nil, role: String? = nil, state: StageState? = nil, tags: [String: String]? = nil) {
            self.arn = arn
            self.created = created
            self.description = description
            self.gameKey = gameKey
            self.lastUpdated = lastUpdated
            self.logGroup = logGroup
            self.name = name
            self.role = role
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "Arn"
            case created = "Created"
            case description = "Description"
            case gameKey = "GameKey"
            case lastUpdated = "LastUpdated"
            case logGroup = "LogGroup"
            case name = "Name"
            case role = "Role"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct StageSummary: AWSDecodableShape {
        /// The description of the stage.
        public let description: String?
        /// The game key associated with the stage.  The game key is a unique identifier that the game client uses to connect to the GameSparks backend.
        public let gameKey: String?
        /// The name of the stage.
        public let name: String?
        /// The state of the stage.
        public let state: StageState?
        /// The tags associated with the stage.
        public let tags: [String: String]?

        public init(description: String? = nil, gameKey: String? = nil, name: String? = nil, state: StageState? = nil, tags: [String: String]? = nil) {
            self.description = description
            self.gameKey = gameKey
            self.name = name
            self.state = state
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case gameKey = "GameKey"
            case name = "Name"
            case state = "State"
            case tags = "Tags"
        }
    }

    public struct StartGeneratedCodeJobRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "snapshotId", location: .uri("SnapshotId"))
        ]

        /// The name of the game.
        public let gameName: String
        /// Properties of the generator to use for the job.
        public let generator: Generator
        /// The identifier of the snapshot for which to generate code.
        public let snapshotId: String

        public init(gameName: String, generator: Generator, snapshotId: String) {
            self.gameName = gameName
            self.generator = generator
            self.snapshotId = snapshotId
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.generator.validate(name: "\(name).generator")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 36)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 33)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^Snapshot_\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3,6}Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case generator = "Generator"
        }
    }

    public struct StartGeneratedCodeJobResult: AWSDecodableShape {
        ///  The identifier of the code generation job. You can use this identifier in the GetGeneratedCodeJob operation.
        public let generatedCodeJobId: String?

        public init(generatedCodeJobId: String? = nil) {
            self.generatedCodeJobId = generatedCodeJobId
        }

        private enum CodingKeys: String, CodingKey {
            case generatedCodeJobId = "GeneratedCodeJobId"
        }
    }

    public struct StartStageDeploymentRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        ///  A client-defined token. With an active client token in the request, this action is idempotent.
        public let clientToken: String?
        /// The name of the game.
        public let gameName: String
        /// The identifier of the snapshot to deploy.
        public let snapshotId: String
        /// The name of the stage to deploy the snapshot onto.
        public let stageName: String

        public init(clientToken: String? = nil, gameName: String, snapshotId: String, stageName: String) {
            self.clientToken = clientToken
            self.gameName = gameName
            self.snapshotId = snapshotId
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 126)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 33)
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 36)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 33)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^Snapshot_\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3,6}Z$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken = "ClientToken"
            case snapshotId = "SnapshotId"
        }
    }

    public struct StartStageDeploymentResult: AWSDecodableShape {
        /// Properties that describe the stage deployment.
        public let stageDeployment: StageDeploymentDetails?

        public init(stageDeployment: StageDeploymentDetails? = nil) {
            self.stageDeployment = stageDeployment
        }

        private enum CodingKeys: String, CodingKey {
            case stageDeployment = "StageDeployment"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to add the tags to.
        public let resourceArn: String
        /// The tags to add to the resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:gamesparks:")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\w+-=\\.:/@]*$")
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
            try self.validate(self.tags, name: "tags", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri("ResourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring("tagKeys"))
        ]

        /// The Amazon Resource Name (ARN) of the resource to remove the tags from.
        public let resourceArn: String
        /// The keys of the tags to remove.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 2048)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, min: 20)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:aws:gamesparks:")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResult: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateGameConfigurationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName"))
        ]

        /// The name of the game.
        public let gameName: String
        /// The list of modifications to make.
        public let modifications: [SectionModification]

        public init(gameName: String, modifications: [SectionModification]) {
            self.gameName = gameName
            self.modifications = modifications
        }

        public func validate(name: String) throws {
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.modifications.forEach {
                try $0.validate(name: "\(name).modifications[]")
            }
            try self.validate(self.modifications, name: "modifications", parent: name, max: 100)
            try self.validate(self.modifications, name: "modifications", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case modifications = "Modifications"
        }
    }

    public struct UpdateGameConfigurationResult: AWSDecodableShape {
        /// Details about the game configuration.
        public let gameConfiguration: GameConfigurationDetails?

        public init(gameConfiguration: GameConfigurationDetails? = nil) {
            self.gameConfiguration = gameConfiguration
        }

        private enum CodingKeys: String, CodingKey {
            case gameConfiguration = "GameConfiguration"
        }
    }

    public struct UpdateGameRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName"))
        ]

        /// The description of the game.
        public let description: String?
        /// The name of the game.
        public let gameName: String

        public init(description: String? = nil, gameName: String) {
            self.description = description
            self.gameName = gameName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\S(.*\\S)?$|^$")
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateGameResult: AWSDecodableShape {
        /// The details of the game.
        public let game: GameDetails?

        public init(game: GameDetails? = nil) {
            self.game = game
        }

        private enum CodingKeys: String, CodingKey {
            case game = "Game"
        }
    }

    public struct UpdateSnapshotRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "snapshotId", location: .uri("SnapshotId"))
        ]

        /// The description of the snapshot.
        public let description: String?
        /// The name of the game.
        public let gameName: String
        /// The identifier of the snapshot.
        public let snapshotId: String

        public init(description: String? = nil, gameName: String, snapshotId: String) {
            self.description = description
            self.gameName = gameName
            self.snapshotId = snapshotId
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\S(.*\\S)?$|^$")
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, max: 36)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, min: 33)
            try self.validate(self.snapshotId, name: "snapshotId", parent: name, pattern: "^Snapshot_\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3,6}Z$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
        }
    }

    public struct UpdateSnapshotResult: AWSDecodableShape {
        /// Properties that provide details of the updated snapshot.
        public let snapshot: SnapshotDetails?

        public init(snapshot: SnapshotDetails? = nil) {
            self.snapshot = snapshot
        }

        private enum CodingKeys: String, CodingKey {
            case snapshot = "Snapshot"
        }
    }

    public struct UpdateStageRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "gameName", location: .uri("GameName")),
            AWSMemberEncoding(label: "stageName", location: .uri("StageName"))
        ]

        /// The description of the stage.
        public let description: String?
        /// The name of the game.
        public let gameName: String
        /// The Amazon Resource Name (ARN) of the role to use for the game snapshots deployed to this stage.
        public let role: String?
        /// The name of the stage.
        public let stageName: String

        public init(description: String? = nil, gameName: String, role: String? = nil, stageName: String) {
            self.description = description
            self.gameName = gameName
            self.role = role
            self.stageName = stageName
        }

        public func validate(name: String) throws {
            try self.validate(self.description, name: "description", parent: name, max: 250)
            try self.validate(self.description, name: "description", parent: name, pattern: "^\\S(.*\\S)?$|^$")
            try self.validate(self.gameName, name: "gameName", parent: name, max: 36)
            try self.validate(self.gameName, name: "gameName", parent: name, min: 1)
            try self.validate(self.gameName, name: "gameName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.validate(self.role, name: "role", parent: name, max: 2048)
            try self.validate(self.role, name: "role", parent: name, min: 20)
            try self.validate(self.role, name: "role", parent: name, pattern: "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/.+$")
            try self.validate(self.stageName, name: "stageName", parent: name, max: 36)
            try self.validate(self.stageName, name: "stageName", parent: name, min: 1)
            try self.validate(self.stageName, name: "stageName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case role = "Role"
        }
    }

    public struct UpdateStageResult: AWSDecodableShape {
        /// Properties that provide details of the updated stage.
        public let stage: StageDetails?

        public init(stage: StageDetails? = nil) {
            self.stage = stage
        }

        private enum CodingKeys: String, CodingKey {
            case stage = "Stage"
        }
    }
}

// MARK: - Errors

/// Error enum for GameSparks
public struct GameSparksErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case serviceQuotaExceededException = "ServiceQuotaExceededException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize GameSparks
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The resource already exists, or another operation is in progress.
    public static var conflictException: Self { .init(.conflictException) }
    /// The service encountered an internal error.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// The resource specified in the request does not exist.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request would result in exceeding service quota.
    public static var serviceQuotaExceededException: Self { .init(.serviceQuotaExceededException) }
    /// The request throughput limit was exceeded.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// One of the parameters in the request is invalid.
    public static var validationException: Self { .init(.validationException) }
}

extension GameSparksErrorType: Equatable {
    public static func == (lhs: GameSparksErrorType, rhs: GameSparksErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension GameSparksErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
