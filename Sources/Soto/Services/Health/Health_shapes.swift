//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2023 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

#if os(Linux) && compiler(<5.10)
// swift-corelibs-foundation hasn't been updated with Sendable conformances
@preconcurrency import Foundation
#else
import Foundation
#endif
@_spi(SotoInternal) import SotoCore

extension Health {
    // MARK: Enums

    public enum EntityStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case impaired = "IMPAIRED"
        case pending = "PENDING"
        case resolved = "RESOLVED"
        case unimpaired = "UNIMPAIRED"
        case unknown = "UNKNOWN"
        public var description: String { return self.rawValue }
    }

    public enum EventAggregateField: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case eventTypeCategory = "eventTypeCategory"
        public var description: String { return self.rawValue }
    }

    public enum EventScopeCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case `public` = "PUBLIC"
        case accountSpecific = "ACCOUNT_SPECIFIC"
        case none = "NONE"
        public var description: String { return self.rawValue }
    }

    public enum EventStatusCode: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case closed = "closed"
        case open = "open"
        case upcoming = "upcoming"
        public var description: String { return self.rawValue }
    }

    public enum EventTypeCategory: String, CustomStringConvertible, Codable, Sendable, CodingKeyRepresentable {
        case accountNotification = "accountNotification"
        case investigation = "investigation"
        case issue = "issue"
        case scheduledChange = "scheduledChange"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AccountEntityAggregate: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public let accountId: String?
        /// The number of entities that match the filter criteria for the specified events.
        public let count: Int?
        /// The number of affected entities aggregated by the entity status codes.
        public let statuses: [EntityStatusCode: Int]?

        public init(accountId: String? = nil, count: Int? = nil, statuses: [EntityStatusCode: Int]? = nil) {
            self.accountId = accountId
            self.count = count
            self.statuses = statuses
        }

        private enum CodingKeys: String, CodingKey {
            case accountId = "accountId"
            case count = "count"
            case statuses = "statuses"
        }
    }

    public struct AffectedEntity: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account number that contains the affected entity.
        public let awsAccountId: String?
        /// The unique identifier for the entity. Format: arn:aws:health:entity-region:aws-account:entity/entity-id . Example: arn:aws:health:us-east-1:111222333444:entity/AVh5GGT7ul1arKr1sE1K
        public let entityArn: String?
        /// The URL of the affected entity.
        public let entityUrl: String?
        /// The ID of the affected entity.
        public let entityValue: String?
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String?
        /// The most recent time that the entity was updated.
        public let lastUpdatedTime: Date?
        /// The most recent status of the entity affected by the event. The possible values are IMPAIRED, UNIMPAIRED, and UNKNOWN.
        public let statusCode: EntityStatusCode?
        /// A map of entity tags attached to the affected entity.  Currently, the tags property isn't supported.
        public let tags: [String: String]?

        public init(awsAccountId: String? = nil, entityArn: String? = nil, entityUrl: String? = nil, entityValue: String? = nil, eventArn: String? = nil, lastUpdatedTime: Date? = nil, statusCode: EntityStatusCode? = nil, tags: [String: String]? = nil) {
            self.awsAccountId = awsAccountId
            self.entityArn = entityArn
            self.entityUrl = entityUrl
            self.entityValue = entityValue
            self.eventArn = eventArn
            self.lastUpdatedTime = lastUpdatedTime
            self.statusCode = statusCode
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case entityArn = "entityArn"
            case entityUrl = "entityUrl"
            case entityValue = "entityValue"
            case eventArn = "eventArn"
            case lastUpdatedTime = "lastUpdatedTime"
            case statusCode = "statusCode"
            case tags = "tags"
        }
    }

    public struct DateTimeRange: AWSEncodableShape {
        /// The starting date and time of a time range.
        public let from: Date?
        /// The ending date and time of a time range.
        public let to: Date?

        public init(from: Date? = nil, to: Date? = nil) {
            self.from = from
            self.to = to
        }

        private enum CodingKeys: String, CodingKey {
            case from = "from"
            case to = "to"
        }
    }

    public struct DescribeAffectedAccountsForOrganizationRequest: AWSEncodableShape {
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public let maxResults: Int?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(eventArn: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.eventArn = eventArn
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.eventArn, name: "eventArn", parent: name, max: 1600)
            try self.validate(self.eventArn, name: "eventArn", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 10)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=/+_.-]{4,10000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventArn = "eventArn"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeAffectedAccountsForOrganizationResponse: AWSDecodableShape {
        /// A JSON set of elements of the affected accounts.
        public let affectedAccounts: [String]?
        /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.   If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.   If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.   If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public let eventScopeCode: EventScopeCode?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(affectedAccounts: [String]? = nil, eventScopeCode: EventScopeCode? = nil, nextToken: String? = nil) {
            self.affectedAccounts = affectedAccounts
            self.eventScopeCode = eventScopeCode
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case affectedAccounts = "affectedAccounts"
            case eventScopeCode = "eventScopeCode"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeAffectedEntitiesForOrganizationRequest: AWSEncodableShape {
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public let locale: String?
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public let maxResults: Int?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?
        /// A JSON set of elements including the awsAccountId, eventArn and a set of statusCodes.
        public let organizationEntityAccountFilters: [EntityAccountFilter]?
        /// A JSON set of elements including the awsAccountId and the eventArn.
        public let organizationEntityFilters: [EventAccountFilter]?

        public init(locale: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationEntityAccountFilters: [EntityAccountFilter]? = nil) {
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationEntityAccountFilters = organizationEntityAccountFilters
            self.organizationEntityFilters = nil
        }

        @available(*, deprecated, message: "Members organizationEntityFilters have been deprecated")
        public init(locale: String? = nil, maxResults: Int? = nil, nextToken: String? = nil, organizationEntityAccountFilters: [EntityAccountFilter]? = nil, organizationEntityFilters: [EventAccountFilter]? = nil) {
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.organizationEntityAccountFilters = organizationEntityAccountFilters
            self.organizationEntityFilters = organizationEntityFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 2)
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^.{2,256}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=/+_.-]{4,10000}$")
            try self.organizationEntityAccountFilters?.forEach {
                try $0.validate(name: "\(name).organizationEntityAccountFilters[]")
            }
            try self.validate(self.organizationEntityAccountFilters, name: "organizationEntityAccountFilters", parent: name, max: 10)
            try self.validate(self.organizationEntityAccountFilters, name: "organizationEntityAccountFilters", parent: name, min: 1)
            try self.organizationEntityFilters?.forEach {
                try $0.validate(name: "\(name).organizationEntityFilters[]")
            }
            try self.validate(self.organizationEntityFilters, name: "organizationEntityFilters", parent: name, max: 10)
            try self.validate(self.organizationEntityFilters, name: "organizationEntityFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "locale"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
            case organizationEntityAccountFilters = "organizationEntityAccountFilters"
            case organizationEntityFilters = "organizationEntityFilters"
        }
    }

    public struct DescribeAffectedEntitiesForOrganizationResponse: AWSDecodableShape {
        /// A JSON set of elements including the awsAccountId and its entityArn, entityValue and its entityArn, lastUpdatedTime, and statusCode.
        public let entities: [AffectedEntity]?
        /// A JSON set of elements of the failed response, including the awsAccountId, errorMessage, errorName, and eventArn.
        public let failedSet: [OrganizationAffectedEntitiesErrorItem]?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(entities: [AffectedEntity]? = nil, failedSet: [OrganizationAffectedEntitiesErrorItem]? = nil, nextToken: String? = nil) {
            self.entities = entities
            self.failedSet = failedSet
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case failedSet = "failedSet"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeAffectedEntitiesRequest: AWSEncodableShape {
        /// Values to narrow the results returned. At least one event ARN is required.
        public let filter: EntityFilter
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public let locale: String?
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public let maxResults: Int?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(filter: EntityFilter, locale: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter.validate(name: "\(name).filter")
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 2)
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^.{2,256}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 10)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=/+_.-]{4,10000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case locale = "locale"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeAffectedEntitiesResponse: AWSDecodableShape {
        /// The entities that match the filter criteria.
        public let entities: [AffectedEntity]?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(entities: [AffectedEntity]? = nil, nextToken: String? = nil) {
            self.entities = entities
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case entities = "entities"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEntityAggregatesForOrganizationRequest: AWSEncodableShape {
        /// A list of 12-digit Amazon Web Services account numbers that contains the affected entities.
        public let awsAccountIds: [String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public let eventArns: [String]

        public init(awsAccountIds: [String]? = nil, eventArns: [String]) {
            self.awsAccountIds = awsAccountIds
            self.eventArns = eventArns
        }

        public func validate(name: String) throws {
            try self.awsAccountIds?.forEach {
                try validate($0, name: "awsAccountIds[]", parent: name, max: 12)
                try validate($0, name: "awsAccountIds[]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.awsAccountIds, name: "awsAccountIds", parent: name, max: 25)
            try self.validate(self.awsAccountIds, name: "awsAccountIds", parent: name, min: 1)
            try self.eventArns.forEach {
                try validate($0, name: "eventArns[]", parent: name, max: 1600)
                try validate($0, name: "eventArns[]", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
            }
            try self.validate(self.eventArns, name: "eventArns", parent: name, max: 25)
            try self.validate(self.eventArns, name: "eventArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountIds = "awsAccountIds"
            case eventArns = "eventArns"
        }
    }

    public struct DescribeEntityAggregatesForOrganizationResponse: AWSDecodableShape {
        /// The list of entity aggregates for each of the specified accounts that are affected by each of the specified events.
        public let organizationEntityAggregates: [OrganizationEntityAggregate]?

        public init(organizationEntityAggregates: [OrganizationEntityAggregate]? = nil) {
            self.organizationEntityAggregates = organizationEntityAggregates
        }

        private enum CodingKeys: String, CodingKey {
            case organizationEntityAggregates = "organizationEntityAggregates"
        }
    }

    public struct DescribeEntityAggregatesRequest: AWSEncodableShape {
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public let eventArns: [String]?

        public init(eventArns: [String]? = nil) {
            self.eventArns = eventArns
        }

        public func validate(name: String) throws {
            try self.eventArns?.forEach {
                try validate($0, name: "eventArns[]", parent: name, max: 1600)
                try validate($0, name: "eventArns[]", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
            }
            try self.validate(self.eventArns, name: "eventArns", parent: name, max: 50)
            try self.validate(self.eventArns, name: "eventArns", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventArns = "eventArns"
        }
    }

    public struct DescribeEntityAggregatesResponse: AWSDecodableShape {
        /// The number of entities that are affected by each of the specified events.
        public let entityAggregates: [EntityAggregate]?

        public init(entityAggregates: [EntityAggregate]? = nil) {
            self.entityAggregates = entityAggregates
        }

        private enum CodingKeys: String, CodingKey {
            case entityAggregates = "entityAggregates"
        }
    }

    public struct DescribeEventAggregatesRequest: AWSEncodableShape {
        /// The only currently supported value is eventTypeCategory.
        public let aggregateField: EventAggregateField
        /// Values to narrow the results returned.
        public let filter: EventFilter?
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public let maxResults: Int?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(aggregateField: EventAggregateField, filter: EventFilter? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.aggregateField = aggregateField
            self.filter = filter
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 10)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=/+_.-]{4,10000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateField = "aggregateField"
            case filter = "filter"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEventAggregatesResponse: AWSDecodableShape {
        /// The number of events in each category that meet the optional filter criteria.
        public let eventAggregates: [EventAggregate]?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(eventAggregates: [EventAggregate]? = nil, nextToken: String? = nil) {
            self.eventAggregates = eventAggregates
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventAggregates = "eventAggregates"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEventDetailsForOrganizationRequest: AWSEncodableShape {
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public let locale: String?
        /// A set of JSON elements that includes the awsAccountId and the eventArn.
        public let organizationEventDetailFilters: [EventAccountFilter]

        public init(locale: String? = nil, organizationEventDetailFilters: [EventAccountFilter]) {
            self.locale = locale
            self.organizationEventDetailFilters = organizationEventDetailFilters
        }

        public func validate(name: String) throws {
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 2)
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^.{2,256}$")
            try self.organizationEventDetailFilters.forEach {
                try $0.validate(name: "\(name).organizationEventDetailFilters[]")
            }
            try self.validate(self.organizationEventDetailFilters, name: "organizationEventDetailFilters", parent: name, max: 10)
            try self.validate(self.organizationEventDetailFilters, name: "organizationEventDetailFilters", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case locale = "locale"
            case organizationEventDetailFilters = "organizationEventDetailFilters"
        }
    }

    public struct DescribeEventDetailsForOrganizationResponse: AWSDecodableShape {
        /// Error messages for any events that could not be retrieved.
        public let failedSet: [OrganizationEventDetailsErrorItem]?
        /// Information about the events that could be retrieved.
        public let successfulSet: [OrganizationEventDetails]?

        public init(failedSet: [OrganizationEventDetailsErrorItem]? = nil, successfulSet: [OrganizationEventDetails]? = nil) {
            self.failedSet = failedSet
            self.successfulSet = successfulSet
        }

        private enum CodingKeys: String, CodingKey {
            case failedSet = "failedSet"
            case successfulSet = "successfulSet"
        }
    }

    public struct DescribeEventDetailsRequest: AWSEncodableShape {
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public let eventArns: [String]
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public let locale: String?

        public init(eventArns: [String], locale: String? = nil) {
            self.eventArns = eventArns
            self.locale = locale
        }

        public func validate(name: String) throws {
            try self.eventArns.forEach {
                try validate($0, name: "eventArns[]", parent: name, max: 1600)
                try validate($0, name: "eventArns[]", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
            }
            try self.validate(self.eventArns, name: "eventArns", parent: name, max: 10)
            try self.validate(self.eventArns, name: "eventArns", parent: name, min: 1)
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 2)
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^.{2,256}$")
        }

        private enum CodingKeys: String, CodingKey {
            case eventArns = "eventArns"
            case locale = "locale"
        }
    }

    public struct DescribeEventDetailsResponse: AWSDecodableShape {
        /// Error messages for any events that could not be retrieved.
        public let failedSet: [EventDetailsErrorItem]?
        /// Information about the events that could be retrieved.
        public let successfulSet: [EventDetails]?

        public init(failedSet: [EventDetailsErrorItem]? = nil, successfulSet: [EventDetails]? = nil) {
            self.failedSet = failedSet
            self.successfulSet = successfulSet
        }

        private enum CodingKeys: String, CodingKey {
            case failedSet = "failedSet"
            case successfulSet = "successfulSet"
        }
    }

    public struct DescribeEventTypesRequest: AWSEncodableShape {
        /// Values to narrow the results returned.
        public let filter: EventTypeFilter?
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public let locale: String?
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.  If you don't specify the maxResults parameter, this operation returns a maximum of 30 items by default.
        public let maxResults: Int?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(filter: EventTypeFilter? = nil, locale: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 2)
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^.{2,256}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 10)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=/+_.-]{4,10000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case locale = "locale"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEventTypesResponse: AWSDecodableShape {
        /// A list of event types that match the filter criteria. Event types have a category (issue, accountNotification, or scheduledChange), a service (for example, EC2, RDS, DATAPIPELINE, BILLING), and a code (in the format AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT).
        public let eventTypes: [EventType]?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(eventTypes: [EventType]? = nil, nextToken: String? = nil) {
            self.eventTypes = eventTypes
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypes = "eventTypes"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEventsForOrganizationRequest: AWSEncodableShape {
        /// Values to narrow the results returned.
        public let filter: OrganizationEventFilter?
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public let locale: String?
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public let maxResults: Int?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(filter: OrganizationEventFilter? = nil, locale: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 2)
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^.{2,256}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=/+_.-]{4,10000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case locale = "locale"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEventsForOrganizationResponse: AWSDecodableShape {
        /// The events that match the specified filter criteria.
        public let events: [OrganizationEvent]?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(events: [OrganizationEvent]? = nil, nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEventsRequest: AWSEncodableShape {
        /// Values to narrow the results returned.
        public let filter: EventFilter?
        /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
        public let locale: String?
        /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
        public let maxResults: Int?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(filter: EventFilter? = nil, locale: String? = nil, maxResults: Int? = nil, nextToken: String? = nil) {
            self.filter = filter
            self.locale = locale
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.filter?.validate(name: "\(name).filter")
            try self.validate(self.locale, name: "locale", parent: name, max: 256)
            try self.validate(self.locale, name: "locale", parent: name, min: 2)
            try self.validate(self.locale, name: "locale", parent: name, pattern: "^.{2,256}$")
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 10)
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 10000)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 4)
            try self.validate(self.nextToken, name: "nextToken", parent: name, pattern: "^[a-zA-Z0-9=/+_.-]{4,10000}$")
        }

        private enum CodingKeys: String, CodingKey {
            case filter = "filter"
            case locale = "locale"
            case maxResults = "maxResults"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeEventsResponse: AWSDecodableShape {
        /// The events that match the specified filter criteria.
        public let events: [Event]?
        /// If the results of a search are large, only a portion of the
        /// results are returned, and a nextToken pagination token is returned in the response. To
        /// retrieve the next batch of results, reissue the search request and include the returned token.
        /// When all results have been returned, the response does not contain a pagination token value.
        public let nextToken: String?

        public init(events: [Event]? = nil, nextToken: String? = nil) {
            self.events = events
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case events = "events"
            case nextToken = "nextToken"
        }
    }

    public struct DescribeHealthServiceStatusForOrganizationResponse: AWSDecodableShape {
        /// Information about the status of enabling or disabling the Health organizational view feature in your organization. Valid values are ENABLED | DISABLED | PENDING.
        public let healthServiceAccessStatusForOrganization: String?

        public init(healthServiceAccessStatusForOrganization: String? = nil) {
            self.healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganization
        }

        private enum CodingKeys: String, CodingKey {
            case healthServiceAccessStatusForOrganization = "healthServiceAccessStatusForOrganization"
        }
    }

    public struct EntityAccountFilter: AWSEncodableShape {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public let awsAccountId: String?
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String
        /// A list of entity status codes.
        public let statusCodes: [EntityStatusCode]?

        public init(awsAccountId: String? = nil, eventArn: String, statusCodes: [EntityStatusCode]? = nil) {
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
            self.statusCodes = statusCodes
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\S+$")
            try self.validate(self.eventArn, name: "eventArn", parent: name, max: 1600)
            try self.validate(self.eventArn, name: "eventArn", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
            try self.validate(self.statusCodes, name: "statusCodes", parent: name, max: 5)
            try self.validate(self.statusCodes, name: "statusCodes", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case eventArn = "eventArn"
            case statusCodes = "statusCodes"
        }
    }

    public struct EntityAggregate: AWSDecodableShape {
        /// The number of entities that match the criteria for the specified events.
        public let count: Int?
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String?
        /// The number of affected entities aggregated by the entity status codes.
        public let statuses: [EntityStatusCode: Int]?

        public init(count: Int? = nil, eventArn: String? = nil, statuses: [EntityStatusCode: Int]? = nil) {
            self.count = count
            self.eventArn = eventArn
            self.statuses = statuses
        }

        private enum CodingKeys: String, CodingKey {
            case count = "count"
            case eventArn = "eventArn"
            case statuses = "statuses"
        }
    }

    public struct EntityFilter: AWSEncodableShape {
        /// A list of entity ARNs (unique identifiers).
        public let entityArns: [String]?
        /// A list of IDs for affected entities.
        public let entityValues: [String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public let eventArns: [String]
        /// A list of the most recent dates and times that the entity was updated.
        public let lastUpdatedTimes: [DateTimeRange]?
        /// A list of entity status codes (IMPAIRED, UNIMPAIRED, or UNKNOWN).
        public let statusCodes: [EntityStatusCode]?
        /// A map of entity tags attached to the affected entity.  Currently, the tags property isn't supported.
        public let tags: [[String: String]]?

        public init(entityArns: [String]? = nil, entityValues: [String]? = nil, eventArns: [String], lastUpdatedTimes: [DateTimeRange]? = nil, statusCodes: [EntityStatusCode]? = nil, tags: [[String: String]]? = nil) {
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.lastUpdatedTimes = lastUpdatedTimes
            self.statusCodes = statusCodes
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.entityArns?.forEach {
                try validate($0, name: "entityArns[]", parent: name, max: 1600)
                try validate($0, name: "entityArns[]", parent: name, pattern: "^.{0,1600}$")
            }
            try self.validate(self.entityArns, name: "entityArns", parent: name, max: 99)
            try self.validate(self.entityArns, name: "entityArns", parent: name, min: 1)
            try self.entityValues?.forEach {
                try validate($0, name: "entityValues[]", parent: name, max: 1224)
                try validate($0, name: "entityValues[]", parent: name, pattern: "^.{0,1224}$")
            }
            try self.validate(self.entityValues, name: "entityValues", parent: name, max: 99)
            try self.validate(self.entityValues, name: "entityValues", parent: name, min: 1)
            try self.eventArns.forEach {
                try validate($0, name: "eventArns[]", parent: name, max: 1600)
                try validate($0, name: "eventArns[]", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
            }
            try self.validate(self.eventArns, name: "eventArns", parent: name, max: 10)
            try self.validate(self.eventArns, name: "eventArns", parent: name, min: 1)
            try self.validate(self.lastUpdatedTimes, name: "lastUpdatedTimes", parent: name, max: 10)
            try self.validate(self.lastUpdatedTimes, name: "lastUpdatedTimes", parent: name, min: 1)
            try self.validate(self.statusCodes, name: "statusCodes", parent: name, max: 5)
            try self.validate(self.statusCodes, name: "statusCodes", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0, name: "tags[]", parent: name, max: 50)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case entityArns = "entityArns"
            case entityValues = "entityValues"
            case eventArns = "eventArns"
            case lastUpdatedTimes = "lastUpdatedTimes"
            case statusCodes = "statusCodes"
            case tags = "tags"
        }
    }

    public struct Event: AWSDecodableShape {
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let arn: String?
        /// The Amazon Web Services Availability Zone of the event. For example, us-east-1a.
        public let availabilityZone: String?
        /// The date and time that the event ended.
        public let endTime: Date?
        /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.   If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.   If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.   If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public let eventScopeCode: EventScopeCode?
        /// A list of event type category codes. Possible values are
        /// issue, accountNotification, or scheduledChange. Currently,
        /// the investigation value isn't supported at this time.
        public let eventTypeCategory: EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public let eventTypeCode: String?
        /// The most recent date and time that the event was updated.
        public let lastUpdatedTime: Date?
        /// The Amazon Web Services Region name of the event.
        public let region: String?
        /// The Amazon Web Service that is affected by the event. For example, EC2, RDS.
        public let service: String?
        /// The date and time that the event began.
        public let startTime: Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public let statusCode: EventStatusCode?

        public init(arn: String? = nil, availabilityZone: String? = nil, endTime: Date? = nil, eventScopeCode: EventScopeCode? = nil, eventTypeCategory: EventTypeCategory? = nil, eventTypeCode: String? = nil, lastUpdatedTime: Date? = nil, region: String? = nil, service: String? = nil, startTime: Date? = nil, statusCode: EventStatusCode? = nil) {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case availabilityZone = "availabilityZone"
            case endTime = "endTime"
            case eventScopeCode = "eventScopeCode"
            case eventTypeCategory = "eventTypeCategory"
            case eventTypeCode = "eventTypeCode"
            case lastUpdatedTime = "lastUpdatedTime"
            case region = "region"
            case service = "service"
            case startTime = "startTime"
            case statusCode = "statusCode"
        }
    }

    public struct EventAccountFilter: AWSEncodableShape {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public let awsAccountId: String?
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String

        public init(awsAccountId: String? = nil, eventArn: String) {
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
        }

        public func validate(name: String) throws {
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, max: 12)
            try self.validate(self.awsAccountId, name: "awsAccountId", parent: name, pattern: "^\\S+$")
            try self.validate(self.eventArn, name: "eventArn", parent: name, max: 1600)
            try self.validate(self.eventArn, name: "eventArn", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case eventArn = "eventArn"
        }
    }

    public struct EventAggregate: AWSDecodableShape {
        /// The issue type for the associated count.
        public let aggregateValue: String?
        /// The number of events of the associated issue type.
        public let count: Int?

        public init(aggregateValue: String? = nil, count: Int? = nil) {
            self.aggregateValue = aggregateValue
            self.count = count
        }

        private enum CodingKeys: String, CodingKey {
            case aggregateValue = "aggregateValue"
            case count = "count"
        }
    }

    public struct EventDescription: AWSDecodableShape {
        /// The most recent description of the event.
        public let latestDescription: String?

        public init(latestDescription: String? = nil) {
            self.latestDescription = latestDescription
        }

        private enum CodingKeys: String, CodingKey {
            case latestDescription = "latestDescription"
        }
    }

    public struct EventDetails: AWSDecodableShape {
        /// Summary information about the event.
        public let event: Event?
        /// The most recent description of the event.
        public let eventDescription: EventDescription?
        /// Additional metadata about the event.
        public let eventMetadata: [String: String]?

        public init(event: Event? = nil, eventDescription: EventDescription? = nil, eventMetadata: [String: String]? = nil) {
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case event = "event"
            case eventDescription = "eventDescription"
            case eventMetadata = "eventMetadata"
        }
    }

    public struct EventDetailsErrorItem: AWSDecodableShape {
        /// A message that describes the error.
        public let errorMessage: String?
        /// The name of the error.
        public let errorName: String?
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String?

        public init(errorMessage: String? = nil, errorName: String? = nil, eventArn: String? = nil) {
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }

        private enum CodingKeys: String, CodingKey {
            case errorMessage = "errorMessage"
            case errorName = "errorName"
            case eventArn = "eventArn"
        }
    }

    public struct EventFilter: AWSEncodableShape {
        /// A list of Amazon Web Services Availability Zones.
        public let availabilityZones: [String]?
        /// A list of dates and times that the event ended.
        public let endTimes: [DateTimeRange]?
        /// A list of entity ARNs (unique identifiers).
        public let entityArns: [String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public let entityValues: [String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public let eventArns: [String]?
        /// A list of event status codes.
        public let eventStatusCodes: [EventStatusCode]?
        /// A list of event type category codes. Possible values are
        /// issue, accountNotification, or scheduledChange. Currently,
        /// the investigation value isn't supported at this time.
        public let eventTypeCategories: [EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public let eventTypeCodes: [String]?
        /// A list of dates and times that the event was last updated.
        public let lastUpdatedTimes: [DateTimeRange]?
        /// A list of Amazon Web Services Regions.
        public let regions: [String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public let services: [String]?
        /// A list of dates and times that the event began.
        public let startTimes: [DateTimeRange]?
        /// A map of entity tags attached to the affected entity.  Currently, the tags property isn't supported.
        public let tags: [[String: String]]?

        public init(availabilityZones: [String]? = nil, endTimes: [DateTimeRange]? = nil, entityArns: [String]? = nil, entityValues: [String]? = nil, eventArns: [String]? = nil, eventStatusCodes: [EventStatusCode]? = nil, eventTypeCategories: [EventTypeCategory]? = nil, eventTypeCodes: [String]? = nil, lastUpdatedTimes: [DateTimeRange]? = nil, regions: [String]? = nil, services: [String]? = nil, startTimes: [DateTimeRange]? = nil, tags: [[String: String]]? = nil) {
            self.availabilityZones = availabilityZones
            self.endTimes = endTimes
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTimes = lastUpdatedTimes
            self.regions = regions
            self.services = services
            self.startTimes = startTimes
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.availabilityZones?.forEach {
                try validate($0, name: "availabilityZones[]", parent: name, max: 18)
                try validate($0, name: "availabilityZones[]", parent: name, min: 6)
                try validate($0, name: "availabilityZones[]", parent: name, pattern: "^[a-z]{2}\\-[0-9a-z\\-]{4,16}$")
            }
            try self.validate(self.endTimes, name: "endTimes", parent: name, max: 10)
            try self.validate(self.endTimes, name: "endTimes", parent: name, min: 1)
            try self.entityArns?.forEach {
                try validate($0, name: "entityArns[]", parent: name, max: 1600)
                try validate($0, name: "entityArns[]", parent: name, pattern: "^.{0,1600}$")
            }
            try self.validate(self.entityArns, name: "entityArns", parent: name, max: 99)
            try self.validate(self.entityArns, name: "entityArns", parent: name, min: 1)
            try self.entityValues?.forEach {
                try validate($0, name: "entityValues[]", parent: name, max: 1224)
                try validate($0, name: "entityValues[]", parent: name, pattern: "^.{0,1224}$")
            }
            try self.validate(self.entityValues, name: "entityValues", parent: name, max: 99)
            try self.validate(self.entityValues, name: "entityValues", parent: name, min: 1)
            try self.eventArns?.forEach {
                try validate($0, name: "eventArns[]", parent: name, max: 1600)
                try validate($0, name: "eventArns[]", parent: name, pattern: "^arn:aws(-[a-z]+(-[a-z]+)?)?:health:[^:]*:[^:]*:event(?:/[\\w-]+){3}$")
            }
            try self.validate(self.eventArns, name: "eventArns", parent: name, max: 10)
            try self.validate(self.eventArns, name: "eventArns", parent: name, min: 1)
            try self.validate(self.eventStatusCodes, name: "eventStatusCodes", parent: name, max: 6)
            try self.validate(self.eventStatusCodes, name: "eventStatusCodes", parent: name, min: 1)
            try self.validate(self.eventTypeCategories, name: "eventTypeCategories", parent: name, max: 10)
            try self.validate(self.eventTypeCategories, name: "eventTypeCategories", parent: name, min: 1)
            try self.eventTypeCodes?.forEach {
                try validate($0, name: "eventTypeCodes[]", parent: name, max: 100)
                try validate($0, name: "eventTypeCodes[]", parent: name, min: 3)
                try validate($0, name: "eventTypeCodes[]", parent: name, pattern: "^[^:/]{3,100}$")
            }
            try self.validate(self.eventTypeCodes, name: "eventTypeCodes", parent: name, max: 10)
            try self.validate(self.eventTypeCodes, name: "eventTypeCodes", parent: name, min: 1)
            try self.validate(self.lastUpdatedTimes, name: "lastUpdatedTimes", parent: name, max: 10)
            try self.validate(self.lastUpdatedTimes, name: "lastUpdatedTimes", parent: name, min: 1)
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, max: 25)
                try validate($0, name: "regions[]", parent: name, min: 2)
                try validate($0, name: "regions[]", parent: name, pattern: "^[^:/]{2,25}$")
            }
            try self.validate(self.regions, name: "regions", parent: name, max: 10)
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
            try self.services?.forEach {
                try validate($0, name: "services[]", parent: name, max: 30)
                try validate($0, name: "services[]", parent: name, min: 2)
                try validate($0, name: "services[]", parent: name, pattern: "^[^:/]{2,30}$")
            }
            try self.validate(self.services, name: "services", parent: name, max: 10)
            try self.validate(self.services, name: "services", parent: name, min: 1)
            try self.validate(self.startTimes, name: "startTimes", parent: name, max: 10)
            try self.validate(self.startTimes, name: "startTimes", parent: name, min: 1)
            try self.tags?.forEach {
                try validate($0, name: "tags[]", parent: name, max: 50)
            }
            try self.validate(self.tags, name: "tags", parent: name, max: 50)
        }

        private enum CodingKeys: String, CodingKey {
            case availabilityZones = "availabilityZones"
            case endTimes = "endTimes"
            case entityArns = "entityArns"
            case entityValues = "entityValues"
            case eventArns = "eventArns"
            case eventStatusCodes = "eventStatusCodes"
            case eventTypeCategories = "eventTypeCategories"
            case eventTypeCodes = "eventTypeCodes"
            case lastUpdatedTimes = "lastUpdatedTimes"
            case regions = "regions"
            case services = "services"
            case startTimes = "startTimes"
            case tags = "tags"
        }
    }

    public struct EventType: AWSDecodableShape {
        /// A list of event type category codes. Possible values are
        /// issue, accountNotification, or scheduledChange. Currently,
        /// the investigation value isn't supported at this time.
        public let category: EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public let code: String?
        /// The Amazon Web Service that is affected by the event. For example, EC2, RDS.
        public let service: String?

        public init(category: EventTypeCategory? = nil, code: String? = nil, service: String? = nil) {
            self.category = category
            self.code = code
            self.service = service
        }

        private enum CodingKeys: String, CodingKey {
            case category = "category"
            case code = "code"
            case service = "service"
        }
    }

    public struct EventTypeFilter: AWSEncodableShape {
        /// A list of event type category codes. Possible values are
        /// issue, accountNotification, or scheduledChange. Currently,
        /// the investigation value isn't supported at this time.
        public let eventTypeCategories: [EventTypeCategory]?
        /// A list of event type codes.
        public let eventTypeCodes: [String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public let services: [String]?

        public init(eventTypeCategories: [EventTypeCategory]? = nil, eventTypeCodes: [String]? = nil, services: [String]? = nil) {
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.services = services
        }

        public func validate(name: String) throws {
            try self.validate(self.eventTypeCategories, name: "eventTypeCategories", parent: name, max: 10)
            try self.validate(self.eventTypeCategories, name: "eventTypeCategories", parent: name, min: 1)
            try self.eventTypeCodes?.forEach {
                try validate($0, name: "eventTypeCodes[]", parent: name, max: 100)
                try validate($0, name: "eventTypeCodes[]", parent: name, min: 3)
                try validate($0, name: "eventTypeCodes[]", parent: name, pattern: "^[a-zA-Z0-9\\_\\-]{3,100}$")
            }
            try self.validate(self.eventTypeCodes, name: "eventTypeCodes", parent: name, max: 10)
            try self.validate(self.eventTypeCodes, name: "eventTypeCodes", parent: name, min: 1)
            try self.services?.forEach {
                try validate($0, name: "services[]", parent: name, max: 30)
                try validate($0, name: "services[]", parent: name, min: 2)
                try validate($0, name: "services[]", parent: name, pattern: "^[^:/]{2,30}$")
            }
            try self.validate(self.services, name: "services", parent: name, max: 10)
            try self.validate(self.services, name: "services", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case eventTypeCategories = "eventTypeCategories"
            case eventTypeCodes = "eventTypeCodes"
            case services = "services"
        }
    }

    public struct OrganizationAffectedEntitiesErrorItem: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public let awsAccountId: String?
        /// A message that describes the error. Follow the error message and retry your request. For example, the InvalidAccountInputError error message appears if you call the DescribeAffectedEntitiesForOrganization operation and specify the AccountSpecific value for the EventScopeCode parameter, but don't specify an Amazon Web Services account.
        public let errorMessage: String?
        /// The name of the error.
        public let errorName: String?
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String?

        public init(awsAccountId: String? = nil, errorMessage: String? = nil, errorName: String? = nil, eventArn: String? = nil) {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case errorMessage = "errorMessage"
            case errorName = "errorName"
            case eventArn = "eventArn"
        }
    }

    public struct OrganizationEntityAggregate: AWSDecodableShape {
        /// A list of entity aggregates for each of the specified accounts in your organization that are affected by a specific event. If there are no awsAccountIds provided in the request, this field will be empty in the response.
        public let accounts: [AccountEntityAggregate]?
        /// The number of entities for the organization that match the filter criteria for the specified events.
        public let count: Int?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public let eventArn: String?
        /// The number of affected entities aggregated by the entitiy status codes.
        public let statuses: [EntityStatusCode: Int]?

        public init(accounts: [AccountEntityAggregate]? = nil, count: Int? = nil, eventArn: String? = nil, statuses: [EntityStatusCode: Int]? = nil) {
            self.accounts = accounts
            self.count = count
            self.eventArn = eventArn
            self.statuses = statuses
        }

        private enum CodingKeys: String, CodingKey {
            case accounts = "accounts"
            case count = "count"
            case eventArn = "eventArn"
            case statuses = "statuses"
        }
    }

    public struct OrganizationEvent: AWSDecodableShape {
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let arn: String?
        /// The date and time that the event ended.
        public let endTime: Date?
        /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.   If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.   If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.   If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public let eventScopeCode: EventScopeCode?
        /// A list of event type category codes. Possible values are
        /// issue, accountNotification, or scheduledChange. Currently,
        /// the investigation value isn't supported at this time.
        public let eventTypeCategory: EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION. For example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public let eventTypeCode: String?
        /// The most recent date and time that the event was updated.
        public let lastUpdatedTime: Date?
        /// The Amazon Web Services Region name of the event.
        public let region: String?
        /// The Amazon Web Service that is affected by the event, such as EC2 and RDS.
        public let service: String?
        /// The date and time that the event began.
        public let startTime: Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public let statusCode: EventStatusCode?

        public init(arn: String? = nil, endTime: Date? = nil, eventScopeCode: EventScopeCode? = nil, eventTypeCategory: EventTypeCategory? = nil, eventTypeCode: String? = nil, lastUpdatedTime: Date? = nil, region: String? = nil, service: String? = nil, startTime: Date? = nil, statusCode: EventStatusCode? = nil) {
            self.arn = arn
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case arn = "arn"
            case endTime = "endTime"
            case eventScopeCode = "eventScopeCode"
            case eventTypeCategory = "eventTypeCategory"
            case eventTypeCode = "eventTypeCode"
            case lastUpdatedTime = "lastUpdatedTime"
            case region = "region"
            case service = "service"
            case startTime = "startTime"
            case statusCode = "statusCode"
        }
    }

    public struct OrganizationEventDetails: AWSDecodableShape {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public let awsAccountId: String?
        public let event: Event?
        public let eventDescription: EventDescription?
        /// Additional metadata about the event.
        public let eventMetadata: [String: String]?

        public init(awsAccountId: String? = nil, event: Event? = nil, eventDescription: EventDescription? = nil, eventMetadata: [String: String]? = nil) {
            self.awsAccountId = awsAccountId
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case event = "event"
            case eventDescription = "eventDescription"
            case eventMetadata = "eventMetadata"
        }
    }

    public struct OrganizationEventDetailsErrorItem: AWSDecodableShape {
        /// Error information returned when a DescribeEventDetailsForOrganization operation can't find a specified event.
        public let awsAccountId: String?
        /// A message that describes the error. If you call the DescribeEventDetailsForOrganization operation and receive one of the following errors, follow the recommendations in the message:   We couldn't find a public event that matches your request. To find an event that is account specific, you must enter an Amazon Web Services account ID in the request.   We couldn't find an account specific event for the specified Amazon Web Services account. To find an event that is public, you must enter a null value for the Amazon Web Services account ID in the request.   Your Amazon Web Services account doesn't include the Amazon Web Services Support plan required to use the
        /// Health API. You must have either a Business, Enterprise On-Ramp, or Enterprise Support plan.
        public let errorMessage: String?
        /// The name of the error.
        public let errorName: String?
        /// The unique identifier for the event. The event ARN has the
        /// arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID
        /// format. For example, an event ARN might look like the following:  arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public let eventArn: String?

        public init(awsAccountId: String? = nil, errorMessage: String? = nil, errorName: String? = nil, eventArn: String? = nil) {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountId = "awsAccountId"
            case errorMessage = "errorMessage"
            case errorName = "errorName"
            case eventArn = "eventArn"
        }
    }

    public struct OrganizationEventFilter: AWSEncodableShape {
        /// A list of 12-digit Amazon Web Services account numbers that contains the affected entities.
        public let awsAccountIds: [String]?
        public let endTime: DateTimeRange?
        /// A list of entity ARNs (unique identifiers).
        public let entityArns: [String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public let entityValues: [String]?
        /// A list of event status codes.
        public let eventStatusCodes: [EventStatusCode]?
        /// A list of event type category codes. Possible values are
        /// issue, accountNotification, or scheduledChange. Currently,
        /// the investigation value isn't supported at this time.
        public let eventTypeCategories: [EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public let eventTypeCodes: [String]?
        public let lastUpdatedTime: DateTimeRange?
        /// A list of Amazon Web Services Regions.
        public let regions: [String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public let services: [String]?
        public let startTime: DateTimeRange?

        public init(awsAccountIds: [String]? = nil, endTime: DateTimeRange? = nil, entityArns: [String]? = nil, entityValues: [String]? = nil, eventStatusCodes: [EventStatusCode]? = nil, eventTypeCategories: [EventTypeCategory]? = nil, eventTypeCodes: [String]? = nil, lastUpdatedTime: DateTimeRange? = nil, regions: [String]? = nil, services: [String]? = nil, startTime: DateTimeRange? = nil) {
            self.awsAccountIds = awsAccountIds
            self.endTime = endTime
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTime = lastUpdatedTime
            self.regions = regions
            self.services = services
            self.startTime = startTime
        }

        public func validate(name: String) throws {
            try self.awsAccountIds?.forEach {
                try validate($0, name: "awsAccountIds[]", parent: name, max: 12)
                try validate($0, name: "awsAccountIds[]", parent: name, pattern: "^\\S+$")
            }
            try self.validate(self.awsAccountIds, name: "awsAccountIds", parent: name, max: 50)
            try self.validate(self.awsAccountIds, name: "awsAccountIds", parent: name, min: 1)
            try self.entityArns?.forEach {
                try validate($0, name: "entityArns[]", parent: name, max: 1600)
                try validate($0, name: "entityArns[]", parent: name, pattern: "^.{0,1600}$")
            }
            try self.validate(self.entityArns, name: "entityArns", parent: name, max: 99)
            try self.validate(self.entityArns, name: "entityArns", parent: name, min: 1)
            try self.entityValues?.forEach {
                try validate($0, name: "entityValues[]", parent: name, max: 1224)
                try validate($0, name: "entityValues[]", parent: name, pattern: "^.{0,1224}$")
            }
            try self.validate(self.entityValues, name: "entityValues", parent: name, max: 99)
            try self.validate(self.entityValues, name: "entityValues", parent: name, min: 1)
            try self.validate(self.eventStatusCodes, name: "eventStatusCodes", parent: name, max: 6)
            try self.validate(self.eventStatusCodes, name: "eventStatusCodes", parent: name, min: 1)
            try self.validate(self.eventTypeCategories, name: "eventTypeCategories", parent: name, max: 10)
            try self.validate(self.eventTypeCategories, name: "eventTypeCategories", parent: name, min: 1)
            try self.eventTypeCodes?.forEach {
                try validate($0, name: "eventTypeCodes[]", parent: name, max: 100)
                try validate($0, name: "eventTypeCodes[]", parent: name, min: 3)
                try validate($0, name: "eventTypeCodes[]", parent: name, pattern: "^[^:/]{3,100}$")
            }
            try self.validate(self.eventTypeCodes, name: "eventTypeCodes", parent: name, max: 10)
            try self.validate(self.eventTypeCodes, name: "eventTypeCodes", parent: name, min: 1)
            try self.regions?.forEach {
                try validate($0, name: "regions[]", parent: name, max: 25)
                try validate($0, name: "regions[]", parent: name, min: 2)
                try validate($0, name: "regions[]", parent: name, pattern: "^[^:/]{2,25}$")
            }
            try self.validate(self.regions, name: "regions", parent: name, max: 10)
            try self.validate(self.regions, name: "regions", parent: name, min: 1)
            try self.services?.forEach {
                try validate($0, name: "services[]", parent: name, max: 30)
                try validate($0, name: "services[]", parent: name, min: 2)
                try validate($0, name: "services[]", parent: name, pattern: "^[^:/]{2,30}$")
            }
            try self.validate(self.services, name: "services", parent: name, max: 10)
            try self.validate(self.services, name: "services", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case awsAccountIds = "awsAccountIds"
            case endTime = "endTime"
            case entityArns = "entityArns"
            case entityValues = "entityValues"
            case eventStatusCodes = "eventStatusCodes"
            case eventTypeCategories = "eventTypeCategories"
            case eventTypeCodes = "eventTypeCodes"
            case lastUpdatedTime = "lastUpdatedTime"
            case regions = "regions"
            case services = "services"
            case startTime = "startTime"
        }
    }
}

// MARK: - Errors

/// Error enum for Health
public struct HealthErrorType: AWSErrorType {
    enum Code: String {
        case concurrentModificationException = "ConcurrentModificationException"
        case invalidPaginationToken = "InvalidPaginationToken"
        case unsupportedLocale = "UnsupportedLocale"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize Health
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    ///  EnableHealthServiceAccessForOrganization is already in progress. Wait for the action to complete before trying again. To get the current status, use the DescribeHealthServiceStatusForOrganization operation.
    public static var concurrentModificationException: Self { .init(.concurrentModificationException) }
    /// The specified pagination token (nextToken) is not valid.
    public static var invalidPaginationToken: Self { .init(.invalidPaginationToken) }
    /// The specified locale is not supported.
    public static var unsupportedLocale: Self { .init(.unsupportedLocale) }
}

extension HealthErrorType: Equatable {
    public static func == (lhs: HealthErrorType, rhs: HealthErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension HealthErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
