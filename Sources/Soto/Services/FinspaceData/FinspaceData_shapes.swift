//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2022 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto-codegenerator.
// DO NOT EDIT.

import Foundation
import SotoCore

extension FinspaceData {
    // MARK: Enums

    public enum ApiAccess: String, CustomStringConvertible, Codable, _SotoSendable {
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum ApplicationPermission: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessNotebooks = "AccessNotebooks"
        case createDataset = "CreateDataset"
        case getTemporaryCredentials = "GetTemporaryCredentials"
        case manageAttributeSets = "ManageAttributeSets"
        case manageClusters = "ManageClusters"
        case manageUsersAndGroups = "ManageUsersAndGroups"
        case viewAuditData = "ViewAuditData"
        public var description: String { return self.rawValue }
    }

    public enum ChangeType: String, CustomStringConvertible, Codable, _SotoSendable {
        case append = "APPEND"
        case modify = "MODIFY"
        case replace = "REPLACE"
        public var description: String { return self.rawValue }
    }

    public enum ColumnDataType: String, CustomStringConvertible, Codable, _SotoSendable {
        case bigint = "BIGINT"
        case binary = "BINARY"
        case boolean = "BOOLEAN"
        case char = "CHAR"
        case date = "DATE"
        case datetime = "DATETIME"
        case double = "DOUBLE"
        case float = "FLOAT"
        case integer = "INTEGER"
        case smallint = "SMALLINT"
        case string = "STRING"
        case tinyint = "TINYINT"
        public var description: String { return self.rawValue }
    }

    public enum DataViewStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case cancelled = "CANCELLED"
        case failed = "FAILED"
        case failedCleanupFailed = "FAILED_CLEANUP_FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case starting = "STARTING"
        case success = "SUCCESS"
        case timeout = "TIMEOUT"
        public var description: String { return self.rawValue }
    }

    public enum DatasetKind: String, CustomStringConvertible, Codable, _SotoSendable {
        case nonTabular = "NON_TABULAR"
        case tabular = "TABULAR"
        public var description: String { return self.rawValue }
    }

    public enum DatasetStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum ErrorCategory: String, CustomStringConvertible, Codable, _SotoSendable {
        case accessDenied = "ACCESS_DENIED"
        case cancelled = "CANCELLED"
        case internalServiceException = "INTERNAL_SERVICE_EXCEPTION"
        case resourceNotFound = "RESOURCE_NOT_FOUND"
        case serviceQuotaExceeded = "SERVICE_QUOTA_EXCEEDED"
        case throttling = "THROTTLING"
        case userRecoverable = "USER_RECOVERABLE"
        case validation = "VALIDATION"
        public var description: String { return self.rawValue }
    }

    public enum ExportFileFormat: String, CustomStringConvertible, Codable, _SotoSendable {
        case delimitedText = "DELIMITED_TEXT"
        case parquet = "PARQUET"
        public var description: String { return self.rawValue }
    }

    public enum IngestionStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case failed = "FAILED"
        case pending = "PENDING"
        case running = "RUNNING"
        case stopRequested = "STOP_REQUESTED"
        case success = "SUCCESS"
        public var description: String { return self.rawValue }
    }

    public enum LocationType: String, CustomStringConvertible, Codable, _SotoSendable {
        case ingestion = "INGESTION"
        case sagemaker = "SAGEMAKER"
        public var description: String { return self.rawValue }
    }

    public enum PermissionGroupMembershipStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case additionInProgress = "ADDITION_IN_PROGRESS"
        case additionSuccess = "ADDITION_SUCCESS"
        case removalInProgress = "REMOVAL_IN_PROGRESS"
        public var description: String { return self.rawValue }
    }

    public enum UserStatus: String, CustomStringConvertible, Codable, _SotoSendable {
        case creating = "CREATING"
        case disabled = "DISABLED"
        case enabled = "ENABLED"
        public var description: String { return self.rawValue }
    }

    public enum UserType: String, CustomStringConvertible, Codable, _SotoSendable {
        case appUser = "APP_USER"
        case superUser = "SUPER_USER"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AssociateUserToPermissionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "permissionGroupId", location: .uri("permissionGroupId")),
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier for the permission group.
        public let permissionGroupId: String
        /// The unique identifier for the user.
        public let userId: String

        public init(clientToken: String? = AssociateUserToPermissionGroupRequest.idempotencyToken(), permissionGroupId: String, userId: String) {
            self.clientToken = clientToken
            self.permissionGroupId = permissionGroupId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, max: 26)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
        }
    }

    public struct AssociateUserToPermissionGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "statusCode", location: .statusCode)
        ]

        /// The returned status code of the response.
        public let statusCode: Int?

        public init(statusCode: Int? = nil) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode
        }
    }

    public struct AwsCredentials: AWSDecodableShape {
        ///  The unique identifier for the security credentials.
        public let accessKeyId: String?
        ///  The Epoch time when the current credentials expire.
        public let expiration: Int64?
        ///  The secret access key that can be used to sign requests.
        public let secretAccessKey: String?
        ///  The token that users must pass to use the credentials.
        public let sessionToken: String?

        public init(accessKeyId: String? = nil, expiration: Int64? = nil, secretAccessKey: String? = nil, sessionToken: String? = nil) {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId
            case expiration
            case secretAccessKey
            case sessionToken
        }
    }

    public struct ChangesetErrorInfo: AWSDecodableShape {
        /// The category of the error.    VALIDATION – The inputs to this request are invalid.    SERVICE_QUOTA_EXCEEDED – Service quotas have been exceeded. Please contact AWS support to increase quotas.    ACCESS_DENIED – Missing required permission to perform this request.    RESOURCE_NOT_FOUND – One or more inputs to this request were not found.    THROTTLING – The system temporarily lacks sufficient resources to process the request.    INTERNAL_SERVICE_EXCEPTION – An internal service error has occurred.    CANCELLED – Cancelled.    USER_RECOVERABLE – A user recoverable error has occurred.
        public let errorCategory: ErrorCategory?
        /// The text of the error message.
        public let errorMessage: String?

        public init(errorCategory: ErrorCategory? = nil, errorMessage: String? = nil) {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCategory
            case errorMessage
        }
    }

    public struct ChangesetSummary: AWSDecodableShape {
        /// Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeFromTimestamp: Int64?
        /// Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeUntilTimestamp: Int64?
        /// The ARN identifier of the Changeset.
        public let changesetArn: String?
        /// The unique identifier for a Changeset.
        public let changesetId: String?
        /// Type that indicates how a Changeset is applied to a Dataset.    REPLACE – Changeset is considered as a replacement to all prior loaded Changesets.    APPEND – Changeset is considered as an addition to the end of all prior loaded Changesets.    MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
        public let changeType: ChangeType?
        /// The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createTime: Int64?
        /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
        public let datasetId: String?
        /// The structure with error messages.
        public let errorInfo: ChangesetErrorInfo?
        /// Options that define the structure of the source file(s).
        public let formatParams: [String: String]?
        /// Options that define the location of the data being ingested.
        public let sourceParams: [String: String]?
        /// Status of the Changeset ingestion.    PENDING – Changeset is pending creation.    FAILED – Changeset creation has failed.    SUCCESS – Changeset creation has succeeded.    RUNNING – Changeset creation is running.    STOP_REQUESTED – User requested Changeset creation to stop.
        public let status: IngestionStatus?
        /// The unique identifier of the updated Changeset.
        public let updatedByChangesetId: String?
        /// The unique identifier of the Changeset that is updated.
        public let updatesChangesetId: String?

        public init(activeFromTimestamp: Int64? = nil, activeUntilTimestamp: Int64? = nil, changesetArn: String? = nil, changesetId: String? = nil, changeType: ChangeType? = nil, createTime: Int64? = nil, datasetId: String? = nil, errorInfo: ChangesetErrorInfo? = nil, formatParams: [String: String]? = nil, sourceParams: [String: String]? = nil, status: IngestionStatus? = nil, updatedByChangesetId: String? = nil, updatesChangesetId: String? = nil) {
            self.activeFromTimestamp = activeFromTimestamp
            self.activeUntilTimestamp = activeUntilTimestamp
            self.changesetArn = changesetArn
            self.changesetId = changesetId
            self.changeType = changeType
            self.createTime = createTime
            self.datasetId = datasetId
            self.errorInfo = errorInfo
            self.formatParams = formatParams
            self.sourceParams = sourceParams
            self.status = status
            self.updatedByChangesetId = updatedByChangesetId
            self.updatesChangesetId = updatesChangesetId
        }

        private enum CodingKeys: String, CodingKey {
            case activeFromTimestamp
            case activeUntilTimestamp
            case changesetArn
            case changesetId
            case changeType
            case createTime
            case datasetId
            case errorInfo
            case formatParams
            case sourceParams
            case status
            case updatedByChangesetId
            case updatesChangesetId
        }
    }

    public struct ColumnDefinition: AWSEncodableShape & AWSDecodableShape {
        /// Description for a column.
        public let columnDescription: String?
        /// The name of a column.
        public let columnName: String?
        /// Data type of a column.    STRING – A String data type.  CHAR – A char data type.  INTEGER – An integer data type.  TINYINT – A tinyint data type.  SMALLINT – A smallint data type.  BIGINT – A bigint data type.  FLOAT – A float data type.  DOUBLE – A double data type.  DATE – A date data type.  DATETIME – A datetime data type.  BOOLEAN – A boolean data type.  BINARY – A binary data type.
        public let dataType: ColumnDataType?

        public init(columnDescription: String? = nil, columnName: String? = nil, dataType: ColumnDataType? = nil) {
            self.columnDescription = columnDescription
            self.columnName = columnName
            self.dataType = dataType
        }

        public func validate(name: String) throws {
            try self.validate(self.columnDescription, name: "columnDescription", parent: name, max: 512)
            try self.validate(self.columnDescription, name: "columnDescription", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.columnName, name: "columnName", parent: name, max: 126)
            try self.validate(self.columnName, name: "columnName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case columnDescription
            case columnName
            case dataType
        }
    }

    public struct CreateChangesetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId"))
        ]

        /// The option to indicate how a Changeset will be applied to a Dataset.    REPLACE – Changeset will be considered as a replacement to all prior loaded Changesets.    APPEND – Changeset will be considered as an addition to the end of all prior loaded Changesets.    MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
        public let changeType: ChangeType
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier for the FinSpace Dataset where the Changeset will be created.
        public let datasetId: String
        /// Options that define the structure of the source file(s) including the format type (formatType), header row (withHeader), data separation character (separator) and the type of compression (compression).   formatType is a required attribute and can have the following values:     PARQUET – Parquet source file format.    CSV – CSV source file format.    JSON – JSON source file format.    XML – XML source file format.    Here is an example of how you could specify the formatParams:   "formatParams":  { "formatType": "CSV", "withHeader": "true", "separator": ",", "compression":"None" }    Note that if you only provide formatType as CSV, the rest of the attributes will automatically default to CSV values as following:   { "withHeader": "true", "separator": "," }   For more information about supported file formats, see Supported Data Types and File Formats in the FinSpace User Guide.
        public let formatParams: [String: String]
        /// Options that define the location of the data being ingested (s3SourcePath) and the source of the changeset (sourceType). Both s3SourcePath and sourceType are required attributes. Here is an example of how you could specify the sourceParams:   "sourceParams":  { "s3SourcePath": "s3://finspace-landing-us-east-2-bk7gcfvitndqa6ebnvys4d/scratch/wr5hh8pwkpqqkxa4sxrmcw/ingestion/equity.csv", "sourceType": "S3" }   The S3 path that you specify must allow the FinSpace role access. To do that, you first need to configure the IAM policy on S3 bucket. For more information, see Loading data from an Amazon S3 Bucket using the FinSpace API section.
        public let sourceParams: [String: String]

        public init(changeType: ChangeType, clientToken: String? = CreateChangesetRequest.idempotencyToken(), datasetId: String, formatParams: [String: String], sourceParams: [String: String]) {
            self.changeType = changeType
            self.clientToken = clientToken
            self.datasetId = datasetId
            self.formatParams = formatParams
            self.sourceParams = sourceParams
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.formatParams.forEach {
                try validate($0.key, name: "formatParams.key", parent: name, max: 128)
                try validate($0.key, name: "formatParams.key", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
                try validate($0.value, name: "formatParams[\"\($0.key)\"]", parent: name, max: 1000)
                try validate($0.value, name: "formatParams[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            }
            try self.sourceParams.forEach {
                try validate($0.key, name: "sourceParams.key", parent: name, max: 128)
                try validate($0.key, name: "sourceParams.key", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
                try validate($0.value, name: "sourceParams[\"\($0.key)\"]", parent: name, max: 1000)
                try validate($0.value, name: "sourceParams[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case changeType
            case clientToken
            case formatParams
            case sourceParams
        }
    }

    public struct CreateChangesetResponse: AWSDecodableShape {
        /// The unique identifier of the Changeset that is created.
        public let changesetId: String?
        /// The unique identifier for the FinSpace Dataset where the Changeset is created.
        public let datasetId: String?

        public init(changesetId: String? = nil, datasetId: String? = nil) {
            self.changesetId = changesetId
            self.datasetId = datasetId
        }

        private enum CodingKeys: String, CodingKey {
            case changesetId
            case datasetId
        }
    }

    public struct CreateDataViewRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId"))
        ]

        /// Beginning time to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let asOfTimestamp: Int64?
        /// Flag to indicate Dataview should be updated automatically.
        public let autoUpdate: Bool?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique Dataset identifier that is used to create a Dataview.
        public let datasetId: String
        /// Options that define the destination type for the Dataview.
        public let destinationTypeParams: DataViewDestinationTypeParams
        /// Ordered set of column names used to partition data.
        public let partitionColumns: [String]?
        /// Columns to be used for sorting the data.
        public let sortColumns: [String]?

        public init(asOfTimestamp: Int64? = nil, autoUpdate: Bool? = nil, clientToken: String? = CreateDataViewRequest.idempotencyToken(), datasetId: String, destinationTypeParams: DataViewDestinationTypeParams, partitionColumns: [String]? = nil, sortColumns: [String]? = nil) {
            self.asOfTimestamp = asOfTimestamp
            self.autoUpdate = autoUpdate
            self.clientToken = clientToken
            self.datasetId = datasetId
            self.destinationTypeParams = destinationTypeParams
            self.partitionColumns = partitionColumns
            self.sortColumns = sortColumns
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.destinationTypeParams.validate(name: "\(name).destinationTypeParams")
            try self.partitionColumns?.forEach {
                try validate($0, name: "partitionColumns[]", parent: name, max: 255)
                try validate($0, name: "partitionColumns[]", parent: name, min: 1)
                try validate($0, name: "partitionColumns[]", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            }
            try self.sortColumns?.forEach {
                try validate($0, name: "sortColumns[]", parent: name, max: 255)
                try validate($0, name: "sortColumns[]", parent: name, min: 1)
                try validate($0, name: "sortColumns[]", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case asOfTimestamp
            case autoUpdate
            case clientToken
            case destinationTypeParams
            case partitionColumns
            case sortColumns
        }
    }

    public struct CreateDataViewResponse: AWSDecodableShape {
        /// The unique identifier of the Dataset used for the Dataview.
        public let datasetId: String?
        /// The unique identifier for the created Dataview.
        public let dataViewId: String?

        public init(datasetId: String? = nil, dataViewId: String? = nil) {
            self.datasetId = datasetId
            self.dataViewId = dataViewId
        }

        private enum CodingKeys: String, CodingKey {
            case datasetId
            case dataViewId
        }
    }

    public struct CreateDatasetRequest: AWSEncodableShape {
        /// The unique resource identifier for a Dataset.
        public let alias: String?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// Description of a Dataset.
        public let datasetDescription: String?
        /// Display title for a FinSpace Dataset.
        public let datasetTitle: String
        /// The format in which Dataset data is structured.    TABULAR – Data is structured in a tabular format.    NON_TABULAR – Data is structured in a non-tabular format.
        public let kind: DatasetKind
        /// Contact information for a Dataset owner.
        public let ownerInfo: DatasetOwnerInfo?
        /// Permission group parameters for Dataset permissions.
        public let permissionGroupParams: PermissionGroupParams
        /// Definition for a schema on a tabular Dataset.
        public let schemaDefinition: SchemaUnion?

        public init(alias: String? = nil, clientToken: String? = CreateDatasetRequest.idempotencyToken(), datasetDescription: String? = nil, datasetTitle: String, kind: DatasetKind, ownerInfo: DatasetOwnerInfo? = nil, permissionGroupParams: PermissionGroupParams, schemaDefinition: SchemaUnion? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.datasetDescription = datasetDescription
            self.datasetTitle = datasetTitle
            self.kind = kind
            self.ownerInfo = ownerInfo
            self.permissionGroupParams = permissionGroupParams
            self.schemaDefinition = schemaDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 255)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^alias\\/\\S+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, max: 1000)
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.datasetTitle, name: "datasetTitle", parent: name, max: 255)
            try self.validate(self.datasetTitle, name: "datasetTitle", parent: name, min: 1)
            try self.validate(self.datasetTitle, name: "datasetTitle", parent: name, pattern: "\\S")
            try self.ownerInfo?.validate(name: "\(name).ownerInfo")
            try self.permissionGroupParams.validate(name: "\(name).permissionGroupParams")
            try self.schemaDefinition?.validate(name: "\(name).schemaDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case clientToken
            case datasetDescription
            case datasetTitle
            case kind
            case ownerInfo
            case permissionGroupParams
            case schemaDefinition
        }
    }

    public struct CreateDatasetResponse: AWSDecodableShape {
        /// The unique identifier for the created Dataset.
        public let datasetId: String?

        public init(datasetId: String? = nil) {
            self.datasetId = datasetId
        }

        private enum CodingKeys: String, CodingKey {
            case datasetId
        }
    }

    public struct CreatePermissionGroupRequest: AWSEncodableShape {
        /// The option to indicate FinSpace application permissions that are granted to a specific group.  When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.     CreateDataset – Group members can create new datasets.    ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.    ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.    ManageAttributeSets – Group members can manage attribute sets.    ViewAuditData – Group members can view audit data.    AccessNotebooks – Group members will have access to FinSpace notebooks.    GetTemporaryCredentials – Group members can get temporary API credentials.
        public let applicationPermissions: [ApplicationPermission]
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A brief description for the permission group.
        public let description: String?
        /// The name of the permission group.
        public let name: String

        public init(applicationPermissions: [ApplicationPermission], clientToken: String? = CreatePermissionGroupRequest.idempotencyToken(), description: String? = nil, name: String) {
            self.applicationPermissions = applicationPermissions
            self.clientToken = clientToken
            self.description = description
            self.name = name
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, max: 4000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationPermissions
            case clientToken
            case description
            case name
        }
    }

    public struct CreatePermissionGroupResponse: AWSDecodableShape {
        /// The unique identifier for the permission group.
        public let permissionGroupId: String?

        public init(permissionGroupId: String? = nil) {
            self.permissionGroupId = permissionGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case permissionGroupId
        }
    }

    public struct CreateUserRequest: AWSEncodableShape {
        /// The option to indicate whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.    ENABLED – The user has permissions to use the APIs.    DISABLED – The user does not have permissions to use any APIs.
        public let apiAccess: ApiAccess?
        /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
        public let apiAccessPrincipalArn: String?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The email address of the user that you want to register. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.
        public let emailAddress: String
        /// The first name of the user that you want to register.
        public let firstName: String?
        /// The last name of the user that you want to register.
        public let lastName: String?
        /// The option to indicate the type of user. Use one of the following options to specify this parameter:    SUPER_USER – A user with permission to all the functionality and data in FinSpace.    APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public let type: UserType

        public init(apiAccess: ApiAccess? = nil, apiAccessPrincipalArn: String? = nil, clientToken: String? = CreateUserRequest.idempotencyToken(), emailAddress: String, firstName: String? = nil, lastName: String? = nil, type: UserType) {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.clientToken = clientToken
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
            self.type = type
        }

        public func validate(name: String) throws {
            try self.validate(self.apiAccessPrincipalArn, name: "apiAccessPrincipalArn", parent: name, max: 2048)
            try self.validate(self.apiAccessPrincipalArn, name: "apiAccessPrincipalArn", parent: name, min: 20)
            try self.validate(self.apiAccessPrincipalArn, name: "apiAccessPrincipalArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 320)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 4)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, pattern: "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 50)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "\\S")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 50)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case apiAccess = "ApiAccess"
            case apiAccessPrincipalArn
            case clientToken
            case emailAddress
            case firstName
            case lastName
            case type
        }
    }

    public struct CreateUserResponse: AWSDecodableShape {
        /// The unique identifier for the user.
        public let userId: String?

        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId
        }
    }

    public struct Credentials: AWSDecodableShape {
        /// The access key identifier.
        public let accessKeyId: String?
        /// The access key.
        public let secretAccessKey: String?
        /// The session token.
        public let sessionToken: String?

        public init(accessKeyId: String? = nil, secretAccessKey: String? = nil, sessionToken: String? = nil) {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }

        private enum CodingKeys: String, CodingKey {
            case accessKeyId
            case secretAccessKey
            case sessionToken
        }
    }

    public struct DataViewDestinationTypeParams: AWSEncodableShape & AWSDecodableShape {
        /// Destination type for a Dataview.    GLUE_TABLE – Glue table destination type.    S3 – S3 destination type.
        public let destinationType: String
        /// Dataview export file format.    PARQUET – Parquet export file format.    DELIMITED_TEXT – Delimited text export file format.
        public let s3DestinationExportFileFormat: ExportFileFormat?
        /// Format Options for S3 Destination type. Here is an example of how you could specify the s3DestinationExportFileFormatOptions     { "header": "true", "delimiter": ",", "compression": "gzip" }
        public let s3DestinationExportFileFormatOptions: [String: String]?

        public init(destinationType: String, s3DestinationExportFileFormat: ExportFileFormat? = nil, s3DestinationExportFileFormatOptions: [String: String]? = nil) {
            self.destinationType = destinationType
            self.s3DestinationExportFileFormat = s3DestinationExportFileFormat
            self.s3DestinationExportFileFormatOptions = s3DestinationExportFileFormatOptions
        }

        public func validate(name: String) throws {
            try self.s3DestinationExportFileFormatOptions?.forEach {
                try validate($0.key, name: "s3DestinationExportFileFormatOptions.key", parent: name, max: 128)
                try validate($0.key, name: "s3DestinationExportFileFormatOptions.key", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
                try validate($0.value, name: "s3DestinationExportFileFormatOptions[\"\($0.key)\"]", parent: name, max: 1000)
                try validate($0.value, name: "s3DestinationExportFileFormatOptions[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case destinationType
            case s3DestinationExportFileFormat
            case s3DestinationExportFileFormatOptions
        }
    }

    public struct DataViewErrorInfo: AWSDecodableShape {
        /// The category of the error.    VALIDATION – The inputs to this request are invalid.    SERVICE_QUOTA_EXCEEDED – Service quotas have been exceeded. Please contact AWS support to increase quotas.    ACCESS_DENIED – Missing required permission to perform this request.    RESOURCE_NOT_FOUND – One or more inputs to this request were not found.    THROTTLING – The system temporarily lacks sufficient resources to process the request.    INTERNAL_SERVICE_EXCEPTION – An internal service error has occurred.    CANCELLED – Cancelled.    USER_RECOVERABLE – A user recoverable error has occurred.
        public let errorCategory: ErrorCategory?
        /// The text of the error message.
        public let errorMessage: String?

        public init(errorCategory: ErrorCategory? = nil, errorMessage: String? = nil) {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }

        private enum CodingKeys: String, CodingKey {
            case errorCategory
            case errorMessage
        }
    }

    public struct DataViewSummary: AWSDecodableShape {
        /// Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let asOfTimestamp: Int64?
        /// The flag to indicate Dataview should be updated automatically.
        public let autoUpdate: Bool?
        /// The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createTime: Int64?
        /// Th unique identifier for the Dataview Dataset.
        public let datasetId: String?
        /// The ARN identifier of the Dataview.
        public let dataViewArn: String?
        /// The unique identifier for the Dataview.
        public let dataViewId: String?
        /// Information about the Dataview destination.
        public let destinationTypeProperties: DataViewDestinationTypeParams?
        /// The structure with error messages.
        public let errorInfo: DataViewErrorInfo?
        /// The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTime: Int64?
        /// Ordered set of column names used to partition data.
        public let partitionColumns: [String]?
        /// Columns to be used for sorting the data.
        public let sortColumns: [String]?
        /// The status of a Dataview creation.    RUNNING – Dataview creation is running.     STARTING – Dataview creation is starting.     FAILED – Dataview creation has failed.     CANCELLED – Dataview creation has been cancelled.     TIMEOUT – Dataview creation has timed out.     SUCCESS – Dataview creation has succeeded.     PENDING – Dataview creation is pending.     FAILED_CLEANUP_FAILED – Dataview creation failed and resource cleanup failed.
        public let status: DataViewStatus?

        public init(asOfTimestamp: Int64? = nil, autoUpdate: Bool? = nil, createTime: Int64? = nil, datasetId: String? = nil, dataViewArn: String? = nil, dataViewId: String? = nil, destinationTypeProperties: DataViewDestinationTypeParams? = nil, errorInfo: DataViewErrorInfo? = nil, lastModifiedTime: Int64? = nil, partitionColumns: [String]? = nil, sortColumns: [String]? = nil, status: DataViewStatus? = nil) {
            self.asOfTimestamp = asOfTimestamp
            self.autoUpdate = autoUpdate
            self.createTime = createTime
            self.datasetId = datasetId
            self.dataViewArn = dataViewArn
            self.dataViewId = dataViewId
            self.destinationTypeProperties = destinationTypeProperties
            self.errorInfo = errorInfo
            self.lastModifiedTime = lastModifiedTime
            self.partitionColumns = partitionColumns
            self.sortColumns = sortColumns
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case asOfTimestamp
            case autoUpdate
            case createTime
            case datasetId
            case dataViewArn
            case dataViewId
            case destinationTypeProperties
            case errorInfo
            case lastModifiedTime
            case partitionColumns
            case sortColumns
            case status
        }
    }

    public struct Dataset: AWSDecodableShape {
        /// The unique resource identifier for a Dataset.
        public let alias: String?
        /// The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createTime: Int64?
        /// The ARN identifier of the Dataset.
        public let datasetArn: String?
        /// Description for a Dataset.
        public let datasetDescription: String?
        /// An identifier for a Dataset.
        public let datasetId: String?
        /// Display title for a Dataset.
        public let datasetTitle: String?
        /// The format in which Dataset data is structured.    TABULAR – Data is structured in a tabular format.    NON_TABULAR – Data is structured in a non-tabular format.
        public let kind: DatasetKind?
        /// The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTime: Int64?
        /// Contact information for a Dataset owner.
        public let ownerInfo: DatasetOwnerInfo?
        /// Definition for a schema on a tabular Dataset.
        public let schemaDefinition: SchemaUnion?

        public init(alias: String? = nil, createTime: Int64? = nil, datasetArn: String? = nil, datasetDescription: String? = nil, datasetId: String? = nil, datasetTitle: String? = nil, kind: DatasetKind? = nil, lastModifiedTime: Int64? = nil, ownerInfo: DatasetOwnerInfo? = nil, schemaDefinition: SchemaUnion? = nil) {
            self.alias = alias
            self.createTime = createTime
            self.datasetArn = datasetArn
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetTitle = datasetTitle
            self.kind = kind
            self.lastModifiedTime = lastModifiedTime
            self.ownerInfo = ownerInfo
            self.schemaDefinition = schemaDefinition
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case createTime
            case datasetArn
            case datasetDescription
            case datasetId
            case datasetTitle
            case kind
            case lastModifiedTime
            case ownerInfo
            case schemaDefinition
        }
    }

    public struct DatasetOwnerInfo: AWSEncodableShape & AWSDecodableShape {
        /// Email address for the Dataset owner.
        public let email: String?
        /// The name of the Dataset owner.
        public let name: String?
        /// Phone number for the Dataset owner.
        public let phoneNumber: String?

        public init(email: String? = nil, name: String? = nil, phoneNumber: String? = nil) {
            self.email = email
            self.name = name
            self.phoneNumber = phoneNumber
        }

        public func validate(name: String) throws {
            try self.validate(self.email, name: "email", parent: name, max: 320)
            try self.validate(self.email, name: "email", parent: name, min: 4)
            try self.validate(self.email, name: "email", parent: name, pattern: "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}$")
            try self.validate(self.name, name: "name", parent: name, max: 250)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 20)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 10)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, pattern: "^[\\+0-9\\#\\,\\(][\\+0-9\\-\\.\\/\\(\\)\\,\\#\\s]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case email
            case name
            case phoneNumber
        }
    }

    public struct DeleteDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId"))
        ]

        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier of the Dataset to be deleted.
        public let datasetId: String

        public init(clientToken: String? = DeleteDatasetRequest.idempotencyToken(), datasetId: String) {
            self.clientToken = clientToken
            self.datasetId = datasetId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDatasetResponse: AWSDecodableShape {
        /// The unique identifier for the deleted Dataset.
        public let datasetId: String?

        public init(datasetId: String? = nil) {
            self.datasetId = datasetId
        }

        private enum CodingKeys: String, CodingKey {
            case datasetId
        }
    }

    public struct DeletePermissionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "permissionGroupId", location: .uri("permissionGroupId"))
        ]

        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier for the permission group that you want to delete.
        public let permissionGroupId: String

        public init(clientToken: String? = DeletePermissionGroupRequest.idempotencyToken(), permissionGroupId: String) {
            self.clientToken = clientToken
            self.permissionGroupId = permissionGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, max: 26)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeletePermissionGroupResponse: AWSDecodableShape {
        /// The unique identifier for the deleted permission group.
        public let permissionGroupId: String?

        public init(permissionGroupId: String? = nil) {
            self.permissionGroupId = permissionGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case permissionGroupId
        }
    }

    public struct DisableUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier for the user account that you want to disable.
        public let userId: String

        public init(clientToken: String? = DisableUserRequest.idempotencyToken(), userId: String) {
            self.clientToken = clientToken
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
        }
    }

    public struct DisableUserResponse: AWSDecodableShape {
        /// The unique identifier for the disabled user account.
        public let userId: String?

        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId
        }
    }

    public struct DisassociateUserFromPermissionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "clientToken", location: .querystring("clientToken")),
            AWSMemberEncoding(label: "permissionGroupId", location: .uri("permissionGroupId")),
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier for the permission group.
        public let permissionGroupId: String
        /// The unique identifier for the user.
        public let userId: String

        public init(clientToken: String? = DisassociateUserFromPermissionGroupRequest.idempotencyToken(), permissionGroupId: String, userId: String) {
            self.clientToken = clientToken
            self.permissionGroupId = permissionGroupId
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, max: 26)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DisassociateUserFromPermissionGroupResponse: AWSDecodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "statusCode", location: .statusCode)
        ]

        /// The returned status code of the response.
        public let statusCode: Int?

        public init(statusCode: Int? = nil) {
            self.statusCode = statusCode
        }

        private enum CodingKeys: String, CodingKey {
            case statusCode
        }
    }

    public struct EnableUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier for the user account that you want to enable.
        public let userId: String

        public init(clientToken: String? = EnableUserRequest.idempotencyToken(), userId: String) {
            self.clientToken = clientToken
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
        }
    }

    public struct EnableUserResponse: AWSDecodableShape {
        /// The unique identifier for the enabled user account.
        public let userId: String?

        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId
        }
    }

    public struct GetChangesetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "changesetId", location: .uri("changesetId")),
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId"))
        ]

        /// The unique identifier of the Changeset for which to get data.
        public let changesetId: String
        /// The unique identifier for the FinSpace Dataset where the Changeset is created.
        public let datasetId: String

        public init(changesetId: String, datasetId: String) {
            self.changesetId = changesetId
            self.datasetId = datasetId
        }

        public func validate(name: String) throws {
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetChangesetResponse: AWSDecodableShape {
        /// Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeFromTimestamp: Int64?
        /// Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let activeUntilTimestamp: Int64?
        /// The ARN identifier of the Changeset.
        public let changesetArn: String?
        /// The unique identifier for a Changeset.
        public let changesetId: String?
        /// Type that indicates how a Changeset is applied to a Dataset.    REPLACE – Changeset is considered as a replacement to all prior loaded Changesets.    APPEND – Changeset is considered as an addition to the end of all prior loaded Changesets.    MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
        public let changeType: ChangeType?
        /// The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createTime: Int64?
        /// The unique identifier for the FinSpace Dataset where the Changeset is created.
        public let datasetId: String?
        /// The structure with error messages.
        public let errorInfo: ChangesetErrorInfo?
        /// Structure of the source file(s).
        public let formatParams: [String: String]?
        /// Options that define the location of the data being ingested.
        public let sourceParams: [String: String]?
        /// The status of Changeset creation operation.
        public let status: IngestionStatus?
        /// The unique identifier of the updated Changeset.
        public let updatedByChangesetId: String?
        /// The unique identifier of the Changeset that is being updated.
        public let updatesChangesetId: String?

        public init(activeFromTimestamp: Int64? = nil, activeUntilTimestamp: Int64? = nil, changesetArn: String? = nil, changesetId: String? = nil, changeType: ChangeType? = nil, createTime: Int64? = nil, datasetId: String? = nil, errorInfo: ChangesetErrorInfo? = nil, formatParams: [String: String]? = nil, sourceParams: [String: String]? = nil, status: IngestionStatus? = nil, updatedByChangesetId: String? = nil, updatesChangesetId: String? = nil) {
            self.activeFromTimestamp = activeFromTimestamp
            self.activeUntilTimestamp = activeUntilTimestamp
            self.changesetArn = changesetArn
            self.changesetId = changesetId
            self.changeType = changeType
            self.createTime = createTime
            self.datasetId = datasetId
            self.errorInfo = errorInfo
            self.formatParams = formatParams
            self.sourceParams = sourceParams
            self.status = status
            self.updatedByChangesetId = updatedByChangesetId
            self.updatesChangesetId = updatesChangesetId
        }

        private enum CodingKeys: String, CodingKey {
            case activeFromTimestamp
            case activeUntilTimestamp
            case changesetArn
            case changesetId
            case changeType
            case createTime
            case datasetId
            case errorInfo
            case formatParams
            case sourceParams
            case status
            case updatedByChangesetId
            case updatesChangesetId
        }
    }

    public struct GetDataViewRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId")),
            AWSMemberEncoding(label: "dataViewId", location: .uri("dataViewId"))
        ]

        /// The unique identifier for the Dataset used in the Dataview.
        public let datasetId: String
        /// The unique identifier for the Dataview.
        public let dataViewId: String

        public init(datasetId: String, dataViewId: String) {
            self.datasetId = datasetId
            self.dataViewId = dataViewId
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.validate(self.dataViewId, name: "dataViewId", parent: name, max: 26)
            try self.validate(self.dataViewId, name: "dataViewId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDataViewResponse: AWSDecodableShape {
        /// Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let asOfTimestamp: Int64?
        /// Flag to indicate Dataview should be updated automatically.
        public let autoUpdate: Bool?
        /// The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createTime: Int64?
        /// The unique identifier for the Dataset used in the Dataview.
        public let datasetId: String?
        /// The ARN identifier of the Dataview.
        public let dataViewArn: String?
        /// The unique identifier for the Dataview.
        public let dataViewId: String?
        /// Options that define the destination type for the Dataview.
        public let destinationTypeParams: DataViewDestinationTypeParams?
        /// Information about an error that occurred for the Dataview.
        public let errorInfo: DataViewErrorInfo?
        /// The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTime: Int64?
        /// Ordered set of column names used to partition data.
        public let partitionColumns: [String]?
        /// Columns to be used for sorting the data.
        public let sortColumns: [String]?
        /// The status of a Dataview creation.    RUNNING – Dataview creation is running.    STARTING – Dataview creation is starting.    FAILED – Dataview creation has failed.    CANCELLED – Dataview creation has been cancelled.    TIMEOUT – Dataview creation has timed out.    SUCCESS – Dataview creation has succeeded.    PENDING – Dataview creation is pending.    FAILED_CLEANUP_FAILED – Dataview creation failed and resource cleanup failed.
        public let status: DataViewStatus?

        public init(asOfTimestamp: Int64? = nil, autoUpdate: Bool? = nil, createTime: Int64? = nil, datasetId: String? = nil, dataViewArn: String? = nil, dataViewId: String? = nil, destinationTypeParams: DataViewDestinationTypeParams? = nil, errorInfo: DataViewErrorInfo? = nil, lastModifiedTime: Int64? = nil, partitionColumns: [String]? = nil, sortColumns: [String]? = nil, status: DataViewStatus? = nil) {
            self.asOfTimestamp = asOfTimestamp
            self.autoUpdate = autoUpdate
            self.createTime = createTime
            self.datasetId = datasetId
            self.dataViewArn = dataViewArn
            self.dataViewId = dataViewId
            self.destinationTypeParams = destinationTypeParams
            self.errorInfo = errorInfo
            self.lastModifiedTime = lastModifiedTime
            self.partitionColumns = partitionColumns
            self.sortColumns = sortColumns
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case asOfTimestamp
            case autoUpdate
            case createTime
            case datasetId
            case dataViewArn
            case dataViewId
            case destinationTypeParams
            case errorInfo
            case lastModifiedTime
            case partitionColumns
            case sortColumns
            case status
        }
    }

    public struct GetDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId"))
        ]

        /// The unique identifier for a Dataset.
        public let datasetId: String

        public init(datasetId: String) {
            self.datasetId = datasetId
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 255)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.validate(self.datasetId, name: "datasetId", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDatasetResponse: AWSDecodableShape {
        /// The unique resource identifier for a Dataset.
        public let alias: String?
        /// The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let createTime: Int64?
        /// The ARN identifier of the Dataset.
        public let datasetArn: String?
        /// A description of the Dataset.
        public let datasetDescription: String?
        /// The unique identifier for a Dataset.
        public let datasetId: String?
        /// Display title for a Dataset.
        public let datasetTitle: String?
        /// The format in which Dataset data is structured.    TABULAR – Data is structured in a tabular format.    NON_TABULAR – Data is structured in a non-tabular format.
        public let kind: DatasetKind?
        /// The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public let lastModifiedTime: Int64?
        /// Definition for a schema on a tabular Dataset.
        public let schemaDefinition: SchemaUnion?
        /// Status of the Dataset creation.    PENDING – Dataset is pending creation.    FAILED – Dataset creation has failed.    SUCCESS – Dataset creation has succeeded.    RUNNING – Dataset creation is running.
        public let status: DatasetStatus?

        public init(alias: String? = nil, createTime: Int64? = nil, datasetArn: String? = nil, datasetDescription: String? = nil, datasetId: String? = nil, datasetTitle: String? = nil, kind: DatasetKind? = nil, lastModifiedTime: Int64? = nil, schemaDefinition: SchemaUnion? = nil, status: DatasetStatus? = nil) {
            self.alias = alias
            self.createTime = createTime
            self.datasetArn = datasetArn
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetTitle = datasetTitle
            self.kind = kind
            self.lastModifiedTime = lastModifiedTime
            self.schemaDefinition = schemaDefinition
            self.status = status
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case createTime
            case datasetArn
            case datasetDescription
            case datasetId
            case datasetTitle
            case kind
            case lastModifiedTime
            case schemaDefinition
            case status
        }
    }

    public struct GetExternalDataViewAccessDetailsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId")),
            AWSMemberEncoding(label: "dataViewId", location: .uri("dataViewId"))
        ]

        /// The unique identifier for the Dataset.
        public let datasetId: String
        /// The unique identifier for the Dataview that you want to access.
        public let dataViewId: String

        public init(datasetId: String, dataViewId: String) {
            self.datasetId = datasetId
            self.dataViewId = dataViewId
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.validate(self.dataViewId, name: "dataViewId", parent: name, max: 26)
            try self.validate(self.dataViewId, name: "dataViewId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetExternalDataViewAccessDetailsResponse: AWSDecodableShape {
        /// The credentials required to access the external Dataview from the S3 location.
        public let credentials: AwsCredentials?
        /// The location where the external Dataview is stored.
        public let s3Location: S3Location?

        public init(credentials: AwsCredentials? = nil, s3Location: S3Location? = nil) {
            self.credentials = credentials
            self.s3Location = s3Location
        }

        private enum CodingKeys: String, CodingKey {
            case credentials
            case s3Location
        }
    }

    public struct GetPermissionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "permissionGroupId", location: .uri("permissionGroupId"))
        ]

        /// The unique identifier for the permission group.
        public let permissionGroupId: String

        public init(permissionGroupId: String) {
            self.permissionGroupId = permissionGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, max: 26)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetPermissionGroupResponse: AWSDecodableShape {
        public let permissionGroup: PermissionGroup?

        public init(permissionGroup: PermissionGroup? = nil) {
            self.permissionGroup = permissionGroup
        }

        private enum CodingKeys: String, CodingKey {
            case permissionGroup
        }
    }

    public struct GetProgrammaticAccessCredentialsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "durationInMinutes", location: .querystring("durationInMinutes")),
            AWSMemberEncoding(label: "environmentId", location: .querystring("environmentId"))
        ]

        /// The time duration in which the credentials remain valid.
        public let durationInMinutes: Int64?
        /// The FinSpace environment identifier.
        public let environmentId: String

        public init(durationInMinutes: Int64? = nil, environmentId: String) {
            self.durationInMinutes = durationInMinutes
            self.environmentId = environmentId
        }

        public func validate(name: String) throws {
            try self.validate(self.durationInMinutes, name: "durationInMinutes", parent: name, max: 720)
            try self.validate(self.durationInMinutes, name: "durationInMinutes", parent: name, min: 60)
            try self.validate(self.environmentId, name: "environmentId", parent: name, max: 26)
            try self.validate(self.environmentId, name: "environmentId", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProgrammaticAccessCredentialsResponse: AWSDecodableShape {
        /// Returns the programmatic credentials.
        public let credentials: Credentials?
        /// Returns the duration in which the credentials will remain valid.
        public let durationInMinutes: Int64?

        public init(credentials: Credentials? = nil, durationInMinutes: Int64? = nil) {
            self.credentials = credentials
            self.durationInMinutes = durationInMinutes
        }

        private enum CodingKeys: String, CodingKey {
            case credentials
            case durationInMinutes
        }
    }

    public struct GetUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// The unique identifier of the user to get data for.
        public let userId: String

        public init(userId: String) {
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetUserResponse: AWSDecodableShape {
        /// Indicates whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.     ENABLED – The user has permissions to use the APIs.    DISABLED – The user does not have permissions to use any APIs.
        public let apiAccess: ApiAccess?
        /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
        public let apiAccessPrincipalArn: String?
        /// The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds.
        public let createTime: Int64?
        /// The email address that is associated with the user.
        public let emailAddress: String?
        /// The first name of the user.
        public let firstName: String?
        /// Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.
        public let lastDisabledTime: Int64?
        /// Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds.
        public let lastEnabledTime: Int64?
        /// Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds.
        public let lastLoginTime: Int64?
        /// Describes the last time the user account was updated. The value is determined as epoch time in milliseconds.
        public let lastModifiedTime: Int64?
        /// The last name of the user.
        public let lastName: String?
        /// The current status of the user account.     CREATING – The user account creation is in progress.    ENABLED – The user account is created and is currently active.    DISABLED – The user account is currently inactive.
        public let status: UserStatus?
        /// Indicates the type of user.      SUPER_USER – A user with permission to all the functionality and data in FinSpace.      APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public let type: UserType?
        /// The unique identifier for the user account that is retrieved.
        public let userId: String?

        public init(apiAccess: ApiAccess? = nil, apiAccessPrincipalArn: String? = nil, createTime: Int64? = nil, emailAddress: String? = nil, firstName: String? = nil, lastDisabledTime: Int64? = nil, lastEnabledTime: Int64? = nil, lastLoginTime: Int64? = nil, lastModifiedTime: Int64? = nil, lastName: String? = nil, status: UserStatus? = nil, type: UserType? = nil, userId: String? = nil) {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.createTime = createTime
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastDisabledTime = lastDisabledTime
            self.lastEnabledTime = lastEnabledTime
            self.lastLoginTime = lastLoginTime
            self.lastModifiedTime = lastModifiedTime
            self.lastName = lastName
            self.status = status
            self.type = type
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case apiAccess
            case apiAccessPrincipalArn
            case createTime
            case emailAddress
            case firstName
            case lastDisabledTime
            case lastEnabledTime
            case lastLoginTime
            case lastModifiedTime
            case lastName
            case status
            case type
            case userId
        }
    }

    public struct GetWorkingLocationRequest: AWSEncodableShape {
        /// Specify the type of the working location.    SAGEMAKER – Use the Amazon S3 location as a temporary location to store data content when working with FinSpace Notebooks that run on SageMaker studio.    INGESTION – Use the Amazon S3 location as a staging location to copy your data content and then use the location with the Changeset creation operation.
        public let locationType: LocationType?

        public init(locationType: LocationType? = nil) {
            self.locationType = locationType
        }

        private enum CodingKeys: String, CodingKey {
            case locationType
        }
    }

    public struct GetWorkingLocationResponse: AWSDecodableShape {
        /// Returns the Amazon S3 bucket name for the working location.
        public let s3Bucket: String?
        /// Returns the Amazon S3 Path for the working location.
        public let s3Path: String?
        /// Returns the Amazon S3 URI for the working location.
        public let s3Uri: String?

        public init(s3Bucket: String? = nil, s3Path: String? = nil, s3Uri: String? = nil) {
            self.s3Bucket = s3Bucket
            self.s3Path = s3Path
            self.s3Uri = s3Uri
        }

        private enum CodingKeys: String, CodingKey {
            case s3Bucket
            case s3Path
            case s3Uri
        }
    }

    public struct ListChangesetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier for the FinSpace Dataset to which the Changeset belongs.
        public let datasetId: String
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(datasetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetId = datasetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListChangesetsResponse: AWSDecodableShape {
        /// List of Changesets found.
        public let changesets: [ChangesetSummary]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(changesets: [ChangesetSummary]? = nil, nextToken: String? = nil) {
            self.changesets = changesets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case changesets
            case nextToken
        }
    }

    public struct ListDataViewsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId")),
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The unique identifier of the Dataset for which to retrieve Dataviews.
        public let datasetId: String
        /// The maximum number of results per page.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(datasetId: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.datasetId = datasetId
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDataViewsResponse: AWSDecodableShape {
        /// A list of Dataviews.
        public let dataViews: [DataViewSummary]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(dataViews: [DataViewSummary]? = nil, nextToken: String? = nil) {
            self.dataViews = dataViews
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case dataViews
            case nextToken
        }
    }

    public struct ListDatasetsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results per page.
        public let maxResults: Int?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDatasetsResponse: AWSDecodableShape {
        /// List of Datasets.
        public let datasets: [Dataset]?
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(datasets: [Dataset]? = nil, nextToken: String? = nil) {
            self.datasets = datasets
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case datasets
            case nextToken
        }
    }

    public struct ListPermissionGroupsByUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// The maximum number of results per page.
        public let maxResults: Int
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// The unique identifier for the user.
        public let userId: String

        public init(maxResults: Int, nextToken: String? = nil, userId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPermissionGroupsByUserResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of returned permission groups.
        public let permissionGroups: [PermissionGroupByUser]?

        public init(nextToken: String? = nil, permissionGroups: [PermissionGroupByUser]? = nil) {
            self.nextToken = nextToken
            self.permissionGroups = permissionGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case permissionGroups
        }
    }

    public struct ListPermissionGroupsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results per page.
        public let maxResults: Int
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(maxResults: Int, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListPermissionGroupsResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of all the permission groups.
        public let permissionGroups: [PermissionGroup]?

        public init(nextToken: String? = nil, permissionGroups: [PermissionGroup]? = nil) {
            self.nextToken = nextToken
            self.permissionGroups = permissionGroups
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case permissionGroups
        }
    }

    public struct ListUsersByPermissionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken")),
            AWSMemberEncoding(label: "permissionGroupId", location: .uri("permissionGroupId"))
        ]

        /// The maximum number of results per page.
        public let maxResults: Int
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// The unique identifier for the permission group.
        public let permissionGroupId: String

        public init(maxResults: Int, nextToken: String? = nil, permissionGroupId: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.permissionGroupId = permissionGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, max: 26)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersByPermissionGroupResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// Lists details of all users in a specific permission group.
        public let users: [UserByPermissionGroup]?

        public init(nextToken: String? = nil, users: [UserByPermissionGroup]? = nil) {
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case users
        }
    }

    public struct ListUsersRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring("maxResults")),
            AWSMemberEncoding(label: "nextToken", location: .querystring("nextToken"))
        ]

        /// The maximum number of results per page.
        public let maxResults: Int
        /// A token that indicates where a results page should begin.
        public let nextToken: String?

        public init(maxResults: Int, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListUsersResponse: AWSDecodableShape {
        /// A token that indicates where a results page should begin.
        public let nextToken: String?
        /// A list of all the user accounts.
        public let users: [User]?

        public init(nextToken: String? = nil, users: [User]? = nil) {
            self.nextToken = nextToken
            self.users = users
        }

        private enum CodingKeys: String, CodingKey {
            case nextToken
            case users
        }
    }

    public struct PermissionGroup: AWSDecodableShape {
        /// Indicates the permissions that are granted to a specific group for accessing the FinSpace application.  When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.     CreateDataset – Group members can create new datasets.    ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.    ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.    ManageAttributeSets – Group members can manage attribute sets.    ViewAuditData – Group members can view audit data.    AccessNotebooks – Group members will have access to FinSpace notebooks.    GetTemporaryCredentials – Group members can get temporary API credentials.
        public let applicationPermissions: [ApplicationPermission]?
        /// The timestamp at which the group was created in FinSpace. The value is determined as epoch time in milliseconds.
        public let createTime: Int64?
        ///  A brief description for the permission group.
        public let description: String?
        /// Describes the last time the permission group was updated. The value is determined as epoch time in milliseconds.
        public let lastModifiedTime: Int64?
        /// Indicates the status of the user account within a permission group.    ADDITION_IN_PROGRESS – The user account is currently being added to the permission group.    ADDITION_SUCCESS – The user account is successfully added to the permission group.    REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public let membershipStatus: PermissionGroupMembershipStatus?
        /// The name of the permission group.
        public let name: String?
        ///  The unique identifier for the permission group.
        public let permissionGroupId: String?

        public init(applicationPermissions: [ApplicationPermission]? = nil, createTime: Int64? = nil, description: String? = nil, lastModifiedTime: Int64? = nil, membershipStatus: PermissionGroupMembershipStatus? = nil, name: String? = nil, permissionGroupId: String? = nil) {
            self.applicationPermissions = applicationPermissions
            self.createTime = createTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.membershipStatus = membershipStatus
            self.name = name
            self.permissionGroupId = permissionGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case applicationPermissions
            case createTime
            case description
            case lastModifiedTime
            case membershipStatus
            case name
            case permissionGroupId
        }
    }

    public struct PermissionGroupByUser: AWSDecodableShape {
        /// Indicates the status of the user account within a permission group.    ADDITION_IN_PROGRESS – The user account is currently being added to the permission group.    ADDITION_SUCCESS – The user account is successfully added to the permission group.    REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public let membershipStatus: PermissionGroupMembershipStatus?
        /// The name of the permission group.
        public let name: String?
        /// The unique identifier for the permission group.
        public let permissionGroupId: String?

        public init(membershipStatus: PermissionGroupMembershipStatus? = nil, name: String? = nil, permissionGroupId: String? = nil) {
            self.membershipStatus = membershipStatus
            self.name = name
            self.permissionGroupId = permissionGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case membershipStatus
            case name
            case permissionGroupId
        }
    }

    public struct PermissionGroupParams: AWSEncodableShape {
        /// List of resource permissions.
        public let datasetPermissions: [ResourcePermission]?
        /// The unique identifier for the PermissionGroup.
        public let permissionGroupId: String?

        public init(datasetPermissions: [ResourcePermission]? = nil, permissionGroupId: String? = nil) {
            self.datasetPermissions = datasetPermissions
            self.permissionGroupId = permissionGroupId
        }

        public func validate(name: String) throws {
            try self.datasetPermissions?.forEach {
                try $0.validate(name: "\(name).datasetPermissions[]")
            }
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, max: 26)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case datasetPermissions
            case permissionGroupId
        }
    }

    public struct ResetUserPasswordRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier of the user that a temporary password is requested for.
        public let userId: String

        public init(clientToken: String? = ResetUserPasswordRequest.idempotencyToken(), userId: String) {
            self.clientToken = clientToken
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
        }
    }

    public struct ResetUserPasswordResponse: AWSDecodableShape {
        /// A randomly generated temporary password for the requested user account. This password expires in 7 days.
        public let temporaryPassword: String?
        /// The unique identifier of the user that a new password is generated for.
        public let userId: String?

        public init(temporaryPassword: String? = nil, userId: String? = nil) {
            self.temporaryPassword = temporaryPassword
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case temporaryPassword
            case userId
        }
    }

    public struct ResourcePermission: AWSEncodableShape {
        /// Permission for a resource.
        public let permission: String?

        public init(permission: String? = nil) {
            self.permission = permission
        }

        public func validate(name: String) throws {
            try self.validate(self.permission, name: "permission", parent: name, max: 250)
            try self.validate(self.permission, name: "permission", parent: name, min: 1)
            try self.validate(self.permission, name: "permission", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case permission
        }
    }

    public struct S3Location: AWSDecodableShape {
        ///  The name of the S3 bucket.
        public let bucket: String
        ///  The path of the folder, within the S3 bucket that contains the Dataset.
        public let key: String

        public init(bucket: String, key: String) {
            self.bucket = bucket
            self.key = key
        }

        private enum CodingKeys: String, CodingKey {
            case bucket
            case key
        }
    }

    public struct SchemaDefinition: AWSEncodableShape & AWSDecodableShape {
        /// List of column definitions.
        public let columns: [ColumnDefinition]?
        /// List of column names used for primary key.
        public let primaryKeyColumns: [String]?

        public init(columns: [ColumnDefinition]? = nil, primaryKeyColumns: [String]? = nil) {
            self.columns = columns
            self.primaryKeyColumns = primaryKeyColumns
        }

        public func validate(name: String) throws {
            try self.columns?.forEach {
                try $0.validate(name: "\(name).columns[]")
            }
            try self.primaryKeyColumns?.forEach {
                try validate($0, name: "primaryKeyColumns[]", parent: name, max: 126)
                try validate($0, name: "primaryKeyColumns[]", parent: name, pattern: "\\S")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case columns
            case primaryKeyColumns
        }
    }

    public struct SchemaUnion: AWSEncodableShape & AWSDecodableShape {
        /// The configuration for a schema on a tabular Dataset.
        public let tabularSchemaConfig: SchemaDefinition?

        public init(tabularSchemaConfig: SchemaDefinition? = nil) {
            self.tabularSchemaConfig = tabularSchemaConfig
        }

        public func validate(name: String) throws {
            try self.tabularSchemaConfig?.validate(name: "\(name).tabularSchemaConfig")
        }

        private enum CodingKeys: String, CodingKey {
            case tabularSchemaConfig
        }
    }

    public struct UpdateChangesetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "changesetId", location: .uri("changesetId")),
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId"))
        ]

        /// The unique identifier for the Changeset to update.
        public let changesetId: String
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
        public let datasetId: String
        /// Options that define the structure of the source file(s) including the format type (formatType), header row (withHeader), data separation character (separator) and the type of compression (compression).   formatType is a required attribute and can have the following values:     PARQUET – Parquet source file format.    CSV – CSV source file format.    JSON – JSON source file format.    XML – XML source file format.    Here is an example of how you could specify the formatParams:   "formatParams":  { "formatType": "CSV", "withHeader": "true", "separator": ",", "compression":"None" }    Note that if you only provide formatType as CSV, the rest of the attributes will automatically default to CSV values as following:   { "withHeader": "true", "separator": "," }   For more information about supported file formats, see Supported Data Types and File Formats in the FinSpace User Guide.
        public let formatParams: [String: String]
        /// Options that define the location of the data being ingested (s3SourcePath) and the source of the changeset (sourceType). Both s3SourcePath and sourceType are required attributes. Here is an example of how you could specify the sourceParams:   "sourceParams":  { "s3SourcePath": "s3://finspace-landing-us-east-2-bk7gcfvitndqa6ebnvys4d/scratch/wr5hh8pwkpqqkxa4sxrmcw/ingestion/equity.csv", "sourceType": "S3" }   The S3 path that you specify must allow the FinSpace role access. To do that, you first need to configure the IAM policy on S3 bucket. For more information, see Loading data from an Amazon S3 Bucket using the FinSpace APIsection.
        public let sourceParams: [String: String]

        public init(changesetId: String, clientToken: String? = UpdateChangesetRequest.idempotencyToken(), datasetId: String, formatParams: [String: String], sourceParams: [String: String]) {
            self.changesetId = changesetId
            self.clientToken = clientToken
            self.datasetId = datasetId
            self.formatParams = formatParams
            self.sourceParams = sourceParams
        }

        public func validate(name: String) throws {
            try self.validate(self.changesetId, name: "changesetId", parent: name, max: 26)
            try self.validate(self.changesetId, name: "changesetId", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.formatParams.forEach {
                try validate($0.key, name: "formatParams.key", parent: name, max: 128)
                try validate($0.key, name: "formatParams.key", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
                try validate($0.value, name: "formatParams[\"\($0.key)\"]", parent: name, max: 1000)
                try validate($0.value, name: "formatParams[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            }
            try self.sourceParams.forEach {
                try validate($0.key, name: "sourceParams.key", parent: name, max: 128)
                try validate($0.key, name: "sourceParams.key", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
                try validate($0.value, name: "sourceParams[\"\($0.key)\"]", parent: name, max: 1000)
                try validate($0.value, name: "sourceParams[\"\($0.key)\"]", parent: name, pattern: "^[\\s\\S]*\\S[\\s\\S]*$")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case clientToken
            case formatParams
            case sourceParams
        }
    }

    public struct UpdateChangesetResponse: AWSDecodableShape {
        /// The unique identifier for the Changeset to update.
        public let changesetId: String?
        /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
        public let datasetId: String?

        public init(changesetId: String? = nil, datasetId: String? = nil) {
            self.changesetId = changesetId
            self.datasetId = datasetId
        }

        private enum CodingKeys: String, CodingKey {
            case changesetId
            case datasetId
        }
    }

    public struct UpdateDatasetRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "datasetId", location: .uri("datasetId"))
        ]

        /// The unique resource identifier for a Dataset.
        public let alias: String?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A description for the Dataset.
        public let datasetDescription: String?
        /// The unique identifier for the Dataset to update.
        public let datasetId: String
        /// A display title for the Dataset.
        public let datasetTitle: String
        /// The format in which the Dataset data is structured.    TABULAR – Data is structured in a tabular format.    NON_TABULAR – Data is structured in a non-tabular format.
        public let kind: DatasetKind
        /// Definition for a schema on a tabular Dataset.
        public let schemaDefinition: SchemaUnion?

        public init(alias: String? = nil, clientToken: String? = UpdateDatasetRequest.idempotencyToken(), datasetDescription: String? = nil, datasetId: String, datasetTitle: String, kind: DatasetKind, schemaDefinition: SchemaUnion? = nil) {
            self.alias = alias
            self.clientToken = clientToken
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetTitle = datasetTitle
            self.kind = kind
            self.schemaDefinition = schemaDefinition
        }

        public func validate(name: String) throws {
            try self.validate(self.alias, name: "alias", parent: name, max: 255)
            try self.validate(self.alias, name: "alias", parent: name, min: 1)
            try self.validate(self.alias, name: "alias", parent: name, pattern: "^alias\\/\\S+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, max: 1000)
            try self.validate(self.datasetDescription, name: "datasetDescription", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.datasetId, name: "datasetId", parent: name, max: 26)
            try self.validate(self.datasetId, name: "datasetId", parent: name, min: 1)
            try self.validate(self.datasetTitle, name: "datasetTitle", parent: name, max: 255)
            try self.validate(self.datasetTitle, name: "datasetTitle", parent: name, min: 1)
            try self.validate(self.datasetTitle, name: "datasetTitle", parent: name, pattern: "\\S")
            try self.schemaDefinition?.validate(name: "\(name).schemaDefinition")
        }

        private enum CodingKeys: String, CodingKey {
            case alias
            case clientToken
            case datasetDescription
            case datasetTitle
            case kind
            case schemaDefinition
        }
    }

    public struct UpdateDatasetResponse: AWSDecodableShape {
        /// The unique identifier for updated Dataset.
        public let datasetId: String?

        public init(datasetId: String? = nil) {
            self.datasetId = datasetId
        }

        private enum CodingKeys: String, CodingKey {
            case datasetId
        }
    }

    public struct UpdatePermissionGroupRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "permissionGroupId", location: .uri("permissionGroupId"))
        ]

        /// The permissions that are granted to a specific group for accessing the FinSpace application.  When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.     CreateDataset – Group members can create new datasets.    ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.    ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.    ManageAttributeSets – Group members can manage attribute sets.    ViewAuditData – Group members can view audit data.    AccessNotebooks – Group members will have access to FinSpace notebooks.    GetTemporaryCredentials – Group members can get temporary API credentials.
        public let applicationPermissions: [ApplicationPermission]?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// A brief description for the permission group.
        public let description: String?
        /// The name of the permission group.
        public let name: String?
        /// The unique identifier for the permission group to update.
        public let permissionGroupId: String

        public init(applicationPermissions: [ApplicationPermission]? = nil, clientToken: String? = UpdatePermissionGroupRequest.idempotencyToken(), description: String? = nil, name: String? = nil, permissionGroupId: String) {
            self.applicationPermissions = applicationPermissions
            self.clientToken = clientToken
            self.description = description
            self.name = name
            self.permissionGroupId = permissionGroupId
        }

        public func validate(name: String) throws {
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.description, name: "description", parent: name, max: 4000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.validate(self.description, name: "description", parent: name, pattern: "^[\\s\\S]*$")
            try self.validate(self.name, name: "name", parent: name, max: 255)
            try self.validate(self.name, name: "name", parent: name, min: 1)
            try self.validate(self.name, name: "name", parent: name, pattern: "\\S")
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, max: 26)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, min: 1)
            try self.validate(self.permissionGroupId, name: "permissionGroupId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case applicationPermissions
            case clientToken
            case description
            case name
        }
    }

    public struct UpdatePermissionGroupResponse: AWSDecodableShape {
        /// The unique identifier for the updated permission group.
        public let permissionGroupId: String?

        public init(permissionGroupId: String? = nil) {
            self.permissionGroupId = permissionGroupId
        }

        private enum CodingKeys: String, CodingKey {
            case permissionGroupId
        }
    }

    public struct UpdateUserRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "userId", location: .uri("userId"))
        ]

        /// The option to indicate whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.    ENABLED – The user has permissions to use the APIs.    DISABLED – The user does not have permissions to use any APIs.
        public let apiAccess: ApiAccess?
        /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
        public let apiAccessPrincipalArn: String?
        /// A token that ensures idempotency. This token expires in 10 minutes.
        public let clientToken: String?
        /// The first name of the user.
        public let firstName: String?
        /// The last name of the user.
        public let lastName: String?
        /// The option to indicate the type of user.    SUPER_USER– A user with permission to all the functionality and data in FinSpace.    APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public let type: UserType?
        /// The unique identifier for the user account to update.
        public let userId: String

        public init(apiAccess: ApiAccess? = nil, apiAccessPrincipalArn: String? = nil, clientToken: String? = UpdateUserRequest.idempotencyToken(), firstName: String? = nil, lastName: String? = nil, type: UserType? = nil, userId: String) {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.clientToken = clientToken
            self.firstName = firstName
            self.lastName = lastName
            self.type = type
            self.userId = userId
        }

        public func validate(name: String) throws {
            try self.validate(self.apiAccessPrincipalArn, name: "apiAccessPrincipalArn", parent: name, max: 2048)
            try self.validate(self.apiAccessPrincipalArn, name: "apiAccessPrincipalArn", parent: name, min: 20)
            try self.validate(self.apiAccessPrincipalArn, name: "apiAccessPrincipalArn", parent: name, pattern: "^arn:aws[a-z\\-]*:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$")
            try self.validate(self.clientToken, name: "clientToken", parent: name, max: 128)
            try self.validate(self.clientToken, name: "clientToken", parent: name, min: 1)
            try self.validate(self.clientToken, name: "clientToken", parent: name, pattern: "\\S")
            try self.validate(self.firstName, name: "firstName", parent: name, max: 50)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.validate(self.firstName, name: "firstName", parent: name, pattern: "\\S")
            try self.validate(self.lastName, name: "lastName", parent: name, max: 50)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.validate(self.lastName, name: "lastName", parent: name, pattern: "\\S")
            try self.validate(self.userId, name: "userId", parent: name, max: 26)
            try self.validate(self.userId, name: "userId", parent: name, min: 1)
            try self.validate(self.userId, name: "userId", parent: name, pattern: "\\S")
        }

        private enum CodingKeys: String, CodingKey {
            case apiAccess
            case apiAccessPrincipalArn
            case clientToken
            case firstName
            case lastName
            case type
        }
    }

    public struct UpdateUserResponse: AWSDecodableShape {
        /// The unique identifier of the updated user account.
        public let userId: String?

        public init(userId: String? = nil) {
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case userId
        }
    }

    public struct User: AWSDecodableShape {
        /// Indicates whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.    ENABLED – The user has permissions to use the APIs.    DISABLED – The user does not have permissions to use any APIs.
        public let apiAccess: ApiAccess?
        /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
        public let apiAccessPrincipalArn: String?
        /// The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds.
        public let createTime: Int64?
        /// The email address of the user. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.
        public let emailAddress: String?
        /// The first name of the user.
        public let firstName: String?
        /// Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.
        public let lastDisabledTime: Int64?
        ///  Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds.
        public let lastEnabledTime: Int64?
        /// Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds.
        public let lastLoginTime: Int64?
        /// Describes the last time the user account was updated. The value is determined as epoch time in milliseconds.
        public let lastModifiedTime: Int64?
        ///  The last name of the user.
        public let lastName: String?
        /// The current status of the user account.     CREATING – The user account creation is in progress.    ENABLED – The user account is created and is currently active.    DISABLED – The user account is currently inactive.
        public let status: UserStatus?
        ///  Indicates the type of user.    SUPER_USER – A user with permission to all the functionality and data in FinSpace.    APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public let type: UserType?
        /// The unique identifier for the user.
        public let userId: String?

        public init(apiAccess: ApiAccess? = nil, apiAccessPrincipalArn: String? = nil, createTime: Int64? = nil, emailAddress: String? = nil, firstName: String? = nil, lastDisabledTime: Int64? = nil, lastEnabledTime: Int64? = nil, lastLoginTime: Int64? = nil, lastModifiedTime: Int64? = nil, lastName: String? = nil, status: UserStatus? = nil, type: UserType? = nil, userId: String? = nil) {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.createTime = createTime
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastDisabledTime = lastDisabledTime
            self.lastEnabledTime = lastEnabledTime
            self.lastLoginTime = lastLoginTime
            self.lastModifiedTime = lastModifiedTime
            self.lastName = lastName
            self.status = status
            self.type = type
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case apiAccess
            case apiAccessPrincipalArn
            case createTime
            case emailAddress
            case firstName
            case lastDisabledTime
            case lastEnabledTime
            case lastLoginTime
            case lastModifiedTime
            case lastName
            case status
            case type
            case userId
        }
    }

    public struct UserByPermissionGroup: AWSDecodableShape {
        /// Indicates whether the user can access FinSpace API operations.    ENABLED – The user has permissions to use the API operations.    DISABLED –  The user does not have permissions to use any API operations.
        public let apiAccess: ApiAccess?
        /// The IAM ARN identifier that is attached to FinSpace API calls.
        public let apiAccessPrincipalArn: String?
        /// The email address of the user. The email address serves as a unique identifier for each user and cannot be changed after it's created.
        public let emailAddress: String?
        /// The first name of the user.
        public let firstName: String?
        /// The last name of the user.
        public let lastName: String?
        /// Indicates the status of the user account within a permission group.    ADDITION_IN_PROGRESS – The user account is currently being added to the permission group.    ADDITION_SUCCESS – The user account is successfully added to the permission group.    REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public let membershipStatus: PermissionGroupMembershipStatus?
        /// The current status of the user account.     CREATING – The user account creation is in progress.    ENABLED – The user account is created and is currently active.    DISABLED – The user account is currently inactive.
        public let status: UserStatus?
        ///  Indicates the type of user.    SUPER_USER – A user with permission to all the functionality and data in FinSpace.    APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public let type: UserType?
        /// The unique identifier for the user.
        public let userId: String?

        public init(apiAccess: ApiAccess? = nil, apiAccessPrincipalArn: String? = nil, emailAddress: String? = nil, firstName: String? = nil, lastName: String? = nil, membershipStatus: PermissionGroupMembershipStatus? = nil, status: UserStatus? = nil, type: UserType? = nil, userId: String? = nil) {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
            self.membershipStatus = membershipStatus
            self.status = status
            self.type = type
            self.userId = userId
        }

        private enum CodingKeys: String, CodingKey {
            case apiAccess
            case apiAccessPrincipalArn
            case emailAddress
            case firstName
            case lastName
            case membershipStatus
            case status
            case type
            case userId
        }
    }
}

// MARK: - Errors

/// Error enum for FinspaceData
public struct FinspaceDataErrorType: AWSErrorType {
    enum Code: String {
        case accessDeniedException = "AccessDeniedException"
        case conflictException = "ConflictException"
        case internalServerException = "InternalServerException"
        case limitExceededException = "LimitExceededException"
        case resourceNotFoundException = "ResourceNotFoundException"
        case throttlingException = "ThrottlingException"
        case validationException = "ValidationException"
    }

    private let error: Code
    public let context: AWSErrorContext?

    /// initialize FinspaceData
    public init?(errorCode: String, context: AWSErrorContext) {
        guard let error = Code(rawValue: errorCode) else { return nil }
        self.error = error
        self.context = context
    }

    internal init(_ error: Code) {
        self.error = error
        self.context = nil
    }

    /// return error code string
    public var errorCode: String { self.error.rawValue }

    /// You do not have sufficient access to perform this action.
    public static var accessDeniedException: Self { .init(.accessDeniedException) }
    /// The request conflicts with an existing resource.
    public static var conflictException: Self { .init(.conflictException) }
    /// The request processing has failed because of an unknown error, exception or failure.
    public static var internalServerException: Self { .init(.internalServerException) }
    /// A limit has exceeded.
    public static var limitExceededException: Self { .init(.limitExceededException) }
    /// One or more resources can&#39;t be found.
    public static var resourceNotFoundException: Self { .init(.resourceNotFoundException) }
    /// The request was denied due to request throttling.
    public static var throttlingException: Self { .init(.throttlingException) }
    /// The input fails to satisfy the constraints specified by an AWS service.
    public static var validationException: Self { .init(.validationException) }
}

extension FinspaceDataErrorType: Equatable {
    public static func == (lhs: FinspaceDataErrorType, rhs: FinspaceDataErrorType) -> Bool {
        lhs.error == rhs.error
    }
}

extension FinspaceDataErrorType: CustomStringConvertible {
    public var description: String {
        return "\(self.error.rawValue): \(self.message ?? "")"
    }
}
