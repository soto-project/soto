//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import SotoCore

// MARK: Paginators

extension AutoScaling {
    ///  Gets information about the Auto Scaling groups in the account and Region. This operation returns information about instances in Auto Scaling groups. To retrieve information about the instances in a warm pool, you must call the DescribeWarmPool API.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAutoScalingGroupsPaginator<Result>(
        _ input: AutoScalingGroupNamesType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, AutoScalingGroupsType, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAutoScalingGroups,
            inputKey: \AutoScalingGroupNamesType.nextToken,
            outputKey: \AutoScalingGroupsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAutoScalingGroupsPaginator(
        _ input: AutoScalingGroupNamesType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (AutoScalingGroupsType, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAutoScalingGroups,
            inputKey: \AutoScalingGroupNamesType.nextToken,
            outputKey: \AutoScalingGroupsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the Auto Scaling instances in the account and Region.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeAutoScalingInstancesPaginator<Result>(
        _ input: DescribeAutoScalingInstancesType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, AutoScalingInstancesType, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeAutoScalingInstances,
            inputKey: \DescribeAutoScalingInstancesType.nextToken,
            outputKey: \AutoScalingInstancesType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeAutoScalingInstancesPaginator(
        _ input: DescribeAutoScalingInstancesType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (AutoScalingInstancesType, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeAutoScalingInstances,
            inputKey: \DescribeAutoScalingInstancesType.nextToken,
            outputKey: \AutoScalingInstancesType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the launch configurations in the account and Region.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeLaunchConfigurationsPaginator<Result>(
        _ input: LaunchConfigurationNamesType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, LaunchConfigurationsType, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeLaunchConfigurations,
            inputKey: \LaunchConfigurationNamesType.nextToken,
            outputKey: \LaunchConfigurationsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeLaunchConfigurationsPaginator(
        _ input: LaunchConfigurationNamesType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (LaunchConfigurationsType, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeLaunchConfigurations,
            inputKey: \LaunchConfigurationNamesType.nextToken,
            outputKey: \LaunchConfigurationsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the Amazon SNS notifications that are configured for one or more Auto Scaling groups.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeNotificationConfigurationsPaginator<Result>(
        _ input: DescribeNotificationConfigurationsType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, DescribeNotificationConfigurationsAnswer, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeNotificationConfigurations,
            inputKey: \DescribeNotificationConfigurationsType.nextToken,
            outputKey: \DescribeNotificationConfigurationsAnswer.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeNotificationConfigurationsPaginator(
        _ input: DescribeNotificationConfigurationsType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (DescribeNotificationConfigurationsAnswer, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeNotificationConfigurations,
            inputKey: \DescribeNotificationConfigurationsType.nextToken,
            outputKey: \DescribeNotificationConfigurationsAnswer.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the scaling policies in the account and Region.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describePoliciesPaginator<Result>(
        _ input: DescribePoliciesType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, PoliciesType, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describePolicies,
            inputKey: \DescribePoliciesType.nextToken,
            outputKey: \PoliciesType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describePoliciesPaginator(
        _ input: DescribePoliciesType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (PoliciesType, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describePolicies,
            inputKey: \DescribePoliciesType.nextToken,
            outputKey: \PoliciesType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the scaling activities in the account and Region. When scaling events occur, you see a record of the scaling activity in the scaling activities. For more information, see Verifying a scaling activity for an Auto Scaling group in the Amazon EC2 Auto Scaling User Guide. If the scaling event succeeds, the value of the StatusCode element in the response is Successful. If an attempt to launch instances failed, the StatusCode value is Failed or Cancelled and the StatusMessage element in the response indicates the cause of the failure. For help interpreting the StatusMessage, see Troubleshooting Amazon EC2 Auto Scaling in the Amazon EC2 Auto Scaling User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeScalingActivitiesPaginator<Result>(
        _ input: DescribeScalingActivitiesType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ActivitiesType, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeScalingActivities,
            inputKey: \DescribeScalingActivitiesType.nextToken,
            outputKey: \ActivitiesType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeScalingActivitiesPaginator(
        _ input: DescribeScalingActivitiesType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ActivitiesType, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeScalingActivities,
            inputKey: \DescribeScalingActivitiesType.nextToken,
            outputKey: \ActivitiesType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Gets information about the scheduled actions that haven't run or that have not reached their end time. To describe the scaling activities for scheduled actions that have already run, call the DescribeScalingActivities API.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeScheduledActionsPaginator<Result>(
        _ input: DescribeScheduledActionsType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, ScheduledActionsType, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeScheduledActions,
            inputKey: \DescribeScheduledActionsType.nextToken,
            outputKey: \ScheduledActionsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeScheduledActionsPaginator(
        _ input: DescribeScheduledActionsType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (ScheduledActionsType, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeScheduledActions,
            inputKey: \DescribeScheduledActionsType.nextToken,
            outputKey: \ScheduledActionsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    ///  Describes the specified tags. You can use filters to limit the results. For example, you can query for the tags for a specific Auto Scaling group. You can specify multiple values for a filter. A tag must match at least one of the specified values for it to be included in the results. You can also specify multiple filters. The result includes information for a particular tag only if it matches all the filters. If there's no match, no special message is returned. For more information, see Tagging Auto Scaling groups and instances in the Amazon EC2 Auto Scaling User Guide.
    ///
    /// Provide paginated results to closure `onPage` for it to combine them into one result.
    /// This works in a similar manner to `Array.reduce<Result>(_:_:) -> Result`.
    ///
    /// Parameters:
    ///   - input: Input for request
    ///   - initialValue: The value to use as the initial accumulating value. `initialValue` is passed to `onPage` the first time it is called.
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each paginated response. It combines an accumulating result with the contents of response. This combined result is then returned
    ///         along with a boolean indicating if the paginate operation should continue.
    public func describeTagsPaginator<Result>(
        _ input: DescribeTagsType,
        _ initialValue: Result,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (Result, TagsType, EventLoop) -> EventLoopFuture<(Bool, Result)>
    ) -> EventLoopFuture<Result> {
        return client.paginate(
            input: input,
            initialValue: initialValue,
            command: describeTags,
            inputKey: \DescribeTagsType.nextToken,
            outputKey: \TagsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }

    /// Provide paginated results to closure `onPage`.
    ///
    /// - Parameters:
    ///   - input: Input for request
    ///   - logger: Logger used for logging output
    ///   - eventLoop: EventLoop to run this process on
    ///   - onPage: closure called with each block of entries. Returns boolean indicating whether we should continue.
    public func describeTagsPaginator(
        _ input: DescribeTagsType,
        logger: Logger = AWSClient.loggingDisabled,
        on eventLoop: EventLoop? = nil,
        onPage: @escaping (TagsType, EventLoop) -> EventLoopFuture<Bool>
    ) -> EventLoopFuture<Void> {
        return client.paginate(
            input: input,
            command: describeTags,
            inputKey: \DescribeTagsType.nextToken,
            outputKey: \TagsType.nextToken,
            on: eventLoop,
            onPage: onPage
        )
    }
}

extension AutoScaling.AutoScalingGroupNamesType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.AutoScalingGroupNamesType {
        return .init(
            autoScalingGroupNames: self.autoScalingGroupNames,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension AutoScaling.DescribeAutoScalingInstancesType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.DescribeAutoScalingInstancesType {
        return .init(
            instanceIds: self.instanceIds,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension AutoScaling.LaunchConfigurationNamesType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.LaunchConfigurationNamesType {
        return .init(
            launchConfigurationNames: self.launchConfigurationNames,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension AutoScaling.DescribeNotificationConfigurationsType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.DescribeNotificationConfigurationsType {
        return .init(
            autoScalingGroupNames: self.autoScalingGroupNames,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension AutoScaling.DescribePoliciesType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.DescribePoliciesType {
        return .init(
            autoScalingGroupName: self.autoScalingGroupName,
            maxRecords: self.maxRecords,
            nextToken: token,
            policyNames: self.policyNames,
            policyTypes: self.policyTypes
        )
    }
}

extension AutoScaling.DescribeScalingActivitiesType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.DescribeScalingActivitiesType {
        return .init(
            activityIds: self.activityIds,
            autoScalingGroupName: self.autoScalingGroupName,
            includeDeletedGroups: self.includeDeletedGroups,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}

extension AutoScaling.DescribeScheduledActionsType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.DescribeScheduledActionsType {
        return .init(
            autoScalingGroupName: self.autoScalingGroupName,
            endTime: self.endTime,
            maxRecords: self.maxRecords,
            nextToken: token,
            scheduledActionNames: self.scheduledActionNames,
            startTime: self.startTime
        )
    }
}

extension AutoScaling.DescribeTagsType: AWSPaginateToken {
    public func usingPaginationToken(_ token: String) -> AutoScaling.DescribeTagsType {
        return .init(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )
    }
}
